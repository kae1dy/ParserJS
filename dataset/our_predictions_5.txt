Is this order guaranteed, ie ls-refs before fetch?
shouldn't you clear out restartToken and lastPackId at the start? The way you are using class variables is error prone. Any thing that should be remembered across sessions should be stored in the Session, otherwise pass the information as arguments. This will require you to create some helper types to hold data e.g. a Header class with two fields, restartToken and lastPackId. This does not apply to in and out, since they are used everywhere.
Move to a separate file? UploadPack.java is getting pretty big...
Define a string constant for this?
What happens to other client capabilities? Could make sense to have an explicit 'else', like } else { // Unrecognized capability. Ignore it. }
This is really minor, but could you use Path api here? As it will return better error message than File will. giving some context on what is going on...
Could this relatively general code be reused in the needsOrderBy method?
in all these OseeArgumentException constructors, you don't need to use String.format, it does that for you.
I have seen cases where a Throwable will return this for getCause() which can cause infinite loops in code like this. I think you want:  java while (true) { Throwable cause = root.getCause(); if (cause == null || cause == root) { return root; } root = cause; }  as a result instead.
It's not public, it can be changed. We need to have it backward compatible for one minor version. If this is to be released as 3.9.4-c1, MC 3.9.x and MC 3.10.x needs to be able to work with this. You can add extra fields which we will use in an upcoming MC 3.10.x release. Removing the field needs to be delayed until HZ 3.11 where we can adjust the codebase to not expect the field.
throw an exception? this is not intended to use.
Symmetry (throw)?
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
@fanifieiev the same above.
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
Here is also that unusual check.
Using a boolean as abort condition for the parsers main while loop is also a deprecated pattern. Instead replace this line with outerloop: while(true) {.
Should use nextTag() and switch-case instead.
use labeled loop instead
Should use nextTag() and switch-case instead.
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
same as above... why not use simple if/else here?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Can make this into a singleton as we have with UNSET.
Strings would be better to be stored in a constant
I see this duplicated in a lot of tests, maybe we should put it in it's own utility function?
Hello~ The classes in jars in extensions directory are loaded by URLClassloader, but the KafkaProducer here use the appClassLoader to load classes in org.apache.kafka.common.config.ConfigDef parseType() and this lead to org.apache.kafka.common.config.ConfigException. That is the problem I got. I found some code in KafkaIndexTask, in method newConsumer() such as:  ClassLoader currCtxCl = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); // ignore some code ... }finally { Thread.currentThread().setContextClassLoader(currCtxCl); }  This can solve the my problem. May I ask have you encounter this problem?
Should we assert a string valued parameter too?
No need to configure the deserializers since we inject them explicitly.
Maybe relate those hardcoded strings to the enum above?
shouldn't be setDaemon(true)
Nit: I would like this broken up into multiple statements so we can tell where it breaks if we get an NPE.
Enclose in if (log.isInfoEnabled())
Can it be null?
ACCESS_CONSENT_ATTR and INST_ACCESS_CONSENT_ATTR are defined in both SamlConstants and NhincConstants. Remove from NhincConstants.
Consider to use StringUtils.hasLength(str) to check
rename the method to createResourceIdAttributeStatements
why not just return it directly?
Consider to move into constant variable into SAMLConstant
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Why going for semantic here ??
Should we handle StatusPart separately?
Please, respect surrounding code style (() {).
This should be object Id, and it would be different from StorageId if it's not root directory. Could you check it for sub-directory case?
Maybe not needed? We don't have to check if a target process definition exists in the source container.
are we not covering this when we do the merge?
This could be written as if (!invoked)
This can be initialized to new ArrayList<>(plan.getEvaluatorsToAdd().size())
Typo, "by" should be "but".
nit: create static variable for this empty set and return that static variable
return Collections.emptyList();
Check that the RyaStatement and Config are not null.
Could be final?
Check that stmts is not null
ERR_DELETE_ERROR, add if there isn't one already
Possible NPE here in case of default constructor. Let's mark the 'log' field as 'final' and initialize it in default constructor.
Consider a streaming implementation: final Optional<List<Rule>> match = rules.entrySet().stream() .filter(e -> e.getKey().includes(length)) .map(Map.Entry::getValue) .findFirst(); return match.isPresent() ? match.get() : null; Not much clearer, but any time I can avoid declaring Map.Entry<A, B> that's reason enough.
Are we sure that we can never have e.getValue() == null ?
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
Out of interest why can you not do DecisionTableOrientation.values()?
At present, we try to avoid use of the keyword final as per our [POLICIES](<LINK_0>
map - confusing name
Does it actually fail if the expansion path is not recognized? In a normal situation I know it fails silently, returning the query results as nothing happened, so it wouldn't fail. But as it's wrapped in this VrapRequestDecorator maybe it's checking it against the RAML specification?
@katmatt i'm not sure you are right person to ask, but at least you could refer me someone else. My question is: don't we want to update assertJ dependency from currently used _3.3.0_ to the latest _3.8.0_, it is 1.5 years since that version and now it has a lot of handy tools, like arrays comparing (including ordered or unordered).
in what scenario path list will be empty with copy error set to true ?
This is File copy error not file system retry case.
switch them. checking boolean is faster than checking isMaster
should be tied in to the FileSystem instance lifecycle too: an FS instance should really have a weak ref to all leases created under it, and fs.close to stop them all
Peter B. said in different commit <LINK_0> that this exception is not thrown for jdbc.query and you said he is right. So there is probably the same problem in every method with jdbc.query.
No need to log here: return binary.getLong();
We try to avoid returning null to express absence. Could this method be refactored to return an Optional<URI>?
What about l < Integer.MIN_VALUE?
I prefer ", not "+(l == null ? null : l.getClass()));
do we want to assertFieldCountEquals here?
no need to specify type on RHS
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
Or maybe:  for(String s : mc) { managedCache.add(getNewMBeanProxy(mbsc.getSecond(), MANAGED_CACHE + s, ManagedCacheMBean.class)); }
Local variable could be declared List instead of ArrayList. Is this worth caching?
check to make sure notificationUUID is not null
This should check to make sure that notificationUUID is not null before attempting to delete it.
It doesn't look like you are doing anything with the bucket here. This can be removed.
Minor typo in first sentence of error message.
Missing final
static
nit: might be clearer as: return involvedTables.stream().anyMatch(this::isValidationNecessary)
Was thinking about collisions here, <LINK_0>, theres about ~1% probability of collision in 10k tables, but we are fine I think (except for the large internal product that is creating and truncating tables). We can take a 16 character substring?
Could we change the message to something like - "Can only read from a table with a no/conservative sweep strategy in a read only transaction." ?
This seems like a good behavior change, though it might affect our big internal product. Especially when serializable transactions are in the mix, we should not allow reads during the commit step.
Agh code duplication! But I don't see a simple way around it. I was thinking about some fancy Java 8 streaming thing, but it's not trivial.
Two TimeAndDims might have dims of different length so I think this could cause an out of bounds array access on that.dims[i]. This also doesn't check types at all but the Comparator for sorted facts does check types. The equals impl could do return dimsComparator.compare(this, that) == 0 although this does some needless name lookups.
Did you mean --i?
IMO it's more obvious what is happening to put for (int i = 1; i <= 4; i++) {
suggestion if (castSource.toLowerCase().startsWith(clobReturningFunctions[i])) {
Seems like there's a spacing issue here, two spaces instead of 4.
Normally, a 'validate' method should return true in case of success, and false if validation failed.
I'm probably missing something, but it seems like this is part of the next case (isn't queue.size() >= 0 an invariant?). Is this called out just to emphasize that setting 0 => "no queuing"?
if static, should be initialized outside the ctor.. maybe make it final static.
This seems wrong
do the comparison the other way around
JDBC
there is an 'n' missing at the end of 'pattern'.
"PasswordController.NewLicenseKey" ->"LicenseKeyController.NewLicenseKey" is better
vmIsDown() == true than vmIsUnlocked() == true vmIsDown() == false than vmIsUnlocked() will not be checked.
Because it can be called by both focusGained and mouseEnter, sometimes you have two active contexts. Maybe there should be only one?
<LINK_0> Let me know if you have any issues managing or adding items to the project
This seems like something the client would want access to, "request a new full page of cards".
Rename into addEditLink, as that is what's added.
Should other contracts should be singletons, too? If so, could you create a separate pull request that makes that change?
You don't need this line because of green 31.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
why was this done?
During rebase, just pass a new ArrayList() to IsVmfree no need for variable
I would move the value-provider to the outside of the loop. Then we make the type check only once.  java final java.util.Map<K, Collection<V>> javaMap = new java.util.HashMap<>(); final Supplier<Collection<V>> javaContainerSupplier; if (containerType == SEQ) { javaContainerSupplier = java.util.ArrayList::new; } else if (containerType == SET) { javaContainerSupplier = java.util.HashSet::new; } else if (containerType == SORTED_SET) { javaContainerSupplier = java.util.TreeSet::new; } else { throw new IllegalStateException("Unknown ContainerType: " + containerType); } for (Tuple2<K, V> t : this) { javaMap.computeIfAbsent(t._1, k -> javaContainerSupplier.get()).add(t._2); } return javaMap;  Don't know if the throw is possible there or if the compiler will complain that javaContainerSupplier is uninitialized. If so, we could create a private method getJavaContainerSupplier()...
Yes, polymorphism is what you want. instanceof generally is a last-resort kind of solution. Here you're in charge of the design so you can easily avoid it by adding another level to your hierarchy.
Please keep this.cell near the related fields (previousFamily & cell count) below
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
have a default constructor with reasonable default values
The responsebody annotation can be removed, because the class is annotated with RestController. suggestion public Promise<CodeSystems> searchByGet(final CodeSystemRestSearch params) {
I'm almost tending to use VRaptor specific exceptions for this case, instead of reusing IllegalArg and IllegalState... We're doing this only because of validations, right? We could create a ValidationFailedException.
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
Should this use a parameterized message? java logger.warning("Connection exception encountered: {}", exception);  Right now this will likely log the exception message twice.
nit: not sure why this method called generateSendFailure. Should this be renamed to handleSendFailure?
this.redisTemplate
Nit-pick for the variable name. It is really not file, so just entry would be good. The new HashMap() is bad code too. Must be with generics
Should add the rule to config file?
We have a removeConfiguration so let's not allow null value here?
space
can't be null?
Hi, I am currently evaluating exception aggregation tools and so far bugsnag seems to be the most promising for my needs. Especially with a logback extension, which is why I am following your pull request. Here at this line you might consider making the initialization of the UncaughtExceptionHandler, which is implicitly done through the constructor, configurable. In my use-case for example I am running a centralised logging server which is reading log events from sockets and writing them to files as well as to an exception aggregation tool. In this context a global exception handler may not be wanted/needed.
Isn't it enough to declare Exception here? An exception will fail the test, regardless of the specific type.
Maybe IOException since it's supported here?
You have to run this thread before the call to sever.serve() because that method is blocking.
Why the sub string ?
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Can we change this to LOGGER.INFO
You might want to not over-complicate it and keep the toString of the Optional perhaps?
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
This filter lead to me to look at the factory again and ask about why/where the exception would be thrown! It seems strange that a factory could NOT return a concrete object.
filter(Objects::nonNull)
this.
You can use CollectionUtils.toImmutableList
Can be deleted since apis was used by ViewEnhancer.
Should this be String.valueOf or is cnn the way to go?
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
ConfigurationImpl_toString = Node configuration: {0}\nEdge configuration: {1} MessageFormat.format(Messages.ConfigurationImpl_toString, nodeConfiguration, edgeConfiguration);
Something to think about: if all of the DataModel types have a specific view type, then you could add an additional generic parameter to MockChartDataModel for the view type in addition to the dataset. This would allow you to move the view field up to the superclass.
this part should be factored out because it is used in several overrides.
I think pNode.getClass() doesn't have to be in the loop, you can move to above and return empty is the condition is true
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
I would suggest moving pNode.getClass() == PointNode.class before the for loop
Why going for semantic here ??
!(parent instanceof MGenericStack) || parent.getSelectedElement() == part
See above about checking the labels
See above about checking the labels
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
I am not following here - why do we want this in sync block?
I'm almost certain that this is intrinsically checked by the tracker since things are only captured for spawning if the spawn events are being listened to.
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
nit: we don't do this (argument alignment) throughout the project, any reason to start with this method?
Yeah, here's where I was thinking of using our custom exceptions. IdpResponse.fromError(...)
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
Is there any purpose to remove temporary workspaces on shutdown if you do it on boostrap? It looks like they should removed either on shutdown or on bootstrap.
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
what about setting db isolation level to serialization?
Shouldn't have printStackTrace() in production code switch to logging.
We should set connection and socket timeouts here. By default there are no timeouts, so in case of network problems this may hang forever, which is pretty long. ;-)
The duplicate close looks strange to me. I think @rmetzger gave a nice idea above. You can just catch and log the error and move each close in a separate try block. You can take org.apache.flink.connector.hbase.sink.HBaseSinkFunction#close as an example. That will be much clean.
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Please replace that 1 by a constant indicating what it is.
final
why rewind?
I know this code was just moved from elsewhere, but is 10 meaningful here ? Although harmless, it seems like random over-allocation by half. Is there any way possible this can use more than the max possible # of bytes in an ITF8 encoding for an int, which is 5?. Can this use the new MAX_BYTES constant ?
Make this a typed exception (e.g. PlatformServicesException)
Remove stack traces
can you change this method to call your new method instead? Make sure to pass 5 seconds as the timeout to not change the meaning of this function.
Log the full exception here as well, this should be fixed in entire PR.
Does the JSONObject type need to be fully qualified here?
Why does this need to be ordered by the synthetic primary key?
Possible copy/paste bug in the order by clause.
Lists obtained from a message are immutable. No need for extra copying.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Shouldn't this close the iterator before returning the list?
Was seconds an intentional omission here?
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
Creating new instances of SimpleDateFormat is expensive. Formatting dates using that is expensive too. Can't make it static because it's not thread safe either. Consider using a static instance of org.joda.time.format.DateTimeFormatter instead.
make it a static method?
Hash code
Can an ArrayValue ever equal something which is not another array and thus an instance of SequenceValue? I would assume that this row always returns false.
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
This is another one that might cause problems. @lbergelson you've done a lot of refactoring to pull interval/region-like methods out into a single class; do you see changing Interval.equals() to not accept subclasses?
we don't need to check other == null here, the next condition check covers it.
Please store these values in a static variable, such as ASSISTANT_USERNAME :smile:
I would rather rewrite the assert to check the full URL or to chack whether the URL contains the name. Just removing the check is a bit hackish
@mcivantos-tribalyte _successCallback_ has changed in another commit, you need to update this to: _(WorkspaceProject project) -> successCallback.execute(project)_
The list will be filled with all models which had to be registered. These should be unregistered once you no longer need them.
unsubscribe()
no need to create a set here..
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
again - encapsulation
I don't think we need to check for null here. We can just have Precondition.checkNotNull, since none of the instances where this is called would have a null query.
Maybe it's just me, but I would find a simple if-else clause more readable.
this part looks similiar to #validateAuthenticationState consider extracting the common code into a shared method
Could call the method addCookie(String domain,....) instead.
return immediately, no need to store it in a local var
Surely this can be done better using streaming cookies.stream.filter(cookie != null && CommonHelper.equals...).findFirst() This will return an Optional directly, or empty.
fail
same as others: log should have Exception as arg
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
Either catch NPE only or add Exceptions.propagateIfFatal.
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
null or empty list?
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
ahh, here it is
UnsupportedOperationException would be better
getRecords() is marked as @NotNull, and then returns null here. Something like throwing an UnsupportedOperationException would be better/clearer too.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Can this be private (or at least package protected)? It's only used by this class.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Can this be private (or at least package protected)? It's only used by this class.
Preferably have one call the other?
I'd put notEmpty there
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
can you pull this from a static string?
This looks like a good candidate for doing ImmutableMap.of(Maps.transformEntries(...)).
please apply formatting
This can be a bit cleaner with Java8 streams: return getPluginProviderRegistry().entrySet().stream().collect( Collectors.toMap( Entry::getKey, e -> e.getValue().createLocalFileIngestPlugin(e.getValue().createOptionsInstances())));
Should this result in all active connections being discarded? During runtime this may happen if the configuration is cleared by the config admin. disclaimer: I have only moderate knowledge about OSGi and this is more of an assumption.
can be simplier: showing empty array even if the value is null is not really a big deal imo. Also, toString are usually only used for logger..
you don't need this. the "+" operator does this for you.
since host_name can be ugly fqdn or ip i think it would be nice to print vds_name as well
We should use StringBuilder here.
String.valueOf(...)? Or TBH, I'm pretty sure the compiler does this for you if you just inline everything like so: java return "PageKey{" + "StartAfter=" + mStartAfter.getId() + ", EndBefore=" + mEndBefore.getId() + '}';
recordCount++; doesn't work?
grammar nit: 1, not one, and no :
I would really like to optimize, but having another sorted data structure would cost more than just having iterative approach
Synchronisation could be avoided in this method using computeIfAbsent and AtomicInteger, but not sure if it is worth changing at this point because I don't know the performance impact that full synchronisation is having.
Here you could use Guava's [checkArgument](<LINK_0>,%20java.lang.Object%29)
Should use StatusHandler.log() instead
:astonished:
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
throw exception
With Timber exceptions are the first argument. Format string arguments go at the end.
Could you check for null or empty? Via StringUtils.isBlank
Oh please, no! Don't ship a null object! :cry:
Symmetry (throw)?
can these parameters be grouped into smaller and more meaningful objects?
Same here: The new flag withAttempts is not passed (used) the paymentProcessor#getAccountPayments
rm 99
Constant
IMO, urlInitialized check here is redundant. I"m not sure how can you get to this point with urlInitialized=false. (And if it is false- don't you want to return?)
simplify this
rlly nit-picky: would turn that around from: is our location precise and do we actually have one to do we have a location and is it precise
Same concern here. true looks wrong.
mapping may be null at this point
Only 'wrapTextFlag' is needed
This should check whether the current contentType is an instance of the target content type, using isKindOf or looking at the baseType too. See FilePropertyTester for instance.
this seems too limiting IMO. could be any kind of local ip or host and still work perfectly. The only known issue is NPE when no matching server/proxy and the openshift redirect. I say we keep this patch simple and fix just the NPE - ssh redirect issue can be known limitation.
i would split this line into two for better readability. also gameUser.getAchievements() could be puted to variable
put call of this method to appropriate place in each method that requires it
why not null as value?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
throws TaskException is part of the interface, did you mean to remove it?
@Serranya The same here. See above.
@Serranya The same here. See above.
@Serranya Please, add the name "body content" into the message to be more clear and specific. It's too much generic.
@Serranya The same here. See above.
@Serranya Please, use Cactoos' TempFile instead of this method.
2xx
@mavrk I think you mixed tabs and whitespaces in the description.setConcept(this) line. in OpenMRS we use tabs. Please remove your whitespaces.
don't need the else here. Too bad java doesn't have XOR :)
Can you convert this into using a ternary operator?  this.diagnosticsLogs = stdOut ? new DiagnosticsStdout(this) : new DiagnosticsLogFile(this);  It makes the code less verbose.
warn seems too relaxing for this kind of exception. maybe error?
You should use ThreadContext.putAll() here.
minor, is it method scope for Visible For Testing? If not please change it to private.
Unnecessary (and incompatible); revert.
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
I think it might be easier to create a list and compare that?
Actually this should fail, because the input isn't a list of strings, and the type of "properties" is "String[]".
This could use Collections.singletonList
As for the previous tests, the two assetions above can be removed I think. But I'm happy to open a new issue for that if you prefer That applies for all the other tests below as well
Hmm you're right, there's not a great way to do this. Up to you, feel free to do nothing but a couple suggestions a. A quick google search revealed: @FixMethodOrder(MethodSorters.NAME_ASCENDING) b. a variant on your first example @test public void testResetA() { checkOrSetInstance(); } @test public void testResetB() { checkOrSetInstance(); } public void checkOrSetInstance(() { if (sShadow != null) { sShadow = getAccessibilityManagerInstance(); } else { assertNotEquals(sShadow, getAccessibilityManagerInstance()); } }
same as above... why not use simple if/else here?
"No provider is registered for the service '" + service.getName() + "'", service" (this is the current errore message). Shouldn't this thrown a ProvisioningException ?
Same issue here. We should keep this as static if at all possible
I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
For readability sake, can these two increments use the same atomic method call?
similarly here, if this is general, I've lost updates...
computeIfAbsent?
check done
not thread safe
You can inject the header variable in this class too, to avoid dealing with static methods.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
suggestion
This could be set in the constructor instead of checking this on every request.
To remove?
Immutable?
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
format as final String[] array. Rename to errorMessage if possible
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
Please use networkClusters instead of getNetworkClusterList().getItems()
Both of these lines should be moved into corresponding methods calculating the desired state according to the two dependencies, as I described in another file.
This should be done with field declaration example:  java private Set<String> users = new HashSet<>()
what guarantees getParameters().getNetworkId()) represents a real network ?
Should be the opposite, the other addTextFilter method should call this one, using a default of false for disableFiltersInputHelps
so for IPv6 hosts when a machine is cloned this is going to break?
there is no need for using FQDN because only one Base64 is imported now
if that previews is showing cleaned-up code, why is this one still here?
This smells like an incompatible change.
This is invalid because it does not verify if rows vs range is in its default value. For instance, count(x) over (order by x RANGE between unbounded preceding and current row) returns different values depending on RANGE vs ROW
I continue to think that **aifc** should to be here...
Can use the already defined Constants
@Nadahar Right, text/vtt, i was too fast...my bad.
this method should probably be final. Also it is missing the @Override annotation AFAICT
Should maybe other countries be added here?
SetConfigurationObject should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetActivityCalendar should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetAdministrativeStatus should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetAlarmNotifications should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
Is there a reason not to use Util.TOLERANCE?
doing += on a Long object causes boxing every time. It'd be better to have sum be a "long", and return Long.valueOf(sum) at the end. Or simply return a long in this method.
why sink->getSink()?
Can be static.
This looks more like average absolute deviation then variance, please rename or change the implementation
This could be null, we should probably handle this if the JIRA api changes again
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
return tags;
Could we return an empty map instead of null so this method doesn't have to be @Nullable?
I don't see a test for this new method
Does it make sense to have this for a class that states it's "modified"?
Rename this local variable to gid as well, like the overall renaming you have done for lrecId.
Use SQLQuery#setString instead of StringEscapeUtils.
@essobedo once used variable can be inline
More accurate error message
Perhaps put the or else in the parameters. More useable  FpKit.findfirst(list, x -> isGood(x), otherwiseThis)  Could be a supplier to make it lazy  FpKit.findfirst(list, x -> isGood(x), () -> otherwiseThis)
Style issue: @Override shuld be on line above the method declaration
null? why not just a () -> {} ?
Why is it a list of lists, not just a list?
would this be called often, and would the list copy be expensive?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
I think you may be able to .put the added PartitionData into sessionPartitions up front, and capture the value returned by the .put, as it will return the previous value. If the previous value was null, then we add to added, if it was not null we add it to altered. This will save us the additional containsKey check.
I understand you're trying to emphasize the connection between the two methods, but calling this onPartitionsAssigned feels a little confusing in this class; on ConsumerRebalanceListener it is intended to convey some subscription/notification semantics that do not apply here. The same applies to onPartitionsRevoked and onRecordsReceived.
nit: not from this patch, but topicPartitionBookkeeper.topicPartitionBookkeeping is really annoying. Maybe we could rename the field to just partitions?
nit: we could use putIfAbsent here
Add check that non-null
is it at all possible to use standard URI building things here? Either hadoop FS path building or the java File and Path constructs?
The forbidden apis check is flagging an error here: > [ERROR] Forbidden method invocation: java.lang.String#matches(java.lang.String) [Use startsWith(), endsWith(), contains(), or compile and cache a Pattern explicitly] The regex also looks more complicated than necessary and is causing test failures: <LINK_0>  [ERROR] testIsTaskCurrent[numThreads = 1](org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest) Time elapsed: 0.142 s <<< ERROR! java.lang.IllegalArgumentException: dataSource cannot contain whitespace character. at com.google.common.base.Preconditions.checkArgument(Preconditions.java:125) at org.apache.druid.segment.indexing.DataSchema.validateDatasourceName(DataSchema.java:108) at org.apache.druid.segment.indexing.DataSchema.<init>(DataSchema.java:76) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.getDataSchema(KafkaSupervisorTest.java:3636) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.testIsTaskCurrent(KafkaSupervisorTest.java:3099)
suggestion LOG.error("Couldn't get datasource for myplaces");
why? let's format it properly, it was ok before. annotations and method definitions on different lines
if (realm != null) maybe - just to be safe.
Remove throws Exception
Is this really needed?
I don't think this is needed
Oh. I just saw this line. target1 and target are little weird. Maybe there are better names.
final
Most callers are assuming that this method returns a non-null DBCollection, so there's no point in having this check.
Can we make ObjectMapper instance static final and reuse it instead of new instance for each execution?
Cluster name should be also included in equals(Object) and hashCode() checks. The client pool is using this configuration object as a map key.
As Ryan mentioned, you may not want to implement locks like this on static methods. I'm guessing he is checking mappers for null in order to instantiate them only once, as well as set their SimpleDateFormat. Someone else can chime in, but one easy and simple way, while keeping the methods static, is to implement the default constructor with no arguments, then call a new static void method from the constructor called something like setMappers(). Inside setMappers() is where you would instantiate the mapper1 and mapper2 ObjectMapper instances. Then you can get rid of the null checks on the mappers, and instead just return them from their respective static get() methods.
minor: don't need this. qualifiers
String.format
I think this is unnecessary => "profile =" + this.profile is sufficient.
I don't think rendering a byte[] as a bunch of ints is useful, maybe omit this (or just include the length, perhaps).
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
bad name of method <LINK_0>
What's the thinking behind inverting values that are passed in?
we don't really use _ (underscore) prefx for any other variables. can you rename it to just 'e'
When this line throws new SQLException("Unsupported target SQL type: ..., it would be good to mention SQLType targetSqlType in the exc msg
Can you just read until you read less than 1024 bytes? It looks like you will call read again after reading less than 1024 bytes when there is nothing more to read.
Add a message. Without it, you just get a NullPointerException with no message. ie. "'containerName' cannot be null." Same with another usages of this.
It is not public API so don't worry about changing that, but we should get @alzimmermsft and / or @jianghaolu to review this to ensure that our builders always have a serviceVersion API and not version or any other naming convention.
should this be pipeline.executor?
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
should this be else if?
Seems like the previous tests should also assert on the length?
No reason to save chars here. I would strongly prefer dynamic
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "enforceNotNullNorEmpty" a "static" method. [![rule](<LINK_2>](<LINK_0>
There should not be a need to set this to public. Perhaps private would be better.
... that way when accessing them from the class we won't need to use "this." for example fString = string vs this.string = string
I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
A create card payment request should always have a return URL, so I don't think this should return an optional
this.
This should be an Optional<...> on the member by convention instead of wrapping on access. I realize this is against IDEA advice.
fileNameBytes is interpreted according to platform encoding. Give it a StandardCharsets.UTF_8 to pin it down.
EndOfStreamException is never thrown in this method, as far as I can see.
unnecessary else clause can be removed
I think it is fine to keep it together since it is so tightly coupled and it is just one exception.
return HConstants.EMPTY_BYTE_ARRAY; ?
Checking for test mode is fine, but maybe we should do it when this method is called, rather than in here -- the environment it's run in doesn't seem like a concern of this class.
We do not consider the whole resource, but only the selected elements (and their descendants). It should read "The selected elements do not contain".
These 2 methods have some overlapping logic with methods getFeedSLAMissPendingAlerts and getSLAStatus of FeedSLAMonitoringService. Please reuse those methods, so that the API and this service are in sync.
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
just one thing here - please add try {} catch(Exception), with proper logging, as if you will throw any exception from scheduled code, no more jobs will be ever scheduled. just a precaution. otherwise jobs will stop running and we will never know it occurred
And this change should be reverted as well.
Uses the varargs version
As we're down to one arg, just do:  return threadRecord.hashCode();
What is the reason for not including preferredHeight and preferredFps here? Looking at BitrateController#setVideoConstraints, I think it might fail to call update if the only thing that changed is the preferred height or FPS. Or is this on purpose?
can just be hash.hashcode()
This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though running == false. I think the only safe place to do the check is after creating the spliterator.
I'd use a different name, e.g. doStream
Missing types
We were going to avoid signatures like IgniteFunction<Stream<UpstreamEntry<K, V>>, Stream<UpstreamEntry<K, V>>>, right?
Missing types
Is this really sufficient to test your WCheckBoxWebElement? One check box is sufficient if it is exposed through a getter so the tests can set properties on it.
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
weight is missing from toString()
Add .omitNullValues() before the toString() call
"Clean orphans from PROPERTIES" to be exact ?
We should validate that's non-null (to fail sooner).
Why did we make this public?
Given that Void is imported in the file, is there any reason to use the package name prefix?
Which type would be assigned in this case?
you should name this thread and make it a daemon thread.
This should return an immutable collection.
Should not this method create a copy of the set just as getStages()?
The keySet is a view... So, the caller could run into a CME using the returned Set it the Map changes. Wouldn't it be better to return a new set created by the content of the view set?
This keyset is mutable and changes to the keyset will cause changes in the underlying map. See if you need to return a copy?
Are all reads/writes to correlationIdToPutChunk done by the main loop? What other threads touch PutOperation?
Do we want to use the platform's default charset when we read this from the database? I suggest we use a fix encoding here like UTF-8? suggestion return new String(licenseResource.getBytes(java.nio.charset.StandardCharsets.UTF_8));
Let's append java checkNotNull(event);  as the first line. EventsShould should have a "nullability check" test case (see other Spine tests for a sample).
We can also skip the query if the resourceId is *
Please, use spaces before and after +.
Do we want to use the platform's default charset when we store this in the database? I suggest we use a fix encoding here like UTF-8? suggestion key.setBytes(licenseKey.getBytes(java.nio.charset.StandardCharsets.UTF_8));
If the code fails to close in, it will never try to close out
for such change. If the code fails to close in, it will never try to close out
Perhaps try-with-resources? And there are also tabs here that could be fixed.
Could this be a single try-with-resources block with two resources and a single statement in the body?
how is this related to ignoring non-accessibility of ~/.gitconfig ?
I guess this will crash as well if getCompatibleOperatingSystems() returns null.
context.getClassLoader() can return null
suggestion return getChannel(context) != null;
can't you just use "scriptFile" instead of the second call to "huntForTheScriptFile"?
Don't open things up that don't have sufficient parameter validation, the @Nonnull is not enforced here because it was an internal method, so you'd need to add a Validate call here.
I keep seeing these checks everywhere that provider is not in SOCIAL_PROVIDERS. I think a positive assertion would be better. Like GENERIC_PROVIDERS.contaains(providerid)
Instead of relying on all the properties shouldn't we just rely on discoveryType? less confusion with if else logic and also while defining the descriptor.
Create a common function for checking the regex and compiling.
verify is probably more trendy
is  if((FIVE_PRIME_ADAPTER == null) != (THREE_PRIME_ADAPTER == null))  clearer/shorter?
You need to check that conceptUuid is not null and blank
When do you ever use the above service? And if you do, is it more than once?
Can we remove these empty new lines?
How to do ensure that by requesting .getConceptNameTagByName(null) for should return null if No concept nameTag is found?
would it be better to throw an UnsupportedOperationException rather than return something that won't work?
+ desc
...if you do not provide...
Missing NLS
Then we can use the name here to get a better description
_[...] on the JobManager_
I think this should be headers.get(name).
Map
just return "" instead of new String()
This part of the patch looks fine and can be merged, with the small correction mentioned below.
technically speaking... :) the user agent header value could be stored in a static field and not computed each time getDefaultHeaders() is called. I'm sure the performance difference is negligible, but I couldn't stop myself from mentioning it :)
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
Put into constant.
Doesn't this now need a @SuppressWarnings("unchecked") ? I think there are a couple of other places just like this.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
This should never be true. The spread should be computed in this case. Actually, it should always have the length of 96.
Do we really want to move this from trace to debug?
As a nit, should have a null guard here.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
We don't need a wrapping if - it is redundant by the reason of a constant for a message.
WRT to the changed logging, shouldn't this method return a success indication (boolean), so the caller could at least log one error message that the server is not running / listen?
@apc999 This needs to be public or reflection will not work
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
I don't know much about how the serialization code works, but is this supposed to be a 1, instead of a unique serial? I'm guessing it doesn't matter because these factories will not be serialized.
can you explain why this change ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
No need to use ConcurrentMap.
YOu can remove the syncrhonized block.
I know this is pre-existing, but getQuery has a bunch of other usages that refers to the query text. I would rename one or the other.
is this the right check?
This is duplicated code
Can this method return void instead? I feel it's a bit funny to return the same thing we just provided as input.
The most likely case of this if statement is the opposite I think.
Could do this.mode != mode instead of comparing the name.
I think this can be a bit cleaner by calling super.onCreateActionMode(), and not exposing getTag(), and then proceed to inflate the menu. (and remove the default inflating of the menu in super()). Or better yet, create an abstract method that asks for the resource-id of the menu to inflate.
mode can be null. You need to return null accordingly
Why give relayType its own variable and rcIndex and rcIntern not? And is it safe to parse a String to an Int without a try / catch?
Not really that big of a deal, but a group matching seems safer. If for what ever reason this property changes to something like 11.0.0_02 this would return 0. Below is essentially what is used for determining the version for domains.  private static int getMajorJavaVersion() { int major = 8; String version = WildFlySecurityManager.getPropertyPrivileged("java.specification.version", null); if (version != null) { Matcher matcher = Pattern.compile("^(?:1\\.)?(\\d+)$").matcher(version); if (matcher.find()) { major = Integer.valueOf(matcher.group(1)); } } return major; }
@erimerturk let's rename this to ex
Please bring back switch statement. This could throw array index out of bounds exception
Let's have these conditions one below other:  if (parts.length != 2 || parts[0].trim() .isEmpty() || parts[1].trim() .isEmpty()) {
style nit: we don't use braces around single line blocks
Code style: Always use curly brackets, and space after if.
Code style: Always use curly brackets, and space after if.
unused try catch block
empty function? also no qualifier (public,private)?
is DebugLogger.INSTANCE.w a sneaky way of calling the logger even when logging is disabled?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
This should be filled in as we know what the 7.0.0 API is. If by some chance we have to create a new API version for EAP 7.2, then we'd rename whatever's here to registerTransformersWildFly15.
I prefer short log messages for events. Would suggest to change it to  return itemName + " changed from " + oldItemState.toString() + " to " + itemState.toString() + " through " + memberName;
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Unnecessary blank lines after a method - let's remove all these to keep it slightly shorter
I think null is default
These tests don't seem to assert anything about their output.
I think null is default
With these changes, the test should fail as no exception is thrown anymore. The only reason this still passes is because there is no fail call before the catch block. Can you adapt the test to make sure it tests what was tested before?
I'm confused. Which of these catch clauses is the expected one?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Why do we need this change?
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
throw an assertion here, i should probably do that in my code as well
Can be checked on a running cluster: <LINK_0>
How come this is not a polling receiver? This polls messages from a queue right (ref:SQSTask.java)?
Any reason why this cant be unloaded?
fixen (in branch gammodes is the starting position een decorator)
Constructors can call other constructors in Java, so this should also work:  this(name, signature, ImmutableList.of())
Is this necessary? We have the StructuralProbe mechanism in the parser. Could that be used instead? Structural probes have recordNewMethod(SInvokable method).
@vilchik-elena Why not make this constructor call the third one?
add requireNonNull for clazz
Can this be private, or is there another use case for default attribute outside the builder's call?
In the plugin.xml, you said TmfTraceStub and now you make the check for CtfTmfTraceStub, that is not coherent (even though I think it will fail elegantly).
Shouldn't receive a RuntimeException anymore?
you can just return false here, even better : return trace instanceof TmfExperiment && super.canExecute(trace);
replace with true at the moment, discussed with Genevieve
This almost looks like code I wrote!
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Can this be private (or at least package protected)? It's only used by this class.
Unknown file name and known line number? Should that be an error?
These error messages are already pretty good! I'm wondering whether we could store the character index for each token and emit it as part of the error message instead of the "token index". Thoughts?
suggestion assertThat(got).contains("Description");
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
Will * <LINK_0> * <LINK_1> work as well?
Very minor nitpick: Using charAt might makes this a bit more readable: if (url.charAt(url.length() - 1) == '/')
You can create a constant to include the "http://" string and named as **HTTP_SCHEME** for instance.
It is recommended to put the method of parsing host and port into NetUtils.java.
We don't need to minus LOCAL_TZ offset for TimestampData, the millis is already an epoch milliseconds.
Do we need to handle BigDecimal as well?
Here also, comparison of value should look at similar types like long and doubles (checking for overflow)
When you extend the abstract class that you use here, you shouldn't need to override these methods. Is there some special reason for doing that? I worry that any new method addition will be forgotten here and would rather that we just used the abstract class'es methods.
index is passed in as an argument, but 0 is used in the add feature delta.
Would it make sense to add something this.caches.clear() to the stop ?
This empty implementation will override CordovaActivity.onXWalkReady. According to the doc, this seems a deprecated Activity replaced by CordovaActivity, so why we make it different here?
Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.
This doesn't need to be public it can be protected.
factory must close its cursor (which is closeable)
Preferably have one call the other?
You should not do this. The unsanitized name only presents problem when displaying as HTML, but not when storing in DB.
Should this return the AzureTable?
what else? any warning or exception should be there?
I see no reason for the setters to be public.
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Synchronize on private lock. <LINK_0>
nit: name = tableName or this.name = name
Please get the current descriptor here. Once you have that, we need to create an array of modifications that need to occur. Those modifications need to be sent in a single RPC. There's a method in AbstractBigtableAdmin:  protected void modifyColumn(TableName tableName, String columnName, String modificationType, Modification... modifications)  Please use this method with an array of modifications. That will send a single RPC.
Could we consolidate these catch clauses? Or is HornetQException a RuntimeException?
should the message include "command _with options_:" + this.options ?
you're not logging the exception
Translate this RuntimeException message in English please
You don't need to save an ObjectReader; you can call readValue directly on the ObjectMapper.
I see a problem with this error - user doesn't know where the expected type comes from (it is already added from other task).
The model value could be passed as a parameter to the validate method in order to create a single instance of ModelValidator and reuse it.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Update labels to go with method names. Alternately, call super.toString for super attributes
Why do we print a secret systemUserPassword here?
Do a detection.  if (e instanceof RuntimeException) { throw (RuntimeException) e; } else { throw new RuntimeException(e) }
I would probably catch throwables, because ClassDefNotFoundError..
I tend to think that this should just return - I think it's totally reasonable that I as a user might first close the writers independently (they do implement closeable after all) and _then_ close the pool which is going to call these methods again.
Nit please alphabetise.
does this need to catch all exceptions?
Is it the same as this?  java final StringBuilder sb = padding(element, length - back.length()).append(back);
it would be easier to understand, and way easier to see whats going wrong if something breaks, if youd also compile a expected and actual list and then compare them with arrayEquals
I think you can get rid of the first condition now, due to the change above.
You forgot your this.s.
typo "should", also "In case".
does this needs to also do a null check for payload before assigning a new reference ?
Instead, I think we should update AbfsOutputStream.close to wrap the exception, short of having the Java implementers fix this. :)
please create a more specific exception that extends this one.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
IOException comes from API signature, so there's nothing we can do there. You can add a release() with the LightblueException.
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
please extract to a separate method
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
why this is in vmCommand? should be in stopBase command
isErrorIfHostDoesntExist => isNewHost
<LINK_0>
Why is list necessary? The number of elements is passed, so array may be allocated at the beginning, it is not necessary to rely on ArrayList to determine the final size of the array.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
This might be better as an array list. Faster iteration, and such.
final
why the new line?
I understand that we still leak off of VerifyingChannelInterceptor in our Testing Framework, but you still can use a MockIntegration.mockMessageHandler() instead of logger in the main flow to verify an incoming message. WDYT?
When you changed the code to also provide the old API, you should be able to revert these changes.
@katmatt i'm not sure you are right person to ask, but at least you could refer me someone else. My question is: don't we want to update assertJ dependency from currently used _3.3.0_ to the latest _3.8.0_, it is 1.5 years since that version and now it has a lot of handy tools, like arrays comparing (including ordered or unordered).
EnvStopFailedEvent?
I'd rather toLowerCase() is applied after substring(), not before.
tmp must be a constant and we dont prevent nullpointerexception for filename.
It may be over thinking this but I got some errors when I tried to make a form name with spaces around the "/" e.g Form with / back slash where as Form with/back slash worked on the device. So maybe we can add another replaceAll() after the first one to replace any patterns like Form_with___back_slash?
you could replace this line with this()
Maybe instead java /** The filename without any compression extension, or the original filename. * It tests for compression types handled by {@link #openFileEx}. */ static public String filenameNoCompression(String filename) { if ( FilenameUtils.isExtension(filename, extensions) ) { return FilenameUtils.removeExtension(filename); } return filename; }  I believe we have commons-io already in the dependencies list. There's some extra check for null bytes in the extension check... but that's not so important. Just simpler I think.
Use MethodType.DERIVATIVE.getCode() and MethodType.MAINTENANCE.getCode()
could be static
devtype is not camelcased, also deviceType would be more descriptive.
I like this CAS operation, but it does not check whether the requested transition is valid or not, which is one of the most important motivation of using StateMachine I think. Also, there is checkAndSetState which is similar to this method, but throws RuntimeException when the given states do not match in the predefined legal transitions. What about allowing users to configure the StateMachine for the action to be taken when an invalid transition occurs? There could be two choices I can imagine for now: 1) Throw RuntimeException, 2) Proceed with leaving WARNING log message. We can introduce a boolean (e.g., failsOnIllegalTransition), and make it an argument of StateMachine.Builder. By changing the return type checkAndSetState() to boolean, and internal logic of it per the boolean field, we can have only one method while achieving the goals of both methods. How does it sound?
@dmzaytsev let's inline this
Space before {
SonarLint is going complain about String concat
Let's include the giver and recipient here too
Use Paths.get or non os specific separator
Use Paths.get or non os specific separator
studentsWhoRespond -> studentsWhoResponded
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Expose Map if you can
nit, Collections.EMPTY_MAP?
Do these methods actually get used? If not, then maybe throw UnsupportedOperationException instead. Then, if someone tries to use them, there will quickly be an exception thrown.
let's call it updateCodeMinings() instead.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
please move the isEmpty methods to the scimSchema
Does this code need to verify that the activeAwardAccounts collection is non-empty?
is it not empty if for example type is an valid empty string?
We should avoid using Java8 for issues which could be backported in 2.4.
There is a duplicate implementation in PushTest. It's a good candidate for a test util function that can be imported statically.
It's pretty inefficient to create all these AclBinding instances, just to check for unknowns. Is it possible to avoid that?
suggestion return entry -> entry.getValue().stream().map(GameId::getId).anyMatch(gameId::equals);
Let's add the partitions parameter to the message as well and verify the expected partitions are revoked.
kind of curious what these magic numbers are
You're testing two completely separate features of the class: 1) closing of environment, 2) converting environment to string. There should be two separate test methods. This anti-pattern is sometimes called "Test it all" (<LINK_0>
@ilyakharlamov I think that this test won't run on windows, it fails on creating files on /dev/null
Perhaps ignorance on my part, but shouldn't env.hasTableId() be checked first? Can env.hasTableId() && env.hasScope()?
Sleeping here for a bit longer (50 in my setup) makes the 2nd issue (missing hasNext) fail more likely.
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
I think we need to specify the locale Locale.ENGLISH for SimpleDateFormat, to avoid a default system locale. Example failing to parse (simulating a German system locale): new SimpleDateFormat("dd-MMM-yyyy", Locale.GERMANY).parse("1-May-1994");
There is a lot going on this one line.
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
is getLastSyncTime() guaranteed to return non-null?
Does this mean that new null handling unconditionally adds overhead in groupBy query processing?
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
Could use Double.BYTES
Short.BYTES
Should include tableName as part of hash code?
This null check should be done in line 274
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
Looks like a null check on sourcePort is missing here because sourcePort is Integer and therefore can be null. If sourcePort is null then the comparison "== 0" will cause problems when trying to debox sourcePort to int. Just tried the following similar code and it crashed with NPE: Integer sourcePort = null; int x = (sourcePort == 0 ? null : sourcePort);
Use Integer#valueOf(int), or delegate the work to the method above, so we can benefit from Java's internal int cache.
This should contain the MTU as well.
don't need optional, just use ImmutableSet.of(ports.get(getNodeType()) should work
Check if there is an appropriate constant for "no metakeys" mask.
nit: We can store this into a static final field TEST_PARTITION_INFO int this class.
Why not use null instead of ""?
How about introducing EventClass.emptySet() so that it's easier to find places where return empty sets?
This is basically a guaranteed crash right? To be avoided at all costs, it's just making future work. A toast and a fall back to the note editor or anything is better than throwing a RuntimeException if we can avoid it
nit: We should use UIUtils.showLongToast(). If it doesn't exist, we should make one.
Any reason for switching from using the PermissionsManager here?
line length
to nitpick: just use this instead of the application.
Lots of unnecessary this. qualifiers.
Recheck some of these please. In Java, all non-primitives are just references, so these lines will not be making deep copies unless you do something like .cpy() which you have done for relativePosition. width, height, relativeAngle and relativePosition will be deep copies with this code. texture, drawableLevel, and tint should all have clone() methods
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
This is a public API change. Does it need to be public? It would have to be reviewed with other language folks
Please change the line 38 to also use EnumMap<> for consistency.
The return statement can be simplified return (currentTime - lastHealthCheck) >= minInterval;
give some meaningful name to this thread.
I think the granularity should be 1 seconds instead of 5 seconds here.
This was mistakenly moved
This should not call Schedulers.computation() directly, but the Scheduler that was passed in, otherwise virtual time is not possible. This is currently the same as calling System.getTimeInMillis() directly since it is hardcoded to a particular Scheduler.
getParent() can return null
this can be implemented with: decodeBucketIndex(EXTENDED_PREFIX_BITS, entry)?
This is the only place that add entry to the pool, is it the only way to fill the pool?
please use AsyncCountDownLatch here. Both handlers slaveConnectionPool, pubSubConnectionPool invoke countDown method and in latch callback we do rest logic.
Why not just catch "Exception"?
Simple for-each?
I still don't understand why the key cannot be the session id
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
Note that all references to CoreRegistry.get(class) need to be replaced with either @In annotations (best idea) or context.get(class) codes (find-and-replace). You'll probably need an @In annotation to pull in a context.
For new API I'd prefer to return an java.util.Optional<T> instead of null to avoid potential NPEs.
This check needs to be done in hasMore(), not nextRow(). hasMore() can block, nextRow technically cannot and just because there is another from hasMore() doesn't mean that it will be within the minTime.
this could also use the get treatment
getCells() can never be null
Could be cached, SingleIndexedInt.of() and cache 0-127 :)
I get a warning for this cast from Object
Please close client at the end.
restore might fail with exception => client should be closed in finally block
I suggest to clean up the client in the same class where it is created - in the parent AbstractMessagingTestCase.
This is not necessary, the client is already created in the parent
Switch order and as well in other similar cases.
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
Same issue with the change in visibility of this method as with JcrRepository.start().
newline
Could we reduce this to debug again (as in the current master)?
Enforce immutable and non-nullable lists. If this is a read-only object, not something users will build and send to ARM in a request, then avoid having nullable collections (the typical tags field of an object is a counter-example as we need to send it as null, so we enforce immutability but not its presence): java new AutoValue_Metric(data == null ? ImmutableList.of() : ImmutableList.copyOf(data), id, name, type, unit);  Apply this pattern to all lists in the new model classes.
Just return data.
nit: you can merge both lines above as checkNotNull will return the given argument
@robbavey don't we have to release this ByteBuf after we've deserialized its contents?
Can we set a charset? Like ASCII or UTF8?
For data.length==0, is it possible to be an empty string?
Let's do return fDetailedLoad; even if it is always null for now
Don't need this - regionGuidePosts is either set in the other constructor or set in the readFields method.
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
IIRC, I use rawQuery with the same result like yours. Please check rawQuery API to simplify this function call...
use try with resources
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
Let's rename "e" to "ignored" Please use fail() <LINK_0>
Let's rename "ignore" to "ignored" Please use fail() <LINK_0>
Let's rename "ignore" to "ignired" Let's replace "// igniore." with "// No-op."
Assert with counter. You could return it's value and assert you only get 1 and that a subsequent call gets 2
may be it is going to be more obvious to have dedicated variable for that? 'boolean predefinedSamplesCount' instead of 'totalSamplesRequested != -1' ?
Get it from the model now that we have one?
Fix the method name here please.
Since we get access to the Site here, it seems wasteful to throw it away, and then have to re-expose it through FeedCoordinatorBase. In all the other cards so far, the Site gets passed all the way through to the server request from here. Perhaps the same can be done for Random?
This could just be: return isFeatureEnabled(context, namespace, name, false); which makes it clearer that the 2 methods do the same thing with just a potential difference in the default.
Same as above - log or throw the weird state.
We could probably use getItem() method here, for consistency.
Like, super.onFailedToRecycleView, this doesn't seem to do anything. Why call one super and not the other? Ditto for below?
Please create a new function dedicated to stopping shimmer for better code readability.
This makes me slightly nervous :P I'm sure it's not a problem, but maybe add some parens to delimit the order of ops?
To be safe, should check gerritTrigger.getJob() != null first.
job
Should we track additional information here, like what kind of trigger it is? What would the cardinality be of that? (e.g. is it a pipeline trigger, an internal trigger, etc)
StringUtils.isEmpty from apache.lang3 I think
I just realized when I checked the failing test that there are parentheses missing around the ternary operator, string concatenation has higher priority. So it should be: IllegalArgumentException("There is no start node that matches the trigger " + (trigger == null ? "none" : trigger));
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
why do we use this. on getters but not on alpha? I would skip this. all together here and use getAlpha()
Wouldn't it be better to only show iterations OR epsilon?
Why not use slf4j format standard? log.info("Heartbeat exceeded for host '{}', last response arrived {} ms ago.", getHostname(), getHeartbeatTime();
prevWeather can be null here- it might be necessary to update the API to make initialWeather anOptional
fileName seems a bit redundant - why not do this in a single line? File file = new File(baseDir + "/src/main/resources/bundles/AppErrors.properties");
can we use BeforeClass annotation?
please use method directly, you don't need to store it in variable
[JavascriptActions.scrollToBottom()](<LINK_0>
use js.execute(script).toString()
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
This should be a constant, not a magic string.
specify array length (based on codecs.size) to optimize. <LINK_0>
properly format the code (select text > right click > source > format)
throw exception
It should throw exception
Possibly more descriptive error message?
Do we really want to move this from trace to debug?
As a nit, should have a null guard here.
Geometry is comparable?
There's probably some edge cases where this isn't true. Consider the case where there's 1 discrete parameter to optimize, with possible values {A,B,C}. In this case, there's only 3 candidates - and the candidate generator should terminate once all 3 have been generated.
return defaultFilterFactorEnabled ?
"Called only after a call to prepareEntities" Might be worth adding a flag to enforce this; I'm guessing this could be unpleasant to debug if someone tried to manipulate entities before they were ready.
I'd say if the entry is present, the command is not successful.
also check this
This represents a poor API. If you are not going to provide a working implementation for all versions, the newInstance method should be marked @Nullable and you should actually return null. This way callers explicitly have to write:  java if (mHighlighter != null) { mHighlighter.highlight(...) }  An alternative strategy is to add an isSupported method that NullHighlighter (prefer NoopHighlighter as well since null has no semantic context here) implements and returns false, then throws on all other methods, forcing callers to write:  java if (mHighlighter.isSupported()) { mHighlighter.highlight(...); }  The reason for being explicit is so that readers of the highlighting code can see plainly that it might not be supported and that would explain why it's not working for them on a naive/quick read of the source code. Forcing folks to dig all the way down into the implementation to see that possibility is frustrating.
static.
stopSelf() at this point might be problematic because the signaling facilities are asynchronous so the service might stop before the signaling facilities get a chance to unregister (send BYE and get back 200 OK) and unbind properly. What is the issue with keeping this in onCloseReply()?
This method can be simplified to  java if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { return SupportedAbiWrapper.getSupportedAbis(); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO) { return Abi2Wrapper.getAbi1andAbi2(); } return Build.CPU_ABI;  Also is it worth wrapping Build.CPU_ABI in an array so that the output format is always consistent regardless of API level?
Assert.notNull(expiry,..) checking might make sense here
nit: line too long. final not required -- a static method cannot be overwritten anyway
how about we redirect to the non deprecated method? The only downside is that the closure cleaner will be applied on the AssignerWithPeriodicWatermarksAdapter.Strateg but I think its fine.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
we should not throw an exception here, simply ignore
![MAJOR](<LINK_0> Make "isExcluded" a "static" method. [![rule](<LINK_1>](<LINK_2>
Does the system property check influences the dataType too?
if injected 2 times, calling two times variable.symbol().metadata() is not efficient. Please use a dedicated intermediate variable.
The expression won't contain the field name.
<LINK_0>
<LINK_0>
Why are you catching and ignoring? as above, if you catch, you should do something, if you wish to ignore an exception, please say so. Typically using the word "expected" as the variable name. <LINK_0>
Why is this using PROJECT_NUMBER? It's supposed to take both and our samples prefer PROJECT_ID.
You don't need this, but if you do keep it in it needs to set standardOutOrig before you call System.setOut - otherwise you are just getting a reference to the value you just set.
Question: Should not we add braces to this statement?
throw exception
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
this just doesnt break anything right now because backpack is not handling user variables correctly. (so this is working because of another bug) since this delete method is also used by the backpack when one deletes a sprite in backpack, it tries to delete the same thing in the currently loaded project aswell.
Whoops, this needs to be the other way round (the first block is for ExecutionException and the second is for InterruptedException)!
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
Make it a static method in ExecutionExceptions or similar class?
if (!(e instanceof ExecutionException) || e.getCause() == null) { return e; } Throwable cause = e.getCause(); return cause instanceof Exception ? (Exception) cause : new Exception(cause);  How about making return statement simpler?
Putting fetch inside get() might not be good. If this api blocks writer, writer can starve because fetch can really take a long time due to hole fills. If this api doesn't block writer, then the NoRollBackException issue will still occur quite often as this reader may override the writer's value with no undo record.
Please use curly braces for conditionals
equals and hashcode are only comparing stepNumber, which is half of the key. Should compare the Progress objects or their IDs too
:bomb: this is not a solution. hashCode() can be equal for two different objects. Do it using the four fields.
Can you add the curly brackets to the if calls.
Liran, Yevgeny, now that we're using hibernate and it creates a proxy for the entities, is there a need to enforce in the equals impl of methods "is instance of" or can we settle for getClass() comparison ?
Could you add an assertion on one of the associated props? Just to be sure...
All these vars are used just once. Maybe just use the method call directly? i.e.  "<LINK_0>" + mUser.getAccountToken() + ....
Why the sub string ?
Does this not need a TypedQuery?
Remove new line.
As [mentioned](<LINK_0> in #408, this variable should be renamed to "args" to be more descriptive.
Good note. I think USER_PORTRAIT would be better so it works upside down too
Why are we configuring drawer in this activity. This activity shouldn't have it.
Are both of these lines required? I'd have expected we'd only need the attachBaseContext
Not required
add message to log
What if client is null?
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
Do we really want to move this from trace to debug?
ClientConnectionException mean that there are issues with network connection. Please consider reconnect logic here.
@apc999 This needs to be public or reflection will not work
This is already initialized by super class.
correct.
suggestion return fileSystem;
Is it OK to swallow this entirely?
Any reason in particular that it shouldn't give the effect to players?
Check first that target is not null.
should be ...object instances can be deleted"
do we want to have actual percents? not rates as everything else is in Picard?
Let's use Identifiers.pack(...). There are no differences between the results of those two, but it feels better to use Identifiers for IDs.
static import
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
could use diamond op
Can we const this magic number somewhere? what does this 300 stand for?
For consistency across the project, please remove the final keyword from this local variable.
Looks like validation result is ignored. Let's wrap it with Assert.assertTrue(). Also constants on rows 115 and 118 should be changed to long (0 -> 0L and 1 -> 1L accordingly).
@stefanbirkner I question using LinkedList here, because I understand that ArrayList, the main alternative, usually performs better on modern hardware because it can better exploit processor caches due to it using an array internally, whereas LinkedList cannot due to it using pointers.
why ConfigurableApplicationContext, not ApplicationContext?
This can be "package-private", i.e. no access modifier.
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
Sorry forgot to mention to change the read to access here too
style nit: remove curly brackets
Should you set the module logger after calling WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(logModuleClassLoader)? (as it is done in activate)?
no lets call Assertion error: error instead of ass.
are you sure it is save to remove this block ?
is this required ?
I note this is using the same namespace as the pre-existing "aggregating" metric.
can this just be collapsed into a single writeAndFlush() call?
@kachayev this is not correct as you already write a FullHttpResonse and so MUST NOT write an extra LastHttpContent
set me free
please add new HelpTag and HashName (as in StorageListModel)
consider a ternary statement instead...
I might be wrong in understanding the bug. Correct me if I'am wrong. But, the bug says "Message in the Restore Popup is not correct when volume is online and snapshot is deactivated" and lets assume now that the snapshot is deactivated and then without this change it would go into the else which is doing the same as your change already right?
Kindly move this to UIMessages
You didn't add the macPoolCommand to 'executeCommand' of this class. Maybe I miss something, but I'm not sure how it suppose to work...
suggestion processInstanceIds.forEach(processInstanceId -> {  You dont need to use _.stream_ to access _forEach_
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
Could change to ProcessInstance.STATE_ACTIVE ?
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
I think here you can call await directly on the configured countdown listener and check the outcome of the await method - it should return false, meaning that it timed out. Wdyt? Otherwise we can replace this with plain Thread.sleep().
This should check to make sure that notificationUUID is not null before attempting to delete it.
check to make sure notificationUUID is not null
It doesn't look like you are doing anything with the bucket here. This can be removed.
Missing final.
Missing final
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
Maybe make this a static final List now that is is used two places? (here and line 123).
have a default constructor with reasonable default values
Please keep this.cell near the related fields (previousFamily & cell count) below
this.fragment = fragment, no need for the ternary ? operator
You could instead have a storeTTL option taking a string and parsed using DurationUtils, for more readable config. Actually I see other places already using storeTTL and using that so something is inconsistent.
Integer.parseInt
Shouldn't options be Immutable?
please see the contract of Map.entrySet(): by invoking put() during the iteration the result is undefined.
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
Per IRL, I meant to say uploadApiBase. This is fine too, but unrelated.
Looks ugly and potentially a source of future NPEs.
what if fParser != this? shouldn't this be fParser.createTimestamp
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
Please use the Spring's Asserts for that, for consistency with rest of codebase
unrelated change ?
This doesn't seem to be used?
You could keep those paths as constants (MODULE1, MODULE2, etc.) since they are re-used
In this case it would be better to define modules variable after JsonArray modulesFromJson after this you will be able to create modules list instance with defined size new ArrayList<>(modulesFromJson.size);
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Would return builder(SecurityLink.resolved(security)); be simpler?
nit: param doesn't need final
Using CompletionException would be more appropriate I think. Otherwise we would end up with longer ex-> RuntimeException(ex) -> CompletionException chain of causes.
make all local vars final if possible
don't catch, but instead allow the ExceptionMapper to handle it
Better, but use logger.logAndThrow(new ...)
This method is not being used anywhere. This class has findbugs failures as well
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Would it not be enough to only catch MergeException here?
we never use NULL, it is a bad practice in general.
is there a reason for StringBuffer instead of StringBuilder?
Since Kieker now requires Java 7, you can use the try-with-resource clause here.
Symmetry (throw)?
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
don't forget default case
When you move the default keyword to the corresponding case you don't have to implement it twice. :wink: java case R.id.brick_glide_to_edit_text_duration: default: // Code
Left over from debugging?
Timberrr!
(ListView)  can be removed
The try-catch surounding this can be replaced with JUnits [ExpectedException](<LINK_0> rule. It reads a bit nicer.
do these test methods really require throws Exception?
should this exception be left to bubble up and fail the test ? If afterEach fails it means the repository was not shutdown properly
I already made several fixes to the unit tests cases and XBeeDevice class that are already committed in master. We will sweat blood to make the merge...
Redundant assertion
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
Maybe make it _this.pool_ to keep it consistent.
Actually as Part of reusability we have added Synchronized block inside TrapReceiverImpl.addToSnmpV3Users and same we are calling here.I hope this serves the cause or If still synchronized is needed even for this block i can update it.Please let me know if its necessary to wrap here as well.
could we use guava Cache instead of doing our own ?
don't update fields in one object in the constructor of another object.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Do we want the toString()= in here ?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Please include clientTelemetryEnabled in toString() API
Just return checkNotNull(id, "id").split("/");
these setters should not be public
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
Why is this necessary?
Uh, IllegalStateException?
Consider adding null check here.
Finish implementing function?
Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods "checkDuplicateEmail" and "checkDuplicateUsername" . And you can instead implement method on the HardcodedAttributeMapperFactory "validateConfiguration" and throw an error in case that "username" or "email" was configured as user model attribute.
Change log level to debug
will potentials AttributeNotFoundException be translated into 404 status code from the REST interface ?
Use org.ovirt.engine.core.compat.StringHelper.isNullOrEmpty(String)
This shouldn't get thrown.
nit: style wants newline
It would be great to cover the util method with tests.
There should not be a need to set this to public. Perhaps private would be better.
Do you need the fully qualified class name here?
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
I believe that this validation doesn't belong into the API. I'd suggest to modify this 'ticket' method so that it works similar to the 'ticket' method in the 'BackendVmGraphicsConsoleResource'. If the 'graphicsType' is null, it should pass null to the 'SetVmTicket' command. The command implementation should then check if it is null, and generate the appropriate message. It should also check if the VM is down.
This should just return 404 HTTP error code (not found).
I always thought that only the first word of a sentence should be capitalized, and that the sentence should end with punctuation: Operation failed. Call me picky, I admit.
Oh yuck. ;)
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
protected instead of package protected
It would be better to avoid casting here as it prevents class cast exception. Please rewrite first constructor instead.
public
redundant ";" character
xml supports SpEL too.
Why we removed final?
Why do we even have this check. It seems like issue in other place of the code.
just readability - we can move 'updateAllVmsSucceeded' declaration to line 118, as it's not needed for floating disk flow.
This calculation avoids choosing the right host in the following example: host 1: sockets 3 cores per socket 2 threads per core 1 host 2: sockets: 6 cores per socket: 1 threads per core: 1 For a vm configured with: sockets 3 cores per socket 2 threads per core 1 Considering all other host parameters are equal, then both hosts will get the same weight and the first ("host 1") will be chosen instead of second ("host 2"). I think that maybe the calculation should contain "cores per socket" comparision instead of "total number of cores" and the same for threads.
Isn't below more readable? if(!ExternalStatus.OK.equals(host.getExternalStatus()) {
rename to contribution
style nit: no braces around single line blocks
You should probably call super.dispose() here too
timed --> direct
We should call clear after disposing all the readers
Likewise don't need the if statement since the optional value will return empty.
Providers will know to filter on SpellType.NONE, so just call the api method for the current spell and the ifPresent will know if the value is empty or not.
Remove the if.
Delete the if, the ifPresent covers the if.
You can eliminate the if statement since the ifPresent will already redundantly add this.
Please use TIME_FORMAT instead of "HH:mm:ss"
Please make the constructor private (see Invalid).
What if the string doesn't end with a " or '? You'll strip the last character.
This could be made static
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
nit: use SUBJECT
What are your thoughts on using an AndroidPreferences instead of a raw SharedPrefs?
I would use something more random here, like RandomStringUtils.randomAlpha(Tv.TEN), for example
Should be removed if empty
This shouldn't declare throws Exception.
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
Local variable could be declared List instead of ArrayList. Is this worth caching?
This exposes the unicode workaround to the public.
new ArrayList<>(causes);
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
check name?
Can we check for an empty string too, please?
shall it also be >= 0?
This thing does check the value for not being null. So the previous expression is redundant.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Have you intentionally omitted index check?
Is this correct?
This needs to be changed to return the long value.
Use Guava hashCode function
If you have to cast here then you probably should have casted when reading the value from the data array.
No need to use UriBuilder
No need to use UriBuilder
Just this.home is enough
No need to use UriBuilder
No need to use UriBuilder
return tags;
I think we can remove this line.
returning null cause null pointer exceptions
Could we return an empty map instead of null so this method doesn't have to be @Nullable?
We shouldn't catch a NPE. We should prevent it from happening. What is resulting in an NPE?
I would not call the leaderContender under the lock because of the risk of introducing potential deadlocks.
shouldn't use the CLUSTER log CLUSTER.debugf("Shutdown while handling command %s", command);?
Again, we shouldn't do this.
This can be condensed. java if ((throwable instanceof ServiceBusAmqpException) || !(throwable instanceof AmqpException)) { return throwable; } return new ServiceBusAmqpException((AmqpException) throwable, errorSource);
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Asserting the actual message isn't a good idea because this could be localised or message changed which would break the test.
Asserting the exception type is sufficient.
You don't need to add this exception to the signature as it is an [unchecked exception](<LINK_0> :)
Same goes for this one :)
This is a test for the userRepository in my opinion and should not be here.
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
sorry i missed that before, you should send "getActionType().getActionGroup()" instead of specifying the actionGroup here, and specify the correct action group in VdcActionType enum (where currently it is wrongly MANIPULATE_USERS it should be the new EDIT_PROFILE
make permissionList private variable, permissionList should be created only once
I don't think this is correct. Consider changing a disk to use QuotaA instead of QuotaB. I'd assume you need ManipulateDisk on the disk, and consume on QuotaB, no?
what about setting the permissions for that?
you can actually use the returned boolean value to nullify astroDiscoveryJob and print the log.
**USB**-serial
Do we care about threading? device is set in the thread that calls initialize (in the parent class), device is unset (set to null) in a thread used by scheduler. So, should we use volatile, some synchronization, ...?
simplify this
Seeing this essentially duplicates the load code above, I feel there must be a more elegant solution to this - something that just retriggers loading of all the existing observable's data...
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
Try using StringUtils.isTruthy(this.path)? <LINK_0>
I'm missing the new field in the toString method.
agentDisconnect also sets this state.
Rest of the class does this lookup in the DataPurgeJob instantiation, this should be there also for the clarity.
sgtm
Let's use the new NETWORK_FACTORY permission that Paul is building in aosp/1099096
could ringsize != -1 check be done here, will allow better escaping and inlining where not being used., e.g. avoids need to call into method below which is many lines long, and unlikely to be inlined
ImmutableSet.copyOf(Iterables.filter(...)) ?
ImmutableSet.copyOf(Iterables.filter(...)) ?
That's good to know.
The methods computeIfAbsent() and putIfAbsent() are not thread-safe. If two threads call fetchTree() concurrently, you might get two ids for the same aspect. You could use a synchronized block around the two lines, synchronization on one of the maps (they are final).
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
Can this happen ?
I would recommend componentType.cast(new GlobalSecurityManagerImpl()); instead.
I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.
You can remove the unchecked warning by doing:  T service = clazz.cast(services.get(clazz));
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
you should have here setSucceeded(true) IIRC.
Do not forget to check that there is no link after enablement/disablement of the preference. With separated tests like the current stat f the class, we do not control the order of the tests.
This method needs to be implemented in LexerATNSimulator as well as ParserATNSimulator.
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
?? why this and the following ones could be left empty?
Mid return may worsen readability
is it not empty if for example type is an valid empty string?
You have chose a policy=static for the reference, so it cannot be null.
please move the isEmpty methods to the scimSchema
How does this work if you resume a download? It's using the same instance right?
The "Name" class implements correctly the "equals" method, so you can do just this: return SCHEMA_ENUMS.contains(type.getName());
if these strings are used elsewhere, create static constants and share
If the list is static, then you don't have to remove the static modifier everywhere. However, I would prefer you to use a dedicated getter lazily loading the configuration of excluded types.
I think this Map.class.equals(type) is a remnant from a previous implementation and can be removed?
These should refer to constants rather than the string literals.
Why decryption is excluded?
id is the id of the container. so it means in the scope of this container "createItem." + this.getId() can be pre-computed for the container, rather than re-computing it each time. Could you pre-compute this in the container level.
can we factor out this code, here and other places? e.g, java return withContext(context -> replaceItem(itemType, itemId, doc, requestOptions,context)) .subscriberContext(reactorContext -> factoredOutFunc())
If we are introducing a new connector, I prefer to not support this option in the first version. It is not very useful and may be error-prone in upsert mode.
This would be a breaking change, are we ok with that?
assertThat(element).hasTotalSize(6)
assertThat(result).hasId("analysis")
Ik. Maven has logging facilities. We should use them.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
having wallClock = 4 for atlasTs = 4 is potentially confusing (ditto below with 6/6).
formatting
We could also have a test to establish that we can be rate limited on one read and then have a smaller read succeed.
Should checking of all details be in every test? Username and other details are checked in other tests. The only difference is "guest=true". Are you sure? I'm not
Should that be a post or a put?
Because there is only one argument, we can pass workerMetrics instead of an object array.
Inconsistent log format. Use either {0}th or {0} th. {0}-th is even better.
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
This mechanism is a bit different from other apps; the number of push/pull requests are done numberOfUpdates times numberOfKeys in one iteration. On the other hand, Dolphin apps (e.g., NMF, MLR) update models by sending push/pull requests in one mini-batch. Could we go with the same semantics?
why both DataProviders have the same article's names inside?
Value nor envVar wont be ever null, but empty strings, so that check will be valuable
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
typo notifiedMessage ?
allowedTexts
I think just CallManager is not healthy should suffice as an explanation. Health.java shouldn't care about the specifics
super.init() method never throw an exception.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Don't you need a super.setUp() call here?
Hi, @nvazquez. I see a little mistake in you test, you are testing if the method has inserted a tag or not, I think that this test needs to verify if the template inserted in the templateResponse is the same that you has passed in the first param of the method. You can do it checking if each variable in both templates are equals. The same problem in the other tests cases. Ty.
This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.
make it fluent
If you want to save a little code, you can use "ArgumentVerifier" in org.threadly.utils. It was designed to be a way to save jar space by reducing duplicated code.
use MAX_SIZE
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
This method looks horrible to me (and to whoever is a sane engineer, I should think).
We don't need a separate implementation of each method for CRS matrix. We already have it in AbstractMatrix.
We don't need this. There is each method in AbstractMatrix class that has the same logic. And we can't do it better than there.
should make a static final.
From <LINK_0> I still think that a declarative programming approach with streams is a much more elegant implementation than this.
We could merge this, but that would cause all extenders of this class which are not LineContentAnnotation or LineHeaderAnnotation to not be clickable. So that could be perceived as a functional regression by those. Is this a big issue in your opinion? I am personally fine with it, as this is very new code and I don't think it has much adopters beyond those who are already following, and that even current adopters do work on the CodeMining layer more than on the annotation one. That said, do you think we could figure out an implementation that would work in basic cases, such as x >= fx && y >= fY && y <= fY + fViewer.getTextWidget().getLineHeight(position.getOffset()) && x <= fx + gc.stringExtent(getText()); ?
just = bit != 0?
I wonder there is a better place for these 2 methods. If I was looking for this functionality. I wouldn't think to look to AbstractFragment. I don't really have a suggestion though, just thinking out loud, I guess. Edit: I just noticed that these 2 methods are the only static ones we have in AbstractFragment, which I guess can be a good reason to think about moving these elsewhere.
I think that casting the two counters before computing the difference is a mistake. We could end up having to truncate the long and computing a false difference, could we? Maybe it would be safer to do return (int) (this.getCounter() - event.getCounter());. Also, we can use field access instead of getters for counter.
Why change the order? You normally stop in opposite order to creation. So, if you create embedded cache manager first and then the server, you normally stop server first, then the cache manager.
Is this double invocation performed on purpose?
I would always call stop regardless of the mode (and make sure that stop is a no-op if it wasn't started). That way, as we implement other modes, we don't have to update that piece of code.
Should be in a finally block?
Ok if already stopped? idempotent?
does this need to be a class member?
You could use METRICS_PERFIX constant here instead of priam
Typo? "BlobDet4acryptionCount"
use a constant instead of null to make the code easier to read at this place pls
Consistency: queryConverter() instead of query()?
please add setSoftLimitInterval() setter and use it.
We need to get rid of DefaultMinThreadPoolSize and DefaultMaxThreadPoolSize and define those as JMX properties inside ovirt-engine.xml.in
Consider getting this value once, and save it, instead of calling it twice.
The <Integer> can probably be omitted.
as this is not interactive command, I suggest you do not call getDbUser twice, drop the canDoAction entirely.
@fanifieiev Let's put this in a constant.
@fanifieiev Why not use the constant here too?
... remove the final modifier from the method. It will be easier for future tests.
Are you positive that value could never be null here? I don't remember if we translate empty values to empty strings or null values.
I think you should throw exception if somebody calls setEvent and give an empty event name. #Pending
We get to rename this variable to prefix it with is I guess
Don't we usually include a test for these validations?
Does getEmails2 always return a collection? Take a look at code to be sure. Concerned about possible NPE.
Nit: extra blank line.
Let's not do partial reformatting as part of a functional PR. In other words, keep the current formatting for unrelated changes, if we want to change line lengths, let's do it for all the source code in a separate PR.
should be false unless one of the vm's disks has true for this
Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.
Why should the About dialog no longer be resizable?
I suppose this should be true ?
This should always be read from the configs.
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
It would be great to rename the variable to isParamCountValid.
I believe it should be allMatch here instead of anyMatch
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
Is this a good practice? Casting to an abstract class? it may be better to have an interface AccessControl and AbstractAccessControl then implements that interface... but that way you program against interfaces which seems cleaner to me.
this is redundant with next instanceof check
since this is the vdsbroker, you should be able to use java.util.Objects.equals()
Needs to consider the new custom fields.
This could be checked earlier I believe
Please remember this ctor changed.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Use same order as the field declarations.
Would be simpler as: return Arrays.asList(Action.RELOAD);
this.
Could change the return type on method to Collection
Collections.emptyList()
Immutable
I realize that the test case was just moved, but maybe for a separate commit or a follow up: Maybe the error could also give a hint on what would be correct. E.g. StringType can only have a single parameter value, received: ... Also in the other error messages. E.g. with 0 it could point out that it must be > 0.
the method name is misleading. You insert a default organization uuid but it's failing. Why?
Since IllegalArgumentException is an unchecked exception you don't need to include throws here
you're crazy man :-)
Eclipse is giving an error that this is not thrown. Changing to Exception fixes it.
user.get() can return null
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
I could be missing something, but why can't we call deleteAll with toDelete and not create a separate KeysIterable temp var? Actually, this method doesn't even need to accept an iterable over entries, just keys.
This is going to fail in case we get an empty list (yes, an edge case, but still... a check on the size would probably be safe). Or perhaps an empty list has a special meaning?
hey guys, here it is what I should do by doing some initial casts (not great code I know, had to review at some point...), but this way the stream and functions to apply seams more clear... up to you!  protected boolean isConnectionAlreadyFormed(final Node<? extends View<? extends Definition>, ? extends Edge> source, final Node<? extends View<? extends Definition>, ? extends Edge> target, final Edge<? extends View<? extends Definition>, ? extends Node> connector) { final String connectorDefId = getDefinitionId(connector.getContent()); final List<Edge<View<? extends Definition>, Node>> outEdges = (List<Edge<View<? extends Definition>, Node>>) source.getOutEdges(); return outEdges .stream() .filter(e -> connectorDefId.equals(getDefinitionId(e.getContent()))) .map(Edge::getTargetNode) .filter(n -> n.equals(target)) .findFirst() .isPresent(); } private String getDefinitionId(final Definition definition) { return definitionManager.adapters().forDefinition().getId(definition); } private String getDefinitionId(final View view) { return definitionManager.adapters().forDefinition().getId(view.getDefinition()); }
value is redundant, just return right away.
are these setters used anywhere?
Same here. Add clarifying parenthesis
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
We do not unpack it for all the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to byte is needed here.
Duplicate in both createSubject and createEvidenceSubject methods. Consider to refactoring into helper method.
Same variable names (change to senderVouches.
This seems unnecessary, if you going to return the same thing at the end of the method anyway.
Instead of relying on all the properties shouldn't we just rely on discoveryType? less confusion with if else logic and also while defining the descriptor.
This doesn't allow for values to be passed in. Should discuss the appropriate solution for this.
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
possible NPE
On START_DATE, the discount factor for start date should be 1.
The smile has an impact on the currency exposure. Run the test with a VOL_PROVIDER_FLAT such that RISK_REVERSAL_5_FLAT and STRANGLE_5_FLAT are 0.0 everywhere. The last 3 lines of the test are incorrect. Replace by: double ceBaseFD = pvBumped.getAmount() / (SPOT + FD_EPS) - pv.getAmount() / SPOT; assertEquals(computed.getAmount(EUR).getAmount() \* FD_EPS, ceCounterFD, NOTIONAL \* TOL); assertEquals(computed.getAmount(USD).getAmount() \* (1.0d/ (SPOT + FD_EPS) - 1.0d/ SPOT), ceBaseFD, NOTIONAL \* TOL); The code in 'BlackFxSingleBarrierOptionProductPricer' seems correct, it is only the test which is incorrect.
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
You should be consistent with either using this for instance methods or not at all. I prefer not using them if not required.
Could probably be shortened to double orbitalPeriod = 48D*Math.pow((Math.pow(orbitalDistance, 3)*Math.pow(Math.PI, 2)*10D)/solarSize, 0.5D);
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Use catch (NoSuchAlgorithmException | KeyStoreException e) when having multiple catch blocks with same output inside them. Also since you are catching 'Exception' finally and throwing the same exception with same message, the 1st two catch blocks has become redundant here. BTW its not the best practice to catch Exception, its better to catch specific exceptions and handle them. Any reason for catching Exception?
This should be handled by the nodeDelete return value, so we don't need this catch.
What made you to wrap, when you still use a simple long afterwards?
this.lockVerbs (like below)
This condition seems like it'll fit in InstructorCopyFsToModal.java more, to reduce the reliance on that id string.
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
Can you use TextUtils.equals(browser, defaultBrowser) instead? It's a null-safe version of String comparison since it is possible that defaultBrowser would be null.
style nit: we don't use braces around single line blocks
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
Make this "info". there's relatively fewer operations scheduled on the executor, and would be good to log their completion status
nit: not sure why this method called generateSendFailure. Should this be renamed to handleSendFailure?
catch RuntimeException
Also try to refine 404 errors to a ResourceNotFoundException to let the 404 fallbacks work
Assuming this is noting completion of initialization, perhaps "Finished initialization."
Get the service registration reference and unregister within the deactivate method
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
we shouldn't commit this change
We may need to put this behind the flag, especially if we want to back-port it to older GCS connector versions. We can enable it by default in master branch though.
Let's re-word this to a forced shutdown
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
This is missing maxTotalRows
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Will * <LINK_0> * <LINK_1> work as well?
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
When we will run this test on www.wowwiki.com it will fail. There is wgServer variable which we can use in this case, then append Special:Promote path to URL
Pretty sure this is also supposed to just be the localization key.
getUsage(...) expects a localization key.
getUsage(...) expects a localization key.
"robot explain --input <file> --axiom <axiom> --output <output>"  Default reasoner should is ELK (returned by CommandLineHelper.getReasonerFactory(...)) so the user wouldn't need to specify that. Maybe make a note in the docs? And if you link to the reason docs, they can see all available reasoners.
This expects a localization key
You could simply do super.setClazz(CommonLog.class)... You don't need to have a vaeiable pojoClass.
Assertion is missing for operator name
it is not really needed, we can simplify the code here
The setup of updatedKeyStorage is not needed if fireOnlyUpdatedPanes is false.
I'm wondering why we even need this class; can we not simply add a boolean property to the base class called "appendPartitionId" ? Also, the ticket description says "If SingleFileOutputOperator is partitioned into **more than one** physical instances then it should append partitionId to file name" (my emphasis), I don't see any check for that condition before appending the partition id.
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
This is missing maxTotalRows
Oh yuck. ;)
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Doesn't List as a Collection have a defined method to check whether it's empty or not?
idx -> index
can just do new ArrayList<ICommand>(commandMap.values()); instead of separate addAll
@treblereel , do we really need the 'list' instance here? Can't we build up the HashSet directly and compare its size with sortList size? Or even better, at that point can't we simply return the first time that the HashSet#add method invocation returns false?
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
discussed a bit more, we're going to make both key-values, and make sure to split on just the first colon
studentsWhoRespond -> studentsWhoResponded
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
same remark for the try with resource statement here. Currently the inputstream close is missing.
Could you check for null or empty? Via StringUtils.isBlank
these 3 methods are public do you really need them?
">=" would be robust, even though not possible as the code is now.
Symmetry (throw)?
This line should not be extra indented
Can lease.getStartingAllowedRequests() every equal zero? Might want to check for that.
withMillisOfSecond(0) is not necessary here if it is used above.
same here re: serialization test; probably worth having an example string to verify consistent serialization, would recommend a non-zero duration too (because zero will frequently be serialized on a different codepath to other things).
I much prefer the loop in @daryn-sharp's original code. Collection<Lease> expired = new HashSet<>(); for (Lease lease : leases) { if (lease.expiredHardLimit(now)) { expired.add(lease); } } This streams code will have to change if we want to pull this back to branch 2. I think @daryn-sharp also said that stream()'s are more expensive.
probably worth using safe-logging preconditions and having args for the incorrect leader ids
Verify the injector has been set before using the delegate here
Similar
Similar
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
It should throw exception
Please remove this line
Could this just be a plain getActivity() call? Any reason you need a BaseActivity for startSupportActionMode?
Can be transformed into an if statement.
So uh, this method is kinda necessary...
You can early return here
Is it the 'native snappy library' that is missing or the java-snappy jar?
In the original code, we throw a runtime exception if the native snappy is not found. Should we follow?  throw new RuntimeException("native snappy library not available: " + "SnappyCompressor has not been loaded.");
nitpick : final Throwable t
where are the corresponding cleaners for these direct byte buffer allocations?
This line String message = buildPrefix(nullSafeGet(messageOrSupplier)) + "Unexpected exception thrown: " is duplicated below. Merge both into a new private createMessage(messageOrSupplier, t) or even a createAssertionFailedError(messageOrSupplier, t)?
addPermissions means you added a permission, but it doesn't mean that no restart is needed... unless I'm missing something here.
u can simply use System.out.printf("Please enter a password for %s:",user);
Is there a need to have both asserts? The reason I'd prefer only one is that I don't want the user to get one error, fix it, and then get another. Since nonNull is implied by hasText, we can give the user only one error message that will repair both problems.
Kind of an anti-pattern here, this compiles into another StringBuffer allocation. Instead:  canonicalizedHeadersBuffer.append(key.toLowerCase()) .append(':').append(header.getValue()).append('\n');
there is no other way of getting article name?
I think this should be > 0 since a value list item of 1=One does not work.
If the input string is "(123(456)" this approach will strip the middle bracket and parse when it shouldn't. You'll need to use substring()
Is this still needed after removing the download stuff?
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
This could be made static
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
you can collapse these 2 lines
It doesn't seem that you did what I asked for. It should be checking the toggle in addition to networkinfo. If the toggle is set to offline then it should return false. If the toggle is set to online then you can check network info and if there's no connection set the toggle to offline and return false, otherwise return true.
I would simplify to return (activeNetwork != null && activeNetwork.isConnectedOrConnecting()) . No isActiveNetwork variable declared nor assigned, easier condition.
Can you separate it into two lines as because of the condition in check style plugin i.e. you can't put more than 100 characters in one line, the build is failing.
Pull this into a static final variable
You could have inlined this loop into the other method because this will create 3000 threads.
should this count be parameterized?
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
It would be preferable for the PutHammer to keep putting data until the main test method has verified that rehash has completed instead of using a fixed-size loop
Needs to be in finally - we might get interrupted.
should this only be set if the latch.await above returned true? in the current impl I don't think it would make a difference since clientTimedOut is checked prior to clientHasReceived in the if/else below, but that order could be a fragile assumption
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Well, with the squash GH doesn't see changes and don't notify via email. I have missed this change therefore :cry:
I would put the return 0L here. This is probably the one and only place where you do not propagate the exception
Cosmetic: Please, split the throws list clause on separate lines.
What if this path actually exists on the user's workstation?
Certainly getCanonicalPath() provides clean path. but this method always returns absolute path. It may need to confirm the logic is no problem or not...
suggestion Preconditions.notBlank(path, () -> "File [" + path + "] must not be null or blank");
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
No need for such harsh line wrapping, the style guide states it is up to 150 characters.
scheduleTimes --> scheduleTime
Can this be private, or is there another use case for default attribute outside the builder's call?
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
same as above with the actionBarWrapper
make it protected. It was my fault to make all API constructors private. I fixed that. In master branch all API constructors are protected, so anyone can extend API in their code if they want. But couldn't instantiate directly, forcing them to use singleton
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
space before constructor
it would be nice to assert here that the actionBar is displayed. (so if it is not visible, and onActionBar() is called, it already breaks here with the error that the bar isnt there instead of later that eg. the title doesnt match)
please use java.util.Objects.toString(username, "") instead
maybe use dnsServerAddress.isEmpty()
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
@dmzaytsev let's inline this
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
I haven't tested yet but the code seems ok
There is a slight chance that this View will be destroyed when this callback is reached. Therefore this should be protected by a check for isAttachedToWindow().
We can use the res variable here instead of getContext().getResources().
Right, it looks not that good to me. Changed.
Just devicePause, there is only one type of pause, so adding the word sync just makes it confusing.
Can this be private, or is there another use case for default attribute outside the builder's call?
I'm missing the new field in the toString method.
public?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
scheduleTimes --> scheduleTime
To make the tests more resilient to future changes, please pick values that are unlikely to ever be the actual defaults. For example 234MB and 11MB.
Same here, keep the order consistent with BenchmarkSuiteConfig
need to change as well
See if we can use assertFailsValidation here
hardcoded things shall be declared as class constants
Removing the interceptors removes logging.
This cannot be removed. The scheduled task needs to be saved.
Output the message that caused an exception, possibly at the FINE log level. Also include the exception parameter so we can see a stack trace.
Should we consider putting that 512 into the AmqpConstants to keep all the protocol-specifics in one place?
We need to avoid waiting until encrypt time to determine that the public key passed at initialization is incorrect.
Here and below: previously the code used only one table lookup operation, not it performs two lookups. Please consider to use get(name) and check the value to decide if it is illegal or not.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Maybe check for if name ends with ':' so we don't do a double one?
These should change to store the names in the attributes map so that you don't need special handling for all the places that handle the tags.
... remove the final modifier from the method. It will be easier for future tests.
Use this.key
Use this.key
Use this.key in place of Keys.SPAWNER_MAXIMUM_NEARBY_ENTITIES
This probably won't be the default value for many items, I believe these should be dependent on the ItemStack being provided to the DataProcessor/ValueProcessor.
the minimum shouldn't be restricted in this case.
why exit here ?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
The action for these terminal cases is now the same as for TASK_RUNNING; so we might as well combine those cases. i.e., Line 97 above is the same as line 104, and there is no longer this special taskTerminated method being invoked for the terminal cases.
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
not sure why this field is public
It's better to cache the values(), a new array is allocated on every invocation.
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
Don't we need to return something like -1 in the null case (i.e. when the type is not in-house one)?
Is this correct?
> Use emoveCallbacksAndMessages(null) to remove all the messages. > Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
refreshJob field should also be set to null on dispose.
> Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
done for patch3.
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
I'd recommend using <LINK_0>
Please format this as:  command.stream() .map((String s) -> "\"" + s + "\"") .collect(Collectors.toList());
Why not just include FlagUsageException in the throws here and then if it's thrown it will still count as a failure.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Its worth adding a null check here too.
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
Collections.singleton?
What's the point of adding a copy here?
That's good to know.
This needs to check if the type is not a Class and throw an exception with a meaningful message. The implicit ClassCastException that's thrown here is unsatisfactory. Also, does this mean I can't use LoganSquare on a List of objects? That's really strange...
different value 50 versus 1. Is that intended?
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
Should be a SamzaException with a message, not NPE.
Perhaps you should keep this, and at the close of the pool, then also close the PRNG object to avoid re-seediing in background when not needed.
why do we have a ; here?
remove redundant ; it will only cause static analysis to complain
previous naming was more clear.
Can we refactor both of this if else if into one condition ?  java if (!accessToken || (accessToken && expiresIn() <= 0)) { accessToken = generateAccessToken(); }
Don't we also need to interrupt a thread if it is interruptible? (to cause calls like Thread.sleep() to be interrupted).
Probably makes sense to move this up too.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Saving preferences inside a setter is not appropriate. Please follow the pattern used for other preferences.
Use IResource.adaptTo(Class).
any particular reason why this method doesn't require an IJavaProject ?
are spaces OK in namespace strings?
as above: are spaces OK in namespace strings?
suggestion return Optional.of("org.junit.platform");
Each of the getters in a POJO like this should have the same return type as the private member variables they expose. In this case, I'd recommend having extension, dateformat, and frequencyOverride be Optional<>s (in both their member variable types and their getter types). Our Jackson YAML deserialization should automatically take care of setting a missing field to an empty Optional<> in the resulting Java object.
this.
fos can be inside try ()
Should that be 8192? 8024 seems like a strange number.
I think try with resources should be used.
use <code>logger.debug("Using charset {}", charset)</code> instead.
outputStream is never used
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
redundant ";" character
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
Do you think we can use an [unmodifiable map](<LINK_0> here?
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
For loop?
For each?
nit: what about java nulls[i] = i % 7 == 0  ?
It is not necessary to check value in compressed vector on zero. It is guaranteed that only non-zero values are store. Which means, that we only need to rename each to eachNonZero in CompressedVector class. Please also make sure that MatrixMarketStream uses the proper iteration method. TIP: It should be eachNonZero.
Nevermind, I see it is the Future.get() that throws the InterruptedException.
what's the difference between checkAuthAttributesAreValid and areAllAuthorizationsForResourceValid? I thought that the plan was to replace the former by the later, right? Since areAllAuthorizationsForResourceValid can perform all of the work that checkAuthAttributesAreValid performs. And in fact checkAuthAttributesAreValid only makes a number of calls to isAuthorizationAttributeValid. I think it may be the source of potential security breaches if we maintain both methods and a user ends up thinking that it's safe to only call isAuthorizationAttributeValid when in fact, areAllAuthorizationsForResourceValid should be also called. Please, correct me if I missed something.
you shouldn't need it as UnknownUserException extends LoginException
Unnecessary.
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
Is this reload really necessary?
If resources are not dependent on each other, reload after adding isn't needed. One reload after adding endpointConfigurationAddress and one after adding both preHandlerChainAddress and postHandlerChainAddress should be enough.
"Clean orphans from PROPERTIES" to be exact ?
minor: key_type instead of key type
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
Do you have time for this? We talked about it on Slack.
I think we should leave getClassName() and getMethodName() as is but _only_ pass them to PojoStackTraceWriter to "optimize" the stacktrace.
It's not a _really_ expensive computation but how about using orElseGet?
You do not have to use brackets in ( isFailedContainer || testIdentifier.isTest() ). There is no collision between boolean and String in this case.
suggestion this.className = requireNonNull(className);
probably don't want to keep filling this map up as we browse around. could just use getOrDefault?
Actually the underlying objectExpr could have free variables.
return ImmutableSet.of();
If an assignment strategy doesn't implement movePartitions and if the operator calls movePartitions, It is better to throw rather than silently return. This way it is clear to the operator that movePartitions is not supported for the connectors using this assingment strategy.
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
You could probably use the same URL as in getResultById here.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
Should this refer to a platform-relative constant?
Well that's a bit dumb :/ Ah well.
If you have to cast here then you probably should have casted when reading the value from the data array.
Use Guava hashCode function
This needs to be changed to return the long value.
use use java.util.Objects
Change to use this.jsonAsString.hashCode().
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
return (getTag() == null ? 0 : getTag().hashCode());
return (dataCollection == null ? 0 : dataCollection.hashCode());
Could you update this method to include "AbfsPerfInfo" introduced by HADOOP-16612?
Should this constructor one just delegate to the new one with Function.identity()?
extra ()
Args.notNull
path
super.init() method never throw an exception.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
Throwing the generic Exception ?
Parameter should be true here, no?
Why do you call this method of superclass? As I can see this method is annotated with @Before by itself. No need to call it again.
I feel like we should be able to take out a lot of these nullity checks. Let's keep this in mind for a future refactor.
Here's another reason for why magic numbers are considered evil: This time it is six 9s. Over in AbstractWidget it is _five_ 9s. On purpose? Bug? With a public static constant you wouldn't have to worry or ever have to make a change in more than one place :-)
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
no braces here, more occurrences in this file
I guess this should never happen in theory
This cycle has very confusing brackets. Could you please add brackets to if and properly tabulate the last bracket?
Here's another unsafe cast that can be changed to use mapperType.cast() instead.
Make this final and since we know how many tasks we're dealing with, make sure we're creating a list with the right capacity.
if implementations is empty, this method will eventually return an empty (immutable) collection. We should throw an UnavailableImplementationException instead to indicate an invalid state or spi class.
Lets pass the ListIterator constructor as method reference and do not subclass it: java return new SeqAsJavaList<T>(seq, (delegate, index) -> new LinearSeqListIterator<>((LinearSeq<T>) delegate, index));
This one is already done on line 816. Do we need it again here?
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
- you can simplify this to model.getSelectedDataCenter().getId() - I believe for Blank template the model.getSelectedDataCenter() returns null and you will fail on NPE here.
It would be cleaner create a new overload of this method, without the 'datacenterId' parameter.
Likewise.
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Should use the log, maybe a warning.
A CoreException doesn't necessarily indicate that the member is not owned by the class. Logging and re-throwing the same exception causes double reporting since the re-thrown exception will be logged or reported some other way elsewhere.
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
Is it worth distinguishing what is null in this case? Is it different if m_txnState or the invocation is null
Remove the redundant null checks.
If there is no Auditor or no AuditTask should we fail the test ? Or shall we wait for an Auditor to be active ?
For lists not marked @Nullable we should return an empty list instead of null (or mark them @Nullable if appropriate).
what happens if you call this several times? It will recreate again and again the asked number of threads. You should have some flag to specify that it's already started no?
with 10 threads I can almost always reproduce the bug.
Suggested to extract a static utility function zeroOut(ByteBuffer)
if the advantage of this compare to 0 <= b && b < 256?
Pull this into a static final variable
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
I have doubts about this code. It means "a single-line case/default must end with a break, otherwise it needs a pair of braces". For example, this code raises two violations regardless of allowSingleLineStatement option:  switch (0) { case 1: return; // false violation default: throw new RuntimeException(""); // false violation }  and they can not be fixed by adding a trailing break. Why not check the last child's line? Something like  private static boolean isSingleLineSwitchMember(DetailAST ast) { final DetailAST slist = ast.getNextSibling(); return slist == null || slist.getFirstChild() == null || isOnSameLine(ast, slist.getLastChild()); }
it is strange to see all those code to handle null if we are using optional...
@mariebawanan I think the proper fix for this is to remove the duplicates in variables VariableTypeList instead of just filtering out the duplicates here.
We can slightly simplify: java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType());
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
correct thread safe code looks like this: if (stopped.compareAndSet(false, true)) { cancel(); }
The Exception is never thrown.
The Exception is never thrown.
@dpgraham I think it is more senseful to throw an exception. Otherwice we have a risk to produce and invalid build or to not react to server changes.
Aren't there any chance that super.inputStream() **is** already PushbackInputStream, so, we don't need to wrap at all?
suggestion "A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.");
The above 2 set* calls don't make any sense other than the fact that the call generates a logger.info line. Note that connectRetries and reconnectRetries are defined only in AbstractSolaceBaseInputOperator so super.setConnectRetries(this.connectRetries) assigns a variable value to itself via a function call. Need a reason for this code.
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
The super() call seems redundant.
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
I thought empty was OK, and it would point to latest?
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
You could use StringUtils.endsWith(str, suffix), since it's null safe.  java return StringUtils.endsWith(version, SNAPSHOT);
It is not enough to judge empty. You should also judge the value > 2.7.0
Can this be private, or is there another use case for default attribute outside the builder's call?
Please remove this field.
shall we rename this as brokerUrl ?
Same here: should be Branding, not ProductBranding
I'm missing the new field in the toString method.
merge else if?
how about doing it a bit different: change #1259 to something like: devices.stream().map(VmDevice::getId).forEach(vmDeviceDao::remove) and this method to something like: removeVmDevice(devices.subList(...))
don't need to wrap safeFormat
int rowCount = model.getSize(); Then the code in if block can be shared.
This is starting to look like something we might want to move to a separate list with the "overflow options". If the index is greater than getSize() - 4, we just get OVERFLOW_MENU[getSize() - OVERFLOW_MENU.length] This way we could maybe also get rid of a few hardcoded numbers.
I think it is done on purpose to avoid auto boxing/unboxing.
To be sure, we choose this format: blobExpression == null ? false : blobExpression.isLiteralText(); regarding this one: blobExpression != null && blobExpression.isLiteralText(); ?
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
1. In general, avoid expr ? true : false pattern and simply substitute that with expr. 2. Ideally, this check should be ... == (byte) 1 or (... != 0).
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
no!
This is good, this thread does not cause the bad failures and dealock anymore. But it should mark the analysis as failed. And for very large traces, I think some failing mechanism should be put in place, to cancel the analysis. For instance, the waitForCompletion could wake up from time to time and make sure the analysis has not failed in the meantime. While this works perfectly fine, resources on a computer _are_ limited and it is better to avoid dragging this thread, and the request thread, and the threaded backend thread and some more view threads waiting for this, imho.
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
This could be moved to VampirePlayer#onEntityAttacked. But I guess it is fine here too
This class has no superclass, so I'm not sure we need to call super() here.
You should also update the error message in order to tell users that this option can be used in order to switch the duplicate field validation off.
Now that services are class members, we should not need to pass them internally in functions either. Please remove them from parameters and access directly in other functions. This needs to be done for all instances of ontology and germplasm data manager services that are being passed in function parameters. I will fix this @abatac while I am syncing master.
Do you want to update this one to make sure that the key _and_ the value are there?
Can you revert this change? toBlockingObservable() is deprecated in 0.19.
why is this method public? why is it static?
Done, it looks like the change was not included in patchset1.
@jmmut should these checks be placed after the variant object has been constructed? I remember there was some weird situation with code being executed after the checks.
We generally prefer assertThat(..., is(..)) for better error messages.
Suggestion: "--active and --inactive options are mutually exclusive."
this check doesn't answer on question in test case, I would create another test case for it, or rename the test case
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
The agg function here should be adjusted to support the optional compression param like in the quantile version
can you explain why this change ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Copy paste code block? Split it out into a function please.
Ik. Maven has logging facilities. We should use them.
Use IResource.adaptTo(Class).
local variable e is never used.
Probably makes sense to move this up too.
We can use defined constants for project natures at org.wso2.developerstudio.eclipse.platform.core.utils.Constants class
one more method where it can take file location of properties would be good.
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
What's the point of adding a copy here?
usually data objects never return null where collections is met
we should not modify the original properties. I would just return properties; here
close streams
I think you're missing getDefaultConfigurationFile() here.
Again, use IOUtils.
I don't think the process deploy should fail in the case of temp file deletion fail
we can use try(BufferedReader...) {}
Needs some sort of assert to show it succeeded
Just for fun ... I'd fid it more readable to have a static import of Mockito.mock() (this is a complete detail, feel free to ignore).
please use static import for Mockito
This instance variable can be inlined.
@cyberone no need for Mockito.times(1)
You have yo use compareAndSet
maybe we don't need AtomicBoolean?
This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)
closed.compareAndSet
minor: change SocketNetworkClient to LocalNetworkClient in line 98 and 102
Why going for semantic here ??
"plugins" could be replaced with ConfigConstants.DEFAULT_FLINK_PLUGINS_DIRS.
requireNonNull
return this.parent == null ? this : this.parent;
Please use parent.is here!
minor, is it method scope for Visible For Testing? If not please change it to private.
there is no need to convert to map. can we directly print headers ?
I think we should have a better exception message, it should state that the header is not allowed to be set by the user
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Inconsistent format! space after comma
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
No need to put before/after annotation since the class is extended from TestCase, We can simply remove the inheritance from here and use the annotation, I favor annotations over inheritance in test. Don't remember why I've extended it at the first place
Please follow existed coding style and put new line after Override
Instead of an empty implementation, make this an abstract method that the subclasses need to implement
This should always be read from the configs.
Why should the About dialog no longer be resizable?
I suppose this should be true ?
Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.
Why show the 'MoveUp' button by default?
Why is this removed?
we need to reset this property in a @Before block
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
Use junit5 instead we are thinking about removing Junit4. There is a way in junit5 to write nested tests <LINK_0>
Don't forget to disable the CrashReporter as well :wink:
Could we prefer a proper logger instead of System.x - we already have a logback.xml in the module.
Use Logger instead of sys out.
Debug still needed?
pvk should not be visible. Please remove it.
remove debug printf when submitting patches.
Assert.areNull
Please use the correct "assert" versions. To check for equality, "assertEquals"
@gjd6640 how about making this more explicit and robust this way:  int windowsOffset = System.getProperty("os.name").contains("Windows") ? 1 : 0; assertTrue(firstHighlightingData.startOffset()).isEqualTo(1 + windowsOffset); ...
there is no need to wait here?
Optional: consider using assertTrue(EXPECTED_EMPTY_CAN_DO_MESSAGE, canDoActionMessages.isEmpty())
You can remove the inheritance from translator and make this method static. So you won't need to create any instances of EnumTranslator.
suggestion return format("metadata[%s]", key);
should use a format placeholder instead of string concat
I would prefer if you use String.format here. Also, have hyou thought of log.debug the stacktrace?
This can be problematic. createAndTranslate(..) returned constants.notAvailableLabel() for null object. while get(...) returned null. You have to make sure no one of the usages relies on this behaviour.
We can't do this - breaking change for anyone that has subclassed and implemented destroy(). I suggest we use // NOSONAR TODO: remove throws in 5.2, which removing it from our subclasses.
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
The operator should be && not ||
The exception message doesn't reflection reality:  "no query or collectionCallback is specified"
Please keep this.cell near the related fields (previousFamily & cell count) below
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
missing final
Same here... completeLoadRequest(request) ?
We could just always use the body instead of flipping based on the payload size.
should be named resource
flagging that we should fix this in the next major version and move back to a parameter for the id
should be called resource
should be named resource
should be called resource
This needs to be changed to support locked stream syntax now.
I think this is main issue that needs to be resolved. The problem is that this implementation can consume a lot of resources because of the retrying and the long latency. It could even end up in a livelock. The best approach is to get everything done in a single remote call. There is no retrying needed here because the operation will have exclusive access to the partition.
I think it'd be a bit cleaner to move the value type check into nullSafeValueHolder.
I might be wrong but vValueHoder may itself be a null, if there was no mapping for the key.
If/Else to avoid unnecessary assignment?
"else if" maybe?
Theoretically it would save a memory allocation and garbage collection to just return value;. Maybe Hotspot will optimise this in practice. Same in the other file.
If you check for Collection wouldn't it be better to work on the collection interface (and perhaps create a new list) instead of rely that the collection will always be a list on this place (if it is the case, then use instanceof List.
Would it make sense to add a String.class entry to POJO_TYPE_MAPPING instead?
Do we need to handle BigDecimal as well?
should be logged only once, not for each block (spooling is either enabled or disabled).
extract out into a const?
what about outWriter? Move this stuff up into the blocks, so you cannot forget adding it here.
Lets' throw TechnicalException to keep the pac4j spirit...
@maria-farooq we should provide a description to the log message
This is not necessary.
unused variable
Why don't we make inDegrees to ConcurrentHashMap also?
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Why is no this. used in lines 320-321 but this. used in lines 322-326?
It's safer to call getProperty("replicatorFactor", DEFAULT_REP_FACTOR). You should validate the arguments as well.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
is there a reason why this method isn't implemented?
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run.
This code can be called from RefreshVdcOptionCache() method too, instead of it being written there also.
I would consider rewriting as: if (values == null) { values = new HashMap<String, Object>(); _vdcOptionCache.put(option.getoption_name(), values); } values.put(option.getversion(), GetValue(option));
why not using addAll?
Maybe remove the OrConstrained here too?
This could be entirely done as a stream.
It is possible to write this and preserve types (e.g. avoid SuppressWarnings). I'm pretty sure it can also be written using generics (vs Object) but didn't have a chance to finish that.  public static Object[][] cartesianProduct(Object[][]... dataProviders) { List<List<List<Object>>> lists = Arrays.stream(dataProviders) .map(Main::nestedArraysToNestedLists) .collect(Collectors.toList()); final List<List<List<Object>>> product = Lists.cartesianProduct(lists); final List<List<Object>> mergeProduct = product.stream() .map(list -> { List<Object> result = new ArrayList<>(); list.forEach(result::addAll); return result; }).collect(Collectors.toList()); return nestedListsToNestedArrays(mergeProduct); } /** * @param dataProvider a nested Object array * @return an equivalent nested List */ public static<T> List<List<T>> nestedArraysToNestedLists(T[][] dataProvider) { return Arrays.stream(dataProvider) .map(Arrays::asList) .collect(Collectors.toList()); } /** * @param lists a nested List * @return an equivalent nested array */ public static Object[][] nestedListsToNestedArrays(List<List<Object>> lists) { return lists.stream().map(List::toArray).toArray(Object[][]::new); }
This should be more efficient as rows.toArray(new Object[rows.size()][] so that the list doesn't have to allocate a new array to populate
It is not necessary to test REPLICATE region in this test.
It is here that runtime.matchesFilters(pickle) should be used to select the pickles to run.
Also added a try with resources here.
RocksDB reference.
remove this?
Should be added the Override annotation.
please rewrite to not use continue, harder to track code.
How about:  int size = Math.min(b.height, b.width); setMinimumSize(new Dimension(s, s)); setPreferredSize(new Dimension(s, s)); setMaximumSize(new Dimension(s, s));
This used to be mBoardSize.height + 1...bug?
You don't need this line because of green 31.
nit: debug? the same for the other new logs in this file
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
Please add the 'can not recover' back? It clearly tells why we must abort the region server.
suggestion "part of a group or is participating in a rebalance right now. You should first call poll to complete " +
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
Please take into account that t could be null.
Might this be a valid spot to use package private level access instead of public? Since the test is in the same package just under engine-tests? Can't entirely recall if it works that way.
given/ execute/ assert
Since listener execution order isn't guaranteed, do we want to validate this this way or just .contains() each of the values?
I would add in reindexing at least one ref tag to show if it updates correctly.
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
Not worth debugging for this QS
Not worth debugging for this QS
Not worth debugging for this QS
Why does the message refer to Logged store here?
why not this String nodeSourcePoliceClass = StaticPolicy.getClass().getName() ?
hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm! so we cannot validate this on gwt, but I do want to validate it at core. can we have something conditional? if the isAssignableFrom works then perform validation else not? when gwt will not use these classes any more we can just remove the conditional.
Might make sense to use a RowMutation here and have the PutAdapter take a MutationApi interface
Should this use RANDOM_PORT_INDICATOR instead of 0?
I don't know if we ever call put twice for the same key, but null effectively removed the previous value in the method's "before" form, and now it doesn't.
Why not use null instead of ""?
Don't we have to say that this is uniqueId JDBC?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
nit, Collections.EMPTY_MAP?
studentsWhoRespond -> studentsWhoResponded
Thanks for this clean-up throughout the code! I should probably start enforcing fcrepo4 code style rules sooner rather than later...
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
just use context as synch obj
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
One more - this will be 3
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
[Checkstyle] ERROR: '{' is not preceded with whitespace.
Correct me if I am wrong, I think here should be numberOfKeys * ( keySize + SIZE_OF_BLOB_FIELD_IN_BYTES )
Aren't these static strings held and reused? We shouldn't have to charge for the weight of the merge strategy string. Actual memory used per entry is pointer sized not string length.
is Options.INDEX_ON_THE_FLY the same as Defaults.CREATE_INDEX?
I feel like there should be a Defaults.toString() or similar for this sort of thing...
Any way to combine both of these try blocks, since it's basically the same error message?
I don't think we need to retrieve a liveChatId here (lines 69-78). (The liveChatId is not used elsewhere in this method.)
Since we're changing the exposed contract anyways as we rename the file, could we fix the visibility of this function as well? I know the visibility is copied over from the old location, so we can leave it as public as well. I'll provide a separate patch set for that then.
any particular reason why this method doesn't require an IJavaProject ?
are you sure we need to use OSString ?
I'd move this method to the end of the file, so that order of declaration corresponds to use as createOpenAction -> getSelectedPaths -> getRepositoryPath.
Overly complex. Just say: Repository repo = repoManager.openRepository(...); try { ... } finally { repo.close(); }
I still think a couple of helper methods will make the tests easier to read: private void setBare(File gitDir, boolean bare) { Repository repo = new Repository(gitDir, null); repo.getConfig().setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_BARE, bare); repo.getConfig().save(); } private void setWorkTree(File gitDir, File workTree) { Repository repo = new Repository(gitDir, null); repo.getConfig().setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_WORKTREE, workTree.getAbsolutePath()); repo.getConfig().save(); } Then the tests are a bit more declarative as they setup their condition to be tested.
This should be 10 << 20 so that the default is 10 MiB. That allows users to specify configuration with standard suffix units e.g.: [merge] inCoreLimit = 10m for a 10 MiB limit.
This is an opportunity to stop the bleeding for this naming standard. I would suggest using the bean naming standards that archaius uses.
just return ListeningExecutorService
static
does this happen or is it an error? Maybe just throw an exception.
given that specificity of this SV is exception type I would add the exceptionType in this.
code format
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
Are you sure that it's a good idea to have such output  ChePlugin{editors=[....]} PluginBase{name=qwe...}
minor: probably add the super.toString() output within the { } brackets, so it is clearer that it is also part of the same object? (same would apply to other toString() impls) Current version looks like this: CachedDataRecordWithStats{cachedValue=null} DataRecordWithStats{value=null} AbstractRecordWithStats{lastStoredTime=-1, expirationTime=-1} AbstractRecord{key=null, ttl=0, maxIdle=0, version=0, hits=0, lastAccessTime=-1, lastUpdateTime=-1, creationTime=-1, metadata=null} suggestion + ", super=" + super.toString() + "}";
This will add the flag to *all* read-resource operations. I'd rather add it only when necessary as suggested at <LINK_0>
shall it also be >= 0?
If the variable name is normalized on the set() method, is it necessary to normalize on the get() as well?
just return "" instead of new String()
Might be better to have dao.exist() and call it, but OK to do that later.
are these setters used anywhere?
this works only until you maintain the order with the values. Safer is to write it like this: return Arrays.stream(values()).filter(e -> e.getValue() == value).findFirst().get();
Help me understand why lazySet is safe to use here. It seems we want to have visibility of this value when we next read, but my understanding of lazySet is that it does not guarantee that.
Need a metric for ignored large messages rate. Should also log them, not ignore them silently.
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
this is not thread safe, nodes can be modified while building the subgraph. I suggest to use Lock for reading and writing accordingly instead of synchronized blocks
The local var is useless, you can remove it.
For objects we provide human readable NullPointerExceptions. Please add a  java Objects.requireNonNull(clazz, "clazz is null");
why simply not call BaseBackendResource.validateEnum(Class<E> clz, String name)? (instead of EnumValidator.validateEnum(reason, detail, clz, name), this why we will not have to maintain localization in two places)
Maybe add protected as modified on this and the other two package protected methods to match what is done for setValue?
I'd still prefer to have the operation for generating the 'key' for a muted topic to be a separate function, or even embed it into the Message object. for example:  mutedTopics.add(message.concatStreamAndTopic()); ... // in Message.java private String concatStreamAndTopic() { return getStream().getId() + getSubject(); }
return void
how about  java private boolean needAck(Message message) { return message.getSequence() == message.getBatch().getWindowSize() }
Is this the intended message?
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
This is now hard to read since it combines two multiline expressions. Please break it up into separate expressions and use suitable variables for each value.
add braces
I guess this doesn't really matter but we normally use toImmutableSet so just keep it consistent?
I wouldn't have thought DoubleStream.of(argument).distinct().count() was that fast?
Same here, it could be a keyword argument. Not sure we need to cover it though, but if you eventually decide to cover it, don't forget to separate mode and padding for Pyca.
instanceof Dataset is redundant
Something to think about: if all of the DataModel types have a specific view type, then you could add an additional generic parameter to MockChartDataModel for the view type in addition to the dataset. This would allow you to move the view field up to the superclass.
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
I think we are doing too much outside of View rather than finding a good way to delegate to a View. We rely on a view's underlying implementation to work, and in this case we don't even throw an exception if that assumption doesn't work (which we should). I'm fine with this as long as it is temporary, but I think we should be delegating more to the implementations rather than relying on them to follow the standard pattern.
ErrorCallback to close "busy indicator."
pull this out into getMockAuthorizer() {return getFileSystem().getAbfsStore.getAuthorizer()}
I think we can still end up with < max threads in the following case: there is only 1 thread doing work, rest are waiting on queue.poll the thread is going thru files or the list responses are slow. it is yet to queue up any subdir. The rest of the threads timeout and fall of their thread main
1. close() the stream and ask for the stats again, to verify they are still readable 2. call toString on opened and closed streams.
after the seek and read, can we also check the actual data in readBufferForReadAhead?
Space needed after "failed"
This will remove description set, please remove.
Maybe the simpler thing is to send the content type as "application/x-xsrf-token" and have the server require this as the content type of the POST body. This makes it harder for a browser to format a valid POST request using a traditional <form> tag. It also means the server won't attempt to parse the _token field from the POST into the parameter map, which means you don't need the _token hack in the CmdLineParser loop, and you don't have to worry about + or = being incorrectly handled somewhere by an incorrect escape. Alternatively we make the GET return valid JSON of {_token:"text"} and we echo that as-is using a JSON content type in the POST. Just as simple for most script language tools to work with, the client just has to strip the first line of the response body from the GET (to remove that JSON_MAGIC literal) and echo that as the POST body, with Content-Type set to JSON_TYPE ("application/json").
This will remove description set, please remove.
Why does it need any change?
check null for req?
There is no need to set the local scope reference to null, but if you prefer...
I would prefer to use System.nanoTime() for such time, as it is independent of the system time and cannot be corrupted by time changes.
Also wondering the case: if Bolt points invalid streamId (not matched with parentStreamId of Spout/Bolt) so could **validation** be required? (to cover this case either **fail-fast** or **warning message** due to redundant Bolt)?
Comparing to the old code, there is a race condition now where two threads could create two streams and assign it to the stream field. That will cause one of the streams to be dangling. The questions is whether this is a significant issue and whether the contract for this class disallows concurrent calls to connect(). If we decide this is significant, we could wrap this function in an additional lock.
declaredOuputStreams is too verbose. the variable/method can be outputStreams/addOutputStream.
matter of taste, this could also be return this.profileTypeRegistry != null;
Can you make this if clause a block by using {...}? Supposing somebody enters a new line accidentally, then this method will end by returning false always.
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
nitpick: just return <cond> sufficient
Its probably a matter of preference, but you can just do return getDelayTime(ingestTime) > TRACKER_DELAYED_METRICS_MILLIS
Can this be private, or is there another use case for default attribute outside the builder's call?
Same here: should be Branding, not ProductBranding
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Looks ReflectiveOperationException is good enough. Why Exception is used?
Is value == null a valid case here?
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
No need for super()
calling super not needed
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
nit: Same here. Leave the checks in the switch and do the assignment at the end: this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
Do we need to start deprecating some of these cases if we are going to just combine them?
This should be cached in the constructor.
this could be handle by Map, key -> value
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
What happens to dst and copier in this case? try-with-resources style wouldn't try the close() again, so should we retry the close to prevent them from leaking?
AFAIK Writer::close throws IOException, so there is posibility that exception is thrown by flush method will be suppressed.
closeQuietly or whatever its called?
Why uppercase fs?
I would suggest using the related constant instead.
I would suggest using the related constant instead.
I remember I made this tests to starts cluster only once. That will improve tests time, You may want to have a look at corresponding ViewFileSystemOverloadScheme test class now.
Is this change correct? I see header is getting set with format(secondcol,2)
I would just delete the version check from master. The logic is very simple and unlikely to cause clashes that are hard to resolve even in the unlikely event of someone adding another field in the lifetime of 7.x.
Should we add null check?
suggestion if (in.getVersion().onOrAfter(Version.V_8_0_0)) { // TODO BWC for V_7_9_0
4.2
Should be: in.skipIds(); in.skipId(); in.skipIds();
use return ... ? ... : ...?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
How big is the overhead to do this check on every log?
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
use constant for UTF-8
A little sanitization here would make a lot of sense, if nothing else make sure no ' ?
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
String.format might make this a little neater and easier to read.
[nit] There is also a cleaner approach using Guava:  java return Enums.getIfPresent(LoadbalancerAlgorithm.class, value).or(UNRECOGNIZED);
Use Enums.getIfPresent like in the previous enum or change that one, but make the code consistent using the same pattern when addressing the same thing.
Send this exception to the log.
rename to segment
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
Can the current method be executed on an other thread than the UI thread ? The layout command might need to get the figure info wth ui thread access.
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
I prefer to use the member "instance" instead of the return value. It's a little bit of confusing.
I am pretty sure this won't work, you can't re-use the model for the popup.
could this block be simplified?  java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; }
All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);
Catch exception.
How about including Loop will be retried in the message (like WorkflowExecutorLoop's Uncaught error during executing workflow state machine. Ignoring. Loop will be retried.) so that we won't be shocked too much when server shows this message?
or("") should be orNull() because the default value is defined as null.
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
Use constants
checkNotNull
With zero knowledge of the code, are you sure this object is not reused? Because if it is a scheduled task it be just reset rather than recreated, but you cannot reset the telescope client, you'll need a new one.
Which type would be assigned in this case?
Why don't we make inDegrees to ConcurrentHashMap also?
the workspaceitem needs to be deleted
Why Exception instead of Throwable like we did for before()?
Instead of an empty implementation, make this an abstract method that the subclasses need to implement
Can you assert the container has the right name?
nit: might want to rename it as signalShutdown or something to indicate that this method will be called before shutdown.
final?
Binary output length can also be calculated.
If the partition being replicated is sealed, should we reflect that here? (Not sure if we have that info available.)
Why is this not singleton?
You don't need to override this, every Spark 2.x distributions support kafka on kerberos regardless of the value returned by this method.
You may also want a test case for a search value that is non-blank but invalid.
This should be public
Have this call the other tryEvaluateWithAll method
we should have another vowel check for columnType.
We need indefiniteWowel1 and indefiniteWovel2 as we have _two_ types.
Can be reduced to throws IOException.
Can be reduced to throws IOException.
I would add the other createTempFile method to enforce the fact that we explicitly target this one only.
other than the previous implementation in subclasses this doesn't create the directory anymore.
dare to extract a constant which increases visibility for this hard-coded value?
Should we add null check?
Assert there is no JPrimitiveType in types?
why do we have a ; here?
Remove ?
remove redundant ; it will only cause static analysis to complain
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
copyright
needs filling in :)
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
please replase MojoExecutionException for a new generic DeploymentExecutionException
same as others: log should have Exception as arg
Consider using getField() instead, ~~it's implementation in OpenJDK 8 seems more performant.~~ Also the semantics of that method apply better in this case, since it is a public field. _Edit: can't confirm first claim_
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
KETTLE_LOGGING_REGISTRY_PURGE_TIMEOUT should probably be a constant in Const.java for consistency with most other kettle params. I know KETTLE_MAX_LOGGING_REGISTRY_SIZE was already there before, but should probably also be defined in Const.java.
Which type would be assigned in this case?
Why don't we make inDegrees to ConcurrentHashMap also?
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
In my testing on Linux I see another SWT.Selection between MouseDown and MouseDoubleClick?
I think we should remove the following events
This should be an @Override of implemenatioin super type..
I would remove all these events after the SWT.MouseUp. They aren't normally sent when you only select an item.
I've always been slightly confused by this - is this only used for the pause before we start sweep? If so, it might be better to defined the backoff time you're adding completely separately from the definition here, unless it should always be 5x this one.
14_000_000
You should be returning the values returned in getCalculatedProlepticMonth() here instead (ie, that leap-day is accounted with the 7th month, and year-day with 13th). Ditch the other method.
Can we get some more information on the magic numbers here?
(ONE_BILLION_L * fClockOffsetSeconds * getClockAntiScale())
As there's no extra handling when an IndexOutOfBoundsException is caught, both old and new code behaves the same way: any exception thrown by logicalPages.get( page ) will always be thrown back! As so, the try-catch is dispensable and it's best to leave the code as it was.
Duplicated code, try to share/reuse.
Duplicated code, try to share/reuse.
I don't think that throwing an exception is necessary. In majority of other places I think we have just empty private constructor.
Why not inject it using guice?
get rid of "..." not enterprisy!
Can use java 8 paths.
Is there another place where we can define this, so that this does not need to be defined in RealVoltDB as well as here?
remove whitespace
Remove throws Exception
move this line before above line, After super.cleanup method couldn't do any of the server requests.
As noted above, just put the init code in init() unless there is a reason not to.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
super.init() method never throw an exception.
Throwing the generic Exception ?
You should use ThreadContext.putAll() here.
Unnecessary (and incompatible); revert.
Typically we use Map on the left hand side rather than HashMap
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
Same question
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
Maybe let the stop() method throw the exception instead of catching and printing?
Is that safe to call when not holding it?
I think Long.MAX_VALUE is too long. How about using 1 hour?
this should be like other errors.. create EngineError key and a corresponding message in vdsmerrors.{java/properties} files then throw a EngineException with this key
"Initial connection"?
:smile: We prefer to use fail("BeanDefinitionStoreException expeted.") within try...catch
I think your tests would be cleaner and more clear if the validation methods returned true/false instead of throwing an exception. If there is a good reason to keep the ValidationException then I think it would probably make more sense to have a boolean local variable here, something like success, that is initialized to true and then set to false on catch. Then you would have a single assertTrue statement at the end: assertTrue("The counts should be been the same.", success); The same goes for all the tests in this class.
y not use @Test (expected...)
What is this for? Feels like some unintended checked in code?
You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure
You can use try with resources here so the Input stream is closed automatically.
Is it OK to swallow this entirely?
@xxDark can you link to the spec where all of this is explained ?
Add message to new RuntimeException
I guess all this (and the finally/close) can be simplified with try-with-resources.
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
.endsWith("'sParty") has an implicit semantical meaning and therefore should be put into a dedicated method. I'd guess something like boolean isOwnPartiesChannel(String name) But just comparing the end of the name sounds really... odd?
Should this method be private or protected?
Racy. Maybe just chuck a synchronized on.
Please put the elses back in here and make it explicit. Sometimes messages use inheritance and it seems possible a future bug could hit two branches.
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
Delegate to isNonCodedDrug() when making the check.
Remove?
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
delegate=true style would be just fine.
need to remove this print or convert it to log stmt
Shouldn't options be Immutable?
throws TaskException is part of the interface, did you mean to remove it?
Is it useful to keep the Exception generic, or should we narrow the Exception type on the interface?
Does this need to be public? Please do not introduce new public members without cause.
Config class have constant defined for default config file name
The <Integer> can probably be omitted.
EmptyConfig.INSTANCE?
It seems that all we should need to refresh the schema is the config name.
please remove empty lines before } lines in this class
Can you please compare something else than integers (String will be ok)? Silly code change in assert method can break its logic but pass this test because both index and value are 2 :)
Not sure if it tests "immediately", this test passes without changes in this PR. Maybe you can avoid going to another thread and awaitTerminalEvent()?
Could be inlined here by using test()
better to check values
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
This needs an @Override annotation.
style nit: s/if(/if (/
This is fine, but why did you think of changing it to protected ?
missing @since tag
Include the file:// as constant.
consider to inline uris
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
this.
You can use CollectionUtils.toImmutableList
Nitpick: startingCounter?
You increment just one of the counters. The total is produced by prometheus automagically. So basically, we could have: starting_attempts.total#debug=false and starting_attempts.total#debug=true and just increment one of them here. We would not have an untagged counter at all.
This is using the default locale when converting to bytes. Not sure if that is a big problem since changes of the locale should be fairly rare and under our control, but still..
Due to a bug in GWT this doesn't work in Firfox [1]. To make it work with all browsers it should be: event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER [1] <LINK_0>
Do we need to remove the reservations here if the member is no longer the replica after rollback, same as for record stores?
Type casting again.
Type casting again.
Using a try .. catch block instead of pre-checking with contains is bad code style and also not very _fail fast_.
Change error string as well. You are not checking for text == null here, but error says you are checking text. Same for all similar ones below
- space after comma - you need to pass the source duration as well
Could this potentially be shortened? return acceptHeader.length() > BROWSER_ACCEPT_MAX_LENGTH ? DEFAULT_BROWSER_ACCEPT_HEADER : acceptHeader;
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
Collections.emptyList() seems cleaner here.
Not for now, but I think every concrete subclass of EpdqPayloadDefinition probably knows enough to add its own operation type as a constant rather than it being added to the data passed to it here.
Why is it a list of lists, not just a list?
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
We can slightly simplify: java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType());
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Simplify it please, you know I hate nested if/else
We should still be able to set the dialog's title (?) In this case, title is always dynamic as it comes from UI plugin API function call.
This could be: filterListEditor = createFilterListEditor(); filterListEditor.hideLabel();
Remove public
I would add: setAlertType(AlertType.INFO); So you have a default of INFO for messages that don't specify.
view should never be null. If anything the contract should be enforced in the ctor and the check here removed.
rename to contribution
rename to contribution
enableEditingButtons(..)
rename to contribution
I noticed a behavior that I am not sure is correct or not. If you apply a filter, then uncheck a parent in the filtered result, it will uncheck all children of this parent, even those that are not currently visible due to the filter. If that is not what we want, a possible solution would be to: 1) here only uncheck the visible children 2) when the filter is cleared, recompute the check state so that the parent will regain its checked state because it now has visible checked children. What is your opinion about the intended behavior?
Why do we have this constructor?
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
I really don't like this convention because it means that we can no longer rename-refactor the identifiers without changing the meaning of the program. It is in effect a very subtle kind of reflection. So I would prefer a distinct string field in this case and others like it. I realize that there's lots of this kind of thing in OCS, but we should fix it when we encounter it. Does this make sense?
public @Nullable String...
just return "" instead of new String()
nit: language is not supported: %s ?
Using a static map would be easier?
Put this exception in the default branch of swith.
curious: why remove anyTree?
nit: does this need to be public?
can this just be boolean instead of Boolean?
Add TODO to not forget implement this in the future.
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
can you add to Builder as well
The code can be simplified to rely on autoboxing.
.hasSize(), 2
This is not time zone?
isNull()?
isn't this the same as if I would have imported the method from Either? @danieldietrich, what's the take on that, is this meant as a shortcut for only importing the API?
Can be static (and following ones).
Do we need to null check event.post here?
This line is redundant.
We can drop final PostModel post = event.post; at the top of this method.
is it not empty if for example type is an valid empty string?
please move the isEmpty methods to the scimSchema
Is this signum call really needed here? compareTo should already return the correct value.
Also, there's no zero comparison covered?
I suggest using "ComparisonChain.start().compare(o1.name, o2.name).result()" - Location.name can be null.
you should use Integer.compare(o1.., o2..) here, since this method should return either -1, 0 or 1.
It's probable that the original intent was to avoid the overhead of Float.compare which will call floatToIntBits to do precise equality ? We could maybe switch to the following logic: if (o1.weight > o2.weight) { return -1; } else if (o1.weight < o2.weight) { return 1; } else { return 0; } To make it clearer for findbugs that we don't care about exact equality? This is only used for ordering and I think it's fine to treat 2 weights equal (for ordering purposes) if they change by just epsilon.
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
The editor can't be null
I think this should be replaceFailed = false instead.
Which tests fail if we don't have this line?
Does this need to work across source windows? (If so, look at DocFocusedEvent and SourceWindowManager.getLastFocusedSourceWindowId)
getFullName()
I think we just want the name and not the email in the message. But username is always null to us (for example), you need the DisplayName.
I think the setMaterializableResourceProperty should handle the materialized scenario itself. This means that this method can simply invoke setMaterializableResourceProperty(ACCOUNT,account); and then, the internal code of setMaterializableResourceProperty will check whether the account is materialized or not and then will relay on setResourceProperty(ACCOUNT,account); internally.
name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "".
I think you can do this shorter: return account != null ? Objects.firstNonNull(account.email, Strings.nullToEmpty(account.name)) : Strings.nullToEmpty(group.name);
Don't need the hostAffinityEnabled check here. You can assume standbyContainer is present only when host-affinity is enabled.
do u need to guard against NPE's anywhere here?
I would suggest extracting the format as a constant and hardcoding some of the format constants instead of doing it the other way. e.g.  CONTAINER_HEART_BEAT_SERVLET_FORMAT = "%s" + "/containerHeartbeat"; CONTAINER_EXECUTION_ID_PARAM_FORMAT = "executionContainerId=" + "%s"; CONTAINER_HEART_BEAT_ENDPOINT_FORMAT = CONTAINER_HEART_BEAT_SERVLET_FORMAT + CONTAINER_EXECUTION_ID_PARAM_FORMAT  Or some flavor of the above, so that you can reuse the format across the unit tests & other places in code. IMO, having the constants by themselves still forces users to figure out how they come together and repetitive code e.g. "%s%s?%s=%s" with readability hit as well.
We can do null check and assignment in one line: this.uuid = Preconditions.checkNotNull(uuid, "uuid cannot be null"); same for others.
Update container-placement-metadata before making a resourceRequest, so that the allocator knows what to do with the resource?
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
return Arrays.asList(boolean.class, Boolean.class)
return Arrays.asList(....)
Collections.singletonList
Collections.singletonList
close already done in Util.read(..)
here we should guard against null is
Since we don't usually run with assertions enabled, please consider converting assert to Preconditions.checkArgument.
same as above, is it necessary?
it seems that the first part of if statement is only good for improving performance, but this isn't a performance bottleneck. is it needed for anything else?
Now this method does not do as it's named...
you should have here setSucceeded(true) IIRC.
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
This method needs to be implemented in LexerATNSimulator as well as ParserATNSimulator.
This doesn't need to be public it can be protected.
nit, just make this real instead of mocking i.e. () -> FALLBACK_INT
Wouldn't it be better to not mock this ? This way we will test filtering. In ACUnitTestBase you have method to create Patient, so you can build a list and see if the filtering returns proper list.
Let's have some constants here instead of repeated magic numbers.
use a constant
I've been meaning to ask you if there's a class I can actually instantiate, thank you!
Wouldn't it be nice to check the path was observablePath rather than _any_ path?
unsubscribe()
We could cover it with some tests.
This check is redundant because you check this in handleSelection()
Is this intended to call getRenameValidator() while building delete action?
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
only EE product can have runtime lineage
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
The code can be simplified to rely on autoboxing.
No need to get the property from System, the property is in the server-config.properties, so you can inject the property value in the class (${crafter.engine.preview}).
Check the env variable before returning true.
Check env variable before returning true.
This should check the environment variable before returning true.
you should check hasImages in canDoAction and if not skip all these validations
findbugs will tell you that JenkinsLocationConfiguration.get() can return null
We should close the FileOutputStream, relying on finalizers is very finicky
I wonder if this is really necessary... jansi uses [isatty](<LINK_0> to avoid writing the escape codes when output is redirected.
I don't like the word "command" in "where the WES command should run". If anything, you're sort of running the (client) command on your local box. How about The URL of the WES server, e.g., ..... Also, I think you should say URL, just to be consistent with --wes-url; right now it's a mixture of url and URI.
Prefer to put these two lines inside the "if (expansionNum ==1)" statement.
Same as below; let's use the parcelable methods
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Instead of using the message, evaluate the topic to generate a good string message
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
Are you sure we need that condition? Are you able to cover it by test case? The null-test was not present before and I can't see any test related to that.
Why is it a list of lists, not just a list?
Style issue: @Override shuld be on line above the method declaration
We don't need another ImmutableList.copyOf. You are doing this when parsing.
null? why not just a () -> {} ?
You can use GenericMath.DBL_EPSILON here.
Does a straight comparison work here? NaN isn't usually equal to itself.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
Not needed, part of constructor
Will the device ID always be 0?
Why is this removed?
Will not delete directory. You should FileUtils.deleteDirectory
I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.
if (realm != null) maybe - just to be safe.
tearDown() should call super.tearDown(); try { mHandlerThread.quitSafely(); } finally { super.tearDown(); }
DEFAULT_HTTP_TIMEOUT?
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
I think this method has no need to be static
same, I think this method has no need to be static
input != null && input.getElement().equals(element) is sufficient now that the Node constructor refuses null elements.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
This shouldn't declare throws Exception.
Let's use debug level instead of info.
Encapsulation
Something else that I missed. I know it's not that important, but we don't have to set the type when creating new objects any more. We can just use the diamond operator new HashSet<>.
this.requirements is never null (but can be empty). The check can be removed.
Generics, please!
Instead of repeating the addition assign it to a value on the stack.
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
Release lock?
This message should be more descriptive. The only was for the handle to be invalid is either if: 1) There is some other thread trying to access the iterator. 2) The iterator has been previously closed. The message should reflect the above conditions.
you should account form previous page too
Move the logic to configAccessor.
Since this will add one more zk read, and admin.getClusterTopology(clusterId) actually reads the cluster, I am not sure how heavy this call is. I assume it is mostly used during deployment? I wonder if we can use the result in admin.getClusterTopology: if the cluster doesn't exist, an exception(HelixException/NoClusterExistException) is thrown. Rest code here catches it and returns 404. Then it saves one zk read.
These lines could be in a private check method to reduce duplicate code.
Can we remove the extra space? It would be great to keep the code quality for open source :-)
Typo? getTopologyMap -> getFaultZoneMap. And getFaultZoneMap throws an IllegalArgumentException when "The fault zone in cluster config is not defined" - it seems to be client error. Would you consider catching the exception and then returning a client error, instead of a server error. I think it'd be better to differentiate a client error and a server error.
Nitpicking, but I'd prefer creating the builder with  org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder(hotRodServer);  and then setting the marshalling. Same in RemoteStoreMixedAccessTest
I don't think setting the timeouts are required in this test, especially since the default is already 60 seconds.
I believe we should add the ability to override the baseUrl of the s3 client. This will allow support for beta regions of S3, and other s3 compatible storage APIs (GCS, Azure CS) <LINK_0>
Unneeded null check
^ This method no longer throws IOException
There is no call to this method outside TableManager, shouldn't we change it to private?
s/RemoteTable/RemoteReadableTable
question: why do we need the TableImpl class? The only usage of the tables map is in ExecutionPlanner.createJobGraph() and it is only taking the TableSpec keySet. Also, it seems that TableImpl class does not provide any further functions except as a container for TableSpec. Can we remove it?
this. prefix is not required within getters
Add "this" qualifier
Magic number <LINK_0> Try to use a constant for the timeout. Review the constants in the project.
this is already called in BasePageObject so you don't have to call it
you can remove this
there is no need to execute initElements method, when you're extending BasePageObject
change to: driver.get(URL_ADMIN);
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
Should move this try/catch deeper into the call stack, either the public overload or in the package-private method so that we don't need to put it in multiple locations.
Did you use our code formatter? <LINK_0>
I would rather we let the Exceptions bubble out of this method; If you want to handle the exception, do it at the call site where this task is created.
nit, java should be able to use (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex)
Don't we need to return something like -1 in the null case (i.e. when the type is not in-house one)?
In alignment with valueOf, perhaps name this valueOfType or fromType?
This is normally made so different implementations can override the type() method to go somewhere else in the objectstore - however you have a getType() on BACoordinator so it means no one could ever override the getType() from what I can see, maybe I miss something or maybe its not required but I do need some clarification
all these methods can be private
You can use StringUtils from the commons.lang3?
Why is there a fromByteArray method? Why not call the constructor directly?
I think it is common to return the written value.
Superfluous blank line :).
suggestion public Long offset() {
Symmetry (throw)?
For each?
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
int[] props would make everyone including the style checker much happier
For loop?
nit: what about java nulls[i] = i % 7 == 0  ?
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
This line is redundant.
that class would be better with a builder, though I wouldn't ask changing it now
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
This function seems like a good candidate to return an Optional
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
no need to call super explicitly. Any construction implicitly always starts with a super() call (unless it's a this() call to another construction).
please remove empty c'tor
You could remove method("POST") as you set the HTTP method on create
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
wouldn't UnsupportedOperationException be a better match ?
this doesn't looks good at all :( let's log the exception using Logger.warn().
Overly complex. Just say: Repository repo = repoManager.openRepository(...); try { ... } finally { repo.close(); }
Same here, no need a transaction
No need to make this a transaction, its a single insert statement.
The value checking is not needed here, only the preference. We already check the value in the other test.
For correctness this should probably use System.nanoTime() which is intended for this use-case.
Please use lambdas where possible.
HQL/JP-QL
clause?
Detail: FROM capitalized.
This variable is not needed, there could be two return statements in if and else blocks
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Could you please use DecisionTableInputType.XLSX
Note that the simpler idiom (which also converts more cleanly to Java 7 syntax) is  InputStream inputStream = new FileInputStream(file); try { return IOUtils.toByteArray(inputStream); } finally { inputStream.close(); }
looks broken, as L262 will always get a closed stream
This is breaking the existing conventions about allowing nulls. If we ever receive null inputstream we should throw an error here. To avoid them, we should change the calling site, not these utility methods, which operate under narrow set of constraints. suggestion
When you're using a local variable that shares a name with a class or instance variable, try to be explicit as to which you're referencing by using this.inputStream (or similar as appropriate). As an aside, the instance variable is never set, so this check will never succeed.
Optional.ofNullable could be used?
This pattern is captured in Optional's [ofNullable](<LINK_0> method, so in this case the body of the method can be simplified to  Optional.ofNullable(gitRepo)  Similarly for other methods in this class. Let's get rid of the boilerplate :)
The original code style in this method is better:  private PagesSerde createPagesSerdeInternal(Optional<SpillCipher> spillCipher) { if (compressionEnabled) { return new PagesSerde(blockEncodingSerde, Optional.of(new Lz4Compressor()), Optional.of(new Lz4Decompressor()), spillCipher); } return new PagesSerde(blockEncodingSerde, Optional.empty(), Optional.empty(), spillCipher); }
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon
Ingest modules need to throw IngestModuleException if there is an error in startUp, with a user readable exception message, since it is displayed to the user. You need to wrap the NoCurrentCaseException in an IngestModuleException and throw, not log here.
I think we can use ConcurrentHashMap::computeIfAbsent to replace synchronized and containsKey
Shouldn't the restoration be in the reverse order of the activation? So that we first restore the last activated context?
static.
Use static call. There's no need to instantiate this util class every time.
"notation".equals(resource.getURI().fileExtension()) to avoid potential NPEs.
Not a good idea to have two methods with the same signature except for the type, espcially when one is a subtype of the other.
I would have inverted the check but that may be unnecessary
Possible ClassCastException, since there is no check that the loaded resource is a view.
I think the offset and limit are miss-leading here with the method name searchPayments. The client uses them to restrict the result payments size, but the plugin will use them on the transaction level. So it would be the case that, the client sends a limit of 100, but only get 1 payment in the page with 100 transactions embedded. Or a payment may cross 2 consequent pages. Are we considering to have the plugins returning a more proper list instead of PaymentTransactionInfoPlugins?  class PluginPayment { private UUID kbPaymentId; private Collection<PaymentTransactionInfoPlugin> transactions }  Just a thought, I'm happy it's not changed in this PR.
Encapsulate this here. Should be returning a MapView here.
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
Please use Optional.ofNullable()
we need a gauge metric here to ensure the thread is running
Why this debug log is removed? Not sure, if it's there for any security issues.
please provide e as argument for stacktrace
As well as this.
Do we need to handle the interrupt in the consumer poll thread? Existing implementation doesn't seem to handle it and the consumer poll thread is interrupted during KafkaSystemConsumer.stop()
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Please remove the public modifier
-1. This means input does not get read.
Style-nit: Should be after this.accountCache = accountCache.
Here you use Byte.toString() where a bit lower, line 63, you use ..Factory.convert(..) - might be better to unify.
Here you use Double.toString() where a bit lower, line 63, you use ..Factory.convert(..) - might be better to unify.
value.toString() vs. factory.convert(..) a bit lower, line 63
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
You need to send cookie here.
Const.ParamsNames.ERROR was previously used to colour the status messages red, is it still used?
Try to use "response.getWriter()".
Add final keyword.
suggestion return Arrays.toString(value);
I think we should sort the tags in a specific order here. Otherwise we could have tests excluded for the same reason, but the strings will not match if tags are not in the same order.
It would be even better to get rid of this line: java String.join(" ", translatedWords);  with java .collect(Collectors.joining(" "));
I like Streams too, but String#join would be more appropriate, wouldn't it? (and it's Java 8 too!)
Collectors.joining(".")
I would suggest using the related constant instead.
I would suggest using the related constant instead.
Why uppercase fs?
Do we want to check both getProjectId() and getJobProjectId() here?
nit: Could be this.conf = requireNonNull(conf);
name could be more descriptive
Vague variable name s
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Please include clientTelemetryEnabled in toString() API
Returning a class instance _or_ a null? This calls for an [Optional](<LINK_0>!
throw new RuntimeException(e);
nit: how about we just use the class name of input strategy by default
return Optional<File>
I'm of two minds on this exception. On one hand it seems like the more correct approach is to raise the exception rather than swallow it. On the other hand, that means if a malformed URL somehow gets into the database, you could never read that row out again without an exception--lame. Any any rate, this should be logged with SLF4J rather than printed to STDOUT
could uh, use checkState(false, "") instead of a lambda ;)
AndroidStudio's inspection highlights and suggests replacing indexOf with contains for the condition expression. WDYT about replacing it? If we will touch this line, and since the index is recalculated below, how about introducing a temp variable to hold the index to avoid doing the lookup twice anyway?
These should be marked as abstract and let the subclasses should implement them.
Missing the -... ex: pt-BR Now that i look into it, is it a - or a _? I believe it's a -. One more reason to use the default functions
return LanguageUtil.LOCALE_CACHE.getUnchecked(this.locale);
Do we need some kind of synchronization here, or will next() never be concurrently called from two separate threads?
Avoid duplication with:  long sliceLength = Math.min(getRemaining(), partSizeInMB << 20);
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
We should verify the flow was invoked correctly - maybe send a CountDownLatch in the payload, or an AtomicReference<Thread> and verify its value is not Thread.currentThread().
please add curly braces
If you remove the condition, the retry analyzer instance will never be null. Better: DisabledRetryAnalyzer should be the default value if clazz == null unless you think the null value is important.
There is a genuine risk that multiple sources will try to set the lookup at the same time ? Just wondering since now this will synchronize ALL access to storing attributes to the vaadin servlet context, not just the lookup. Just wondering if synchronization access go through another API, but then again also the getAttribute is already synchronized. So probably this is fine and I'm just thinking out loud.
These seem to be covered by NUMBER_TYPES already?
LinkedHashMap please <LINK_0>
Why you will need substring() when Class.getSimpleName() would only return the class' own name without package? Please remove.
This could be confusing here. How the user know the all fields?
let's call it updateCodeMinings() instead.
ooh! I ...Connector, here!
if at all possible let's try to avoid introducing more mess:)
can we improve this by giving some meaningful exception message ?
@drcrallen I tried a hadoop batch ingestion job with this patch applied, and the task didn't pick up my hadoop-client jars. Passing in the directory:  new URL[]{extension.toURL()}  doesn't seem to get the jars picked up, I had to change the URLClassLoader creation back to the original implementation with a url for each file to get the task to proceed.
Please add ? and % as well
Isn't it also important that adType was async and method was top?
40?
IntelliJ has a "Reformat Code" option which will clean up a lot of the stylistic issues that I might list here: - fewer empty lines - space between ']' and '(' - space after ',' - space between ')' and '{' - no newline between ')' and '{' - space around operators - space between if/while/for and '(' - no space between method-name and '(' - if/else with brackets and the else line looking like '} else {' -make final any variable that can be (method arguments included)
Please remove an excessive space character.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
In case self is a BufferedIterator should this return self instead of re-wrapping?
Added because?
Why not just define the new question index as -1 like what we do in JS file instructorFeedbackEdit.js.  javascript const NEW_QUESTION = -1;
Should not be able to submit when there is no question selected.
Same here. Magic -1 :P
I tried running your test locally; the new question button cannot be clicked because the discard changes confirmation dialog is still open.
To defend against catastrophes from bad future refactorings, I would recommend extracting a protected method for the computer's log directory, to make it clear that what you are deleting is specific to this computer only.
Should the InterruptedException here be treated as a cancellation?
You can use GlowServer.logger.log(Level.X, "message", exception)
ExtractedContentPanel.getText.error.msg appears to be undefined. As previously noted, this means that there will an unchecked runtime exception if this code is executed. Please correct the error and use the generated method for the messages instead of NbBundle.getMessage, which moves errors such as this from runtime to compile time. *** While we are in this code, it would be nice to group the catch for InterruptedException with the CancellationException, since they amount to the same thing (even though we do not support cancellation of this task at this time).
The exception should actually be the fourth argument to the method so that it is logged as the causing exception with a full stack trace - we should never throw away debugging data. Also, the class name has changed, so the log message could lead a debugging developer astray if they are not paying close attention to the stack trace.
seems like synchonized is not needed here, given increment/decrement already protect
Actually.... what if we avoid using addFileSystemBind (that [creates a mountable file](<LINK_0> but use the bind API directly for the SHM? This ~~hack~~ adjustment does solve the problem too, but I think we're fixing it in the wrong place. WDYT?
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
I think lowercase l should also be considered
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
It's considered bad practice to have an optional around a list. Just return an empty list, instead of an empty optional.
Not good to use Optional for collections, just return empty collection
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
suggestion final List<String> lines = Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8);
Should we use UTF-8 instead of default character setting?
maybe test first char for empty letter as well to reuse s if possible?
can this use the MMX StringUtils functions?
This involves a look up of the character encoding type table. Use MessagePack.UTF8
I would rather use a constant such as com.splicemachine.primitives.Bytes.UTF8_CHARSET
Is it really worth checking before setting it?
Should you be closing the connection as well? What happens if the caller attempts to execute query after closing the prepstmt
just remove this check and the corresponding else. managementRealmOpenTask permissionRealmOpenTask may finished at the different time, so you could have managementRealm != null but permissionRealm == null
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Should close kill the memspace? What if someone want to reopen the key?
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree)  return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
This could be reworked to avoid having ! in nearly every condition to make the different cases cleaner to read.
Why not push/pop methods ? bit clearer IMO.
no need for the ||
I would make explicit tests for every kind (or switch) and have overloaded method for those. That will make classCast less likely to happen. Here there is a lot of implicit going on. Let's make thing explicit. checkIfUnknown(MethodInvocationTree ) checkIfUnknown(NewClasstree )
suggestion if (this.currentTask != null) checkAndRethrow();
Same why not else if?
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
optimize
How does this work for (ridiculous) timezones with 30 or 45 minute offsets form UTC?
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
I prefer ", not "+(l == null ? null : l.getClass()));
"must be of the format"
currentTimeMillis() instead of creating a new DateTime() object
This method can be static, as all the methods it calls.
Since this logic is getting more complex, it probably makes sense to reuse isBindableType here.
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
you could have merged the expression of this if with the previous one.
combine with assignment this.outputType = requireNonNull(type, "type is required");
Shall Alter database to add source_of_replication DB property and see if Dump succeed afterwards.
It looks like sparkObject could now be a byte[], so should setSparkObject call deserialize here, the same as the code you added in getLength() ?
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
Why is this change? Should not this minimally depend on if this table is transactional or not? What happens if we call it on a non-transactional table?
Duplicate method. Can we have a static method in MetastoreUtils that takes MSC as input?
final
Unnecessary.
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
Instead, I think we should update AbfsOutputStream.close to wrap the exception, short of having the Java implementers fix this. :)
Should we check for systemConfig.isOutdated() as well?
Pretty minor but would you mind adding some parentheses around the arithmetic? :) Is it possible to have a divide by zero error?
Why not unconditionally update the SessionData?
Is there reason behind how you access this wrt to property or accessor function? Perhaps we should change all these uses to getters/setters?
combine these two lines -> OwApplicability app = artifact.getAppId();
Can this case happen? We initialize app in onCreate(). If so, can we initialize app in onAttach instead?
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
Is it possible context.getAuthenticationInfo() is null or context.getAuthenticationInfo().getUser() is null
I tend to prefer having all code at the same level =>  if (0 != context.prepareSelect("select count(uuid) from quality_gates where is_built_in = ?".setBoolean(1, true).get(row -> row.getLong(1))) { return; } context.prepareUpsert("insert into quality_gates (uuid, name, is_built_in, created_at) values (?,?,?,?)") ...
Instead of having this be a part of every authorizer, we probably want to push it up a level and have it be a part of the code that calls the Authorizer.
The filter should be moved to SQL to not load all the table in memory: select ... from properties where prop_key like 'sonar.webhooks%'
minor: don't need this. qualifiers
channelId => channelName
s/id/ID
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
suggestion return getClass().getSimpleName() + '@' + this.id + '#' + this.version + ' ' + toJson();  IntelliJ thinks this is better
The two methods above are the same except for the first line...perhaps reuse the code instead?
The two methods above are the same except for the first line...perhaps reuse the code instead?
Can be rewritten as Assertions.assertThat(utilities.getValueList(column)).isEmpty()
Some more methods (appendColumn(..) and deleteColumn(..) a bit further) with very similar code that could be reused.
Maybe also here we could use MessageFormat as we pass twice column.getBoundName()
Parameter should be a string instead and be called label
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
This fix is incorrect. It only caused the empty oplog (created by the offline compaction) is not deleted by the recovery's auto compaction. I modified the dunit test a little bit and proved it. Unfortunately, there's no flag or status to show that a compaction is just finished. Even we want to use the empty oplog created by offline compaction, we need to careful arrange the logic. Such as: change needsCompaction to return int. 1: need to compact, -1: no need to compact, 0: there's one empty file, only need to delete it. But maybe there's better ideas.
We should now be using the actionParameter itself
Missing @Override
Braces on following line
Let's not catch NullPointers but do a check whether element is null before trying to get the attribute.
I don't think you need this new String
You could use a StringBuilder :)
I would recommend an else if here to avoid comparing against a string unnecessarily.
If this should never happen throw an IllegalArgumentException instead.
ChannelClosed needs to be added to (though not strictly necessary)
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
1. _1 suffix almost everywhere means that error code has one parameter. Use different names for exceptions. They are also expected to be self-descriptive. 2. Vendor-specific codes can't start with '0', '1', '2', '3', '4', 'A', 'B', 'C', 'D', 'E', 'F', 'G', or 'H'. Don't use 42S here, add some plain 90*** codes instead.
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
suggestion return GitHubServerConfig.GITHUB_URL;
Existing code use null as the sentinel for this field, so I think you should keep using null here. suggestion this.apiUri = null;
Let's use a template path string like  String BASE_LINE = "/%s/something/%s"  Then the code here is cleaner.
Could use '/' and ']' to avoid the need for extra NON-NLS
I believe this whole catch block can be removed. The standard WaitUntil handling will be sufficient I believe.
Is it OK to swallow this entirely?
Avoid logging an error if there's already a throw.
Why do you have to check for null here?
Thoughts on putting log messages in a Utils class?
We don't need to use System.out.println() here. These two lines should be assertTrue("Expecting: " + expected + ", got: " + e, e.getMessage().contains(expected));.
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
What's the reason to do it here rather than in InternalEntityFactory (analogously to the policy path)?
I would probably replace this with a string builder
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
please create a more specific exception that extends this one.
factor out
throw UncheckedIOException(e)?
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
you could be more specific and check instance of Function0 maybe?
Can this happen ?
Clone method is wrong. Kernel/stride/padding are already handled in superclass clone. And it doesn't set depth multiplier.
Should close kill the memspace? What if someone want to reopen the key?
should call clear() on timeStamps and values ... this will cause null pointer exceptions when calling add after clear
For loop?
nit: what about java nulls[i] = i % 7 == 0  ?
Format this file using our code style.
no need for the "this"
For each?
After checking how MimeBodyPart is implemented, it might make sense to tweak this to:  java return String.format("%s; charset=%s", mimeType, MimeUtility.quote(charset, HeaderTokenizer.MIME));
this is confusing, it is called router but actually it is routerUrl.
Looks like you are making double slashes here...
Can we use url building here, to avoid problems with / at the end of the server.
Not provided the Locale in the first argument can cause issues depending on which user the Locale has the app set to. I ran into this with the Simperium library.
style nit: we don't use braces around single line blocks
style nit: we don't use braces around single line blocks
What's the point of the 6 trailing zeros ?
Just wondering what was with the random "getClass();"?
Package private constructor, rather than just public?
Apply changes similar to setVisibility.
Simpler to apply the mask after the shift.
You need to calculate the righ margin to account for the width
You need to calculate the righ margin to account for the width
This should use the new checkPosLength(int) method as well.
A message might be helpful
this seems misnamed
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
Eclipse is warning that the argument r is unused. I guess this should be changed to r?
There's no validation in here. I'm not sure if there should be, but we can't assume the UI will provide "valid" numbers. My guess is that we should have a min value and a max value, defined as environment.properties values, and ensure that whatever the end user passes in falls within that range, or is constrained to that range by the code, if we want to allow that
you need call addColorSettingsListener on the new instance.
They are mutually exclusive? Or is that a micro optimization?
This thing does check the value for not being null. So the previous expression is redundant.
Preferably have one call the other?
Redundant condition.
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
I think for removing a thing the order was already fine. If we remove the thing from the ThingManager before notifying listeners, they could try to disable the thing in that short gap. Moreover, if we leave the order in this method unchanged, then it will be exactly the reverse order from the notifyListenersAboutAddedElement method, which is also what I would expect.
Is there a chance of a NPE? could be getFile() null?
Just in case, please wrap with Collections.unmodifiableCollection()
It would be better to not hand out a reference to the internal data structure. The TagName objects are immutable, but the collections are not.
return Collections.emptyList();
nit: create static variable for this empty set and return that static variable
Not that it matters in the case of this class but how about Collections.unmodifiableCollection(EMPTY_PARTITIONS_SET)?
Define "data-agent-conf.xml" as a constant
duplicate regex as above, can we reuse it?
correct.
fyi: if we counting everything, fs.getContentSummary(path) would be the most efficient.
Args.notNull
Did you intentionally ignore the patientProgram parameter?
?? why this and the following ones could be left empty?
We could throw an UnsupportedException here.
Will need a @since tag.
factory must close its cursor (which is closeable)
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
Great idea! Can we use Locale.ROOT instead, though?
probably the date format string could be refactored since it's used in multiple places. I'm also wondering how expensive the creation of a new SDF is.
Why change the name the property? Accident due to mass refactor/rename with IDE?
can we split this into multiple lines and add tab support?
log.trace if at all
log.tracef
Might be cleaner in terms of minimum visibility to just return the timestamp from the transaction task.
In general throughout this class, is isNotNull() really needed? I imagine the isEqualTo check should be good enough. Transaction#getTimestamp returns a primitive long, so non-null.
same here. NEVER do anything with null, it's a bad practice
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
The cast is not needed
I think this should be done in the constructor rather than here - or at least, in the if-clause of this method. Otherwise we risk adding the instance as a listener multiple times for each getInstance call
Please do a format of all files before committing (ALT+SHIFT+F).
Does this need to be a singleton?
can just be return pattern.matcher(value).matches();
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
can we move this method to Utils
Suppose makes sense to convert value to lower case before comparing.
return StringUtils.isNotBlank(value) && value.equals("true");
Use logging framework instead of printing to stdout
assuming this was for debugging, should remove.
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
Remember to revert this file, it should know about the transport class.
InputStream.close() doesn't contain any implementation so you can drop that call (but it doesn't matter). But I am pretty sure that the base class close will not get an implementation some time because it would break all previously working subclasses.
This updates all gauges when any of these gauge is visited. It'll be better to override getValue() instead, and only calculate the percentile for the gauge currently being visited.
Should this be removed from here if this is already being updated in getValue?
I am confused b/w the description and implementation of filter here.
do we need currentTime? "-1" would be simpler, no?
this is not thread safe
Be explicit about e.getMessage here? (and perhaps enclose it in double-quotes)
Oh, I see Well, I'm not against mentioning subscribe() as long as we don't just say to "set this error handler to avoid this exception" We can also mention onErrorXXX, might be a bit overwhelming tho
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
I would suggest to change the name of skipRemoteGet() to something like skipFetch(). Also, change the name of the internal flag and the setter :)
This prevents menuDetected triggered by the Menu key (e.detail == SWT.MENU_KEYBOARD), as mouseUp will not follow (neither will keyReleased).
Padding should probably be extracted in a separate method. (I could also argue that getting the int value could be another method, but I sense that there might be some opposition there).
we never use NULL, it is a bad practice in general.
This will NPE if input is null, yet the parameter is marked @Nullable. Should we remove the annotation, or explicitly check for null (e.g. to return null if input is null)?
If you make the EMPTY_EXPIRES, you could use it here.
nit: space
This can just be catch Exception.
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Should we check for systemConfig.isOutdated() as well?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
consider catch(Exception e) { throw Throwables.propagate(e) }
suggestion return Optional.ofNullable(getLhsType()).map(s -> s.getTypeImage() + ".").orElseGet(() -> Optional.ofNullable(getAmbiguousLhs()).map(s -> s.getName() + ".").orElse("")) + getImage();  and avoid computing the ambigousName unless necessary
Must be in format ID@ADDRESS
Just an FYI for future - You can use this method for this: <LINK_0>
same here as for CheckResult
can we use frameworks/base/core/java/android/os/Build.java#IS_USER
An optional of not null is a bit painful. Use another constraint perhaps? Do we have one test on the payload business btw. (applying it to the wrapper)?
UnsupportedOperationException ?
The current style used for the method return annotation is to put it above the declaration. This also applies to all other usages in this PR. suggestion @NotNull public static IReferencePoint create(@NotNull Module module) {
also static
better URL: <LINK_0>
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
Would suggest to make it private.
Patametrrized logging please
Why this has to wait for 5 mins to stop the proxy thread. Can we set the proxy thread stop timeout to reasonably low value?
Would suggest to make it private.
Why this change?
I think it would be better to make drawing the border conditional on the line width.
public? And maybe put it next to the other setter.
That will use the width of the column at the time that the item is checked for the first time. When the column is resized or the item is toggled, it doesn't seem to update the width. Maybe the tree/tree item needs to be layed out again. But perhaps it should have a shorter width that does not change instead. I got some success by calling pack() on the column before getting its width.
What's the default background? Is it already OK? If not, you probably want to simply use display.getSystemColor(SWT.COLOR_WIDGET_BACKGROUND). This is the background set on the Chart.
This must be unique, as it is the ID jclouds will try to find when calling the computeService.getImage(id) method. Is this label unique?
shouldn't we do it only if getParameters().getSourceDomainId() is null or empty?
Why is it setting the SD to the Master SD? What if the disk used is not on the Master SD but on some other random SD? I think qemu-img will fail and so will the import.
better use Strings.isNullOrEmpty(item.getLargeImageUrl())
Maybe use the getStorageId method here?
Something like this.
Same here. Multiple places.
You may find many examples in the existing code base.
Tiny grammar mistakes in test messages. - [ ] greater - [ ] equal to I created an issue regarding "grater" typo. <LINK_0>
similar here, should verify html content after the edition, so that you can know the edition indeed appears on the page
several style nits: spaces before {, before variable names, between functions, etc.
I think we are doing too much outside of View rather than finding a good way to delegate to a View. We rely on a view's underlying implementation to work, and in this case we don't even throw an exception if that assumption doesn't work (which we should). I'm fine with this as long as it is temporary, but I think we should be delegating more to the implementations rather than relying on them to follow the standard pattern.
invert it
ViewUtil.destroy(View) use the GMF CrossReferenceAdapter and should be removed
This is extremely wasteful. Try a CopyOnWriteArrayList for listeners instead?
suggestion throw new IOException(MESSAGE, (Exception) DummyClassLoader.apply(TestCallable.class));
@andreoss Why throw Exception here instead of the original IOException?
Maybe IOException since it's supported here?
Style-nit: Remove the added final keyword.
Should you set the iis to null here so that it is immediately known that this is closed if you try to re-use it? I'm just concerend about someone using one of these and not realizing that it wasn't being used correctly.
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
Might this not cause extra copying of the buffer contents when transferring data between network and storage?
Just personal preference, for this, I would use java 8 style getOrDefault to make it a bit cleaner :) java _currentAssignments.getOrDefault(resource, Collections.emptySet());
why do you set it twice?
Since it's the same in both branches of the if, I believe it can be put outside of the if
Move this validation to PluginProfileService.
Move this validation to PluginProfileService.
That should be toHtmlForAnthology. You mixed those two up.
I think lowercase l should also be considered
need to throw the exception
side note to bringing in this dep, installing this module would also likely start up a number of pollers/db connections/zk connections/etc which we don't want
Should you call analysisReady(false) here?
Missing call to super implementation of onResumeFragments()
configure is user-overridable method, and also there is no need to trigger it here
eventService.unregisterListener(EventConfigUpdate.class, this); this.eventService = null;
LinkedHashMap please <LINK_0>
why silent catch?
ConfigurationException?
Could you add the path /artifacts/ to <LINK_0> and reference that instead? Then search&replace in other methods.
Missing a unit test to ensure maintainability.
should be setSucceeded(true)
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
Since we know we're in ConnectStoragePoolVDSCommand, is the getCommandName() really necessary? also, remove the "to" - "Failed in VdsCommand %1, error = %2$s"
* shuoldn't we call super? * worth adding some log..
I would replace this by System.nanos() instead of doing a call to nanos. To prevent running out of inlinining budget.
Doing this via double math is still 3x slower than return (nano + 1000) / 1000L;
same here - call the constructor with 4 args
Shouldn't we return the actual estimate?
You should return the native pointer you get from the nativeCreateWatchStream method: suggestion return this.nativePtr;
Same here.. we should not have these checks here.
Here, we need to check value also along with key. A case like createBucket, DeleteBucket, we will have the key in the cache for that bucket, but with the value null. And also is this isExist will be called with the lock? As someone can modify the same key while checks are happening.
change "get(key)" to "redisSet"
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
How does this work when an item is evicted from the underlying cache, but is still in locker?
Why is it public?
Can you add a check to see if the metadata is present (stream.hasMetadata()), if not create metadata?
@fabriciofx Here also, we could return the body() of our decorated object directly
No, need for close here as you use try-with-resource?
No, need for close here as you use try-with-resource?
Should return ReadOnlyArray.
Should return ReadOnlyDictionary.
personal preference (so up to you to take the suggestion into account) but I would go for :  if(cond) { return 1; } return 0;
before accessing it's property, wait for element
Do we need the toString() here?
ImageData for current image needs to be updated in the array?
I like the way you change it (very smart) however I think this change is a very good candidate to create an unit test to test previous code working against new code.
A List<String> would probably be simpler to use as return value
IMO, "cluster.properties" is better because this is a cluster config
fileName += COMPRESS_PER_RG_OUTPUTS ? ".fastq.gz" : ".fastq";
I would prefer to move this line in the if branch, so it is more clear, "return element" is done if a managed provider is available only
add(int, E)
We should not catch generic Exceptions. Can you make this more specific?
It is a good idea to add all releases in a finally block, so that we never lose permits.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
I think only one impassable entity should be allowed on a Square. Exception otherwise.
I foresee clashes here. Should at least use <type> + "/" + <name>
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
It looks like we need to modify ContainerAttributesResource to simply take a Map in its constructor. That way it's not only simpler, but it would also mean that all attribute values (including user-provided ones beyond those available OOTB) would be represented by the resource representation.
The use of false here seems un-intuitive, in that we never update set the hash - even for new objects. Is this because we rely on the id being null in these cases in order to detect it is dirty? In any case I think it needs some tests around it.
you have to add a canDoAction message if you fail canDoAction
return Optional<File>
For easier maintainability in the future, I suggest having curly braces for this if condition.
matter of taste, this could also be return this.profileTypeRegistry != null;
<LINK_0>
Program to interface, not to implementation - please change return type to Map<String, Object>
import that one as well, to make the code more readable, or prefix all with ConfigValues
Should this be putTransient because of IMap#putTransient?
I don't understand this change: envs should be referenced using ${env.MY_VAR}
this is unnecessary repeat code. The only thing you need to do if schema is not null is put the schema property in the ImmutableMap builder
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
Why are you calling setUp()? Is there a way to avoid this?
Alex, I don't think they can be merged. getLong is still missing in the code base. Committing this patch without test seems a bad idea to me.
the order of arguments in assert*() is counter-intuitive... it's (expected, actual). Technically the 'result' variables should always be second.
run already called tally, so do you need to call it again?
there is Long.hashCode(long value) method.
Could you put this change to a separate PR?
bad hashcode.
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
Probably returned value can be long.
can it be made in one line?
Please group mr, ms, and mrs together
Was the closing head at the end on purpose?
Why is this needed?
Why does the newline have three backslashes in front of it, but the other control characters only two?
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
Are we comparing InputEdge vs SourceInputConfig here?
Is it OK to assume that neither of these can be null? Couldn't a user easily create a ref entry which only has one of these defined? Perhaps you don't really support this case in the code, but perhaps it should be supported? I can easily see a project wanting to override one without overriding/specifying the other.
Toni, could we please choose better variable names here? equals and equals1 do not say much for newcomer to the codebase. Or we could avoid storing partial results by: java if(!Objects.equals(editorPlaceRequest, event.getPlace())) { return false; } if (!Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier())) { return false; } return true;  Please let me know what do you think.
Should this code also check for null on total, maximum, minimum, average or maybe use Objects.equals for comparison on these fields?
is logics correct here?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
nit: was gonna point out this should stop matching the parameter value at # to avoid including the fragment value, but probably all the querystrings passed here wouldn't have fragments.
static?
ChannelClosed needs to be added to (though not strictly necessary)
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
Unsigned types are not used in the current implementation. So, you can omit them.
This list needs to include soul lantern.
1. _1 suffix almost everywhere means that error code has one parameter. Use different names for exceptions. They are also expected to be self-descriptive. 2. Vendor-specific codes can't start with '0', '1', '2', '3', '4', 'A', 'B', 'C', 'D', 'E', 'F', 'G', or 'H'. Don't use 42S here, add some plain 90*** codes instead.
can move ListVersionView object construction in ViewFactory? this will replace publicBodiesConfiguration dependency by ViewFactory to make it consistent with other resources.
Possible NPE here unless I am mistaken -- there may be no defaultValue.
Could throw IllegalArgumentException instead.
space
We have a removeConfiguration so let's not allow null value here?
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
One more unnecessary "save and restore" of system property value. Please remove it to be consistent in the entire test suite and use clearProperty below.
Since this a string, safer to use StringUtils.isBlank
Change to: tenantId = injector.getInstance(Key.get(String.class, Tenant.class));
How about remove the property, rather than set it.
rename to child or childItem
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
suggestion list.setSourceList(new ArrayList<>());
This empty check can be removed if you add one element to values in the constructor.
missed two
That is not clear, why do we have "Save" is not adding alarm item is enough? Actually, it is saved in Realm but not scheduled in Alarm manager?
This is just a quibble given that the entire thing is private and the class is tiny. Still we could separate the loading of the preference and turning it into a ScaleInterpolation from the side effect of updating the menu selection. On the other hand I guess this is never going to be pure function anyway given that it reads from mutable source (Preferences), but it still might be an improvement. Regardless, we should log the exception instead of just printing it there so it shows up in the log. Since it isn't critical it could just be at INFO priority I guess.
getItems().length > 0 implies menu.getItemCount() > 0, so menu.getItemCount check can be removed. getItems().length is not sufficent, it should be checked that any of these items is visible, e.g. Stream.of(getItems()).anyMatch(IContributionItem::isVisible)
The last argument here is wrong, it should be swapped with the "..._changeto_all" of above. It's the tooltip that is shown when hovering over the icon and tells the user what the *next* thing will be when clicking on it.
Could you please create a new enum for the Menu and Button constants (I don't like magic strings).
should we use ObjectUtils.nullSafeEquals here as well?
It might be a tiny bit more readable to call this.sortFileSizeConditions as well. Ditto on line 359.
Good catch. Should be the same for initCond on the next line. It's a bit unnerving that this is not a compile-time error :( EDIT -- I checked with a structural search: Objects.equals($o1$, $o2$) with a constraint on o2's expression type java\.util\.Optional. This is the only occurrence.
Better to throw NullPointerException?
Isn't this... just a re-implementation of natural ordering? I don't think you actually need this.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
This message should be included in our Log class (with a parameter for the service name and a @Cause, you have tons of examples in the code). The message should also probably be something like "An error occurred while loading an instance of service <service class>.".
I still don't understand why the key cannot be the session id
Simple for-each?
log this
Move this else if just after the } above
Have we tested this with a song that is currently being played
should call super.onClick() here?
are the tabs here misformatted?
Camel case
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
Delegate to isNonCodedDrug() when making the check.
Please use <br /> instead of <br>
better use query(QueryRequest) method
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Why not override visitClass() method?
If you clear the list at the end of the scan, no need to clear it before.
This one should not be necessary... safe to keep it but a bit defensive.
Is there any particular reason to call getMuteReason instead of just checking the value of muteReason directly?
constant?
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
For simplicity, this can just be return getChildren(inputElement);
Toni, could we please choose better variable names here? equals and equals1 do not say much for newcomer to the codebase. Or we could avoid storing partial results by: java if(!Objects.equals(editorPlaceRequest, event.getPlace())) { return false; } if (!Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier())) { return false; } return true;  Please let me know what do you think.
Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?
All uses of from/join on ExaminationConstraintConfiguration should theoretically be removable when converted to penalizeConfigurable().
Why fromUnfiltered(), if you then filter anyway?
Math.pow does long to double conversation, which is inaccurate, try (double) 9007199254740993L <LINK_0> then just to convert it back to long (again, inaccurate) Lets simply do r.getDrivingTimeFromPreviousStandstill() * r.getDrivingTimeFromPreviousStandstill() ?
Can we use the variable name "employee" in such cases? (Same for a above constraints) lamdba's don't have an explicit type written down. (It says "e", not "Employee e"), so for readability (most users start from one of these examples), let's use a full variable name. In general, in optaplanner-core only the following short var names are used: int i, Object o, Exception e.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
can you explain why this change ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Fix indention (should align with following code).
Copy paste code block? Split it out into a function please.
This is a test for the userRepository in my opinion and should not be here.
no need for type cast
This line should be placed before the thrown.expect... calls, because the exception must be thrown by tempFolder.newFolder.
None of these error cases need to post events
agreed :) Shall we rename the field "thrown" to "expectedException" so the link with expected is more clear?
super() can be spared here.
Do we really need this? It's implicit
this("Safety Command")
personal style on my part - have only one constructor do super() - so have this one do this(true or false).
CalDavConfig has no super class (except of java.lang.Object). Do we need a super() here?
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Don't initialize to empty when null.
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
Simpler as ImmutableMap.<String,String>of().
suggestion return Collections.unmodifiableMap(tags);
Shouldn't this message be changed to "Should be 500"?
instead of calling an extra method for just one if statement (seems a little overkill), why don't you do one if statement to determine the validation status Status status = condition ? passed : failed and then one more line for setting the status if it needs to be set => 3 lines of code
This doesn't look like a recoverable scenario, should you be re-throwing this one? Or is there some default/fallback VipAddressResolver if the instantiation fails here?
Let's make sure that no project uses this resolver. If there is a project using this resolver, let's throw an exception and tell the user, he can't remove the resolver because it's used.
why do we need this setter exposed? Should constructor handle this automatically?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
Please group mr, ms, and mrs together
Hi @diegolovison , I think the message here should be not stopped but: Pattern.compile(".*\\[org\\.jboss\\.as\\].*started \\(with errors\\) in.*"); (at least this is how it was before Gustavo's changes) Would be great if you will fix that too. Then I will rebase the PR as I am facing this issue too.
Why is this needed?
This may become static member of the class.
nit: param doesn't need final
Collectors.toList()?
Would return builder(SecurityLink.resolved(security)); be simpler?
No lambda param type needed, we use the simple form result -> ...
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
I want to method accessor to be package private :eyes:
Please use the more compact one-line syntax:  java if (defaultUI == null) return;  for consistency with the other blocks of code in these here parts.
Also this: parent.syncScroll(DisplaySide.A); // match A's viewport
Why not use the builder syntax here?
You can create a new method to show the snackbar, with the error message as parameter.
Add log.info "connecting to ATSD at host:port"
Why are we eating the exception here?
I think it's unnecessary, method is synchronized?
Add the info log back after this line?
I don't think this is going to work reliably. The read may have split a multi-byte sequence at the end of content and then creating a string from it is going to break. Is there any reason you want to use a stream when reading the temporary file rather than a reader?
rename to comply java standard name convention. validateEmail
Avoid ByteSource in API. byte[] is ok here
format should default to "tar.gz" is null or empty and not throw an exception.
I'm pretty sure this is a breaking change. Certain libraries like Kragle and I believe our UI expect the dates in the previous format with the Z at the end.
This is strange that this method throws SizeTooLargeException and not the new one. Are you sure that this exception is always necessary?
70-75: extract method (see following methods)
i would add additional check to make sure we will never make it to more then 100 :)
if the max stream tail moves, it calls prepareSiteRoleChange(), which call queryStreamTail() one more time, and will update totalNumEntriesToSend. Then it call queryEntriesToSend() again, will get a pretty close result as currentNumEntriesToSend. So percent calculation will always return a 0.
there is no need to declare it public
just call this percent
Maybe wrap in an immutable map.
Maintenance of the map will be simpler than that of the list
no need to say "public" here, it is always public in an interface. "static" is important though.
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
try using getOrCompute instead. Besides delaying creation of the collection to the moment where a key actually wasn't found, it also stored the result in the map, making it somewhat faster for consecutive invocations.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Can this be private, or is there another use case for default attribute outside the builder's call?
Current code doesn't detect port 8080 is used by my local EAP. The only way it works for me is if it's implemented as  java try (Socket socket = new Socket("localhost", port)){ return true; } catch (IOException e) { return false; }
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
Let's add a message here: "Checking if port XXXX is in use...".
Could use port 0 to avoid someone else stealing the port.
Should be > I think, as we _could_ have found port 65535 was available.
Why is this still using the Id?
format should default to "tar.gz" is null or empty and not throw an exception.
Why is this still using the Id?
I think this is ripe for unit tests, along with removing relations to make sure the tree is pruned.
A design where this is side effect free would be most desirable.
Unfortunately, you cannot delete this method. This is how we initialize our Indices when they are created via reflection in the AccumuloRyaDAO.
Just let the exception bubble up, otherwise it can be confusing to debug IOException ' s.
I would not print anything to stderr. I would suggest using a logger and use it in both cases (cleanMethod or invokeCleanerMethod)
I think the following variant would be simpler  } catch (IOException | ApiException | MachineTokenException e) ... }
no need for this double nested try/catch, move this block to the cleanMySqlCleanupThreadsThreadFactory method if want to log that this particular cleanup failed. Is more cohesive to handle the exception for logging in the method that has the logic that failed.
rename
not all listener
maybe rename?
rename
not all listener
Should we return immutable list here?
@v-stepanov Is method marked as @Nullable ?
Is there a reason to create an ArrayList here instead of using Collections.emptyList() ?
Why empty? It supports ALL streams!
use the interface here
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
This is a bug
This is wrong.
![MAJOR](<LINK_0> 'Severity: MAJOR') Constructor has 12 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
suggestion
this should be config.get("path-style-access", boolean.class, false)
It is good to have a method to convert config.get(Config.TOPOLOGY_RELIABILITY_MODE) to enum and then compare two enum values. Comparing two Strings is error prone.
This code should use instead entrySet
please remove or decrease log level to TRACE
Nits: use Map as the variable type, and omit the generic types after HashMap. You're also missing spaces before arguments as in ",hints)" instead of ", hints)"
This method should first attempt to get it's result from a file stub.
@ivandalbosco This method should be annotated withjavax.annotation.CheckForNull.
That's wrong. Please see org.intellij.erlang.psi.ErlangSpecFun#getReference and isReferenceTo() method.
java if (function.isDeterministic() && hasInputs(function) && allConstantInputs(function) && !evaluateDeterministicFilterFunctionWithConstantInputs(function)) { return false; }
xor should take care of these two checks
Please add ioe to the exception.
Please add ioe to the exception.
we should pull the ObjectMapper out as a static final and use Afterburner, to avoid thrashing and testing too much serDe  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().registerModule(new AfterburnerModule());
Yes. I would say this is an api change. So we should deprecate the old method first
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
Ahhh, the speaking check is here. Calling speakNames() to have to sometimes not speak names is confusing and wastes a method call. I think we should just pass the boolean into presentation manager.
null != settings
I think the existing code is correct for the "jump" plot behavior - this should advance the plot as time marches on. Although this change would result in desired behavior for the non-changing historical data, it would result in incorrect behavior for live/streaming data. The issue comes from the fact that settings.getMaxTime() is returning system time in the first place. This makes sense as a reasonable default only in the absence of a time service, but should be overridden if a time service is available. Some care should be taken to ensure that only defaults are overridden in this manner (e.g. to avoid overriding when getMaxTime() is returning a persisted user-specified value.)
Since both annotations define a default value when is this ever 0?
Looks like you forgot to pass ignoreTrailingAndLeadingWhitespace to CsvParserSettings.
This doesn't honor the contract of an iterator's remove. In fact, i'm not sure you can support this atomically with only a single file.
How is this changing how it used to work previously?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Should the override annotation be on a separate line (not sure of the convention in this codebase)?
As this operation is optional, just say it won't be supported because it's not mandatory.
Static string constants
Could you please replace this boilerplate pattern with a single method registerSerde(String, Supplier<ComplexMetricSerde>) thoughout the code?
How did this happen?
No tests to cover this method! :open_mouth:
Could use .get instead of .getOrDefault
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
minor: can you regenerate toString to reflect the renamed variables.
This should also flag whether the binary is reused.
Should have a space after add
Another space after add
binding -> bindings
@prachidamle you shouldn't need to quote the string. The nature of program arguments is that they are passed as a whole string.
This doesn't feel like an improvement; the original form was easier to follow, IMO, despite the ugly lack of whitespace around the binary operators ;o)
I'm wondering why we even need this class; can we not simply add a boolean property to the base class called "appendPartitionId" ? Also, the ticket description says "If SingleFileOutputOperator is partitioned into **more than one** physical instances then it should append partitionId to file name" (my emphasis), I don't see any check for that condition before appending the partition id.
context.PROCESSING_MODE => OperatorContext.PROCESSING_MODE (to get rid of "The static field Context.OperatorContext.PROCESSING_MODE should be accessed in a static way")
I'm thinking if we could provide an automatic way to call these method by set annotation on the field just like those IoC frameworks do
You could simply do super.setClazz(CommonLog.class)... You don't need to have a vaeiable pojoClass.
As it is a new behaviour, should this be exposed as a new method in the operator interface? This allows us to identify the operators that actually make use of this feature.
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
Remove this
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
when doing enum comparison the double-equal operator (==) is a bit nicer to use :)
Missing StringUtils.isNotNullOrEmpty() check
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
My problem here is that the timeout is coming from another place (that will override this). I don't like properties coming from two places. I don't have the best answer but I don't think it's a good idea.
What is this test for?
I think we could reduce this constructor to a call to another constructor:  java this(configuration, null);
this is perhaps incorrect. This queue should be Multiple publisher single consumer
As iirc a HC can not spontaneously become a DC, I wonder if we could cache this data. Otoh, this is a relatively light-weight call and not done often, so probably does not warrant the hassle of cache invalidation checks.
F.isEmpty()
What about skipping parenthesis, so that we still raise issue for the following: conn.setRequestProperty("Authorization", ("Basic " + encoding + encoding))
It seems this check is not necessary because it is covered by the scheduled.compareAndSet logic.
[minor] This return value from safeUri() should be reused a few lines below.
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
@tsurdilo take a look at org.jbpm.kie.services.impl.CommonUtils.getAuthenticatedUserRoles(IdentityProvider) that does some additional logic in case roles are empty list. There is an issue with some dbs handling empty list as part of in clause
getStorageDomain is the TARGET domain - you should get the SOURCE domain according to the storageDomainId parameter passed.
This block is repeated here: <LINK_0> It could be refactored as a private method to avoid repetition: > @Override public Collection<CaseInstance> getSubCaseInstancesByParentCaseId(String parentCaseId, List<CaseStatus> statuses, QueryContext queryContext) { List<String> ids = Arrays.asList(parentCaseId); return getSubCaseInstances(ids, statuses, queryContext); } @Override public Collection<CaseInstance> getAllDescendantSubCaseInstancesByParentCaseId(String parentCaseId, List<CaseStatus> statuses, QueryContext queryContext) { // this will iterate foreach level. It will do as much queries as levels in the hierarchy List<CaseInstance> cases = new ArrayList<>(); List<String> ids = Arrays.asList(parentCaseId); do { List<CaseInstance> processInstances = getSubCaseInstances(ids, statuses, queryContext); cases.addAll(processInstances); ids = processInstances.stream().map(CaseInstance::getCaseId).collect(Collectors.toList()); } while (!ids.isEmpty()); // empty means there are not more leves to go return cases; } private List<CaseInstance> getSubCaseInstances(List<String> ids, List<CaseStatus> statuses, QueryContext queryContext) { Map<String, Object> params = new HashMap<>(); params.put("parentCaseId", ids); params.put("statuses", resolveCaseStatuses(statuses)); applyQueryContext(params, queryContext); applyDeploymentFilter(params); return commandService.execute(new QueryNameCommand<List<CaseInstance>>("getSubCaseInstancesByParentCaseIds", params)); }
> public abstract class ExecutionStrategy { this super(); call doesn't need to be here
collect to a set that can preserve order?
I don't think it's necessary to create a set here since it accepts collections and then tries to figure out the fastest way to check them.
We should check whether the variant context in the output vcf is filtered. The output vcf in testDreamTumorNormal has one filtered site (20:38245275, alt_allele_in_normal) and it's counted as a false positive. This applies to calculateConcordance in HaplotypeCallerIntegrationTest also.
pico-optimization: dataStreams not needed until after templateName is confirmed to exist
Method newTargetGroups has a Cognitive Complexity of 8 (exceeds 5 allowed). Consider refactoring.
Once again, just use getMonth(calendar), which embeds the knowledge of the +1 difference in its body. DRY.
But existing rows use null not "" for the parentUuid.
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
CheckReturnValue?
style: extra parentheses
we need good docs here
remove throws OseeCoreException
Swap the order of modifiers, like it in all other methods in this class.
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Remote exception handling changed a bit, so I think you can make this more specific: if (throwable instance of RemoteException && throwable.getCause() instanceof RetryPrepareException).
I think you want isPossiblyOkHttpTimeoutBug(cause) otherwise it will SO.
Do we want to include the original throwable so it can be shown in stacktrace as "caused by"?
Again, we shouldn't do this.
Optional.map
Optional.map
You should pass here message not group converted to string.
These might look a bit tidier as static imports
There should be an assertion around this.
remove
NPE if header missing.
How about to use here NamedParameterJdbcTemplate as you've done in the JdbcChannelMessageStore#doPollForMessage ?
formatting
unused variable
Add here if (outlinePage != null) { outlinePage.setSelection(new StructuredSelection(selected)); } to make the normal outline page follow the selection in the quick outline.
How about return ((List<?>) ((IStructuredSelection) selection).toList()) .stream().allMatch(e -> e instanceof RepositoryNode); ?
boolean canExecute = false; if (selection != null) { canExecute = Iterables.all(selection, Predicates.instanceof( AbstractToolDescription.class)); } return canExcute;
Why do you not return directly the condition value ?
If the argument selection is a NodeSelection then the method brakes it's contract and doesn't create a new instance. I'd remove the if statement.
Is there a subclass? I'd like to see these protected methods be private if possible.
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
unnecessary parenthesis?
Should check if the Counterparty that should be updated belongs to the logged AppUser
A validation should be made to compare the oldCategory.getUser() to current authenticated user. Maybe...what do you think?
See UseCase.
remove unnecessary { return x; } around wrapBlocking
remove unnecessary { return x; } around wrapBlocking
Add not-null check here.
@aklish what do we expect if both initializer and injector are defined?
Maybe some not-null check should be added here.
Is this code well-covered with tests? The spot where it moved to is different in ways that I don't entirely understand (like where did line 715 go, and why did the set turn into an inc?).
Maybe this should use makeUnknown instead of getUnknown. I think the difference is that makeUnknown will create a new one, and the new one will have its own insert date and user. I think getUnknown will cause all placeholders to have the same insert date and user.
Why change the name the property? Accident due to mass refactor/rename with IDE?
Translate this RuntimeException message in English please
space before {
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
Let's use the same logger we use for the rest of Baragon rather than System.out, for example <LINK_0>
nit, Collections.EMPTY_MAP?
what if the subExpr is empty ?
Now that this will be returning an object that is never null, refactor Optional return to Map<String, String>
s/on name. But got:/by name but got:/
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
How about remove the property, rather than set it.
super.init() method never throw an exception.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
immutable copy!
Should make sure the constructor and this method follow the same pattern around ensuring the internal values list isn't mutable. Right now the constructor will clone the list, effectively a deep clone based on how Strings work, ensuring it is immutable if the original list changes but this will return a reference to the internal list that could be mutated.
Can't this be further improved to just Arrays.asList(values)?
This seems like a mismatch, maybe you should not include the @Nullable here?
Nit - just return Arrays.asList("createSockets", "getInsecure") instead?
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Do same for this one
> new Date(mExpiresOn.getTime()) [](start = 15, length = 30) why are we returning a new object? #Closed
I wouldn't fix this in the same PR. Probably a separate PR for this fix would be better. It's not related to this change.
Why you are using diffrent methods here? 1 . new Date(onsetDate.getTime()) 2. (Date) endDate.clone() Better to keep the consistency among the code, and provide your feedback why did you select that among others.
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Is it really filter name?
This should stay final
Should this method be final?
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Currently we know that close doesn't throw, but just to make the code future proof we can use guava Closer here to make sure that both readers get closed.
If the first orchestrator throws an exception when closing, the second one will never get closed. Please use a closer instead; see org.hibernate.search.backend.elasticsearch.impl.ElasticsearchBackendImpl#close for an example.
Why not closer.register(...::close), as above?
close should invalidate the iterator, but you are reliant on the internal iterator for this. You should have a flag isOpen (or isClosed) that is checked for the various methods. Take a look at htsjdk/samtools/util/CloseableIterator.java You should also (evidently) call close() if hasNext is about to return false.
I think it will be better to close the other store as well.
lockRefreshToken should be set to Optional.empty() here, otherwise isHeld() will still return true. There should be a test for this.
This seems needlessly complex. You're using a boolean supplier to assertTrue. Why not just call doSomething() directly?
fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)
Yeah, unfortunately the FunctionalInterface->Object conversion doesn't usually go well.
Do we not want to filter on isInstance first? (even just to protect from wierd bundle reloading errors?)
We don't need this, the ConfigSaved would handle this already.
Typo
as a suggestion you could remove the followup NPE check and use Objects.requireNonNull suggestion org.eclipse.core.resources.IProject project = Objects.requireNonNull(getProject(referencePoint), "No project found for reference point: " + referencePoint);
I disagree that this is the right place for it, it's hiding this logic in an unrelated place, I think this call needs to be done explicitly where the remove is called (as is the case for statistics)
Just thrown an Exception.
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_1>
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
Need to use parameterized logging instead of string concatenation.
Also not comfortable with this.
May or may not be necessary to e.getMessage() as well as , e ... you're going to get the message duplicated in logs.
Missing codes.
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
@Nadahar Right, text/vtt, i was too fast...my bad.
Should maybe other countries be added here?
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
same here simply inline the attributes variable
if you do not need the variable to make assertions just inline it patientService.getDuplicatePatientsByAttributes(null);
Encapsulation
non -> not
The binding shouldn't refer to the currently selected entry because this might change in the future and then the binding needs to be reevaluated. The following should work suggestion ObjectBinding<BibEntry> entry = Bindings.valueAt(selectedEntries, 0); return Bindings.createBooleanBinding(() -> { if (entry.get() == null) return false; else return entry.get().getFields().stream().anyMatch(fields::contains); }, entry, entry.getFieldsObserable());
I think entry.getFields().stream().anyMatch(fields::contains) is slightly better performance wise (as disjoint needs to check if *all* elements of fields are not contained in entry.getFields())
does queryNextPage need the query string again?
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
Not sure if this is a good place for the current limitation for window functions. The same limitation applies for non-aggregate functions so we'd have to limit that elsewhere anyway. I'd remove this limitation at the parser level.
Can you avoid duplicate code here? (PreferenceManager.getDefaultSharedPreferences)
you can directly put .commit() at the end of this. Editor calls always return the Editor again ;)
java @Override protected void setUp() throws Exception { super.setUp();
It is best practice to use editor.apply() as commit() should not be called from the UI thread.
Instead of assigning the variable here, update the variable in the CrashReporter.initialize method itself.
We are always in a case of an AbstractDiagramElementContainerEditPart host here?
This API is only reliable when the notifier is known a priori to be of the 'expectedClass' type. Usually we just check whether notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED The getFeatureID API is usually only employed for notifiers that aren't Objects, such as Resources and ResourceSets.
rename fileInfo to ledgerInfo
event.equals("clear")
Nitpick: the instanceof check is redundant here.
EchoParametersDao.getEchoParameters() already returns a list.
this variable may make more sense just as itag given it isn't only for items.
I am not familiar with the script cache stuff, but this will delazify the cache contents and hold it all into memory. Is this okay?
Idem about null list
.forEach(intervals::add) avoids materializing extra list
We can use guava Closer to make sure we close all of these clients (just in case if one of them throws a runtime exception in the middle of the loop)
rename to breakpointRequest
can't foreach be used here?
Empty line.
Please let's use getUploadQueue() here instead - as mQueue could be null and we're using it like this elsewhere in the Service code
This might throw exception
make this private and move it after public constructor
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
Please add the cause here.
if (max < min) ??
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
I know this is not introduced in this PR, but could we consider not allocating the buffer multiple times (here we would allocate three times, each in different levels of the object's serialize() function).
if you want to be Really Fancy, you could rewrite this as:  java final Optional<TimeZoneHistory> timeZone = this.timeZoneHistoryDAODynamoDB.getCurrentTimeZone(accountId); final Optional<DateTime> nowForUser = timeZone.transform(new Function<? super TimeZoneHistory, DateTime>() { @Override public DateTime apply(TimeZoneHistory history) { return DateTime.now(DateTimeZone.UTC) .plusMillis(history.offsetMillis) .withTimeAtStartOfDay(); } }); return nowForUser.or(new Supplier<? extends DateTime>() { @Override public DateTime get() { return DateTime.now(DateTimeZone.UTC).withTimeAtStartOfDay(); } });
both filtering methods should also be abstracted I believe. edit: by both I mean this one and the one above. the only difference being && or ||.
Is it better to get the value out to some variables so debugging could be easier?
Does it still make sense to use forkJoinPool? The tiles are no longer downloaded at this point, so it would add an overhead to run this in parallel.
Could you check for null or empty? Via StringUtils.isBlank
Why do we need this constructor? It doesn't use the 2nd parameter...
can these parameters be grouped into smaller and more meaningful objects?
Symmetry (throw)?
What you should be sending is the cluster compatibility version, not a constant version.. You could send the host's version but that would be confusing to the users. The norm in oVirt is to restrict version specific features by either cluster or DC - since this is clearly related to cluster (and not related to storage), the restriction should be by cluster level.
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
when can it be null?
can be simplified to: ValidationResult.failWith(VdcBllMessages.PLUGGED_UNLINKED_VM_INTERFACE_WITH_EXTERNAL_NETWORK_IS_NOT_SUPPORTED) .when(RequiredAction.PLUG == getRequiredAction() && !nic.isLinked() && isVnicAttachedToExternalNetwork());
would you mind reverting the condition into a positive form ? return FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion()) ? ValidationResult.VALID: new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
Lists obtained from a message are immutable. No need for extra copying.
Maybe unmodifiable
does this have to be a list or can it be an iterable?
Style issue: @Override shuld be on line above the method declaration
We don't need another ImmutableList.copyOf. You are doing this when parsing.
I don't see where we handle HibernernateException.
it would be nice if we could instead use a class called Wait, that would keep trying until a certain condition was reached in the server. This type of sleep will certainly eventually fail. i'm looking for a case where the test always pass.. with this we will still have eventually a failure.
I think we should add this datum to the frame and confirm that the session also successfully moves on (just to ensure the end-to-end is also still working)
Oh yes, can change this back to formatDateTimeForSessions and delete this method from TimeHelper? It's a workaround for this issue.
why are we changing the visibility of these methods?
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
From the code it appears that 'nulls' may be in the Iterable<TokenCacheItem> returned. Because we create the collection as ArrayList<TokenCacheItem> tokens = new ArrayList<TokenCacheItem>(results.values().size()); If decrypt fails, we will not add the tokenCacheItem.
we never use NULL, it is a bad practice in general.
List
nit: line to long (break each parameter in it's own line)
suggestion return new SearchHitsImpl<String>(hits.size(), TotalHitsRelation.EQUAL_TO, 0, "1234", hits, null);
nit, Collections.EMPTY_MAP?
- s/userPassCollection/userPass - s/userPass/userAndPassword - s/lastIndex/atPos - s/firstIndex/colonPos  for (String userPass : userPasses) { int atPos = userPass.lastIndexOf('@'); checkArgument(atPos > 0, "Invalid Credential format. Requires user:password@collection"); String userAndPassword = userPass.substring(0, atPos); String collection = userPass.substring(atPos + 1); int colonPos = userAndPassword.indexOf(':'); checkArgument(colonPos > 0, "Invalid Credential format. Requires user:password@collection"); String user = userAndPassword.substring(0, colonPos); String password = userAndPassword.substring(colonPos + 1); builder.add(createCredential(user, collection, password.toCharArray())); }
Why this change?
0 is the default value for an int field. We do not make assignments to default values in constructors.
Could use assertEquals?
maybe also add?:  java mapper.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, false);
Does this need to be a perpetual change or is it bound by this method? If it is the latter, I'd reset the context classloader to its original value in a finally block in this method.
final
I believe that we want this test to return a UnsupportedEntityIdValue too
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Sure thing. Though I still think there is an interesting case to be made for a "heavy-handed" view even in this case... my intuition is that it's odd that the view output's root and all strings originate in the middle of a SQL query. It smells like action-at-a-distance between layers. Oh well, a debate for another time if anyone is interested.
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
you may want to get into a good habit of using guava builders (Lists.newArrayList)
random? really? I would have used idFor(). public ObjectId insert(int objectType, byte[] data) { return idFor(type, data); } public ObjectId insert(int type, long len, InputStream in) { return idFor(type, len, in); } or something like that. I forget which of the insert methods is the "bottom" of the call stack before punting to the InputStream version that is required, but I would implement both in terms of idFor and return the actual SHA-1.
Shouldn't this be set to false?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
No, this. when you call methods.
Can this be private, or is there another use case for default attribute outside the builder's call?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
The agg function here should be adjusted to support the optional compression param like in the quantile version
This looks like it would have different behavior from what was there before. If this is based on the path, I'd expect needing to go through getFormFilePath (the method that builds database paths based on whether or not scoped storage is used).
secretLabels = Arrays.stream(labels) .map(l -> l.split("=", 2)) .collect(Collectors.toMap(p -> p[0], p -> p.length == 1 ? "" : p[1]));  ?
We shall trim at the final values level but not the above layers. What do you think?
Consider returning a constant
@Nadahar Right, text/vtt, i was too fast...my bad.
Should maybe other countries be added here?
Fair enough. I don't think it was meant as a cost saving thing, just to make it easier to understand when something did or did not have caught-up clients. If you find this logic easier to follow, go for it
suggestion private MockClientState getMockClientWithPreviousCaughtUpTasks(final Set<TaskId> statefulActiveTasks) {
Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?
I'd just like to say what an awesome tool for optimization this class is. Kudos to you and @cadonna .
This doesn't really make sense, onPartitionsRevoked is always called before onAssignment
should be VOT.Storage
this should be the disk id, not the image id
would you mind inverting the condition to simplify it and skip the negation ? if (isImageProvided()) { ... } else { ... }
CommandBase.checkPermissions will always return true for this, meaning will authorize the user to perform this action. It would be better assign null value to dataCenterId.
need to change to copy/move on disk
No need for the *31 here.
bad hashcode.
static
Use Guava hashCode function
typically, you don't use getters when inside the same class
nit: Maybe more explicit:  Only function definition classes (classes annotated with @ScalarFunction) can define SQL functions via non-static java function. Function set classes can only define SQL functions via static java functions. Thus constructor in function set classes is used to define SQL functions.
this can be done with a stream, filter & collect so it'd look something like this return film.getPeople().stream() .filter(crewMember -> crewMember.publisher() != Publisher.RADIO_TIMES) .collect(MoreCollectors.toImmutableList);
This should probably be private.
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
I fail to see any reason why an ImmutableList would be needed here. You know it's just an ArrayList internally right?
You can use CollectionUtils.toImmutableList
this.
This variable name is misleading. These bounds are _not_ verified at the time this call is made - they are the candidates you want to verify. In the previous model it was correct (because that's where you start the query from).
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
This is quite a heavy class and it feels like the last two parts on translating PaxosHistoryOnRemote to CompletePaxosHistoryForNamespaceAndUseCase seems a bit of a separate concern from getting the data which the first three parts here do. We should split this up, though I'm fine with getting this in first as long as we track doing this when we return to this project later on.
Couple more static imports here?
Another static import?
Statics
Static imports again?
...and again... ;-)
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Immutable fileinfo
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Can this be private, or is there another use case for default attribute outside the builder's call?
Should be ClassNotFoundException. Catching all exceptions and disposing them may miss unexpected exceptions.
This is the wrong method to update, replace the one that was called here. For a global check if the patch was successful check for references like registerDeploymentPlan, instantiate, they should we restricted to the EntityManagementUtils class only (outside of camp projects).
How about narrowing it to ClassNotFoundException and fail with other exceptions?
Can this case happen? We initialize app in onCreate(). If so, can we initialize app in onAttach instead?
combine these two lines -> OwApplicability app = artifact.getAppId();
Can StringUtils.fromUtf8 be used?
@nielsbasjes Is making this method public really necessary? Do we need to expose this method in the public APIs? Can't it be package private?
final float sleepDuration = (int) ((double)  feels odd.
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
skipId
Methods in Preconditions should be imported statically
This can be removed.
Do you think we can use an [unmodifiable map](<LINK_0> here?
just return "" instead of new String()
Just a small note: the add(...) method on Set<T> returns false if the element already exists in the set so the contains check here is actually superfluous. The code could be changed to:  if (!items.add(name)) { LOGGER.warn("Overriding the existing {} registered with the name: {}", type, name); }
StringPool.EMPTY instead
I think there is some findbugs issue with not using {} not sure.
Generic type not used, remove.
1. what if value is not bool? exception? you should be able to recover from it nicely 2. you doing unneeded boxing, by returning class where primitive expected, use Boolean.parseBoolean() instead 3. please cache the value of the header, there might be few queries during the hit calling isFiltered(), - you don't need to preform header retrieval and casting every time.
I think it is better to throw exception
Why are you looping here? Can you give a use-case?
Should we return true at some point? It looks like the old code could.
I think a foreach loop here would be shorter and easier to read - or a lambda expression in future
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
Shouldn't we throw a NoSuchElementException instead?
Do we really want to always assume Latin-1?
Could just use Arrays.fill(max_byte_arr, (byte) 0xff); here
please remove TODO and printStackTrace() and use proper logging instead
use Bytes.memcmp()
Could you explain the contract here in a docstring? If two arrays are different lengths why are they equal if they have the same content up to the length of the smaller array?
Why don't we make inDegrees to ConcurrentHashMap also?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Why is no this. used in lines 320-321 but this. used in lines 322-326?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
KETTLE_LOGGING_REGISTRY_PURGE_TIMEOUT should probably be a constant in Const.java for consistency with most other kettle params. I know KETTLE_MAX_LOGGING_REGISTRY_SIZE was already there before, but should probably also be defined in Const.java.
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
A for each loop on the listeners can be used here instead.
should this count be parameterized?
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
setSelection takes an ISelection, no need to cast what you get from the viewer. you also do not need a local variable
you can use IStructuredViewer::getStructuredSelection
remove assertion and change ISelection to IStructuredSelection
change to IStructuredSelection
Why do we need a snapshot of the world? Isn't it possible to just use getCurrentState() to get the selection?
I am still in favor of removing this static. I don't think its necessary. I think if tserver wants to keep one instance, then it should keep a reference to it. All the current static stuff we have is troublesome and we would like to move away from it. Could rename this method to newInstance if you drop the static.
The cause should really have an abstract method for this instead. And return EnumCause rather than Enum<EnumCause> from its method.
Return this enum from the Target instance.
These seem to be covered by NUMBER_TYPES already?
Why you will need substring() when Class.getSimpleName() would only return the class' own name without package? Please remove.
This should be part of the try-with-resources block.
This is ok but can be made more compact: java try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()))) {
we can use try-with-resources statement and avoid the finally clause
use FileUtils.createNewFile() instead in order to check return value
Please move the write down, so that it is performed only if the file has been created and the permissions changed.
Item dropped should be a hopper
my guess is that this should be: return receivedStatus[0] == statusCode[0] && receivedStatus[1] == statusCode[1];
this for is exactly the same in all the array tests, let's move it to a private method
This seems redundant to me as we are logging in as the current user in the base class.
final
is this still needed?
This will throw redundancy warnings in IntelliJ
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Style issue: @Override shuld be on line above the method declaration
Why is it a list of lists, not just a list?
The this. in getters are unnecessary too.
public @Nullable String...
Why do we return the parents name instead of the name we store a few lines above?
You should use toLowerCase(Locale.ROOT) as using using "toLowerCase" by itself will use the default locale (which may lowercase incorrectly depending on the language)
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
assertTrue or assertFalse but never equals. Also add a message so if it fails you know what has failed.
When using suggestion Assert.assertThat(testRealmResource().users().search("a", true), Matchers.hasSize(0)); Assert.assertThat(testRealmResource().users().search("apollo", true), Matchers.hasSize(1)); Assert.assertThat(testRealmResource().users().search("tbrady", true), Matchers.hasSize(1));  the output on failure shows the search results which is better for debugging potential failures.
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Shouldn't this also test an Array that is empty, i.e []? Instead of a String that is empty, ""? Also, I am wondering about multi-dimensional arrays which is kinda the point of deepToString... If the array contains other arrays as elements, the string representation contains their contents and so on. <LINK_0>
You can use assertTrue and assertFalse instead of assertEquals, that will give better error messages when the tests fails :)
Missing types
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
We were going to avoid signatures like IgniteFunction<Stream<UpstreamEntry<K, V>>, Stream<UpstreamEntry<K, V>>>, right?
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
any special characters to block in webhook name?
you should probably check Item.Configure here
Catching a generic Exception is poor practice.
According to <LINK_0>, while _most_ of the --security-opt arguments are of the form "name=value", there's at least one that isn't: > --security-opt="no-new-privileges:true|false" : Disable/enable container processes from gaining new privileges ...and this is then further confused by the example: > docker run --security-opt no-new-privileges -it centos bash which doesn't have a :true or :false at the end. As-is, this code would complain to the user if they specified that option in either form.
Single or double pipe?
I think a compare between capacity and maxPageBytes is still reasonable here - even through the capacity > maxPageBytes is always true here. Because we cannot ensure the private HeaderChannelBuffer constructor is always called in create. Maybe it will be called somewhere else someday? A compare here may seem redundant now but will decouple the private constructor and the create
Might be nice to list valid dio pins out in the message?
This code should be:  this.channel.close();
Did it help in any scenario or is it a defensive programming?
Can we make logger a private static final
You don't need to save an ObjectReader; you can call readValue directly on the ObjectMapper.
nit: Suggest renaming iterations and its getter as well here
this and m_ is redundant
How about adding this log message to CheckpointManager?
what does compare and hascode mean for datanode if they have different ssl ports?
how could contributions be null? Create it at the field level if you want. It should also be final. There are minor style violations in this file, no spaces around operators
This can never be null given the code in setData above?
This branch is not needed
do {   } while (current == null) is more natural here.
why this change?
I think the current state of the art is to do something like: int hc = key.hashCode(); hc *= 31; hc += value.hashCode(); return hc; But actually for an attribute there aren't too many that can can be multi-valued, are there? So just using the key's hashCode as our own hashCode might be sufficient here.
this client side GWT compiled classes needs a sort of sanitized hashCode implementaiton using our utility class HashUtils. Should look something like this @Override public int hashCode() { return HashUtil.combineHashCodes(super.hashCode(), executionSet.hashCode()); }
add requireNonNull for bytes
HashUtil.combineHashCodes
Currently we don't have PERUNOBSERVER role assignable by config to specific credentials (unlike perun admin). This mean, we will always have User, related to this role. So anywhere, check on SELF (without specifying user or where passed user is only own) will let PERUNOBSERVER pass too. Only if it would filter result, we would have to separate them. What do you think @stavamichal @licehammer @martin-kuba ? Will we need PERUNOBSERVER role for accounts without User in Perun or not ? I suppose not, it is always safer to have account with contact info etc.
Since this method process any type of attributes, exception text is misleading. You can get eg. facility attributes with non-null value from all facilities specified by attribute definition.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
Please add also VOOBSERVER.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
type might not always be a Class. If the API method returns List<User> this will be a ParamterizedType which isn't not a Class.
space after ,
It's not a good design pattern to close resource-parameters in methods. There are the following converntions (which may violated in certain cases) - If you pass in a resource, the caller is responsible to close it - If you wrap a stream (e.g. new BufferedInputStream(is)), closing the outer stream will close also the inner. You should fix that resource leak at the caller side, there is only one in io.ebean.config.properties.Loader: java void loadYaml(String resourcePath, Source source) { if (yamlLoader != null) { try (InputStream is = resource(resourcePath, source)) { yamlLoader.load(is); } catch (Exception e) { log.warn("Failed to read yml from:" + resourcePath, e); } } }
you have lost the cause e
close already done in Util.read(..)
should be debug and consider moving logging to checkData()
Could be written on one line RemoteService.getRemoteService().doRemoteFunction(value)
we don't need to change the Creation classes.
please decrease log level to DEBUG
Would it be clearer using _routingTableChangeListenerMap.entrySet().forEach((k, v) -> k.onRoutingTableChange(...));
please keep style changes separate from PRs (or better just don't create them at all)
Should reset the values in the config file too?
Alternatively you could have a static constant Set<String> and do a contains(). It would go nicely when we can use a Set.of.
I thin we should create a new method httpMethod() that will return the enum and then deprecate this one to be removed on feign 12!?
please extract key as constant
Please extract this string
It'd be safer to put EXTRA_SUBJECT only if !TextUtils.isEmpty(subject)
I would try to reduce the code duplication by something like that  final Class... activity; if (PreferencesHelper.getCreateAccountStatus() == CreateAccountStatus.WAITING_FOR_SMS) { activity = VerifyNumberActivity.class; } else { activity = AgreeActivity.class; } startActivity(new Intent(this, activity).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP));
Use strings.xml
Should be Localized in Android framework.
static imports
static imports
In general we use == to compare classes (Cf. *AdapterFactory implementations for example)
You can use StringUtils from the commons.lang3?
This method can be static, as all the methods it calls.
does this have to be a list or can it be an iterable?
why public?
What about :  names = new ArrayList<>(attributes.keySet());
You can seed the size since it it known.
will this skip empty strings?
innerInterfaceOrClass checks parentType, but in line 236 similar check is performed. They can be merged in one method
When is it not identifier? And does this cover things like new OuterClass.InnerClass() or new package.Class().
Please split this if into two and revert else if. The condition will be easy to read. Or, the whole condition can be inverted: java final DetailAST parametersNode = ast.findFirstToken(TokenTypes.PARAMETERS); if (parametersNode != null) { TokenUtil.forEachChild(parametersNode, TokenTypes.PARAMETER_DEF, super::visitToken); } else if (ast.getParent().getType() != TokenTypes.SWITCH_RULE) { super.visitToken(ast); }
This can be  return nextSibling != null && nextSibling.getType() == TokenTypes.SLIST && nextSibling.getFirstChild().getType() != TokenTypes.SLIST;
vmIsDown() == true than vmIsUnlocked() == true vmIsDown() == false than vmIsUnlocked() will not be checked.
createObjectFromMap(name, NAME_TO_FULL_MODULE_NAME); should be the first thing we try. It will be the fastest and the most common scenario. pure createObject(name) should probably be used last when user supplies full package as name. Order of finding module should be, imo: 1) our module map test 2) 3rd party map test 3) full package (or raw) test 4) fail. We can probably discuss skipping 1-2 if given name has a period in it. 3 is only really needed if we don't examine maps for the full package. I don't really see a benefit from doing this.
just return "" instead of new String()
This check is useless as the customParams can never be null.
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
style nit: since quite a while we use curly braces around single line blocks so missing braces should be added when touching old code not following this rule
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
please inject the DAO
try to consolidate with the previous method
shouldn't there be any validation to the cron expression correctness ?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
What do you think about changing to stripContextPath(request)? So stripContextPath ask for contextPath and requestURI internally.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
nit: s/upload/upload ID/ I was thinking of consistent log keywords so taht for any retry log we can search "upload ID" or "commit ID"
I think it's time to key on a proper object
suggestion
extension can't be empty or /
extension.toString()
Why don't instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
Could be protected instead (and it could be defined before the nested class).
I would change this to if(url == null) { return null; } less indentation, code looks a lot cleaner
I understand the purpose of the change is to make sure we streamline the value change in the class variables to happen as late in time as possible, and issue the notifyDatSetChanged() signal right after that. Can we then enclose these 3 below lines in a synchronized block to make sure these 3 are packed together in an atomic action?
Should this be as in OzaBag?  @Override protected Measurement[] getModelMeasurementsImpl() { return new Measurement[]{new Measurement("ensemble size", this.ensemble != null ? this.ensemble.length : 0)}; } @Override public Classifier[] getSubClassifiers() { return this.ensemble.clone(); }
needs US-ASCII charset, or some other simple ascii encoding conversion
delete the old file when a new one is generated? It's nice behavior to clean up our mess. Or use .deleteOnExit, if some tests might still be using the old file.
![MINOR](<LINK_0> Remove this unnecessary cast to "LaunchManager". [![rule](<LINK_1>](<LINK_2>
use 'waitForElementByElement(newestVideoDeleteIcon); and use 'waitForElementByElement(deleteConfirmButton); before each click
this method suppose to return instance of DiffPagePageObject class, because its redirecting to diff page beginning of the method should be: public DiffPagePageObject goToDiffPageFromHistoryPage() and last step should return new object: return new DiffPagePageObject(driver);
log () here and after
wait.forElementClickable() should be used before
log()
Are there mandatory parameters which require validation?
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
Let's keep the usage of force aligned with the rest of the backend commands: action.isSetForce() ? action.isForce() : false
no need for the failover treatment, this is done by the infra, just return doAction()
This won't invoke the additional interceptors, is that okay?
you could invert the if to avoid negate the condition.
Wouldn't Arrays.asList() be enough here? Arrays.stream seems to have a lot of memory overhead.
From the point of async store, it is not necessary to have the *function* serializable but the resulting entry. So the check does not belong here. The same holds for compute commands.
some invocations could be optimized. we can skip the read when ignore return values flags is used for example. Although, it may need to check if the key exists to trigger the correct notification.
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
the instanceof check includes a null check
Compare with null not necessary since null instanceof FileModelSource is false
please add braces for the else block.
please add braces for the else block.
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
Check if there is an appropriate constant for "no metakeys" mask.
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
volumeEntity.getStatus()
I think this should be replaceFailed = false instead.
Why don't we make inDegrees to ConcurrentHashMap also?
Why is no this. used in lines 320-321 but this. used in lines 322-326?
0 is a legitimate option value for min. selectable choices. Why not -1?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
Can you just make this constructor to call the other one?
Hey @oguzkocer , should this array include VIEWERS_TABLE as well?
IMO, return (int) Math.min(size, Integer.MAX_VALUE); looks better (as you did above)
In other places we use java.util.Math.toIntExact(long).
same about exception and doc Also resources might never be closed
I am a bit confused that this check will be called on almost every line of code.
I think it makes sense to use builder and return ImmutableSet...
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
probably don't want to keep filling this map up as we browse around. could just use getOrDefault?
Selenium already has a org.openqa.selenium.Cookie. There will be lower friction with other parts of the Selenium APIs if we return extant Selenium types. I think it's fine to extend those types to be more meaningful if necessary.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
pls use addStatus(new WarnStatus(message,this)); or addError(...) to report failures
Use Logger instead of System.out.println
Use Logger instead of System.out.println
This is not how it should be. This should be:  if (log.isDebugEnabled()) { log.logDebug( message ); }  Do not use "if (debug)" because this is hardcoded and will never be enabled. Do not use "setLogLevel()" because you're overriding the system administrator's configuration.
Reads nicely if this is written as if (isBinaryValueAvailable()) {.
this.sourceType
throw -> failure or exception?
diff - source.readInt() == 1 ? true : false + source.readInt() == 1
An empty message is OK.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Should this use RANDOM_PORT_INDICATOR instead of 0?
Please keep this.cell near the related fields (previousFamily & cell count) below
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
have a default constructor with reasonable default values
maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.
we can replace all these with getTxBuilder()
Why an event ID is built around project UUID?
nit -> Skip update of current version {} to {}, as they are the same.
Why?
nit: I'd prefer warn, this is probably not super actionable for us?
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
is there no common place (at the broker level) we can add the unioning query runner?
This can be static
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
Why not create the taskExecutionDAoFactoryBean in the ctor?
Should pass parameters along instead of doing null checks.
Instead of making it a singleton, why not create the connector in setUp?
setStarred would be a better name imo
What does "received" mean here? Please rephrase the message.
if we continue with this convention, please init to true also here
casting to Integer is redundant. IDE shows warning
not so readable. looks like good candidates for parametrization
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?
You probably want checkNotNull here - assertNotNull is no op if assertions are disabled resulting in a NPE below, checkNotNull will always fail on null leading to a consistent error message.
This bit of code needs the same treatment as lines 120-122 I think. If the evidence type is PasswordGuessEvidence, then return the result of getCredentialAcquireSupport for any algorithm (pass in null for the third argument).
I'm not a reviewer but FYI  CredentialModel.PASSWORD.equals(credentialType) in that order can't throw a null pointer exception, usually always the constants first because equals accept "null" but null don't have equals function.
What's the point of adding a copy here?
You can do credentialType.cast(...) here instead of the unsafe (C) cast which generates a warning.
can be replaced by List.of
Collections.addAll saves the wrapper object... although we don't need to go full-on nit picky on allocations like we would something in a library.
Please use Collections.addAll(Collection<? super T>, T...) instead.
The options are input only
use ImmutableList
why not an empty map?
@ILikeToNguyen Why the change in visibility here?
You can use Map.of
please extract as constant
This can be static.
Rather than calling run here, make run() call out to a no-args method like this: java public void onClick(View view) { // ... if (id == R.id.button_done) { nextWithEmailAndPassword(); } // ... } // ... @Override public void run() { nextWithEmailAndPassword(); } private voidNextWithEmailAndPassword() { next(mEmail, mPasswordField.getText().toString()); }
the if and else clauses here will both result in the same behavior below
I think you can remove the surrounding if, it's quite safe :]
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Why do you use a static newInstance Method? Just do it f.e. like this: AboutDialog aboutDialog = new AboutDialog(); aboutDialog.show(getFragmentManager(), "dialog");
Before go through the loop make sure that position and symbol parameters are not null.
Extract this into method getTotalSellAmount. The refactoring tool can do it automatically. Code smell Overly long function
needs to be named something more relevant like market
Returning an empty string when an invalid position is passed could hide some bugs. What do you think about skipping this position check so an ArrayIndexOutOfBoundsException occurs if an invalid position is passed?
Since this is a separate check anyways, I don't see a benefit in comparing with FFFD instead of 10000. Use >= Character.MIN_SUPPLEMENTARY_CODE_POINT instead. It's also more evident what the code is trying to do that way.
What does the magic number 2 mean?
Do you have unit tests? Again you need to use equals
Did you take a look at HibernateDiagnosisDAO? The service layer will delegate to the data access layer which fetches directly filtered data from the database instead of fetch it all and then filter in the application memory.
Was this implemented like so in the emrapi module?
Why is it a list of lists, not just a list?
name it github config
If you get something like an InterruptedException, this will just catch it and move on.
This line and the line above is migration code so that no db-script is needed, right? That's fine! Why not doing it in one place (maybe also together with the if-statement), so here or in SW360Utils?
What you have done is sensible and should speed things up by hitting the database less. But, the logic is now duplicated between ConvertUserDOToUserDTO and converUserDOsToUserDTOs. Changing the body of convertUserDOToDTO to just call the other with a list of size one will eliminate this duplication and avoid future bugs where we update one and not the other. Same goes for getAuthenticationProvidersByUsers and getSegueAccountExistenceByUsers.
it's more like initUsersAndOrganizations instead of Coduno ?
Idem this could be handled with an Optional...
If we are changing this code, then relying on Optional could be a good move.
If we are changing this code, then relying on Optional could be a good move.
If we modify this changeset, then we could give a try to using Optional here
Use Integer#valueOf(int), or delegate the work to the method above, so we can benefit from Java's internal int cache.
Wouldn't this test be more "accurate" if the only thing that changed in each entry was the timestamp (and not the value)?
exists is statically imported.
Unlike other tests, this test does not compose the chain using expected.
Wouldn't this test be more "accurate" if the only thing that changed in each entry was the timestamp (and not the value)?
Why 0,8 if all we are setting is 7?
Call I18N.getString(String) (there are no parameters in the resource messages).
Can we use url building here, to avoid problems with / at the end of the server.
this is confusing, it is called router but actually it is routerUrl.
Not provided the Locale in the first argument can cause issues depending on which user the Locale has the app set to. I ran into this with the Simperium library.
Probably should crash if bad format string
This logic needs updating to handle non-deterministic filters. See latest BooleanSelectiveStreamReader.
use filter.orElse(null) with requireNonNull this.filter = requireNonNull(filter, "filter is null").orElse(null);
Maybe add a requireNonNull for filter and outputType. Missed that before.
like in direct reader make this: checkArgument(filter.isPresent() || outputRequired, "filter must be present if output is not required");
isn't this already done by makeFiltersModifiable()?
I think the annotations should be on separate lines
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Same backward compatibility concern as in EC2AbstractSlave.
You could probably use the same URL as in getResultById here.
Why can't you just return value here?
remove static
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
Looks like this function is never used. Do we need at for this feature?
why not build this behavior right into TypeHelper.isA?
nit: suggestion if (HeaderParam.class.equals(annotation.annotationType())) {
Instead of FileHandler, you should use the PropertyConfigurationLayout to save it to a FileWriter.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Imagine we have 2 KIE Servers. None of them are up and running when we do the first round of client creation. So they both fall back to async creation. First KIE Server client creation then succeeds and it then forbids the scheduling of next possible tasks for other KIE Servers. I think we should just cancel the periodic task just for the KIE Server which we were able to connect to. So we should hold all tasks in a separate collection. Moreover, after the last task is removed, we can shut down the executor service.
i don't think its a good idea to include password in exception message
You could use try with resources here like this:  try (InputStream in = Config.class.getClassLoader().getResourceAsStream(fileName)) { config.load(in); }
I believe this line is incorrect and should be removed
This will only work if Jenkins is running on the same host as the docker daemon. It won't work in the general case where Jenkins is on a separate host from the docker hosts/swarms that it's talking to.
It seems cleaner to make this private, and add 2 static constructors: ServerFrontEnd.udp(adapter, port) ServerFrontEnd.tcp(adapter, port)
this could be moved to field level (practical reason next to one line less is we don't have to take care of it if we introduce a new constructor)
Is it a good idea to give access to the view directly to the page? Wouldn't it be better to have an inner class for the sheet page to access the contents?
hasAnnotatedAllParameters is already checked in the super class, right?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
What if extended SherlockActivity contains android MenuItem or vice versa? I haven't tried, but it seems that the user will get an error in generated folder.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
The super() returns "" on null. Why should we differ?
you can either remove else or add pair of curly brackets
why this double usage of URL? Wouldnt be using URI instead of URL be fully sufficient? (URL is known to have severe flaws and should be avoided if possible)
As per bug 487713#c11, the previous revision used to return the path in case of IOException. Do you think it makes sense to add that return statement?
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
As part of the bigger picture to eventually have checked exceptions, I think this should be specifically a runtime exception. We shouldn't hit the MalformedURLException, since the url is the same that was provided to us, minus the user info. So I think we should just throw a RuntimeException directly.
Is there a chance of a NPE? could be getFile() null?
Looking at the usages better throw in this case.
We need to keep the throw exception as we are not changing the existing behavior
Why do we return the parents name instead of the name we store a few lines above?
Use another name here. My suggestion is: Asset Options
@dmzaytsev let's inline this
Maybe expectThrowable for consistency?
Although your change enables editing the right-hand side if the left-hand side is read-only, the changes on the right-hand side still won't be saved; I assume you need to modify the check here too: (isLeft && getCompareConfiguration().isLeftEditable() || !isLeft && getCompareConfiguration().isRightEditable())
Don't initialize to empty when null.
Simpler as ImmutableMap.<String,String>of().
Add { and }.
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
I can't believe I let this line of code get in. Terrible.
hm, how about "...".equals(intent.getAction()) or TextUtils.equals(intent.getAction(), "...")? [fyi, commit amend + force push are fine]
Why did you only do this for HealthReportBroadcastService? AnnouncementsBroadcastService uses a similar paradigm.
Debugging code?
The system properties that we access from Java (as opposed to Maven-only) usually start with infinispan.test
just return ListeningExecutorService
I think we should change this example to call 2 minutes with TimeUnit.SECONDS instead
nit: typo UNKNOWN_VM_VENDOR ?
same here for node
as above for cache
super nit: make string task a public final variable.
nit: as above for external, and entity here and below
unnecessary parenthesis?
return id;
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
JDT uses compact assignement, e.g. i= 3;
Missing StringUtils.isNotNullOrEmpty() check
It's better to use #isLegal because that sends an IllegalArgumentException. Also, it is more elegant to first check the argument and then execute the code. That gets rid of the 'if'.
Should be added the Override annotation.
When do you ever use the above service? And if you do, is it more than once?
Can we remove these empty new lines?
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
Maybe take the opportunity to set index = null here?
If storageManager gets a value in constructor, then we don't need to check null.
cannot be null.
Does it make sense to cache the result?
See below; there is no reason for this that I can see.
Same as above: I think it is clear enough without the id variable same for below too
The names should be consistent. As suggested, cancelAddInstructorLink is preferred over addIntrCancelLink.
I think can just use the @FindBy defined at the top instead of findElement() againt
i think you can replace browser.driver.findElement(By.id(id)) with inputBox?
i think you can replace browser.driver.findElement(By.id(id)) with inputBox?
I think it will be better to close the other store as well.
Could you please add a null check and isClosed() check (if available)?
Build failed: Need to throw IOException or catch it  public void close(){ try { if (input != null) input.close() } catch (IOException e) { // ignored } }
This shouldn't be closing the underlying store since it may be shared with other 'NamespaceAwareCoordinatorStreamStore' instances.
close should invalidate the iterator, but you are reliant on the internal iterator for this. You should have a flag isOpen (or isClosed) that is checked for the various methods. Take a look at htsjdk/samtools/util/CloseableIterator.java You should also (evidently) call close() if hasNext is about to return false.
Check command and status null.
Check if address is null.
Not sure if we want to print out the exception.
os.write(command.getBytes()); ?
If we already generate the checksum field in the constructor, the reset over it would be enough to regenerate.
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
suggestion return new BridgePath(virtualFile.parent(), fileSystem);
we could prevent this if the color is "white"
You don't need to cast to an EntityLocal to call getAttribute() on parent.
!(parent instanceof MGenericStack) || parent.getSelectedElement() == part
Does TYPICAL_LOG_MESSAGE need to be a local variable? You can hard-code /typicalLogMessage.json here if only used once.
check if getters1 is null and remove firstTimeStream
Style issue: @Override shuld be on line above the method declaration
null? why not just a () -> {} ?
Why is it a list of lists, not just a list?
null != settings
A check for settings.getConstructorArgs() != null is not required if we check that null can't be passed to MockSetting.useConstructor(Object ...args) as described above.
return settings == null || settings.isChatColours()?
I think the existing code is correct for the "jump" plot behavior - this should advance the plot as time marches on. Although this change would result in desired behavior for the non-changing historical data, it would result in incorrect behavior for live/streaming data. The issue comes from the fact that settings.getMaxTime() is returning system time in the first place. This makes sense as a reasonable default only in the absence of a time service, but should be overridden if a time service is available. Some care should be taken to ensure that only defaults are overridden in this manner (e.g. to avoid overriding when getMaxTime() is returning a persisted user-specified value.)
you should catch EbodacLookupException too
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
Please check that the data buffer has at least 2 bytes to avoid a NPE.
why is this necessary?
Why you convert short to int and then to Integer here and below?
these should be closed?  try (ByteArrayInputStream bytein = new ByteArrayInputStream(body); GZIPInputStream gzin = new GZIPInputStream(bytein); ByteArrayOutputStream byteout = new ByteArrayOutputStream();) { ... }
emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet()
this.
Does this mean that we get an additional object per invocation? If so, then I'm not in favor of merging this pr.
I think this can be:  m.put(key, ImOption.apply(m.get(key)).map(lst-> lst.append(elem)).getOrElse(() -> create(elem));  Though maybe not any better.
Are you intending to be able to call DataRegistration.of(Keys.FOO)? because the varargs can have a length of 0 by omitting the argument altogether in this case (this is why Cause historically always had an Object, Object... method signature, to ensure there's at least one argument passed in.
suggestion return new Intent(context, CustomTabsManagerActivity.class);
Move the intent instantiation code inside the else branch, as it is not needed otherwise
I think we should set isBound = false here. onServiceDisconnected is not called when the client is unbound normally. According to the docs, onServiceDisconnected is only called when the process hosting the service is killed/crashed.
Travis is failing due to this empty line. Removing it will fix the checkstyle.xml exception.
can we be sure that context is a ScriptActivity?
Should be here ac.stateChangingCheck(); @zlamalp?
List<User> -> List<Facility>
Please change the return type of the method to Long: suggestion public Long call(ApiCaller ac, Deserializer parms) throws PerunException {
Again please fix all occurrences of this exception message.
Where are exceptions? We are describing all exceptions except InternalErrorException, PrivilageException and RpcException. You can check in AttributesManagerMethod (It is missing here in this manager)
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
how do we utilize timeout?
why this is in vmCommand? should be in stopBase command
isErrorIfHostDoesntExist => isNewHost
Changing this to true would still be useful to solve the unreported bug that I described.
@Before / @After could overwrite System.out :-P
When the view is closed you need to stop the build thread
Will need a @since tag.
you should have here setSucceeded(true) IIRC.
audit log ? setSucceeded(true) should be added IIRC
Which type would be assigned in this case?
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
Then should we just use it to save the update items?
Do the traits have to be ordered? Could you use a hashset instead?
Rename to "dependency"
You could just use Closeables2.closeQuietly(azureBlob);
Remove by dn/key.
Let's keep it as it is for the being.
If you'd like to get telemetry how frequently this error occurs use ClientAnalytics to log this event and information that might help you to investigate what happened
Throw it; we want to fail fast rather than wait for auth failures talking to the far end.
The original version is more precise?
[If a player is targetable becuase VANISH_PREVENTS_TARGETING is false](<LINK_0>, should spawning also be unaffected?
are you still creating new contexts here?
Once you switch back to the Apache commons collection 4.0, it would be unmodifiableMap
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
reference equality?
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
I guess you forgot "other." prefix
missing { and }
nit: Take a look at QueryConfiguration for this part, for consistency
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
I am not following here - why do we want this in sync block?
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
Are we guaranteed that we will always have a ZK connection when EmbeddedServletContainerInitializedEvent is raised?
The %2$s is positional and needs to be adjusted since payload type moved from position 2 to position 4. Or, alternatively keep this the same, but move getQuoteString to the end and use %3$send%3$s above rather than %send%s.
I think the <zookeeper> argument comes after the other arguments. Also, it'd be good to add one more example with your -d flag.
alias is count but the function is sum
This nice plan nesting looks like you mean a specific query plan (joining tree) shape. Is it guaranteed? See com.facebook.presto.SystemSessionProperties#REORDER_JOINS
Can you use an anonymous name for the maintainer? Not something from production
should atleast check o being non-null and instanceof IdentityExtractionFn .
Instead of reference equality, we should change the implementation to use the query field in equals and hashCode computations.
Cannot we simply use equals twice instead of relying on reflectionEquals? ;) Or if underlying Table does not have proper equals implemented it there instead of hacking it here?
It looks like equals:ImmutableDruidDataSource is not the Java convention. At least I'm not familiar with it. Would you tell me where this convention came from?
This is a bug IIUC. This must be an &&, or any GitHubPushCause instance will be seen as equal?
Can we please add limit to the exception message? So it will be much easier to see the problem!
Use checkArgument instead to throw an IllegalArgumentException?
We don't need to cast to int.
I don't think you need this new flag. You should immediately return null from fetchNextReady() if the child has already been closed, which you can test with child.isOpen() or child.eos(). @jingjingwang do you agree?
You may want to say something like "Items per page limit cannot be..."
This was purposely catching both checked and runtime exceptions, hence catch of Exception, because if this were to have a fundamental flaw causing a runtime exception it could conceivably kill all sling resource fetches.
Maybe we can improve the message further by checking if null == operation and show a different message in case it is. Something generic (like Unable to complete operation on "event-type-name" + reason. What do you think?
@NielsCharlier this is a strange idiom. Does your intent differ from !resource.path().isEmpty()? Can resource.path() return null?
@AlexOreshkevich : I don't think I quite agree with the try/catch here... Could you please remove it, unless there is a good reason I'm missing?
using this approach only root collections will have validatorLocator, all sub-collections/resources will get NPE, when you'll try to use it, you need to inject it in runtime to every resource.
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
can we use messageFormat instead of string-concatination? String result = MessageFormat.format( "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.", planet, new Date(), event);
As discussed; are there character or length limits on the string returned? Also, although nothing wrong here, these are fairly structured strings. The first is a fully qualified class name and the second and third are uuids. Such there is opportunity for a simpler format; e.g. "%s|%s|%s"
unnecessary parenthesis?
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
nit: maybe merge the lines as the formatting looks a bit strange.
This is a bit weak when it comes to IPv6 addresses, as it assumes "hostname" is properly enclosed in [ ].
I guess we can use the following instead of both lines? suggestion ensureNotEmpty("hostName", hostname);
Nit: this consistency.
hostname = DOMAIN_NAME_FIRST_CHAR_MATCHER.negate().trimLeadingFrom(hostname); return DOMAIN_NAME_MATCHER.negate().trimAndCollapseFrom(hostname, '-');  This would be better, it only removes disallowed characters from the start, and replaces anything else disallowed in the body of the string with -. There's length restrictions too, 63 characters per segment and 255 characters overall maximum.
@inverno Why public?
Only null check here, so empty string will go through. Shouldn't we check for blank strings ?
Given there is no caching going on and lazyEntriesView is not exposed externally anyways would it make more sense to remove lazyEntriesView all together and just do lazyEntries.keySet() (with the remainder of the line being as it currently is).
no need to instantiate this hashset (not being used?)
Nitpicking: would have been more compact with a constructor KeysSupplier(Collection<Object>, boolean).
can we use sysprop or something for url?
version is protected. I don't think we need to access it via its accessor
options -> version
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
@qqmyers this is used by the ActionLogRecord; there is a generic implementation in AbstractCommand.
use Long.valueOf() instead of new Long() - always for performance reasons
456L
use 'L'
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
Is start check needed? Could it be problematic (somehow delay/miss the start when it should be immediate)?
Would it not be enough to only catch MergeException here?
Can this be private, or is there another use case for default attribute outside the builder's call?
Break this line a bit earlier?
Needs to be a constant
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
This should be package scoped, not public.
Did you test the response == null branch? I believe login returns either error or a valid access token, never a null response.
It's better to check/assert that callback is not null in execute instead of sweeping the problem under rug and simply do nothing.
add curly brackets
Why we return AsyncClient here?
Don't we have to say that this is uniqueId JDBC?
- log warning that option is not supported by SNMP
usually data objects never return null where collections is met
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
Not sure about coding style, but I wouldn't use an else here ("else after return").
Don't put any logic in the descriptor, it should be pure data. Do everything in the caller.
By convention, files in Jenkins home indicate what they were based on class names. Maybe jenkins.install.InstallUtil.lastExecVersion?
Are you sure this is right? Please double check.
dare to extract a constant which increases visibility for this hard-coded value?
Nit: it is a good practice not to reassign the input parameters so I would change this to something like the following: Map<String, String> mapToUse = (map == null) ? emptyMap() : map; JSONObject pathPartMap = new JSONObject(mapToUse);
you can use  return CollectionUtils.map("inode",contentlet.getInode(),"languageId",contentlet.getLanguageId()+"");
My feelings for using exceptions as flow control aside, this log statement is forgot to include the exception e.
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
How about AM's memory mentioned at Line 111?
shardSpecFactory -> partialShardSpec. Lombok would be nice and hide all of this away :)
should this have a ,  to match the rest of the pattern?
This is missing maxTotalRows
Why do we print a secret systemUserPassword here?
the idea of using a builder is a bit off here :-)
I am not sure the changes here improve the situation. It would probably be best to change this into a String.format(...) call... or at least to format the code to remove the many line breaks.
one param per line; leave the first line empty
Ah, if (null) is not compiling, thanks for this fix!
Should delete this empty line?
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void ...) This avoids extra sync objects (and saves one level of indentation!)
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
These should change to store the names in the attributes map so that you don't need special handling for all the places that handle the tags.
Try to use constant non null values in front for comparison methods, as their is less chance for a NPE. "COOKIE".equalsIgnoreCase(name)
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
@weisebrazil all indentations should be 4 spaces, not 8.
It's an obvious code duplication. We can save this new request with a modified URI into this.request, and use it in all methods. This is how it works in other classes, take a look
it's more natural to use String.format() here
refs is also a one-time variable
better do .path("/gitignore/templates").path(name)
If environment accepts null, mark it as <code>@CheckForNull</code>
Maintenance of the map will be simpler than that of the list
Is this first else-if dead code? It seems to have the same condition as the initial if() statement.
Maybe wrap in an immutable map.
is this something like /system/tasks ?
Create date once and use it twice. That way the acceptance time will be the same for both.
Matchers.is
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
have you thought about using the builder pattern to follow the code line in the other projects?
From reading this line I'd expect this test to pass. We should probably name this CONFIG_WITH_KEYSPACE_2, or make CONFIG_WITH_KEYSPACE receive KEYSPACE and compare it to KEYSPACE_2.
Nit: Make "content" a constant?
I wish there is a good place to have these convertor util methods so that it's more discoverable. Not sure, may be as static in GsonJsonSerializer type, just a thought.
Whoa, this looks wrong. The query doesn't have a native query and it returns an empty result set. I think that probably, this query should return an error, because it represents a kind of query structure Druid can't do right now (aggregation on top of a non-aggregating subquery).
no need to catch exceptions. just let them propagate.
no braces around single line block
oops, I missed to merge with Stefans fix for annotated tags (calling getPeeledObjectID()). I'll add that again.
It shouldn't be public
It's better to mention name of the method here like "commit()".
Move this into the block above: if (blob == null) { updatePath(commit); blob = getBlob(commit); if (blob == null) { markSessionBound(); return false; } }
Let's do return fDetailedLoad; even if it is always null for now
not related to this PR but wondering if returning null or an Optional.empty() in case of corrupted data shouldn't be better.
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
I'm a bit sceptic about this type of changes. @gunnarmorling what's your take on this? I'm not worried about these occurrences but more about how it will be frustrating when we write new tests.
Shouldn't we use empty list here ?
using compareAndSet() might be better since you need not execute the rest of the statements if this is already false, right?
I would guess that the work queue itself listens to the stop event and cancels the tasks. But this would have to be verified.
what happens if the future is already completed?
the null check isn't needed when having the taskScheduler final an being set in the constructor.
By default, it's enable, I didn't see you set it false. So, you can remove it.
To clean up properly, please place the Builder in a try-with-resource block java try (Builder b = new Builder()) { // test }
It doesn't really matter, but could be: java return new byte[] { (byte) (val >>> 24), (byte) (val >>> 16), (byte) (val >>> 8), (byte) val };
Check if byte[] b is null.
This could break existing users... perhaps deprecate, and add nextByteBuffer()?
style nit: missing braces, more of these below
what about location ? we do not need LocationSerializer ?
this is redundant
Will this have any effect to legacy data (i.e. those existing before this PR)?
why you remove this 'full' option ?
Yes, please add these asserts back.
Used to be fileSystem.deleteFileOrThrow underneath.
there is no case in which httpClient become null, right ?
the second parameter can be removed
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
one param per line and leave the first line empty
Shouldn't we call removePropertyChangeListener, BEFORE we call doEdit, since doEdit will change the current object?
isn't it true by default?
Please have result variable.
If we can't get a model-set, will anything work? Perhaps this should throw an appropriate exception in that case.
This is not required, already take care presenter
I think we should at least log this exception here before throwing other one
log.trace if at all
log.tracef
Might be cleaner in terms of minimum visibility to just return the timestamp from the transaction task.
In general throughout this class, is isNotNull() really needed? I imagine the isEqualTo check should be good enough. Transaction#getTimestamp returns a primitive long, so non-null.
I believe this method should be getServerMetricConf()
I would prefer not to use null ... just a empty set and then assert that its not null
Please extract some values to make this more readable.
Please think of other test names.
Why an event ID is built around project UUID?
This is a local variable, should be camelCase not fCamelCase
There's no packet data, this contains partial NRB data amputated by what was read in 28 bytes of packet header (incorrectly).
I think 28 bytes have been read into the packet header (incorrectly...), so it will read too far into the next block?
That is Original Packet Length. According to spec, the included packet length is minimum between this and SnapLen (for Interface ID = 0).
Where are you trying to position the file channel? I think it is already at the end of the packet data?
Sort of believe We should have MetricManager in parameter given this case.
can we avoid this null check and instantiate it on fields directly (+private constructor if we don't want to create it in any other way) - it's potential race condition if we need that for tests we could have it package scoped reset method
sync
nit: do you need double checking here? if (INSTANCE == null) { synchronized(this) { if(INSTANCE == null) { ... } } }
Please use atomics instead:  java private static final AtomicReference<Schedulers> INSTANCE = new AtomicReference<Schedulers>(); private static Schedulers getInstance() { for (;;) { Schedulers current = INSTANCE.get(); if (current != null) { return current; } current = new Schedulers(); if (INSTANCE.compareAndSet(null, current)) { return current; } else { current.shutdown(); } } }
log message is about "attach" in the "detach" method. this is misleading.
Did we want to have this normalize the path also by returning the normalized version from Path?
It seems duplicate code. We can also put the exception throwing into checkIfPathBelongsToZkRealm or validateZkRealmPath() so we don't have to have the duplicate exception throwing in each method. Update: Maybe I would just wrap this into a method getZkClient(path) and put this check logic in it. So just getZkClient(path).operation()
See my previous remark regarding _GenericUtils.length(...) > 0_
I prefer:  java if (GenericUtils.length(owner) > 0) { throw ... }  The assumption is that there is not such thing as "empty" owner - and if there is, then we assume no violation since we cannot determine the user.
This is duplicated
make it final
To be super clear, wdyt about renaming mTryAgainButton to better match its new functionality?
We don't really need this log string anymore.
You don't need the variable here. You could directly return inflater.inflate(fragmentResource, container, false)
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikiPage object/browser info.
Please remove extra line
I never knew you can do typeof(...) although it's a little misleading because typeof is not a function, it's an operand, adding () makes it look like it's a function. How about triple =?
Thoughts: it is better now - but in ideal world I would like to see something like this:  java AdSlot topLeaderboard = page.getSlot(AdsFandomContent.TOP_LEADERBOARD); Assertion.assertNotNull(topLeaderboard); Assertion.assertTrue(topLeaderboard.isVisible()); AdSlot floatingMedrec = page.getSlot(AdsFandomContent.INCONTENT_BOXAD); Assertion.assertNull(floatingMedrec);  _(pseudo-code)_
I see that 3 = pageviews from the method description, but avoid using magic number '3'.
Why include the name in the comparison? fullName should be enough.
Aside: I'm assuming this was generated. What IDE are you using? Most of them should be able to generated Java 7-style equals that use java.util.Objects.equals(Object, Object) to avoid these null checks.
since you are changing this, I would use:  return addressNum == that.addressNum && Objects.equals(name, that.name);
please fix this one
consider to put && at the beginning
Check if byte[] b is null.
style-nit: avoid braces for simple constructs
could use writeInt(Float.floatToIntBits(v)) to avoid code duplication.
Style-nit: We don't use curly braces around simple loops.
this would not be necessary if we made RunLengthBitPackingHybridDecoder depend on InputStream instead
SHOW+DATABASES? looks strange.....
formatting
viewers > 0 implies page is non-null
unused variable
Here too, using at least two different timezones would be nice, be it only to check that the timezone is not retrieved as "Europe/Paris" by chance, because it happens to be the JVM default time zone.
Same as above, this looks like an error.
I don't think the process deploy should fail in the case of temp file deletion fail
You can safely remove the file.exists()(implicitly done by isFile
You've got some auto formatting thing on which basically adds "this." everywhere. You may like it, but it makes for a very noisy diff :-( This diff Should be a 2 lines fix. There's no need for the incremental approach here either, given that it's a trivial change. Making it an incremental PR just delays it's acceptance.
The initialization of length needs to be done only once and not all the time getClonedStream() is called. If we would like to handle file length changes it does not work (IIRC) as the file size could change also after the file input stream has been created. So, I think this line could be moved above after file = new File(outputFile); Or is it because you don't want to handle FileNotFoundException twice? But reset the size all the time... Hm WDYT?
targetValues is a List<String> so we don't need to use toString. Could use String.join(", ", targetValues) instead.
suggestion return Arrays.toString(value);
Please use - StringUtils.join(Entities.objectNames(networks), ", ")
consider to inline uris
I think we should sort the tags in a specific order here. Otherwise we could have tests excluded for the same reason, but the strings will not match if tags are not in the same order.
events can't be null
please use {}
Why are these probably incorrect?
Is there a need to move from getters to fields here?
I don't think it can be null?
Would you mind if we kept our privates on bottom? I'm a class client (reader) of more code than I author, which means the most relevant source is almost always the public API. It's quicker to get to on top since codes read from top to bottom.
A Repository can be opened through the RepositoryCache or in a standalone way. We cannot change the close method to not close otherwise we will affect the standalone use case. The repository will never be closed because evict will not be called in standalone. I see 2 options here: Repository opened through the repository cache could be wrapped in a class holding the usage counters (useCnt and lastUsed) and overwrite the close method to do the logic done in evict method. The problem with that approach is that wrapping repository in not possible when repository is added to the cache using the register method. For this solution to work, we would need to remove the register method (and break backward compatibility). Another option is when repository are opened through the RepositoryCache, we leak one usage counter(as it was originally implemented) so useCnt=1 would mean that repo is not used but still in cache. In the therminator thread we do: Runnable terminator = new Runnable() { @Override public void run() { try { for (Reference<Repository> ref : cacheMap.values()) { Repository repository = ref.get(); if (repository.useCnt.get() == 1 && (System.currentTimeMillis() - repository.lastUsed.get() > 20000)) { RepositoryCache.unregister(repository); repository.close(); } } } catch (Throwable e) { LOG.error(e.getMessage(), e); } } };
we don't need to change the Creation classes.
minor: change SocketNetworkClient to LocalNetworkClient in line 98 and 102
I think that this is not a clear way to reset values to default - I think, that there should be something like: System.setOut(System.out);
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Please use Optional.ofNullable()
Don't we have to say that this is uniqueId JDBC?
should be edit
why add?
Similar to start, stop, etc. I think the name of the action enum can be more generic (VAR__ACTION__ENABLE)
It seems that the HotPlugUnplugVmNic Command is being used for both Plug ("Activate") and UnPlug ("Deactivate") actions. Therefore, I think that the ActionMessageParameters should be set according to the "Action" property within the HotPlugUnplugVmNicParameters class: If getAction() is PlugAction.PLUG, then the CanDoActionMessages array-list should be added the "VAR__ACTION__ACTIVATE" message ("activate"). If getAction() is PlugAction.UNPLUG, then the CanDoActionMessages array-list should be added the "VAR__ACTION__DEACTIVATE" message ("deactivate"). [worth consulting with an engine-core maintainer about this]
perhaps change to import instead of move
why don't you just use a node here that does the right thing? There should a node to read outer, no need to duplicate that logic here, or is it somehow special?
To avoid confusion, rename the variable to sessionId.
entry
could be set via the constructor?
Too much nulls in arguments, please make variable content = null and use it in constructor. Please apply the same for all other test method you changed
RuntimeException would be sufficient
RuntimeException will be sufficient
Should the scanner be closed after the call ?
Can this affect the other versions that don't specify any families, like flush(TableName tableName)? Because region.flush(true), internally, loads all families before delegating to flushcache(List<byte[]> families, boolean writeFlushRequestWalMarker, FlushLifeCycleTracker tracker), but it doesn't seem we are doing this now.
Changing the region should also invalidate the client like above.
This change could break people.
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
public isn't needed
nit: you can merge both lines above as checkNotNull will return the given argument
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
The operator should be && not ||
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
done for patch3.
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
suggestion return new PgClassTable.Entry( OidHash.relationOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name(), info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
..and if it does equal null do we want to put the view into a state that prevents erroneous manipulation (and further errors)?
this log seems useless, remove it
i would add additional check to make sure we will never make it to more then 100 :)
@decarbonization: i think this should be Math.round(0.25f * temperatureScore + 0.25f * humidityScore + 0.50f * soundScore) coz right now Math.round(0.25f * 90) + Math.round(0.25f * 90) + Math.round(0.50f * 90) returns 91
Under what circumstances (given the validation you do) could index.equals(indexInterpolated) be true?
We maybe want to use ColorMode.HS.toString() in this case too - which is default and you do not need to set it.
tab can't be null at that point.
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Should this constructor one just delegate to the new one with Function.identity()?
I would prefer to avoid any dependency from UriComponentsBuilder on UrlPathHelper. The latter is more of a Servlet API specific component while the former is more general. Even if the re-use in this case doesn't touch on anything Servlet specific, it seems very minor and not worth the gain.
Ensure path is non-null
Args.notNull
Why U don't want to consider id in equals and hashCode ?
Please remove the unused method.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
I think I'd rather store the instance as a field than to have to loop through the projections with instanceof attempts? You can easily store the EntityInstance during populateWithEntityInstance.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
You should output the session id in the message to aid debugging. Also, I would use this form log.error("An error occurred while removing session", e);
Do we need this else block?
catch throwable in activate method
@rvansa I think stop() should release all the semaphore permits. Threads trying to read from/write to the store after it was stopped should throw an exception immediately, they should not block forever.
We don't need to cast to int.
checkState
Can remove the first clause if you change maxWriteSize to Integer.MAX_VALUE
You can reassign to offset, we don't forbid assignment to method parameters and in this case it's more readable.
I don't think you need this new flag. You should immediately return null from fetchNextReady() if the child has already been closed, which you can test with child.isOpen() or child.eos(). @jingjingwang do you agree?
DoubleMath.isMathematicalInteger?
I prefer short log messages for events. Would suggest to change it to  return itemName + " changed from " + oldItemState.toString() + " to " + itemState.toString() + " through " + memberName;
final field to it's computed once and for all, as most values should be constants
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
Should be public.
Should be public.
Should be public.
Should be public.
Should be public.
In fact, I don't think it's a good idea to allocate a Long. This function should be fast. Thus, a three branch if seems to be the solution. if (a < b) ... else if (a > b) ... else ... The domain trick works to avoid the "sign" hack.
can use org.apache.commons.lang3.StringUtils.isNotEmpty(value.textValue()) ??
Add parens on (value - 1)
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
Bug is here. You shouldn't have = here. Think about it and understand why this bug only affected negative test case, but not the positive test case.
throw exception
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
As a nit, should have a null guard here.
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
can you call it first, just for consistency..
This can be simplified to model.getCommands().addAll(uiCommands).
This is a status field. It should not be mapped from REST-API to Backend. The way that the user changes this status is by running activate/deactivate action. So please remove this mapping. The mapping in the other direction is ok (REST-API should show the status, so the status should be mapped from Backend --> REST)
potential NPE, please check if element was set before assignment.
System.out.format instead?
Symmetry (throw)?
can these parameters be grouped into smaller and more meaningful objects?
Could you check for null or empty? Via StringUtils.isBlank
I think we can reuse GWTDateConverter java static String format(final Date value) { return GWTDateConverter.getInstance().format(value); }
true=>false
There is no point of having separate variable. Why not to use it directly in method call or even hard code it in pollWhileWaitingForTaskCompletion.
may want to externalise to constants..in a separate patch maybe? call it GEOREP_ROOT_USER or similar
I hate these additional constructors - just add it to the signature, and pass false in the places that call it. IntelliJ should be able to do this pretty easily.
that's unneeded..it will be false by default.
I don't think we ever use this method again
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Move both to variables for consistency.
We could just always use the body instead of flipping based on the payload size.
suggestion
I think the code will be easier to understand like that: java Object object = getInstance(); if (object == null) { clazz = getConstructorOrMethod().getDeclaringClass(); } else { clazz = object.getClass(); } ITestOrConfigurationclassAnnotation = getAnnotationFinder().findAnnotation(clazz, annotationClass);
Use a builder method from TestNG Collections
we don't use braces around single line blocks
Maybe remove the package name as it is already in the import statements.
Can be simplified to: java return Arrays.stream(groups.split(",")) .map(String::trim) .filter(s -> !s.isEmpty()) .collect(Collectors.collectingAndThen(Collectors.toSet(), Collections::unmodifiableSet));
@paulodamaso the braces and return are not needed here
@fanifieiev the same above.
@super132 please use Collections.emptyList()
@fanifieiev the same above.
@fanifieiev You can inline all this
We only set thisReadSequence and mateReadSequence in the ReadHead, right? Why don't we have set(long uuid) for those kmers which aren't ReadHead?
for write and getActiveMessageFields, you can check if the lists are null OR if their length is 0. If either of those cases, don't write/read them.
At a high level this is what I meant.  java // member variable AtomicBoolean shouldRotate = new AtomicBoolean(); ... In the TimerTask shouldRotate.set(true); in save() if(shouldRotate.get() == true) { // do the file rotation ... shouldRotate.set(false); }
next time you can leverage switch case for ENUM
I'd prefer to require these be empty sets.
public?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
add this selector to UI mapping at the beginning
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
could metric == null?
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
why do we default to one minute everywhere? just get higher multiplier for travis, but don't make me wait one minute for test to fail (x 100) while i'm developing
Let's keep things reactive and functional and return either Observable<Void> or (preferably) Completable instead of void.
Null comparisons can be replaced by UtilMethods.isSet(object)
All actions from
cannot **be** empty
It is the same in this line, leave a blanck space before "+"
Shouldn't we throw here?
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
"else if" maybe?
this requires a declared logger in ActiveMQRALogger and logger code
This could be made static
Same as above. this is deprecated and should no longer be used.
This is deprecated, we should use MoreObjects.ToStringHelper(this) instead.
Should just be dimensionId, ToStringHelper automatically formats and uppercase keys look odd.
Change toString method to include both
tableScanSchedulingOrder
reuse getAcceptableTokens()
I am a bit confused that this check will be called on almost every line of code.
@romani Should it be possible to specify different naming conventions between parameters and lambdas? If so, this shouldn't be a required field, but be acceptable and default.
(not related to this issue) Should AutomaticBean issue a warning when a deprecated property is specified in the configuration?
This is super wrong. zzUnpackAction populates result.
Replacing "\" does not require regular expression, use replace("\\", "\\\\\\\\") or replace("\\", "\\x5C") instead of replaceAll().
Why is this needed?
input and expected output should be copied to test's input folder.
Why does the newline have three backslashes in front of it, but the other control characters only two?
Does this class exist by magic or ?
Use getSimpleName instead?
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
For increasing stability "wait" is better to use than "Assert":  waitUrlStartsWith(testRepo.getHtmlUrl()); } private void waitUrlStartsWith(String expectedUrlPart){ seleniumWebDriverHelper.waitSuccessCondition(driver -> seleniumWebDriver.getCurrentUrl().startsWith(expectedUrlPart)); }
<LINK_0>
projectExplorer.waitAndSelectItem(PROJECT_NAME); projectExplorer.openItemByPath(PROJECT_NAME); projectExplorer.openItemByPath(PATH_TO_GO_FILE);  Can be changed to "ProjectExplorer#expandPathInProjectExplorerAndOpenFile(String path, String fileName)"
We could shorten a code if we will have the method: projectExplorer.waitVisibilityByName(String... names) projectExplorer.openItemByVisibleNameInExplorer(String... names)
need to remove downloaded package here
could this hide bugs? Would it make sense to throw an exception or simply remove the check? Also because 0x0 is a valid code point this makes this return value a bit ambiguous. I'd be in favor of just accessing the array and let the JVM throw an error if this is possible.
this creates a hard dependency on the outer class and will make future refactoring a bit harder if you want to extract this class to its own file. Perhaps tokenSep should be passed or made a member of this class?
seeing this, I am a little worried that these checks are not always at the same abstraction level in the code. Why is it checked here at the level of the callee, instead of the caller as for instance in the Actor class? Not sure which version is better, also because I don't know how many callers these methods have. But, would be good if it is done somehow uniformly, if possible/sensible.
@xupyprmv it's better to use %d when printing numbers
Use [StandardCharsets.UTF_8](<LINK_0>
Hum seems we are already setting this listener
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
I'm missing the new field in the toString method.
nit: you can merge both lines above as checkNotNull will return the given argument
As for me, brokerConfig variable name would be simpler here
I generally don't have an issue wit bitshifts when they are actually useful but here it only obfuscates the code for people who don't know much about them
Sorry, I was thinking of this:  java private void handleBadgeResetPN(Bundle data) { if (data == null || !data.containsKey(PUSH_ARG_NOTE_ID)) { // ignore the reset-badge PN if it's a global one return; } removeNotificationWithNoteIdFromSystemBar(this, data); //now that we cleared the specific notif, we can check and make any visual updates if (sActiveNotificationsMap.size() > 0) { rebuildAndUpdateNotificationsOnSystemBar(data); } EventBus.getDefault().post(new NotificationEvents.NotificationsChanged()); }
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
What do you guys think about setting this method to Evolving, at least for one release.
Can we weaken the signature to throws Exception?
...this change really doesn't make sense. > Changed off screen limit for unlocks to 1(on unlock it was 2 and once activity open it would report usage of all 3 fragments, so to add little more accuracy I moved to 1 off screen as on SoldierStats) Are you really considering to give the user a WORSE experience, just so that we can get a bit more accurate analytics? I for one would rather get analytics with a known misrepresentation (all three fragments) than a random misreprentation. Example in your current implementation: 1. User opens unlocks 1.1. Fragment A and B are downloaded (A=1,B=1) 2. User scrolls to fragment B 2.1. Fragment C is downloaded (A=1, B=1, C=1) 3. User scrolls to fragment C 3.1. Fragment A is cleared (A=1, B=1, C=1) 4. User scrolls to fragment B 4.1. Fragment A is downloaded (A=2, B=1, C=1) 5. User scrolls to fragment C because he forgot something 5.1. Fragment A is unloaded (A=2, B=1, C=1) 6. User scrolls to fragment B again 6.1. Fragment A is downloaded again, third time now (A=3, B=1, C=1) So, basically, what that would generate would be... three hits for A, one for B and one for C. How is that more accurate? If we load all fragments at the same time, we get one for each, which is a more viable representation. I'm just trying to make sure that we don't do stuff that makes the app worse for the users (and the experience). For example, I would rather look into if we can use the ViewPager "hooks" and send a "trigger" once we switch to a given fragment. That way, if we go from A -> B -> C -> B -> C, we'll instead notice that the user used fragment B and C twice, and A once. This seems both possible and more useful to me, instead of causing people to re-download information just because we're doing it wrong. :+1: @peter-budo
This method is only ever relevant for when writing snapshots and not used on restore. Therefore, this should always be the latest version, and not the read older version. suggestion return VERSION;
Can we use enums or constants instead of hardcoded numbers here? Also, making RAMP_STAGE_MAX protected should be good enough and avoids having this function.
remove 'driver' parameter (yes, a know you didn't write this line, but please change it :) )
I know its not your line, but please remove "driver" parameter. This parameter is not needed here, because screenshot is not needed in verification methods.
why is there "waitForCongratulationsLightBox " in PageObjectLogging.log, if you don't wait for lightbox? Maybe it should be waitForElementByElement method or in PageObjectLogging.log method should be "closeNewWikiCongratulationsLightBox" and "Congratulations lightbox closed".
Could consider removing the word verify from the logging description.
Could consider removing the word verify from the logging description.
IMO it's better to use different values, e.g. 0 and 1 to be sure, for example, that the "delegated" method is not simply using the first parameter twice...
If your initial value is Double.MAX_VALUE, then this reset must be the same
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.
After having a look at the entire class, all tests require this to be present. Throw a SkipException here to automatically skip all tests in this class, showing the reason?
use execute i mentioned above
replace (String) js.executeScript(script) with js.executeScript(script).toString()
use js.execute(script).toString()
please add line above to separate 'block'
Why asserting this?
Looks like both XmlTest and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
Two "parallel"?
let's call it updateCodeMinings() instead.
Pls, use InvokedMethodNameListener
I believe we can remove the try/catch wrappers. No checked Exceptions are thrown. Is there a particular Exception you are anticipating?
Or even better, this.mName = Objects.requireNonNull(name);. To be check everywhere else.
Will this inject all instances of Task on the classpath?
Clarify doc. Returns a proxy not a real result set, and throws NPE if not initialized.
This seems a bit profligate... and the stream construction around a spliterator seems a bit unusual.
We always put "XXX is null" as the error message for requireNonNull
Why do we print a secret systemUserPassword here?
Oh yuck. ;)
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
StringUtils.isBlank(nodeId)
Style-nit: We avoid curly braces on single statements.
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
you could just do setConfirmWindow(null); like above method
Item dropped should be a hopper
Change this to == and I'll merge it.
The default should be updated to return 8 parameters to the test
final
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
should be setSucceeded(true)
return flagdown; ?
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
Why do we use iterators? I know the base class does, but why in the first place?
Get it from the model now that we have one?
I don't think this can return null. We should probably add an external annotation.
You could use a Multimap instead
I recommend using Collections.emptyMap() instead
Why the change? This is going to cause a memory leak if the SaveSmartLock fragment is rotated since it's a setRetainInstance(true).
I dont see any reason for adding this to string.xml. It is not really a string resource, it is more of an id. We wouldn't want this to change if we decide to translate the App strings later. A better way would be to move it to the Constants class.
Same here, better in the constant class.
I think that there is no need for a full package path as we already have import on the top of the file?
This should be done generically in BaseSingleFragmentActivity I guess, instead of needing to have the Fragments query the Activity's launching Intent extras. This would make the Fragments much more modular, as can be seen here.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
The agg function here should be adjusted to support the optional compression param like in the quantile version
This looks like it would have different behavior from what was there before. If this is based on the path, I'd expect needing to go through getFormFilePath (the method that builds database paths based on whether or not scoped storage is used).
Is this already protected by a lock?
How about to check whether workersToCheck is empty or not before notifying?
Does it make sense to set globalMinimumClock as 0 when workerClockMap is empty?
We are using snake case, so workerId should be worker_id.
What does rcvMsg stand for?
I would suggest that it checks the count of the entries to see if it increases one after the recovery happens.
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
Is this the recommended way in Karaf - do they not have an equivalent of JCA I wonder? I guess for the dummyxaresource it has to be this way but can we try a H2 datasource somehow?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Underscore looks a bit odd
If createParams should always have commonParams and commonServerParams, why not just define it that way to start with? And I think you could make the collection a static final variable at the class level.
why uniqueKey, be consistent call it keyField
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
Maybe use a logger ?
Not sure, why not use @NotNull?
@cvrebert maybe MkIssueEvents.class.cast(?
this doesn't looks good at all :( let's log the exception using Logger.warn().
Please, add the opposite case  other.compareTo(commit)
@Iprogrammerr Please use IsEquals from hamcrest in these two assertions
@Iprogrammerr Same as above, use new IsEqual to these two assertions
Remove useless assert
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
This test is exactly the same as testPublishWithNullUsername. I think you meant to pass in a non-null username into resource.publish()
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
This line is redundant.
don't use finalize, it's a bad practice
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
can you enclose this in { } ;
"witing list" vs "waiting list"
This check will be needed in case of every single widget button. If so it would be better to create our own WidgetButton class that will extend com.google.android.material.button.MaterialButton (then you can use it in your layout file). In such a class we can then override:  @Override public boolean performClick() { if (MultiClickGuard.allowClick(getClass().getName())) { return super.performClick(); } else { return false; } }  what do you think about this approach?
I'm not convinced that showing the context (Workbench, etc.) is particularly meaningful to most end-users and adds a lot of visual "stuff" that in most cases you'll train your brain to ignore? Plus when using a screen reader it causes that context to be read at the start of every command as you scroll through the list, significantly slowing down the time and cognitive load. At the very least, maybe an option to turn it off both visually and audibly? Or maybe it has more value than I realize.
Ah - guessing that we are using static Bugsnag everywhere to make this whole interface possible. Any workarounds you can think of that would avoid depending on the static class?
what's the intent of this change?
it means that subscription will be switch to the dead state and then will be returned back here to finish clean up state. it brings behaviour when subscription is switched not from cleanup to dead state, but from inside cleanup state we go to the dead state + all the things in taskQueue for execution will be executed anyway. does it make sense to clean the taskQueue, and add fresh task, if you need immediate switch?
use the constant defined earlier (moreover, aren't jdo connection options available from some sort of options class)
Could have @VisibleForTesting annotation. Also could public be removed?
Add this to WireMessages localization resource
one more method where it can take file location of properties would be good.
How do locations look like in Azure? These looks more like Regions? I mean, zones in providers are usually in the form: northeurope-1, northeurope2, etc.
Do we want to include data= (since it's required) similar to how we include connection= for SQL? It would also be nice if the cursor was placed at the end of data= (as we do for connection=)
I assume there is no suitable interface/class that could be used here instead of Object?
why does this test need to change ?
why does this test need to change ?
@dmzaytsev try to use org.apache.commons.lang3.StringUtils#join() here. It could be more visual
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
Isn't that should be setWriteRate
Error message needs updated.
Creation date and last modified date should not need to be set here since the database sets them. You may need to mark them as insertable = false, updatable = false in the entity.
@rishabh-997 there is one in the application constants that convers this
Can we rename from exonCollection to something more appropriate, like targetCollection?
Could this be delegated to one of the classes that deals with HDF5 specifically?(like **HDF5AllelicPoNUtils**) Seems like some other classes might want to use it too
Should we return true when file does not exists ?
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
(optional) likewise
@ILikeToNguyen Why the change in visibility here?
I think it is not only the platform name. W3C defines a bunch of keys, which must be supplied without prefixes and Selenium has this list somewhere in constants
Should this variable name be updated as well?
I don't see clusterId being used in sync-job. Is this required?
Shouldn't it be key:value for cases where value != ""?
can you explain why this change ?
Does transform need a null check here?
should we have an "unsupported" status instead of successful? successful seems misleading to me.
It might be best to add more context to this logging statement by stating that it failed to create the buffered circle from a point.
should we move line 339 to 333 (after the IF's closing bracket right before the catch)? Otherwise the intersects=true at line 336 will be overridden by the intersects operation at line 339 (which may also involve different geometry's CRS right?)
can't we just store filename = String.format("%s.%s", filenameBase, "values"); and not have makeFilename called in multiple places?
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
It's good practice to use getters (like getPerunBl()) than directly accessing attributes.
Please catch GroupResourceMismatchException from conversion method here and wrap it to ConsistencyErrorException. Because on input, there is no group and we retrieve groups assigned to resource - hence from the same VO and there shouldn't happen any Group-Resource mismatch.
Why is it a list of lists, not just a list?
When adding members to group, VO is null and call createMemberCandidates() ends with null pointer in members manager impl layer. You should re-get VO from a Group and pass it to createMemberCandidates() since its behavior doesn't differ on VO and is expected non-null.
I guess checking, that group and resource are from the same VO, would be more interesting. Since when it's true, there is no chance, that member wouldn't be from the same VO as resource. Hence you should catch MemberResourceMismatchException thrown by conversion method and wrap it as ConsistencyErrorException. Then you can add explicit check on group and resource and throw necessary exception to API layer.
- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
Calling cancel method like this will not actually cancel the task. You have to do this through task driver.
I'd make these numbers constants
should be tied in to the FileSystem instance lifecycle too: an FS instance should really have a weak ref to all leases created under it, and fs.close to stop them all
Definitely use parameterized logging here instead of string concatenation, because otherwise this method will be generating garbage objects on every call!
I am a bit confused that this check will be called on almost every line of code.
reuse getAcceptableTokens()
@romani Should it be possible to specify different naming conventions between parameters and lambdas? If so, this shouldn't be a required field, but be acceptable and default.
(not related to this issue) Should AutomaticBean issue a warning when a deprecated property is specified in the configuration?
This is super wrong. zzUnpackAction populates result.
shouldn't we return a new or immutable copy of our internal list? just returning the list allows plugins to fully modify the list. @WonderCsabo wdyt?
I think the lambda expression could be passed directly to Comparator.comparingInt
That's good to know.
Although the returned Map is unmodifiable, the values are modifiable lists. Please change to:  public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotation) { return Collections.unmodifiableList(fMethodsForAnnotations.get(annotation)); }  (though I would prefer that the values for fMethodsForAnnotations to be unmodifiable lists)
...and change this to getAnnotatedFields(Class<? extends Annotation> annotation)
Is there a need to have log.debug within transaction scope?
it appears that this change can be reverted.
also should be warning
Why do we need double logging here? One when logException is called and later in 101-102.
Since we never try to recover from the error later on it would be best to let exceptions be thrown from the init(). That way the ActionHandler is not available for use by the frontend and we don't need to check if the services are initialized correctly for every request on preProcess().
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
return Collections.emptyList();
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
please decrease severity to "debug"
just wondering, w/ slf4j do we still need the custom format() ? I hope/think that's done by the slf4j logging library
lets use loggers
for logger.info, partitionName is same as message.getPartitionName
Use guard conditions to deal with the low hanging fruit first. It reduces the complexity of the execution paths.  java if (!confirmNewBoardCreation()) { logger.info("New board creation cancelled"); return; } panels.closeAllPanels(); onBoardSaveAs();
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
Init should only be called one single time when constructing the controller. That is done in OnStart. Please add a space between if and (
no need for an ArrayList
No need to put before/after annotation since the class is extended from TestCase, We can simply remove the inheritance from here and use the annotation, I favor annotations over inheritance in test. Don't remember why I've extended it at the first place
Result.SUCCESS
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Can this be private, or is there another use case for default attribute outside the builder's call?
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
suggestion mapper.orElseGet(ObjectMapper::new).convertValue(this, new TypeReference<Map<String, String>>(){});
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
Encapsulation
suggestion recommendedLayout.keySet().retainAll(newServices.keySet());
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
use return ... ? ... : ...?
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
use constant for UTF-8
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Let's create a new ArrayList and copy the attachments. If the "client" needs to alter what is in the attachments, that would be logic they would need to implement. A clone should be a full copy.
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
also, at this point in the code, the plugin is not loaded, only PluginInfo is read from the jar metadata (correct me if I'm wrong). The loading actually occurs on line 74. The log could be misleading.
suggestion return new PgClassTable.Entry( OidHash.relationOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name(), info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
I would add a check here: if the ID contains the suffix, throw an IllegalStateException or InvalidParameterException, otherwise, there's a chance that you'll have an ID like abc-client-client, which is never appropriate.
You could probably use the same URL as in getResultById here.
This is not needed anymore... now you can just return id
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
not all listener
not all listener
not all listener
not all listener
rename
@erikdw MESOS_SANDBOX is set by Mesos correct? Wondering if we should override System.getenv("MESOS_SANDBOX") with logdir only if storm.log.dir is configured?
unecessary test : less is more.
Returning the process seems really weird to me. I would make the method void unless there's a good reason otherwise.
do we need setupStreams()? Also, return;
No need for this.
Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.
new AssertionError -> new UnsupportedOperationException
As this operation is optional, just say it won't be supported because it's not mandatory.
Instead of "Not implemented yet", I would suggest "Iterator is read-only"
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
Lol! You're going to remove that, right :)
do not assing parameter! nowhere!
Optional<String> ?
Summary: 1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(<variable> == null) {. 3. Add a space between if and (. Should be if (<variable> == null). 4. Add . (full stop) at the end of "... is null" -> ... is null. 5. Do the same for the other methods.
Summary: 1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(<variable> == null) {. 3. Add a space between if and (. Should be if (<variable> == null). 4. Add . (full stop) at the end of "... is null" -> ... is null. 5. Do the same for the other methods.
This can be java return valueOf(value.toUpperCase(ENGLISH));
nit: Unsupported byte value ' + value + ' for row kind.
You could save a few lines by moving the return null into the default case instead of break.
This case is the same as default...
Why are we casting thiis to a timestamp?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
You could probably use the same URL as in getResultById here.
Maybe for cases like this where the list is only consumed once it would make sense to add a mapLazy that is based on something like this: java static class LazyMapList<I, O> extends AbstractList<O> { private final List<I> list; private final Function<? super I, ? extends O> mapper; public LazyMapList(List<I> list, Function<? super I, ? extends O> mapper) { this.list = list; this.mapper = mapper; } @Override public O get(int index) { return mapper.apply(list.get(index)); } @Override public int size() { return list.size(); } }
As I said in #1208 : In driver 4.0 we don't have any specific exception for codecs except CodecNotFoundException. When a codec cannot serialize or deserialize something, we use IllegalArgumentException. I don't think you need to introduce a special exception in these examples.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
I would only create a different exception if the request returns a 404, otherwise, I would not catch this exception.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Seen proxies before that didn't parse multiple entries on a Cache-Control line. Do we need both, or can we just use max-age?
NB: no-cache is a value usually found in requests, not responses. I'm not sure of the effect in this case. To be on the safe side, I'd update this to read private, max-age=0 instead.
Why not in-line 'enc'?
Worth doing a flush here as well?
I think we need to check validation of the state transition diagram. Let's handle it in a separate issue. Please create an issue for this.
please move the isEmpty methods to the scimSchema
let's call it updateCodeMinings() instead.
This could be confusing here. How the user know the all fields?
Don't think items can be null, and ArrayList (as well as List and Collection) has an isEmpty() method itself...
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Is this reload really necessary?
These 2 conditions can be merged into 1 condition
Please call this one time and also check only one time.
This line can be combined with previous line.
Please make this a string resource and change it to "Unable to display nearest place that needs pictures without location permissions".
Seems that empty elses are generated now (at least in Java)
upt.unifyGraph(graph) is double code. Better use this structure: new ReferencePositionTraverser(reference).referenceMapGraph(graph);. The graph = isn't needed.
same for thos changes
assertThat(graph.getEdges()).isEmpty() looks better
I don't like that we're setting it on the CheckpointConfig that the user gave to us. I think it's in general not good that we just pass this through but now is the first time that we modify it here, I think. Maybe we should do an internal copy of the checkpoint config and then we can modify it?
Why is this change necessary?
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
A little wasteful when all you need to do is just set the fields and return this...
BlockPos.ORIGIN
It might improve readability a little bit if the expected score was a variable instead
What's the point of the 6 trailing zeros ?
s/policies/policy
Use getSimpleName instead?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
why object? lets change it to the particular time we expect to receive so we could catch potential failures here
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Should we check for systemConfig.isOutdated() as well?
Should we break the for-loop early if the condition is not met?
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
in the case where the Bytes object is immutable, it would be nice to store this after computing. This way it does not need to constantly recompute for case when Bytes are used in hashset.
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
if the advantage of this compare to 0 <= b && b < 256?
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.
suggestion return stage.thenCompose(ignore -> awaitQuiescence());
+NonNull for return type
Nitpick, but if you made this have an else block you can remove the thenCompose lambda allocation.
Unnecessary, can remove.
entry
entry
entry
entry
entry
delete
Use [Bundle.putInt(String, int)](<LINK_0>,%20int)) instead, no need to serialize a base type.
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
Use a streaming version here
directly return
here we'll also have changed from ConfigException.BadValue to IllegalArgumentException I think; a toBytes that takes the origin/path could solve.
should this filter out null resources? (ie. bad paths)
Should this constructor one just delegate to the new one with Function.identity()?
Set.of(...)
Do we need to make sure these file names are also Windows-compatible? If so, we should include a few more characters to the list. - Linux/Unix: / (forward slash) - Windows: < (less than) > (greater than) : (colon - sometimes works, but is actually NTFS Alternate Data Streams) " (double quote) / (forward slash) \ (backslash) | (vertical bar or pipe) ? ( question mark) * (asterisk)
Codacy found an issue: [Use explicit scoping instead of the default package private level](<LINK_0>
style guide
previous naming was more clear.
Double* variant of this class uses object == null ? null that is better
Default should be false
Default should be false
It could be useful to factor out this constant, which is also used by org.nuxeo.connect.client.jsf.AppCenterViewsManager.shouldValidateStudioSnapshot
Default should be false
When migrating isBooleanPropertyTrue  the default must be false.
return Promise just to symmetric with start()...
Should this also set engine to null in a finally block? If not, I'm not sure why it checks for null (line 177).
Need to check those variables are initialized or not to avoid NPE.
After shutting down the Executor, we should explicitly set it to null which is more friendly to the GC.
What's with the suppression? Also what happens when you call shutdown twice?
This method is no longer waiting for the refresh operation to complete. Not sure if that is important for the test flow or not.
I would prefer IllegalStateExceptions in such cases.
This will NPE if BundleRevision.getSymbolicName() returns null, I would reverse the equals target to be symbolicName.equals(bundle.adapt(BundleRevision.class).getSymbolicName()) This does not scale well if you have large numbers of bundles. If this is a hotspot of your code you can consider using org.osgi.framework.wiring.FrameworkWiring.findProviders(Requirement) using an "osgi.identity" namespace requirement. If I recall correctly virgo uses Equinox regions. That can end up hiding bundles from a BundleContext perspective. Using FrameworkWiring.findProviders would bypass the equinox region hooks so you need to be aware of that.
bundles.size not logged
Use ImmutableList.Builder to construct a new collection.
This will probably be permanently unsupported.
MemStore is used for tests, so we need to implement this function.
This should be implemented for consistency.
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
should return false if the validation fails
You can remove all the following code: if (!(.... return false; } return true; With simply : return super.canDoAction() && canRemoveVm()
We should also check the servers which we want to update the hook content is in UP state.
this should be in super as well.. even first
using command line user can provide a wrong id (say, by mistake), so its better to check for getVdsGroup() == null here as well
The operator should be && not ||
done for patch3.
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
The exception message doesn't reflection reality:  "no query or collectionCallback is specified"
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
please use (1 << priority) instead of priority + 1
This can be static.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
I'd add an always-printed log message here too to make sure it's remembered.
I don't see clusterId being used in sync-job. Is this required?
looking at the gson code base, remove also could return null if element not exists hence we might want to guard aganist NPE here as well.
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
Better assume immutable parameters. Don't modify references to an input variable.
return null to make this more explicit ?
Modifier 'private' is redundant for Enum constructor - needs to be removed.
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
I think we can avoid this .INSTANCE. business by putting the fromV1APIJson method inside a companion object.
We mix two different comparisons styles here: "expected".equals(actual) vs. actual.equals("expected"). I would prefer to use the first one only as it is NPE safe.
Can be simplified as: return Strings.isNullOrEmpty(valueInEnvironment)? getPropertyValue(properties, defaultValue, property) : valueInEnvironment;
System.out.format instead?
These implementations are fine, but I wonder if the code wouldn't become a bit simpler if the defaults were stored as String values, and instead of the parameters.containsKey(String) you would do something like: return EventLogCategory.fromValue(Helpers.getString(parameters, PlatformSmartmeteringKeys.EVENT_TYPE, DEFAULT_EVENT_LOG_CATEGORY)); as a one-liner.
I would prefer to use String.valueOf(value)
I would prefer to use String.valueOf(value)
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
we never use NULL, it is a bad practice in general.
inUse is set twice in this constructor
unnecessary
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
Maybe extract this if-else in a method like createResponseHandler(Logger), otherwise it is duplicated in both constructors.
We create a new map-operation for every call, so moving evictions here doesn't make any difference.
remoteVolumeName passed twice. I feel remoteHost to be passed as second arg
Instead of catching NullPointerExceptions, it's better to check if session.getRemoteAddress() returns an object (and only call .toString() in that case).
Would this method stop the rebalance as well? I can not see stop call here.
@Override
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Can you just change the return type of this method?
Shouldn't this be member? I think there are a bunch of places below where you have it as session, too.
Should this be false or true?
Change this to  java Member me = (Member) session.getAttribute("member"); MemberDao memberDao = new MemberDao(); me = memberDao.getMemberById(member.getId()); if (me == null) { return "redirect:/denied"; }
Like above, using the absolute path should accomplish this properly
Just want to double check that the following null check is correct:  if (mScrollDirectionListener != null) { mDetector.onTouchEvent(event); }  I think yes, since mDetector is always not null, and it fires updates on mScrollDirectionListener.
why are you using getAdapter() and not directly mAdapter?
why getAdapter() and not mAdapter?
Generally agree + good find. This method probably should return false to indicate that we have not handled the event. <LINK_0>
@manuelplazaspalacio I have a doubt here. This Listener is in the main and affects also the rest of the variants. returning false wouldn't it make the rest of the variants to stop working? The feature I'm concerned about is the previous/next swipe in Laos, for example. I guess that we would need to create a Strategy here, moving the common behavior to a common method and separating the difference into a per-variant answer?
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
Since the varargs parameter of String.format(...) is of type Object for which toString() will be called if non-null, it's a bit safer to do the following in case the key schema or value schema are null: suggestion return String.format("<SchemaPair: %s, %s>", keySchema, valueSchema);
Should we just use MoreObjects.toStringHelper() for this?
Should this method be final?
This should stay final
this does not handle the empty 'lists', it will throw an exception
This is already done in the other method.
Why are the problems not enough?
This would not be a performance improvement. (And a tab character has appeared in the file.)
Simpler: ArrayList<T> result = new ArrayList<>(collection);
This should follow the normal exception handling path and let the caller handle the printing of the exception.
To avoid confusion, rename the variable to sessionId.
Missing the substitutions for the {}'s. suggestion LOG.error("Failed to parse value of system property {}='{}' to an integer. Using default value.", sysProp, val);
Too much nulls in arguments, please make variable content = null and use it in constructor. Please apply the same for all other test method you changed
entry
So, if the xpath query matches event than this method will return true, right? Than the event will be propagated to TreeWalker. This java if (!filter.accept(event)) {  will be evaluated to false and the message will not be removed from the set. Thus, what is the sense of the suppression? What do you filter? Look at testMatching. The user writes the query /CLASS_DEF[@text='InputSuppressByXpath'] in order to suppress the violation, the filter should deny the event, but your filter will accept it.
we should only handle non-transient values, or?
@prondzyn Let's use UnsupportedOperationException instead, to avoid importing from commons-lang library.
If you run checkstyle, it will complain you the access modifier order. You should do public final instead of final public.
@dmzaytsev ThreadInfo can read currentThread in Ctor, no need to pass static
Please use assertThat (result, failsWith(NAME_OF_FAILURE))
You can make this method private
we should not care about LOC metric. We should care about expressions without side effect. ~~ Ideally if test should not have modify anything, unless actually needed. Please update result variable, and only after that proceed with testing it.
We actually don't need this line at all. The test check something else
run already called tally, so do you need to call it again?
StringUtils.isEmpty
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
This branch is not needed
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
I don't understand this change?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
This will throw redundancy warnings in IntelliJ
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Why did we make this public?
We should validate that's non-null (to fail sooner).
My point is about consistency between different codecs. Protobuf codec assumes the callback handles the flush, while this code has to call it explicitly. We should make it consistent and set the expectation that the traverse callback should handle flushing/closing the generator. Then the codec's would just close the traverse callback.
Should be switch (type)?
Does this make sense? I didn't think bare repositories have an index so repository.readDirCache() would already throw an exception at this point since repository.getIndexFile() throws an exception for bare repositories as is called by DirCache.read
I think 15, 11, and 4542278 should be named constants.
It would be great to rename the variable to isParamCountValid.
This wouldn't take the precision into account so if the other method would return a fully qualified host name, this would always return that instead of a substring of it.
excluded. isExcluded is name for a getter.
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
could be simplified: Collections.addAll(refsSpecs, specs);
same thing, while you are cleaning, other thread could store other key.
Is this idiomatic? In fact expect that won't be true, it's just that will be interrupted before the assertTrue returns? Would be clearer to omit the assertTrue?
In the utils package there is a class called ConverterUtils that has isEmpty and hasContent functions. I suggest using these when you want to check if lists, sets, maps, and strings are empty/null vs full.
You'll want this inside the lock
Formatting issues. Please use appropriate spaces between string literals.
static
sounds like it could be set on error level
not necesary
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
unneeded throws Exception
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Wouldn't the below code be more readable and correct? public static boolean isStatusOk(Map<String, Object> response) { String error = (String) response.get("error"); if (error != null) { String errorCode = response.get("error_code"); String errorDescription = response.get("error_description"); StringBuilder sb = new StringBuilder(); sb.append(error); if (errorCode != null) { sb.append(", Code: "); sb.append(errorCode); } if (errorDescription != null) { sb.append(", Derscription: "); sb.append(errorDescription); } throw new RuntimeException(sb.toString()); } return true; }
I think the annotations should be on separate lines
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
or more simply: if (forceRemote != null && forceRemote)
I think you should be able to pass config in directly
i think you should be able to pass in config directly
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Use map.forEach
filename
why not null as value?
cant we directly remove from table.getParameters() ? why need a copy ?
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
If this should never happen throw an IllegalArgumentException instead.
Unsigned types are not used in the current implementation. So, you can omit them.
Gson doesn't run on these versions so I don't see any reason to include them.
This list needs to include soul lantern.
Is it necessary to call this again?
As there is no else branch you seem to allow unknown/unexpected fields. Is this always allowed (i.e. per setting on the mapper/parser)?
Minor, but "extra".equals(tagname) would make this more concise. Java and its endless checking for nulls...
Are you sure that you should check value on null here?
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
Argument name
Argument name
MarketData.getValue never returns null
MarketData.getValue never returns null
There are no tests for these two new methods
Looking at the CommandCache#reset() method you pointed me to, it made me realize that we should check here that ctx is not null first, to avoid any risk of NPE.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
So this will be used for quantity and duration too or you need separate ones?
fCommandCache stores the MI command we sent to GDB for a particular context. My guess is that it can also be associated to an IMemorySpaceDMC. In that case, I believe it should also be cleared when its parent IMemoryDMC resumes. If I'm right, you should be able to trigger this issue by requesting the exact same memory after a resume or suspend; my guess is that a cached MI command will be returned with old values.
This will trigger for thread exists also. We should make sure we are dealing with a process using: if (event.getDMContext() instanceof IContainerDMContext)
+ NUM_HEADERS + NUM_FOOTERS;
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
.add("noShutdownOnExit", noShutdownOnExit) (was shutd **wo** n)
Add .omitNullValues() before the toString() call
"Clean orphans from PROPERTIES" to be exact ?
No interest in removing the stageTimeoutMs value?
I feel like there is a case here where there isn't an existing pipeline (via the save entrypoint), which should probably be legit from a stale checking perspective. I also suspect the submitted payload in that case would not have a last modified (unless that is magically set somewhere along the way with a default value).
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
Planning on making the number of retries configurable?
lets change this to pipeline.hasLeaderID().
Can you add getId() and mark id() as deprecated?
Can we make it final?
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
Missing StringUtils.isNotNullOrEmpty() check
Is this method used?
Not good to use Optional for collections, just return empty collection
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
Why absent?
We should at least resolve the Type at construction, so that exceptions are thrown as early as possible. The qualifier lookup can still happen in the build method though, and satisfy the purpose of this refactor.
That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead.
This should occur before setInput(input);
![BLOCKER](<LINK_0> 'Severity: BLOCKER') Refactor this method to not always return the same value. [![rule](<LINK_1>](<LINK_2>
According to the reference bellow, a UserProfile may not have a reference to a Person, hence the getPerson method may return null, which will lead to a new NPE. <LINK_0>
This name, EMacroContext, needs to change and be in line with other services in the workbench (i.e., XXXService).
this change is no longer needed.
Check other tests in this class. Replace startGrid(1); by startClientGrid(1);.
Field should be named the same as the resulting JSON object to reduce confusion (if possible).
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this null-check of an "Optional". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this null-check of an "Optional". [![rule](<LINK_1>](<LINK_2>
Is payeeIdL a typo or intentional?
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
make this synchronized.
This assumes the webcam res == screen size... Not the case. height:width set in reporter seems to be ignored
Worth reporting what was null?
Can you specify the exception/message being thrown on this call? Otherwise you could use the Assert#nonNull(T, Supplier<String>) function contained in the framework. Doesn't return the field like requireNonNull() though. :/
this.configuration = Assert.requireNonNull(this.configuration, "this.configuration"); We should use this pattern for each final param that is created by the constructor. By doing so exceptions in case of a null value will be thrown as early as possible
Here it would be nice to use a static import - that would make it more consistent with the other code
Shouldn't there be an assertion checking that the shipping method was actually set, price and all?
Here it would be nice to use a static import - that would make it more consistent with the other code
Do we need the two lines above? Or are they left overs from testing?
Here we should add an assert to make sure that the value is set correctly.
Why is this necessary? This should probably use the generic updateBiometicListeningState(). I think you're doing this to turn on the iris scanner? If so, you should leave it authenticating state, like we do for fingerprint, and send another signal to go into high power mode to complete authentication. This is what we do in fingerprint.
Same question.
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
Pull this into a static final variable
I would retain the existing indexOf body to to avoid indirection in the most common case.
Please add a java Objects.requireNonNull(computation, "computation is null");
Please add a java Objects.requireNonNull(computation, "computation is null");
java Objects.requireNonNull(callable, "callable is null");
In case self is a BufferedIterator should this return self instead of re-wrapping?
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
It's a good update
use the optional, luke! ![image](<LINK_0>
Use fire(event); for all EventHandler based events
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
Program to interface, not to implementation - please change return type to Map<String, Object>
technically speaking... :) the user agent header value could be stored in a static field and not computed each time getDefaultHeaders() is called. I'm sure the performance difference is negligible, but I couldn't stop myself from mentioning it :)
I'm seeing most of the string literals used for property names, etc are re-used in quite a few places. Let's introduce appropriate constants upon them to be able to make the code more maintainable.
Missing space between ) and !
In migration case, we shall validate if stats are associated with correct writeId. I think, in our tests, it should be pointing to last allocated writeId.
Maybe wrap in an immutable map.
Maintenance of the map will be simpler than that of the list
What do you think about Comparator.naturalOrder() instead of null ?
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
I'd like to see direct unit testing of withService and updateServices . There appears to be a fair amount of indirect testing of withService but updateServices gets little to no coverage.
Can we have a thread name here?
please validate ledger id
you could use Exceptions.expectExecutionException();
close should be implemented with asyncClose()
This should happen within the future
must be package local
Minor: Ideally we should avoid doing work in the constructor. Pas apiRooUrl and Client to the constructor, and provide a factory method receiving apiRootUrl, username and password and creating the constructor dependencies.
There are keystore types which don't require a password or gets it from another channel (e.g. WINDOWS-MY type).
suggestion this.authentication = new AuthenticationContext(username, password.toCharArray(), null);
tests method could only throws Exception, since you already expect which one will bo throwned
suggestion connectionFactoryList.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
We can strip this down quite a bit to just java this.eventReceivers.forEach(EventReceiver::close);
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
remove this
better do the close in a finally block.
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
no need to call super explicitly. Any construction implicitly always starts with a super() call (unless it's a this() call to another construction).
please remove empty c'tor
Should be a SamzaException with a message, not NPE.
Not sure, why not use @NotNull?
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
I think you should be able to pass config in directly
i think you should be able to pass in config directly
use ShellIsAvailable
use ShellIsAvailable
use ShellIsAvailable
add wait condition for shell
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now
nit: plural naming on list?
This class has no superclass, so I'm not sure we need to call super() here.
Use fire(event); for all EventHandler based events
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
Just curious, why do we need to change the access qualifier to protected?
so if you make this private that would prevent subclasses other than Some, right?
Why does a utility class need a protected constructor?
Should this method be in the account object instead? Something like isRegistered():boolean?
I think the setMaterializableResourceProperty should handle the materialized scenario itself. This means that this method can simply invoke setMaterializableResourceProperty(ACCOUNT,account); and then, the internal code of setMaterializableResourceProperty will check whether the account is materialized or not and then will relay on setResourceProperty(ACCOUNT,account); internally.
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
The code can be simplified to rely on autoboxing.
if these Boolean methods can never be null why not have the return type be boolean instead of Boolean ?
can you add to Builder as well
boolean
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
casting to Integer is redundant. IDE shows warning
not so readable. looks like good candidates for parametrization
you don't want to check that images are legal and exist?
would be good to mention TestMojo#getTestDependencies() here as it has to be kept in sync
We need to check offset + length <= arr.length?
My expectation here is by the time the code is JITted the JVM will be able to predict ConverterHolder#getBestConverter() is both monomorphic and returns the same value for every invocation. There will be a bit of extra code to typecheck and branch (and de-opt) if the prediction fails, but I believe the branches will have the right prediction hints. The generated code will have the same performance characteristics as previous. If this is a concern, a jmh-based microbenchmark could confirm.
@njhill just to be 100 % safe should we better use: ?  System.arraycopy(array, index, copy.array, copy.arrayOffset(), length);
do we care to check for the length to be positive here?
Not very readable. Also, did you consider DictionaryBlock constructor that takes idsOffset instead of copying the array?
We usually don final local variables.
before:-20160923, timeFormat:YYYYMMdd is misleading as the reader may think the value for before should match timeFormat, while in reality a value starting with a - indicates number of days and timeFormat is not used to parse it. Something like before:-10000 would be better.
I think it is better to throw exception
Please import assertThat statically here and in the other places.
Lets keep these methods internal for now (package accessible).
I thought you wanted to end this practice, Adrian?
Even if this was copied, we should fix the this.m_ references here :)
You should use assertNull.
minor: this. does not appear to be our convention for fields. Use it (or don't use it) consistently for all fields
assert.NotNull ?
Use Guava hashCode function
Yeah this should be return set.get();
This isn't correct; it defers to the default implementation of Object::hashCode, which will be different for different instances, but the contract of hashCode requires that two objects' hash codes be the same if equals is true. It would be better to return a constant.
hashCode and equals are inconsistent.
you didn't use methodName here, is it intended?
!reason.isEmpty() can be used
They are mutually exclusive? Or is that a micro optimization?
The 'if' check isn't needed here, right? replaceAll will only match if these are true?
return null to make this more explicit ?
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
can be delegated as: putByteProperty(key(key), value)
can be delegated as: putCharProperty(key(key), value)
can be delegated as: putBytesProperty(key(key), value)
am i missing something this seems like a duplicate method call.
That's in the hot path of any send operation and rollbackIds would be contended by all the producers/consumers using the same AMQSession and it create a Long instance on any call of it. There are other ways to implement it?
use a constants in PicsConstants for page.png
Is this an artifact or intentional? It's not in the interface.
Should it be internationalized ?
Select Gradle Project to Import
Should we also check isVisible here?
On iOS I chose to not ignore this error since it makes the data structure useless and should require some action from the API consumer.
Should this return the AzureTable?
is there a reason why this method isn't implemented?
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
you may add the error message as an additional third argument here, in order to give the users a chance to understand why that is
This should stay final
Should this method be final?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
This check is redundant because you check this in handleSelection()
I'm pretty sure we use IllegalArgumentException for these everywhere else.
unsubscribe()
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
backspace (bracket should be one tab back)
space
1. openHistoryPage() method should be named like openFileHistoryPage() 2. method looks better if parameter consist only from one variable e.g. historyPage.openHistoryPage(URLsContent.fileName);
Please use Yoda DateTime.now().getMillis() for a timestamp
it would be mighty fine to clean this up into a string format or the like if you're feeling up to it
Wouldn't it make sense to at least log a warning? I mean, in the end it's the user who accidentally made a mistake/typo, the service silently "accepts" this configuration but it somehow does not really work as expected. Or did I miss anything?
@ILikeToNguyen Why the change in visibility here?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
Nit: Consider adding the default to defaults.yaml instead of here. That way it's obvious to users what the default is.
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
@slubwama provide an error message description of what has failed in addition to the stack trace
some other Executors wait here and see if the task exits immediately. Maybe we should do that too?
Should we be concerned that the expireTask can be reset after this synchronized block completes? Whose cancels the Future in that case?
Should we abort for all exception or only for OOM?
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
nitpick: just return <cond> sufficient
This is a little peculiar - does the index represent the position in super interceptors or executor interceptors? Maybe we should only support 0 as the index here?
Either null or empty
Why is there a fromByteArray method? Why not call the constructor directly?
When you extend the abstract class that you use here, you shouldn't need to override these methods. Is there some special reason for doing that? I worry that any new method addition will be forgotten here and would rather that we just used the abstract class'es methods.
But existing rows use null not "" for the parentUuid.
I assume this is a time value, let's indicate its units in the member and column name.
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
Could we reuse instances? Perhaps justified if getCoder is frequently called.
static imports
static imports
we'll never reach break;
The philosophy of simple-mode is to work soundly on most code, with very minimal restrictions (using around reflection). We shouldn't be using type-based optimizations in simple mode.
This should say "LocalTime".
This should say "OffsetTime".
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable length second fractions. An example of this is here: <LINK_0>, along with adjustments to the tests to make sure they are consistently truncated (H2 supports milliseconds but the tests were comparing it to microseconds on my machine).
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
please replase MojoExecutionException for a new generic DeploymentExecutionException
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
we don't use curly brackets for single line bolocks
Why do we need a snapshot of the world? Isn't it possible to just use getCurrentState() to get the selection?
This not really a good name
return an Optional<Integer> instead, then you can probably also get rid of JMXServer#getInstance
what's the intent of this change?
please fix whitespace
Em, what does spotbugs say on Boolean?
no public
Huh? :-)
I think this should have its own integration test as this is nth_value specific stuff only
Would you mind improving this test to use executeFile() instead of executeString()?
StringBuilder, or Joiner.on(" ")... something
Can you use an anonymous name for the maintainer? Not something from production
have a look [<LINK_0>](here). This class should be deprecated and no longer be updated, at all.
Same here, with respect to bad exception handling.
quit can be made public, to be more explicit.
ATDServiceHost
Line wrapping usually happens before the period.
return symbol != null ? symbol.qualifiedName() : "";
It is useless to test before marking as ignored, as only the symbol which are already known could be marked. Note that to be known the symbol have to pass the "isSymbolRelevant" test, which is equivalent.
This can only happen if semantic is not present (symbol method is not annotated as returning null). As such you should test if semantic is present and not raise an issue if it is not the case.
Use JavaSymbol.MethodJavaSymbol rather than simply MethodJavaSymbol. This class is a nested class from JavaSymbol and we usually prefer to limit the number of imports.
remove final modifier.
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
This will create a new instance every time. Cache the instance in a member variable?
It would be cleaner to have this set as part of the UnitTestModule() at the guice level so people don't need to remember to do this themselves.
Do we need to do this here? This seems like it's creating a circular dependency of the EMF into Guice, but the EMF depends on Guice.
Can this also go where zookeeper.root_key is configured?
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
why not just return it directly?
Can you replace IDs with names in this log message?
Enforce immutability
If you make the EMPTY_EXPIRES, you could use it here.
I think you want to do this in the reverse order
empty finally block
why we don't swallow exception here for close?
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
please refactor code a bit more like:  do{ String line = lnr.readLine(); if (line != null) { readerLines.add(line); } } while (line != null)
Can we have a message assert on this? I think the point here is that the exception thrown by the runner close isn't the exception that happened inside the shutdown operation
You should use deadline. Furthermore what the interest to change it ?
Does it still work on Windows?
If the path is null it should be set to "/apps/" + name.
StreamApplication app = new WikipediaApplication();
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
Remember to revert this file, it should know about the transport class.
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
add mScanner to the Closer when it gets initialized. The way you have it now could potentially NPE
InputStream.close() doesn't contain any implementation so you can drop that call (but it doesn't matter). But I am pretty sure that the base class close will not get an implementation some time because it would break all previously working subclasses.
final
"Path validation" instead of "Request validation"
RuntimeException will be sufficient
Is this a list of file names or fully qualified file names? Not trying to nitpick but it does make a difference and with the need to build XML and .done files based on what we initially get, it might make it more clear which one we are dealing if with more explicit variable and parameter names were used; especially during maintenance. Thoughts?
RuntimeException would be sufficient
Why are we doing double math here? This should be: return Math.max(1L, nano / 1000L);
> In Java the / operator has a higher predence that the cast operator. actually, no, [cast has higher precedence than division](<LINK_0> <LINK_1>
Maybe Ints.checkedCast() for sanity
this is a confusing name for a function - why rename?
lock user_point
Should this have output partition too?
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
Camel case here too
should we have srcBlockId and dstBlockId?
Change toString method to include both
Consider Arrays.asList("xxx","yyy", "zzz");
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
Why this change?
why do we remove internal? internal should be as any other.
Eep, does null actually happen? We should figure out where that's coming from and replace it with "".
filter could still be null when this line is reached - we should check it isn't null
Generic type not used, remove.
StringPool.EMPTY instead
Also, this whole method could be shortened to a single line: return (INTERVALS != null) ? filter.getFilteredRecords() : filter.getFilteredBases(); Oh, and another thing: protocol in this codebase is to put spaces after the 'if' and before the braces. Otherwise, you risk incurring the wrath of @nh13.
I think there is some findbugs issue with not using {} not sure.
- log warning that option is not supported by SNMP
Based on how it's used, it's more like a listener not callback.
suggestion recommendedLayout.keySet().retainAll(newServices.keySet());
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
You might also consider adding constructor that passes k8s environment instead of internal one
nit: remove brackets to be consistent with 2 lines below.
I think you missed updating the parenthesis on this one
do we care to check for the length to be positive here?
We need to check offset + length <= arr.length?
shouldn't you do a defensive copy?
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Should check if errors contains error with key "Concept.conceptClass.empty"
Should check if errors contains error with key "Concept.datatype.empty"
this should be true.
I haven't looked at messages.properties, but this seems like an odd message code. (Other?)
To increase readability of this test I would just drop this statement, and move ifCond block inside if condition
It is a bug! Please notice that there is sort in array_agg(orderstatus ORDER BY orderstatus).
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
isInfoDebug
Why change the name the property? Accident due to mass refactor/rename with IDE?
Technically setting closed = false isn't needed since this is the default for a boolean
The original constructor can delegate to your new one, i.e.: java public KafkaRecordSupplier( Map<String, Object> consumerProperties, ObjectMapper sortingMapper ) { this(consumerProperties, sortingMapper, getKafkaConsumer()); }
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
INITIAL_SIZE is misleading because this constructor creates a fixed-capacity queue. So this value is actually the maximum size.
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "createExecutor" a "static" method. [![rule](<LINK_2>](<LINK_0>
Just out of curiosity: does this test fail with 60 seconds timeout?
Because the failureCounter is incremented at multiple places, it would be easier for test fixing to use a failure log which you push a message to. It doesn't matter much for the completeness of the test though.
rename
rename 'listeners'
not all listener
not all listener
not all listener
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need anything to be added to DB.
cannot be null.
We can directly use updatedVolumeList instead of copying it to a local variable.
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
But we have already clicked the button in the command before, haven't it?
What we are waiting here on?
just reuse this method where you need  public void selectAutocompleteProposal(String item) { seleniumWebDriverHelper.waitAndClick( By.xpath(format(AUTOCOMPLETE_CONTAINER + "/li/span[text()='%s']", item))); }  <LINK_0>
Might to replace on the exist _waitAndClick(By elementLocator)_
Are we really need to wait 2 seconds if we are waiting on web element anyway later?
If you instead call this lastItemPositions and subtract 1 here, does that save you from having to subtract 1 from the final return? I think it reads clearer not to have a "- 1" on the last return.
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
== RHS_NULL?
This should never be null; let's not check against that. Nesting makes the code less readable, so we have nothing to gain here and something to lose.
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
I'd rather use Money here.
Let's adjust the formatting :)
Please avoid duplications. Rename this method to just create.
LOG.debug
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
I would recommend an else if here to avoid comparing against a string unnecessarily.
I think lowercase l should also be considered
That should be toHtmlForAnthology. You mixed those two up.
Args.notNull
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Not sure that it's good. If path is not setup - this.dir will be still null - and we just pushing NullPointerException one level down.
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
this if/else is equivalent to this.path = Optional.ofNullable(path);
think you should add it as method somewhere
FindBugs finds this line not to it's liking it seems: Exception is caught when Exception is not thrown in org.jboss.weld.probe.Reports.getDesc(ConfigurationKey) ["org.jboss.weld.probe.Reports"] At Reports.java:[lines 78-370]
Nitpick: Can probably remove both the if and the else (saving three lines) by starting with description = MoreObjects.firstNonNull(description, "") right at the top.
Please restore the original formatting.
Can we reuse the existing converter?
I don't think we need this catch - this is handled by the boolean return value.
This should be handled by the nodeDelete return value, so we don't need this catch.
Revert back to sessionFactory.getCurrentSession()
I believe it will be nicer to just generate a String containing either an 'On instance of...' or 'Of class: ...' and add that to the message.
Use final variable declarations
same here. In case you want to open an ErrorScreen, you can do so by using one of the reportError() methods from <LINK_0>
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
log the exception ?
specify charset?
Why not throw IOException and let caller handle and log etc.
can you make all of these as just Query and not org.hibernate.Query?
Please use the positional parameters.
We can't filter by closing time?
Also for the next few methods, just return (List<CourseStudent>) q.execute(...); directly.
I'd lean mildly toward using uppercase for overlapping keywords. But would be okay leaving it as is.
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
If an implemented class uses this default group method, does it work with returned null or it has to override with some implementation?
I think these methods should throw exceptions (might need to create one). They can't return false, and having the impl throw IllegalStateException on any failure doesn't feel right.
Why not result.removeAll(b)?
studentsWhoRespond -> studentsWhoResponded
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Don't we have to say that this is uniqueId JDBC?
These two lines get called repeatedly in (i.e., 87-88) several of the methods that follow. Would it be worth creating a private method that returns the objAcls?
I think Local.ROOT is probably a better choice.
This should be removed - it's absolutely fine for entity data to be empty. It's only during serialization to native format that it should not be empty (ie adding the EntityType field)
You can static import the checkState method.
return this.toInteger() == 6;  Since toInteger never returns > 6, I find the >= a bit confusing (even though it's more future-proof).
this.
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
Use same order as the field declarations.
that class would be better with a builder, though I wouldn't ask changing it now
This line is redundant.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
does this need to be calculated on the fly each time or can we save the iterable?
Should we throw an exception instead if a DimFilter was null?
Can these 2 functions be constants? So we don't need to create new instances every time these methods are called
There are 2 issues with this line: - It's long & complicated due to chaining several method invocations and cause reader hard to realize the purpose. If we can break it down to multiple lines, it will be great. - The Function object can be refactored into a method to be reused in the next getAllProgramLead function.
Can you make these final?
We should call the init() method first, instead of letting the KerberosAuthenticator do that for us.
I don't think we need this catch - this is handled by the boolean return value.
Is it for sure targetName will contain @. I mean in case of serverName null, and when targetName is not under server control entirely.
This should be handled by the nodeDelete return value, so we don't need this catch.
One more very, very minor point: We should be wrapping these exceptions properly (IE: initializing the throwable source in the new exception) rather than just adding the same string message, otherwise we lose the most relevant part of the stack trace. This is a general habit we should get into with error handling
Unsure this addition is useful.
Is there a reason that allocationPools, dnsNameServers, and hostRoutes are missing here?
Omit nulls or not?
.add("noShutdownOnExit", noShutdownOnExit) (was shutd **wo** n)
weight is missing from toString()
Remove all "null" cases. There is a default case for that.
If this should never happen throw an IllegalArgumentException instead.
Gson doesn't run on these versions so I don't see any reason to include them.
You should not duplicate code here. Add second switch case for exiting SOS alarm option.
Unsigned types are not used in the current implementation. So, you can omit them.
static
The null check is now redundant since now we do literal.equals(variable).
remove
calendar.setTimeZone(new SimpleTimeZone(timeZoneOffset, Integer.toString(timeZoneOffset))); ======== don't use string concat
Variable names must start with lower case. Also make this hostId, instead of host because that is more accurate.
ctx.close()
replace with ReferenceCountUtil.release(msg)
maybe log an error message here if numConnections ever goes less than zero
Why wasn't this left as-is? I'm fine with it, but it just didn't follow the pattern of the rest of the PR.
if there is possibility of writabilityStates to be null, it might be better to write this as "".equals(writabilityStates)
is the server name mandatory still ?
assertNull? And the withTx... though I know you've just moved this code from another test.
Could you please use Map interface here (and not the implementation)?
you can use try-with-resources to automatically close the client when finishes. java try (RemoteCacheManager cacheManager = new RemoteCacheManager(builder.build())) { ... }
Good one! :)
replacing this with helper method would be great
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
You could probably use the same URL as in getResultById here.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
If component is null, this will have NPE'd by this point if typeMapping does not happen to be a type that allows null keys (most don't)
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
It should be "path".
This is three minutes. An since FAT is two seconds we require only larger than two seconds. On many file systems that is three seconds, but 2.001 would do. With a Unit test you would have found this out. Do we break anything because the ObjectDirectory had two /minutes/ as fudge?
Return sizeInByte instead, if available.
Add a blank here, please.
I think it is better to add this to the generic 'Request' interface. To make it easier to use I think also that we should have several 'header' and 'query' methods in that interface, at least two: one to set just one header/query, and another one to set a map (I'd consider this optional), that way the user can do the following: vmService.start() .header("My", "header") .query("my", "parameter") .send(); We should also probably have a new 'BaseRequest', or similar, implementing that interface and providing the implementations of those methods.
Same, 4 spaces.
Is this really needed? What if the exception throws by the target isn't a RuntimeException?
This method can be static, as all the methods it calls.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
I guess I'm out voted on using this. :-(
If an assignment strategy doesn't implement movePartitions and if the operator calls movePartitions, It is better to throw rather than silently return. This way it is clear to the operator that movePartitions is not supported for the connectors using this assingment strategy.
Make a copy of the keySet like ImmutableSet.copyOf(modes.keySet())
If you are using synchronization to control access to the session data, than I would suggest reverting the map type to a simple HashMap and synchronizing around the map as opposed to this whenever you read, put, remove, or alter it.
Avoid the intermediate variable and directly assign selfID.
suggestion Assert.notNull(id, "Labelset ID must not be null.");
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
Can you add getId() and mark id() as deprecated?
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
Try pushing methods such as getAuthorization().getViewConfig().isAdmin and getAuthorization().getAdminsConfig().isAdmin to Authorization class
Any reason for logging and throwing the exception. Normally, we log or throw.
In my opinion, we do not need this log. WDYT?
Is there reason for throws Exception in signature?
Should be externalized.
Externalize
Externalize
Externalize
you do not need the @NonNull
Which tests fail if we don't have this line?
I think this should be replaceFailed = false instead.
Silly think but can we call this workbenchPage, wPage and Ctrl+K lands frequently on the method sho(wPage) and I like to use Ctrl+K to follow a variable
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
5 or 10 minute schedule?
use log's parameter here
Fix logging level here (error)
suggestion logger.warn("Failed to do decode hash using base64! " + ex.getMessage());
Each of these catches should use a logger statement.
Again, please don't catch Exception. Code compiles fine without the try catch but you might want to replace it with catch for NumberFormatException.
hmm, why don't you verify the type ?
None of the tests in CaseDbQueryTests handle the condition where this Lookup is actually valid (and neither of the other two tests cover this code path)
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
The blank lines before and after method bodies are quite strange. We don't have rules about that but it seems inconsistent to me. It could be valuable to have feedback from others.
you can simplify it with a single line by replacing the method's body with: return validate(hostExists()) && validate(hostStatusValid());
to get variable replacement you need to use the idiom: if (!validate(isClusterSwitchTypeOVS()) && !validate(...)) { return false; } where the predicate methods return a validation result instead of a boolean (which will encapsulate test+result nicely) there are lots of examples in other commands
Please use StorageDomainValidator.isDataDomain()
note that here we will initialize imageToDestinationDomainMap. Maybe now we will be able to send it to ValidateDiskNotAlreadyExistOnDB and avoid the filterInvalidDisksForImport in excecuteCommand. please try this change and then: 1. create a template 2. detach the SD with the template 3. register only the template disk 4. register the template 5. try to watch the template disks (if something wrong UI exception occurs) 6. Remove the template and verify that the disk remains in the environment
please add dc compatibility level
this is 3.3 feature, not 3.2
This should be as it used to be, no need to convert to lower case as that should already be part of the "value()" implementation of SELinuxMode.
This should be 3.6, even if the "quota mode" concept was available sinnce 3.2.
Is it needed to wrap the exception in a RuntimeException, can we just remove the catch?
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
This check feels a little weird for a few reasons. It behaves like a factory (in that it returns new instances) but sLock is not assigned here. It also initializes a static field from an instance method and that feels strange. I suspect that if the lock is not being acquired in one method and released in another, and there aren't any waits involved a more primitive synchronization technique may be sufficient (such as a synchronized method or block, without the use of a ReentrantLock) -- I'll leave this up to your judgement but this looks dodgy
Please remember this ctor changed.
ooh! I ...Connector, here!
could this block be simplified?  java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; }
I guess we can remove the unnecessary this. accessor from these getters as well.
Can this be private, or is there another use case for default attribute outside the builder's call?
should the message include "command _with options_:" + this.options ?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
scheduleTimes --> scheduleTime
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
Don't need toString()
Can you add getId() and mark id() as deprecated?
Missing StringUtils.isNotNullOrEmpty() check
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
these setters should not be public
unused field
the attribute is not used
Can this be private, or is there another use case for default attribute outside the builder's call?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
scheduleTimes --> scheduleTime
It's beeter to used int type.
Would be better to have all these methods return a primitive long rather than an Object Long.
I propose to log the actual timeout used if it differs from the default.
maybe replace this with a @NamedQuery using JPQL.
valueOf() can directly take a String argument. And I think many of the other instances can be removed due to autoboxing.
Maybe catch Exception? Otherwise propagation stops.
if target is already updated or expiration time = -1, in either case we can skip update
For debugging: Would it make sense to log the exceptions here?
This code creates a HashSet object even though v exists.
As there is only one element, we don't need to use an object array.
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
Put suppress warnings annotation to method and change to direct returning the getted value to avoid temporary store the return value.
You can remove the unchecked warning by doing:  T service = clazz.cast(services.get(clazz));
I would recommend componentType.cast(new GlobalSecurityManagerImpl()); instead.
why is this return null??
Can you please move the Preconditions up to the constructor? Also perhaps check for matching with " projects/(projectId)/instances/(instanceId)/clusters/(clusterId)"?
Just return checkNotNull(id, "id").split("/");
Let's have these conditions one below other:  if (parts.length != 2 || parts[0].trim() .isEmpty() || parts[1].trim() .isEmpty()) {
What does this do? The result is passed directly into Datasets.load above so it should produce a dataset or view URI. But it appears to check if the URI is absolute (assuming that it has a scheme) and remove the beginning '/' if so?
@viczhang861 This class cannot possibly know that it is used to describe a non-builtin function. Can you give an example of a query that is failing?
it needs to be protected against concurrent modification
again I think you can use the diamond operator
There must be a more succinct way of doing this using streams.
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
/s/else/elseif
why not replace these two lines with return (getState(key) == State.SET)
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
OPTIONS could be more suitable here, since we don't want to transport the whole value
Should this method be private or protected?
make the constructor package private instead of private to avoid going through a generated synthetic constructor.
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
Can you assert the container has the right name?
Doesn't List as a Collection have a defined method to check whether it's empty or not?
Highly suggest isEmpty
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
throw e will never be executed.
Why do we need this change?
is this needed?
Use the new String(byte[], Charset.forName("UTF-8")); form to avoid the try/catch. Constify the UTF-8 Charset elsewhere for extra points ;)
if (args.length > 0 && "stop".equalsIgnoreCase(args[0])) { ServerLauncher.shutdown(true); return; }
Should this return the AzureTable?
is there a reason why this method isn't implemented?
These two lines probably can be combined into one.
Should we throw an exception here, or just replace the null value with an empty string?
I think the annotations should be on separate lines
Remove by dn/key.
We need configuration property persistence-manager-remove-count: 1000
final
Please consider using "debug" as far as message reject is a valid option of a client.
"Path validation" instead of "Request validation"
please use String.format to concatenate strings
whole expression should be wrapped into toIntExact not only rebase( index ) % entriesPerPage
shouldn't it be- (index +1) % numberOfMacsInRange ?
not super sure about this.
Is it correct that it is assumed that localToGlobal will always be called before globalToLocal?
Everywhere we call entity.getClass - we need to use the EntityDictionary.getTYpe instead.
The use of false here seems un-intuitive, in that we never update set the hash - even for new objects. Is this because we rely on the id being null in these cases in order to detect it is dirty? In any case I think it needs some tests around it.
Maybe rename idToChildResource or something along those lines.
Error message needs updated.
@rishabh-997 there is one in the application constants that convers this
Why are you changing to patient 7 here too?
Maybe, but I like simple and dumb unit test, this test checks that the service is started and well initialized, we don't need to test that on all tests. I don't see cases where a Before something is useful to understand failure in this case.
Using == for object comparison? :)
You need to test for another openmrs object to understand why am insisting
Do we need to store this as a field, can't we just return that in the getIpinterfaceId() method?
Log debug - not info.
method can be protected now (private if not isolated in tests).
Another option would be to use  log.debug("This is the execution root? " + result) to replace the lines 532 to 539.
Be careful when copy paste :). You are printing "bundle started" when stopping also. Another thing is when you have no string manipulations in debug messages, you don't need to check isDebugEnabled(). It is an extra if.
We do not need to check if debug is enabled since there is no string concatenation. The check will be done internally.
could we check this without throwing an exception?
Resources is itself part of Guava, and is marked @Beta. Why not use GuavaCompatibility.class.getClassLoader()?
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
missing non-nls warning.
static
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Not an exception
here is where i mean
@benbosman : I'd still encourage us to start with minimal/basic unit tests rather than waiting for "perfection". As you'll see above, I already have concerns that the UUID parsing is very fragile. So, having unit tests to prove it is working at a basic level would be helpful here, especially since the client using the REST API can literally send *anything* in a text/uri-list...so we need to ensure the parsing works as we expect.
I think a special case should be made for an anonymous principal, to disallow the API in such a case.
this method is @NonNull, throw UnsupportedOperationException until we implement this ?
This should return the list of resources under it, see FileResource impl for more details
@o-alex can you replace this with the DistributedFsService.closeDfsClient()?
What if we have only private static boolean isIncluded(String[] groups, Collection<String> includedGroups, Collection<String> excludedGroups) instead of 2 methods?
Maybe remove the package name as it is already in the import statements.
Use a builder method from TestNG Collections
we don't use braces around single line blocks
replace with List interface
I think on reason to wrap into isDebugEnabled() since we don't do any logic with argument to log.
RuntimeException would be better. Typically SI components check the exception and wrap it to MessagingException with "guilty" Message. If it is MessagingException already we lose the "guilty" Message context.
setErrorMessage
... and below.
why the double wrap?
This field is written here but never read, can be removed (Findbugs)
I don't see any change that is related to elapsed-time, why is this change needed?
super.getVm() will do dao call...
We might want factory methods for these common exceptions. Having all these magic strings all over the codebase is likely not ideal.
Good, if there are no other places where it may be set to null. But I would rather fix the comparison.
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
is this necessary?
these error messages should use the name of the expected property. keyField
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
I don't understand why we need to make this ThresholdInputStream so configurable. As I understand, this class is going to be used only inside this package. I would make it package-only visible and remove this "runnable" injection.
Please, use text "Project owner login" (Name was fixed after sending this pool request) thank you.
Please, use text "Project directory permission" (Name was fixed after sending this pool request) thank you.
Use "Mail" instead of "Mails". There is only one trusted mail.
Not your mistake, but please, fix it too. There is description for other attribute.
Please, use text "Projects base path" (Name was fixed after sending this pool request) thank you.
This can be made static
You can chain this like  java return ImmutableList.<String>builder() .addAll(currentSeeds) .addAll(newSeeds) .addAll(oldSeeds) .build();
This can be simplified to:  java return ds3Requests.stream() .filter(this::isGetObjectAmazonS3Request) .map(this::toGetObjectCommand) .collect(GuavaCollectors.immutableList());
This should probably be a constant since it is used in other places.
Change this to say "No requests to split" to differentiate the error message from some of the others.
no need for an ArrayList
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
nit: ~Square formatting
You've overridden this method but dropped the @Nullable annotation.
get(). (Btw since inner is plain, this check may end up hoisted and you'd never see it turning null).
