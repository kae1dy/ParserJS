Is this order guaranteed, ie ls-refs before fetch?
shouldn't you clear out restartToken and lastPackId at the start? The way you are using class variables is error prone. Any thing that should be remembered across sessions should be stored in the Session, otherwise pass the information as arguments. This will require you to create some helper types to hold data e.g. a Header class with two fields, restartToken and lastPackId. This does not apply to in and out, since they are used everywhere.
Move to a separate file? UploadPack.java is getting pretty big...
Define a string constant for this?
What happens to other client capabilities? Could make sense to have an explicit 'else', like } else { // Unrecognized capability. Ignore it. }
Should this get a trailing newline too?
catch NumberFormatException and throw PackProtocolException just in case?
Why isn't this changed to readString() which strips the LF?
bad rebase? I don't think rawLine is in scope here.
unrelated? Moving the enableCapabilities() call here looks like a good change but makes the change harder to follow.
This is really minor, but could you use Path api here? As it will return better error message than File will. giving some context on what is going on...
Could this relatively general code be reused in the needsOrderBy method?
in all these OseeArgumentException constructors, you don't need to use String.format, it does that for you.
I have seen cases where a Throwable will return this for getCause() which can cause infinite loops in code like this. I think you want:  java while (true) { Throwable cause = root.getCause(); if (cause == null || cause == root) { return root; } root = cause; }  as a result instead.
It's not public, it can be changed. We need to have it backward compatible for one minor version. If this is to be released as 3.9.4-c1, MC 3.9.x and MC 3.10.x needs to be able to work with this. You can add extra fields which we will use in an upcoming MC 3.10.x release. Removing the field needs to be delayed until HZ 3.11 where we can adjust the codebase to not expect the field.
Paths.get may be more appropriate here too
should we swap method parametrr orders above?
root would not change and I can't think why its access needs to be serialized with other methods so why does this need to be synchronized?
Could you add one more call after getFoo() to make sure it does not crash on a second invocation? Just to make sure and base on the original bug report.
You shouldn't use boxed primitives. Also, there is no need for variables here at all.
throw an exception? this is not intended to use.
Symmetry (throw)?
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
@fanifieiev the same above.
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
wont this be a breaking change removing the old api's if anyone is using CORE api directly? I appreciate its hidden for JMS users.
don't look like a good assertion. would be much better to check whether a release is returned
this can be replaced with your function
Use Local variable start time created on top instead of new Integer(0)
debug instead.
Here is also that unusual check.
Using a boolean as abort condition for the parsers main while loop is also a deprecated pattern. Instead replace this line with outerloop: while(true) {.
Should use nextTag() and switch-case instead.
use labeled loop instead
Should use nextTag() and switch-case instead.
I don't like the density here. I would prefer if all arguments of the constructor are declared as local variables.
That's an ideal use case for a string switch-case. See (most) other providers for examples.
I'd prefer if this parser would follow the same idiom all other parsers use, i.e. break outerloop here.
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
confused about the value of this boolean
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
same as above... why not use simple if/else here?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Can make this into a singleton as we have with UNSET.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
why is this return null??
This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.
Strings would be better to be stored in a constant
I see this duplicated in a lot of tests, maybe we should put it in it's own utility function?
Hello~ The classes in jars in extensions directory are loaded by URLClassloader, but the KafkaProducer here use the appClassLoader to load classes in org.apache.kafka.common.config.ConfigDef parseType() and this lead to org.apache.kafka.common.config.ConfigException. That is the problem I got. I found some code in KafkaIndexTask, in method newConsumer() such as:  ClassLoader currCtxCl = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); // ignore some code ... }finally { Thread.currentThread().setContextClassLoader(currCtxCl); }  This can solve the my problem. May I ask have you encounter this problem?
Should we assert a string valued parameter too?
No need to configure the deserializers since we inject them explicitly.
@adyach are these two properties used at all? As I understand they are overwritten in getKafkaConsumerProperties. I ask this because I see that you changed it from StringDeserializer to ByteArrayDeserializer.
Are you asserting anything here? you could use the AssertionLogger (whatever the name that is)
Do these belong in the test base class? Maybe we can scope these to just the relevant test classes? idk, i'm kinda 50/50 on this. It does mean that we're not testing with this config disabled, which probably isn't good. I think you can keep the refactor for topicsDir as a Map, but just disable the config options.
I don't think we need these (this connector doesn't require a license)
What's the advantage of loading the properties from the resource file instead of your previous approach?
Maybe relate those hardcoded strings to the enum above?
shouldn't be setDaemon(true)
Nit: I would like this broken up into multiple statements so we can tell where it breaks if we get an NPE.
Enclose in if (log.isInfoEnabled())
Can it be null?
Needs to shut down the scheduler.
nit: Use the variable record instead? Rename it to something that stresses that it's just a static value?
Will we ever hit firstPollOffsetStrategy == EARLIEST case here ?
Perhaps it's reasonable in this case to let preferredReadReplica use assignedStateOrNull?
IIRC nc needs to be 0 padded to 8 digits. Which is what I was trying to do with 8.8x.
ACCESS_CONSENT_ATTR and INST_ACCESS_CONSENT_ATTR are defined in both SamlConstants and NhincConstants. Remove from NhincConstants.
Consider to use StringUtils.hasLength(str) to check
rename the method to createResourceIdAttributeStatements
why not just return it directly?
Consider to move into constant variable into SAMLConstant
Two stylistic suggestions to consider here: 1. Changing to "wrapEvidence" would follow the normal verb-/action-based method naming convention. 2. "Wrapper" in a class name would usually go last, not first; e.g., org.apache.wss4j.common.saml.**SamlAssertionWrapper**
why is it adding null?
recommend to use CollectionUtil
Ideally, we'd use the Time#milliseconds() here instead of System.currentTimeMillis(), but you'd have to pass the time instance in through configure. It would aid in testability, but it's not strictly necessary. I'll leave it to you.
Suggest retaining [] brakets
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Why going for semantic here ??
Should we handle StatusPart separately?
Please, respect surrounding code style (() {).
This should be object Id, and it would be different from StorageId if it's not root directory. Could you check it for sub-directory case?
Please use parent.is here!
Does this need to be public?
requireNonNull
Minor: you can decrease the visibility modifier for some methods here and change some methods to be static.
you should use a local variable instead of reallocating the argument, IMO.
Maybe not needed? We don't have to check if a target process definition exists in the source container.
are we not covering this when we do the merge?
This could be written as if (!invoked)
This can be initialized to new ArrayList<>(plan.getEvaluatorsToAdd().size())
Typo, "by" should be "but".
this should also use the output of the util method. That way both the client and server behaviour are consistent in case we change the behaviour of the util later.
When is scan null?
generics
we should still use the hudsonUrlUtil. It was introduced to handle jobs in folders. If we need some behavioural change we should update HudsonUrlUtil
the size check is unecessary
nit: create static variable for this empty set and return that static variable
return Collections.emptyList();
Check that the RyaStatement and Config are not null.
Could be final?
Check that stmts is not null
Change to use Iterables.partition and return an Iterable
use static final instance of EVENT_CONVERTER
I would prefer to use same code as in method getProjectRelease  final Set<String> releaseIds = project.getReleaseIdToUsage().keySet(); for (string releaseId : releaseIds) { ...
That's why it was taking 2 seconds :) What happens in getTSMeta is that it will issue another GetRequest for the specified row. Instead, for this method, you want to override the scanner to fetch the META_QUALIFIER column instead of the COUNTER_QUALIFIER and then the scanner will return the meta data column. Then call TSMeta.parseFromColumn() to parse out the row.get(0).value(); and it will return the TSMeta object. This should be much closer to the 60ms you're looking for.
We shouldn't silently swallow this Exception. Maybe don't use a Java 8 lambda here since they're poor at handling throwing checked Exceptions. There are some workarounds for throwing an Exception but most of them aren't ideal.
ERR_DELETE_ERROR, add if there isn't one already
Possible NPE here in case of default constructor. Let's mark the 'log' field as 'final' and initialize it in default constructor.
Consider a streaming implementation: final Optional<List<Rule>> match = rules.entrySet().stream() .filter(e -> e.getKey().includes(length)) .map(Map.Entry::getValue) .findFirst(); return match.isPresent() ? match.get() : null; Not much clearer, but any time I can avoid declaring Map.Entry<A, B> that's reason enough.
Are we sure that we can never have e.getValue() == null ?
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
Error extends RuntimeException, this is unnecessary overhead.
This can be a bit cleaner with Java8 streams: return getPluginProviderRegistry().entrySet().stream().collect( Collectors.toMap( Entry::getKey, e -> e.getValue().createLocalFileIngestPlugin(e.getValue().createOptionsInstances())));
What about caching the list? AFAIK this method will be called multiple times on the same connection.
java subList.stream() .map(timings -> timings.getObject().get()) .filter(Objects::nonNull) .limit(10) .forEach(obj -> sender.sendMessage(buildTrackString(sender, obj)));  Much neater, right?
This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.
Out of interest why can you not do DecisionTableOrientation.values()?
At present, we try to avoid use of the keyword final as per our [POLICIES](<LINK_0>
map - confusing name
Does it actually fail if the expansion path is not recognized? In a normal situation I know it fails silently, returning the query results as nothing happened, so it wouldn't fail. But as it's wrapped in this VrapRequestDecorator maybe it's checking it against the RAML specification?
@katmatt i'm not sure you are right person to ask, but at least you could refer me someone else. My question is: don't we want to update assertJ dependency from currently used _3.3.0_ to the latest _3.8.0_, it is 1.5 years since that version and now it has a lot of handy tools, like arrays comparing (including ordered or unordered).
When you changed the code to also provide the old API, you should be able to revert these changes.
instanceof
instanceof
instanceof
Why is this exposed to the things implementing PushingAsyncDataInput? I guess to make implementation easier? I mean, there should be no reason for StreamTaskNetworkInput or StreamTaskSourceInput to call output.endOutput(), as the runtime can do it for them and it can only lead to bugs if the method is called prematurely. Maybe there is an easy way to hide it from the emitNext()? Like splitting into two separate interfaces?
in what scenario path list will be empty with copy error set to true ?
This is File copy error not file system retry case.
switch them. checking boolean is faster than checking isMaster
should be tied in to the FileSystem instance lifecycle too: an FS instance should really have a weak ref to all leases created under it, and fs.close to stop them all
Peter B. said in different commit <LINK_0> that this exception is not thrown for jdbc.query and you said he is right. So there is probably the same problem in every method with jdbc.query.
Same error issue. I'd just fail rather than return a partial list.
use srcPath instead
Shall check if CM path exist and if not, shall throw the error/exception as in base code.
I'd log the whole error and not just the message
In what scenario, fileInfoList can be empty?
No need to log here: return binary.getLong();
We try to avoid returning null to express absence. Could this method be refactored to return an Optional<URI>?
What about l < Integer.MIN_VALUE?
I prefer ", not "+(l == null ? null : l.getClass()));
do we want to assertFieldCountEquals here?
Does this mean assertParcelSane?
Style-nit: You can just return Collections.unmodifiableList ... here and avoid assignment back to l.
"must be of the format"
- why postSetUp isn't called from applyInlineDeployments - should we use pushInlineDeployments here ? - use of deployContrib with a test contribution
Make a variable name less verbose, that's not like you Cookie
no need to specify type on RHS
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
Or maybe:  for(String s : mc) { managedCache.add(getNewMBeanProxy(mbsc.getSecond(), MANAGED_CACHE + s, ManagedCacheMBean.class)); }
Local variable could be declared List instead of ArrayList. Is this worth caching?
My apologies, I realised that when option type is recipient, the key used is the recipient email rather than recipient name. Hence we can't sort them here (in generateOptionPointsMapping), as it would be sorting by the recipient email rather than the recipient name.
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
we dont need this variable, we can use _unavailableSegments in line 110 right?
for (Instructor instructor: instructors) { should do the trick.
Add server name in the log
check to make sure notificationUUID is not null
This should check to make sure that notificationUUID is not null before attempting to delete it.
It doesn't look like you are doing anything with the bucket here. This can be removed.
Minor typo in first sentence of error message.
Missing final
Presumably the method getAllGroupsSize in KeycloakUtil was written so that it could be used here?
I believe that this should be final
too bad we don't have a feign Response assertj class, right? this would look much nicer chained. (ps if you feel like it, make one, else no biggie)
Missing final
why retry?
static
nit: might be clearer as: return involvedTables.stream().anyMatch(this::isValidationNecessary)
Was thinking about collisions here, <LINK_0>, theres about ~1% probability of collision in 10k tables, but we are fine I think (except for the large internal product that is creating and truncating tables). We can take a 16 character substring?
Could we change the message to something like - "Can only read from a table with a no/conservative sweep strategy in a read only transaction." ?
This seems like a good behavior change, though it might affect our big internal product. Especially when serializable transactions are in the mix, we should not allow reads during the commit step.
need to pass the startTime into this method from compactInternally as logTimeAndTable will get a startTime only when the logger is called.
The way you wrote this, this will never return null.
now I see why this is do-not-merge :)
I'd be happy to push this down into doRun beside the logging saying we're starting. This is where the actual sweep work is done and means the start and stop on the StopWatch match up at either end of a single method.
Let's delete the old versions, since a future delete would clean up the lower case version and the stale versions would become visible again.
Agh code duplication! But I don't see a simple way around it. I was thinking about some fancy Java 8 streaming thing, but it's not trivial.
Two TimeAndDims might have dims of different length so I think this could cause an out of bounds array access on that.dims[i]. This also doesn't check types at all but the Comparator for sorted facts does check types. The equals impl could do return dimsComparator.compare(this, that) == 0 although this does some needless name lookups.
Did you mean --i?
IMO it's more obvious what is happening to put for (int i = 1; i <= 4; i++) {
suggestion if (castSource.toLowerCase().startsWith(clobReturningFunctions[i])) {
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
It might be better to use IntelliJ generated equals and hashCode methods which are more straight forward and depends on ByteBuffer.equals(): java @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; DefaultUdtValue that = (DefaultUdtValue) o; return Objects.equals(type, that.type) && Arrays.equals(values, that.values); } @Override public int hashCode() { int result = Objects.hash(type); result = 31 * result + Arrays.hashCode(values); return result; }
Do we need to adapt the behaviour of CompositeValue#hashCode because of this? In another words, can it happen that compareTo returns 0 but equals returns false?
This method looks horrible to me (and to whoever is a sane engineer, I should think).
Nit: can you add braces, even if there is only one statement? That's part of the Google style guide that we adhere to.
Seems like there's a spacing issue here, two spaces instead of 4.
Normally, a 'validate' method should return true in case of success, and false if validation failed.
I'm probably missing something, but it seems like this is part of the next case (isn't queue.size() >= 0 an invariant?). Is this called out just to emphasize that setting 0 => "no queuing"?
if static, should be initialized outside the ctor.. maybe make it final static.
This seems wrong
this.
Could be suggestion return !selectedBaseResources.isEmpty();
Can we use !mResponses .isEmpty()?
aren't these throw declarations wrong now?
I would add some logs here to be able to identify which entitlements and for which enum were parameterezied.
do the comparison the other way around
JDBC
there is an 'n' missing at the end of 'pattern'.
"PasswordController.NewLicenseKey" ->"LicenseKeyController.NewLicenseKey" is better
vmIsDown() == true than vmIsUnlocked() == true vmIsDown() == false than vmIsUnlocked() will not be checked.
/s/verifyShareableDisksMoving/validateShareableNotMovedToGluserDomain() regardless i think that this check should reside in validateDestStorage() method
This validation should be in LiveMigrateVmDisksCommand since in this command we only move disks that their VMs are down (checkCanBeMoveInVm should verify this). LiveMigrateVmDisksCommand is the command that is responsible to move the disks inside a running VM
Why using String instead of a boolean ? getPreferenceStore().getBoolean(..)
Should this be compared with || instead of &&?
Might this field connectClientTsApiFolder  ever be a null? it's created in CTOR and has a final.
Because it can be called by both focusGained and mouseEnter, sometimes you have two active contexts. Maybe there should be only one?
<LINK_0> Let me know if you have any issues managing or adding items to the project
This seems like something the client would want access to, "request a new full page of cards".
Rename into addEditLink, as that is what's added.
Should other contracts should be singletons, too? If so, could you create a separate pull request that makes that change?
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
"Clean orphans from PROPERTIES" to be exact ?
minor: key_type instead of key type
This looks like it's just for card payments so don't think we should add these her.e
this migration becomes useless since analysis_uuid can be null
You don't need this line because of green 31.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
why was this done?
During rebase, just pass a new ArrayList() to IsVmfree no need for variable
I would move the value-provider to the outside of the loop. Then we make the type check only once.  java final java.util.Map<K, Collection<V>> javaMap = new java.util.HashMap<>(); final Supplier<Collection<V>> javaContainerSupplier; if (containerType == SEQ) { javaContainerSupplier = java.util.ArrayList::new; } else if (containerType == SET) { javaContainerSupplier = java.util.HashSet::new; } else if (containerType == SORTED_SET) { javaContainerSupplier = java.util.TreeSet::new; } else { throw new IllegalStateException("Unknown ContainerType: " + containerType); } for (Tuple2<K, V> t : this) { javaMap.computeIfAbsent(t._1, k -> javaContainerSupplier.get()).add(t._2); } return javaMap;  Don't know if the throw is possible there or if the compiler will complain that javaContainerSupplier is uninitialized. If so, we could create a private method getJavaContainerSupplier()...
good call, this can save a double copy! :)
this method should be changed to private
please import java.util instead of explicitly writing here
Can you elaborate what's being done here? a list containing the same elements of getImages() is created which seems wrong . all the disks in that list are assigned with the same storageDomains list, which is wrong as well, all of them are with the same list so changing the domains of one will affect the other. perhaps i missed the point,,can you explain this method?
you could change this to an switch instead, as ContainerType is an enum and maybe extract to separate method, to get rid of break statements, e.g.:  java @Override public java.util.Map<K, Collection<V>> toJavaMap() { final java.util.Map<K, Collection<V>> javaMap = new java.util.HashMap<>(); final Supplier<Collection<V>> supplier = getJavaContainerSupplier(); for (Tuple2<K, V> t : this) { javaMap.computeIfAbsent(t._1, k -> supplier.get()).add(t._2); } return javaMap; } private Supplier<Collection<V>> getJavaContainerSupplier() { switch (containerType) { case SEQ: return java.util.ArrayList::new; case SET: return java.util.HashSet::new; case SORTED_SET: return java.util.TreeSet::new; default: throw new IllegalStateException("Unknown ContainerType: " + containerType); } }  edit, or even better, the enum could be extended with a supplier parameter
Yes, polymorphism is what you want. instanceof generally is a last-resort kind of solution. Here you're in charge of the design so you can easily avoid it by adding another level to your hierarchy.
Please keep this.cell near the related fields (previousFamily & cell count) below
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
have a default constructor with reasonable default values
the default should be made a constant somewhere instead of being defined in multiple places
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
for all the "waiting" items, I think we need to add "resource" otherwise people will ask "why am I waiting after I was queued".
This seems ill adviced, same reason why it was ill adviced to do this in the constructor.
The responsebody annotation can be removed, because the class is annotated with RestController. suggestion public Promise<CodeSystems> searchByGet(final CodeSystemRestSearch params) {
I'm almost tending to use VRaptor specific exceptions for this case, instead of reusing IllegalArg and IllegalState... We're doing this only because of validations, right? We could create a ValidationFailedException.
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
Should this use a parameterized message? java logger.warning("Connection exception encountered: {}", exception);  Right now this will likely log the exception message twice.
nit: not sure why this method called generateSendFailure. Should this be renamed to handleSendFailure?
I don't see you overriding this in your Bounded implementation, why make this protected?
A test would be nice too.
The final was there so that the user can't override the method.
Thinking about it, this method can be protected and final.
Who told you to do this? We still want the localized message for these exceptions
this.redisTemplate
Nit-pick for the variable name. It is really not file, so just entry would be good. The new HashMap() is bad code too. Must be with generics
Should add the rule to config file?
We have a removeConfiguration so let's not allow null value here?
space
Class and constructor can be package-private as only used internally.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
Possible NPE here unless I am mistaken -- there may be no defaultValue.
Avoiding to nest the for loop inside the if would make it more readable:  java if (labels == null) { returns names; } for (Map.Entry<String, String> label : labels.entrySet()) { ... }
do not use + +
can't be null?
Hi, I am currently evaluating exception aggregation tools and so far bugsnag seems to be the most promising for my needs. Especially with a logback extension, which is why I am following your pull request. Here at this line you might consider making the initialization of the UncaughtExceptionHandler, which is implicitly done through the constructor, configurable. In my use-case for example I am running a centralised logging server which is reading log events from sockets and writing them to files as well as to an exception aggregation tool. In this context a global exception handler may not be wanted/needed.
Isn't it enough to declare Exception here? An exception will fail the test, regardless of the specific type.
Maybe IOException since it's supported here?
You have to run this thread before the call to sever.serve() because that method is blocking.
Same here, using a process containing a user task would allow to check the variable valued after the connector execution.
There is jenkins.util.Timer.get() for these sorts of things, I'm debating with myself if that one can handle once a second... It probably would I think.
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
I think a !is missing in the second condition
Why the sub string ?
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Can we change this to LOGGER.INFO
You might want to not over-complicate it and keep the toString of the Optional perhaps?
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Why do we print a secret systemUserPassword here?
This is missing maxTotalRows
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Seemed better before? More readable
This filter lead to me to look at the factory again and ask about why/where the exception would be thrown! It seems strange that a factory could NOT return a concrete object.
filter(Objects::nonNull)
this.
You can use CollectionUtils.toImmutableList
Can be deleted since apis was used by ViewEnhancer.
I would use the enum constant: Could maybe also work with bibEntry.getType().equals(LIBRARY_ENTRY) as well suggestion .filter(bibEntry -> bibEntry.getType().getName().equals(LIBRARY_ENTRY.getName()))
This looks suspicious: call to Optional.get without .ifPresent. You can avoid having those misleading Optional-s, if you replace .collect(groupingBy(...)) with .collect(toMap(SortExpressionContext::getSortExpression, c->c, SortExpressionExtractor::merge).
Use toImmutableList
this optional access is without the isPresent check. I looks like Success result is internally "protected" by using a nullable optional. Is it possible to reach this point with a Faiure?
It may be clearer to check if a string is empty using .isEmpty() instead of "".equals()
Should this be String.valueOf or is cnn the way to go?
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
ConfigurationImpl_toString = Node configuration: {0}\nEdge configuration: {1} MessageFormat.format(Messages.ConfigurationImpl_toString, nodeConfiguration, edgeConfiguration);
Something to think about: if all of the DataModel types have a specific view type, then you could add an additional generic parameter to MockChartDataModel for the view type in addition to the dataset. This would allow you to move the view field up to the superclass.
this part should be factored out because it is used in several overrides.
Create a constant.
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
is to possible to catch some Exception sub-type? I mean some ParserException..
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
ErrorCallback to close "busy indicator."
I think pNode.getClass() doesn't have to be in the loop, you can move to above and return empty is the condition is true
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
I would suggest moving pNode.getClass() == PointNode.class before the for loop
Why going for semantic here ??
!(parent instanceof MGenericStack) || parent.getSelectedElement() == part
Please, respect surrounding code style (() {).
Do it also work with requestLayout() which is an asynchronous layout call?
why not reusing the isNonEmptyTextNode() method? It seems to me that you can simplify this part quite a lot: java if (isNonEmptyTextNode(parent.getPreviousSibling())) { return false; }
Please rename to getDownstreamNodes
This doesn't check that the IIFE is an expr-result. Does that matter, or do you want to do this optimization for all iifes?
See above about checking the labels
See above about checking the labels
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
I am not following here - why do we want this in sync block?
I'm almost certain that this is intrinsically checked by the tracker since things are only captured for spawning if the spawn events are being listened to.
Style nitpick: Lists.newArrayList() instead of new ArrayList<>()
Why didn't the sharedLock used in here but did used in addNextEvent?
Why synchronised here? The previous code already synchronized and also checked if it is ready and the queue is empty.
Not quite convinced about the method name...
Nit: final.
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
nit: we don't do this (argument alignment) throughout the project, any reason to start with this method?
Yeah, here's where I was thinking of using our custom exceptions. IdpResponse.fromError(...)
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
Is there any purpose to remove temporary workspaces on shutdown if you do it on boostrap? It looks like they should removed either on shutdown or on bootstrap.
You should be able to genericize this so you don't have to cast the return value
I would prefer to fail (throw RuntimeException).
Sorry, but as I said we still don't understand why its better to hide the error. As far as I know only a rooted device or an OTA which contained a bad apns-conf.xml could contain a malformed file. And adding this code will only make it more likely that the problem will be undetected. I could see a solution where a dialog or notification was added to this code, but that seems like more effort than its worth. Can you present a case where this would help a normal user?
Message not strictly true if isReadOnly was true. Why do we not need to also handle isReadOnly in start, above?
This is strange, I don't think we can get constraint violation for relationships when setting a property? When removing I guess we could violate a existence constraint, but that's anyway not checked until commit. In general it feels like here are way more catch clauses than necessary...
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
what about setting db isolation level to serialization?
Shouldn't have printStackTrace() in production code switch to logging.
We should set connection and socket timeouts here. By default there are no timeouts, so in case of network problems this may hang forever, which is pretty long. ;-)
The duplicate close looks strange to me. I think @rmetzger gave a nice idea above. You can just catch and log the error and move each close in a separate try block. You can take org.apache.flink.connector.hbase.sink.HBaseSinkFunction#close as an example. That will be much clean.
Why was this removed?
Add final keyword.
So I should also remove parameter 'log' and 'debug'?
wait 15 seconds to match the code?
conditional could be clearer here.
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Please replace that 1 by a constant indicating what it is.
final
why rewind?
I know this code was just moved from elsewhere, but is 10 meaningful here ? Although harmless, it seems like random over-allocation by half. Is there any way possible this can use more than the max possible # of bytes in an ITF8 encoding for an int, which is 5?. Can this use the new MAX_BYTES constant ?
nit: you can merge both lines above as checkNotNull will return the given argument
Use buffer.remaining() when allocating the copy buffer. Set bb.position(0) and don't touch bb.limit().
Add Preconditions.checkArgument checks to verify that the passed buffer is not null and that sessionProposedCapacity is greater than zero.
it looks like we're releasing it twice here. release calls allocator.release as well.
ordinal?
Make this a typed exception (e.g. PlatformServicesException)
Remove stack traces
can you change this method to call your new method instead? Make sure to pass 5 seconds as the timeout to not change the meaning of this function.
Log the full exception here as well, this should be fixed in entire PR.
Does the JSONObject type need to be fully qualified here?
log with a message
:ant: multicast is one word.
if there is unhandled exception it will cause that opengrok will need to be restarted, isn't it better to check for Exception or Throwable?
trace?
aren't fqans strings as well?
Why does this need to be ordered by the synthetic primary key?
Possible copy/paste bug in the order by clause.
Lists obtained from a message are immutable. No need for extra copying.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Shouldn't this close the iterator before returning the list?
Style issue: @Override shuld be on line above the method declaration
Why is it a list of lists, not just a list?
ImmutableList.copyOf each of them?
If this situation happen, I need to know some information to be able to investigate why. For this reason, I would add at least Audit event to the log.
Could you add generic types for all of these?
Was seconds an intentional omission here?
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
Creating new instances of SimpleDateFormat is expensive. Formatting dates using that is expensive too. Can't make it static because it's not thread safe either. Consider using a static instance of org.joda.time.format.DateTimeFormatter instead.
make it a static method?
This is one of the points we should use Zulu Time, but do use the configured default Timezone.
Why this change here?
it would also be important to be able to specify a Locale
1000 is a magic number. Please extract to constant or use Duration to transform the time
maybe use clusterName.pid to not conflict with instances from other nodes?
Hash code
Can an ArrayValue ever equal something which is not another array and thus an instance of SequenceValue? I would assume that this row always returns false.
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
This is another one that might cause problems. @lbergelson you've done a lot of refactoring to pull interval/region-like methods out into a single class; do you see changing Interval.equals() to not accept subclasses?
we don't need to check other == null here, the next condition check covers it.
what is the logic behind this, i am not sure why a non instance of MapLookupExtractorFactory will replace MapLookupExtractorFactory
what's the point of replacing with null ? that will raise NPEs for no reasons
This line appears to be prone to NPE in case the name is null (initial objects state). We'd better use Objects.equals.
Good catch. Should be the same for initCond on the next line. It's a bit unnerving that this is not a compile-time error :( EDIT -- I checked with a structural search: Objects.equals($o1$, $o2$) with a constraint on o2's expression type java\.util\.Optional. This is the only occurrence.
nit: please break a line.
Please store these values in a static variable, such as ASSISTANT_USERNAME :smile:
I would rather rewrite the assert to check the full URL or to chack whether the URL contains the name. Just removing the check is a bit hackish
@mcivantos-tribalyte _successCallback_ has changed in another commit, you need to update this to: _(WorkspaceProject project) -> successCallback.execute(project)_
The list will be filled with all models which had to be registered. These should be unregistered once you no longer need them.
unsubscribe()
if you compare against the ID of the view rather than the instance you don't need to maintain the fields
What if an exception other than InvalidOrganizationalUnitNameException is thrown? Would use of CommandDrivenErrorCallback not be better, so you can report invalid OU _file_ names separately to, for example, a NPE or other unexpected exception?
.record on the same line please
I'm pretty sure we use IllegalArgumentException for these everywhere else.
unnecessary line break
no need to create a set here..
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
again - encapsulation
I don't think we need to check for null here. We can just have Precondition.checkNotNull, since none of the instances where this is called would have a null query.
Remove this check after merging #139 to develop and synchronizing this PR with develop.
I think there is a concurrency issue. Multiple threads can insert the same query in this line and DefaultOperatorChainImpl 145 line.
Since this is not really activity related, I think we should have this in the ViewModel. We shouldn't really need to clear the adapter and manually handle the empty view. This creates an inconsistency between the view and view model. If the search will go through, we should remove the current data in the view model and post an update and let the observer pattern do its thing. I've already made a suggestion about how to handle the empty view previously. There is an example of this which starts [here](<LINK_0>
Suggest having this error message mention the time condition property, so that users who encounter it know that the problem is with their query and not an internal server error. e.g. "requireTimeCondition is enabled, all queries must include a filter condition on the __time column."
Why completely remove the implementation of sanitizeURL?
Maybe it's just me, but I would find a simple if-else clause more readable.
this part looks similiar to #validateAuthenticationState consider extracting the common code into a shared method
Could call the method addCookie(String domain,....) instead.
return immediately, no need to store it in a local var
Surely this can be done better using streaming cookies.stream.filter(cookie != null && CommonHelper.equals...).findFirst() This will return an Optional directly, or empty.
What's the reason of removing the null checking?
Does it make sense here to overwrite cookies with same name (i.e. check using name if already in list and overwrite rather than allowing multiple cookies with the same name)?
See above, I don't think None is a possible value over the wire, only in the storage model.
please remove this addition logging lines
Why the block?
fail
same as others: log should have Exception as arg
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
Either catch NPE only or add Exceptions.propagateIfFatal.
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
should be thrown, the others as well
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
Peter B. said in different commit <LINK_0> that this exception is not thrown for jdbc.query and you said he is right. So there is probably the same problem in every method with jdbc.query.
Same error issue. I'd just fail rather than return a partial list.
All of those continue statements are redundant.
null or empty list?
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
ahh, here it is
UnsupportedOperationException would be better
getRecords() is marked as @NotNull, and then returns null here. Something like throwing an UnsupportedOperationException would be better/clearer too.
no Multimap please
As far as I understand, we can get rid of explicit type parameters is such calls
this noopSubscription seems used in many places, create a single one and reuse?
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
it's a good place to use diamond operator and drop the type.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Can this be private (or at least package protected)? It's only used by this class.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
I'd put notEmpty there
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Preferably have one call the other?
Please add curly bracers here. Also please check other places, because I saw it also on more other places. You could use IDEA formatting highlights for that.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Can this be private (or at least package protected)? It's only used by this class.
Preferably have one call the other?
I'd put notEmpty there
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Please add curly bracers here. Also please check other places, because I saw it also on more other places. You could use IDEA formatting highlights for that.
can you pull this from a static string?
This looks like a good candidate for doing ImmutableMap.of(Maps.transformEntries(...)).
please apply formatting
This can be a bit cleaner with Java8 streams: return getPluginProviderRegistry().entrySet().stream().collect( Collectors.toMap( Entry::getKey, e -> e.getValue().createLocalFileIngestPlugin(e.getValue().createOptionsInstances())));
Should this result in all active connections being discarded? During runtime this may happen if the configuration is cleared by the config admin. disclaimer: I have only moderate knowledge about OSGi and this is more of an assumption.
please extract as constant
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
Is this really needed? I mean I believe the idea here was that getProperties returns an unmodifiable map, while getMutableProperies returns the actual mutable map. Is there a problem with this?
We deserve at least a DEBUG log here.
can be simplier: showing empty array even if the value is null is not really a big deal imo. Also, toString are usually only used for logger..
you don't need this. the "+" operator does this for you.
since host_name can be ugly fqdn or ip i think it would be nice to print vds_name as well
We should use StringBuilder here.
String.valueOf(...)? Or TBH, I'm pretty sure the compiler does this for you if you just inline everything like so: java return "PageKey{" + "StartAfter=" + mStartAfter.getId() + ", EndBefore=" + mEndBefore.getId() + '}';
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
Arrays.toString already returns "null" if you pass null
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
There is no need to do check for null, right? I mean you could just write something like return "SslSession(alpn=" + alpn +...
recordCount++; doesn't work?
grammar nit: 1, not one, and no :
I would really like to optimize, but having another sorted data structure would cost more than just having iterative approach
Synchronisation could be avoided in this method using computeIfAbsent and AtomicInteger, but not sure if it is worth changing at this point because I don't know the performance impact that full synchronisation is having.
Here you could use Guava's [checkArgument](<LINK_0>,%20java.lang.Object%29)
space between ) and {
You can use checkArgument here, same as <LINK_0>
Same as for outgoing, I think this augment will also include loops.
Is this going to be correct if there is a loop added in the transaction as well? I'm suspecting Direction.OUTGOING is the graphdb semantics which should include loops.
can this else block be avoided by having line no 88 as while (count < offset and count < recordCount)?
Should use StatusHandler.log() instead
:astonished:
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
throw exception
With Timber exceptions are the first argument. Format string arguments go at the end.
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
We should at least log those exceptions.
reopen -> open
same as others: log should have Exception as arg
Checking a non-checked (RuntimeException) usually requires a special reason. What is the special reason here for checking NPE?
Could you check for null or empty? Via StringUtils.isBlank
Oh please, no! Don't ship a null object! :cry:
Symmetry (throw)?
can these parameters be grouped into smaller and more meaningful objects?
Same here: The new flag withAttempts is not passed (used) the paymentProcessor#getAccountPayments
![MAJOR](<LINK_0> 'Severity: MAJOR') Constructor has 12 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
Do we want to have null maps here? Can't we follow the same pattern and default to empty ones?
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
this is the spotbugs issue, you're building a new object but not assigning it anywhere
.parallelStream() does not make sense here. I think it needs to be sequential and all in the same transaction. The memory dataset does not support parallel updates. At best, it'll just get queued on the lock. But then error messages are going to be random order.
rm 99
Constant
IMO, urlInitialized check here is redundant. I"m not sure how can you get to this point with urlInitialized=false. (And if it is false- don't you want to return?)
simplify this
rlly nit-picky: would turn that around from: is our location precise and do we actually have one to do we have a location and is it precise
get(). (Btw since inner is plain, this check may end up hoisted and you'd never see it turning null).
Does the mod check need to be here too?
Fix your formatter settings please or disable it :wink:
no public
Nit: Private method can be made static so therefore probably should since it makes lack of side effects clear.
Same concern here. true looks wrong.
mapping may be null at this point
Only 'wrapTextFlag' is needed
This should check whether the current contentType is an instance of the target content type, using isKindOf or looking at the baseType too. See FilePropertyTester for instance.
this seems too limiting IMO. could be any kind of local ip or host and still work perfectly. The only known issue is NPE when no matching server/proxy and the openshift redirect. I say we keep this patch simple and fix just the NPE - ssh redirect issue can be known limitation.
Why PrimitivesTypes ? We have a problem on Metaclass, so it should be something like : if(((View)model).getElement() instance of Class){ Class clazz = model.getElement; if(clazz.isMetaclass()[ }
May be you do not need another submonitor conversion here?
We have to have a submonitor in case we need to pass it to #getTopLevelFoldersForChildren. I can avoid it by if'ing larger amount of code and create a submonitor only if we are dealing with Branch.
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
Is there a way to set up the unit test where the config is already deleted instead of needed a @VisibleForTesting method? configDeleted is an internal detail of the ContentDirectoryMonitor. If somebody changed the implementation, these unit tests would need to be re-written, right?
i would split this line into two for better readability. also gameUser.getAchievements() could be puted to variable
put call of this method to appropriate place in each method that requires it
why not null as value?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
throws TaskException is part of the interface, did you mean to remove it?
This could be null, we should probably handle this if the JIRA api changes again
- log warning that option is not supported by SNMP
Don't we have to say that this is uniqueId JDBC?
Based on how it's used, it's more like a listener not callback.
unnecessary default implementation
@Serranya The same here. See above.
@Serranya The same here. See above.
@Serranya Please, add the name "body content" into the message to be more clear and specific. It's too much generic.
@Serranya The same here. See above.
@Serranya Please, use Cactoos' TempFile instead of this method.
The bytes can only be cached if the backing buffer isn't reused. If it is reused, then the backing buffer might change and cachedBytes could be stale.
add requireNonNull for bytes
what classes are we accounting for with isAssignableFrom?
As Kai already stated the mime type should not be optional.
Both JDK client and Netty client have to do the same logic for converting response byte array to string. It would be better to put this in Core utils somewhere to reduce duplication and if there are any fixes or updates to this logic, we don't need to update in two places.
2xx
@mavrk I think you mixed tabs and whitespaces in the description.setConcept(this) line. in OpenMRS we use tabs. Please remove your whitespaces.
don't need the else here. Too bad java doesn't have XOR :)
Can you convert this into using a ternary operator?  this.diagnosticsLogs = stdOut ? new DiagnosticsStdout(this) : new DiagnosticsLogFile(this);  It makes the code less verbose.
warn seems too relaxing for this kind of exception. maybe error?
why are the throws on the next line?
This looks like a help string that really is intended to go to stdout
Won't fix.
The generic type is somehow unrelated.
"Connection acquired time" -> "Connection acquire time"
You should use ThreadContext.putAll() here.
minor, is it method scope for Visible For Testing? If not please change it to private.
Unnecessary (and incompatible); revert.
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
Replace by Map<String, String> result = new HashMap<>(map.size());
Like below: putAll instead of loop.
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
why not null as value?
why not try with?
I think it might be easier to create a list and compare that?
Actually this should fail, because the input isn't a list of strings, and the type of "properties" is "String[]".
This could use Collections.singletonList
As for the previous tests, the two assetions above can be removed I think. But I'm happy to open a new issue for that if you prefer That applies for all the other tests below as well
Hmm you're right, there's not a great way to do this. Up to you, feel free to do nothing but a couple suggestions a. A quick google search revealed: @FixMethodOrder(MethodSorters.NAME_ASCENDING) b. a variant on your first example @test public void testResetA() { checkOrSetInstance(); } @test public void testResetB() { checkOrSetInstance(); } public void checkOrSetInstance(() { if (sShadow != null) { sShadow = getAccessibilityManagerInstance(); } else { assertNotEquals(sShadow, getAccessibilityManagerInstance()); } }
At present, we try to avoid use of the keyword final as per our [POLICIES](<LINK_0>
Using Collections.singletonList() is slightly more efficient as long as the result doesn't need to be modified, which is true here and and for getDescription()
Can we inject this feature directly ?
That's true It's fine then.
Haven't executed it myself, and am curious about rs.getInt(1). How can int be equal to String in this (test) case?
same as above... why not use simple if/else here?
"No provider is registered for the service '" + service.getName() + "'", service" (this is the current errore message). Shouldn't this thrown a ProvisioningException ?
Same issue here. We should keep this as static if at all possible
I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Please remove an excessive space character.
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
I think it makes sense to use builder and return ImmutableSet...
Make this final and since we know how many tasks we're dealing with, make sure we're creating a list with the right capacity.
Not sure is worth doing this change.
For readability sake, can these two increments use the same atomic method call?
similarly here, if this is general, I've lost updates...
computeIfAbsent?
check done
not thread safe
And this too?
Cool attempt! :+1: One could reduce some redundancy here as the processing of the key and the value is identical.
You are missing some variables here. I wonder if we should make a common method for configuring these so if we add any more 'with' methods that they can just invoke the proper method instead of adding each of these lines.
I admit to also being confused by what happens in that catch block. But I believe the change you made does change the return of that method, so I think you need to replace return v; with returned installed.get() ? null : v; to preserve behaviour.
Why doing this only in one branch? What happens otherwise if expiry or evictions were triggered by the logic?
You can inject the header variable in this class too, to avoid dealing with static methods.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
suggestion
This could be set in the constructor instead of checking this on every request.
To remove?
no need for these manual checks.
Don't use TABs in your code. Please replace all of them with 4 spaces.
You will never get a cache hit with "boundary" as equals() still checks parameters being equal. Maybe just not cache at all if there is a "boundary"?
this duplicates code with RequestUtils and RequestMetadataInterceptor , we could extract this out by creating some method that takes HttpServletRequest as a parameter, returns a Map, then add the info where it is required
I think this exception should be propagated?
Immutable?
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
format as final String[] array. Rename to errorMessage if possible
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
This LinkedList looks redundant. We could parse the words and directly put them in the words array.
Move to a helper function?
Suggest retaining [] brakets
for (final Point point : cluster.getClusteredPoints())
do we really need this catch block ?
Please use networkClusters instead of getNetworkClusterList().getItems()
Both of these lines should be moved into corresponding methods calculating the desired state according to the two dependencies, as I described in another file.
This should be done with field declaration example:  java private Set<String> users = new HashSet<>()
what guarantees getParameters().getNetworkId()) represents a real network ?
Should be the opposite, the other addTextFilter method should call this one, using a default of false for disableFiltersInputHelps
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
Why not IllegalArgumentException?
Avoiding to nest the for loop inside the if would make it more readable:  java if (labels == null) { returns names; } for (Map.Entry<String, String> label : labels.entrySet()) { ... }
What is the reason for calling toString() method as StringUtils.trim() already returns a String? I already pointed that out in <LINK_0>
so for IPv6 hosts when a machine is cloned this is going to break?
there is no need for using FQDN because only one Base64 is imported now
if that previews is showing cleaned-up code, why is this one still here?
This smells like an incompatible change.
This is invalid because it does not verify if rows vs range is in its default value. For instance, count(x) over (order by x RANGE between unbounded preceding and current row) returns different values depending on RANGE vs ROW
Why do we need to handle exception?
Agreed with Julian, we should not modify the agg call name which is a unique identifier of the function, better to add some distinct flag to the Aggregate digest instead: java public RelWriter explainTerms(RelWriter pw) { // We skip the "groups" element if it is a singleton of "group". super.explainTerms(pw) .item("group", groupSet) .itemIf("groups", groupSets, getGroupType() != Group.SIMPLE) .itemIf("aggs", aggCalls, pw.nest()); if (!pw.nest()) { for (Ord<AggregateCall> ord : Ord.zip(aggCalls)) { pw.item(Util.first(ord.e.name, "agg#" + ord.i), ord.e); } } return pw; }
Is there a reason for using stringbuffer instead of stringbuilder?
@sleshchenko looks like this class is changed by mistake
@sleshchenko looks like this class is changed by mistake
I continue to think that **aifc** should to be here...
Can use the already defined Constants
@Nadahar Right, text/vtt, i was too fast...my bad.
this method should probably be final. Also it is missing the @Override annotation AFAICT
Should maybe other countries be added here?
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
These arrays could be defined statically in this class, as to not create a new array every time this method is called.
Missing codes.
Consider returning a constant
we should have a test that involves multiple tokens (an input with a space) to properly test the position increments
SetConfigurationObject should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetActivityCalendar should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetAdministrativeStatus should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetAlarmNotifications should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
GetAdministrativeStatus should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
Service endpoint property is set in a parent class, so this can be removed.
I would suggest to put "526 Retrieve association objectlist bundle" in a parameter as following: private static final String TEST_CASE_XML_526 = "526 Retrieve association objectlist bundle";
asserttrue
asserttrue....
Is there a reason not to use Util.TOLERANCE?
doing += on a Long object causes boxing every time. It'd be better to have sum be a "long", and return Long.valueOf(sum) at the end. Or simply return a long in this method.
why sink->getSink()?
Can be static.
This looks more like average absolute deviation then variance, please rename or change the implementation
return Arrays.stream(executeBatch).sum();
Does this complete faster than early exiting with an if (b != 0) return false ?
But for this case, it will lose numbers under a decimal point.
It's bad form to create a new random object for each number. You should make it a private instance variable
There is no need to check argument length at this time, on the initialize method you can establish whether you have a sigil and proceed accordingly.
This could be null, we should probably handle this if the JIRA api changes again
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
return tags;
Could we return an empty map instead of null so this method doesn't have to be @Nullable?
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
This exception is likely to stay in for a long time, let's get a bit more specific (multi-catch may help you)
why not null as value?
As you suggested in your PR description, I think this should be a 400 error.
Can't we directly cast this into a map?
I don't see a test for this new method
Does it make sense to have this for a class that states it's "modified"?
Rename this local variable to gid as well, like the overall renaming you have done for lrecId.
Use SQLQuery#setString instead of StringEscapeUtils.
@essobedo once used variable can be inline
It is possible to write this and preserve types (e.g. avoid SuppressWarnings). I'm pretty sure it can also be written using generics (vs Object) but didn't have a chance to finish that.  public static Object[][] cartesianProduct(Object[][]... dataProviders) { List<List<List<Object>>> lists = Arrays.stream(dataProviders) .map(Main::nestedArraysToNestedLists) .collect(Collectors.toList()); final List<List<List<Object>>> product = Lists.cartesianProduct(lists); final List<List<Object>> mergeProduct = product.stream() .map(list -> { List<Object> result = new ArrayList<>(); list.forEach(result::addAll); return result; }).collect(Collectors.toList()); return nestedListsToNestedArrays(mergeProduct); } /** * @param dataProvider a nested Object array * @return an equivalent nested List */ public static<T> List<List<T>> nestedArraysToNestedLists(T[][] dataProvider) { return Arrays.stream(dataProvider) .map(Arrays::asList) .collect(Collectors.toList()); } /** * @param lists a nested List * @return an equivalent nested array */ public static Object[][] nestedListsToNestedArrays(List<List<Object>> lists) { return lists.stream().map(List::toArray).toArray(Object[][]::new); }
Concatenation of e.getMessage() is redundant
you lost the test to see if orderBy already has a prefix, this will end up breaking the measurements app, I know I utilize an order by with a prefix. This also lost the test for null orderBy.
use ALIAS_TO_BEAN
The logic looks fragile when the partitionRecords is empty. For all -1 cases, we add one more dummy record to the array being checked, or just remove the last element from the derived array so that we could maintain the same verification.
More accurate error message
Perhaps put the or else in the parameters. More useable  FpKit.findfirst(list, x -> isGood(x), otherwiseThis)  Could be a supplier to make it lazy  FpKit.findfirst(list, x -> isGood(x), () -> otherwiseThis)
Style issue: @Override shuld be on line above the method declaration
null? why not just a () -> {} ?
Why is it a list of lists, not just a list?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Generic type not used, remove.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
I know it's trivial, but would be much nicer if this mapping was extracted to a separate function.
the HashMap declaration doesn't need to be parameterized, HashMap<> would be sufficient. Same with terms and depts
would this be called often, and would the list copy be expensive?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Collections.emptyList()
this is unused.
File
defensive copy?
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
I think you may be able to .put the added PartitionData into sessionPartitions up front, and capture the value returned by the .put, as it will return the previous value. If the previous value was null, then we add to added, if it was not null we add it to altered. This will save us the additional containsKey check.
I understand you're trying to emphasize the connection between the two methods, but calling this onPartitionsAssigned feels a little confusing in this class; on ConsumerRebalanceListener it is intended to convey some subscription/notification semantics that do not apply here. The same applies to onPartitionsRevoked and onRecordsReceived.
nit: not from this patch, but topicPartitionBookkeeper.topicPartitionBookkeeping is really annoying. Maybe we could rename the field to just partitions?
nit: we could use putIfAbsent here
This doesn't seem right. lastAckedSequence(topicPartition) may exist.
Could be simplified as: hasUnresolvedSequence(topicPartition) && sequence == this.partitionsWithUnresolvedSequences.get(topicPartition)
Does this method need to be synchronized?
In this method, you call validCheckpointableTopics three times, once directly and twice within validCheckpointableOffsets. Wouldn't it make sense to call it once in the beginning and passing the result into validCheckpointableOffsets?
What happens when this returns null?
Add check that non-null
is it at all possible to use standard URI building things here? Either hadoop FS path building or the java File and Path constructs?
The forbidden apis check is flagging an error here: > [ERROR] Forbidden method invocation: java.lang.String#matches(java.lang.String) [Use startsWith(), endsWith(), contains(), or compile and cache a Pattern explicitly] The regex also looks more complicated than necessary and is causing test failures: <LINK_0>  [ERROR] testIsTaskCurrent[numThreads = 1](org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest) Time elapsed: 0.142 s <<< ERROR! java.lang.IllegalArgumentException: dataSource cannot contain whitespace character. at com.google.common.base.Preconditions.checkArgument(Preconditions.java:125) at org.apache.druid.segment.indexing.DataSchema.validateDatasourceName(DataSchema.java:108) at org.apache.druid.segment.indexing.DataSchema.<init>(DataSchema.java:76) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.getDataSchema(KafkaSupervisorTest.java:3636) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.testIsTaskCurrent(KafkaSupervisorTest.java:3099)
suggestion LOG.error("Couldn't get datasource for myplaces");
why? let's format it properly, it was ok before. annotations and method definitions on different lines
ataSource.setUrl("jdbc:arjuna:");
Should we let the validation query be set as a parameter?
i think we should just always use a validation query
onCreate() is called one time on start up thus it's always null. If we got onCreate called second time then it's bug which must be fixed. At the end if here is redundant.
It looks like if the user provides the username, password and connectionURL in the dbcp config file as well in the runtime properties, the values from dbcp config file would be ignored. Is that the expected behavior?
if (realm != null) maybe - just to be safe.
Remove throws Exception
Is this really needed?
I don't think this is needed
Oh. I just saw this line. target1 and target are little weird. Maybe there are better names.
No need for this or the @RunTestInLooperTread. Just ending the test with the assert should be fine.
Any reason this is running in a seperate thread?
Are there tests checking this logic?
clientScope
Can we find a better name? I mean, when you read quickly, you can easily read it as a RealmObject.
final
Most callers are assuming that this method returns a non-null DBCollection, so there's no point in having this check.
Can we make ObjectMapper instance static final and reuse it instead of new instance for each execution?
Cluster name should be also included in equals(Object) and hashCode() checks. The client pool is using this configuration object as a map key.
As Ryan mentioned, you may not want to implement locks like this on static methods. I'm guessing he is checking mappers for null in order to instantiate them only once, as well as set their SimpleDateFormat. Someone else can chime in, but one easy and simple way, while keeping the methods static, is to implement the default constructor with no arguments, then call a new static void method from the constructor called something like setMappers(). Inside setMappers() is where you would instantiate the mapper1 and mapper2 ObjectMapper instances. Then you can get rid of the null checks on the mappers, and instead just return them from their respective static get() methods.
Why U don't want to consider id in equals and hashCode ?
Do we use IVdcQueryable somewhere in AAA?
... two non-equal objects can have the same hashCode! :(
return obj != null && getClass() == obj.getClass()
:bomb: this is not a solution. hashCode() can be equal for two different objects. Do it using the four fields.
minor: don't need this. qualifiers
String.format
I think this is unnecessary => "profile =" + this.profile is sufficient.
I don't think rendering a byte[] as a bunch of ints is useful, maybe omit this (or just include the length, perhaps).
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
channelId => channelName
Same as above for toString(): <LINK_0>
Can we make toString a little smarter and print out what's appropriate for weather or camera?
Guava has Objects.ToStringHelper() to make it nicer.
Can be replaced with this.constructLockKey()
bad name of method <LINK_0>
What's the thinking behind inverting values that are passed in?
we don't really use _ (underscore) prefx for any other variables. can you rename it to just 'e'
When this line throws new SQLException("Unsupported target SQL type: ..., it would be good to mention SQLType targetSqlType in the exc msg
Can you just read until you read less than 1024 bytes? It looks like you will call read again after reading less than 1024 bytes when there is nothing more to read.
hi, few notes - 1. we should take locks for all the commands in status different then ENDED_SUCCESFULLY/ENDED_WITH_FAILURE/NOT_STARTED/UNKNOWN (so basically - for commands that are during execution, i think that we should add boolean member or method to the enum for checking that so that it'll be maintainable when new enum values are added). 2.we should also filter out the commands not managed by ATM/COCO - those are the commands that their status is updated to ENDED_WITH_FAILURE in line 98. so this code needs to be after the update done in line 98.
i see a problem here- let's take a command with no async operations, for example - UpdateVmCommand. That command locks will be acquired here but never be released because it won't get to it endAction() method (as it doesn't has task or a callback). so we need to handle here commands with callbacks only, for regular commands there's no need to acquire the locks as there won't be any operations to perform after the reboot.
I assume we should also add filter(x -> !x.getCommandStatus().isCallbackNotified) because commands might fail during the endAction() and not reach END_SUCCESFULLY/ENDED_WITH_FAILURE statuses (but their locks will be released as part of the endAction()).
let's change to - .map(x -> retrieveCommand(x.getId())) .filter(Objects::nonNull) .forEach(CommandBase::reacquireLocks);
Date[] boolean[] Boolean[]
Add a message. Without it, you just get a NullPointerException with no message. ie. "'containerName' cannot be null." Same with another usages of this.
It is not public API so don't worry about changing that, but we should get @alzimmermsft and / or @jianghaolu to review this to ensure that our builders always have a serviceVersion API and not version or any other naming convention.
should this be pipeline.executor?
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
should this be else if?
lets change this to pipeline.hasLeaderID().
For consistency, can you move this between passport and http handlers (line 65) and change the method to addLast?
Same question as above
Planning on making the number of retries configurable?
should this be assigned to something? like orcaResponse?
Seems like the previous tests should also assert on the length?
No reason to save chars here. I would strongly prefer dynamic
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "enforceNotNullNorEmpty" a "static" method. [![rule](<LINK_2>](<LINK_0>
There should not be a need to set this to public. Perhaps private would be better.
... that way when accessing them from the class we won't need to use "this." for example fString = string vs this.string = string
It would be great to cover the util method with tests.
setText in both cases (null defaults to empty and the append is not required, is being called as set).
nit: style wants newline
Could you please add clear message for case when assert failed?
this can be static
I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
A create card payment request should always have a return URL, so I don't think this should return an optional
this.
This should be an Optional<...> on the member by convention instead of wrapping on access. I realize this is against IDEA advice.
I'm not convinced Optional will add value here.
this.
synchronized -- this class is thread-safe and guaranteed happens-before between producing value and consuming it
Could, technically, throw a mixin into net.minecraft.entity.passive.AbstractHorse#initHorseChest to set the carrier?
I am confused about this line. In the original, if isTestJSONEnabled() is true, it will use Optional.empty. Otherwise, it will use the stub. This holds true if it is in test mode. I think this can be made close to the original and more readable with this  if (isTestMode()) { return new RepoIO(Optional.of(new DummySource()), isTestJSONEnabled() ? Optional.empty() : Optional.of(new JSONStoreStub()), Optional.of(RepoStore.TEST_DIRECTORY)); } else { return new RepoIO(Optional.empty(), Optional.empty(), Optional.empty()); }  The above should be safe since if test json command line option is set to true, i.e. isTestJSONEnabled() is true, isTestMode() would return true. Hence if developer forgot to put test mode to true when testing json is set to true, the real JSONs will not be messed up.
fileNameBytes is interpreted according to platform encoding. Give it a StandardCharsets.UTF_8 to pin it down.
EndOfStreamException is never thrown in this method, as far as I can see.
unnecessary else clause can be removed
I think it is fine to keep it together since it is so tightly coupled and it is just one exception.
return HConstants.EMPTY_BYTE_ARRAY; ?
Can you change to static variable ?
Should we allow to provide int values bigger than 255 and less than 0? If no, we should throw an IllegalArgumentException when this happens.
whitespace
check state first (cheaper first)
To simplify the change, you could just modify the original code. Old: keyValue = record.getPartitionKey().isPresent() ? record.getPartitionKey().get().getBytes() : keyValue; New: keyValue = record.getPartitionKey().isPresent() ? record.getPartitionKey().get().getBytes() : null; Or you can set byte[] keyValue = null on line 100.
Checking for test mode is fine, but maybe we should do it when this method is called, rather than in here -- the environment it's run in doesn't seem like a concern of this class.
We do not consider the whole resource, but only the selected elements (and their descendants). It should read "The selected elements do not contain".
These 2 methods have some overlapping logic with methods getFeedSLAMissPendingAlerts and getSLAStatus of FeedSLAMonitoringService. Please reuse those methods, so that the API and this service are in sync.
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
just one thing here - please add try {} catch(Exception), with proper logging, as if you will throw any exception from scheduled code, no more jobs will be ever scheduled. just a precaution. otherwise jobs will stop running and we will never know it occurred
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
Extract notification to own method notify...
Repository should be a dependency inject it in the constructor
Extract notification to own method notify...
maybe throw in && mServiceConnection.isBound(), there are cases where the connection might die
And this change should be reverted as well.
Uses the varargs version
As we're down to one arg, just do:  return threadRecord.hashCode();
What is the reason for not including preferredHeight and preferredFps here? Looking at BitrateController#setVideoConstraints, I think it might fail to call update if the only thing that changed is the preferred height or FPS. Or is this on purpose?
can just be hash.hashcode()
replicaList is not null so I would have just used replicaList.hashCode(). This might allocate a wrapper array for varargs. Objects.hashCode() is the single arg version that won't allocate.
really minor, probably it can just return value to avoid integer boxing with Objects.hash or use Integer#hashCode.
not consistent with equals, also the use of ID should be avoided
Just don't override the method instead of hashing the hash.
not safe. what if ntCall changes?
This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though running == false. I think the only safe place to do the check is after creating the spliterator.
I'd use a different name, e.g. doStream
Missing types
We were going to avoid signatures like IgniteFunction<Stream<UpstreamEntry<K, V>>, Stream<UpstreamEntry<K, V>>>, right?
Missing types
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Can you please revert this file. It will cause bunch of conflicts with my changes.
staterReceiver.stop(), too?
Use ByRef.Boolean instead
The test should call put from at least 2 threads, to see that all the thread locals are cleared - not just the one in the thread calling stop.
Is this really sufficient to test your WCheckBoxWebElement? One check box is sufficient if it is exposed through a getter so the tests can set properties on it.
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
weight is missing from toString()
Add .omitNullValues() before the toString() call
"Clean orphans from PROPERTIES" to be exact ?
minor: key_type instead of key type
This looks like it's just for card payments so don't think we should add these her.e
Add new catalog options.
this migration becomes useless since analysis_uuid can be null
Should we really accept steps?
We should validate that's non-null (to fail sooner).
Why did we make this public?
Given that Void is imported in the file, is there any reason to use the package name prefix?
Which type would be assigned in this case?
you should name this thread and make it a daemon thread.
Should be switch (type)?
I believe calling this every time is equivalent to this on the factory .enable(SerializationFeature.INDENT_OUTPUT);
Then should we just use it to save the update items?
perhaps pass along the entire BaseIndexOptions to be more future-proof?
Perhaps we could use a constant for that or maybe give a way to set this name in some sort of configuration
This should return an immutable collection.
Should not this method create a copy of the set just as getStages()?
The keySet is a view... So, the caller could run into a CME using the returned Set it the Map changes. Wouldn't it be better to return a new set created by the content of the view set?
This keyset is mutable and changes to the keyset will cause changes in the underlying map. See if you need to return a copy?
Are all reads/writes to correlationIdToPutChunk done by the main loop? What other threads touch PutOperation?
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
Using something like ImmutableSet.copyOf(contentTypeToTemplateEngineMap.keySet()); would make sense imho...
Using something like ImmutableSet.copyOf(contentTypeToTemplateEngineMap.keySet()); would make sense imho...
I think this should be fieldSet, as there is existing fields method (that returns Iterator)?
Do we want to use the platform's default charset when we read this from the database? I suggest we use a fix encoding here like UTF-8? suggestion return new String(licenseResource.getBytes(java.nio.charset.StandardCharsets.UTF_8));
Let's append java checkNotNull(event);  as the first line. EventsShould should have a "nullability check" test case (see other Spine tests for a sample).
We can also skip the query if the resourceId is *
Please, use spaces before and after +.
Do we want to use the platform's default charset when we store this in the database? I suggest we use a fix encoding here like UTF-8? suggestion key.setBytes(licenseKey.getBytes(java.nio.charset.StandardCharsets.UTF_8));
Override
Why only for CompleteTaskCmd ?
minor: this not required anywhere.
Why do you have synchronized on an empty method?
As long as it is public, we should ensure both producerId and commandContext aren't nulls. I also assume we don't have a nullability check for the static methods of this class in tests.
If the code fails to close in, it will never try to close out
for such change. If the code fails to close in, it will never try to close out
Perhaps try-with-resources? And there are also tabs here that could be fixed.
Could this be a single try-with-resources block with two resources and a single statement in the body?
how is this related to ignoring non-accessibility of ~/.gitconfig ?
change
You only want to use closeQuietly() on an OutputStream when an exception already occurred. Otherwise you mask exceptions that happen during a close(). Those should be treated the same as exceptions during write() calls.
Here you can use Files.copy.
remoteSize is never read. If the line is remove, the function can be removed too since it's not used.
file is better name here.
I guess this will crash as well if getCompatibleOperatingSystems() returns null.
context.getClassLoader() can return null
suggestion return getChannel(context) != null;
can't you just use "scriptFile" instead of the second call to "huntForTheScriptFile"?
Don't open things up that don't have sufficient parameter validation, the @Nonnull is not enforced here because it was an internal method, so you'd need to add a Validate call here.
ObjectUtil.checkNotNull(tm, "tm"); See below.
I think this needs to happen in a finally block
Shouldn't this be: !script.getEdits().isEmpty() || !script.getPatchHeader().isEmpty() IOW, if we have an Edit, we want to show something in the side-by-side or unified view, *or* if we have a header, we need to show that because its a mode change and/or rename/copy information. Maybe this would make it easier to follow: final boolean hasEdit = !script.getEdits().isEmpty(); final boolean hasMeta = !script.getPatchHeader().isEmpty(); final boolean hasDifferences = hasEdit || hasMeta; final boolean pureMetaChange = !hasEdit && hasMeta;
Variable initialization can be closer to it's first usage.
Just stick the message in a static member of some class. :-) Since the message is unique for a given PatchSet.Id, store two things: The PatchSet.Id of the message, and the String of the message text. If the id matches the id of the file, you can reuse the string. If it doesn't match, you need to fetch it from the server, and then cache it. The static members are per browser tab/window, which will mean we can nicely cache the message for most browsing activity along a single change. When ChangeScreen loads, it should also set the message into the static field so its available to the files.
I keep seeing these checks everywhere that provider is not in SOCIAL_PROVIDERS. I think a positive assertion would be better. Like GENERIC_PROVIDERS.contaains(providerid)
Instead of relying on all the properties shouldn't we just rely on discoveryType? less confusion with if else logic and also while defining the descriptor.
Create a common function for checking the regex and compiling.
verify is probably more trendy
is  if((FIVE_PRIME_ADAPTER == null) != (THREE_PRIME_ADAPTER == null))  clearer/shorter?
I'd say the change in this line is a mistake solving conflicts, right?
Potentially break context or client out as a separate variable.
could use general regex? like split "," to get a map
ah, and this one breaks the file upload for posts i guess its depricated since you have the mediaList call?
If these logs are for the testing purpose, remove them. If they will be kept, let's merge them into one line. LOG.info(parallelise, container, runtimeConfig)
You need to check that conceptUuid is not null and blank
When do you ever use the above service? And if you do, is it more than once?
Can we remove these empty new lines?
How to do ensure that by requesting .getConceptNameTagByName(null) for should return null if No concept nameTag is found?
would it be better to throw an UnsupportedOperationException rather than return something that won't work?
@dilekamadushan please remove any change made to SchedulerUtil as @wluyima mentioned
This test is wrong, check that the expected exception gets thrown using the expected attribute of the @Test annotation
You should be testing ProgramWorkflowService and not the DAO
Alternatively, i think it should be okay for one to pass in a null locale and then in ConceptSaveHandler you set it to what is returned to Context.getLocale(), we could also add a constructor that only takes a actual description and the locale would still get set by the save handler
DEREncoder shouldn't be referenced from ASN1Encoder - the implementation of this method should just be moved to DEREncoder.
+ desc
...if you do not provide...
Missing NLS
Then we can use the name here to get a better description
_[...] on the JobManager_
Missing NLS
Missing NLS
suggestion return "Returns the type of o as a string ('string', 'date', 'number', 'array', or 'boolean'). The string 'error' is returned if the value can't be evaluated";  Now that the bug is fixed, can it ever return a Java class name? I'd be tempted to just pare this down to simply "Returns the type of o as a string."
The description is incorrect. Should be something along the lines of "clean up empty pubmed id entries"
Please name it "Shortest unique abbreviation".
I think this should be headers.get(name).
Map
just return "" instead of new String()
This part of the patch looks fine and can be merged, with the small correction mentioned below.
technically speaking... :) the user agent header value could be stored in a static field and not computed each time getDefaultHeaders() is called. I'm sure the performance difference is negligible, but I couldn't stop myself from mentioning it :)
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
You forgot this!
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
Instead of continuing, you can do the inverse of the if statement and add it then. It'll make the code more readable. You can replace all of the continues that way.
Should we do the same here ? I'm confused about what this function actually does
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
Put into constant.
Doesn't this now need a @SuppressWarnings("unchecked") ? I think there are a couple of other places just like this.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
This should never be true. The spread should be computed in this case. Actually, it should always have the length of 96.
If data is null then StringUtils.isBlank(data) will return true, so the null test is not needed.
Debugging artifact?
use Arrays.fill instead for loops
I realized that this is incorrect counting. Next thread can finish first before the first thread finishes. You need completedTaskCount as well as runningTaskCount
maybe worth adding an assertion to ensure its a boolean? Is this ensured somewhere else? otherwise it should throw an exception here.
Do we really want to move this from trace to debug?
As a nit, should have a null guard here.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
We don't need a wrapping if - it is redundant by the reason of a constant for a message.
WRT to the changed logging, shouldn't this method return a success indication (boolean), so the caller could at least log one error message that the server is not running / listen?
this should probably fail on receiving interrupt
You can clean the BlobStore via: java BlobStore blobStore = blobStoreContext.getBlobStore(); for (StorageMetadata metadata : blobStore.list()) { blobStore.deleteContainer(metadata.getName()); } blobStoreContext.close();
You're better off pokemon-catching these.
Need to use parameterized logging instead of string concatenation.
Do you need to decrement EVENTS_IN_MEMORY?
@apc999 This needs to be public or reflection will not work
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
I don't know much about how the serialization code works, but is this supposed to be a 1, instead of a unique serial? I'm guessing it doesn't matter because these factories will not be serialized.
can you explain why this change ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
should we have an "unsupported" status instead of successful? successful seems misleading to me.
Doesn't work as expected as this message is never displayed, whatever is the type of media.
This looks like it would have different behavior from what was there before. If this is based on the path, I'd expect needing to go through getFormFilePath (the method that builds database paths based on whether or not scoped storage is used).
Why don't we set the certificationstatuses filter of the searchRequest here? Then the DB could filter the results rather than having to put the logic in java below
No need to use ConcurrentMap.
YOu can remove the syncrhonized block.
I know this is pre-existing, but getQuery has a bunch of other usages that refers to the query text. I would rename one or the other.
is this the right check?
This is duplicated code
Why don't you use String.format?
Maybe it would be good to create a utility class for the client messages.
Move this method above, so that it's directly after killQuery. That will make it easier to read, since the long helper method will no longer be splitting them up.
Use MyriaApiException, which is a wrapper intended to simplify precisely this type of code.
Is this idempotent? PUT should be idempotent. What happens when we call failQuery for a query that's already failed?
Can this method return void instead? I feel it's a bit funny to return the same thing we just provided as input.
The most likely case of this if statement is the opposite I think.
Could do this.mode != mode instead of comparing the name.
I think this can be a bit cleaner by calling super.onCreateActionMode(), and not exposing getTag(), and then proceed to inflate the menu. (and remove the default inflating of the menu in super()). Or better yet, create an abstract method that asks for the resource-id of the menu to inflate.
mode can be null. You need to return null accordingly
I wouldn't object to it it seems to work our supported API levels. I think a generic originView() type method would very useful!
We ask the helper if we should do something and, if so, then use the helper to do that something. Does it make sense for the helper to have a onSupportActionModeStarted callback or is the only Activity we'd ever use it in?
Style-nit: Space after if
when calling jgit fetch --recurse-submodules origin without a value for --recurse-submodules (which is accepted by native git) this fails here with the error "fatal: Invalid recurse submodules mode: origin". Maybe that's a limitation of args4j. when I reverse the order jgit fetch origin --recurse-submodules I get "fatal: Option "--recurse-submodules" takes an operand" jgit fetch --recurse-submodules yes origin yields "fatal: Invalid recurse submodules mode: yes" The only working format seems to be the following: jgit fetch --recurse-submodules YES origin so it seems the detection needs to be made case insensitive. BranchRebaseMode has the same case-sensitivity problem. would be true, false also valid option values ?
Could simplify by handling the uninteresting case first: if (!prefs.syntaxHighlighting() || !Objects.equals(mode, getSelectedMode()) || !view.isAttached()) { return; } view.operation(
Why give relayType its own variable and rcIndex and rcIntern not? And is it safe to parse a String to an Int without a try / catch?
Not really that big of a deal, but a group matching seems safer. If for what ever reason this property changes to something like 11.0.0_02 this would return 0. Below is essentially what is used for determining the version for domains.  private static int getMajorJavaVersion() { int major = 8; String version = WildFlySecurityManager.getPropertyPrivileged("java.specification.version", null); if (version != null) { Matcher matcher = Pattern.compile("^(?:1\\.)?(\\d+)$").matcher(version); if (matcher.find()) { major = Integer.valueOf(matcher.group(1)); } } return major; }
@erimerturk let's rename this to ex
Please bring back switch statement. This could throw array index out of bounds exception
Let's have these conditions one below other:  if (parts.length != 2 || parts[0].trim() .isEmpty() || parts[1].trim() .isEmpty()) {
use parts[0].trim() and parts[1].trim() here
Good point
Can you call this maxIterations, as the actual number is rather determined by the termination criterion?
This is a main() so please leave as println().
We pass ordered flag to index definition here. At the same time, we know for sure that ordered bitmap indexes are not supported, and an exception is thrown from IndexImpl.createIndexStore afterwards. Does it make sense to throw an exception earlier? E.g. from IndexDefinition.tryParseBitmap or even MapIndexConfig.validateIndexAttribute, i.e. before the distributed operation is triggered?
style nit: we don't use braces around single line blocks
Code style: Always use curly brackets, and space after if.
Code style: Always use curly brackets, and space after if.
unused try catch block
empty function? also no qualifier (public,private)?
does this need to be implemented? For example, shutting down the EventLoopGroup?
Should you set the iis to null here so that it is immediately known that this is closed if you try to re-use it? I'm just concerend about someone using one of these and not realizing that it wasn't being used correctly.
you could just do setConfirmWindow(null); like above method
Style-nit: We avoid curly braces on single statements.
A variable with the same name as it's type - is this more Java 8 craziness I haven't seen before? :)
is DebugLogger.INSTANCE.w a sneaky way of calling the logger even when logging is disabled?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
This should be filled in as we know what the 7.0.0 API is. If by some chance we have to create a new API version for EAP 7.2, then we'd rename whatever's here to registerTransformersWildFly15.
I prefer short log messages for events. Would suggest to change it to  return itemName + " changed from " + oldItemState.toString() + " to " + itemState.toString() + " through " + memberName;
If we are defining the toString for ItemDefinition, could you please ensure name (by using method getName()) is the first of the properties shown?
Printing the query as keys will look something like: ... keys=[IndexQuery.ExistsPredicate[propertyKeyId=0]]. I think it is worth extracting the actual keys from the queries and only print those.
I like the standard auto-generated Intellj code a bit more...
keyDeserializer.getClass().getSimpleName() (same for value)
Should we just use a Set to store supportedGrains in the first place?
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Unnecessary blank lines after a method - let's remove all these to keep it slightly shorter
I think null is default
These tests don't seem to assert anything about their output.
I think null is default
nitpick. Maybe better to use StringUtils.isEmpty(value) ?
Not really related, but this reminds me that during a demo, it was a bit of a pain that we don't have the synonyms found and masterterm found column when not doing every "token" (I guess that word is actually wrong in some cases now). Would there be any drawbacks to always returning them?
Instead of calling "replaceAll" three times you could call it one time with a regex as (\\[|\\]|\\s).
Let's do return fDetailedLoad; even if it is always null for now
This array is the same for all cases, you can use a static final constant to avoid creating the same array multiple times.
With these changes, the test should fail as no exception is thrown anymore. The only reason this still passes is because there is no fail call before the catch block. Can you adapt the test to make sure it tests what was tested before?
I'm confused. Which of these catch clauses is the expected one?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Why do we need this change?
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
1. Shouldn't it be new RuntimeException(e.getCause()) ? 2. Does this handle if e is IgnoreTransactionRollbackException and e.getCause() is null?
Third time we do the same code, WDYT about adding a method to ClusterService or a helper to retrieve the duration from a given Framework property name? On 10.10 and 9.10, it could be on the ClusterLockHelper.
(fuzzy on java exception details, so bear with me...) Can the RunTimeException here have multiple causing exceptions? (or I guess, a stack of them...). common/src/main/java/org/candlepin/common/exceptions/mappers/CandlepinExceptionMapper.java iterates until getCause() is null
Note that all such else clauses are redundant. You're typing too much! :)
Nit: you shouldn't need the null check when using instanceof.
throw an assertion here, i should probably do that in my code as well
Can be checked on a running cluster: <LINK_0>
How come this is not a polling receiver? This polls messages from a queue right (ref:SQSTask.java)?
Any reason why this cant be unloaded?
fixen (in branch gammodes is the starting position een decorator)
Are these methods part of the upgrade?
why not protected, use only extended
Shouldn't this return true?
isn't this changing the default behavior?
final?
Constructors can call other constructors in Java, so this should also work:  this(name, signature, ImmutableList.of())
Is this necessary? We have the StructuralProbe mechanism in the parser. Could that be used instead? Structural probes have recordNewMethod(SInvokable method).
@vilchik-elena Why not make this constructor call the third one?
add requireNonNull for clazz
Can this be private, or is there another use case for default attribute outside the builder's call?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
scheduleTimes --> scheduleTime
null check?
This seems to be changed by accident. summarizeTaskInfo is boolean :D
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
In the plugin.xml, you said TmfTraceStub and now you make the check for CtfTmfTraceStub, that is not coherent (even though I think it will fail elegantly).
Shouldn't receive a RuntimeException anymore?
you can just return false here, even better : return trace instanceof TmfExperiment && super.canExecute(trace);
replace with true at the moment, discussed with Genevieve
This almost looks like code I wrote!
Iterables.any(trace.getEventAspects(), aspect -> aspect instanceof ITmfCounterAspect); ?
should we have an early exit if the trace is the same? I am asking, I don't know
this should go in .canExecute(ITmfTrace trace)
This check should be moved to setTrace() (overridden version which then calls super.setTrace()). Then getTrace() can be overridden in this class to always return a LttngKernelTrace.
Here you refuse trimming if any trace is non-trimmable, but later you get the subset of trimmable traces for the operation... Should it be allowed if at least one is trimmable? Then you could get away with !getValid().isEmpty()...
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Can this be private (or at least package protected)? It's only used by this class.
I see no reason for the setters to be public.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Preferably have one call the other?
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
They are mutually exclusive? Or is that a micro optimization?
Unknown file name and known line number? Should that be an error?
These error messages are already pretty good! I'm wondering whether we could store the character index for each token and emit it as part of the error message instead of the "token index". Thoughts?
suggestion assertThat(got).contains("Description");
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
This logic would be better: if element is an anchor, check for class, else check for attribute.
Same here, it should be false.
Please reduce arguments to only 'element'. Because first and second are valued of element.
Do we want a test case that you can create an element with any revision?
This is fault. I meant **change** this property to the extract-payload...
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
Will * <LINK_0> * <LINK_1> work as well?
Very minor nitpick: Using charAt might makes this a bit more readable: if (url.charAt(url.length() - 1) == '/')
You can create a constant to include the "http://" string and named as **HTTP_SCHEME** for instance.
It is recommended to put the method of parsing host and port into NetUtils.java.
It would be better to avoid casting here as it prevents class cast exception. Please rewrite first constructor instead.
Here I would follow another approach, you get a ZIP file, and you interested only in its content, the schemas data directory providers I described above are the ones responsible to provide the location to store them, we got a ZIP or a file, we clear the current schemas directory content and drop the ZIP output or file in it. When handling the ZIP file, it may happens that the user ZIP the schemas as root or a directory, we shoudl vouch for the two use cases: 1. we have a directory inside a ZIP, we use the directory content 2. we have files as root inside the directory, we use whatever is there
this.url = checkNotNull(url, "url");
I think this is an accidental duplicate check (checks the same thing twice, no modification in between).
Please, wrap lines at 120 characters so that they can be read in Github in a glance, without using the horizontal scrollbar.
We don't need to minus LOCAL_TZ offset for TimestampData, the millis is already an epoch milliseconds.
Do we need to handle BigDecimal as well?
Here also, comparison of value should look at similar types like long and doubles (checking for overflow)
When you extend the abstract class that you use here, you shouldn't need to override these methods. Is there some special reason for doing that? I worry that any new method addition will be forgotten here and would rather that we just used the abstract class'es methods.
index is passed in as an argument, but 0 is used in the add feature delta.
Use parameterized logging instead of string concatenation.
I assume this is a time value, let's indicate its units in the member and column name.
May cause NPE.
I don't think we need to initialize the refs array first, then fetch the correct one with catching the error (that should never be thrown) and at last evaluate -- if the error has been catched -- the null array... If you want to move the code outside of the try-block then you can keep the final and remove the initialization with the null array. Just add a return -1; to the catch block.
I know, this in theory cannot happen. However, if it does for whatever crazy circumstances, it's hard do find. So IMHO it can't hurt to log it anyway....
Would it make sense to add something this.caches.clear() to the stop ?
This empty implementation will override CordovaActivity.onXWalkReady. According to the doc, this seems a deprecated Activity replaced by CordovaActivity, so why we make it different here?
Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.
This doesn't need to be public it can be protected.
factory must close its cursor (which is closeable)
you should have here setSucceeded(true) IIRC.
No parameter in setter method?
Interesting wrapping style :)
maybe rename TRHEADS while you're in there
DEREncoder shouldn't be referenced from ASN1Encoder - the implementation of this method should just be moved to DEREncoder.
Preferably have one call the other?
You should not do this. The unsanitized name only presents problem when displaying as HTML, but not when storing in DB.
Should this return the AzureTable?
what else? any warning or exception should be there?
I see no reason for the setters to be public.
This thing does check the value for not being null. So the previous expression is redundant.
You don't need the new Integer, Java will autobox.
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
... remove the final modifier from the method. It will be easier for future tests.
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Synchronize on private lock. <LINK_0>
nit: name = tableName or this.name = name
Please get the current descriptor here. Once you have that, we need to create an array of modifications that need to occur. Those modifications need to be sent in a single RPC. There's a method in AbstractBigtableAdmin:  protected void modifyColumn(TableName tableName, String columnName, String modificationType, Modification... modifications)  Please use this method with an array of modifications. That will send a single RPC.
Why is the modifier private? We should set same modifiers to validateDatabaseName and validateTableNamet methods.
The Cassandra check should be before the postgres one as that limit is lower, to ensure that users are warned with the appropriate message.
all these methods can be private
Nit: the else is redundant since the if block above returns unconditionally
maybe throw SkipException instead. This could mislead as one may think that tests are passing so metastore supports that.
Could we consolidate these catch clauses? Or is HornetQException a RuntimeException?
should the message include "command _with options_:" + this.options ?
you're not logging the exception
Translate this RuntimeException message in English please
You don't need to save an ObjectReader; you can call readValue directly on the ObjectMapper.
log message is somewhat misleading, IMO
DITTO: suggestion Assert.state(object != null, "Mapper mapped the message to 'null'.");
When concatenating the log message it would better to pass every parameter into the Objects.... rather than concatenating the string which is inefficient.
more naming
This is unnecessary. I would rather we keep the history intact than bother about the order.
I see a problem with this error - user doesn't know where the expected type comes from (it is already added from other task).
The model value could be passed as a parameter to the validate method in order to create a single instance of ModelValidator and reuse it.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Update labels to go with method names. Alternately, call super.toString for super attributes
Why do we print a secret systemUserPassword here?
This is missing maxTotalRows
You might want to not over-complicate it and keep the toString of the Optional perhaps?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Seemed better before? More readable
Do a detection.  if (e instanceof RuntimeException) { throw (RuntimeException) e; } else { throw new RuntimeException(e) }
I would probably catch throwables, because ClassDefNotFoundError..
I tend to think that this should just return - I think it's totally reasonable that I as a user might first close the writers independently (they do implement closeable after all) and _then_ close the pool which is going to call these methods again.
Nit please alphabetise.
does this need to catch all exceptions?
Could refactor this to something like the following, this would reuse code in super class. java @Override CompletableFuture<Boolean> getMainOp(CommitData cd) { return super.getMainOp(cd).thenApply(b-> { Preconditions.checkArgument(b); //expect this to always be true.. was not sure about adding this but decided its good to make few assumptions about the super method cd.commitObserver.committed(); return true; }); }  I was trying to make this shorter by using thenRun() but the void return type threw me off.
Since v is not used/needed, could use thenRun here like .thenRun(() -> cd
You expect here get InfrastructureException but you won't get it here. Because this completable future is complete exceptionally [here](<LINK_0> And then as far as I understand firstFailed.join(); will throw CompletionException caused by InfrastructureException.
The interceptors must not try to access the TM transaction via the thread-local, only via the invocation context. So it's safe to suspend the TM transaction before calling invokeAsync.
Is it really images build? Or build or pull?
Is it the same as this?  java final StringBuilder sb = padding(element, length - back.length()).append(back);
it would be easier to understand, and way easier to see whats going wrong if something breaks, if youd also compile a expected and actual list and then compare them with arrayEquals
I think you can get rid of the first condition now, due to the change above.
You forgot your this.s.
typo "should", also "In case".
It seems you can remove the IOException now.
do we care to check the length to be positive here?
We need to check offset + length <= arr.length?
is length == 0 allowed? then it is expected to be "non-negative" not "positive"
Can you include the element type in the output message as well?
does this needs to also do a null check for payload before assigning a new reference ?
Instead, I think we should update AbfsOutputStream.close to wrap the exception, short of having the Java implementers fix this. :)
please create a more specific exception that extends this one.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
IOException comes from API signature, so there's nothing we can do there. You can add a release() with the LightblueException.
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
here you can get the token from the 'querystring' and issue an initial HELO message
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Why guava SettableFuture over java8 CompletableFuture?
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
please extract to a separate method
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
why this is in vmCommand? should be in stopBase command
isErrorIfHostDoesntExist => isNewHost
I think we can set them for all external systems (for xen it will just be null or empty) and then not to use them where they should not be used in the vdsbroker command as you did, no?
the storage pool should be set from the quota object, i don't see a reason to send it separately, apply also for update and remove
Could this repeated logic in message tasks & member-side map proxy be hidden within MapOperationProvider eg:  MapOperation createPutIfAbsentOperation(String name, Data dataKey, Data value, long ttl, long maxIdle) { if (ttl == DEFAULT_TTL) { return new PutIfAbsentOperation(..); } else { return new PutIfAbsentWithExpiryOperation(..); } }
did you verify that flow? I'm not sure if the cluster is set on the template we get in the parameters
Check for null value.
<LINK_0>
Why is list necessary? The number of elements is passed, so array may be allocated at the beginning, it is not necessary to rely on ArrayList to determine the final size of the array.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
This might be better as an array list. Faster iteration, and such.
final
You never used MAX_SPH?
typo
I think it might be cleaner to directly use bitLens and values here.
If you have a minute, I'd refactor this into a method (mergeIntegerArrays) simply because it would make the code mildly easier to read.
?useTopologyForLoadBalance=false
why the new line?
I understand that we still leak off of VerifyingChannelInterceptor in our Testing Framework, but you still can use a MockIntegration.mockMessageHandler() instead of logger in the main flow to verify an incoming message. WDYT?
When you changed the code to also provide the old API, you should be able to revert these changes.
@katmatt i'm not sure you are right person to ask, but at least you could refer me someone else. My question is: don't we want to update assertJ dependency from currently used _3.3.0_ to the latest _3.8.0_, it is 1.5 years since that version and now it has a lot of handy tools, like arrays comparing (including ordered or unordered).
EnvStopFailedEvent?
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
We don't need another ImmutableList.copyOf. You are doing this when parsing.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Name flag and the Set<String> consistently. Either both module or provide.
I'd rather toLowerCase() is applied after substring(), not before.
tmp must be a constant and we dont prevent nullpointerexception for filename.
It may be over thinking this but I got some errors when I tried to make a form name with spaces around the "/" e.g Form with / back slash where as Form with/back slash worked on the device. So maybe we can add another replaceAll() after the first one to replace any patterns like Form_with___back_slash?
you could replace this line with this()
Maybe instead java /** The filename without any compression extension, or the original filename. * It tests for compression types handled by {@link #openFileEx}. */ static public String filenameNoCompression(String filename) { if ( FilenameUtils.isExtension(filename, extensions) ) { return FilenameUtils.removeExtension(filename); } return filename; }  I believe we have commons-io already in the dependencies list. There's some extra check for null bytes in the extension check... but that's not so important. Just simpler I think.
Missed a space here between the ) and {
consider merging both lines
I don't think reusing the StringBuilder makes a big difference, but if you want to reuse it I'd call sb.setLength(0) rather than sb.delete() to clear it, since the latter ends up calling a native method.
> Alternatively, as we're concerned about usage of the image in a Wiki article, I think it makes sense to copy the wikicode for the "thumbnail" image rather than the wikicode for the full image. I agree with the thumbnail approach, pictures are almost always displayed as thumbnails in wiki articles AFAIK.
Please remove final keyword. JVM and our eyes are smart enough to detect these variables are constant for this amount of code.
Use MethodType.DERIVATIVE.getCode() and MethodType.MAINTENANCE.getCode()
could be static
devtype is not camelcased, also deviceType would be more descriptive.
I like this CAS operation, but it does not check whether the requested transition is valid or not, which is one of the most important motivation of using StateMachine I think. Also, there is checkAndSetState which is similar to this method, but throws RuntimeException when the given states do not match in the predefined legal transitions. What about allowing users to configure the StateMachine for the action to be taken when an invalid transition occurs? There could be two choices I can imagine for now: 1) Throw RuntimeException, 2) Proceed with leaving WARNING log message. We can introduce a boolean (e.g., failsOnIllegalTransition), and make it an argument of StateMachine.Builder. By changing the return type checkAndSetState() to boolean, and internal logic of it per the boolean field, we can have only one method while achieving the goals of both methods. How does it sound?
@dmzaytsev let's inline this
we never use NULL, it is a bad practice in general.
Idea: Since the goal afaik is to trim any string deserialized in JSON context, why not to call trim(super.deserialize(jp, ctx)); in case this super.deserialize evolves in the lib ?
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
We mix two different comparisons styles here: "expected".equals(actual) vs. actual.equals("expected"). I would prefer to use the first one only as it is NPE safe.
this is the spotbugs issue, you're building a new object but not assigning it anywhere
Space before {
SonarLint is going complain about String concat
Let's include the giver and recipient here too
Use Paths.get or non os specific separator
Use Paths.get or non os specific separator
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
Let's use a template path string like  String BASE_LINE = "/%s/something/%s"  Then the code here is cleaner.
Collapse the no-longer needed +.
can we use frameworks/base/core/java/android/os/Build.java#IS_USER
why not using ID_REGEX?
studentsWhoRespond -> studentsWhoResponded
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Expose Map if you can
nit, Collections.EMPTY_MAP?
Do these methods actually get used? If not, then maybe throw UnsupportedOperationException instead. Then, if someone tries to use them, there will quickly be an exception thrown.
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
again I think you can use the diamond operator
You can use the Diamond Operator here m_nodeToOnmsSnmpMap = new HashMap<>() instead; I'd opt here to invoke m_nodeToOnmsSnmpMap.clear() and initialize it in the constructor or directly.
I think this method can be private?
Ah, it's a Multi-API thing. There's probably a way to make this a nice aspect since it's in every call.
let's call it updateCodeMinings() instead.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
please move the isEmpty methods to the scimSchema
Does this code need to verify that the activeAwardAccounts collection is non-empty?
is it not empty if for example type is an valid empty string?
wouldn't it be enough that one of these is null?
This could be confusing here. How the user know the all fields?
can we improve this by giving some meaningful exception message ?
You have chose a policy=static for the reference, so it cannot be null.
The code above doesn't appear to be setting the budget total on the XML Award DTO.
We should avoid using Java8 for issues which could be backported in 2.4.
There is a duplicate implementation in PushTest. It's a good candidate for a test util function that can be imported statically.
It's pretty inefficient to create all these AclBinding instances, just to check for unknowns. Is it possible to avoid that?
suggestion return entry -> entry.getValue().stream().map(GameId::getId).anyMatch(gameId::equals);
Let's add the partitions parameter to the message as well and verify the expected partitions are revoked.
did you mean to make this change?
Did you check if here is any chance to share code with the warning generation?
I would suggest using a getter that auto-loads the eInvoice DAO if needed, similar to what you did for the lookup DAO in this class.
At this point where the code is detecting there is a problem, shouldn't it also be reporting specifics about the population that had the issue? IMHO, recording the identifiers of the items with the issue being checked for at the point where the problem happens. It hard to try to find that population or the conditions later on.
We already have the PeriodicDeltaChangeListener, which wraps calls to persister.delta. It handles queues, and does smart stuff like if you do a modify then a remove within the same time period, it will discard the modify and just do the remove. Should we try to reuse PeriodicDeltaChangeListener somehow, rather than having queueDelta here?
kind of curious what these magic numbers are
You're testing two completely separate features of the class: 1) closing of environment, 2) converting environment to string. There should be two separate test methods. This anti-pattern is sometimes called "Test it all" (<LINK_0>
@ilyakharlamov I think that this test won't run on windows, it fails on creating files on /dev/null
Perhaps ignorance on my part, but shouldn't env.hasTableId() be checked first? Can env.hasTableId() && env.hasScope()?
Sleeping here for a bit longer (50 in my setup) makes the 2nd issue (missing hasNext) fail more likely.
Please review - are you still using these: statsUpdateFrequencyMs and maxStatsAgeMs as you have code in GlobalCache that deals with this as well.
How expensive do we expect calls to the ExternalResourceDrivers to be? I'm just wondering because here we retrieve the ExternalResourceInfos for every task, independent of whether they need it or not. I think I would prefer that this feature would not add additional costs for tasks which don't want to use it.
At this point, the switch statement (here and in the other class) could be turned into a simple conditional: java if (env.getScope() == ChooserScope.TABLE) { return getVolumeChooserForTable(env); } return getVolumeChooserForScope(env);  This probably comes down to style also... both work fine, but the conditional is slightly shorter and probably easier to read, since the choice is binary.
Looks like coprocessorScanWorks will return true for any HBase version >= 0.98.6, and the earliest version we currently support is 1.3. Can we rid of the getTableFromSingletonPool calls?
The configuration is confusing it's similar to number of mutations but it's actually a timestamp. It can be something like INDEX_FAILURE_HANDLING_REBUILD_PERIOD?
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
I think we need to specify the locale Locale.ENGLISH for SimpleDateFormat, to avoid a default system locale. Example failing to parse (simulating a German system locale): new SimpleDateFormat("dd-MMM-yyyy", Locale.GERMANY).parse("1-May-1994");
There is a lot going on this one line.
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
is getLastSyncTime() guaranteed to return non-null?
calling value.source() can throw, so this will need split into two lines, variable initialization and retrieving the source-the latter of which is inside the try block
We should have an alias getSource() and deprecate source().
Can you use the dateTimeService instead?
Is not safer to use Locale.US instead of ENGLISH ?
There is no use for creating new util methods to create ProductData instances. You can create a ProductDataTranslatorTest instance and call initSourceObject() instead
Does this mean that new null handling unconditionally adds overhead in groupBy query processing?
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
Could use Double.BYTES
Short.BYTES
Should include tableName as part of hash code?
Got confused, does BP include flag and dcId?
I don't understand where it is actually used, I see only where getUsedFlagBufferCapacity (for bitset) and cardinalityWithMissingValue * recordSize (for records) space is used
I would throw an exception here if this is not a BaseGCMCipher since only such ciphers are expected to reach this code
this should be based on the version passed in to the writer. Yes, we use only version 2 now, but let us keep the versioning clean. It is there in the constructor, use it. It will help if we want to select a different version in the writer for whatever reason.
String.valueOf(stateValue)? There wouldn't be any null str, and no need for the if-then-else, just one line
This null check should be done in line 274
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
Looks like a null check on sourcePort is missing here because sourcePort is Integer and therefore can be null. If sourcePort is null then the comparison "== 0" will cause problems when trying to debox sourcePort to int. Just tried the following similar code and it crashed with NPE: Integer sourcePort = null; int x = (sourcePort == 0 ? null : sourcePort);
Use Integer#valueOf(int), or delegate the work to the method above, so we can benefit from Java's internal int cache.
This should contain the MTU as well.
Please use TimeUnit.MINUTES.toMillis(15)
what do you think about using org.apache.commons.lang3.builder.EqualsBuilder  return new EqualsBuilder().append(company, that.company).append(firstName, that.firstName)... same suggestion for future implementation of hashCode by using org.apache.commons.lang3.builder.HashCodeBuilder
61 is already used in line 1389. Suggest using 67
You should consider the isLocal property too.
Confused, why is the commit changing all field access to getters? The method has visibility of the fields and I see no late/lazy inizialization of them. This kind of change is likely going to be reverted next time someone uses a IDE code generator to update hashCode/equals
don't need optional, just use ImmutableSet.of(ports.get(getNodeType()) should work
Check if there is an appropriate constant for "no metakeys" mask.
nit: We can store this into a static final field TEST_PARTITION_INFO int this class.
Why not use null instead of ""?
How about introducing EventClass.emptySet() so that it's easier to find places where return empty sets?
inline
Would you also add an IS_NULL filter here?
Which tests fail if we don't have this line?
In current implementation, killed is printed out only when the session attempt has been done...?
this test is redundant; it is included in the test on L232 because that call test no filter as well as filter cases:  if (useSelectiveOrcReader) { assertFileContentsPresto(types, tempFile, expectedValues, orcEncoding, orcPredicate, Optional.empty()); for (Map<Integer, TupleDomainFilter> columnFilters : filters) { assertFileContentsPresto(types, tempFile, filterRows(types, expectedValues, columnFilters), orcEncoding, orcPredicate, Optional.of(columnFilters)); } return; }
This is basically a guaranteed crash right? To be avoided at all costs, it's just making future work. A toast and a fall back to the note editor or anything is better than throwing a RuntimeException if we can avoid it
nit: We should use UIUtils.showLongToast(). If it doesn't exist, we should make one.
Any reason for switching from using the PermissionsManager here?
line length
to nitpick: just use this instead of the application.
Excellent! Just add a Toast here and we are done
:P
Don't need last else
assertEquals(0, permissions.length)
Not sure, but profilesToActivate() may be too late for the foo(literal) => fooExpression conversion.
Lots of unnecessary this. qualifiers.
Recheck some of these please. In Java, all non-primitives are just references, so these lines will not be making deep copies unless you do something like .cpy() which you have done for relativePosition. width, height, relativeAngle and relativePosition will be deep copies with this code. texture, drawableLevel, and tint should all have clone() methods
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
This is a public API change. Does it need to be public? It would have to be reviewed with other language folks
Please change the line 38 to also use EnumMap<> for consistency.
copy to,cc,bcc fields which are List of objects in the copy constructor
please add check for null
Just a thought, will it be better if we make a getCopy method and make the copy-constructor private? Something like:  java public FeedbackQuestionAttributes getCopy() { return new FeedbackQuestionAttributes(this); } private FeedbackQuestionAttributes(FeedbackQuestionAttributes other) { // as per this method }
nit: use this on other assignments for consistency
4 spaces
The return statement can be simplified return (currentTime - lastHealthCheck) >= minInterval;
give some meaningful name to this thread.
I think the granularity should be 1 seconds instead of 5 seconds here.
This was mistakenly moved
This should not call Schedulers.computation() directly, but the Scheduler that was passed in, otherwise virtual time is not possible. This is currently the same as calling System.getTimeInMillis() directly since it is hardcoded to a particular Scheduler.
I don't think you need a line break here. 120ish chars is OK.
return getExpirationTimeStamp(0L)
I've always been slightly confused by this - is this only used for the pause before we start sweep? If so, it might be better to defined the backoff time you're adding completely separately from the definition here, unless it should always be 5x this one.
Should this be (currentTime > timestamp && currentTime - timestamp > threshold) The current check expires any timestamp after the currentTimeMillis() in the iterator. Seems like you are assuming that the times are synced perfectly between the server that wrote a mutation and the one this iterator is running on during scan/compaction.
14_000_000
getParent() can return null
this can be implemented with: decodeBucketIndex(EXTENDED_PREFIX_BITS, entry)?
This is the only place that add entry to the pool, is it the only way to fill the pool?
please use AsyncCountDownLatch here. Both handlers slaveConnectionPool, pubSubConnectionPool invoke countDown method and in latch callback we do rest logic.
Why not just catch "Exception"?
please do not add new line after = operator... should be: entry.enabled = EngineLocalConfig. no need for getInstance() in a loop... please store a reference.
I would have moved it to own function...
add name of the already loaded as file maybe null
if you added the new flag this was valid... I mean overriding the entry.enabled with the localconfig, as this is configuration.
line 378-389 can be simplified with the sync method, no?
Simple for-each?
I still don't understand why the key cannot be the session id
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
Note that all references to CoreRegistry.get(class) need to be replaced with either @In annotations (best idea) or context.get(class) codes (find-and-replace). You'll probably need an @In annotation to pull in a context.
For new API I'd prefer to return an java.util.Optional<T> instead of null to avoid potential NPEs.
This can be moved to the while condition to avoid unnecessary break.
Missing @ Override
Use Iterators.transform from Guava?
I see this method does something similar to execute minus the optional processing with the rowProcessor
....and then you don't need to call it on every other method
This check needs to be done in hasMore(), not nextRow(). hasMore() can block, nextRow technically cannot and just because there is another from hasMore() doesn't mean that it will be within the minTime.
this could also use the get treatment
getCells() can never be null
Could be cached, SingleIndexedInt.of() and cache 0-127 :)
I get a warning for this cast from Object
I don't think we need these last else if / else and simply return true. My reasoning is that when we get here, we can't tell much about the row so we should preserve it so it gets displayed.
I dont't like this code, if a question is not active then inside it should remove input error, seems this responsibility is of questionview not dynamictabadapter
Would be nice to circumvent the creation of the Text and go straight from String to byte[]. Same applies to the other Step interface methods.
We shouldn't synthesize the brand if there is a BRAND_IA_ID value, since we can create the brand using that ID. Update: ah that's contained in canParseBrandFromEpisode. I think, for clarity, it belongs in this method. Its functionality matches the method name then.
Why is the BatchAppenderatorDriver skipping the lineage check now? I thought it could still make more than one segment per interval if it's running in non-incremental-publishing mode.
Please close client at the end.
restore might fail with exception => client should be closed in finally block
I suggest to clean up the client in the same class where it is created - in the parent AbstractMessagingTestCase.
This is not necessary, the client is already created in the parent
Switch order and as well in other similar cases.
Is the administration.reloadIfRequired() necessary before deployment?. If not I suggest calling this method after the deployment.
Is restart necessary here? Even the check takes some time in the test run...
Are consecutive reloads necessary or will be one reload at the end sufficient?
Is the restart really necessary here? Try to run tests on fresh instance of server and the check if restart-required state is set.
Is the getManagementClient method used elsewhere? I can only see that it's used here, in which case please inline it.
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
Same issue with the change in visibility of this method as with JcrRepository.start().
newline
Could we reduce this to debug again (as in the current master)?
Enforce immutable and non-nullable lists. If this is a read-only object, not something users will build and send to ARM in a request, then avoid having nullable collections (the typical tags field of an object is a counter-example as we need to send it as null, so we enforce immutability but not its presence): java new AutoValue_Metric(data == null ? ImmutableList.of() : ImmutableList.copyOf(data), id, name, type, unit);  Apply this pattern to all lists in the new model classes.
Symmetry (throw)?
![MAJOR](<LINK_0> 'Severity: MAJOR') Constructor has 12 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
Please use AbstractInfinispanTest.testExecutor() in the tests, with the common pool it's impossible to filter logs by test.
Want to Polling.await here?
Just return data.
nit: you can merge both lines above as checkNotNull will return the given argument
@robbavey don't we have to release this ByteBuf after we've deserialized its contents?
Can we set a charset? Like ASCII or UTF8?
For data.length==0, is it possible to be an empty string?
Unreachable statement?
What's going on here? Why load the data into memory and then send it back as a stream? This should just return the InputStream returned by requests.get(attachmentURI). If you're having problems getting your test to pass with this way of doing things, we can look at what is going wrong.
Sorry, I was thinking of this:  java private void handleBadgeResetPN(Bundle data) { if (data == null || !data.containsKey(PUSH_ARG_NOTE_ID)) { // ignore the reset-badge PN if it's a global one return; } removeNotificationWithNoteIdFromSystemBar(this, data); //now that we cleared the specific notif, we can check and make any visual updates if (sActiveNotificationsMap.size() > 0) { rebuildAndUpdateNotificationsOnSystemBar(data); } EventBus.getDefault().post(new NotificationEvents.NotificationsChanged()); }
let's just rename everything related to SubTitle to SubText
Right, this should have been here already. It should also check for HTTPS_REMOTING.
Let's do return fDetailedLoad; even if it is always null for now
Don't need this - regionGuidePosts is either set in the other constructor or set in the readFields method.
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
IIRC, I use rawQuery with the same result like yours. Please check rawQuery API to simplify this function call...
use try with resources
Is it guaranteed that the first entry in the list will be the latest?
This array is the same for all cases, you can use a static final constant to avoid creating the same array multiple times.
List<...> rules = ...
Jacoco provider used to ensure that two classes with same name across different packages had appropriate coverage information posted to Phabricator. But now that we're stripping the path from the file name, that will be broken
monitoringId will be null if split fails
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
Let's rename "e" to "ignored" Please use fail() <LINK_0>
Let's rename "ignore" to "ignored" Please use fail() <LINK_0>
Let's rename "ignore" to "ignired" Let's replace "// igniore." with "// No-op."
Assert with counter. You could return it's value and assert you only get 1 and that a subsequent call gets 2
What does using a SwingWorker get us here as opposed to passing "true" to the Children.create() call below (which will cause the key creation to happen on a separate thread).
this does not assertion is this wanted?
make this one final maybe? there should never be a reason to override this
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
It may also be fine in a lot of situations to just cast it, since presumably nobody is actually trying to cast the returned Void value to a Void, so there should never actually be a bad cast at runtime. But, eh.
may be it is going to be more obvious to have dedicated variable for that? 'boolean predefinedSamplesCount' instead of 'totalSamplesRequested != -1' ?
Get it from the model now that we have one?
Fix the method name here please.
Since we get access to the Site here, it seems wasteful to throw it away, and then have to re-expose it through FeedCoordinatorBase. In all the other cards so far, the Site gets passed all the way through to the server request from here. Perhaps the same can be done for Random?
This could just be: return isFeatureEnabled(context, namespace, name, false); which makes it clearer that the 2 methods do the same thing with just a potential difference in the default.
What happened to this code in Settings.checkAndNoteChangeNetworkStateOperation? if (context.checkCallingOrSelfPermission(android.Manifest.permission.CHANGE_NETWORK_STATE) == PackageManager.PERMISSION_GRANTED) { return true; } An app with the CHANGE_NETWORK_STATE permission must be able to call requestNetwork without having WRITE_SETTINGS.
Wouldn't it be better to have a checked exception for this case?
last seen should be defaulted to lastBuilt
Ooops!!! Bug spotted Hint: discussionThread isn't the right object to use here.
Why do you need this here? Shouldn't it be done already when the payment system retrieves the plugin name (in PaymentAutomatonDAOHelper and/or in ProcessorBase)?
Same as above - log or throw the weird state.
We could probably use getItem() method here, for consistency.
Like, super.onFailedToRecycleView, this doesn't seem to do anything. Why call one super and not the other? Ditto for below?
Please create a new function dedicated to stopping shimmer for better code readability.
This makes me slightly nervous :P I'm sure it's not a problem, but maybe add some parens to delimit the order of ops?
Do these need to check itemToBind?
Maybe we should factor this duplicate code?
can we have 2 formatters: for current year and for past ones? we don't need year for current
This is really similar to updatePlusOne method. If we put the else statement to the method, they are the same.
please replace with TextUtils.isEmpty (i.e. instead of the static import that's there now)
To be safe, should check gerritTrigger.getJob() != null first.
job
Should we track additional information here, like what kind of trigger it is? What would the cardinality be of that? (e.g. is it a pipeline trigger, an internal trigger, etc)
StringUtils.isEmpty from apache.lang3 I think
I just realized when I checked the failing test that there are parentheses missing around the ternary operator, string concatenation has higher priority. So it should be: IllegalArgumentException("There is no start node that matches the trigger " + (trigger == null ? "none" : trigger));
Please change this to warn also. Thx.
can't dc be null??
You can replace this if clause with StringUtils.isEmpty() from apache.lang. Also please add a space before the opening (.
Quartz best practices state that all listener methods contain a try-catch and should handle ALL exceptions [1]. If something happens when committing the JobStatus, we violate this best practice and could potentially introduce issues. [1] <LINK_0>
I think this should be:  this.mode = trigger.getMode() != null ? trigger.getMode() : Mode.FIRING this.match = trigger.getMode() == Mode.FIRING ? trigger.getFiringMatch() : trigger.getAutoResolveMatch();
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
why do we use this. on getters but not on alpha? I would skip this. all together here and use getAlpha()
Wouldn't it be better to only show iterations OR epsilon?
Why not use slf4j format standard? log.info("Heartbeat exceeded for host '{}', last response arrived {} ms ago.", getHostname(), getHeartbeatTime();
prevWeather can be null here- it might be necessary to update the API to make initialWeather anOptional
Can we make toString a little smarter and print out what's appropriate for weather or camera?
Same as above for toString(): <LINK_0>
Guava has Objects.ToStringHelper() to make it nicer.
make them invisible on creation. if the minion is full level the buttons are shown for a brief moment before hiding them suggestion Button button = this.addButton(new Button(guiLeft + 225, guiTop + 43 + 26 * i, 20, 20, "+", (button) -> VampirismMod.dispatcher.sendToServer(new UpgradeMinionStatPacket(entity.getEntityId(), finalI)))); statButtons.add(button); button.visible = false;
Are these debug prints? Remove before merging
fileName seems a bit redundant - why not do this in a single line? File file = new File(baseDir + "/src/main/resources/bundles/AppErrors.properties");
can we use BeforeClass annotation?
please use method directly, you don't need to store it in variable
[JavascriptActions.scrollToBottom()](<LINK_0>
use js.execute(script).toString()
you can use .toString() instead of casting
Same as above, this looks like an error.
Just a suggestion: Objects#requireNonNull(Object, String)
So the algorithm here is: * if unencoded file exists, return it * if encoded file exists, return it * encode the filename if required * trim the filename and return the file Have I got that right?
pass the classloader as param
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
This should be a constant, not a magic string.
specify array length (based on codecs.size) to optimize. <LINK_0>
properly format the code (select text > right click > source > format)
Don't need last else
We probably need to be looking to get the mechanism error messages converted to ElytronMessages, this way instead of concatenating the values like this a formatted message can be used. Also an unavailable digest error message seems like something that could be used across mechanism implementations.
Fedora uses 4 levels of hashed containers for identifiers, does it just use 3 for file storage?
Not sure, but profilesToActivate() may be too late for the foo(literal) => fooExpression conversion.
The number of parameters is extremely large -- creating a brittle interface and difficult to comprehend client client. Please refactor to the Builder pattern.
throw exception
It should throw exception
Possibly more descriptive error message?
Do we really want to move this from trace to debug?
As a nit, should have a null guard here.
Wouldn't it be better to use an injected version of this?
well this could be changed as JDK will always be 8 or more.
In general I prefer readable Configuration settings. It helps with debugability. could this be serialized in JSON? there are examples in parquet-thrift.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
I don't know, but wouldn't it be better to let the Thread sleep for a short period if the service isn't available? Or will this block something? Don't know how long it normally takes until the service is available normally. Maybe it could also be interesting to set a maximum number of tries?
Geometry is comparable?
There's probably some edge cases where this isn't true. Consider the case where there's 1 discrete parameter to optimize, with possible values {A,B,C}. In this case, there's only 3 candidates - and the candidate generator should terminate once all 3 have been generated.
return defaultFilterFactorEnabled ?
"Called only after a call to prepareEntities" Might be worth adding a flag to enforce this; I'm guessing this could be unpleasant to debug if someone tried to manipulate entities before they were ready.
I'd say if the entry is present, the command is not successful.
Iterables.all(toolGroup.getTools(), Predicates.instanceof( AbstractToolDescription.class)); allow to return false if all items are not of type AbstractToolDescription
Shouldn't we do the validation that occurs in the run method here? It seems that at a minimum, we need to be sure that some folder path has been entered in the text field.
isCacheable is now true? I guess this was supposed to be false for generic extractors. Or am I wrong?
log and throw anti patttern
Another option would be to use  log.debug("This is the execution root? " + result) to replace the lines 532 to 539.
also check this
This represents a poor API. If you are not going to provide a working implementation for all versions, the newInstance method should be marked @Nullable and you should actually return null. This way callers explicitly have to write:  java if (mHighlighter != null) { mHighlighter.highlight(...) }  An alternative strategy is to add an isSupported method that NullHighlighter (prefer NoopHighlighter as well since null has no semantic context here) implements and returns false, then throws on all other methods, forcing callers to write:  java if (mHighlighter.isSupported()) { mHighlighter.highlight(...); }  The reason for being explicit is so that readers of the highlighting code can see plainly that it might not be supported and that would explain why it's not working for them on a naive/quick read of the source code. Forcing folks to dig all the way down into the implementation to see that possibility is frustrating.
static.
stopSelf() at this point might be problematic because the signaling facilities are asynchronous so the service might stop before the signaling facilities get a chance to unregister (send BYE and get back 200 OK) and unbind properly. What is the issue with keeping this in onCloseReply()?
This method can be simplified to  java if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { return SupportedAbiWrapper.getSupportedAbis(); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO) { return Abi2Wrapper.getAbi1andAbi2(); } return Build.CPU_ABI;  Also is it worth wrapping Build.CPU_ABI in an array so that the output format is always consistent regardless of API level?
Since we get access to the Site here, it seems wasteful to throw it away, and then have to re-expose it through FeedCoordinatorBase. In all the other cards so far, the Site gets passed all the way through to the server request from here. Perhaps the same can be done for Random?
Why do you need to set connectivity false here? is onCapabilitiesChanged not always called when a network is lost or becomes available?
Get it from the model now that we have one?
last seen should be defaulted to lastBuilt
We can use the @SdkSuppress(minSdkVersion = Build.VERSION_CODES.M) at the top of the ExtensionTest.
Assert.notNull(expiry,..) checking might make sense here
nit: line too long. final not required -- a static method cannot be overwritten anyway
how about we redirect to the non deprecated method? The only downside is that the closure cleaner will be applied on the AssignerWithPeriodicWatermarksAdapter.Strateg but I think its fine.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
As we discussed, the Hystrix cache command needs to have its own name and default properties including time out.
this feels like it violates the fluent workflow, is there a way to make this work inline with the fluent query runner?
So, technically, it is possible for a Sequence to get used more than once. Meaning that with this setup, we can actually get multiple decrement()s for a single increment(). We don't use them multiple times right now, but I think it would be better to be safe. In order to be safe, though, we have to do the increment on the Sequence.toYielder() call instead of here. This ends up introducing a delay in when the actual incremental happens, which is unfortunate, but I don't think it's the end of the world. I think we should move the increment into the toYielder() method of the ReferenceCountingSequence<>, and we also need to make the ReferenceCountingSegment thread-safe and aware of when it has been closed. Once it is closed, it should reject increment() calls (let's make it return a boolean and set it to false once it is closed, meaning that it is not safe to use the instance) and return null for all of the other methods that rely on the underlying buffers.
maybe we should have all query related metrics start with query? e.g. query/segment/time, query/cache/time to be more consistent between all the query metrics
This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.
we should not throw an exception here, simply ignore
![MAJOR](<LINK_0> Make "isExcluded" a "static" method. [![rule](<LINK_1>](<LINK_2>
Does the system property check influences the dataType too?
if injected 2 times, calling two times variable.symbol().metadata() is not efficient. Please use a dedicated intermediate variable.
The expression won't contain the field name.
For assignment statements, as I understand it we shouldn't raise on class attributes:  class MyClass: max = 42 # OK  I'd suggest looking at the first ancestor of the assignment which is either a FUNCDEF or a CLASS and avoid raising an issue in the case it's a class.
Same trouble: what about this.myField = "";
make static
return Optional.empty instead of null
@mariebawanan I think the proper fix for this is to remove the duplicates in variables VariableTypeList instead of just filtering out the duplicates here.
<LINK_0>
<LINK_0>
Why are you catching and ignoring? as above, if you catch, you should do something, if you wish to ignore an exception, please say so. Typically using the word "expected" as the variable name. <LINK_0>
Why is this using PROJECT_NUMBER? It's supposed to take both and our samples prefer PROJECT_ID.
You don't need this, but if you do keep it in it needs to set standardOutOrig before you call System.setOut - otherwise you are just getting a reference to the value you just set.
[ERROR] /tmpfs/src/github/java-docs-samples/iot/api-client/manager/src/test/java/com/example/cloud/iot/examples/ManagerIT.java:[75,18] error: no suitable constructor found for PrintStream(ByteArrayOutputStream,boolean,Charset) constructor PrintStream.PrintStream(boolean,OutputStream,Charset) is not applicable (argument mismatch; ByteArrayOutputStream cannot be converted to boolean) constructor PrintStream.PrintStream(boolean,Charset,OutputStream) is not applicable (argument mismatch; ByteArrayOutputStream cannot be converted to boolean) constructor PrintStream.PrintStream(OutputStream,boolean,String) is not applicable (argument mismatch; Charset cannot be converted to String)  Try setting StandardCharsets.UTF_8.name() instead.
It could be - can you create a short script to show the issue and open an issue against the repo that contains it?
bout is never closed here (I know it doesn't really matter but things like findbugs don't like that)
Does this take a long time to run? Is it worth pre-creating a lot of these setup steps in a DO_NOT_DELETE like company / tenant id that the tests can just access?
@pecko let's also assert it does not contain the other string.
Question: Should not we add braces to this statement?
throw exception
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
this just doesnt break anything right now because backpack is not handling user variables correctly. (so this is working because of another bug) since this delete method is also used by the backpack when one deletes a sprite in backpack, it tries to delete the same thing in the currently loaded project aswell.
You should be able to genericize this so you don't have to cast the return value
I've taken the other two patches, do you want to change this to implement the "fail fast" code above?
Is this supposed to be mId = null? mTitle is set in the next block
Sorry, but as I said we still don't understand why its better to hide the error. As far as I know only a rooted device or an OTA which contained a bad apns-conf.xml could contain a malformed file. And adding this code will only make it more likely that the problem will be undetected. I could see a solution where a dialog or notification was added to this code, but that seems like more effort than its worth. Can you present a case where this would help a normal user?
This is strange, I don't think we can get constraint violation for relationships when setting a property? When removing I guess we could violate a existence constraint, but that's anyway not checked until commit. In general it feels like here are way more catch clauses than necessary...
Whoops, this needs to be the other way round (the first block is for ExecutionException and the second is for InterruptedException)!
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
Make it a static method in ExecutionExceptions or similar class?
if (!(e instanceof ExecutionException) || e.getCause() == null) { return e; } Throwable cause = e.getCause(); return cause instanceof Exception ? (Exception) cause : new Exception(cause);  How about making return statement simpler?
Putting fetch inside get() might not be good. If this api blocks writer, writer can starve because fetch can really take a long time due to hole fills. If this api doesn't block writer, then the NoRollBackException issue will still occur quite often as this reader may override the writer's value with no undo record.
The class is HTTPServer
Extract this try-catch block to a method to avoid code duplication
Make this public since the class is public
Throwing an IllegalArgumentException could be confusing since it's not the arguments passed to the invoked method causing the problem. Maybe throw new InvokerInvocationException(ex) or  throw new InvokerInvocationException( new AccessControlException("Illegal access to method" + cachedMethod.getName(), ex) )
I haven't worked with futures much, but doesn't this exception get thrown on the main thread? I would think that Future.get(...) will interrupt the thread where the task is being run? I might be totally wrong though.
Please use curly braces for conditionals
equals and hashcode are only comparing stepNumber, which is half of the key. Should compare the Progress objects or their IDs too
:bomb: this is not a solution. hashCode() can be equal for two different objects. Do it using the four fields.
Can you add the curly brackets to the if calls.
Liran, Yevgeny, now that we're using hibernate and it creates a proxy for the entities, is there a need to enforce in the equals impl of methods "is instance of" or can we settle for getClass() comparison ?
Use Objects.equals() to handle nulls concisely.
Cluster name should be also included in equals(Object) and hashCode() checks. The client pool is using this configuration object as a map key.
Is this a good practice? Casting to an abstract class? it may be better to have an interface AccessControl and AbstractAccessControl then implements that interface... but that way you program against interfaces which seems cleaner to me.
since this is the vdsbroker, you should be able to use java.util.Objects.equals()
Instead of this, check if the String values are equal.
Could you add an assertion on one of the associated props? Just to be sure...
All these vars are used just once. Maybe just use the method call directly? i.e.  "<LINK_0>" + mUser.getAccountToken() + ....
Why the sub string ?
Does this not need a TypedQuery?
Remove new line.
this is redundant here.
unnecessary parenthesis?
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
As [mentioned](<LINK_0> in #408, this variable should be renamed to "args" to be more descriptive.
Good note. I think USER_PORTRAIT would be better so it works upside down too
Why are we configuring drawer in this activity. This activity shouldn't have it.
Are both of these lines required? I'd have expected we'd only need the attachBaseContext
Not required
I'm starting to question whether this is a good idea. Generally we shouldn't use it but I understand I left it in my previous PR. Will investigate.
suggestion ((WordPress) requireActivity().getApplication()).component().inject(this);  This getActivity() can be requireActivity().
This is considered a bad practice. You should only retain a fragment for a dialog that returns no view, so onCreateView should return null. Anyway you already use a DialogFragment (they don't leak on rotation), and RN in manifest also says that do not destroy the activity so you do not need this line.
The actual bug-fix: Use a style that inherits from AppCompat
These Overrides are generally on separate lines (I don't think our styles are set up correctly but check the rest of this file)
add message to log
What if client is null?
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
Do we really want to move this from trace to debug?
ClientConnectionException mean that there are issues with network connection. Please consider reconnect logic here.
Do we have to check this as well? if (IFuture.CURRENT.get().isCancelled()) { return; }
Why is the error message only about LifeCycleOperation? Why was ServerStoreOperations excluded?
It might be useful to extract 1, 2,3 as useful constants or enums to indicate what the code means.
ExchangeSecurityException would be better for 401
It should be continue else the message below would get logged. (Error in rerun consumer) ?
@apc999 This needs to be public or reflection will not work
This is already initialized by super class.
correct.
suggestion return fileSystem;
Is it OK to swallow this entirely?
Make this an assume
Please use DescriptiveRunnable class here, because if we have problems with threads it is impossible to follow them up if they don't have a proper name
As you saw in ConfigUserService I usually write to a temp file and then rename to the target file on successful completion of write. I'd like to have that logic here.
fsDb.getSoftDeletedFeedbackSession should not return null.
What if close() throw IOException ? Even it has cached object, it will not return that.
Any reason in particular that it shouldn't give the effect to players?
Check first that target is not null.
should be ...object instances can be deleted"
do we want to have actual percents? not rates as everything else is in Picard?
Let's use Identifiers.pack(...). There are no differences between the results of those two, but it feels better to use Identifiers for IDs.
Aren't we doing this in the superclass?
invert this.  java if (List.class.isAssignableFrom(target.getClassType())) { return multiInstantiator.instantiate(target, parameters); } return conver....
Null values aren't used for item stacks. Use !target.getHeldItemMainhand().isEmpty() instead of target.getHeldItemMainhand() != null, and _maybe_ put target.getHeldItemMainhand() in a variable since you're using it multiple times.
This will prevent changing to null, which should be allowed
Is this a duplicate/unnecessary call?
static import
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
could use diamond op
Can we const this magic number somewhere? what does this 300 stand for?
For consistency across the project, please remove the final keyword from this local variable.
Don't we need to fix up the ID and timestamp, like is done in read() ??
You collect PositionDTOs one by one, what result in a lot of database operation. It is possible to eliminate unnecessary database selects if you collect PositionDTOs in one call. In JpaRepository there is a method: List<T> findAll(Iterable< ID > var1);. In this situation it seems perfect, refactor getPositionById method and use findAll.
Assert.notNull()
Can use Guavate.toImmutableList()
nit: Expected bucketFunctionType to be HIVE_COMPATIBLE, got %s ...
Looks like validation result is ignored. Let's wrap it with Assert.assertTrue(). Also constants on rows 115 and 118 should be changed to long (0 -> 0L and 1 -> 1L accordingly).
@stefanbirkner I question using LinkedList here, because I understand that ArrayList, the main alternative, usually performs better on modern hardware because it can better exploit processor caches due to it using an array internally, whereas LinkedList cannot due to it using pointers.
why ConfigurableApplicationContext, not ApplicationContext?
This can be "package-private", i.e. no access modifier.
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
It's an enum, you can use !=
Could probably further reduce the duplication here, although the generics might get hairy.
Sorry forgot to mention to change the read to access here too
style nit: remove curly brackets
Should you set the module logger after calling WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(logModuleClassLoader)? (as it is done in activate)?
no lets call Assertion error: error instead of ass.
are you sure it is save to remove this block ?
I would rather choose to have a while loop to implement this rather than a recursive call (call stack can grow quite big unecessarily because of this call depending on the level of nesting of the file) and moreover, I believe a while loop would be more readable.
Why not refer to the symbols by their String value or '<' value? All these 0x9 don't make a lot of sense for the readers.
These should just be static instances of the ThrowableCategory as they have no local state.
Should this honour the actively published flag of the extracted content, rather than being explicitly set to true?
Can be rewritten with a single constructor call.
is this required ?
I note this is using the same namespace as the pre-existing "aggregating" metric.
can this just be collapsed into a single writeAndFlush() call?
@kachayev this is not correct as you already write a FullHttpResonse and so MUST NOT write an extra LastHttpContent
set me free
You could move the construction of msg and response under the if clause as you don't use it in the else case. Just curious though, since the check and the write aren't atomic, what happens if writeAndFlush() is called when the channel isn't active?
can you wrap this with if (log.isTraceEnable)
@kachayev one question... isn't this assuming that we are talking HTTP/1.1 ? I mean for 1.0 we would need to add the keep-alive imho
Why not using the othe constructor and let the base class allocate?
Release the response
please add new HelpTag and HashName (as in StorageListModel)
consider a ternary statement instead...
I might be wrong in understanding the bug. Correct me if I'am wrong. But, the bug says "Message in the Restore Popup is not correct when volume is online and snapshot is deactivated" and lets assume now that the snapshot is deactivated and then without this change it would go into the else which is doing the same as your change already right?
Kindly move this to UIMessages
You didn't add the macPoolCommand to 'executeCommand' of this class. Maybe I miss something, but I'm not sure how it suppose to work...
can you have a string that is set conditionally and then 1 single model.setmessage thatstring at the bottom any way 1 message is compulsorily there right?
Out of curiosity, why is the return type of this setter not void?
camelCase with small letter starting
move to line 184 - right before the query invocation (just for convention reasons)
most part of this method could be extracted to a parent class. It could be called like this: setupNewVmModel(new UnitVmModle(new NewVmFromTemplateModelBehavior(template)); and than some specific setups, but not too much...
suggestion processInstanceIds.forEach(processInstanceId -> {  You dont need to use _.stream_ to access _forEach_
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
Could change to ProcessInstance.STATE_ACTIVE ?
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
I think here you can call await directly on the configured countdown listener and check the outcome of the await method - it should return false, meaning that it timed out. Wdyt? Otherwise we can replace this with plain Thread.sleep().
suggestion createGrantAuthorizationWithoutAuthentication(PROCESS_DEFINITION, ONE_TASK_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
I think that Kie server should return HTTP status 4xx in this case (possibly 400) as request parameter cannot be parsed.
Please update the test to use error assertion defined here [1] to have such functionality in one place. [1] <LINK_0>
I would use method reference as per below suggestion String[] nodeIds = logs.stream().map(NodeInstanceDesc::getNodeId).toArray(String[]::new);
Basically the same issue as mentioned above, I believe.
This should check to make sure that notificationUUID is not null before attempting to delete it.
check to make sure notificationUUID is not null
It doesn't look like you are doing anything with the bucket here. This can be removed.
Missing final.
Missing final
Missing final
You call Ds3ClientHelpers.wrap here, but then in the next expression you call wrap() are these two expressions doing the same thing?
The response generation already does this. Here you should be using an assert and then getting the status code.
I believe that this should be final
@lautarobock I believe there is a need to forward exit call on the Pass instance corresponding to the index.
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
Maybe make this a static final List now that is is used two places? (here and line 123).
have a default constructor with reasonable default values
Please keep this.cell near the related fields (previousFamily & cell count) below
this.fragment = fragment, no need for the ternary ? operator
In general, we should probably be moving away from client-side validation where possible.
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
for all the "waiting" items, I think we need to add "resource" otherwise people will ask "why am I waiting after I was queued".
You could instead have a storeTTL option taking a string and parsed using DurationUtils, for more readable config. Actually I see other places already using storeTTL and using that so something is inconsistent.
Integer.parseInt
Shouldn't options be Immutable?
please see the contract of Map.entrySet(): by invoking put() during the iteration the result is undefined.
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
Please initialize this with setMaxInflightRpcs(BIGTABLE_MAX_INFLIGHT_RPCS_PER_CHANNEL_DEFAULT * BIGTABLE_DATA_CHANNEL_COUNT_DEFAULT)
Why not just CCorePlugin.getOptions()? It returns a HashMap<String, String>.
please fix the whitespace. You just need to return the options here.
Should we use our "utils" for that?
can we still add a check for null and throw if it is not set?
Per IRL, I meant to say uploadApiBase. This is fine too, but unrelated.
Looks ugly and potentially a source of future NPEs.
what if fParser != this? shouldn't this be fParser.createTimestamp
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
that class would be better with a builder, though I wouldn't ask changing it now
Unneeded change. This only used in RegexPathPredicateTest, that is in the same package.
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
[minor] For factory methods that have such an amount of constructor parameters, we could consider providing a builder, so code is easier to read and understand.
Shouldn't we use empty list here ?
Please use the Spring's Asserts for that, for consistency with rest of codebase
unrelated change ?
This doesn't seem to be used?
You could keep those paths as constants (MODULE1, MODULE2, etc.) since they are re-used
In this case it would be better to define modules variable after JsonArray modulesFromJson after this you will be able to create modules list instance with defined size new ArrayList<>(modulesFromJson.size);
I intermittently get test timeouts on testGetModulesByClass(), and when this happens, every single test afterwards will time out. I have a feeling doing fTrace.openTrace() here has the potential to really mess up things. An individual test should not modify the class fields relevant to all other tests. This could use a different trace instance here.
Do we really need this anywhere else but in the SecureStoreProvider? To me it looks like the SitePaths should be injected into the SecureStoreProvider and it should read the class name directly from the gerrit.config there. The SecureStoreClassName annotation and the SecureStoreClassNameProvider can then be deleted as the SecureStoreProvider is the only one who needs this information.
Use != instead of equals() here
This is awkward as a singleton. Strongly prefer new .... In particular, it makes it possible to edit the singleton state without going through Network which makes the code harder to explore and reason about. Instead, expose a getter or, better yet, have Network offer the register methods directly and forward them internally.
Is there any reason why you do not just call listModule.add(module)?
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Would return builder(SecurityLink.resolved(security)); be simpler?
nit: param doesn't need final
Using CompletionException would be more appropriate I think. Otherwise we would end up with longer ex-> RuntimeException(ex) -> CompletionException chain of causes.
make all local vars final if possible
Collectors.toList()?
You could just use: java return RxJavaPlugins.onAssembly(new SingleToObservable(mapper.apply(t)));
Might the following (or a variant thereof) be a little more clear as to the intent? java FluentConfigurationBuilder<?> fluentBuilder = configBuilder; if (fluentBuilder.getService(configType) == null) { fluentBuilder = fluentBuilder.withService(emptyConfig); } return new CacheManagerBuilder<>(this, fluentBuilder.updateServices(configType, update));  And it's a pity we can't determine the type of the configuration without creating a potentially unused instance.
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
Can't we use containsKeyAsync?
don't catch, but instead allow the ExceptionMapper to handle it
Better, but use logger.logAndThrow(new ...)
This method is not being used anywhere. This class has findbugs failures as well
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Would it not be enough to only catch MergeException here?
ex will always be null here
I think it is a bit easier to understand if you add the logic to enable / disable the input field after the while loop. I guess inputTextField.setDisable(!tags.isEmpty()) should work.
Needs to be a constant
Is this method really meant to be public? Looks like it should be protected.
Multi exception catch and usage of ReflectiveOperationException.
we never use NULL, it is a bad practice in general.
is there a reason for StringBuffer instead of StringBuilder?
Since Kieker now requires Java 7, you can use the try-with-resource clause here.
Symmetry (throw)?
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
@dmzaytsev why not  java final int size = Math.min(8192, stream.available())  ?
Use Local variable start time created on top instead of new Integer(0)
It's not the first time I see such inline immutable on-heap Chain implementation (in the builder too?), please consider extracting that to an external class and re-use it.
Please give this exception a name
Thank you for cleaning this up! I think this is carryover from the .net LL since Dictionary is the commonly used map type
don't forget default case
When you move the default keyword to the corresponding case you don't have to implement it twice. :wink: java case R.id.brick_glide_to_edit_text_duration: default: // Code
Left over from debugging?
Timberrr!
(ListView)  can be removed
Having a try/catch block here makes the code harder to read and duplicates the error handling code. I suggest creating a new method that gets the recipients from a message and handles the exception.
It's better to use != RELEASE_PROD, so that the feature will appear in Beta and Alpha.
you could shortcut this code snippet to:  String[] optionStrings = {view.getContext().getString(R.string.brick_place_at_option_place_visually), view.getContext().getString(R.string.brick_context_dialog_formula_edit_brick)}; new AlertDialog.Builder(view.getContext());.setItems(optionStrings, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { switch (which) { case 0: showVisualPlacement(view); break; case 1: PlaceAtBrick.super.showFormulaEditorToEditFormula(view); break; } } }).show();
These two always go together. It might be cleaner to set the field inside prepareToFinish().
should be handled in a method
The try-catch surounding this can be replaced with JUnits [ExpectedException](<LINK_0> rule. It reads a bit nicer.
do these test methods really require throws Exception?
should this exception be left to bubble up and fail the test ? If afterEach fails it means the repository was not shutdown properly
I already made several fixes to the unit tests cases and XBeeDevice class that are already committed in master. We will sweat blood to make the merge...
Redundant assertion
Did you just forget to remove the above printStackTrace? :)
You can also use IO.close(bb) as IO.close will not throw any exception.
check is not really needed. Split will throw TableNotFound if it does not exists.
I think you need some synchronization around modifications to this data structure. If I understand correctly, the Chore will be run in it's own thread, while quota changes would be dispatched from an IPC handler thread.
I would use a matcher to avoid pattern recompilation.
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
Maybe make it _this.pool_ to keep it consistent.
Actually as Part of reusability we have added Synchronized block inside TrapReceiverImpl.addToSnmpV3Users and same we are calling here.I hope this serves the cause or If still synchronized is needed even for this block i can update it.Please let me know if its necessary to wrap here as well.
could we use guava Cache instead of doing our own ?
don't update fields in one object in the constructor of another object.
If these fields were configured macros, then config.fileSystemProperties will not be set in the constructor, you will have to set it in prepareRun in that case.
selectorExecutorPoolSize can be removed from this class.
Shouldn't a copy constructor be used here, instead of sharing the same reference?
It seems we create and fill a temporary ArrayList here that we drop after filling without using it. I guess we miss a config.setPartitionLostListenerConfigs() call here.
Please do not reformat line 131-133, it is unncessary.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Do we want the toString()= in here ?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Please include clientTelemetryEnabled in toString() API
This is missing maxTotalRows
Why do we print a secret systemUserPassword here?
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Seemed better before? More readable
Just return checkNotNull(id, "id").split("/");
these setters should not be public
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
Why is this necessary?
Uh, IllegalStateException?
Is there a reason to have this setter instead of using a randomly assigned uuid and having the RollingOperation constructor check not null on it? We use this in some tests, but I don't see us testing the Id itself (and we shouldn't, I think).
No need for this.
(optional) likewise [and so on in other files]
Enforce immutable and non-nullable lists. If this is a read-only object, not something users will build and send to ARM in a request, then avoid having nullable collections (the typical tags field of an object is a counter-example as we need to send it as null, so we enforce immutability but not its presence): java new AutoValue_Metric(data == null ? ImmutableList.of() : ImmutableList.copyOf(data), id, name, type, unit);  Apply this pattern to all lists in the new model classes.
You can remove this call and also remove the public default constructor: it's not used.
Consider adding null check here.
Finish implementing function?
Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods "checkDuplicateEmail" and "checkDuplicateUsername" . And you can instead implement method on the HardcodedAttributeMapperFactory "validateConfiguration" and throw an error in case that "username" or "email" was configured as user model attribute.
Change log level to debug
will potentials AttributeNotFoundException be translated into 404 status code from the REST interface ?
dont use assert check and throw exception
I don't think this cast will work in the general case when the underlying attributeValue object is not a HashMap. Have you tested this with a non-HashMap Map?
Convert Unspecified to constant. And there's probably a framework constant for this string somewhere.
May be mention the attribute type in the log?
This seems wrong to me. If the type is _Address_. I would expect the name to not be "author__address" or "publisher__address". The name should be linked to the type - not the attribute name.
Use org.ovirt.engine.core.compat.StringHelper.isNullOrEmpty(String)
This shouldn't get thrown.
nit: style wants newline
It would be great to cover the util method with tests.
There should not be a need to set this to public. Perhaps private would be better.
Could you please add clear message for case when assert failed?
Could you please add clear message for case when assert failed?
this can be static
Could you please add clear message for case when assert failed?
This should be 8 rather than 6
Do you need the fully qualified class name here?
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
I believe that this validation doesn't belong into the API. I'd suggest to modify this 'ticket' method so that it works similar to the 'ticket' method in the 'BackendVmGraphicsConsoleResource'. If the 'graphicsType' is null, it should pass null to the 'SetVmTicket' command. The command implementation should then check if it is null, and generate the appropriate message. It should also check if the VM is down.
This should just return 404 HTTP error code (not found).
I always thought that only the first word of a sentence should be capitalized, and that the sentence should end with punctuation: Operation failed. Call me picky, I admit.
tiny nitpick. Change to: return Response.status(Response.Status.BAD_REQUEST).entity(new ErrorResponse(Response.Status.BAD_REQUEST.getStatusCode(), "path /{userID} required")).build() This is here and in other places too.
Is this the most accurate check possible? You check if some bricks are being removed in this volume. But what if you ran 'activate' action on brick A, and in the same volume, brick B is being deleted (and not brick A)? Seems like this would pass validation.
The reason seems incorrect. Shouldn't the reason indicate that brick cannot be activated unless migration is complete?
s/allow/allowed
This has already been committed, does it need to be rebased?
Oh yuck. ;)
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
You might want to not over-complicate it and keep the toString of the Optional perhaps?
This is missing maxTotalRows
Why do we print a secret systemUserPassword here?
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Seemed better before? More readable
protected instead of package protected
It would be better to avoid casting here as it prevents class cast exception. Please rewrite first constructor instead.
public
redundant ";" character
xml supports SpEL too.
I think these all should go into your symbol table class eventually.
You don't actually need to get the "file system" from the tserver. You can get it from the ServerContext: suggestion this.fs = server.getContext().getVolumeManager();
I assume this has to return a Map of Maps for the front end? Anyway to use just one List or Map?
!networks.isEmpty()?
If this is purely for testing purposes, it might be useful to define a counting id in the client, and append the counting id to the end of this to differentiate between channel generations.
Why we removed final?
Why do we even have this check. It seems like issue in other place of the code.
just readability - we can move 'updateAllVmsSucceeded' declaration to line 118, as it's not needed for floating disk flow.
This calculation avoids choosing the right host in the following example: host 1: sockets 3 cores per socket 2 threads per core 1 host 2: sockets: 6 cores per socket: 1 threads per core: 1 For a vm configured with: sockets 3 cores per socket 2 threads per core 1 Considering all other host parameters are equal, then both hosts will get the same weight and the first ("host 1") will be chosen instead of second ("host 2"). I think that maybe the calculation should contain "cores per socket" comparision instead of "total number of cores" and the same for threads.
Isn't below more readable? if(!ExternalStatus.OK.equals(host.getExternalStatus()) {
if we have one vm which is down, why do we need to perform it?
I still don't get this method, what is the disk isn't plugged to any VM at the moment? what if we have more then 1 vm that the disk is plugged to and they are DOWN? it won't be executed.. don't we need to sync between the qcow header and the metadata then? it's not clear
This will add a message per host. So if we have 100 hosts and 2 are fine, we still get 98 messages. Wouldn't it be better to collect all failed hosts to the same message? Also, please check with Martin Sivak how he makes sure to collect all filtered-out hosts, so when there are no resources we present an informative message per filter.
I would recommend dropping size var and just calling timeStamps.size() ... this way do not have to keep this thing correct... for example should set this to zero when calling clear
maybe change to 20000 or even 30000 to be on the safe side
rename to contribution
style nit: no braces around single line blocks
You should probably call super.dispose() here too
timed --> direct
We should call clear after disposing all the readers
rename to operation
I suggest you reset colorPreviewImages to null after that.
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
Papyrus is sufficiently prone to exceptions in dealing with stale data that it is probably worth catching and logging any RuntimeException that may occur in the listener call-back here so that we don't miss the call to super.dispose().
@rsearls, is there a reason you put the test before processing the ResourceFactories?
Likewise don't need the if statement since the optional value will return empty.
Providers will know to filter on SpellType.NONE, so just call the api method for the current spell and the ifPresent will know if the value is empty or not.
Remove the if.
Delete the if, the ifPresent covers the if.
You can eliminate the if statement since the ifPresent will already redundantly add this.
Do we have the sitting key value for wolves? IF it's just a key, you can: suggestion vanillaValues.add(this.angry().asImmutable()); this.getValue(Keys.WOLF_SITTING).map(Value::asImmutable).ifPresent(vanillaValues::add);
Delete the if, it's covered by the ifPresent.
We'll need to add Optional<Value<Something>> to the Entity interfaces that have Values that may not exist so that everything goes through the DataProvider system and call that instead.
Delete the if, it's covered by the ifPresent.
Same with this.
Please use TIME_FORMAT instead of "HH:mm:ss"
Please make the constructor private (see Invalid).
What if the string doesn't end with a " or '? You'll strip the last character.
This could be made static
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
"else if" maybe?
Usually we want to do additional assertions with the captured value, is that also this case? If not, please use other mockito matcher.
Should we consider other measurement units, like kg?
Minor: same as in other number check, WDYT about checking for the decimal point?
I wouldn't recommend changing the method accessibility only for testing purpose. In this case it means we can't unit test the method directly but it can still be tested on a higher level.
nit: use SUBJECT
What are your thoughts on using an AndroidPreferences instead of a raw SharedPrefs?
I would use something more random here, like RandomStringUtils.randomAlpha(Tv.TEN), for example
Should be removed if empty
This shouldn't declare throws Exception.
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
needs filling in :)
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
Why is this exposed to the things implementing PushingAsyncDataInput? I guess to make implementation easier? I mean, there should be no reason for StreamTaskNetworkInput or StreamTaskSourceInput to call output.endOutput(), as the runtime can do it for them and it can only lead to bugs if the method is called prematurely. Maybe there is an easy way to hide it from the emitNext()? Like splitting into two separate interfaces?
Can you revert this and keep the explicit exceptions.
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
Local variable could be declared List instead of ArrayList. Is this worth caching?
This exposes the unicode workaround to the public.
new ArrayList<>(causes);
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
studentsWhoRespond -> studentsWhoResponded
Don't we have to say that this is uniqueId JDBC?
Add server name in the log
we dont need this variable, we can use _unavailableSegments in line 110 right?
Probably would be cleaner as two lambdas, once over inputs, once over outputs.
check name?
Can we check for an empty string too, please?
shall it also be >= 0?
This thing does check the value for not being null. So the previous expression is redundant.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Redundant condition.
They are mutually exclusive? Or is that a micro optimization?
Have you intentionally omitted index check?
Is this correct?
This needs to be changed to return the long value.
Use Guava hashCode function
If you have to cast here then you probably should have casted when reading the value from the data array.
bad hashcode.
why are we casting to "int" ? it the value is a "long" we must return a "long" or we have to handle the overflow some way
Should this be changed to long (to match the return type of Duration.toMinutes()) or is it too much hassle? It's not a big deal cuz I don't think we'll ever encounter a situation where we'll overflow int...
This should probably check for > maxInt and throw in that case. Unlikely with an index file... but you never know...
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
No need to use UriBuilder
No need to use UriBuilder
Just this.home is enough
No need to use UriBuilder
No need to use UriBuilder
No need to use UriBuilder
No need to use UriBuilder
No need to use UriBuilder
Use formParam() instead
No need to use UriBuilder
return tags;
I think we can remove this line.
returning null cause null pointer exceptions
Could we return an empty map instead of null so this method doesn't have to be @Nullable?
We shouldn't catch a NPE. We should prevent it from happening. What is resulting in an NPE?
Can you just use the diamond operator here?  Map<String, Map<String, Integer>> ret = new HashMap<>();
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Suggest druid.host instead of 127.0.0.1
Is there a possibility that singleGene is just an empty map at this point?
Update to use Security.doAs
I would not call the leaderContender under the lock because of the risk of introducing potential deadlocks.
shouldn't use the CLUSTER log CLUSTER.debugf("Shutdown while handling command %s", command);?
Again, we shouldn't do this.
This can be condensed. java if ((throwable instanceof ServiceBusAmqpException) || !(throwable instanceof AmqpException)) { return throwable; } return new ServiceBusAmqpException((AmqpException) throwable, errorSource);
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
This can be simplified java if (throwable instanceof AmqpException) { return new ServiceBusReceiverException((AmqpException) throwable, errorSource); } return throwable;
nit: extract the logger into a constant
this line can be removed
Let's use parameterized logging, shall we? That way, you don't need to check if debug log is enabled.
Do we want to include the original throwable so it can be shown in stacktrace as "caused by"?
Asserting the actual message isn't a good idea because this could be localised or message changed which would break the test.
Asserting the exception type is sufficient.
You don't need to add this exception to the signature as it is an [unchecked exception](<LINK_0> :)
Same goes for this one :)
This is a test for the userRepository in my opinion and should not be here.
None of these error cases need to post events
use expectAssertionError and check the correct error is built with verify(failures).failure(info, <error factory>);
@elguardian this test is failing because this constructor needs to be updated to receive the identity provider. suggestion router = new KieServerRouter(true, "fake");
Could you please use custom output stream here, e.g. like at sqlline.SqlLineArgsTest#testSetWrongColorScheme it will keep output clearer in case of success tests
Just to complete: could we have a test that fails because we use index == fieldList.size() (I guess 2 in this specific case) ?
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
sorry i missed that before, you should send "getActionType().getActionGroup()" instead of specifying the actionGroup here, and specify the correct action group in VdcActionType enum (where currently it is wrongly MANIPULATE_USERS it should be the new EDIT_PROFILE
make permissionList private variable, permissionList should be created only once
I don't think this is correct. Consider changing a disk to use QuotaA instead of QuotaB. I'd assume you need ManipulateDisk on the disk, and consume on QuotaB, no?
what about setting the permissions for that?
CommandBase.checkPermissions will always return true for this, meaning will authorize the user to perform this action. It would be better assign null value to dataCenterId.
now that we have some permissions in common in ImportVmCommand and ImportVmFromExternalProviderCommand, we should probably move the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to ImportVmCommand and have the permission check on the destination cluster only in ImportVmCommandBase as it is common to all import commands, what do you think?
would you mind inverting the condition to simplify it and skip the negation ? if (isImageProvided()) { ... } else { ... }
I think that if the network exist you should be able to edit the (attach) parameters if you have permission on the network or if you have permission on the cluster
what about multiple storage domains?
you can actually use the returned boolean value to nullify astroDiscoveryJob and print the log.
**USB**-serial
Do we care about threading? device is set in the thread that calls initialize (in the parent class), device is unset (set to null) in a thread used by scheduler. So, should we use volatile, some synchronization, ...?
simplify this
Seeing this essentially duplicates the load code above, I feel there must be a more elegant solution to this - something that just retriggers loading of all the existing observable's data...
I thought the default was false.
what about outWriter? Move this stuff up into the blocks, so you cannot forget adding it here.
verify is probably more trendy
Should this be removed or moved to debug level?
Could be set to null after dispose().
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
Try using StringUtils.isTruthy(this.path)? <LINK_0>
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Same thing here; if oc not null, ocn must be.
You can remove this call and also remove the public default constructor: it's not used.
Mind replacing this with Boolean.parseBoolean(metadata.get(Constants.HeaderConstants.DIRECTORY_METADATA_KEY)), it does the same thing.
The number of parameters is extremely large -- creating a brittle interface and difficult to comprehend client client. Please refactor to the Builder pattern.
agentDisconnect also sets this state.
Rest of the class does this lookup in the DataPurgeJob instantiation, this should be there also for the clarity.
sgtm
Let's use the new NETWORK_FACTORY permission that Paul is building in aosp/1099096
could ringsize != -1 check be done here, will allow better escaping and inlining where not being used., e.g. avoids need to call into method below which is many lines long, and unlikely to be inlined
The old code was: void updateRenderEntireFile() { cmA.removeKeyMap(RENDER_ENTIRE_FILE_KEYMAP); cmB.removeKeyMap(RENDER_ENTIRE_FILE_KEYMAP); Now, that you are iterating over A and B in a loop, one removeKeyMap should be enough.
use translateText
L324 and L333,334 are racy. cm.getActiveNetworkInfo().isConnectedOrConnecting() just indicate that any kind of network connection including cellular is established. L333,334 checks that the active network is Wifi. If the network connection is flapping between wifi and cellular, this can still set the high res map on. Let's change isConnectedOrConnecting() to isConnected() to minimize the impact of network flapping, and move the info check on L333 to immediately before L324.
This patch set looks good except for the behavior issues discussed on this line in patch set 2.
This line is too long. Line break before ? and : and indent both one more level.
ImmutableSet.copyOf(Iterables.filter(...)) ?
ImmutableSet.copyOf(Iterables.filter(...)) ?
That's good to know.
The methods computeIfAbsent() and putIfAbsent() are not thread-safe. If two threads call fetchTree() concurrently, you might get two ids for the same aspect. You could use a synchronized block around the two lines, synchronization on one of the maps (they are final).
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
why the newArrayList? Iterables.filter already returns an iterable.
Make sure to return a read-only version of the List (not set) here. We don't want people to think this is the method to register interceptors.
Iterables.filter(Iterables.concat(bob), isAssignabe)). use iterables methods on iterables?
Maybe make it unmodifiable?
You will see a problem: nullable annotations go bananas. :(
Can this happen ?
I would recommend componentType.cast(new GlobalSecurityManagerImpl()); instead.
I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.
You can remove the unchecked warning by doing:  T service = clazz.cast(services.get(clazz));
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
Should this be implemented?
Should this be implemented?
Shouldn't this return a Page<T> instead of a List<T>?
Hm, maybe this should return bitmapResultFactory.wrapAllTrue(Filters.allTrue(selector)); and return true for supportsBitmapIndex. As-is, TrueFilter shouldn't be returning true for supportsSelectivityEstimation since it doesn't support bitmap indexes, but not supporting bitmap indexes would potentially interfere with use of bitmap indexes for other subfilters when an And/Or filter contains a TrueFilter (See makeCursors() in QueryableIndexStorageAdapter and getExecutionPlan() in AutoStrategy).
why is this return null??
you should have here setSucceeded(true) IIRC.
Do not forget to check that there is no link after enablement/disablement of the preference. With separated tests like the current stat f the class, we do not control the order of the tests.
This method needs to be implemented in LexerATNSimulator as well as ParserATNSimulator.
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
?? why this and the following ones could be left empty?
Recommend throwing UnsupportedOperationException if the disk methods are called.
Will need a @since tag.
the ArrayList of languages to translated could be cleared.
@Before / @After could overwrite System.out :-P
DEREncoder shouldn't be referenced from ASN1Encoder - the implementation of this method should just be moved to DEREncoder.
Mid return may worsen readability
is it not empty if for example type is an valid empty string?
You have chose a policy=static for the reference, so it cannot be null.
please move the isEmpty methods to the scimSchema
How does this work if you resume a download? It's using the same instance right?
wouldn't it be enough that one of these is null?
Why 0,8 if all we are setting is 7?
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
Shouldn't we use empty list here ?
shall we use an or now that we have three of them? :)
The "Name" class implements correctly the "equals" method, so you can do just this: return SCHEMA_ENUMS.contains(type.getName());
if these strings are used elsewhere, create static constants and share
If the list is static, then you don't have to remove the static modifier everywhere. However, I would prefer you to use a dedicated getter lazily loading the configuration of excluded types.
I think this Map.class.equals(type) is a remnant from a previous implementation and can be removed?
These should refer to constants rather than the string literals.
+static
Use isVarcharType from Varchars. Also change the check in parsePartitionValue.
Do we need to check which button triggered the event?
Before return, assert that the underlying java type does not change.
Maybe this lne should be moved to castPreferenceIfNecessary(), since this is present in both handlers.
Why decryption is excluded?
id is the id of the container. so it means in the scope of this container "createItem." + this.getId() can be pre-computed for the container, rather than re-computing it each time. Could you pre-compute this in the container level.
can we factor out this code, here and other places? e.g, java return withContext(context -> replaceItem(itemType, itemId, doc, requestOptions,context)) .subscriberContext(reactorContext -> factoredOutFunc())
If we are introducing a new connector, I prefer to not support this option in the first version. It is not very useful and may be error-prone in upsert mode.
This would be a breaking change, are we ok with that?
Is Itemizing (or promoting parts of) request option, to limit to applicable ones?
remove sink semantic option.
I think this should copy to preserve the existing semantics <LINK_0>
Can we update logic in CosmosAsyncContainer#createItem from  public <T> Mono<CosmosItemResponse<T>> createItem( T item, PartitionKey partitionKey, CosmosItemRequestOptions options) { if (options == null) { options = new CosmosItemRequestOptions(); } ModelBridgeInternal.setPartitionKey(options, partitionKey); return createItem(item, options); }  to  public <T> Mono<CosmosItemResponse<T>> createItem( T item, PartitionKey partitionKey, CosmosItemRequestOptions options) { if (options == null) { options = new CosmosItemRequestOptions(); } if (partitionKey != null) { ModelBridgeInternal.setPartitionKey(options, partitionKey); } return createItem(item, options); }  So we can delete if (partitionKey == null) here.
Should we use our "utils" for that?
assertThat(element).hasTotalSize(6)
assertThat(result).hasId("analysis")
Ik. Maven has logging facilities. We should use them.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
We can use defined constants for project natures at org.wso2.developerstudio.eclipse.platform.core.utils.Constants class
please use a separate button and separate method, don't use "showAggregtedProcesses()"
I think we could use a better naming here. It should express that the project hierarchy is (or is not) flattened in the Tasks view. How about TaskViewState.isProjectHierarchyFlattened()?
This is out of scope for this issue and requires extensive testing. Please revert for now.
I guess we can simply make it either java RegisteredProject project = projectConfigRegistry.get(wsPath).orElseThrow(() -> new NotFoundException("Can't find project"));  or java RegisteredProject project = projectConfigRegistry.getOrNull(wsPath); if (project == null) { throw new NotFoundException("Can't find project"); }
having wallClock = 4 for atlasTs = 4 is potentially confusing (ditto below with 6/6).
formatting
We could also have a test to establish that we can be rate limited on one read and then have a smaller read succeed.
Should checking of all details be in every test? Username and other details are checked in other tests. The only difference is "guest=true". Are you sure? I'm not
Should that be a post or a put?
why not declare those values there <LINK_0>
I think that we also need to verify that the server did got everything it expected.
So there is only one irq style that 3 states use. Then why not make the view use only one style. The resources view may want the same style for all 3 states, but another view may prefer to differentiate them. These 2 situations shows a counterexample of the centralized registry. Or why not sub-states, for IRQ and SOFTIRQs for instance, there could be a basic state: IRQ, SOFTIRQ, then you could have sub-states and depending on the level of details for a concept that a view desires, you can use the sub-state or the state. RUNNING could also be a base state with SYSCALL as a sub-state.
I'm wondering if the height hint shouldn't be per view instead of global... again some views might want a varying treatment to an IRQ state...
logSizeQuota -> logSizeLimitPercentage
Because there is only one argument, we can pass workerMetrics instead of an object array.
Inconsistent log format. Use either {0}th or {0} th. {0}-th is even better.
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
This mechanism is a bit different from other apps; the number of push/pull requests are done numberOfUpdates times numberOfKeys in one iteration. On the other hand, Dolphin apps (e.g., NMF, MLR) update models by sending push/pull requests in one mini-batch. Could we go with the same semantics?
why both DataProviders have the same article's names inside?
Arguments should be switched.
Why don't we append a suffix Ms?
nit: let's make it one line.
Better to remain final modifier, if possible.
Let's change the loss value to the sum of squared loss; later we can revert to regularized loss when we are evaluating convergence at offline.
Value nor envVar wont be ever null, but empty strings, so that check will be valuable
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
typo notifiedMessage ?
allowedTexts
I think just CallManager is not healthy should suffice as an explanation. Health.java shouldn't care about the specifics
This validates whether the kit is correctly formatted in the config - is there a reason for removing this?
these should probably be defined only once in the file
it would fit easily one line
+ get
This change isn't required either?
super.init() method never throw an exception.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Don't you need a super.setUp() call here?
Should be removed if empty
Should be added the Override annotation.
We normally reserve checkNotNull for argument checking, and use checkState for state-like checks.
This shouldn't declare throws Exception.
needs filling in :)
Hi, @nvazquez. I see a little mistake in you test, you are testing if the method has inserted a tag or not, I think that this test needs to verify if the template inserted in the templateResponse is the same that you has passed in the first param of the method. You can do it checking if each variable in both templates are equals. The same problem in the other tests cases. Ty.
This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.
make it fluent
If you want to save a little code, you can use "ArgumentVerifier" in org.threadly.utils. It was designed to be a way to save jar space by reducing duplicated code.
use MAX_SIZE
Can you add small addition to make sure that error port has same string tuple that was passed on input port?
It might improve readability a little bit if the expected score was a variable instead
There is almost certainly something here you should flip so the textures don't need to be manually flipped later.
parser.teardown() call should be part of finished() call of TestWatcher
if you use a second client instance and do this remote operation, the test can be easily duplicated by non-java clients as well.
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
This method looks horrible to me (and to whoever is a sane engineer, I should think).
We don't need a separate implementation of each method for CRS matrix. We already have it in AbstractMatrix.
We don't need this. There is each method in AbstractMatrix class that has the same logic. And we can't do it better than there.
should make a static final.
braces
why 4. make private static int
It's better to use shift operators here. Instead of java value += (int) Math.pow(2.0, (double) i);  it's better to have java value += 1 << i;  The left-shift operator is equivalent to 2 to the n-th power (2 ^ i == 1 << i), and has the advantage of not requiring conversions to floating-point and back, and also avoids any expensive operations that happen inside Math.pow. The left-shift operator is a single assembly instruction :)
what is the purpose of testing a while loop? :)
After refactoring ACTIVITIES. for(Page page : PAGES) { executePreformanceTest(page.action, page.title, page.displayName); }
From <LINK_0> I still think that a declarative programming approach with streams is a much more elegant implementation than this.
We could merge this, but that would cause all extenders of this class which are not LineContentAnnotation or LineHeaderAnnotation to not be clickable. So that could be perceived as a functional regression by those. Is this a big issue in your opinion? I am personally fine with it, as this is very new code and I don't think it has much adopters beyond those who are already following, and that even current adopters do work on the CodeMining layer more than on the annotation one. That said, do you think we could figure out an implementation that would work in basic cases, such as x >= fx && y >= fY && y <= fY + fViewer.getTextWidget().getLineHeight(position.getOffset()) && x <= fx + gc.stringExtent(getText()); ?
just = bit != 0?
I wonder there is a better place for these 2 methods. If I was looking for this functionality. I wouldn't think to look to AbstractFragment. I don't really have a suggestion though, just thinking out loud, I guess. Edit: I just noticed that these 2 methods are the only static ones we have in AbstractFragment, which I guess can be a good reason to think about moving these elsewhere.
I think that casting the two counters before computing the difference is a mistake. We could end up having to truncate the long and computing a false difference, could we? Maybe it would be safer to do return (int) (this.getCounter() - event.getCounter());. Also, we can use field access instead of getters for counter.
This variable should be called something more generic instead of sort since it could be any int
could be a single return statement
I'm afraid this could spam the logs. I made bad experiences with logging when developing the DOIConsumer. Please reduce the log level to debug.
I suggest to condense this somehow to a single return
This is redundant. instanceof will return false for the case of null.
Why change the order? You normally stop in opposite order to creation. So, if you create embedded cache manager first and then the server, you normally stop server first, then the cache manager.
Is this double invocation performed on purpose?
I would always call stop regardless of the mode (and make sure that stop is a no-op if it wasn't started). That way, as we implement other modes, we don't have to update that piece of code.
Should be in a finally block?
Ok if already stopped? idempotent?
Add a proper log message.
Also too many dots
check if it started here.
Here we can either get rid of the DEBUG variable altogether or use LOGGER.isDebugEnabled(). The best solution is not having DEBUG at all and using the LOGGER.debug statements directly.
Would it make sense to add something this.caches.clear() to the stop ?
does this need to be a class member?
You could use METRICS_PERFIX constant here instead of priam
Typo? "BlobDet4acryptionCount"
use a constant instead of null to make the code easier to read at this place pls
Consistency: queryConverter() instead of query()?
This change is incorrect: we shouldn't change a URL but only the content (view) that will be rendered when this URL is requested. Here is a link that should help and also shed a light on how it works now: <LINK_0>
When accessing /gui, none of the resources can be reached. The log hints at why:  Feb 14, 2014 11:27:38 AM org.springframework.web.servlet.handler.AbstractUrlHandlerMapping registerHandler INFO: Mapped URL path [/gui] onto handler '/gui' Feb 14, 2014 11:27:38 AM org.springframework.web.servlet.handler.AbstractUrlHandlerMapping registerHandler INFO: Mapped URL path [/gui/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]  Could it be this resourcehandler mapping?
getter.
by default we have the DS binding methods with modifier protected instead of public. This prevents others from accidentally "destroying" an existing service. Although the ProfileTypeResource is not injected into other services I suggest following this approach. In the test case you are nonetheless able to call these methods with a little trick. Instantiate the ProfileTypeResource like this:  ptr = new ProfileTypeResource() { { setChannelTypeRegistry(...); setProfileTypeRegistry(...); } };
Remove the decorator registered in line [229](<LINK_0>
please add setSoftLimitInterval() setter and use it.
We need to get rid of DefaultMinThreadPoolSize and DefaultMaxThreadPoolSize and define those as JMX properties inside ovirt-engine.xml.in
Consider getting this value once, and save it, instead of calling it twice.
The <Integer> can probably be omitted.
as this is not interactive command, I suggest you do not call getDbUser twice, drop the canDoAction entirely.
1. this error is not needed as you removed (VdcQueryAuthType.User) from GetAllHosts query 2. please also remove this exception from BackendHostResource.get() after you make GetVdsByVdsId admin-only as well thanks.
i'd prefer separating list in two methods: 1. listall 2. glusteronly and return them accordingly
i'd prefer separating list in two methods: 1. listall 2. listvirtonly and return them accordingly
hmmmm.... how is this done for this specific session? nevermind... I think yo can just call getData with refersh and the soft timeout will set for you, no?
same please.
@fanifieiev Let's put this in a constant.
@fanifieiev Why not use the constant here too?
... remove the final modifier from the method. It will be easier for future tests.
Are you positive that value could never be null here? I don't remember if we translate empty values to empty strings or null values.
I think you should throw exception if somebody calls setEvent and give an empty event name. #Pending
Try to use constant non null values in front for comparison methods, as their is less chance for a NPE. "COOKIE".equalsIgnoreCase(name)
So is there value of having a whole class that just does such a simple thing? Perhaps a static method in a utility class is easier and adds less to the heap?
Can header name and value be null?
This constructor should call the more general one with a default value (3 in this case)
Why not: if (value.names().equals(value.toString()) n = value.name().toLowerCase().replace('_', ' '); else n = value.toString();
We get to rename this variable to prefix it with is I guess
Don't we usually include a test for these validations?
Does getEmails2 always return a collection? Take a look at code to be sure. Concerned about possible NPE.
Nit: extra blank line.
Let's not do partial reformatting as part of a functional PR. In other words, keep the current formatting for unrelated changes, if we want to change line lengths, let's do it for all the source code in a separate PR.
@bdragan performance-wise I think it's better to compile the regex and keep it in a constant...
= null not needed
Seems possible to simplify. I'm not sure, but is this just?  if (profile == null || profile.email == null) { return user.getUsername(); } return profile.email;
See if you can extract a smaller method to generate the email for one instructor/student. e.g.  for (...){ emails.add(FeedbackSessionClosedEmailForInstructor(...)); }
That's to verbose and the logic is preaded in three different places. So no return, just one method: putPreferred and do all there: search for preferred mail, change it and return or issue the warning when not found.
should be false unless one of the vm's disks has true for this
Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.
Why should the About dialog no longer be resizable?
I suppose this should be true ?
This should always be read from the configs.
Does any of these have to be protected?
The code can be simplified to rely on autoboxing.
The default value should be true.
I think this should be replaceFailed = false instead.
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
It would be great to rename the variable to isParamCountValid.
I believe it should be allMatch here instead of anyMatch
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
@mariebawanan I think the proper fix for this is to remove the duplicates in variables VariableTypeList instead of just filtering out the duplicates here.
excluded. isExcluded is name for a getter.
I think it'd be better to throw an exception if the user sets isForceGuaranteedRollup=true but it can't be applied, otherwise it may be confusing if the task succeeds but they later notice that rollup was not "perfect"
Format this code please.
this is the spotbugs issue, you're building a new object but not assigning it anywhere
Is this a good practice? Casting to an abstract class? it may be better to have an interface AccessControl and AbstractAccessControl then implements that interface... but that way you program against interfaces which seems cleaner to me.
this is redundant with next instanceof check
since this is the vdsbroker, you should be able to use java.util.Objects.equals()
Needs to consider the new custom fields.
This could be checked earlier I believe
Shouldn't this be at line 134 ? Replacing .getClass() check instead of obj == null check ? Like in User object ? I know it will return false for null anyway, but this will also return false if you compare Member and RichMember which we wanted to be comparable. In User object you just continue with params comparison when you compare User and Candidate or RichUser. I believe implementation should be at least equivalent in both Member and User objects.
shouldn't we also consider the name?
Just to stay consistent, I would keep this as its own check. We always use "return true;" on its own at the end normally.
same as previous patch (keep its own check). I know its tempting to REMOVE LIIIIIINES, but let's not get crazy :P
Please use curly braces for conditionals
Please remember this ctor changed.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Use same order as the field declarations.
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
that class would be better with a builder, though I wouldn't ask changing it now
Why 0,8 if all we are setting is 7?
since we construct a default conf already, better to use it rather than call defaultValues.  internalConf = ClientInternalConf.fromConfig(conf)
Shouldn't we use empty list here ?
Would be simpler as: return Arrays.asList(Action.RELOAD);
this.
Could change the return type on method to Collection
Collections.emptyList()
Immutable
See below (return copy)
Why is it a list of lists, not just a list?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
invokeAll on an empty list returns null. So you may want to handle that
I know it's trivial, but would be much nicer if this mapping was extracted to a separate function.
I realize that the test case was just moved, but maybe for a separate commit or a follow up: Maybe the error could also give a hint on what would be correct. E.g. StringType can only have a single parameter value, received: ... Also in the other error messages. E.g. with 0 it could point out that it must be > 0.
the method name is misleading. You insert a default organization uuid but it's failing. Why?
Since IllegalArgumentException is an unchecked exception you don't need to include throws here
you're crazy man :-)
Eclipse is giving an error that this is not thrown. Changing to Exception fixes it.
I don't think this error message very accurately describes what has gone wrong. Please change it to something which describes the problem The same applies to the next two tests
check that the wrapped error is the one the method actually throws?
remark: we name the variable ws everywhere. It's a pity it's named actionTester. I then have to check what it is. I think so even if the name actionTester were better
@bgeVam please remove the unnecessary parenthesis around encounter.getUuid().equals
For consistency let's use braces on all conditionals and loops, even if they're one line
user.get() can return null
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
I could be missing something, but why can't we call deleteAll with toDelete and not create a separate KeysIterable temp var? Actually, this method doesn't even need to accept an iterable over entries, just keys.
This is going to fail in case we get an empty list (yes, an edge case, but still... a check on the size would probably be safe). Or perhaps an empty list has a special meaning?
hey guys, here it is what I should do by doing some initial casts (not great code I know, had to review at some point...), but this way the stream and functions to apply seams more clear... up to you!  protected boolean isConnectionAlreadyFormed(final Node<? extends View<? extends Definition>, ? extends Edge> source, final Node<? extends View<? extends Definition>, ? extends Edge> target, final Edge<? extends View<? extends Definition>, ? extends Node> connector) { final String connectorDefId = getDefinitionId(connector.getContent()); final List<Edge<View<? extends Definition>, Node>> outEdges = (List<Edge<View<? extends Definition>, Node>>) source.getOutEdges(); return outEdges .stream() .filter(e -> connectorDefId.equals(getDefinitionId(e.getContent()))) .map(Edge::getTargetNode) .filter(n -> n.equals(target)) .findFirst() .isPresent(); } private String getDefinitionId(final Definition definition) { return definitionManager.adapters().forDefinition().getId(definition); } private String getDefinitionId(final View view) { return definitionManager.adapters().forDefinition().getId(view.getDefinition()); }
Same issue here, don't think any of these bulk methods should use memoized Function instances
this is a moot set to even bother using. It's a temp registry that gets dropped as soon as the game has finished loading.
You can avoid creating the updatedUserList if you move the for cycle below into a forEach() here.
I don't think this should be memoized... the Store should be able to call into this multiple times with different sets of keys.
You can't return null from the compute method. This throws NPE for me when I run it. The same thing happens in the other tests cases but I don't think you see anything besides the first one
value is redundant, just return right away.
are these setters used anywhere?
Same here. Add clarifying parenthesis
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
We do not unpack it for all the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to byte is needed here.
Add parens on (value - 1)
I'd suggest having an OptionalLong for value here, and have users just use an Optional<ColumnStatus> rather than the null object pattern we're trying here
Bug is here. You shouldn't have = here. Think about it and understand why this bug only affected negative test case, but not the positive test case.
"else if" maybe?
Should we consider other measurement units, like kg?
Duplicate in both createSubject and createEvidenceSubject methods. Consider to refactoring into helper method.
Same variable names (change to senderVouches.
This seems unnecessary, if you going to return the same thing at the end of the method anyway.
Instead of relying on all the properties shouldn't we just rely on discoveryType? less confusion with if else logic and also while defining the descriptor.
This doesn't allow for values to be passed in. Should discuss the appropriate solution for this.
Switch to [{}] for consistency. Also, log the stacktrace please.
This should be trace and remoe the "Minh version ....".
Why we suppress this generic exception and throw SAMLAssertionBuilderException above? Should we remove the generic exception here?
check code format
you can group them like this Assertion assertion = OpenSAML2ComponentBuilder.getInstance().createAssertion();
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
possible NPE
Worth including an entitlements check, because the return values could contain passwords retrieved from brooklyn.properties. For example, something like:  if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) { throw WebResourceUtils.unauthorized("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user()); }
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
One thing about that is that the builder pattern doesn't gives feedback to the dev of what is mandatory and what is optional at coding/compile time instead you have to wait until you run the app for the asserts to take place and that was biting me over and over with the way we where configuring the controllers before. I like the builder pattern and having a lot of params in the constructor does bother me. In the register branch that I'm working on I reduce a couple of params. Let me think on how to improve this while keeping the benefits of the constructor.
so much boilerplate :\ would this be easier to do with [AutoValue](<LINK_0>
Could this method be gutted and just call the new deleteElements method?
On START_DATE, the discount factor for start date should be 1.
The smile has an impact on the currency exposure. Run the test with a VOL_PROVIDER_FLAT such that RISK_REVERSAL_5_FLAT and STRANGLE_5_FLAT are 0.0 everywhere. The last 3 lines of the test are incorrect. Replace by: double ceBaseFD = pvBumped.getAmount() / (SPOT + FD_EPS) - pv.getAmount() / SPOT; assertEquals(computed.getAmount(EUR).getAmount() \* FD_EPS, ceCounterFD, NOTIONAL \* TOL); assertEquals(computed.getAmount(USD).getAmount() \* (1.0d/ (SPOT + FD_EPS) - 1.0d/ SPOT), ceBaseFD, NOTIONAL \* TOL); The code in 'BlackFxSingleBarrierOptionProductPricer' seems correct, it is only the test which is incorrect.
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
You should be consistent with either using this for instance methods or not at all. I prefer not using them if not required.
Could probably be shortened to double orbitalPeriod = 48D*Math.pow((Math.pow(orbitalDistance, 3)*Math.pow(Math.PI, 2)*10D)/solarSize, 0.5D);
ouch. HeronSocketOptions also needs to be updated to use ByteAmount in another pr.
Does it work on line across dateline?
Should be FLOORLET_SHORT.getYearFraction(). Even if the year fractions are the same it is more readable to use the Floorlet version.
Could apply all of these fixed memory string test to both functions. The following is one way to do this in Java 8 I was playing around with. Is there a shorter way to create the list of functions? java List<Function<String,Long>> funcs = Arrays.asList(AccumuloConfiguration::getFixedMemoryAsBytes, AccumuloConfiguration::getMemoryAsBytes); for(Function<String,Long> memFunc : funcs) { assertEquals(42l, memFunc.apply("42")); //rest of asserts }
Magic number
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Use catch (NoSuchAlgorithmException | KeyStoreException e) when having multiple catch blocks with same output inside them. Also since you are catching 'Exception' finally and throwing the same exception with same message, the 1st two catch blocks has become redundant here. BTW its not the best practice to catch Exception, its better to catch specific exceptions and handle them. Any reason for catching Exception?
This should be handled by the nodeDelete return value, so we don't need this catch.
What made you to wrap, when you still use a simple long afterwards?
Should we use .getMessage() as in the remove() or .getLocalizedMessage() as is done here?
Can be replaced by X.hasCause(): not 100% precise, but will work for this very situation.
I don't think we need this catch - this is handled by the boolean return value.
Extract this try-catch block to a method to avoid code duplication
This is strange, I don't think we can get constraint violation for relationships when setting a property? When removing I guess we could violate a existence constraint, but that's anyway not checked until commit. In general it feels like here are way more catch clauses than necessary...
this.lockVerbs (like below)
This condition seems like it'll fit in InstructorCopyFsToModal.java more, to reduce the reliance on that id string.
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
Can you use TextUtils.equals(browser, defaultBrowser) instead? It's a null-safe version of String comparison since it is possible that defaultBrowser would be null.
style nit: we don't use braces around single line blocks
Just wondering if it is possible to call this on a different thread than the EDT ? If it is not possible then the syncCall on line 82 is not necessary.
could be static
I believe we don't need this if if we use stream() on the List. Plus there is a .collect(Collectors.toMap(...))
q.timeTaken is a misleading name. Is it the time taken by q?
suggestion mandatory = Boolean.TRUE.equals(q.getMandatoryFlag());
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
Make this "info". there's relatively fewer operations scheduled on the executor, and would be good to log their completion status
nit: not sure why this method called generateSendFailure. Should this be renamed to handleSendFailure?
catch RuntimeException
Also try to refine 404 errors to a ResourceNotFoundException to let the 404 fallbacks work
Who told you to do this? We still want the localized message for these exceptions
You may need to include INSTRUCTOR_COURSE_STATS_PAGE as well.
Can you use LOG.debug("CSS parser error: {}", exception.getMessage());
I think we need to catch the throwble here. Otherwise if's a RuntimeException like SamzaException the thread will be killed without notifying the listener.
log.warn
Assuming this is noting completion of initialization, perhaps "Finished initialization."
Get the service registration reference and unregister within the deactivate method
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
we shouldn't commit this change
We may need to put this behind the flag, especially if we want to back-port it to older GCS connector versions. We can enable it by default in master branch though.
empty function? also no qualifier (public,private)?
does this need to be implemented? For example, shutting down the EventLoopGroup?
Should you set the iis to null here so that it is immediately known that this is closed if you try to re-use it? I'm just concerend about someone using one of these and not realizing that it wasn't being used correctly.
Should this check for the presence of the 2 nested jobs?
A variable with the same name as it's type - is this more Java 8 craziness I haven't seen before? :)
Let's re-word this to a forced shutdown
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
This is missing maxTotalRows
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Why do we print a secret systemUserPassword here?
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Seemed better before? More readable
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Will * <LINK_0> * <LINK_1> work as well?
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
When we will run this test on www.wowwiki.com it will fail. There is wgServer variable which we can use in this case, then append Special:Promote path to URL
you can either remove else or add pair of curly brackets
Here I would follow another approach, you get a ZIP file, and you interested only in its content, the schemas data directory providers I described above are the ones responsible to provide the location to store them, we got a ZIP or a file, we clear the current schemas directory content and drop the ZIP output or file in it. When handling the ZIP file, it may happens that the user ZIP the schemas as root or a directory, we shoudl vouch for the two use cases: 1. we have a directory inside a ZIP, we use the directory content 2. we have files as root inside the directory, we use whatever is there
why do you do the substring if you are using contains?
this.url = checkNotNull(url, "url");
I think this is an accidental duplicate check (checks the same thing twice, no modification in between).
Pretty sure this is also supposed to just be the localization key.
getUsage(...) expects a localization key.
getUsage(...) expects a localization key.
"robot explain --input <file> --axiom <axiom> --output <output>"  Default reasoner should is ELK (returned by CommandLineHelper.getReasonerFactory(...)) so the user wouldn't need to specify that. Maybe make a note in the docs? And if you link to the reason docs, they can see all available reasoners.
This expects a localization key
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
CMD_DECOMMISSIONBOOKIE + " [-bookieid <bookieaddress>]"
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
You could simply do super.setClazz(CommonLog.class)... You don't need to have a vaeiable pojoClass.
Assertion is missing for operator name
it is not really needed, we can simplify the code here
The setup of updatedKeyStorage is not needed if fireOnlyUpdatedPanes is false.
I'm wondering why we even need this class; can we not simply add a boolean property to the base class called "appendPartitionId" ? Also, the ticket description says "If SingleFileOutputOperator is partitioned into **more than one** physical instances then it should append partitionId to file name" (my emphasis), I don't see any check for that condition before appending the partition id.
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It should only be temporarily turned off to create (or delete) test content.
As it is a new behaviour, should this be exposed as a new method in the operator interface? This allows us to identify the operators that actually make use of this feature.
context.PROCESSING_MODE => OperatorContext.PROCESSING_MODE (to get rid of "The static field Context.OperatorContext.PROCESSING_MODE should be accessed in a static way")
can you add instanceof check?
I'm thinking if we could provide an automatic way to call these method by set annotation on the field just like those IoC frameworks do
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
This is missing maxTotalRows
Oh yuck. ;)
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Why do we print a secret systemUserPassword here?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Seemed better before? More readable
Doesn't List as a Collection have a defined method to check whether it's empty or not?
idx -> index
can just do new ArrayList<ICommand>(commandMap.values()); instead of separate addAll
@treblereel , do we really need the 'list' instance here? Can't we build up the HashSet directly and compare its size with sortList size? Or even better, at that point can't we simply return the first time that the HashSet#add method invocation returns false?
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Highly suggest isEmpty
Perhaps this would be more readable with the last two cases switched
Shouldn't this close the iterator before returning the list?
May want to do a null check
please remove else, code will be more readable
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
discussed a bit more, we're going to make both key-values, and make sure to split on just the first colon
studentsWhoRespond -> studentsWhoResponded
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
same remark for the try with resource statement here. Currently the inputstream close is missing.
new ArrayList<>(causes);
This exposes the unicode workaround to the public.
Don't we have to say that this is uniqueId JDBC?
List<...> rules = ...
we dont need this variable, we can use _unavailableSegments in line 110 right?
Could you check for null or empty? Via StringUtils.isBlank
these 3 methods are public do you really need them?
">=" would be robust, even though not possible as the code is now.
Symmetry (throw)?
This line should not be extra indented
I think the offset and limit are miss-leading here with the method name searchPayments. The client uses them to restrict the result payments size, but the plugin will use them on the transaction level. So it would be the case that, the client sends a limit of 100, but only get 1 payment in the page with 100 transactions embedded. Or a payment may cross 2 consequent pages. Are we considering to have the plugins returning a more proper list instead of PaymentTransactionInfoPlugins?  class PluginPayment { private UUID kbPaymentId; private Collection<PaymentTransactionInfoPlugin> transactions }  Just a thought, I'm happy it's not changed in this PR.
suggestion: What are your thoughts to add a postcondition here to check that sum of aggregated results is equal to the run count?
hey guys, here it is what I should do by doing some initial casts (not great code I know, had to review at some point...), but this way the stream and functions to apply seams more clear... up to you!  protected boolean isConnectionAlreadyFormed(final Node<? extends View<? extends Definition>, ? extends Edge> source, final Node<? extends View<? extends Definition>, ? extends Edge> target, final Edge<? extends View<? extends Definition>, ? extends Node> connector) { final String connectorDefId = getDefinitionId(connector.getContent()); final List<Edge<View<? extends Definition>, Node>> outEdges = (List<Edge<View<? extends Definition>, Node>>) source.getOutEdges(); return outEdges .stream() .filter(e -> connectorDefId.equals(getDefinitionId(e.getContent()))) .map(Edge::getTargetNode) .filter(n -> n.equals(target)) .findFirst() .isPresent(); } private String getDefinitionId(final Definition definition) { return definitionManager.adapters().forDefinition().getId(definition); } private String getDefinitionId(final View view) { return definitionManager.adapters().forDefinition().getId(view.getDefinition()); }
debug instead.
We should rename the variable tags here and below (in addBillingEventsForBundles) to avoid any confusion. Maybe tagsForAccount?
Can lease.getStartingAllowedRequests() every equal zero? Might want to check for that.
withMillisOfSecond(0) is not necessary here if it is used above.
same here re: serialization test; probably worth having an example string to verify consistent serialization, would recommend a non-zero duration too (because zero will frequently be serialized on a different codepath to other things).
I much prefer the loop in @daryn-sharp's original code. Collection<Lease> expired = new HashSet<>(); for (Lease lease : leases) { if (lease.expiredHardLimit(now)) { expired.add(lease); } } This streams code will have to change if we want to pull this back to branch 2. I think @daryn-sharp also said that stream()'s are more expensive.
probably worth using safe-logging preconditions and having args for the incorrect leader ids
Looking into this again, why can't we use leaseManager.getLease(shardInfo.getShardId()) here?
After discussing with @ChrisGreenaway, this condition should be inverted to use the other Lease type in the check.
would synchronized(ClientLeaseGranter.this) work instead of making a lock object?
LeaseToken, ContinuationToken, Owner are Camel case, but timestamp, id, etag are not is that expected? also for Owner, timestamp, ContinuationToken, LeaseToken we probably should define constants.
This doesn't log what you intend. %s is for String.format not for slfj4 logger. slf4j logger doesn't understand %s placeholder please fix. <LINK_0>
Verify the injector has been set before using the delegate here
Similar
Similar
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
It should throw exception
Wrap up in a SamzaException or add separate catch blocks for general exceptions and SamzaExceptions if you'd like them to be treated differently
Log the full exception here as well, this should be fixed in entire PR.
suggestion LOG.error("Error parsing procotol buffer in message. The message will be dropped. Ensure that all components are running the same version of the software.");
these arrays could be static finals. That would save allocating new ones all the time.
Wrong name for variable. It's really Message
Please remove this line
Could this just be a plain getActivity() call? Any reason you need a BaseActivity for startSupportActionMode?
Can be transformed into an if statement.
So uh, this method is kinda necessary...
You can early return here
Instead of finish(), you can just set the parent of the activity in the manifest to MITMainActivity, that way it'll navigate properly to the home activity
The back button works for me in the current app? Is there a bug I don't know about?
showFirebaseLoginDialog? Aside from that, awesome idea!
Since the menu item click has been handled, return true instead here.
Thanks for changing this to a switch! When I originally added the Lite and Premium versions of the app, I had to implement this as an if statement because the R.id constants were not declared as final.
Is it the 'native snappy library' that is missing or the java-snappy jar?
In the original code, we throw a runtime exception if the native snappy is not found. Should we follow?  throw new RuntimeException("native snappy library not available: " + "SnappyCompressor has not been loaded.");
nitpick : final Throwable t
where are the corresponding cleaners for these direct byte buffer allocations?
This line String message = buildPrefix(nullSafeGet(messageOrSupplier)) + "Unexpected exception thrown: " is duplicated below. Merge both into a new private createMessage(messageOrSupplier, t) or even a createAssertionFailedError(messageOrSupplier, t)?
are you sure you want equals here and not ==?
Why return the ClientProxyConnector here? The only place it's called the return value is ignored, and subclasses could get it via getClientProxyConnector() anyway.
suggestion "part of a group or is participating in a rebalance right now. You should first call poll to complete " +
To avoid repetition, you could - Make the super method protected - have it use getStartTime() / getEndTime() instead of fSht.getTreeStart() / fSht.getTreeEnd() That way the reimplementation of getEndTime() in this class is re-used.
please stop the IDE removing trailing whitespace on lines which haven't been edited; complicates life
addPermissions means you added a permission, but it doesn't mean that no restart is needed... unless I'm missing something here.
u can simply use System.out.printf("Please enter a password for %s:",user);
Is there a need to have both asserts? The reason I'd prefer only one is that I don't want the user to get one error, fix it, and then get another. Since nonNull is implied by hasText, we can give the user only one error message that will repair both problems.
Kind of an anti-pattern here, this compiles into another StringBuffer allocation. Instead:  canonicalizedHeadersBuffer.append(key.toLowerCase()) .append(':').append(header.getValue()).append('\n');
there is no other way of getting article name?
there is no other (more elegant) way of getting article name
please name it as line ,as term header we use for block of lines.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
It's fine I forgot that the keys are hashes so they will always be fixed size and small.
I think this should be > 0 since a value list item of 1=One does not work.
If the input string is "(123(456)" this approach will strip the middle bracket and parse when it shouldn't. You'll need to use substring()
Is this still needed after removing the download stuff?
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
This could be made static
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
This.
What if the string doesn't end with a " or '? You'll strip the last character.
default method visibility OK?
Minor: same as in other number check, WDYT about checking for the decimal point?
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
you can collapse these 2 lines
It doesn't seem that you did what I asked for. It should be checking the toggle in addition to networkinfo. If the toggle is set to offline then it should return false. If the toggle is set to online then you can check network info and if there's no connection set the toggle to offline and return false, otherwise return true.
I would simplify to return (activeNetwork != null && activeNetwork.isConnectedOrConnecting()) . No isActiveNetwork variable declared nor assigned, easier condition.
Can you separate it into two lines as because of the condition in check style plugin i.e. you can't put more than 100 characters in one line, the build is failing.
If you want to be sure that isConnected never throws an exception (as stated in your commit message), then Exception or even Throwable should be catched (i.e. an IOException could be thrown).
For code maintainability, can you use the Utils.isNetworkConnected? Just to cut down on rewriting of code :)
if the goal is not to check traffic on zero rated network, NetworkUtil.isOnZeroRatedNetwork() check should be at the start of the method call
L324 and L333,334 are racy. cm.getActiveNetworkInfo().isConnectedOrConnecting() just indicate that any kind of network connection including cellular is established. L333,334 checks that the active network is Wifi. If the network connection is flapping between wifi and cellular, this can still set the high res map on. Let's change isConnectedOrConnecting() to isConnected() to minimize the impact of network flapping, and move the info check on L333 to immediately before L324.
use translateText
Pull this into a static final variable
You could have inlined this loop into the other method because this will create 3000 threads.
should this count be parameterized?
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
It would be preferable for the PutHammer to keep putting data until the main test method has verified that rehash has completed instead of using a fixed-size loop
you didn't use your fancy new syntax :-)
IMO if we know executeTask() doesn't trigger maxIdle expiration, we should assert that
All of this can be replaced with an ExecutorService
use Arrays.fill instead for loops
?useTopologyForLoadBalance=false
Needs to be in finally - we might get interrupted.
should this only be set if the latch.await above returned true? in the current impl I don't think it would make a difference since clientTimedOut is checked prior to clientHasReceived in the if/else below, but that order could be a fragile assumption
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Well, with the squash GH doesn't see changes and don't notify via email. I have missed this change therefore :cry:
This should be done in reconfigure. The DM can indeed start with a wrong messaging configuration. This configuration can be updated at runtime and then become valid. It is at this moment we should listen to debug messages.
Missing an argument
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
When concatenating the log message it would better to pass every parameter into the Objects.... rather than concatenating the string which is inefficient.
I would put the return 0L here. This is probably the one and only place where you do not propagate the exception
Cosmetic: Please, split the throws list clause on separate lines.
What if this path actually exists on the user's workstation?
Certainly getCanonicalPath() provides clean path. but this method always returns absolute path. It may need to confirm the logic is no problem or not...
suggestion Preconditions.notBlank(path, () -> "File [" + path + "] must not be null or blank");
If an exception needs to caught, does this exception need to be more specific? Do we know what potential exception is thrown, like InvalidACLException/InterruptedException/ZkNodeExistsException?
@AlexOreshkevich : I don't think I quite agree with the try/catch here... Could you please remove it, unless there is a good reason I'm missing?
Same error issue. I'd just fail rather than return a partial list.
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
I would do something different, if logger.isDebugEnabled() then print this message (in warning) if logger.isTraceEnabled() then print the full exception
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
No need for such harsh line wrapping, the style guide states it is up to 150 characters.
scheduleTimes --> scheduleTime
Can this be private, or is there another use case for default attribute outside the builder's call?
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Even though it's safe to do so, I'd prefer we called this.next() only once.
Tangentially, we should likewise install the backup service as ACTIVE, so that it toggles to NEVER instead of ON_DEMAND as well.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
same as above with the actionBarWrapper
make it protected. It was my fault to make all API constructors private. I fixed that. In master branch all API constructors are protected, so anyone can extend API in their code if they want. But couldn't instantiate directly, forcing them to use singleton
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
space before constructor
it would be nice to assert here that the actionBar is displayed. (so if it is not visible, and onActionBar() is called, it already breaks here with the error that the bar isnt there instead of later that eg. the title doesnt match)
Best to leave super() to avoid empty block complaint from Sonar.
serialization?
Could we avoid using this if ? Maybe this is the sign that the start should not happen here, but in a different place that we would not reach from unit tests ?
Very minor: consider adding a isProdRelease() release method to WikipediaApp.
"Couldn't rename [" -> Fail to rename
please use java.util.Objects.toString(username, "") instead
maybe use dnsServerAddress.isEmpty()
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
@dmzaytsev let's inline this
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
You could probably use the same URL as in getResultById here.
empty hashmap.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
I haven't tested yet but the code seems ok
There is a slight chance that this View will be destroyed when this callback is reached. Therefore this should be protected by a check for isAttachedToWindow().
We can use the res variable here instead of getContext().getResources().
Right, it looks not that good to me. Changed.
Just devicePause, there is only one type of pause, so adding the word sync just makes it confusing.
If we have this menu option, we know that the page was in a list the last time updateBookmarkAndMenuOptionsFromDao was called. That being the case I'm not sure it's necessary to call anyListContainsTitleAsync again here; couldn't we just show the RemoveFromReadingListsDialog immediately? If it is otherwise possible to get the app in a state where this menu item is showing despite the article no longer appearing in any list, then it seems cleaner to me to invalidate the options menu as necessary after reading list DB interactions in order to prevent that from happening. Side note: it's probably best to put all of this logic into a private helper method as is being done for the other cases.
Should be a tab instead of 4 spaces
could we do:  collectionId = null; if (intent.hasExtra(EXTRA_COLLECTION_ID)) { collectionId = intent.getLongExtra(EXTRA_COLLECTION_ID); }
The strings are defined in values for reusability and consistency
Can we avoid calling findFragmentById on each character that gets typed?
Can this be private, or is there another use case for default attribute outside the builder's call?
I'm missing the new field in the toString method.
public?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
scheduleTimes --> scheduleTime
add this selector to UI mapping at the beginning
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
There is an extra semicolon on this line.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
To make the tests more resilient to future changes, please pick values that are unlikely to ever be the actual defaults. For example 234MB and 11MB.
Same here, keep the order consistent with BenchmarkSuiteConfig
need to change as well
See if we can use assertFailsValidation here
hardcoded things shall be declared as class constants
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
This method was added in java 8. It will fail with java 7. Note that it might compile on Gerrit because we compile with java 8.
I don't quite understand why the Keys of this Property Map are localized Strings; if these Properties are meant for being processed programmatically, I would expect Strings that don't change when the UI is localized.
usually data objects never return null where collections is met
Use Map for the declared type
Removing the interceptors removes logging.
This cannot be removed. The scheduled task needs to be saved.
Output the message that caused an exception, possibly at the FINE log level. Also include the exception parameter so we can see a stack trace.
Should we consider putting that 512 into the AmqpConstants to keep all the protocol-specifics in one place?
We need to avoid waiting until encrypt time to determine that the public key passed at initialization is incorrect.
Maybe put Charset.forName(...) somewhere and reuse it?
This is almost there, but I think we need to change this condition to this: !(localSubscriptions.containsKey(subject) || subscriptions.containsKey(subject) || shadowSubscriptions.containsKey(subject)) If you look in the implementation of the send method in the bus. Those three fields + remotes are all the places where a message can be delivered, so if any of those three contains a matching subject then the message had subscribers.
no Object[]
use database string constants instead of these values
use database string constants instead of these values
Here and below: previously the code used only one table lookup operation, not it performs two lookups. Please consider to use get(name) and check the value to decide if it is illegal or not.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Maybe check for if name ends with ':' so we don't do a double one?
These should change to store the names in the attributes map so that you don't need special handling for all the places that handle the tags.
... remove the final modifier from the method. It will be easier for future tests.
They are mutually exclusive? Or is that a micro optimization?
Preferably have one call the other?
I'd put notEmpty there
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Use this.key
Use this.key
Use this.key in place of Keys.SPAWNER_MAXIMUM_NEARBY_ENTITIES
This probably won't be the default value for many items, I believe these should be dependent on the ItemStack being provided to the DataProcessor/ValueProcessor.
the minimum shouldn't be restricted in this case.
This is correct - you should just use 1000 in contexts like this, where you don't have access to an actual furnace.
new SpongeValue<>(this.key, DyeColors.PURPLE, actualValue);
You can use this.key (or this.usedKey, one of those fields - name always escapes me :P)
The default value should be true.
this.key
why exit here ?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
The action for these terminal cases is now the same as for TASK_RUNNING; so we might as well combine those cases. i.e., Line 97 above is the same as line 104, and there is no longer this special taskTerminated method being invoked for the terminal cases.
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this switch case number of lines from 10 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
It seems like a mistake to not track payload frames.
Typo. PNAccessManagerGranToken Missing "t" in Grant
Does consume(int) support skipping across buffer boundary? I guess another method like skip(int) is necessary.
fix string, fix array, fix map and fix ext needs length as well as type. My pseudo code encoded the length into the last 8 bits.
not sure why this field is public
It's better to cache the values(), a new array is allocated on every invocation.
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
Don't we need to return something like -1 in the null case (i.e. when the type is not in-house one)?
Is this correct?
Have you intentionally omitted index check?
Would it not be better to leave this enum ignorant of how it's used, but instead just throw an exception like is done in fromString above, for consistency and also keeping concerns separated? Then the user of this enum will catch the exception and log from that layer.
~~Why do types ending with a list have a constant width?~~ My bad, it's for when the _outer_ type is a list.
Are arrays declared as fixed width right now? We'll need to change this, maybe in phase 2. Let me think on this a bit. We'll need to change the logic in a few places (as you've already discovered!).
Instead of create a new type, i would prefer to let the SqlTypeUtil.convertTypeToSpec(type, charSet, maxPrecision) support a explicit precision parameter.
> Use emoveCallbacksAndMessages(null) to remove all the messages. > Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
refreshJob field should also be set to null on dispose.
> Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
done for patch3.
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
> Use h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
I believe mIsRadioTechnologyChangeOnGoing should be set to true here.
Could be set to null after dispose().
I'd recommend using <LINK_0>
Please format this as:  command.stream() .map((String s) -> "\"" + s + "\"") .collect(Collectors.toList());
Why not just include FlagUsageException in the throws here and then if it's thrown it will still count as a failure.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Its worth adding a null check here too.
In my opinion, we do not need this log. WDYT?
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
Would be more readable using swagger-java-quay-client. Can take a look at the series of PRs ending with <LINK_0> to demo how to use it.
nit: Can replace dois.size() == 0 with dois.isEmpty().
Optionally, Files.readAllLines() provides a smoother way to read the definition file: I bet you can use its output directly as a stream.
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
Collections.singleton?
What's the point of adding a copy here?
That's good to know.
This needs to check if the type is not a Class and throw an exception with a meaningful message. The implicit ClassCastException that's thrown here is unsatisfactory. Also, does this mean I can't use LoganSquare on a List of objects? That's really strange...
Maybe make it unmodifiable?
Looks like you're returning an empty TreeSet, but don't register that as the value of handlers (as would be the case in computeIfAbsent). If you just want to return an empty stream, it's better to use getOrDefault(type, emptySet()).
You can extract the contextForType(..) code outside the switch.
Is this annotation still present for JSON? That's a little weird.
Could probably further reduce the duplication here, although the generics might get hairy.
different value 50 versus 1. Is that intended?
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
Should be a SamzaException with a message, not NPE.
Perhaps you should keep this, and at the close of the pool, then also close the PRNG object to avoid re-seediing in background when not needed.
I think you should be able to pass config in directly
i think you should be able to pass in config directly
Not sure, why not use @NotNull?
It seems we create and fill a temporary ArrayList here that we drop after filling without using it. I guess we miss a config.setPartitionLostListenerConfigs() call here.
should we warn the client user that config.m_topologyChangeAware is ignored when config.m_useClientAffinity is false?
why do we have a ; here?
remove redundant ; it will only cause static analysis to complain
previous naming was more clear.
Can we refactor both of this if else if into one condition ?  java if (!accessToken || (accessToken && expiresIn() <= 0)) { accessToken = generateAccessToken(); }
Don't we also need to interrupt a thread if it is interruptible? (to cause calls like Thread.sleep() to be interrupted).
style guide
Codacy found an issue: [Use explicit scoping instead of the default package private level](<LINK_0>
why would this be required again?
throw an exception ?
It was args, not argb, that was supposed to be checked for null.
Probably makes sense to move this up too.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Saving preferences inside a setter is not appropriate. Please follow the pattern used for other preferences.
Use IResource.adaptTo(Class).
any particular reason why this method doesn't require an IJavaProject ?
Use IResource.adaptTo(Class) instead of casting.
Ik. Maven has logging facilities. We should use them.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
We can use defined constants for project natures at org.wso2.developerstudio.eclipse.platform.core.utils.Constants class
I guess we can simply make it either java RegisteredProject project = projectConfigRegistry.get(wsPath).orElseThrow(() -> new NotFoundException("Can't find project"));  or java RegisteredProject project = projectConfigRegistry.getOrNull(wsPath); if (project == null) { throw new NotFoundException("Can't find project"); }
are spaces OK in namespace strings?
as above: are spaces OK in namespace strings?
suggestion return Optional.of("org.junit.platform");
Each of the getters in a POJO like this should have the same return type as the private member variables they expose. In this case, I'd recommend having extension, dateformat, and frequencyOverride be Optional<>s (in both their member variable types and their getter types). Our Jackson YAML deserialization should automatically take care of setting a missing field to an empty Optional<> in the resulting Java object.
this.
A create card payment request should always have a return URL, so I don't think this should return an optional
this.
Seems like just sending an empty Map here would avoid all the null and isPresent checks later. Thoughts?
Let's just make this @Nullable instead of using Optional
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
fos can be inside try ()
Should that be 8192? 8024 seems like a strange number.
I think try with resources should be used.
use <code>logger.debug("Using charset {}", charset)</code> instead.
outputStream is never used
Using [Buffered IO](<LINK_0> would improve the efficiency of this test.
What is useful of 1 << 12?
This can be defined inside the try block.
make this method private. Being a bit more conservative is worth here.
should output.close() be called explicitly?
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
redundant ";" character
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
Do you think we can use an [unmodifiable map](<LINK_0> here?
Do the traits have to be ordered? Could you use a hashset instead?
I think these all should go into your symbol table class eventually.
The this. in getters are unnecessary too.
Maybe we want to keep something similar to what id was before
It is better to avoid this syntax because it creates an anonymous class every time it is called. instantiating a map and then calling fact.put(name, value); should be fine
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
For loop?
For each?
nit: what about java nulls[i] = i % 7 == 0  ?
It is not necessary to check value in compressed vector on zero. It is guaranteed that only non-zero values are store. Which means, that we only need to rename each to eachNonZero in CompressedVector class. Please also make sure that MatrixMarketStream uses the proper iteration method. TIP: It should be eachNonZero.
As the generated mask is read only and privately used it might be better to create once and reuse the same array.
All of this can be replaced with an ExecutorService
use Arrays.fill instead for loops
You used to erase the type, and as far as I can tell it's not the case anymore. Is there a reason for that, that would not be explicitly stated in the ticket? Was the erasure only necessary because of the bug you're fixing? Also, are you sure this won't cause trouble (behavior change for users in particular)? Might be better to move this change to a separate commit, with an explanation, or at least explain it in the commit message.
?useTopologyForLoadBalance=false
Nevermind, I see it is the Future.get() that throws the InterruptedException.
what's the difference between checkAuthAttributesAreValid and areAllAuthorizationsForResourceValid? I thought that the plan was to replace the former by the later, right? Since areAllAuthorizationsForResourceValid can perform all of the work that checkAuthAttributesAreValid performs. And in fact checkAuthAttributesAreValid only makes a number of calls to isAuthorizationAttributeValid. I think it may be the source of potential security breaches if we maintain both methods and a user ends up thinking that it's safe to only call isAuthorizationAttributeValid when in fact, areAllAuthorizationsForResourceValid should be also called. Please, correct me if I missed something.
you shouldn't need it as UnknownUserException extends LoginException
Unnecessary.
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
seems like we would like this log message for all exceptions no? can move this to mutlicatch as well.
![MAJOR](<LINK_0> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
should add some context in the exception message here
This is strange, I don't think we can get constraint violation for relationships when setting a property? When removing I guess we could violate a existence constraint, but that's anyway not checked until commit. In general it feels like here are way more catch clauses than necessary...
Is this reload really necessary?
If resources are not dependent on each other, reload after adding isn't needed. One reload after adding endpointConfigurationAddress and one after adding both preHandlerChainAddress and postHandlerChainAddress should be enough.
"Clean orphans from PROPERTIES" to be exact ?
minor: key_type instead of key type
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
This looks like it's just for card payments so don't think we should add these her.e
Add new catalog options.
this migration becomes useless since analysis_uuid can be null
I think this value should be defined as a constant (maybe even randomize it between runs?).
Should we really accept steps?
Do you have time for this? We talked about it on Slack.
I think we should leave getClassName() and getMethodName() as is but _only_ pass them to PojoStackTraceWriter to "optimize" the stacktrace.
It's not a _really_ expensive computation but how about using orElseGet?
You do not have to use brackets in ( isFailedContainer || testIdentifier.isTest() ). There is no collision between boolean and String in this case.
suggestion this.className = requireNonNull(className);
early return when if (testIdent.isContainer())?
I think there is an issue if the generation suffix has more than 1 character.
set locale
Please move the exception handling into notifyTestExecutionListeners() instead of duplicating it.
Can be the className null? If not I would maybe rewrite as [1], what do you think? My point is to not nesting expression into try catch, if an exception can not be thrown. [1] java if (ScenarioSimulationSharedUtils.isMap(className)) { return new HashMap(); } else if (SIMPLE_TYPES_LIST.contains(className)) { return null; } else { try { return classLoader.loadClass(className).newInstance(); } catch (Exception e) { throw new IllegalArgumentException("Impossible to instantiate " + className, e); } }
probably don't want to keep filling this map up as we browse around. could just use getOrDefault?
Actually the underlying objectExpr could have free variables.
return ImmutableSet.of();
If an assignment strategy doesn't implement movePartitions and if the operator calls movePartitions, It is better to throw rather than silently return. This way it is clear to the operator that movePartitions is not supported for the connectors using this assingment strategy.
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
Is order important here? Should the 2 collections correlate each to another?
Could we introduce a concrete class for this concept, of full/transient ranges?
Formatting nit: this should be on previous line
wrap with unmodifiableSet in constructor and then just return field reference from get* methods.
This is a lot of parameters. Perhaps it would be good to do a refactor (in a future PR), extracting a method object or parameter object (or both). For now I think we should leave it as-is.
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
You could probably use the same URL as in getResultById here.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
Space before {
I think the annotations should be on separate lines
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
Should this refer to a platform-relative constant?
Well that's a bit dumb :/ Ah well.
If you have to cast here then you probably should have casted when reading the value from the data array.
Use Guava hashCode function
This needs to be changed to return the long value.
you don't really need to populate the builder if expectedTypes contains actual.
bad hashcode.
Can we remove this?
you can reuse it for the application
Error message should indicate "Seventeen-argement init()" instead of "Fourteen-argument init()".
use use java.util.Objects
Change to use this.jsonAsString.hashCode().
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
return (getTag() == null ? 0 : getTag().hashCode());
return (dataCollection == null ? 0 : dataCollection.hashCode());
return (id == null ? 0 : id.hashCode());
If fields can be null, be sure to check so in other places (like in compareTo as well), otherwise don't include null checks in equals/hashCode either.
use java.util.Objects
use java.util.Objects
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and should be removed. The same goes for the other fields.
Could you update this method to include "AbfsPerfInfo" introduced by HADOOP-16612?
Should this constructor one just delegate to the new one with Function.identity()?
extra ()
Args.notNull
path
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
No need for else here.
this if/else is equivalent to this.path = Optional.ofNullable(path);
Putting a method call to an overridable method in a constructor means that you can end up calling a method in an object whose constructor hasn't been called yet. This can lead to some very hard to debug errors. One way to avoid this kind of dependency is to make a field lazily initialized, e.g. in its getter.
could we please use final due to consistency with the rest of parameters?
super.init() method never throw an exception.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
Throwing the generic Exception ?
Parameter should be true here, no?
Why do you call this method of superclass? As I can see this method is annotated with @Before by itself. No need to call it again.
Throwable is not needed, you can delete them. It was generated automatically by cucumber for the default pending exception.
We can't change the signature of published methods
This looks weird
Put this string in a final static so it can be updated in a single location?
Does it add an error message?
I feel like we should be able to take out a lot of these nullity checks. Let's keep this in mind for a future refactor.
Here's another reason for why magic numbers are considered evil: This time it is six 9s. Over in AbstractWidget it is _five_ 9s. On purpose? Bug? With a public static constant you wouldn't have to worry or ever have to make a change in more than one place :-)
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
no braces here, more occurrences in this file
I guess this should never happen in theory
Does this method need to be public?
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
As mentioned earlier, these calls might need to also regenerate the iterator. Please double-check.
Why is this calling setText 3 times a row?
Can we have all the variables above this be in camelCase?
This cycle has very confusing brackets. Could you please add brackets to if and properly tabulate the last bracket?
Here's another unsafe cast that can be changed to use mapperType.cast() instead.
Make this final and since we know how many tasks we're dealing with, make sure we're creating a list with the right capacity.
if implementations is empty, this method will eventually return an empty (immutable) collection. We should throw an UnavailableImplementationException instead to indicate an invalid state or spi class.
Lets pass the ListIterator constructor as method reference and do not subclass it: java return new SeqAsJavaList<T>(seq, (delegate, index) -> new LinearSeqListIterator<>((LinearSeq<T>) delegate, index));
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Perfect! :+1: Just a few things. I'm a little picky here :grimacing: No need to extends Object. Please use Map as declaration type. java return new ArrayList<>(uniqueMap.values());  The method is a perfect text-book example for tests. :wink:
This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.
This one is already done on line 816. Do we need it again here?
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
- you can simplify this to model.getSelectedDataCenter().getId() - I believe for Blank template the model.getSelectedDataCenter() returns null and you will fail on NPE here.
It would be cleaner create a new overload of this method, without the 'datacenterId' parameter.
you can simplify this to getSelectedDataCenter().getId()
you can simplify this to model.getSelectedDataCenter().getId()
most part of this method could be extracted to a parent class. It could be called like this: setupNewVmModel(new UnitVmModle(new NewVmFromTemplateModelBehavior(template)); and than some specific setups, but not too much...
you can not use this one since the definithion contains this: "VMs Tab > Make Template" which is not correct for this. Please add a new entry to HelpTag which will contain the correct path
This whole logic is not supposed to be in the widget (expect the one which has been here already: subTemplateExpanderContent.setVisible(model.getIsSubTemplate().getEntity()); because this is a widget, it should only define the view and it's binding to the model. It is not supposed to manipulate the model, even less doing some real logic. Since the rest is a logic, it should be on the model (or better the specific model behavior). In this case NewTemplateVmModelBehavior
Likewise.
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Should use the log, maybe a warning.
A CoreException doesn't necessarily indicate that the member is not owned by the class. Logging and re-throwing the same exception causes double reporting since the re-thrown exception will be logged or reported some other way elsewhere.
We should probably return v_private since this is the default for classes and getKey returns k_class in case of a CoreException.
Should be extracted to a local variable
What is the reason for this change?
I'd do: if (log.isDebugEnabled()) log.debug("Node {} added to Cluster {}", member, getClusterName()); And similar for onEntityRemoved.
System.err
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
Is it worth distinguishing what is null in this case? Is it different if m_txnState or the invocation is null
Remove the redundant null checks.
If there is no Auditor or no AuditTask should we fail the test ? Or shall we wait for an Auditor to be active ?
For lists not marked @Nullable we should return an empty list instead of null (or mark them @Nullable if appropriate).
Will queueSpinTake() ever return a null?
Null comparisons can be replaced by UtilMethods.isSet(object)
In general, we should probably be moving away from client-side validation where possible.
getSelection() should be returning the current selection
I think if the url is null, we don't want to return that task, so we should have a guard around both ifs.
what happens if you call this several times? It will recreate again and again the asked number of threads. You should have some flag to specify that it's already started no?
with 10 threads I can almost always reproduce the bug.
Suggested to extract a static utility function zeroOut(ByteBuffer)
if the advantage of this compare to 0 <= b && b < 256?
Pull this into a static final variable
should this count be parameterized?
Should we break the for-loop early if the condition is not met?
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
I would retain the existing indexOf body to to avoid indirection in the most common case.
?useTopologyForLoadBalance=false
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
I have doubts about this code. It means "a single-line case/default must end with a break, otherwise it needs a pair of braces". For example, this code raises two violations regardless of allowSingleLineStatement option:  switch (0) { case 1: return; // false violation default: throw new RuntimeException(""); // false violation }  and they can not be fixed by adding a trailing break. Why not check the last child's line? Something like  private static boolean isSingleLineSwitchMember(DetailAST ast) { final DetailAST slist = ast.getNextSibling(); return slist == null || slist.getFirstChild() == null || isOnSameLine(ast, slist.getLastChild()); }
it is strange to see all those code to handle null if we are using optional...
@mariebawanan I think the proper fix for this is to remove the duplicates in variables VariableTypeList instead of just filtering out the duplicates here.
We can slightly simplify: java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType());
I suppose we could use CollectionUtils.isNotEmpty() here but I'm not sure that buys us much.
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
Be a darling and fix that name for me please!
Not in the scope of your patch. But- error message should be localized
Doesn't there need to be a translation call in the case of getCanDoActionMessages() containing a single message? This code drops it right through to the failure event handler. The previous code would translate it first.
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
correct thread safe code looks like this: if (stopped.compareAndSet(false, true)) { cancel(); }
The Exception is never thrown.
The Exception is never thrown.
@dpgraham I think it is more senseful to throw an exception. Otherwice we have a risk to produce and invalid build or to not react to server changes.
You don't need this as compareAndSet will set it to true.
maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Sorry but I did not find where we call the close method?
This assertion should remain - when caching just Channels, there is only one connection (default). I suppose we can allow it to be set as long as they set it to 1. Will change during merge.
Aren't there any chance that super.inputStream() **is** already PushbackInputStream, so, we don't need to wrap at all?
suggestion "A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.");
The above 2 set* calls don't make any sense other than the fact that the call generates a logger.info line. Note that connectRetries and reconnectRetries are defined only in AbstractSolaceBaseInputOperator so super.setConnectRetries(this.connectRetries) assigns a variable value to itself via a function call. Need a reason for this code.
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
The super() call seems redundant.
It might be more readable if you have one setter per line.
I'm not really a fan of passing in null to methods/constructors. It feels a little hacky. I think perhaps we should use either the factory/builder design pattern since IncludeHierarchy seems to have a few different ways to construct it.
Why is this required?
The registration1 doesn't care about the value other than it is different than registration. For this case, registration3 needs to use the new variables, so (if it is kept around) it should be named more explicitly.
@xpdavid is this the right thing to do?
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
I thought empty was OK, and it would point to latest?
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
You could use StringUtils.endsWith(str, suffix), since it's null safe.  java return StringUtils.endsWith(version, SNAPSHOT);
It is not enough to judge empty. You should also judge the value > 2.7.0
Having this public feels problematic. What classes need to call this that don't live in io.realm ?
nit: you can merge both lines above as checkNotNull will return the given argument
This println can probably be removed.
nit: if {} else {log.trace()}.
Please use the form given before
Can this be private, or is there another use case for default attribute outside the builder's call?
Please remove this field.
shall we rename this as brokerUrl ?
Same here: should be Branding, not ProductBranding
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
Try using StringUtils.isTruthy(this.path)? <LINK_0>
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
The number of parameters is extremely large -- creating a brittle interface and difficult to comprehend client client. Please refactor to the Builder pattern.
merge else if?
how about doing it a bit different: change #1259 to something like: devices.stream().map(VmDevice::getId).forEach(vmDeviceDao::remove) and this method to something like: removeVmDevice(devices.subList(...))
don't need to wrap safeFormat
int rowCount = model.getSize(); Then the code in if block can be shared.
This is starting to look like something we might want to move to a separate list with the "overflow options". If the index is greater than getSize() - 4, we just get OVERFLOW_MENU[getSize() - OVERFLOW_MENU.length] This way we could maybe also get rid of a few hardcoded numbers.
what does this branch mean exactly, seems weird for me :/ Shouldn't we throw an exception instead?
else if ((index > 0) && (index =< 3)) { index = (int)(mIndexMax * mPrescaleAbsoluteVolume[index-1]) /10; }
For unknown size, getItemCount() returns either 0 (initially) or the current estimate. Why is not intentionally working if I ask for the item that is current estimate + 1? Why is not intentionally working if I ask for the first item before the data communicator has fetched any items? It should be my problem if my backend cannot handle the query for outside the range, or then when I return null then this just returns null. I would presume that 1) if exact size is used and I request outside the current size, I get the exception because we know this 2) if unknown size is used, the query is done even if it is outside of the current estimate - what this method returns cannot depend on the active range or the estimate at that moment or whether or not the data provider has loaded any items yet, as the flush occurs later during the roundtrip.
index < arguments.size() ?
Extra parentheses can be removed.
I think it is done on purpose to avoid auto boxing/unboxing.
To be sure, we choose this format: blobExpression == null ? false : blobExpression.isLiteralText(); regarding this one: blobExpression != null && blobExpression.isLiteralText(); ?
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
1. In general, avoid expr ? true : false pattern and simply substitute that with expr. 2. Ideally, this check should be ... == (byte) 1 or (... != 0).
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
matter of taste, this could also be return this.profileTypeRegistry != null;
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
whitespace, but prefer if you don't change existing code style
Please use TimeUnit.MINUTES.toMillis(15)
May be more readable if the check for null userCompactionTaskQueryTuningConfig is moved up: java if (userCompactionTaskQueryTuningConfig == null) { return new ClientCompactQueryTuningConfig( maxRowsPerSegment, null, null, ... ) } else { return new ClientCompactQueryTuningConfig( maxRowsPerSegment, userCompactionTaskQueryTuningConfig.getMaxRowsInMemory(), userCompactionTaskQueryTuningConfig.getMaxBytesInMemory(), ... ) }
no!
This is good, this thread does not cause the bad failures and dealock anymore. But it should mark the analysis as failed. And for very large traces, I think some failing mechanism should be put in place, to cancel the analysis. For instance, the waitForCompletion could wake up from time to time and make sure the analysis has not failed in the meantime. While this works perfectly fine, resources on a computer _are_ limited and it is better to avoid dragging this thread, and the request thread, and the threaded backend thread and some more view threads waiting for this, imho.
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
This could be moved to VampirePlayer#onEntityAttacked. But I guess it is fine here too
This class has no superclass, so I'm not sure we need to call super() here.
I know its nit-picky but for future expansion, it is better to re-use twice or more often used fields and methods by binding them to variables. If you will get a NPE, it is easier to identify which variable had the NPE. Same as variables down below
Use fire(event); for all EventHandler based events
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
Do we need to check here if this member is still a replica before clearing the counter (same as the check is done when clearing the record stores)?
I am not following here - why do we want this in sync block?
You should also update the error message in order to tell users that this option can be used in order to switch the duplicate field validation off.
Now that services are class members, we should not need to pass them internally in functions either. Please remove them from parameters and access directly in other functions. This needs to be done for all instances of ontology and germplasm data manager services that are being passed in function parameters. I will fix this @abatac while I am syncing master.
Do you want to update this one to make sure that the key _and_ the value are there?
Can you revert this change? toBlockingObservable() is deprecated in 0.19.
why is this method public? why is it static?
I would prefer to use same code as in method getProjectRelease  final Set<String> releaseIds = project.getReleaseIdToUsage().keySet(); for (string releaseId : releaseIds) { ...
Fine with me (although it does slightly detract from the opt-out possibility). WDYT about adding a retry backoff though? I'm a bit concerned we might just end up stuck in a loop of useless rebalancing, and waiting the full probing.rebalance.interval doesn't feel right either
Recent refactorings in ChangeNotifications allow for empty server lists. I think in the very beginning we should not emit empty list (filter empty lists out), but we should allow them afterwards, which means that all previously advertised server gone away. The bottom line is that ChangeNotifications transformers must offer enough flexibility to do that.
Ideally, we'd use the Time#milliseconds() here instead of System.currentTimeMillis(), but you'd have to pass the time instance in through configure. It would aid in testability, but it's not strictly necessary. I'll leave it to you.
suggestion if (highAvailabilityEnabled) { taskAssignor = new HighAvailabilityTaskAssignor<>(clientStates, allTasks, statefulTasks, assignmentConfigs); } else { taskAssignor = new StickyTaskAssignor<>(clientStates, allTasks, statefulTasks, assignmentConfigs); if (!lagComputationSuccessful) { ((StickyTaskAssignor) taskAssignor).preservePreviousTaskAssignment(); } }
Done, it looks like the change was not included in patchset1.
@jmmut should these checks be placed after the variant object has been constructed? I remember there was some weird situation with code being executed after the checks.
We generally prefer assertThat(..., is(..)) for better error messages.
Suggestion: "--active and --inactive options are mutually exclusive."
this check doesn't answer on question in test case, I would create another test case for it, or rename the test case
Arguments.of --> arguments (via static import )
This begin/commit/rollback pattern is present all around the source code and we've encapsulated into TestingUtil.withTx, could you use that instead? :)
would you mind adding: 012abc and 012ab
Stray empty line.
should return i2Alias - i1Alias ?
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
The agg function here should be adjusted to support the optional compression param like in the quantile version
can you explain why this change ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Copy paste code block? Split it out into a function please.
should we have an "unsupported" status instead of successful? successful seems misleading to me.
We are trying to remove the Globals class (in the long term). To facilitate this, could you please extract the themeLoader and preferences, and initialize them by passing the global objects as dependencies through the constructor (i.e. move Globals from this class to the caller)
Doesn't work as expected as this message is never displayed, whatever is the type of media.
This looks like it would have different behavior from what was there before. If this is based on the path, I'd expect needing to go through getFormFilePath (the method that builds database paths based on whether or not scoped storage is used).
Why don't we set the certificationstatuses filter of the searchRequest here? Then the DB could filter the results rather than having to put the logic in java below
Ik. Maven has logging facilities. We should use them.
Use IResource.adaptTo(Class).
local variable e is never used.
Probably makes sense to move this up too.
We can use defined constants for project natures at org.wso2.developerstudio.eclipse.platform.core.utils.Constants class
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Could "this." be removed?
any particular reason why this method doesn't require an IJavaProject ?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
I guess we can simply make it either java RegisteredProject project = projectConfigRegistry.get(wsPath).orElseThrow(() -> new NotFoundException("Can't find project"));  or java RegisteredProject project = projectConfigRegistry.getOrNull(wsPath); if (project == null) { throw new NotFoundException("Can't find project"); }
one more method where it can take file location of properties would be good.
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
What's the point of adding a copy here?
usually data objects never return null where collections is met
we should not modify the original properties. I would just return properties; here
Is this really needed? I mean I believe the idea here was that getProperties returns an unmodifiable map, while getMutableProperies returns the actual mutable map. Is there a problem with this?
This method was added in java 8. It will fail with java 7. Note that it might compile on Gerrit because we compile with java 8.
Don't we have to say that this is uniqueId JDBC?
I don't quite understand why the Keys of this Property Map are localized Strings; if these Properties are meant for being processed programmatically, I would expect Strings that don't change when the UI is localized.
please extract as constant
close streams
I think you're missing getDefaultConfigurationFile() here.
Again, use IOUtils.
I don't think the process deploy should fail in the case of temp file deletion fail
we can use try(BufferedReader...) {}
Use try-with-resources, to make the code more concise and to ensure that the reader is closed even if an exception is thrown.
It would be useful to know if i file was not deleted for any reason. Maybe add an Logcat error.
file might be a directory - message will then be misleading
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
You can safely remove the file.exists()(implicitly done by isFile
Needs some sort of assert to show it succeeded
Just for fun ... I'd fid it more readable to have a static import of Mockito.mock() (this is a complete detail, feel free to ignore).
please use static import for Mockito
This instance variable can be inlined.
@cyberone no need for Mockito.times(1)
Nit: You can use static imports for Mockito methods.
Let's favor static imports with Mockito and AssertJ, as it reduces the amount someone needs to read in the test.
new Font("Verdana", Font.BOLD, 36), true)  can be replaced by "any(), anyBoolean()" to improve readability, as you need to return a mocked font for every font which will/can be created. If you want to be certain you only return the mocked font when this particular font is created you should keep it as is.
All these common mocked objects can be initialized just once in a BeforeClass method and then re-used in each test, to avoid code repetition.
can we use the noop cache instead?
You have yo use compareAndSet
maybe we don't need AtomicBoolean?
This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)
closed.compareAndSet
minor: change SocketNetworkClient to LocalNetworkClient in line 98 and 102
Don't know if FixedChannelPool#close is idempotent or not, but it would be better if we could make closed an AtomicBoolean and call super.close() only if it wasn't called before, via closed.compareAndSet(false, true)?
Is this going to solve the problem? If I understand correctly, close() will get called one time (by the thread that is reading aggregated values out of the ConcurrentGrouper) but none of those threads actually own a ThreadLocal Grouper (the threads that own those Groupers are processing-pool threads).
shouldnt the delegate be closed or at least flushed?
Sorry but I did not find where we call the close method?
This shouldn't declare throws Exception.
Why going for semantic here ??
"plugins" could be replaced with ConfigConstants.DEFAULT_FLINK_PLUGINS_DIRS.
requireNonNull
return this.parent == null ? this : this.parent;
Please use parent.is here!
!(parent instanceof MGenericStack) || parent.getSelectedElement() == part
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Does this need to be public?
fix whitespace, format across lines  if (parent == null) { throw new ...; }
you should use a local variable instead of reallocating the argument, IMO.
minor, is it method scope for Visible For Testing? If not please change it to private.
there is no need to convert to map. can we directly print headers ?
I think we should have a better exception message, it should state that the header is not allowed to be set by the user
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Inconsistent format! space after comma
Typically we use Map on the left hand side rather than HashMap
You forgot this!
This can be collapsed to a single line.
why not null as value?
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
No need to put before/after annotation since the class is extended from TestCase, We can simply remove the inheritance from here and use the annotation, I favor annotations over inheritance in test. Don't remember why I've extended it at the first place
Please follow existed coding style and put new line after Override
Instead of an empty implementation, make this an abstract method that the subclasses need to implement
Why Exception instead of Throwable like we did for before()?
throws Exception is redundant.
nit: might want to rename it as signalShutdown or something to indicate that this method will be called before shutdown.
Still duplicated code. Let's have a single wrapper implement class for the IOItech interface.
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
This should always be read from the configs.
Why should the About dialog no longer be resizable?
I suppose this should be true ?
Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.
Why show the 'MoveUp' button by default?
Shouldn't this be reverted?
Check for the existence of the file to delete?
Is there a clearer way to do this? :)
return true? no need to inform the user he sent wrong vm (vm doesnt exist), or other issues?
should be false unless one of the vm's disks has true for this
Why is this removed?
we need to reset this property in a @Before block
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
Use junit5 instead we are thinking about removing Junit4. There is a way in junit5 to write nested tests <LINK_0>
Don't forget to disable the CrashReporter as well :wink:
Not necessary. See quality rule : MITRE, CWE-397 - Declaration of Throws for Generic Exception
@After; must handle case where fc == null
Should reset the previous version of the global callback.
How about remove the property, rather than set it.
Don't you need a super.tearDown() call here at the end?
Could we prefer a proper logger instead of System.x - we already have a logback.xml in the module.
Use Logger instead of sys out.
Debug still needed?
pvk should not be visible. Please remove it.
remove debug printf when submitting patches.
This sounds strange, can you please explain why do we need this synchronized block?
use Log instead of System.out
it's better to show any API call with this access_token
Do we need to print all this info?
Here indentation is screwed again. Just remove the whole try there's no need for this example
Assert.areNull
Please use the correct "assert" versions. To check for equality, "assertEquals"
@gjd6640 how about making this more explicit and robust this way:  int windowsOffset = System.getProperty("os.name").contains("Windows") ? 1 : 0; assertTrue(firstHighlightingData.startOffset()).isEqualTo(1 + windowsOffset); ...
there is no need to wait here?
Optional: consider using assertTrue(EXPECTED_EMPTY_CAN_DO_MESSAGE, canDoActionMessages.isEmpty())
This is problematic, because you're creating an adaptive MediaFormat (i.e. one that really spans multiple individual formats) from a non-adaptive one (i.e. an arbitrary one of the individual formats), and the adaptive MediaFormat is getting the id from the arbitrary individual format that you use. You should probably take a look at the places that call this method, and either decide to set the id to null here or allow a different id to be passed in as an argument, so you can set it to some other value, depending on what you think makes most sense.
Please use assertEquals(a, b) or assertEquals(String, a, b)
This try-catch-finally is redundant in the tests. Why catch exception and do cleanup in finally, when you could just remove the try-catch wrapping and do the cleanup in @After cleanup method?
Use Assert static imports
with static import: assertEquals(queueResponse.getPrepareResponse().getStatus(), ActionResponse.STATUS.OK); Is much better. Also, if it fails, the error message tells you more.
You can remove the inheritance from translator and make this method static. So you won't need to create any instances of EnumTranslator.
suggestion return format("metadata[%s]", key);
should use a format placeholder instead of string concat
I would prefer if you use String.format here. Also, have hyou thought of log.debug the stacktrace?
This can be problematic. createAndTranslate(..) returned constants.notAvailableLabel() for null object. while get(...) returned null. You have to make sure no one of the usages relies on this behaviour.
Use logger instead of printStackTrace() calls.
use constant for key/value separator
this initial check for null is good to avoid the synchronization check across DB instances, but it's not needed once you make the variable an instance variable. Also, to do this null check properly you'd have to make the variable volatile to ensure the JVM properly handled the fact that you're looking at it here outside of the lock.
should use a format placeholder instead of string concat
Let's declare it as private static final String?
We can't do this - breaking change for anyone that has subclassed and implemented destroy(). I suggest we use // NOSONAR TODO: remove throws in 5.2, which removing it from our subclasses.
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
The operator should be && not ||
The exception message doesn't reflection reality:  "no query or collectionCallback is specified"
Please keep this.cell near the related fields (previousFamily & cell count) below
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
for all the "waiting" items, I think we need to add "resource" otherwise people will ask "why am I waiting after I was queued".
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
missing final
Same here... completeLoadRequest(request) ?
We could just always use the body instead of flipping based on the payload size.
this duplicates code with RequestUtils and RequestMetadataInterceptor , we could extract this out by creating some method that takes HttpServletRequest as a parameter, returns a Map, then add the info where it is required
Move both to variables for consistency.
by moving from commit to apply, there is now a file write on the calling thread, but the call is guaranteed to be persisted when the call completes. Does that change your API expectations?
This can be rewritten as: java boolean exemptionEngine = request.getGatewayAccount().isRequires3ds() && Optional.ofNullable(request.getGatewayAccount().getWorldpay3dsFlexCredentials()) .map(Worldpay3dsFlexCredentials::isExemptionEngine) .orElse(false);  However, I wonder if we actually need this flag to consider whether or not 3DS is enabled. Presumably it's just going to be used inside the template and we can nest it inside a check that 3DS is enabled.
Wouldn't the usual request contain either the alternate base OR the variant type?
should be named resource
flagging that we should fix this in the next major version and move back to a parameter for the id
should be called resource
should be named resource
should be called resource
constructUrl does the encoding so no need to do it here.
Please auto format all files, so spaces are set properly everywhere
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
should be called resource
should be called resource
This needs to be changed to support locked stream syntax now.
I think this is main issue that needs to be resolved. The problem is that this implementation can consume a lot of resources because of the retrying and the long latency. It could even end up in a livelock. The best approach is to get everything done in a single remote call. There is no retrying needed here because the operation will have exclusive access to the partition.
I think it'd be a bit cleaner to move the value type check into nullSafeValueHolder.
I might be wrong but vValueHoder may itself be a null, if there was no mapping for the key.
If/Else to avoid unnecessary assignment?
I think we do not maintain key order here, which is iteration order of the elements of this Traversable. The result of toMap does not guarantee any specific key order. So we need to do some extra work to order the keys of the LinkedHashMap: java default <K extends Comparable<? super K>, V> Map<K, V> toLinkedMap( Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends V> valueMapper, BiFunction<? super V, ? super V, ? extends V> merge) { final Map<K, V> map = toMap(keyMapper, valueMapper, merge); final Iterator<K, V> entries = iterator().map(t -> { K key = keyMapper.apply(t); V value = map.getOrElse(key, null); // the default value will not be used return Tuple.of(key, value); }); return LinkedHashMap.ofEntries(entries); }
Does this mean that we get an additional object per invocation? If so, then I'm not in favor of merging this pr.
Hi, please move this method behind the next method (of(Comparator, Tuple2)) and add an additional method  java public static <K, V> TreeMap<K, V> of(Comparator<? super K> keyComparator, K key, V value) { ... }
iteratorIncludingExpired(), to match sizeIncludingExpired()?
Why is this here?
"else if" maybe?
Theoretically it would save a memory allocation and garbage collection to just return value;. Maybe Hotspot will optimise this in practice. Same in the other file.
If you check for Collection wouldn't it be better to work on the collection interface (and perhaps create a new list) instead of rely that the collection will always be a list on this place (if it is the case, then use instanceof List.
Would it make sense to add a String.class entry to POJO_TYPE_MAPPING instead?
Do we need to handle BigDecimal as well?
Need a metric for ignored large messages rate. Should also log them, not ignore them silently.
FieldData
how about making the if-tree in here smaller by checking for value instanceof Number (instead of all the individual number types) and delegate to the numberValue method (which should be moved to this _"BOXED FACTORY METHODS"_ section by the way)?
This condition is never reached, ZonedDateTime implements Temporal
Could you include a note explaining why double, char, and long aren't included?
should be logged only once, not for each block (spooling is either enabled or disabled).
extract out into a const?
what about outWriter? Move this stuff up into the blocks, so you cannot forget adding it here.
Lets' throw TechnicalException to keep the pac4j spirit...
@maria-farooq we should provide a description to the log message
lets be cautius with logger level. I dont thin kthis is error level
removed
As we removed the extraneous null here we could also use the primitive long type, right? I don't see any gain of using boxed types here. I see a lot of boxing/unboxing down in this method, so it could be simply int sid, protocolVersion; (this slightly falls into "the don't fix if..." adage, but we can ignore this for once ;) ).
You should better catch NumberFormatExceptions here (and set 0 as a fallback).
There are some project types that are not AbstractProject like Build Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstractProject that causes problems in these scenarios but those should be fixed as time goes on (hopefully) and maybe we could try to avoid those problems here. Can we find a better class or interface to check for that also has getTriggers?
This is not necessary.
unused variable
Why don't we make inDegrees to ConcurrentHashMap also?
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Why is no this. used in lines 320-321 but this. used in lines 322-326?
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
why not directly initialized?
This line has an unneeded extra semicolon.
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
Then should we just use it to save the update items?
It's safer to call getProperty("replicatorFactor", DEFAULT_REP_FACTOR). You should validate the arguments as well.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
is there a reason why this method isn't implemented?
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
I think the annotations should be on separate lines
String key -> String columnQualifier, and also update its subclass
Looks like createTopic and deleteTopic should be in the @Before/@After
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run.
This code can be called from RefreshVdcOptionCache() method too, instead of it being written there also.
I would consider rewriting as: if (values == null) { values = new HashMap<String, Object>(); _vdcOptionCache.put(option.getoption_name(), values); } values.put(option.getversion(), GetValue(option));
why not using addAll?
Maybe remove the OrConstrained here too?
Can't we ensure that we always set a List in the context and just do a cast when we get it ?
We provide 'user friendly' messages on NullPointerException, here:  java Objects.requireNonNull(values, "values is null");
Does this need to be a mutable? Could we wrap empty list instead?
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
Is this necessary? result is a set, so a straight add should actually be cheaper than a check + add - both will try to look up if the element is present.
This could be entirely done as a stream.
It is possible to write this and preserve types (e.g. avoid SuppressWarnings). I'm pretty sure it can also be written using generics (vs Object) but didn't have a chance to finish that.  public static Object[][] cartesianProduct(Object[][]... dataProviders) { List<List<List<Object>>> lists = Arrays.stream(dataProviders) .map(Main::nestedArraysToNestedLists) .collect(Collectors.toList()); final List<List<List<Object>>> product = Lists.cartesianProduct(lists); final List<List<Object>> mergeProduct = product.stream() .map(list -> { List<Object> result = new ArrayList<>(); list.forEach(result::addAll); return result; }).collect(Collectors.toList()); return nestedListsToNestedArrays(mergeProduct); } /** * @param dataProvider a nested Object array * @return an equivalent nested List */ public static<T> List<List<T>> nestedArraysToNestedLists(T[][] dataProvider) { return Arrays.stream(dataProvider) .map(Arrays::asList) .collect(Collectors.toList()); } /** * @param lists a nested List * @return an equivalent nested array */ public static Object[][] nestedListsToNestedArrays(List<List<Object>> lists) { return lists.stream().map(List::toArray).toArray(Object[][]::new); }
This should be more efficient as rows.toArray(new Object[rows.size()][] so that the list doesn't have to allocate a new array to populate
It is not necessary to test REPLICATE region in this test.
It is here that runtime.matchesFilters(pickle) should be used to select the pickles to run.
Don't we want this here?
I am wondering why LinkedList is used instead of ArrayList. Is it more efficient to use ArrayList than LinkedList?
Can we add new Object[]{3, "QA"} here to ensure it will not be a part of the output?
Are we really need this kind of Model? For what case it can be used?
There is a mix of log and log10 variable names.
Also added a try with resources here.
RocksDB reference.
remove this?
Should be added the Override annotation.
please rewrite to not use continue, harder to track code.
super.init() method never throw an exception.
Is the throws Exception needed here?
Should be removed if empty
create this in a try-with-resource statement to ensure that the walk is closed when it's no longer needed
why a NameConflictTreeWalk ?
How about:  int size = Math.min(b.height, b.width); setMinimumSize(new Dimension(s, s)); setPreferredSize(new Dimension(s, s)); setMaximumSize(new Dimension(s, s));
This used to be mBoardSize.height + 1...bug?
You don't need this line because of green 31.
nit: debug? the same for the other new logs in this file
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
return Collections.emptyList();
Selenium already has a org.openqa.selenium.Cookie. There will be lower friction with other parts of the Selenium APIs if we return extant Selenium types. I think it's fine to extend those types to be more meaningful if necessary.
Note that you can do this instead: children = ImmutableMap.of(NE, ne, NW, nw, SW, sw, SE, se); I think that you can create an ImmutableMap of size up to 5 using of() in this way.
wrap with unmodifiableSet in constructor and then just return field reference from get* methods.
It's an enum, you can use !=
Please add the 'can not recover' back? It clearly tells why we must abort the region server.
suggestion "part of a group or is participating in a rebalance right now. You should first call poll to complete " +
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
Please take into account that t could be null.
Might this be a valid spot to use package private level access instead of public? Since the test is in the same package just under engine-tests? Can't entirely recall if it works that way.
as is in 718
why do we need to pass "t" to ThrowableHandlers two times?
Suggesting to make the method private unless there is a immediate need where these methods can be overridden by subclass.
or("") should be orNull() because the default value is defined as null.
Import? I didn't see a name collision.
given/ execute/ assert
Since listener execution order isn't guaranteed, do we want to validate this this way or just .contains() each of the values?
I would add in reindexing at least one ref tag to show if it updates correctly.
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
This shouldn't declare throws Exception.
needs filling in :)
Should be removed if empty
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
Could you please explain why has this number changed so drastically?
Not worth debugging for this QS
Not worth debugging for this QS
Not worth debugging for this QS
Why does the message refer to Logged store here?
why not this String nodeSourcePoliceClass = StaticPolicy.getClass().getName() ?
nit: remove trim on both lines above.
Why do we print a secret systemUserPassword here?
Use ReplicationArn instead of Role - arn:minio:replica::28285312-2dec-4982-b14d-c24e99d472e6:exampletargetbucket
can we remove all these System.out
Seemed better before? More readable
hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm! so we cannot validate this on gwt, but I do want to validate it at core. can we have something conditional? if the isAssignableFrom works then perform validation else not? when gwt will not use these classes any more we can just remove the conditional.
Might make sense to use a RowMutation here and have the PutAdapter take a MutationApi interface
Should this use RANDOM_PORT_INDICATOR instead of 0?
I don't know if we ever call put twice for the same key, but null effectively removed the previous value in the method's "before" form, and now it doesn't.
Why not use null instead of ""?
An alternative here would be to use a Set instead of a Map and assume that membership in the set means that the corresponding event was detected. Clearing out the set is simply a call to .clear(). If you prefer Map then going with an enum and iterating over the values would be less error prone for additional states.
use USER.key() or USER.toString()
is there a reason why this statement is called twice?
logSizeQuota -> logSizeLimitPercentage
In migration case, we shall validate if stats are associated with correct writeId. I think, in our tests, it should be pointing to last allocated writeId.
Don't we have to say that this is uniqueId JDBC?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
nit, Collections.EMPTY_MAP?
studentsWhoRespond -> studentsWhoResponded
we dont need this variable, we can use _unavailableSegments in line 110 right?
I think that EntityChangedEvent is more suitable here. EntityChangedEvent is a private case of PropertychangeEvent, when the changed property is 'Entity'.
Might just be a personal taste, but I'd also prefer a for loop here:  for (Filter f : filters) { ArrayList<String> parameterValues = f.getParameterValues(parameter); if (parameterValues.size() != 1 || (commonValue != null && !commonValue.equals(parameterValues.get(0)))) { hasCommonValue = false; break; } commonValue = parameterValues.get(0); }
The 'list' is never used. Please remove it.
Update to use Security.doAs
Thanks for this clean-up throughout the code! I should probably start enforcing fcrepo4 code style rules sooner rather than later...
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
just use context as synch obj
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
To always be safe please use context.getApplicationContext()
not needed
Please remove the public modifier
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Constructor can be package now.
One more - this will be 3
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
[Checkstyle] ERROR: '{' is not preceded with whitespace.
Correct me if I am wrong, I think here should be numberOfKeys * ( keySize + SIZE_OF_BLOB_FIELD_IN_BYTES )
Aren't these static strings held and reused? We shouldn't have to charge for the weight of the merge strategy string. Actual memory used per entry is pointer sized not string length.
This should not be protected but package.
I think "debug" is better here -- this kind of diagnostic is a bit too loud for logging by default.
cast before adding to SPEED, same goes for all cases except size
remove
Remove
is Options.INDEX_ON_THE_FLY the same as Defaults.CREATE_INDEX?
I feel like there should be a Defaults.toString() or similar for this sort of thing...
Any way to combine both of these try blocks, since it's basically the same error message?
I don't think we need to retrieve a liveChatId here (lines 69-78). (The liveChatId is not used elsewhere in this method.)
Since we're changing the exposed contract anyways as we rename the file, could we fix the visibility of this function as well? I know the visibility is copied over from the old location, so we can leave it as public as well. I'll provide a separate patch set for that then.
Use ReplicationArn instead of Role - arn:minio:replica::28285312-2dec-4982-b14d-c24e99d472e6:exampletargetbucket
This needs to use a StringBuilder.
These should not be here. If you want you can log at debug or trace level, but tests should not produce output under normal circumstances.
could you reuse CentralPAPropertyRepository.PA_TEST_TIMEOUT.getValue() instead of a hardcoded value ?
Is there any other output method that you could use besides System.out ?
any particular reason why this method doesn't require an IJavaProject ?
are you sure we need to use OSString ?
I'd move this method to the end of the file, so that order of declaration corresponds to use as createOpenAction -> getSelectedPaths -> getRepositoryPath.
Overly complex. Just say: Repository repo = repoManager.openRepository(...); try { ... } finally { repo.close(); }
I still think a couple of helper methods will make the tests easier to read: private void setBare(File gitDir, boolean bare) { Repository repo = new Repository(gitDir, null); repo.getConfig().setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_BARE, bare); repo.getConfig().save(); } private void setWorkTree(File gitDir, File workTree) { Repository repo = new Repository(gitDir, null); repo.getConfig().setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_WORKTREE, workTree.getAbsolutePath()); repo.getConfig().save(); } Then the tests are a bit more declarative as they setup their condition to be tested.
default is true
I think "foo bar" should also return the same result, no? Same for "one two" below.
You should use <code>j.jenkins</code> here
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
Shouldn't we use empty list here ?
This should be 10 << 20 so that the default is 10 MiB. That allows users to specify configuration with standard suffix units e.g.: [merge] inCoreLimit = 10m for a 10 MiB limit.
This is an opportunity to stop the bleeding for this naming standard. I would suggest using the bean naming standards that archaius uses.
just return ListeningExecutorService
static
does this happen or is it an error? Maybe just throw an exception.
Should make this a DataVersions constant so it's more understandable the differences between said versions.
Suggested getClass().hashCode() as something "more random"
could this be 8? the size of a char?
For boolean field, I prefer it's Getter method like isXXX, so change the StatsDEmitterConfig#getDogstatsd to StatsDEmitterConfig#isDogstatsd would be better.
If poolSize = 1, batchThreads = 0 and we starve the batch threads. So I would instead say: int batchThreads = Math.min(1, poolSize - interactiveThreads) But... I actually would invert this. Let the admin set the number of batch threads, and allow the rest of the pool to be the interactive threads. I think its a lot easier to say what your batch concurrency level needs to be. E.g. we have X build machines, so set batchThreads = X. I also wonder if we shouldn't have some smarts about this. What if sshd.batchThreads is set but sshd.threads isn't, and sshd.batchThreads is > sshd.threads default? Should we automatically increase sshd.threads to match? Yes, probably.
given that specificity of this SV is exception type I would add the exceptionType in this.
code format
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
Are you sure that it's a good idea to have such output  ChePlugin{editors=[....]} PluginBase{name=qwe...}
minor: probably add the super.toString() output within the { } brackets, so it is clearer that it is also part of the same object? (same would apply to other toString() impls) Current version looks like this: CachedDataRecordWithStats{cachedValue=null} DataRecordWithStats{value=null} AbstractRecordWithStats{lastStoredTime=-1, expirationTime=-1} AbstractRecord{key=null, ttl=0, maxIdle=0, version=0, hits=0, lastAccessTime=-1, lastUpdateTime=-1, creationTime=-1, metadata=null} suggestion + ", super=" + super.toString() + "}";
minor: can you regenerate toString to reflect the renamed variables.
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
minor: can you regenerate toString to reflect the renamed variables.
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
Printing the query as keys will look something like: ... keys=[IndexQuery.ExistsPredicate[propertyKeyId=0]]. I think it is worth extracting the actual keys from the queries and only print those.
This will add the flag to *all* read-resource operations. I'd rather add it only when necessary as suggested at <LINK_0>
shall it also be >= 0?
If the variable name is normalized on the set() method, is it necessary to normalize on the get() as well?
just return "" instead of new String()
Might be better to have dao.exist() and call it, but OK to do that later.
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
I don't think we have to wrap the attributes map twice here (including the read-only wrapper) - it should be the responsibility of ContainerAttributes to decide what to do with the contents of the map handed to it. This can be simplified by just passing the attributes map directly to the ContainerAttributes constructor.
This is a surprising behavior...is it possible to add a function that takes a filtername and responds with 1 or 0 depending on whether the filter is applied to the genotype?
Better with query than quest.
I see no reason for the setters to be public.
are these setters used anywhere?
this works only until you maintain the order with the values. Safer is to write it like this: return Arrays.stream(values()).filter(e -> e.getValue() == value).findFirst().get();
Help me understand why lazySet is safe to use here. It seems we want to have visibility of this value when we next read, but my understanding of lazySet is that it does not guarantee that.
Need a metric for ignored large messages rate. Should also log them, not ignore them silently.
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
It's tangential, but IllegalArgumentException seems more reasonable.
use SAMFileHeader.SORT_ORDER_TAG
message needs updating: checkArgument(values.length > 0, "values must not be empty");
how about making the if-tree in here smaller by checking for value instanceof Number (instead of all the individual number types) and delegate to the numberValue method (which should be moved to this _"BOXED FACTORY METHODS"_ section by the way)?
Could you include a note explaining why double, char, and long aren't included?
this is not thread safe, nodes can be modified while building the subgraph. I suggest to use Lock for reading and writing accordingly instead of synchronized blocks
The local var is useless, you can remove it.
For objects we provide human readable NullPointerExceptions. Please add a  java Objects.requireNonNull(clazz, "clazz is null");
why simply not call BaseBackendResource.validateEnum(Class<E> clz, String name)? (instead of EnumValidator.validateEnum(reason, detail, clz, name), this why we will not have to maintain localization in two places)
Maybe add protected as modified on this and the other two package protected methods to match what is done for setValue?
input != null && input.getElement().equals(element) is sufficient now that the Node constructor refuses null elements.
Rather than instantiating the view here, I think you should just pass it to the [DatasetSourceTarget constructor](<LINK_0> That way we keep the number of places where views are instantiated to a minimum because we always want to push that as late as possible. For example, support for handleExisting will probably push that until when the job is being committed.
Shouldn't all the new methods have a protected modifier instead of a public modifier?
Does this sound good? 'Create a new aggregating set expression using a backing TreeSet using the given comparator'
Could you change the name to oldElement?
I'd still prefer to have the operation for generating the 'key' for a muted topic to be a separate function, or even embed it into the Message object. for example:  mutedTopics.add(message.concatStreamAndTopic()); ... // in Message.java private String concatStreamAndTopic() { return getStream().getId() + getSubject(); }
return void
how about  java private boolean needAck(Message message) { return message.getSequence() == message.getBatch().getWindowSize() }
Is this the intended message?
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
I would ignore empty notifications and would log warning.
Please put the elses back in here and make it explicit. Sometimes messages use inheritance and it seems possible a future bug could hit two branches.
This cannot be removed. The scheduled task needs to be saved.
What if the Site thread is idle (not receiving any message) after BalanceSPI request is initiated? Does it mean the new leader will not get notified unless a new VoltMessage coming?
This does not protect against a replica generating itself a truncation message
This is now hard to read since it combines two multiline expressions. Please break it up into separate expressions and use suitable variables for each value.
add braces
I guess this doesn't really matter but we normally use toImmutableSet so just keep it consistent?
I wouldn't have thought DoubleStream.of(argument).distinct().count() was that fast?
Same here, it could be a keyword argument. Not sure we need to cover it though, but if you eventually decide to cover it, don't forget to separate mode and padding for Pyca.
I see that one method above you check instancof ArrayList. Is it ok that you check here instanceof Collection?
Haven't we lost a branch here?
Does this function have to be that complex? You are given a function call expression, and a psi element that is supposed to be a child of an argument of this call - why all these casts, instanceof checks, recursion?
this can be set by user
won't it be better to ask if default is non null outside the loop?
instanceof Dataset is redundant
Something to think about: if all of the DataModel types have a specific view type, then you could add an additional generic parameter to MockChartDataModel for the view type in addition to the dataset. This would allow you to move the view field up to the superclass.
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
I think we are doing too much outside of View rather than finding a good way to delegate to a View. We rely on a view's underlying implementation to work, and in this case we don't even throw an exception if that assumption doesn't work (which we should). I'm fine with this as long as it is temporary, but I think we should be delegating more to the implementations rather than relying on them to follow the standard pattern.
ErrorCallback to close "busy indicator."
Add this part of code inside the if (notifier instanceof EObject) {
If we pass the path created by convert.fromKey(key) to partitionAdded rather than the StorageKey, then we don't need to expose dirnameForValue through the Accessor. I think this would be better because we would be passing the actual directory names passed to newFileWriter, rather than relying on both partitionAdded and convert.fromKey(key) to use the same implementation.
This is somewhat confusing, I'd say move the second check to within the first.
null should only be returned when the view is NOT resolved. However with the new use cases I think it makes more sense to return the view anyway, resolved or unresolved, and let the callers handle it themselves.
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
pull this out into getMockAuthorizer() {return getFileSystem().getAbfsStore.getAuthorizer()}
I think we can still end up with < max threads in the following case: there is only 1 thread doing work, rest are waiting on queue.poll the thread is going thru files or the list responses are slow. it is yet to queue up any subdir. The rest of the threads timeout and fall of their thread main
1. close() the stream and ask for the stats again, to verify they are still readable 2. call toString on opened and closed streams.
after the seek and read, can we also check the actual data in readBufferForReadAhead?
Space needed after "failed"
replace "/" with AbfsHttpConstants.ROOT_PATH
Try using AssertJ.assertThat here, it lets you declare the specific "isGreaterThan" assertion; it's describedAs() does the string formatting too.
1. close() the stream and ask for the stats again, to verify they are still readable 2. call toString on opened and closed streams.
style nit: put the newline before the && operator, so make it the start of th next line
why the name change? What does this statistic mean?
This will remove description set, please remove.
Maybe the simpler thing is to send the content type as "application/x-xsrf-token" and have the server require this as the content type of the POST body. This makes it harder for a browser to format a valid POST request using a traditional <form> tag. It also means the server won't attempt to parse the _token field from the POST into the parameter map, which means you don't need the _token hack in the CmdLineParser loop, and you don't have to worry about + or = being incorrectly handled somewhere by an incorrect escape. Alternatively we make the GET return valid JSON of {_token:"text"} and we echo that as-is using a JSON content type in the POST. Just as simple for most script language tools to work with, the client just has to strip the first line of the response body from the GET (to remove that JSON_MAGIC literal) and echo that as the POST body, with Content-Type set to JSON_TYPE ("application/json").
This will remove description set, please remove.
Why does it need any change?
check null for req?
you need to also release the req. Add something like: java } finally { req.release(); }
Inkonistenter assert-string
This should be URL encoded before adding it to the URL.
To save an RPC roundtrip, could you create a new suggestservice that does both of these queries and returns the combined results instead? I think that it is important to ensure a single RPC for an oracle since it needs to respond quickly while users are typing. Additonnaly, such an oracle could perhaps already filter groups which are larger than maxAllowed? It could also filter out the Registered and Anonymous User groups?
Please, check these changes with code style checker. <UUID> not required, you can safely remove it.
There is no need to set the local scope reference to null, but if you prefer...
I would prefer to use System.nanoTime() for such time, as it is independent of the system time and cannot be corrupted by time changes.
Also wondering the case: if Bolt points invalid streamId (not matched with parentStreamId of Spout/Bolt) so could **validation** be required? (to cover this case either **fail-fast** or **warning message** due to redundant Bolt)?
Comparing to the old code, there is a race condition now where two threads could create two streams and assign it to the stream field. That will cause one of the streams to be dangling. The questions is whether this is a significant issue and whether the contract for this class disallows concurrent calls to connect(). If we decide this is significant, we could wrap this function in an additional lock.
declaredOuputStreams is too verbose. the variable/method can be outputStreams/addOutputStream.
please remove unsed code
While we are at this, I sort of feel that readIntString() should be general enough to support 0 length strings - to have the flexibility to make certain fields in the stream optional, say. Do you see any problems with doing that?
Not your change, but could you call this variable Version1 rather than Current_Version?
minor: don't need this
wouldn't this code become incorrect if more fields were added to the flag? Is the better thing to do - read the flag, use correct bit to set this field?
matter of taste, this could also be return this.profileTypeRegistry != null;
Can you make this if clause a block by using {...}? Supposing somebody enters a new line accidentally, then this method will end by returning false always.
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
nitpick: just return <cond> sufficient
Its probably a matter of preference, but you can just do return getDelayTime(ingestTime) > TRACKER_DELAYED_METRICS_MILLIS
This pattern seems to be used very frequently. I think the state itself should know if it is the final state.
is this part necessary?
I suggest to keep the order consistent for easier reading/comparison: * field declarations in StashNotifier (maybe) * setters/getters in StashNotifier (maybe) * default values (lines 751-758) in StashNotifier::configure * assertThat calls (lines 27-33) in ConfigAsCodeTest::should_support_jcasc_from_yaml * setter calls (lines 40-47) in ConfigAsCodeTest::should_support_jcasc_to_yaml
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
Usually a dummy notifyAll without any flag in the same synchronized block will have race... Mind explain a bit what is the problem we want to fix here?
Can this be private, or is there another use case for default attribute outside the builder's call?
Same here: should be Branding, not ProductBranding
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Looks ReflectiveOperationException is good enough. Why Exception is used?
Try using StringUtils.isTruthy(this.path)? <LINK_0>
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
The number of parameters is extremely large -- creating a brittle interface and difficult to comprehend client client. Please refactor to the Builder pattern.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
Is value == null a valid case here?
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
No need for super()
calling super not needed
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
default method visibility OK?
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
I forgot to mention in the other review: It's always good to call Preconditions.checkNotNull on nullable parameters. See other status as an example.
Since the JsonCreator is on the constructor instead of the builder, you can bypass immutability by deserializing from JSON. (Or by calling the constructor directly.)
nit: Same here. Leave the checks in the switch and do the assignment at the end: this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
Do we need to start deprecating some of these cases if we are going to just combine them?
This should be cached in the constructor.
this could be handle by Map, key -> value
tiny nit: I would embed this into the conditional below because (1) we may not even need it, and (2) in case there is a long pause between execution of this and the next line. (Although optimizer may take care of both... I dunno.)
Am I being dumb, or can this method be replaced by a >= sign on the ordinal value?
If previousFormatParameters is empty you will enter this if while it used to not be the case before.
It seems like a mistake to not track payload frames.
That's nice. Could you please consider polishing this suggestion a bit more by renaming the variable to ex? The only reason we're not using it here is because we have two catch blocks
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
What happens to dst and copier in this case? try-with-resources style wouldn't try the close() again, so should we retry the close to prevent them from leaking?
AFAIK Writer::close throws IOException, so there is posibility that exception is thrown by flush method will be suppressed.
closeQuietly or whatever its called?
suggestion sharedResources.close();
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
Add the info log back after this line?
What's the purpose of this change
We are doing nothing here. Bad practice. We should let the caller know.
Why uppercase fs?
I would suggest using the related constant instead.
I would suggest using the related constant instead.
I remember I made this tests to starts cluster only once. That will improve tests time, You may want to have a look at corresponding ViewFileSystemOverloadScheme test class now.
Is this change correct? I see header is getting set with format(secondcol,2)
Do we want to check both getProjectId() and getJobProjectId() here?
need to use the removeBaseAndBucketOverrides() code in S3ATestUtils to make sure that any per-bucket setting has turned it on. Look for other uses to see what to do
where did this go?
nit: Could be this.conf = requireNonNull(conf);
This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.
I would just delete the version check from master. The logic is very simple and unlikely to cause clashes that are hard to resolve even in the unlikely event of someone adding another field in the lifetime of 7.x.
Should we add null check?
suggestion if (in.getVersion().onOrAfter(Version.V_8_0_0)) { // TODO BWC for V_7_9_0
4.2
Should be: in.skipIds(); in.skipId(); in.skipIds();
skipId
It's a pre-existing issue but I'd rather like that we use readOptionalWriteable for symmetry with writeTo, which uses writeOptionalWriteable. Or change the write logic to write booleans.
If in.line == null or in.line == 0 then in.range must be null.
This will fail when node is Optional.absent()
I disagree. It should be OK for in.line==null && in.range!=null. The line can come from in.range.getEndLine(). The problem is in.line==0 and in.range!=null. This should have been caught on the line above.
use return ... ? ... : ...?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
How big is the overhead to do this check on every log?
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
use constant for UTF-8
can we also cover that a null response comes back with content type text/plain and you get the right Optional behavior?
This restriction only applies to the event name and parameter name. Parameter values can be any string, long, or double.
Just use the ternary operator here.
pls use switch
> Before I modified, 'ByteBufUtil.writeAscii' did not perform vector optimization Help me to understand: the new version in this PR can trigger auto-vectorization here? Or, are you gonna change this part I have reviewed to make it happen, instead?
A little sanitization here would make a lot of sense, if nothing else make sure no ' ?
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
String.format might make this a little neater and easier to read.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Same error issue. I'd just fail rather than return a partial list.
I think these variable names should be changed to be the same as the field names now.
Shouldn't we add isEmpty() check for domain?
Use CharacterEncoder.getSafeText()
[nit] There is also a cleaner approach using Guava:  java return Enums.getIfPresent(LoadbalancerAlgorithm.class, value).or(UNRECOGNIZED);
Use Enums.getIfPresent like in the previous enum or change that one, but make the code consistent using the same pattern when addressing the same thing.
Send this exception to the log.
rename to segment
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
This will return true if the value is "no". Why has this changed?
can just be return pattern.matcher(value).matches();
Suppose makes sense to convert value to lower case before comparing.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
You catch only NumberFormatException which could be thrown by Long.valueOf, but timeTZOf-> checkRange could throw IllegalArgumentException that is not handled.
Can the current method be executed on an other thread than the UI thread ? The layout command might need to get the figure info wth ui thread access.
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
I prefer to use the member "instance" instead of the return value. It's a little bit of confusing.
I am pretty sure this won't work, you can't re-use the model for the popup.
could this block be simplified?  java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; }
suggestion "A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.");
Looks like we have unnecessary parenthesis here.
service id check?
@xpdavid is this the right thing to do?
private field "oldFile" has different class than "oldFile" the constructor parameter (a bit unusual)
All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);
Catch exception.
How about including Loop will be retried in the message (like WorkflowExecutorLoop's Uncaught error during executing workflow state machine. Ignoring. Loop will be retried.) so that we won't be shocked too much when server shows this message?
or("") should be orNull() because the default value is defined as null.
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
I'd be more comfortable knowing when a CompletionException is expected here instead of assuming that it's possible regardless of method and ownership.
@ndinu @alegmarra Is this correct? The expression has to always return a number
double 's' at the end?
nit: I would change this back to GitHubSCMSource.GITHUB_URL like it was before.
@XiongKezhi I guess there are multiple states of the check run that need to be tested for, Is this the only one?
Use constants
checkNotNull
With zero knowledge of the code, are you sure this object is not reused? Because if it is a scheduled task it be just reset rather than recreated, but you cannot reset the telescope client, you'll need a new one.
Which type would be assigned in this case?
Why don't we make inDegrees to ConcurrentHashMap also?
Doesn't this mean you'll have a single reporter for the whole life of the worker (and a single reporter means a single task I think?) I thought it had been talked about having a new task every hour or similar?
Why is no this. used in lines 320-321 but this. used in lines 322-326?
Given you are on this class, it might be worth changing the constructor to private and making a static factory method to bring this in line with the code style. Leaving the campsite a little cleaner than we found it every time and all that.
Then should we just use it to save the update items?
perhaps pass along the entire BaseIndexOptions to be more future-proof?
the workspaceitem needs to be deleted
Why Exception instead of Throwable like we did for before()?
Instead of an empty implementation, make this an abstract method that the subclasses need to implement
Can you assert the container has the right name?
nit: might want to rename it as signalShutdown or something to indicate that this method will be called before shutdown.
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
suggestion list.setSourceList(new ArrayList<>());
create a member for ClusterServiceModel
You should access the attribute directly
Since the VM subtab always uses this query, I would encapsulate it inside VmAffinityGroupListModel and make its constructor no-arg.
final?
Binary output length can also be calculated.
If the partition being replicated is sealed, should we reflect that here? (Not sure if we have that info available.)
Why is this not singleton?
You don't need to override this, every Spark 2.x distributions support kafka on kerberos regardless of the value returned by this method.
Is this supposed to be true?
why not protected, use only extended
isn't this changing the default behavior?
I prefer this == NON_BLOCKING
Nitpicking this change here - isn't this antipattern?
You may also want a test case for a search value that is non-blank but invalid.
This should be public
Have this call the other tryEvaluateWithAll method
we should have another vowel check for columnType.
We need indefiniteWowel1 and indefiniteWovel2 as we have _two_ types.
Ops.. the same line twice. In fact, verifying getters being called does not test what the method really does. The method is initialising the this.constraintValue and the this.constraintType, I think we need to assert that.
indexTypeMap.computeIfAbsent?
shall we do the check like **"int".equals(expectedType)** . So that we can avoid null check at the beginning.
I am confused. If argType is BackendIntegerType(), than argType will not be VoltType.Decimal, so is check " argType != VoltType.DECIMAL" necessary?
Also catches IllegalStateException from getActiveInstance(). Maybe OK
Can be reduced to throws IOException.
Can be reduced to throws IOException.
I would add the other createTempFile method to enforce the fact that we explicitly target this one only.
other than the previous implementation in subclasses this doesn't create the directory anymore.
dare to extract a constant which increases visibility for this hard-coded value?
Never use printStackTrace. Here there's no need to catch at all as the method already throws IOException.
This isn't right given the method signature of the base method -- name should be used in some way. If you want to pass in the full path to the db file, then I think DatabaseContext needs to be redesigned.
libJars might throw NPE. Please check for listFiles != null
photonDirectory should be created before esDirectory
This file needs to be created (with touch or similar) under docs/sphinx/examples to prevent a NPE.
Should we add null check?
Assert there is no JPrimitiveType in types?
why do we have a ; here?
Remove ?
remove redundant ; it will only cause static analysis to complain
If the code fails to close in, it will never try to close out
for such change. If the code fails to close in, it will never try to close out
previous naming was more clear.
style guide
skipId
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
copyright
needs filling in :)
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
Should be removed if empty
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
This shouldn't declare throws Exception.
Why is this exposed to the things implementing PushingAsyncDataInput? I guess to make implementation easier? I mean, there should be no reason for StreamTaskNetworkInput or StreamTaskSourceInput to call output.endOutput(), as the runtime can do it for them and it can only lead to bugs if the method is called prematurely. Maybe there is an easy way to hide it from the emitNext()? Like splitting into two separate interfaces?
Can you revert this and keep the explicit exceptions.
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
please replase MojoExecutionException for a new generic DeploymentExecutionException
same as others: log should have Exception as arg
Consider using getField() instead, ~~it's implementation in OpenJDK 8 seems more performant.~~ Also the semantics of that method apply better in this case, since it is a public field. _Edit: can't confirm first claim_
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
I don't think we need this catch - this is handled by the boolean return value.
Same error issue. I'd just fail rather than return a partial list.
Why not just throw e;? (granted, this one has a slightly nicer stack trace)
Should this be logged at more prominent level ?
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
KETTLE_LOGGING_REGISTRY_PURGE_TIMEOUT should probably be a constant in Const.java for consistency with most other kettle params. I know KETTLE_MAX_LOGGING_REGISTRY_SIZE was already there before, but should probably also be defined in Const.java.
Which type would be assigned in this case?
Why don't we make inDegrees to ConcurrentHashMap also?
Then should we just use it to save the update items?
I don't think it is possible to have global stepping field. I don't see how that can be meaningful.
explicit type not needed
could you elaborate here a little bit more why for appendblob the max concurrent requests is 1?
perhaps pass along the entire BaseIndexOptions to be more future-proof?
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
In my testing on Linux I see another SWT.Selection between MouseDown and MouseDoubleClick?
I think we should remove the following events
This should be an @Override of implemenatioin super type..
I would remove all these events after the SWT.MouseUp. They aren't normally sent when you only select an item.
If it doesn't have the right coordinates it's probably not useful ;)
!(equals)?
Do you think we should allow modifierKey == 0? And only check if it's a modifier key if it's not 0? Is there any chance that the special handling of this method would be required in some cases with a normal click? It's still fine that click(int, int) doesn't call this, though.
Statemask for DefaultSelection is as follows- win(BUTTON1), linux(NONE), mac(NONE). Here BUTTON1 will be sent for macOS which is not the case.
this, otherwise it prints Canvas {*Wrong Thread*}
I've always been slightly confused by this - is this only used for the pause before we start sweep? If so, it might be better to defined the backoff time you're adding completely separately from the definition here, unless it should always be 5x this one.
14_000_000
You should be returning the values returned in getCalculatedProlepticMonth() here instead (ie, that leap-day is accounted with the 7th month, and year-day with 13th). Ditch the other method.
Can we get some more information on the magic numbers here?
(ONE_BILLION_L * fClockOffsetSeconds * getClockAntiScale())
I think we should prefer accuracy over speed here, and use a BigDecimal for all these calculations. It won't be noticeably slower (I don't think anyone is calling this every frame or op!), and it would allow us to provide better guarantees about the results of the method.
Feels a bit odd that we specify the average maximum but don't really control the actual maximum - I think we really want to control the maximum and have that be 30. You could either cap everything at 30s, or take 30s as the maximum, then calculate 2/3 of this and apply the +/-50% from this value.
@decarbonization: i think this should be Math.round(0.25f * temperatureScore + 0.25f * humidityScore + 0.50f * soundScore) coz right now Math.round(0.25f * 90) + Math.round(0.25f * 90) + Math.round(0.50f * 90) returns 91
Replace repetition with helper function. E.g.:  private int toEmbroideryUnit(float value) { return Math.round(value * DSTFileConstants.STITCH_POINT_UNIT_FACTOR); }
simpler to say meanY=r-meanX rather than recompute tan
As there's no extra handling when an IndexOutOfBoundsException is caught, both old and new code behaves the same way: any exception thrown by logicalPages.get( page ) will always be thrown back! As so, the try-catch is dispensable and it's best to leave the code as it was.
Duplicated code, try to share/reuse.
Duplicated code, try to share/reuse.
I don't think that throwing an exception is necessary. In majority of other places I think we have just empty private constructor.
Why not inject it using guice?
I think it should be IllegalArgument exception, rather than IllegalStateException.
@super132 we can init decrypt/encrypt ciphers in Ctor, no need to create this each time.
@super132 we can init decrypt/encrypt ciphers in Ctor, no need to create this each time.
@jrdalpra we also need negative test cases here like e.g. it is still not allowed
Perhaps this should read something like: "Change is codependent on changes which are not submittable"
get rid of "..." not enterprisy!
Can use java 8 paths.
Is there another place where we can define this, so that this does not need to be defined in RealVoltDB as well as here?
remove whitespace
Remove throws Exception
there is a lot of code which is already for "WINDOWS", so try this: chormeBinaryName = (OSName.contains("MAC")) ? "chromedriver" : "chromedriver.exe"; then reuse this code for both systems: File chromeBinary = new File ( - "." + File.separator - + "src" + File.separator - + "test" + File.separator - + "resources" + File.separator - + "ChromeDriver" + File.separator - + chromeBinaryName - );
"components.repo" and other system keys can be moved to constants.
Why are you calling super.init() and uploadApp() here ?
check if there is other way to check right access
.toString() is not needed here
move this line before above line, After super.cleanup method couldn't do any of the server requests.
As noted above, just put the init code in init() unless there is a reason not to.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
super.init() method never throw an exception.
Throwing the generic Exception ?
Lets use super.cleanUpUsingRest() here
Lets use the previous cleanUp method as discussed.
we need to reset this property in a @Before block
is super.init throwing the parents class Exception? Whats throwing Exception within the init method ?
not needed; just cut it
You should use ThreadContext.putAll() here.
Unnecessary (and incompatible); revert.
Typically we use Map on the left hand side rather than HashMap
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
Same question
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Like below: putAll instead of loop.
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
why not null as value?
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
Do we need to swap expected and actual here (and also for the next two as well)?
please remove this "assert", it is not required , it will do no good in future updates.
Don't think the "Tenor" in the toString adds any value now. Merge toFormattedString into toString.
@shelan so no need to declare every method as final
filename should not be null according to interface (or do we want to allow it?)
Maybe let the stop() method throw the exception instead of catching and printing?
Is that safe to call when not holding it?
I think Long.MAX_VALUE is too long. How about using 1 hour?
this should be like other errors.. create EngineError key and a corresponding message in vdsmerrors.{java/properties} files then throw a EngineException with this key
"Initial connection"?
forgive my ignorance, but how does this solve the issue? Isn't there still the org.hibernate.Query vs org.hibernate.query.Query issue in the source code?
unsafeSubscribe shouldn't call the ERROR_HANDLER.
We should at least log a message in case the executorService fails to terminate on time.
@luck3y I believe these fixes in this file and EmbeddedHostControllerFactory should all use EmbeddedLogger.ROOT_LOGGER, and the *existing* uses of ServerLogger in EmbeddedHostControllerFactory should switch to using EmbeddedLogger. (AFAICT the ServerLogger messages used there are not used outside that class so they can just move.) The EmbeddedHostControllerFactory change perhaps being a task for you, not necessarily for this PR. WDYT?
Multi exception catch and usage of ReflectiveOperationException.
:smile: We prefer to use fail("BeanDefinitionStoreException expeted.") within try...catch
I think your tests would be cleaner and more clear if the validation methods returned true/false instead of throwing an exception. If there is a good reason to keep the ValidationException then I think it would probably make more sense to have a boolean local variable here, something like success, that is initialized to true and then set to false on catch. Then you would have a single assertTrue statement at the end: assertTrue("The counts should be been the same.", success); The same goes for all the tests in this class.
y not use @Test (expected...)
What is this for? Feels like some unintended checked in code?
You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure
ditto. Doing nothing here is bad
Asserting inside the sub-thread won't fail the test. Should probably refactor.
Use the narrowest exception required, I think in this case you just need ApiException
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
could have a loop for the -r opt, where it tries -p,-e,-s, and -s -e. Could also have a loop for the -p opt. This would try all combos, I think the current test misses some combos.
You can use try with resources here so the Input stream is closed automatically.
Is it OK to swallow this entirely?
@xxDark can you link to the spec where all of this is explained ?
Add message to new RuntimeException
I guess all this (and the finally/close) can be simplified with try-with-resources.
Use Assumption.fail and Const.EOL.
Maybe we should log both success and error while recovering with service name
do we still nee line 390
Could we add something like: if(System.getProperty(PROP_UUID) != null) { return System.getProperty(PROP_UUID); } Then product creators can disable by setting the property to whatever value they want.
Multi exception catch and usage of ReflectiveOperationException.
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
We mustn't use .get() as it can cause freezes to the whole chain of computation, it is probably worse than a synchronized list.
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
this feels like it violates the fluent workflow, is there a way to make this work inline with the fluent query runner?
This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.
.endsWith("'sParty") has an implicit semantical meaning and therefore should be put into a dedicated method. I'd guess something like boolean isOwnPartiesChannel(String name) But just comparing the end of the name sounds really... odd?
Should this method be private or protected?
Racy. Maybe just chuck a synchronized on.
Please put the elses back in here and make it explicit. Sometimes messages use inheritance and it seems possible a future bug could hit two branches.
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
call equal on constant
I would ignore empty notifications and would log warning.
make the constructor package private instead of private to avoid going through a generated synthetic constructor.
This does not protect against a replica generating itself a truncation message
What if the Site thread is idle (not receiving any message) after BalanceSPI request is initiated? Does it mean the new leader will not get notified unless a new VoltMessage coming?
Delegate to isNonCodedDrug() when making the check.
Remove?
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
delegate=true style would be just fine.
You can use MoreObjects::toStringHelper().
toString looks wrong: will say "private-key" whether or not there is privateKeyData, and will say "public-key" if there is no publicKeyData.
Why change it up? I don't like it like that, because for me that's not really readable.
Variable names must start with lower case. Also make this hostId, instead of host because that is more accurate.
Maybe rewrite this thing to y = getYRegenOffset(i, regenOffset) and also replace the upper if with that call to keep them unified.
need to remove this print or convert it to log stmt
Shouldn't options be Immutable?
throws TaskException is part of the interface, did you mean to remove it?
Is it useful to keep the Exception generic, or should we narrow the Exception type on the interface?
Does this need to be public? Please do not introduce new public members without cause.
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
It should be repartition job
Don't we need to fix up the ID and timestamp, like is done in read() ??
A warning message with the actual property being checked (DELETE_HANDLING_ACTION_OPTION) and the value that we have no enum-value for would be useful.
/cc @manstis could you kindly advise, following this PR discussion, on the UI/authoring functionality if the DMN Import element needs to be converted to _its own node_, or is just sufficient for it be available inside the Definitions' "main" node graph, please?
Config class have constant defined for default config file name
The <Integer> can probably be omitted.
EmptyConfig.INSTANCE?
It seems that all we should need to refresh the schema is the config name.
please remove empty lines before } lines in this class
As an improvement over current state of this test, could initialize config with smallInstanceConfig() (also use the same in MemcachedMultiendpointTest)
Can we show that this method is not supposed to be used directly by consumers of this class by making the method protected?
pls use formatter
In these properties, I think we can replace the word "PAGINATOR" with "PAGINATION".
Does this make Font Awesome the default font for all text? That doesn't seem right?
Can you please compare something else than integers (String will be ok)? Silly code change in assert method can break its logic but pass this test because both index and value are 2 :)
Not sure if it tests "immediately", this test passes without changes in this PR. Maybe you can avoid going to another thread and awaitTerminalEvent()?
Could be inlined here by using test()
better to check values
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
assertFailure()? it also checks that no completion events were emitted
Maybe just Completable.error(e)?
Should you use RxRingBuffer.SIZE here?
A non-void @Test method? I did not know it is valid. Not sure what the intent is though...
Rename method to "hasPathways", which is probably clearer and avoids negation.
This needs an @Override annotation.
style nit: s/if(/if (/
This is fine, but why did you think of changing it to protected ?
missing @since tag
Include the file:// as constant.
File.separator
externalize the message using JGitText
This isn't right given the method signature of the base method -- name should be used in some way. If you want to pass in the full path to the db file, then I think DatabaseContext needs to be redesigned.
This can be reduced to java if (!new File(path).isAbsolute() && relativeTo != null) { return new File(new File(relativeTo), path).getAbsolutePath(); } return path;
style nit: we don't use curly braces around single line blocks
consider to inline uris
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
this.
You can use CollectionUtils.toImmutableList
You can iterate only once on the lit of symbols and collect everything: java methodTree.parameters().stream().map(VariableTree::symbol).forEach(symbol -> { parameterNames.add(symbol.name().toLowerCase(Locale.ENGLISH)); parameterTypes.add(symbol.type()) });
you don't need to collect inside getMachineNames if you stream it again on next line. Just return Stream or maybe getMachineNames is not necessary here and just inline it. If you want to split the long stream chain I would maybe do something like  Stream<String> machinesInPod = containers.stream().map(c -> Names.machineName(podMeta, c)); return machinesInPod .map(....
refactor this into a method please. I mean the part after versions ->
I am not convinced that using the stream API here is the right choice. What we are doing is to do computations with side effects. For that I would always prefer a traditional for-each loop.
nit: we don't generally declare unchecked exceptions suggestion public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {
Nitpick: startingCounter?
You increment just one of the counters. The total is produced by prometheus automagically. So basically, we could have: starting_attempts.total#debug=false and starting_attempts.total#debug=true and just increment one of them here. We would not have an untagged counter at all.
This is using the default locale when converting to bytes. Not sure if that is a big problem since changes of the locale should be fairly rare and under our control, but still..
Due to a bug in GWT this doesn't work in Firfox [1]. To make it work with all browsers it should be: event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER [1] <LINK_0>
Do we need to remove the reservations here if the member is no longer the replica after rollback, same as for record stores?
Is it needed? If instance(CircuitBreaker) is made from registry, instance has not only instance's tag but also registry's tags. So I think it can be addMetrics(registry, circuitBreaker). What do you think?
I am not following here - why do we want this in sync block?
Could we please use <LINK_0> ?
What is the purpose of this conditional?
When is it possible that PrevStatus is not STOPPED but status is STARTING?
Type casting again.
Type casting again.
Using a try .. catch block instead of pre-checking with contains is bad code style and also not very _fail fast_.
Change error string as well. You are not checking for text == null here, but error says you are checking text. Same for all similar ones below
- space after comma - you need to pass the source duration as well
why not use the mappingContext? mappingFacade.map(source.getFirmwareFile(), Firmware.class);
Assert.notNull()
Maybe add an assert as the other definitions are using it?
There is no use for creating new util methods to create ProductData instances. You can create a ProductDataTranslatorTest instance and call initSourceObject() instead
Typo in destination.
Could this potentially be shortened? return acceptHeader.length() > BROWSER_ACCEPT_MAX_LENGTH ? DEFAULT_BROWSER_ACCEPT_HEADER : acceptHeader;
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
Collections.emptyList() seems cleaner here.
Not for now, but I think every concrete subclass of EpdqPayloadDefinition probably knows enough to add its own operation type as a constant rather than it being added to the data passed to it here.
Why is it a list of lists, not just a list?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Please use diamond operator, you don't have to repeat time a second time. ArrayList<Integer> a1 = new ArrayList<>();
invokeAll on an empty list returns null. So you may want to handle that
I know it's trivial, but would be much nicer if this mapping was extracted to a separate function.
the HashMap declaration doesn't need to be parameterized, HashMap<> would be sufficient. Same with terms and depts
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
We can slightly simplify: java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType());
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Simplify it please, you know I hate nested if/else
This test should contain assertions. At least to verify the existence of the variable a in each scope.
That should be toHtmlForAnthology. You mixed those two up.
What else can this be?
@bkmeneguello Are you sure that <code>!=</code> is correct?
Note that it will be returning it for Pipeline. "In progress" may help here
We should still be able to set the dialog's title (?) In this case, title is always dynamic as it comes from UI plugin API function call.
This could be: filterListEditor = createFilterListEditor(); filterListEditor.hideLabel();
Remove public
I would add: setAlertType(AlertType.INFO); So you have a default of INFO for messages that don't specify.
view should never be null. If anything the contract should be enforced in the ctor and the check here removed.
I think these lines are unnecessary since these elements are always empty on initialization.
If we turned initWidget into the constructor for version 2.0 would that not work better?
this seems off. Isn't this widget generic?
Why use a FocusPanel here? Doing so creates an extra focusable element so when Tabbing through there is an extra stop, and it doesn't have a meaningful accessible description nor obvious purpose.
Do we know if we're in packrat mode? If we do, can we disable or hide this in packrat mode (since it doesn't actually do anything there)?
rename to contribution
rename to contribution
enableEditingButtons(..)
rename to contribution
I noticed a behavior that I am not sure is correct or not. If you apply a filter, then uncheck a parent in the filtered result, it will uncheck all children of this parent, even those that are not currently visible due to the filter. If that is not what we want, a possible solution would be to: 1) here only uncheck the visible children 2) when the filter is cleared, recompute the check state so that the parent will regain its checked state because it now has visible checked children. What is your opinion about the intended behavior?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
rename to element
Rename to something more readable, e.g. showButtonsBasedOnPerspective or even shorter showButtonsByPerspective
Strange formatting; could be one line?
rename 'child'?
Why do we have this constructor?
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
I really don't like this convention because it means that we can no longer rename-refactor the identifiers without changing the meaning of the program. It is in effect a very subtle kind of reflection. So I would prefer a distinct string field in this case and others like it. I realize that there's lots of this kind of thing in OCS, but we should fix it when we encounter it. Does this make sense?
public @Nullable String...
just return "" instead of new String()
suggestion super(() -> name);
I'm updating this PR since I would like to merge it before tagging the next release. Thanks for the fix btw!
return null to make this more explicit ?
Better be cooperative-sticky? cooperative is too general I think.
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
nit: language is not supported: %s ?
Using a static map would be easier?
Put this exception in the default branch of swith.
curious: why remove anyTree?
nit: does this need to be public?
This can be reused by declaring static member.
Use a static import here, it's already imported
IndexModule.getIndexType(dbInjector) == IndexType.LUCENE
I would change the message a bit to: "Types mismatch for query: \n " + actual + "\n:"
Typo, "by" should be "but".
can this just be boolean instead of Boolean?
Add TODO to not forget implement this in the future.
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
can you add to Builder as well
The code can be simplified to rely on autoboxing.
There's no reason to box.
No need to get the property from System, the property is in the server-config.properties, so you can inject the property value in the class (${crafter.engine.preview}).
That doesn't look right
Same potential NPE as above.
Add note of parameter [PostGIS DataStore](<LINK_0> doc page.
.hasSize(), 2
This is not time zone?
isNull()?
isn't this the same as if I would have imported the method from Either? @danieldietrich, what's the take on that, is this meant as a shortcut for only importing the API?
Can be static (and following ones).
Interesting wrapping style :)
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
This is inconsistent with the other tests but I'm assuming we want to gradually move towards using AuthCardDetailsBuilder rather than AuthUtils (how did we end up with so many different ways to build these objects?!)
are we missing an assertion for serviceReference here? should it be null/empty? or will it be generated?
Revert when you have reverted the fragment.
Do we need to null check event.post here?
This line is redundant.
We can drop final PostModel post = event.post; at the top of this method.
is it not empty if for example type is an valid empty string?
please move the isEmpty methods to the scimSchema
wouldn't it be enough that one of these is null?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Shouldn't we use empty list here ?
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
just reset to null
Is this signum call really needed here? compareTo should already return the correct value.
Also, there's no zero comparison covered?
I suggest using "ComparisonChain.start().compare(o1.name, o2.name).result()" - Location.name can be null.
you should use Integer.compare(o1.., o2..) here, since this method should return either -1, 0 or 1.
It's probable that the original intent was to avoid the overhead of Float.compare which will call floatToIntBits to do precise equality ? We could maybe switch to the following logic: if (o1.weight > o2.weight) { return -1; } else if (o1.weight < o2.weight) { return 1; } else { return 0; } To make it clearer for findbugs that we don't care about exact equality? This is only used for ordering and I think it's fine to treat 2 weights equal (for ordering purposes) if they change by just epsilon.
Making sure I understand it right: this ranking is specifically for bandwidth allocation, which is why we prioritize first by ideal height, and then by speaker rank?
Inconsistent indentation, and with the cast I don't find it any clearer than the original. Please revert this change in this file.
Should be "else if (o2 == null)" only, shouldn't it?
This could be condensed to one-line lambda, if updated to the latest version of fastutil library
Nice fix. At first glance I see no problem with transitive and antisymmetric property. LGTM.
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
The editor can't be null
I think this should be replaceFailed = false instead.
Which tests fail if we don't have this line?
Does this need to work across source windows? (If so, look at DocFocusedEvent and SourceWindowManager.getLastFocusedSourceWindowId)
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
When would this be the case?
Looks like these two typeTextIntoEditor commands can be united into the single command:  editor.typeTextIntoEditor("\n\nobject = MyClass()\nprint(object.");
Constant
Why it was removed? It was an important check - ensure that there are no error markers just after the **AppController.java** has opened, wasn't it?
getFullName()
I think we just want the name and not the email in the message. But username is always null to us (for example), you need the DisplayName.
I think the setMaterializableResourceProperty should handle the materialized scenario itself. This means that this method can simply invoke setMaterializableResourceProperty(ACCOUNT,account); and then, the internal code of setMaterializableResourceProperty will check whether the account is materialized or not and then will relay on setResourceProperty(ACCOUNT,account); internally.
name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "".
I think you can do this shorter: return account != null ? Objects.firstNonNull(account.email, Strings.nullToEmpty(account.name)) : Strings.nullToEmpty(group.name);
Is username case sensitive?
remove mRoles
This should be .equals() instead of ==?
is the adjusting of the version required after the removal of snapshot version from equals()?
Should there be a test that verifies that not assigning an external ID doesn't try to assign the external ID again?
Don't need the hostAffinityEnabled check here. You can assume standbyContainer is present only when host-affinity is enabled.
do u need to guard against NPE's anywhere here?
I would suggest extracting the format as a constant and hardcoding some of the format constants instead of doing it the other way. e.g.  CONTAINER_HEART_BEAT_SERVLET_FORMAT = "%s" + "/containerHeartbeat"; CONTAINER_EXECUTION_ID_PARAM_FORMAT = "executionContainerId=" + "%s"; CONTAINER_HEART_BEAT_ENDPOINT_FORMAT = CONTAINER_HEART_BEAT_SERVLET_FORMAT + CONTAINER_EXECUTION_ID_PARAM_FORMAT  Or some flavor of the above, so that you can reuse the format across the unit tests & other places in code. IMO, having the constants by themselves still forces users to figure out how they come together and repetitive code e.g. "%s%s?%s=%s" with readability hit as well.
We can do null check and assignment in one line: this.uuid = Preconditions.checkNotNull(uuid, "uuid cannot be null"); same for others.
Update container-placement-metadata before making a resourceRequest, so that the allocator knows what to do with the resource?
Minor: StringUtils.isEmpty?
+1 expose single synchronized methods for reads and writes to the control-action-metadata. All accesses to control-action-metada should be from those methods; can optionally add logging in those methods.
Can localityManager or readLocality results be null?
Any particular reason we need to augment config with processorId? seems the processorId is passed down to both containerController and jobCoordinator.
The current flow doesn't set the job as healthy in the event that all the containers are from the previous attempt and there is no necessity to spin up a new one.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
return Arrays.asList(boolean.class, Boolean.class)
return Arrays.asList(....)
Collections.singletonList
Collections.singletonList
Collections.singletonList
Collections.singletonList
Collections.singletonList
variable is not needed
Should be an iterator assertion, e.g:  assertThat(Arrays.asList(ITEMS).iterator()).hasNext();
close already done in Util.read(..)
here we should guard against null is
Since we don't usually run with assertions enabled, please consider converting assert to Preconditions.checkArgument.
same as above, is it necessary?
it seems that the first part of if statement is only good for improving performance, but this isn't a performance bottleneck. is it needed for anything else?
It's not a good design pattern to close resource-parameters in methods. There are the following converntions (which may violated in certain cases) - If you pass in a resource, the caller is responsible to close it - If you wrap a stream (e.g. new BufferedInputStream(is)), closing the outer stream will close also the inner. You should fix that resource leak at the caller side, there is only one in io.ebean.config.properties.Loader: java void loadYaml(String resourcePath, Source source) { if (yamlLoader != null) { try (InputStream is = resource(resourcePath, source)) { yamlLoader.load(is); } catch (Exception e) { log.warn("Failed to read yml from:" + resourcePath, e); } } }
Remove debug info?
you have lost the cause e
You can use is = InventoryUtil.itemOrEmpty(is)
Sorry, I seem to be having trouble expressing myself clearly these days. I meant to say, "Does it make sense to add resetEntity() to BuiltResponse.setInputStream()?"
Now this method does not do as it's named...
you should have here setSucceeded(true) IIRC.
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
This method needs to be implemented in LexerATNSimulator as well as ParserATNSimulator.
This doesn't need to be public it can be protected.
Recommend throwing UnsupportedOperationException if the disk methods are called.
Should this not do something like ErrorPopup.showMessage( ProjectEditorResources.CONSTANTS.NoRepositorySelectedPleaseSelectARepository() )?
I'm not sure I like the way it would work. You mean that before every request, I would have to call "login"? Doesn't sound very user friendly.
As this method isn't implemented for a merge request why does the MergeRequestBuildAction extend the BuildWebHookAction at all? This class still just needs to implement the WebHookAction interface. This will make the BuildWebHookAction obsolete as you can move the processForCompatibilty stuff directly to the PushBuildAction.
DEREncoder shouldn't be referenced from ASN1Encoder - the implementation of this method should just be moved to DEREncoder.
nit, just make this real instead of mocking i.e. () -> FALLBACK_INT
Wouldn't it be better to not mock this ? This way we will test filtering. In ACUnitTestBase you have method to create Patient, so you can build a list and see if the filtering returns proper list.
Let's have some constants here instead of repeated magic numbers.
use a constant
I've been meaning to ask you if there's a class I can actually instantiate, thank you!
I'd be nice to keep parameters split on different lines.
Consider replacing with Arrays.asList(labelField, textBoxField, valueLabelField).
getUri() should remain as is. (so why does this work?)
Please use just when(state.getActiveGridColumns()).thenReturn(Collections.singletonList(uiColumn));
when(state.getActiveGridRows()).thenReturn(Collections.singletonList(uiRow));
Wouldn't it be nice to check the path was observablePath rather than _any_ path?
unsubscribe()
We could cover it with some tests.
This check is redundant because you check this in handleSelection()
Is this intended to call getRenameValidator() while building delete action?
I'm pretty sure we use IllegalArgumentException for these everywhere else.
Looks to me like the last parameter never does anything, but not sure if there is some location that uses it and it is just not in the diff.
Do we actually want to request it? We don't handle it, right?
I think we should be stamping the submit record that was accepted by the submit rule, not all existing approvals.
I think ternary operator would be easier here as well.
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
only EE product can have runtime lineage
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
The code can be simplified to rely on autoboxing.
No need to get the property from System, the property is in the server-config.properties, so you can inject the property value in the class (${crafter.engine.preview}).
can you add to Builder as well
Why this? Why you need a third state? true / false / undefined? Why not just keep it boolean.. either mask it or not... Besides.. if you really need the third option.. I would make DEFAULT_MASK_PASSWORD = null; instead of returning null here. I couldn't understand why you need it.
Don't you need a cast to byte: "byteBuffer.get() == (byte) 0"?
Same potential NPE as above.
Add note of parameter [PostGIS DataStore](<LINK_0> doc page.
Check the env variable before returning true.
Check env variable before returning true.
This should check the environment variable before returning true.
you should check hasImages in canDoAction and if not skip all these validations
findbugs will tell you that JenkinsLocationConfiguration.get() can return null
java.util.Objects.equals(Object a, Object b) ?
While we're removing validators that just return true, consider fixing validEmail
For easier maintainability in the future, I suggest having curly braces for this if condition.
This is wrong. While yes, the "return true" could be made static, this is inherently meant as an instance method (thats why the TODO). We could either give it an instance field with a fixed value, or suppress the warning here...
While you are at it, maybe you could also change the .equals("") to .isEmpty()?
We should close the FileOutputStream, relying on finalizers is very finicky
I wonder if this is really necessary... jansi uses [isatty](<LINK_0> to avoid writing the escape codes when output is redirected.
I don't like the word "command" in "where the WES command should run". If anything, you're sort of running the (client) command on your local box. How about The URL of the WES server, e.g., ..... Also, I think you should say URL, just to be consistent with --wes-url; right now it's a mixture of url and URI.
Prefer to put these two lines inside the "if (expansionNum ==1)" statement.
Same as below; let's use the parcelable methods
This if-else can be removed if we go w/ boolean instead of Boolean for wheelchairAccessible. Wdyt?
Do we need to print all this info?
Would it be possible to delay the decoding further to when it's actually used? For NLJoins we serialize the operation in order to clone it, so we'd be paying the overhead anyway.
Missing RU support?
Why do you delete it?
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Instead of using the message, evaluate the topic to generate a good string message
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
unnecessary parenthesis?
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
will delete then add instead.
Are you sure we need that condition? Are you able to cover it by test case? The null-test was not present before and I can't see any test related to that.
Why is it a list of lists, not just a list?
Style issue: @Override shuld be on line above the method declaration
We don't need another ImmutableList.copyOf. You are doing this when parsing.
null? why not just a () -> {} ?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
When you changed the code to also provide the old API, you should be able to revert these changes.
@katmatt i'm not sure you are right person to ask, but at least you could refer me someone else. My question is: don't we want to update assertJ dependency from currently used _3.3.0_ to the latest _3.8.0_, it is 1.5 years since that version and now it has a lot of handy tools, like arrays comparing (including ordered or unordered).
<LINK_0>
I know it's trivial, but would be much nicer if this mapping was extracted to a separate function.
You can use GenericMath.DBL_EPSILON here.
Does a straight comparison work here? NaN isn't usually equal to itself.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
Not needed, part of constructor
Will the device ID always be 0?
I would put this on the failure path: if (!d.mkdir()) { if (skipExisting && d.isDirectory()) return; throw new IOException(...); } Because odds are the caller wants to make a new directory and we can reasonably assume it doesn't exist yet. If it does, we'll fail on the mkdir and check its mode, if its a directory, we're fine, if its not, we fail.
This throws the _other_ CancelledException.
can you please extract refactor to a separate patch?
Prefer DoubleStream.of() to Arrays.stream(). Clearer.
argument validation?
Why is this removed?
Will not delete directory. You should FileUtils.deleteDirectory
I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.
if (realm != null) maybe - just to be safe.
tearDown() should call super.tearDown(); try { mHandlerThread.quitSafely(); } finally { super.tearDown(); }
why synchronized ?
we need to reset this property in a @Before block
Should this have been reverted too?
here should delete users as well as databases because users are not associated to a database in PostgreSQL.
Should reset the previous version of the global callback.
DEFAULT_HTTP_TIMEOUT?
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
I think this method has no need to be static
same, I think this method has no need to be static
input != null && input.getElement().equals(element) is sufficient now that the Node constructor refuses null elements.
The Tracer and TracingContext are only present when the channel is created with them, so you'll have to check whether the Tracer is null and fallback to the previous behavior.
Why this change?
I don't like these kind of names with numeric suffix.
Here we are changing a bit the behaviour of the exception handling compared to what is currently in the master. The change seems reasonable, but I want to point it out for future reference (if needed) and also to verify that this was a conscious change.
Shouldn't this check: if(element.getCurSharedRef() == ph) { element.setCurSharedRef(null); }
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
This shouldn't declare throws Exception.
Should be removed if empty
needs filling in :)
Instead of an empty implementation, make this an abstract method that the subclasses need to implement
Why is this exposed to the things implementing PushingAsyncDataInput? I guess to make implementation easier? I mean, there should be no reason for StreamTaskNetworkInput or StreamTaskSourceInput to call output.endOutput(), as the runtime can do it for them and it can only lead to bugs if the method is called prematurely. Maybe there is an easy way to hide it from the emitNext()? Like splitting into two separate interfaces?
Can you revert this and keep the explicit exceptions.
Let's use debug level instead of info.
Encapsulation
Something else that I missed. I know it's not that important, but we don't have to set the type when creating new objects any more. We can just use the diamond operator new HashSet<>.
this.requirements is never null (but can be empty). The check can be removed.
Generics, please!
This method isn't called very often, so I think it's better to have just one signature (the 3-arg signature) so call sites have to be explicit about their multiValueHandling. IMO this will make bugs less likely.
You may get a ClassCastException here. There are two ways to avoid this: either make the check above be capabilities.getCapability("enableDownloading") instanceof String, or use String.valueOf here.
The dictionary value is just the row number. They aren't sorted.
The key invalidated, it should not be in the code
isNullOrEmpty
Instead of repeating the addition assign it to a value on the stack.
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
Release lock?
This message should be more descriptive. The only was for the handle to be invalid is either if: 1) There is some other thread trying to access the iterator. 2) The iterator has been previously closed. The message should reflect the above conditions.
you should account form previous page too
Couldn't this just check unavailableException if it is null or not? Seems we wouldn't need the managerAvailable variable as well then.
Recheck the condition, it should be 0 <= pageIndex && pageIndex < getChildren().size()
string concat can be inefficient. consider sth:  ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES); buffer.putLong(x);
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
do we just delete the file not the parent dirs? will a lot of empty dirs be left after running this a while?
Move the logic to configAccessor.
Since this will add one more zk read, and admin.getClusterTopology(clusterId) actually reads the cluster, I am not sure how heavy this call is. I assume it is mostly used during deployment? I wonder if we can use the result in admin.getClusterTopology: if the cluster doesn't exist, an exception(HelixException/NoClusterExistException) is thrown. Rest code here catches it and returns 404. Then it saves one zk read.
These lines could be in a private check method to reduce duplicate code.
Can we remove the extra space? It would be great to keep the code quality for open source :-)
Typo? getTopologyMap -> getFaultZoneMap. And getFaultZoneMap throws an IllegalArgumentException when "The fault zone in cluster config is not defined" - it seems to be client error. Would you consider catching the exception and then returning a client error, instead of a server error. I think it'd be better to differentiate a client error and a server error.
For this exception, is it caused by a server error or a client error? It is good to make sure the response status code is appropriate.
This is not badRequest. It may be something related to internal server error.
you could send the cluster object instead of just the id, so you wouldn't need to get it again from the db just for the name
This isn't needed. Actually I think that one constructor is enough, put everything here: super(ClusterFeature.class, ...); this.clusterId = clusterId; Also consider using Guid instead of String for the type of the "clusterId" field. The caller of this constructor will probably have converted it already.
You have these odd newlines at the beginning of some methods and classes. Do you think that is introduced by your code style settings?
Nitpicking, but I'd prefer creating the builder with  org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder(hotRodServer);  and then setting the marshalling. Same in RemoteStoreMixedAccessTest
I don't think setting the timeouts are required in this test, especially since the default is already 60 seconds.
I believe we should add the ability to override the baseUrl of the s3 client. This will allow support for beta regions of S3, and other s3 compatible storage APIs (GCS, Azure CS) <LINK_0>
Unneeded null check
^ This method no longer throws IOException
I think that timeout should be its own setting
Replace with Strings.isNullOrEmpty()
What would be the drawbacks if this was always on (as it effectively used to be before migration to client builder)? <LINK_0> lists one drawback: > Enabling this mode has several drawbacks, because it has the potential to increase latency in the event that the location of the bucket is physically far from the location from which the request was invoked. but AFAIU this says "it will work slow in the cases when it would just fail quickly".
What about considering this an invalid configuration and throwing instead?
Should be able to use add instead of put to avoid the list creation. <LINK_0>
There is no call to this method outside TableManager, shouldn't we change it to private?
s/RemoteTable/RemoteReadableTable
question: why do we need the TableImpl class? The only usage of the tables map is in ExecutionPlanner.createJobGraph() and it is only taking the TableSpec keySet. Also, it seems that TableImpl class does not provide any further functions except as a container for TableSpec. Can we remove it?
this. prefix is not required within getters
Add "this" qualifier
anyway we are skipping this for external table ..this new check is not required
I think you should be able to pass config in directly
i think you should be able to pass in config directly
I think we should make this change, but it looks like refactoring not directly related to the external table replication. May be a separate commit, at list in this pull request?
This check is not required
Magic number <LINK_0> Try to use a constant for the timeout. Review the constants in the project.
this is already called in BasePageObject so you don't have to call it
you can remove this
there is no need to execute initElements method, when you're extending BasePageObject
change to: driver.get(URL_ADMIN);
no need to cast to JavascripExecutor
create instance of this object when requested not in constructor
this.currentLocation.get() this may fail, as the currentLocation is not always guaranteed to be set. Check for presence
if you use AppiumDriver<?> driver = (AppiumDriver<?>) getDriverSafe(); then there is no sense in if (driver instanceof AppiumDriver)
Redundant local variable, just return new ElasticsearchTableDescription(...)
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
Should move this try/catch deeper into the call stack, either the public overload or in the package-private method so that we don't need to put it in multiple locations.
Did you use our code formatter? <LINK_0>
I would rather we let the Exceptions bubble out of this method; If you want to handle the exception, do it at the call site where this task is created.
nit, java should be able to use (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex)
1. Be aware of NPE of chaining getter 2. Why not just call afterComponentDetached(root, null);
ex will always be null here
what about move into page destroy function?
Multi exception catch and usage of ReflectiveOperationException.
I still see all the WARNING logs that we have talked about removing. See Ln 250 in the new code. There are a lot of these " catch (Exception ex)" blocks remaining in the code. I believe @rcordovano has decided to no longer log warnings inside those catch blocks.
Don't we need to return something like -1 in the null case (i.e. when the type is not in-house one)?
In alignment with valueOf, perhaps name this valueOfType or fromType?
This is normally made so different implementations can override the type() method to go somewhere else in the objectstore - however you have a getType() on BACoordinator so it means no one could ever override the getType() from what I can see, maybe I miss something or maybe its not required but I do need some clarification
all these methods can be private
You can use StringUtils from the commons.lang3?
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
Let's make this value a constant.
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
This method can be static, as all the methods it calls.
Instead of create a new type, i would prefer to let the SqlTypeUtil.convertTypeToSpec(type, charSet, maxPrecision) support a explicit precision parameter.
Why is there a fromByteArray method? Why not call the constructor directly?
I think it is common to return the written value.
Superfluous blank line :).
suggestion public Long offset() {
Symmetry (throw)?
Same here: The new flag withAttempts is not passed (used) the paymentProcessor#getAccountPayments
I just cross-referenced this with the server code and I think this will break regular S3 GETs. If there's no job id we shouldn't send the offset.
typo: must
Minor point, but it seems like the reading should be in a separate outer try-with-resources, rather than nested in side the writer.
Why a new random per MergeOp? Why not make a single static final Random and reuse that RNG for all of the backoff?
For each?
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
int[] props would make everyone including the style checker much happier
For loop?
nit: what about java nulls[i] = i % 7 == 0  ?
use Arrays.fill instead for loops
As the generated mask is read only and privately used it might be better to create once and reuse the same array.
All of this can be replaced with an ExecutorService
@yingsu00 I think moving away from page.getRetainedSizeInBytes() and using estimated flattened size is the right direction. It allows for much cleaner design. The DecodedBlockNode still needs the original value for the retainedSizeInBytes as it is used in memory tracking. Hence, I suggest to introduce a new variable to store the estimate of the flattened size of the block.
?useTopologyForLoadBalance=false
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
This line is redundant.
that class would be better with a builder, though I wouldn't ask changing it now
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
This function seems like a good candidate to return an Optional
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
Shouldn't we use empty list here ?
since we construct a default conf already, better to use it rather than call defaultValues.  internalConf = ClientInternalConf.fromConfig(conf)
Could be set to null after dispose().
just reset to null
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
no need to call super explicitly. Any construction implicitly always starts with a super() call (unless it's a this() call to another construction).
please remove empty c'tor
Can we make the type of this field ProblemFactChange instead of Object?
Do we really need this? It's implicit
This public constructor is unnecessary because the compiler will generate it.
super() can be spared here.
It might be more readable if you have one setter per line.
You could remove method("POST") as you set the HTTP method on create
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
wouldn't UnsupportedOperationException be a better match ?
this doesn't looks good at all :( let's log the exception using Logger.warn().
Overly complex. Just say: Repository repo = repoManager.openRepository(...); try { ... } finally { repo.close(); }
I'd move this method to the end of the file, so that order of declaration corresponds to use as createOpenAction -> getSelectedPaths -> getRepositoryPath.
Did you notice that the message is wrong? It says that the key has a passphrase, but the test says repo.getPassphrase() == null.
style: extra parentheses
If our setters in commands are going to fail-fast about single-execution, we should fail-fast here too about a null pointer being passed in for Repository. NPE right away in the constructor rather than deferred: Git git = new Git(null); git.commit().setMessage("Test").call() We should NPE on the first line of that, not the second.
I think this should just return an instance of the interface
Same here, no need a transaction
No need to make this a transaction, its a single insert statement.
The value checking is not needed here, only the preference. We already check the value in the other test.
For correctness this should probably use System.nanoTime() which is intended for this use-case.
Please use lambdas where possible.
Nice, I like this.
Minor nit: we need a space before && here.
Since Preference changes may occur due to outside stimulus, we should bail if getActivity() is null here.
Update error message. state could be null.
I would rename it to something like migrateLegacyPreferences to make it more clear what it actually does.
HQL/JP-QL
clause?
Detail: FROM capitalized.
This variable is not needed, there could be two return statements in if and else blocks
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
again - encapsulation
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
avoid catching all exceptions be more explicit
Why completely remove the implementation of sanitizeURL?
Could you please use DecisionTableInputType.XLSX
Note that the simpler idiom (which also converts more cleanly to Java 7 syntax) is  InputStream inputStream = new FileInputStream(file); try { return IOUtils.toByteArray(inputStream); } finally { inputStream.close(); }
looks broken, as L262 will always get a closed stream
This is breaking the existing conventions about allowing nulls. If we ever receive null inputstream we should throw an error here. To avoid them, we should change the calling site, not these utility methods, which operate under narrow set of constraints. suggestion
When you're using a local variable that shares a name with a class or instance variable, try to be explicit as to which you're referencing by using this.inputStream (or similar as appropriate). As an aside, the instance variable is never set, so this check will never succeed.
I don't like this solution - it's a lot of overhead on the server to get ready for a file transfer which we will never execute. I think we need to use the previous technique from this PR for a file and fall back to the test below on if false is returned, in case the test was for a directory.
Can't be this simplified? java Definitions toDefinitions(final InputStream inputStream) { try (InputStream inputStreamAutoclosable = inputStream; InputStreamReader reader = toInputStreamReader(inputStreamAutoclosable)) { return marshaller.unmarshal(reader); } catch (IOException ioe) { //Swallow. null is returned by default. } return null; }
Do we get an NPE if inp and or inputStream are null?
Should SeekablePathStream be used here as well, or does it have to be Files.newInputStream() for some reason?
There's still a leak here because the original code is rather odd. It's opening an input stream here, and then possibly re-assigning inputStream immediately in the if below (I have no idea why). Perhaps move line 173 into an else block after line 179?
Optional.ofNullable could be used?
This pattern is captured in Optional's [ofNullable](<LINK_0> method, so in this case the body of the method can be simplified to  Optional.ofNullable(gitRepo)  Similarly for other methods in this class. Let's get rid of the boilerplate :)
The original code style in this method is better:  private PagesSerde createPagesSerdeInternal(Optional<SpillCipher> spillCipher) { if (compressionEnabled) { return new PagesSerde(blockEncodingSerde, Optional.of(new Lz4Compressor()), Optional.of(new Lz4Decompressor()), spillCipher); } return new PagesSerde(blockEncodingSerde, Optional.empty(), Optional.empty(), spillCipher); }
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon
suggestion return Optional.of("org.junit.platform");
Could, technically, throw a mixin into net.minecraft.entity.passive.AbstractHorse#initHorseChest to set the carrier?
nit: checkNotNull is not doing anything. The same NPE will be thrown by serializer#write. Either leave out or replace by checkState with a descriptive messsage.
Thanks for finding this bug! I think the root cause was the state inconsistency among {leftOverLimit, leftOverStart} with leftOverData. During #clear() we only reset leftOverData as null, but now reset the derived {leftOverLimit, leftOverStart} from leftOverData. So we have to check the condition only by leftOverData here. Another option is also to reset {leftOverLimit, leftOverStart} during #clear() to keep all consistency.
Is this a duplicate/unnecessary call?
Ingest modules need to throw IngestModuleException if there is an error in startUp, with a user readable exception message, since it is displayed to the user. You need to wrap the NoCurrentCaseException in an IngestModuleException and throw, not log here.
I think we can use ConcurrentHashMap::computeIfAbsent to replace synchronized and containsKey
Shouldn't the restoration be in the reverse order of the activation? So that we first restore the last activated context?
static.
Use static call. There's no need to instantiate this util class every time.
Constructor can be package now.
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Do you really want to request updates from both NETWORK and GPS? As opposed to trying GPS but fallback to NETWORK or such?
To always be safe please use context.getApplicationContext()
the isDownloadOnlyLastEvents functionality should not be deleted, we should download the last event filtering by dates
"notation".equals(resource.getURI().fileExtension()) to avoid potential NPEs.
Not a good idea to have two methods with the same signature except for the type, espcially when one is a subtype of the other.
I would have inverted the check but that may be unnecessary
Possible ClassCastException, since there is no check that the loaded resource is a view.
I think the offset and limit are miss-leading here with the method name searchPayments. The client uses them to restrict the result payments size, but the plugin will use them on the transaction level. So it would be the case that, the client sends a limit of 100, but only get 1 payment in the page with 100 transactions embedded. Or a payment may cross 2 consequent pages. Are we considering to have the plugins returning a more proper list instead of PaymentTransactionInfoPlugins?  class PluginPayment { private UUID kbPaymentId; private Collection<PaymentTransactionInfoPlugin> transactions }  Just a thought, I'm happy it's not changed in this PR.
resource.getResourceSet().getResources().stream().filter(res-> new ResourceQuery(res).isSrmResource()).collect(Collector.toList());
Should we size this?
change the double "unmodifiable(newList(...))" in "ImmutableList.copyOf(...)"
This is created/instantiated, but never consumed.
Collection is enough
Encapsulate this here. Should be returning a MapView here.
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
Please use Optional.ofNullable()
Don't we have to say that this is uniqueId JDBC?
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
why not null as value?
It appears that we're invoking StringUtils.isNotBlank immediately after <serde>.fromBytes(). Is it possible to create a Util wrapper for serde and call this method there. Then you check like so:  String locationId = new MySerdeWrapper(valueSerde).fromBytes(valueBytes); public class MySerdeWrapper { public Deserializer deserializer; public MySerdeWrapper(Deserializer deserializer) { this.deserializer = deserializer; } public Optional<String> fromBytes(byte[] bytes) { return StringUtils.isNotBlank(deserializer.fromBytes(bytes)) ? Optional.of(deserializer.fromBytes(bytes)) : Optional.empty(); } }
we need a gauge metric here to ensure the thread is running
Why this debug log is removed? Not sure, if it's there for any security issues.
please provide e as argument for stacktrace
As well as this.
Do we need to handle the interrupt in the consumer poll thread? Existing implementation doesn't seem to handle it and the consumer poll thread is interrupted during KafkaSystemConsumer.stop()
use markers like {}
Whether to checkpoint is determined by the application, so checkpointing here isn't safe. This should use a similar dispatch mechanism that processRecords uses. It might be possible to shortcut the dispatch at this time, and just make whether to checkpoint a configuration flag. The [dispatch code for processRecords](<LINK_0> for reference.
Would suggest to make it private.
Can these be the same object?
"Incorrect path to log directory; directory {} does not exist"
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Please remove the public modifier
Constructor can be package now.
please use constructor inheritance for these
use try-with-resource instead: try (Scanner scanner = new Scanner() { }
just use context as synch obj
Why you are not checking compaction mark here?
-1. This means input does not get read.
Style-nit: Should be after this.accountCache = accountCache.
Here you use Byte.toString() where a bit lower, line 63, you use ..Factory.convert(..) - might be better to unify.
Here you use Double.toString() where a bit lower, line 63, you use ..Factory.convert(..) - might be better to unify.
value.toString() vs. factory.convert(..) a bit lower, line 63
value.toString() vs. factory.convert(..) a bit lower, line 63, again
remove line
rename this to spanTagCount.received
this function should receive generator object
Why a new random per MergeOp? Why not make a single static final Random and reuse that RNG for all of the backoff?
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
You need to send cookie here.
Const.ParamsNames.ERROR was previously used to colour the status messages red, is it still used?
Try to use "response.getWriter()".
Add final keyword.
You should use HttpServletResponse.SC_... everywhere, no need for HttpStatus here.
What do you think of adding some errorMsg in the page if a user without ADMIN permission tries to access this page?
This (and the following lines) could be replaced by: java getTasks().stream() .map(Task::getName) .sorted() .forEach(output::println);
InsertOrUpdateObject?
This change should be discussed in another PR.
suggestion return Arrays.toString(value);
I think we should sort the tags in a specific order here. Otherwise we could have tests excluded for the same reason, but the strings will not match if tags are not in the same order.
It would be even better to get rid of this line: java String.join(" ", translatedWords);  with java .collect(Collectors.joining(" "));
I like Streams too, but String#join would be more appropriate, wouldn't it? (and it's Java 8 too!)
Collectors.joining(".")
.map(part -> part.replaceAll("-", " "))
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
I would suggest using the related constant instead.
I would suggest using the related constant instead.
Why uppercase fs?
Do we want to check both getProjectId() and getJobProjectId() here?
nit: Could be this.conf = requireNonNull(conf);
Since this method is the one that is responsible for returning the correct folder based on the impersonation and the process method is more of a general method, how about this method calculates the short user name and passes the short user name directly to the process method instead of the impersonated flag.
Does this mean that every Job will be named "NutchJob"?
Is not this a global change? Any test must be written in such way that it does not affect other tests.
This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.
Is this change correct? I see header is getting set with format(secondcol,2)
name could be more descriptive
Vague variable name s
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Please include clientTelemetryEnabled in toString() API
Why do we print a secret systemUserPassword here?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
Seemed better before? More readable
Returning a class instance _or_ a null? This calls for an [Optional](<LINK_0>!
throw new RuntimeException(e);
nit: how about we just use the class name of input strategy by default
return Optional<File>
I'm of two minds on this exception. On one hand it seems like the more correct approach is to raise the exception rather than swallow it. On the other hand, that means if a malformed URL somehow gets into the database, you could never read that row out again without an exception--lame. Any any rate, this should be logged with SLF4J rather than printed to STDOUT
Logging and throw is imho an anti-pattern since the caller will most likely log an exception that he catches.
As per bug 487713#c11, the previous revision used to return the path in case of IOException. Do you think it makes sense to add that return statement?
Shouldn't this throw IllegalArgumentException (as below)? That means you can also collapse the catch to the one below.
can we do a shortcut here and return null if url == null, to avoid that deep nesting?
Can't we use a one try catch block here? or throw exception and wrap the method inside a try catch block? WDYT?
could uh, use checkState(false, "") instead of a lambda ;)
AndroidStudio's inspection highlights and suggests replacing indexOf with contains for the condition expression. WDYT about replacing it? If we will touch this line, and since the index is recalculated below, how about introducing a temp variable to hold the index to avoid doing the lookup twice anyway?
These should be marked as abstract and let the subclasses should implement them.
Missing the -... ex: pt-BR Now that i look into it, is it a - or a _? I believe it's a -. One more reason to use the default functions
return LanguageUtil.LOCALE_CACHE.getUnchecked(this.locale);
Minor thing: please use "something <operator> null" convention.
I suggest to improve the debug message in this case, and mention in it also the returned value of "lookupSupportedLocale(locale, getLocaleKeys())", especially if it is != locale.
- [x] Not required to check isDebugEnabled, because no heavy function on logging.
You are initializing all existing localizations in constructors, no need to do the same here. On the other hand, shouldn't be here the logic to return default locale if client locale doesn't have translation?
Hmm, just an idea: Wouldn't it be faster to load all messages for all existing locales at startup (IMO we don't have that many messages/locales to cause memory issue) than calling synchronized method for each translated message in each user request?
Do we need some kind of synchronization here, or will next() never be concurrently called from two separate threads?
Avoid duplication with:  long sliceLength = Math.min(getRemaining(), partSizeInMB << 20);
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
We should verify the flow was invoked correctly - maybe send a CountDownLatch in the payload, or an AtomicReference<Thread> and verify its value is not Thread.currentThread().
please add curly braces
Should'n it be range == null
please add curly braces
Eclipse is warning that the argument r is unused. I guess this should be changed to r?
Same here; use the injected one.
please add curly braces
If you remove the condition, the retry analyzer instance will never be null. Better: DisabledRetryAnalyzer should be the default value if clazz == null unless you think the null value is important.
There is a genuine risk that multiple sources will try to set the lookup at the same time ? Just wondering since now this will synchronize ALL access to storing attributes to the vaadin servlet context, not just the lookup. Just wondering if synchronization access go through another API, but then again also the getAttribute is already synchronized. So probably this is fine and I'm just thinking out loud.
These seem to be covered by NUMBER_TYPES already?
LinkedHashMap please <LINK_0>
Why you will need substring() when Class.getSimpleName() would only return the class' own name without package? Please remove.
I suggest, instead of returning boolean, throw IllegalArgumentException for bad claim classes right from here. The benefit is that you can provide the class and value of the offending claim right in the exception message, which GREATLY simplifies the troubleshooting.
I think it might be easier to read if we don't modify the allFields variable. Perhaps create a new variable called superClassFields and rename allFields to classFields then do Stream.concat(classFields, superClassFields) below (line 75)?
rename to simple
Can we combine the two? I don't see the point to have a different annotation for multiple functions and single function. We use @ScalarFunction to annotate both class and method. It's also quite confusing to user since it's very hard to notice the difference of the two (so very easily to use the wrong one).
I think that the following check works, but could you test it please? suggestion if (Enum.class.isAssignableFrom(clazz)) {
This could be confusing here. How the user know the all fields?
let's call it updateCodeMinings() instead.
ooh! I ...Connector, here!
if at all possible let's try to avoid introducing more mess:)
can we improve this by giving some meaningful exception message ?
Would it be simpler to call the maintainDepth() method that takes no arguments? Or even to combine the maintainDepth() methods as a method that takes no arguments and has line 490 as its first statement?
Feels odd to be assigning empty char here given we know empty char will always return false in the subsequent check. Admittedly the alternatives would require more code but this is abit random IMO.
catch Throwable? When methods shouldn't throw, like where shouldThrow is false here, it's easy to end up with a hang because an exception type changed.
Minor: maybe just move this a line up so it's after the bracket.
this should only happen if sDisplayAnswer is False right?
@drcrallen I tried a hadoop batch ingestion job with this patch applied, and the task didn't pick up my hadoop-client jars. Passing in the directory:  new URL[]{extension.toURL()}  doesn't seem to get the jars picked up, I had to change the URLClassLoader creation back to the original implementation with a url for each file to get the task to proceed.
Please add ? and % as well
Isn't it also important that adType was async and method was top?
40?
IntelliJ has a "Reformat Code" option which will clean up a lot of the stylistic issues that I might list here: - fewer empty lines - space between ']' and '(' - space after ',' - space between ')' and '{' - no newline between ')' and '{' - space around operators - space between if/while/for and '(' - no space between method-name and '(' - if/else with brackets and the else line looking like '} else {' -make final any variable that can be (method arguments included)
Can created URL class loaders be cached, it should not be necessary to create a new class loader each time loadDependencies() is called.
Throwing exception is required.
we could loop above in the stream without .toArray(URI[]::new);
I think that better to use UndeclaredThrowableException here and in similar cases
Not sure worth changing a deprecated class.
Please remove an excessive space character.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
In case self is a BufferedIterator should this return self instead of re-wrapping?
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
Lets pass the ListIterator constructor as method reference and do not subclass it: java return new SeqAsJavaList<T>(seq, (delegate, index) -> new LinearSeqListIterator<>((LinearSeq<T>) delegate, index));
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.
Added because?
Why not just define the new question index as -1 like what we do in JS file instructorFeedbackEdit.js.  javascript const NEW_QUESTION = -1;
Should not be able to submit when there is no question selected.
Same here. Magic -1 :P
I tried running your test locally; the new question button cannot be clicked because the discard changes confirmation dialog is still open.
Similar to FeedbackMcqQuestionUiTest.java above, not sure why this method is used here
Not related to gender type
Why we delete the first question?
Can be joined with the previous line?
Can be joined with the previous line?
To defend against catastrophes from bad future refactorings, I would recommend extracting a protected method for the computer's log directory, to make it clear that what you are deleting is specific to this computer only.
Should the InterruptedException here be treated as a cancellation?
You can use GlowServer.logger.log(Level.X, "message", exception)
ExtractedContentPanel.getText.error.msg appears to be undefined. As previously noted, this means that there will an unchecked runtime exception if this code is executed. Please correct the error and use the generated method for the messages instead of NbBundle.getMessage, which moves errors such as this from runtime to compile time. *** While we are in this code, it would be nice to group the catch for InterruptedException with the CancellationException, since they amount to the same thing (even though we do not support cancellation of this task at this time).
The exception should actually be the fourth argument to the method so that it is logged as the causing exception with a full stack trace - we should never throw away debugging data. Also, the class name has changed, so the log message could lead a debugging developer astray if they are not paying close attention to the stack trace.
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
What does using a SwingWorker get us here as opposed to passing "true" to the Children.create() call below (which will cause the key creation to happen on a separate thread).
Each of these catches should use a logger statement.
ex will always be null here
I still see all the WARNING logs that we have talked about removing. See Ln 250 in the new code. There are a lot of these " catch (Exception ex)" blocks remaining in the code. I believe @rcordovano has decided to no longer log warnings inside those catch blocks.
seems like synchonized is not needed here, given increment/decrement already protect
Actually.... what if we avoid using addFileSystemBind (that [creates a mountable file](<LINK_0> but use the bind API directly for the SHM? This ~~hack~~ adjustment does solve the problem too, but I think we're fixing it in the wrong place. WDYT?
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
I think lowercase l should also be considered
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
The access can be made package local for this method.
run already called tally, so do you need to call it again?
We should use other method, this ends up creating an AccessControlScannerThread unnecessarily.
I would recommend an else if here to avoid comparing against a string unnecessarily.
That should be toHtmlForAnthology. You mixed those two up.
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
It's considered bad practice to have an optional around a list. Just return an empty list, instead of an empty optional.
Not good to use Optional for collections, just return empty collection
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
suggestion final List<String> lines = Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8);
why do you need all these 4 checks and castings? Will not it just work with: recursiveCheckConstraints(schema, jsonPath, schemaIncompatibilities);
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
Let's keep the old code here or let's try to move this method in the IndirectClient?
can be just diamond new ArrayList<>();
Those can be refactored as  final SortedMap<Long, T> x = new TreeMap<>(); // decode values and put in x dataKeyValueMap = Optional.of(x);  But still, I'm not fully convinced yet why we want to use SortedMap.
Should we use UTF-8 instead of default character setting?
maybe test first char for empty letter as well to reuse s if possible?
can this use the MMX StringUtils functions?
This involves a look up of the character encoding type table. Use MessagePack.UTF8
I would rather use a constant such as com.splicemachine.primitives.Bytes.UTF8_CHARSET
Do you mean s.length() > len?
no need for logging here
is it possible to have tests for the encrypt/decrypt methods of this util?
This will throw an exception if there are no strings in the vector. I would honestly just space separate them and not worry about the hanging space at the end.
I think this should be new ExtractIlluminaBarcodes.BarcodeMetric("dummy", "more_dummy", s[0] + s[1], s). Shouldn't change the behavior of the test, and is more in line with what the parameters of the constructor are (first parameter is "barcodeName", third parameter is "barcodeDisplay", which is what BarcodeMetric.BARCODE is set from).
Is it really worth checking before setting it?
Should you be closing the connection as well? What happens if the caller attempts to execute query after closing the prepstmt
just remove this check and the corresponding else. managementRealmOpenTask permissionRealmOpenTask may finished at the different time, so you could have managementRealm != null but permissionRealm == null
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Should close kill the memspace? What if someone want to reopen the key?
Why are we doing this null check? Are we expecting this pool to be null in some real scenarios? If this check is here to allow tests to pass in null then I think that they should pass in a no-op consumer instead so that we can get rid of this condition. (many similar places below too).
This line is redundant.
We will leak the connection if table.close() or resultScanner.close() fails with an exception. I believe the proper way would be to wrap each close in a separate try block, and catch and log the error.
invoking combinations of close and releases here looks strange
Could be set to null after dispose().
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree)  return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
This could be reworked to avoid having ! in nearly every condition to make the different cases cleaner to read.
Why not push/pop methods ? bit clearer IMO.
no need for the ||
I would make explicit tests for every kind (or switch) and have overloaded method for those. That will make classCast less likely to happen. Here there is a lot of implicit going on. Let's make thing explicit. checkIfUnknown(MethodInvocationTree ) checkIfUnknown(NewClasstree )
you can inline everything here: ((SwitchStatementTree) tree).cases().stream()...
can be wrapped in one invocation : is method has multiple arity so no need for the ||
I think we should check if we have semantic information  if (!hasSemantic()) { return; }
@ivandalbosco IMHO it's better to move the call to isPrivate into isException
CFG.Block.successors returns a Set<Block> and I don't think that's any guarantee on the order of the case blocks.
suggestion if (this.currentTask != null) checkAndRethrow();
Same why not else if?
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
optimize
Please keep this.cell near the related fields (previousFamily & cell count) below
optimize
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
without **a** 'MessageHandler'.
Not sure what this is trying to say, if the condition is false, there won't be any conversion.
How does this work for (ridiculous) timezones with 30 or 45 minute offsets form UTC?
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
I prefer ", not "+(l == null ? null : l.getClass()));
"must be of the format"
currentTimeMillis() instead of creating a new DateTime() object
Let's use a template path string like  String BASE_LINE = "/%s/something/%s"  Then the code here is cleaner.
do we want to assertFieldCountEquals here?
Collapse the no-longer needed +.
can we use frameworks/base/core/java/android/os/Build.java#IS_USER
you could call the copyFileToTestProject
This method can be static, as all the methods it calls.
Since this logic is getting more complex, it probably makes sense to reuse isBindableType here.
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
you could have merged the expression of this if with the previous one.
combine with assignment this.outputType = requireNonNull(type, "type is required");
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
This has nothing to do with your contribution. I would keep the class name as a String as it is clearer and avoid to import Serializable which is not required. Same remark for the other arguments.
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
Extraneous space after (
replace with FactoryLocator.getFieldFactory()
Shall Alter database to add source_of_replication DB property and see if Dump succeed afterwards.
It looks like sparkObject could now be a byte[], so should setSparkObject call deserialize here, the same as the code you added in getLength() ?
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
Why is this change? Should not this minimally depend on if this table is transactional or not? What happens if we call it on a non-transactional table?
Duplicate method. Can we have a static method in MetastoreUtils that takes MSC as input?
Why 2 different flows for No database case?
CheckReturnValue?
Why remove this processing? If we fail to sync the db, we should not have attached the db, right?
Should these all be final then?
Add default behavior instead of throwing exception in every implementation.
final
Unnecessary.
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
Instead, I think we should update AbfsOutputStream.close to wrap the exception, short of having the Java implementers fix this. :)
Should we check for systemConfig.isOutdated() as well?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
We should rethrow java catch (InvalidFunctionArgumentException e) { closeWithSuppression(e); throw new PrestoException(INVALID_.....); }
Why not just throw e;? (granted, this one has a slightly nicer stack trace)
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
This is strange, I don't think we can get constraint violation for relationships when setting a property? When removing I guess we could violate a existence constraint, but that's anyway not checked until commit. In general it feels like here are way more catch clauses than necessary...
Pretty minor but would you mind adding some parentheses around the arithmetic? :) Is it possible to have a divide by zero error?
Why not unconditionally update the SessionData?
Is there reason behind how you access this wrt to property or accessor function? Perhaps we should change all these uses to getters/setters?
combine these two lines -> OwApplicability app = artifact.getAppId();
Can this case happen? We initialize app in onCreate(). If so, can we initialize app in onAttach instead?
The problem with this.... While it is quite ugly to just create a new thread when you create this, but the loading will start immediately. Now instead the loading is governed by the framerate. Well, not really that big of an issue. But what if you load the app minimized or alt tab away. Loading basically never starts because it waits for the screen to draw.
Might need add below after line 211 here, since if this process is gone, the other app's procstate/adj could get impacted due to this if (oomAdjAll) { updateOomAdjLocked(oomAdjReason); }
Where do we actually wait for the callback to be called? We just check unfinished below, but it's unlikely this proc will be done. The old version uses a latch. Why use the async api at all? Why not just use the sync API?
Hmmm? :~)
here it could be if(Android.SDK_BUILD >= 19) { static function to create that class (and specify full classpath to the class without imports) }
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
Is it possible context.getAuthenticationInfo() is null or context.getAuthenticationInfo().getUser() is null
I tend to prefer having all code at the same level =>  if (0 != context.prepareSelect("select count(uuid) from quality_gates where is_built_in = ?".setBoolean(1, true).get(row -> row.getLong(1))) { return; } context.prepareUpsert("insert into quality_gates (uuid, name, is_built_in, created_at) values (?,?,?,?)") ...
Instead of having this be a part of every authorizer, we probably want to push it up a level and have it be a part of the code that calls the Authorizer.
The filter should be moved to SQL to not load all the table in memory: select ... from properties where prop_key like 'sonar.webhooks%'
It seems like it may be better to leave the implementation of getInstanceID() in Client context. Then the private members of client context would not need to be exposed. This method could then return context.getInstanceID().
Please only log at debug or trace
you could even add and prj.enabled=? with value true.
Logging should be done at debug level or lower, normal test execution should produce no log output.
We log the "message" here which doesn't have row (which is null) but includes "value" input argument which can potentially have sensitive data. Need to put the "message" into debug log.
minor: don't need this. qualifiers
channelId => channelName
s/id/ID
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
suggestion return getClass().getSimpleName() + '@' + this.id + '#' + this.version + ' ' + toJson();  IntelliJ thinks this is better
I don't think rendering a byte[] as a bunch of ints is useful, maybe omit this (or just include the length, perhaps).
Guava has Objects.ToStringHelper() to make it nicer.
Same as above for toString(): <LINK_0>
Can be replaced with this.constructLockKey()
Can we make toString a little smarter and print out what's appropriate for weather or camera?
The two methods above are the same except for the first line...perhaps reuse the code instead?
The two methods above are the same except for the first line...perhaps reuse the code instead?
Can be rewritten as Assertions.assertThat(utilities.getValueList(column)).isEmpty()
Some more methods (appendColumn(..) and deleteColumn(..) a bit further) with very similar code that could be reused.
Maybe also here we could use MessageFormat as we pass twice column.getBoundName()
Is it possible to have an empty row group without any records in it? In this case, a binary column also has null statistics values, and isAllNulls/hasNulls both return true, which is at least semantically wrong.
Minor thing, but it's the only message constant from this file that has a label that doesn't start with a capital letter. If you change it, while you're there remove the extra blank line before it in Messages.java. Also, according to UI guidelines the text should probably be "Show All" not "Show all".
Please align with Double (no protected)
Did you take the alignment from Vogel's tutorial too? Because it's wrong here ;) This looks like something that could be re-used in other places in this class too?
Missing @Override
Parameter should be a string instead and be called label
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
This fix is incorrect. It only caused the empty oplog (created by the offline compaction) is not deleted by the recovery's auto compaction. I modified the dunit test a little bit and proved it. Unfortunately, there's no flag or status to show that a compaction is just finished. Even we want to use the empty oplog created by offline compaction, we need to careful arrange the logic. Such as: change needsCompaction to return int. 1: need to compact, -1: no need to compact, 0: there's one empty file, only need to delete it. But maybe there's better ideas.
We should now be using the actionParameter itself
Missing @Override
Instead of 2 columns, you could simply have one and have its LabelProvider returning the preview in the getImage().
That's were StringBuilder are efficient compare to concatenation. The compiler wont do the optimisation within loops
List
Change that back
Doesn't work as expected as this message is never displayed, whatever is the type of media.
Braces on following line
Let's not catch NullPointers but do a check whether element is null before trying to get the attribute.
I don't think you need this new String
You could use a StringBuilder :)
I would recommend an else if here to avoid comparing against a string unnecessarily.
Tabs
I think lowercase l should also be considered
I'm not sure how this is working with the old ncml being used here.
I think this and the below line can be deleted.
Rather than catching exceptions on the tests I think we should let them bubble up and let fail the test so stack trace is printed, which will be an aid in debugging.
If this should never happen throw an IllegalArgumentException instead.
ChannelClosed needs to be added to (though not strictly necessary)
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
1. _1 suffix almost everywhere means that error code has one parameter. Use different names for exceptions. They are also expected to be self-descriptive. 2. Vendor-specific codes can't start with '0', '1', '2', '3', '4', 'A', 'B', 'C', 'D', 'E', 'F', 'G', or 'H'. Don't use 42S here, add some plain 90*** codes instead.
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
Unsigned types are not used in the current implementation. So, you can omit them.
This list needs to include soul lantern.
What type of view will TIMEX3 be? Right now, it is of type NULL. Move the case to the block that contains the correct view type.
What in the... Please no. You can do better <3
It is probably worthy to make sure this class only gets instantiated once per language. I would abstract it to its own file that enforces that class is a singleton and just use it from the UDF, if you call it from the "initialize" method *i think* the application environment ensures that only once instance would exists but regardless that can be explicit on the code too.
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
suggestion return GitHubServerConfig.GITHUB_URL;
Existing code use null as the sentinel for this field, so I think you should keep using null here. suggestion this.apiUri = null;
Let's use a template path string like  String BASE_LINE = "/%s/something/%s"  Then the code here is cleaner.
Could use '/' and ']' to avoid the need for extra NON-NLS
Collapse the no-longer needed +.
Ditto, I think this would be cause issues in other places as well, this is just one of the only places the tests catch it. I think it should be done in GitHubRepositoryInfo.
can we use frameworks/base/core/java/android/os/Build.java#IS_USER
These three lines should be able to be ignorant of the helper, after the most recent changes, right (and if not, I would change the implementations so these lines don't need to change)? They should be able to be something like this:  repoOwner = source.getRepoOwner(); repository = source.getRepository(); repositoryUrl = source.getRepositoryUrl();
why not using ID_REGEX?
I believe this whole catch block can be removed. The standard WaitUntil handling will be sufficient I believe.
Is it OK to swallow this entirely?
Avoid logging an error if there's already a throw.
Why do you have to check for null here?
Thoughts on putting log messages in a Utils class?
Log and throw is generally considered an anti-pattern. You can perhaps just throw the exception without logging in instances similar to this.
This should not be needed if using the users' session.
Is this a specific exception? Or an internal issue? If it is not an internal issue, we should not throw RestAPIException.
For consistency drop the cap on Back?
Check for empty strings as well. Use builtin methods like StringUtils.isBlank or appropriate. Please do the same for all applicable places.
We don't need to use System.out.println() here. These two lines should be assertTrue("Expecting: " + expected + ", got: " + e, e.getMessage().contains(expected));.
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
What's the reason to do it here rather than in InternalEntityFactory (analogously to the policy path)?
I would probably replace this with a string builder
You never close the BufferedReader, this will create a ResourceLeak, wrap it in a try with resource statement  try (BufferedReader br = new BufferedReader){ .... }
Please log Bundle ID data here.
Message not strictly true if isReadOnly was true. Why do we not need to also handle isReadOnly in start, above?
I don't see why we need to match the error message here.
Use slf4j to avoid need for String.format
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
please create a more specific exception that extends this one.
factor out
throw UncheckedIOException(e)?
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
Nit: "failed"
You can also use IO.close(bb) as IO.close will not throw any exception.
Why not throw IOException and let caller handle and log etc.
should this be synchronized?
Is it necessary to have nested try-catch scopes? Can we make it simpler?
you could be more specific and check instance of Function0 maybe?
Can this happen ?
Clone method is wrong. Kernel/stride/padding are already handled in superclass clone. And it doesn't set depth multiplier.
Should close kill the memspace? What if someone want to reopen the key?
should call clear() on timeStamps and values ... this will cause null pointer exceptions when calling add after clear
Shouldn't you add a inQueue = 0; here?
events.isEmpty()
Not sure why you need this. If you're getting a leak here lets try to work out what's causing and see if there is a better way to solve it!
Fix Radio instead
Shouldn't we use empty list here ?
For loop?
nit: what about java nulls[i] = i % 7 == 0  ?
Format this file using our code style.
no need for the "this"
For each?
return i; Or break; No need to continue the loop
As the generated mask is read only and privately used it might be better to create once and reuse the same array.
All of this can be replaced with an ExecutorService
What's the intention to set AbortRepair flag here?
?useTopologyForLoadBalance=false
After checking how MimeBodyPart is implemented, it might make sense to tweak this to:  java return String.format("%s; charset=%s", mimeType, MimeUtility.quote(charset, HeaderTokenizer.MIME));
this is confusing, it is called router but actually it is routerUrl.
Looks like you are making double slashes here...
Can we use url building here, to avoid problems with / at the end of the server.
Not provided the Locale in the first argument can cause issues depending on which user the Locale has the app set to. I ran into this with the Simperium library.
Doesn't String.format need a value to be formatted?
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
Better to return "";.
just put "unkonwn" in format string instead of as parameter
maybe use clusterName.pid to not conflict with instances from other nodes?
style nit: we don't use braces around single line blocks
style nit: we don't use braces around single line blocks
What's the point of the 6 trailing zeros ?
Just wondering what was with the random "getClass();"?
Package private constructor, rather than just public?
Do these strings all need to include the escaped newline? Everything seemed to work ok for me if I replaced all occurrences of \\n with a simple \n? On a related note, would that change make the matrixAsString.replaceAll("\\\\n", "\n") lines removable too?
I think you can rewrite this: if (++sinceLastIndex > REBUILD_INDEX_COUNT) buildIndex(); inQueue++; and move the sinceLastIndex reset to into the buildIndex method. This rewrite is a little shorter here in this already long method, and avoids an extra compare. We still get the benefit that we don't attempt to create the index until we have added at last 1000 items, but we avoid the extra branch for inQueue.
low < high? When they are equal there is no point in running a binary search iteration. There is exactly one element to examine from index and the reassignment of q when the loop breaks will pick that single element.
new Object[] is unnecessary.
Redundant array creation - getDouble(int...) is varargs method.
Apply changes similar to setVisibility.
Simpler to apply the mask after the shift.
You need to calculate the righ margin to account for the width
You need to calculate the righ margin to account for the width
This should use the new checkPosLength(int) method as well.
Should include tableName as part of hash code?
Use Guava hashCode function
If you have to cast here then you probably should have casted when reading the value from the data array.
This needs to be changed to return the long value.
bad hashcode.
A message might be helpful
this seems misnamed
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
Eclipse is warning that the argument r is unused. I guess this should be changed to r?
There's no validation in here. I'm not sure if there should be, but we can't assume the UI will provide "valid" numbers. My guess is that we should have a min value and a max value, defined as environment.properties values, and ensure that whatever the end user passes in falls within that range, or is constrained to that range by the code, if we want to allow that
nit: line break after ( or before ".set" here.
Where do these numbers come from?
can you explain this?
Can we collapse these two branches and just pass the parameter (direction == Direction.ASC) ?
For new code we should always use braces even for single statements
you need call addColorSettingsListener on the new instance.
They are mutually exclusive? Or is that a micro optimization?
This thing does check the value for not being null. So the previous expression is redundant.
Preferably have one call the other?
Redundant condition.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
I'd put notEmpty there
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
I think for removing a thing the order was already fine. If we remove the thing from the ThingManager before notifying listeners, they could try to disable the thing in that short gap. Moreover, if we leave the order in this method unchanged, then it will be exactly the reverse order from the notifyListenersAboutAddedElement method, which is also what I would expect.
Is there a chance of a NPE? could be getFile() null?
The super() returns "" on null. Why should we differ?
You could maybe use enclosingClass to save a few hops...
I would not recommend a publish workflow for this, especially not a one-way publish workflow. In practice, developers will create a revision, publish it immediately to test with, and then create a new revision, resulting in a myriad of unused revisions. This is the same reason we ended up removing the publish workflow from schemas. It would be better to just always allow elements to be mutable.
Do we want a test case that you can create an element with any revision?
We should not catch generic Exceptions. Can you make this more specific?
Just in case, please wrap with Collections.unmodifiableCollection()
It would be better to not hand out a reference to the internal data structure. The TagName objects are immutable, but the collections are not.
return Collections.emptyList();
nit: create static variable for this empty set and return that static variable
Not that it matters in the case of this class but how about Collections.unmodifiableCollection(EMPTY_PARTITIONS_SET)?
why not public
Same question here: no start and end, means only one continuous, never ending pane?
nitpick. Suggest to use a init factor " new ArrayList<>(batchSize)"
you can directly declare batches as ArrayList<Collection<T>>, so no need to do further casting again. And same to batch.
Change to use Iterables.partition and return an Iterable
Define "data-agent-conf.xml" as a constant
duplicate regex as above, can we reuse it?
correct.
fyi: if we counting everything, fs.getContentSummary(path) would be the most efficient.
Args.notNull
Files.delete(path)
![CRITICAL](<LINK_0> Possible null pointer dereference in org.carlspring.strongbox.providers.storage.FileSystemStorageProvider.getArtifactPath(String, String) due to return value of called method [![rule](<LINK_1>](<LINK_2>
Recursive delete counts as 1 removed?
While this is syntactically correct it will read more clearly with curly braces and formatting like other ifs. Other than that it looks goid yo me.
Use Logger.
Did you intentionally ignore the patientProgram parameter?
?? why this and the following ones could be left empty?
We could throw an UnsupportedException here.
Will need a @since tag.
factory must close its cursor (which is closeable)
Would be nice to leave existing code the way it is that is not related to this ticket
Shouldn't this be done before the patientProgram is saved, instead of after?
voidDate is not human understandable. Use a english name for void? what does this date is relevant.
DEREncoder shouldn't be referenced from ASN1Encoder - the implementation of this method should just be moved to DEREncoder.
I thought this should only be happening when completing a program, am not seeing the condition that ensures that.
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
Great idea! Can we use Locale.ROOT instead, though?
probably the date format string could be refactored since it's used in multiple places. I'm also wondering how expensive the creation of a new SDF is.
Why change the name the property? Accident due to mass refactor/rename with IDE?
can we split this into multiple lines and add tab support?
Do we have plans to eliminate this JRuby instance eventually (may not be in this PR)?
Try using StringUtils.isTruthy(this.path)? <LINK_0>
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
log.trace if at all
log.tracef
Might be cleaner in terms of minimum visibility to just return the timestamp from the transaction task.
In general throughout this class, is isNotNull() really needed? I imagine the isEqualTo check should be good enough. Transaction#getTimestamp returns a primitive long, so non-null.
same here. NEVER do anything with null, it's a bad practice
this is not required and it'll slowdown
log.trace if at all
log.tracef
This doesn't actually make the transaction additive, it just changes what we think the current representation of that transaction is. It needs to be made additive when the transaction is created.
can we lower this number?
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
The cast is not needed
I think this should be done in the constructor rather than here - or at least, in the if-clause of this method. Otherwise we risk adding the instance as a listener multiple times for each getInstance call
Please do a format of all files before committing (ALT+SHIFT+F).
Does this need to be a singleton?
Possibly. You'll need to run the tests and make a determination.
I suggest inverting these two calls, so that the instance no longer is in the created collection.
macOs implementation is pending
Don't think any method is going to throw an IOException. We can get rid of this.
Yes @alena1108, I like that.
can just be return pattern.matcher(value).matches();
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
can we move this method to Utils
Suppose makes sense to convert value to lower case before comparing.
return StringUtils.isNotBlank(value) && value.equals("true");
Would it make sense to add a String.class entry to POJO_TYPE_MAPPING instead?
Minor: same as in other number check, WDYT about checking for the decimal point?
I wonder why this whole if/else is not phrased as one single boolean expression.
This should be: return isIdempotent(clauseValue).
This condition is never reached, ZonedDateTime implements Temporal
Use logging framework instead of printing to stdout
assuming this was for debugging, should remove.
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
Remember to revert this file, it should know about the transport class.
InputStream.close() doesn't contain any implementation so you can drop that call (but it doesn't matter). But I am pretty sure that the base class close will not get an implementation some time because it would break all previously working subclasses.
We may also want to cancel our subscription.
Should you set the iis to null here so that it is immediately known that this is closed if you try to re-use it? I'm just concerend about someone using one of these and not realizing that it wasn't being used correctly.
These should not be here. If you want you can log at debug or trace level, but tests should not produce output under normal circumstances.
Is there any other output method that you could use besides System.out ?
You should assert something around titles, URLs, and name, not jut print them out. Similarly, assertNotNull(ie), the test should be failing when you see something unexpected, no need to print "null encountered", that would be a bug.
This updates all gauges when any of these gauge is visited. It'll be better to override getValue() instead, and only calculate the percentile for the gauge currently being visited.
Should this be removed from here if this is already being updated in getValue?
I am confused b/w the description and implementation of filter here.
do we need currentTime? "-1" would be simpler, no?
this is not thread safe
As a note to self, the behavior for non-finite values is something that should be clarified in so the user has a clear expectation.
Why return if is not the one registered?
Is this thread-safe?
synchronizing a read access to a concurrent concurrent hashMap is off it defies the point of using it.
suggestion protected void doRun() throws Exception {  Move your tests files to the right package and you should not have to update visibility of the method.
Be explicit about e.getMessage here? (and perhaps enclose it in double-quotes)
Oh, I see Well, I'm not against mentioning subscribe() as long as we don't just say to "set this error handler to avoid this exception" We can also mention onErrorXXX, might be a bit overwhelming tho
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
I would suggest to change the name of skipRemoteGet() to something like skipFetch(). Also, change the name of the internal flag and the setter :)
This prevents menuDetected triggered by the Menu key (e.detail == SWT.MENU_KEYBOARD), as mouseUp will not follow (neither will keyReleased).
Does this now call stop asynchronously, rather than previously doing a blocking call? Should we do a .getUnchecked() as well? Or return the task?
Message not strictly true if isReadOnly was true. Why do we not need to also handle isReadOnly in start, above?
It looks like 3.11 is before we started using MicroProfile Config. Maybe ResteasyConfiguration config = ResteasyProviderFactory.getContextData(ResteasyConfiguration.class); boolean originalBehavior = false; if (config != null) { try { String s = config.getParameter(ResteasyContextParameters.RESTEASY_ORIGINAL_WEBAPPLICATIONEXCEPTION_BEHAVIOR); originalBehavior = (s == null ? true : Boolean.parseBoolean(s)); } catch (Exception ex) { // } }
Could this check fail and expire a newer value? If not, do we need the extra lifespan check?
i think you just have to store a reference to the compareColor object
Padding should probably be extracted in a separate method. (I could also argue that getting the int value could be another method, but I sense that there might be some opposition there).
we never use NULL, it is a bad practice in general.
This will NPE if input is null, yet the parameter is marked @Nullable. Should we remove the annotation, or explicitly check for null (e.g. to return null if input is null)?
If you make the EMPTY_EXPIRES, you could use it here.
nit: space
Missing the separator
This key ("properties") is used at multiple locations. I'd make it a constant.
Update to use Security.doAs
Don't do that in test code, change the throws clause of the test method itself.
Suggest retaining [] brakets
This can just be catch Exception.
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Should we check for systemConfig.isOutdated() as well?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
consider catch(Exception e) { throw Throwables.propagate(e) }
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Don't swallow exception here
Add message to new RuntimeException
You should use multi catch in here to make all of these catch blocks be just one line - much cleaner. Or since you are simply wrapping the checked exception in a runtime exception, perhaps you want to simply catch Exception, and rethrow it as RuntimeException. Please read here. <LINK_0>
Can you remove the Special class (see below), and just use SSLCustomizerInterceptor directly?
suggestion return Optional.ofNullable(getLhsType()).map(s -> s.getTypeImage() + ".").orElseGet(() -> Optional.ofNullable(getAmbiguousLhs()).map(s -> s.getName() + ".").orElse("")) + getImage();  and avoid computing the ambigousName unless necessary
Must be in format ID@ADDRESS
Just an FYI for future - You can use this method for this: <LINK_0>
same here as for CheckResult
can we use frameworks/base/core/java/android/os/Build.java#IS_USER
This is an Optional not a stream so there is no peek operation
This doesn't break the test?
last lastHeartbeatRead read -> last heartbeat read but not a big deal...
keyOfSchemeList then (to be compliant with the other variable)?
I suggest to wrap printing code to try - catch block to avoid node failure if printing code has errors.
An optional of not null is a bit painful. Use another constraint perhaps? Do we have one test on the payload business btw. (applying it to the wrapper)?
UnsupportedOperationException ?
The current style used for the method return annotation is to put it above the declaration. This also applies to all other usages in this PR. suggestion @NotNull public static IReferencePoint create(@NotNull Module module) {
also static
better URL: <LINK_0>
Looks like it does not handle the action correctly. When clicking on a "Translate description" card, it will still go to the "Add description" screen.
nit: remove the last arg?
suggestion public DeliveryStatus deliver(@NotNull EventPayload payload,
suggestion public DeliveryStatus deliver(@NotNull EventPayload payload,
usually we avoid using of getters / setters, let's rename this method (and maybe the field as well) as described [here](<LINK_0>
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
Would suggest to make it private.
Patametrrized logging please
Why this has to wait for 5 mins to stop the proxy thread. Can we set the proxy thread stop timeout to reasonably low value?
Would suggest to make it private.
use markers like {}
This should probably be this.prefix == null || this.prefix.isEmpty() or use the new Guard method Guard.isStringNullOrEmpty(this.prefix)
Nit: unnecessary new line
Please don't use emoji in log messages. :smile: Also, I guess these messages are leftovers from debugging? If they are still needed we should probably change them to LOG.debug() calls.
I'd log the whole error and not just the message
Why this change?
I think it would be better to make drawing the border conditional on the line width.
public? And maybe put it next to the other setter.
That will use the width of the column at the time that the item is checked for the first time. When the column is resized or the item is toggled, it doesn't seem to update the width. Maybe the tree/tree item needs to be layed out again. But perhaps it should have a shorter width that does not change instead. I got some success by calling pack() on the column before getting its width.
What's the default background? Is it already OK? If not, you probably want to simply use display.getSystemColor(SWT.COLOR_WIDGET_BACKGROUND). This is the background set on the Chart.
This line appears in both branches of the if, so it should be taken out, thereby removing duplication.
This font needs to be cached somewhere, and disposed when appropriate.
I don't believe you ;)
In theory that should be OPAQUE.toInt() but in practice it's the same...
This is almost getColor(int), but it would be better to use getSystemColor(SWT.COLOR_BLACK)? It could be a constant.
This must be unique, as it is the ID jclouds will try to find when calling the computeService.getImage(id) method. Is this label unique?
shouldn't we do it only if getParameters().getSourceDomainId() is null or empty?
Why is it setting the SD to the Master SD? What if the disk used is not on the Master SD but on some other random SD? I think qemu-img will fail and so will the import.
better use Strings.isNullOrEmpty(item.getLargeImageUrl())
Maybe use the getStorageId method here?
If we validate in here instead of validation phase, we won't avoid copying the image (in copyImagesToTargetDomain). So we would just fail on execute... Also, we still ignore the specified 'getParameters().getSourceDomainId()', i.e., we're still changing behaviour. Let's see what others have to say about this solution.
/s/in/is
This line sets the Item.image field which can be used instead of enabledImage.
Wouldn't it make sense to call setImage here? Or do we have different semantics in that method and this one?
consider using List.of()
Something like this.
Same here. Multiple places.
You may find many examples in the existing code base.
Tiny grammar mistakes in test messages. - [ ] greater - [ ] equal to I created an issue regarding "grater" typo. <LINK_0>
similar here, should verify html content after the edition, so that you can know the edition indeed appears on the page
Move this line to before line 71?
I would have put this line above the previous instruction to make sure #xtree can be found. WDYT?
Is this part of the issue?
This can be a class variable instead, using the @FindBy annotation; especially since this same element is used in another method.
I think we should put this line after **______TS("unreg student");** as this is needed for that test specifically. If someone moves that test, this needs to move as well
several style nits: spaces before {, before variable names, between functions, etc.
I think we are doing too much outside of View rather than finding a good way to delegate to a View. We rely on a view's underlying implementation to work, and in this case we don't even throw an exception if that assumption doesn't work (which we should). I'm fine with this as long as it is temporary, but I think we should be delegating more to the implementations rather than relying on them to follow the standard pattern.
invert it
ViewUtil.destroy(View) use the GMF CrossReferenceAdapter and should be removed
This is extremely wasteful. Try a CopyOnWriteArrayList for listeners instead?
nit: create static variable for this empty set and return that static variable
return Collections.emptyList();
Rather than instantiating the view here, I think you should just pass it to the [DatasetSourceTarget constructor](<LINK_0> That way we keep the number of places where views are instantiated to a minimum because we always want to push that as late as possible. For example, support for handleExisting will probably push that until when the job is being committed.
Can there be circular dependencies on views that aren't siblings? That is, can a view refer to another view outside of it's parent when aligning?
Same question about TODO
suggestion throw new IOException(MESSAGE, (Exception) DummyClassLoader.apply(TestCallable.class));
@andreoss Why throw Exception here instead of the original IOException?
Maybe IOException since it's supported here?
Style-nit: Remove the added final keyword.
Should you set the iis to null here so that it is immediately known that this is closed if you try to re-use it? I'm just concerend about someone using one of these and not realizing that it wasn't being used correctly.
This is the same handling as in the block at L288-291, so it could be added there instead, i.e. } catch (IOException | Throwable err) { .... Also, should this specifically catch OutOfMemoryError rather than Throwable?
We should have fs.close() in a finally block. Without that, it's possible for the file.close() method to fail and we'd leave open the FileSystem we created for this stream, resulting in a memory leak. It will be a bit tricky, because we have to properly handle the potential exception in the finally block (which overrides any exception in the try block), since we want to always return the _first_ exception for either file.close() or fs.close().
I think these extra try catch blocks are unnecessary
If lock is true you just truncated a file that wasn't supposed to be modified until the new version was fully written to disk *and* the lock was released. Git relies on doing atomic updates on the filesystem by writing the new content to a new temporary file, and renaming that over the real file name once the new content is completely written. This method *COMPLETELY* ignores that scheme, making it incompatible and useless for JGit.
Didn't the finally block in uploadWithExceptionPropagation() handle this?
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
Might this not cause extra copying of the buffer contents when transferring data between network and storage?
Just personal preference, for this, I would use java 8 style getOrDefault to make it a bit cleaner :) java _currentAssignments.getOrDefault(resource, Collections.emptySet());
why do you set it twice?
Since it's the same in both branches of the if, I believe it can be put outside of the if
using this approach only root collections will have validatorLocator, all sub-collections/resources will get NPE, when you'll try to use it, you need to inject it in runtime to every resource.
This was purposely catching both checked and runtime exceptions, hence catch of Exception, because if this were to have a fundamental flaw causing a runtime exception it could conceivably kill all sling resource fetches.
Very nice!
patchSet?
Unable to update the index. %s is not a supported file path.
Move this validation to PluginProfileService.
Move this validation to PluginProfileService.
That should be toHtmlForAnthology. You mixed those two up.
I think lowercase l should also be considered
need to throw the exception
Do the (cheaper) authorization check earlier?
I would recommend an else if here to avoid comparing against a string unnecessarily.
I don't think this is needed on the originator: keyDataConversion and valueDataConversion are not private to the command, they're already wired, and even if wireDependencies is idempotent, it's not that cheap. SingleRpcCommand and PrepareCommand already init the sub-commands on the target nodes, you just need to add it in BackupWriteCommand.
IMHO, this should be on debug level.
assert on the result object --  assertFalse(result.isSuccessful()) assertThat(result.toString(), containsString("UNAUTHORIZED_TO_EDIT"));
side note to bringing in this dep, installing this module would also likely start up a number of pollers/db connections/zk connections/etc which we don't want
Should you call analysisReady(false) here?
Missing call to super implementation of onResumeFragments()
configure is user-overridable method, and also there is no need to trigger it here
eventService.unregisterListener(EventConfigUpdate.class, this); this.eventService = null;
Not needed, please leave the method empty
In order to not make this a breaking change this method should still actually clear the data.
Should this method check motor.checkMCException()?
Why do you have synchronized on an empty method?
Instead of an empty implementation, make this an abstract method that the subclasses need to implement
LinkedHashMap please <LINK_0>
why silent catch?
ConfigurationException?
Could you add the path /artifacts/ to <LINK_0> and reference that instead? Then search&replace in other methods.
Missing a unit test to ensure maintainability.
Could you import import static com.google.common.base.Preconditions.checkNotNull; and add a null check on the arguments as a prerequisite in each method before the call, e.g. checkNotNull(artifactId);?
You can remove the unchecked warning by doing:  T service = clazz.cast(services.get(clazz));
Just put another if inside of the else if. Seems a little more clear as I was first confused as to why we were calling isTransactional twice.
You could use TimeUnit.SECONDS.toMillis(endTimeNode.asLong()) rather than the less expressive * 1000
System properties should have meaningful names like mylyn.tests.configuration.url
should be setSucceeded(true)
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
Since we know we're in ConnectStoragePoolVDSCommand, is the getCommandName() really necessary? also, remove the "to" - "Failed in VdsCommand %1, error = %2$s"
* shuoldn't we call super? * worth adding some log..
Not needed, please leave the method empty
As we discussed before I would simply add an audit log as been done in line 133
In order to not make this a breaking change this method should still actually clear the data.
Should this method check motor.checkMCException()?
i think its good enough to log: "Failed to hibernate vm '{0}' in vds = {1} : {2}, error = {3}"
I would replace this by System.nanos() instead of doing a call to nanos. To prevent running out of inlinining budget.
Doing this via double math is still 3x slower than return (nano + 1000) / 1000L;
same here - call the constructor with 4 args
Shouldn't we return the actual estimate?
You should return the native pointer you get from the nativeCreateWatchStream method: suggestion return this.nativePtr;
why not delegate.getSystemMemoryUsage()?
Should this maybe return RecordStore.DEFAULT_TTL (-1 --> use MapConfig's default) instead of 0 (--> infinite max idle)?
Why are we doing double math here? This should be: return Math.max(1L, nano / 1000L);
is this going to be removed?
might be worth writing a function for this since you do it in a lot of places.
Same here.. we should not have these checks here.
Here, we need to check value also along with key. A case like createBucket, DeleteBucket, we will have the key in the cache for that bucket, but with the value null. And also is this isExist will be called with the lock? As someone can modify the same key while checks are happening.
change "get(key)" to "redisSet"
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
How does this work when an item is evicted from the underlying cache, but is still in locker?
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
Since the first if returns on success, we should just get the countMatches into a variable, and check it to determine which type of StarPathElement to create.
Make it faster simply by calling get once and checking if the processor is null.
Variable name choice is confusing because it shadows the field key
I believe get(null) won't work correctly if map contains only one element with null key. That's not the case if map contains several elements.
Why is it public?
Can you add a check to see if the metadata is present (stream.hasMetadata()), if not create metadata?
@fabriciofx Here also, we could return the body() of our decorated object directly
No, need for close here as you use try-with-resource?
No, need for close here as you use try-with-resource?
I guess this is controllable, but just to make sure that no v1 requests will exist any more? Any reason not to be backward compatible?
When does this happen again?
i think it's better to move this logic inside the DiagnosticsProvider (DiagnosticsProvider.addRejectedStream(ImediaStream, msg)
please remove unsed code
We should close is now to ensure the cloned stream if multiAccess is true (if it is false is is equal to stream).
Should return ReadOnlyArray.
Should return ReadOnlyDictionary.
personal preference (so up to you to take the suggestion into account) but I would go for :  if(cond) { return 1; } return 0;
before accessing it's property, wait for element
Do we need the toString() here?
Return value of the method is never used.
I think this is up to embed the current index into the message but this will result in a message like where no index is printed. The escaped ' also seem useless.
don't need to wrap safeFormat
Have you intentionally omitted index check?
For unknown size, getItemCount() returns either 0 (initially) or the current estimate. Why is not intentionally working if I ask for the item that is current estimate + 1? Why is not intentionally working if I ask for the first item before the data communicator has fetched any items? It should be my problem if my backend cannot handle the query for outside the range, or then when I return null then this just returns null. I would presume that 1) if exact size is used and I request outside the current size, I get the exception because we know this 2) if unknown size is used, the query is done even if it is outside of the current estimate - what this method returns cannot depend on the active range or the estimate at that moment or whether or not the data provider has loaded any items yet, as the flush occurs later during the roundtrip.
ImageData for current image needs to be updated in the array?
I like the way you change it (very smart) however I think this change is a very good candidate to create an unit test to test previous code working against new code.
A List<String> would probably be simpler to use as return value
IMO, "cluster.properties" is better because this is a cluster config
fileName += COMPRESS_PER_RG_OUTPUTS ? ".fastq.gz" : ".fastq";
@pwillworth why not use File#separatorChar ?
Another option here would be [FilenameUtils#getBaseName](<LINK_0>
{ }
The @Override should be on this line.
I can see why this is necessary, with the change a few lines above from 'indexOf(".")' to 'lastIndexOf(".")'. However, there are two things I don't like about it: * what about, say, "model.profile.profile.di" ? (granted, unlikely, but handled by the previous version of this code) * more seriously, this hard-codes an extension that is defined in a <diagramCategory> contributed by some plug-in on the org.eclipse.papyrus.infra.core.papyrusDiagram extension point. Other plug-ins can define additional extensions that aren't enumerated, here. Rather than hard-coding this, we should look up the extensions that need to be trimmed off in the DiagramCategoryRegistry
I would prefer to move this line in the if branch, so it is more clear, "return element" is done if a managed provider is available only
add(int, E)
We should not catch generic Exceptions. Can you make this more specific?
It is a good idea to add all releases in a finally block, so that we never lose permits.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
This is something I struggled with. The semantics of observed-remove make it not-so-obvious what the user _means_ by an add shipped in the same operation as a remove. In the Erlang client, we decided that sending _all_ recorded operations was the least surprising solution, with the caveat that removes are applied before adds.
same again: do not create a new empty exception but reuse the old one.
inline getInsertIndex and putAtIndex  ++count; int index; if (elements.length < maxSamples) { index = elements.length; } else { index = ThreadLocalRandom.current().nextInt(0, (int) count); } if (index < elements.length) { if (elements.length < maxSamples) { double[] newElements = new double[elements.length + 1]; System.arraycopy(elements, 0, newElements, 0, elements.length); elements = newElements; } elements[index] = element; }
if we implement that offset we mentioned, we could even map negative elements here with a negative offset :)
Do we want a test case that you can create an element with any revision?
I think only one impassable entity should be allowed on a Square. Exception otherwise.
I foresee clashes here. Should at least use <type> + "/" + <name>
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
It looks like we need to modify ContainerAttributesResource to simply take a Map in its constructor. That way it's not only simpler, but it would also mean that all attribute values (including user-provided ones beyond those available OOTB) would be represented by the resource representation.
The use of false here seems un-intuitive, in that we never update set the hash - even for new objects. Is this because we rely on the id being null in these cases in order to detect it is dirty? In any case I think it needs some tests around it.
Isn't that should be setWriteRate
Creation date and last modified date should not need to be set here since the database sets them. You may need to mark them as insertable = false, updatable = false in the entity.
This will probably disappear when you rebase.
@rishabh-997 there is one in the application constants that convers this
Would entity being null break the rest of the code?
you have to add a canDoAction message if you fail canDoAction
return Optional<File>
For easier maintainability in the future, I suggest having curly braces for this if condition.
matter of taste, this could also be return this.profileTypeRegistry != null;
<LINK_0>
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
why do you do the substring if you are using contains?
could possibly use instanceof here... when null is passed to instanceof it returns false.
I this this(url,new HashSet<>()); would better. What do you say?
getLoginMode() == LoginMode.JETPACK_STATS seems to be repeated 6 times, maybe it's worth adding a helper for it?
Program to interface, not to implementation - please change return type to Map<String, Object>
import that one as well, to make the code more readable, or prefix all with ConfigValues
Should this be putTransient because of IMap#putTransient?
I don't understand this change: envs should be referenced using ${env.MY_VAR}
this is unnecessary repeat code. The only thing you need to do if schema is not null is put the schema property in the ImmutableMap builder
Use Map for the declared type
In migration case, we shall validate if stats are associated with correct writeId. I think, in our tests, it should be pointing to last allocated writeId.
I'm not sure why but in this case the type inference didn't work, and we have to repeat <@NonNull String, @NonNull String>
check
logSizeQuota -> logSizeLimitPercentage
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
Why are you calling setUp()? Is there a way to avoid this?
Alex, I don't think they can be merged. getLong is still missing in the code base. Committing this patch without test seems a bad idea to me.
the order of arguments in assert*() is counter-intuitive... it's (expected, actual). Technically the 'result' variables should always be second.
run already called tally, so do you need to call it again?
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
That should be toHtmlForAnthology. You mixed those two up.
Missing finals
Let's set this to true in fixtures.xml so we make sure we properly load a non-default value?
the backup flag of the result will be false for 72e3a666-89e1-4005-a7ca-f7548004a9ab
there is Long.hashCode(long value) method.
Could you put this change to a separate PR?
bad hashcode.
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
Probably returned value can be long.
nit: Change 2147483647 to 0x7fffffff  for easier understanding.
If you have to cast here then you probably should have casted when reading the value from the data array.
You may want to prevent inlining of those methods too.
can this just be private?
i would just say that "Points with more than 3 dimensions are not supported" since most of the supported/unsupported things are property format related and those can be quite different independently from type of store.
can it be made in one line?
Please group mr, ms, and mrs together
Was the closing head at the end on purpose?
Why is this needed?
Why does the newline have three backslashes in front of it, but the other control characters only two?
Unneeded since it is in teardown.
Does this class exist by magic or ?
collectionName = collectionName.replaceFirst(".*getCollection\\s*\\(\\s*(['\"])([^'\"]+)\\1\\s*\\).*", "$2"); I think using the above regex makes the matches more robust.
If you use format, don't use concatenate +: format("... Expected regular expression (%s) ...", regex)
Using System.lineSeperator() makes me cringe. Can't remember/motivate why though... For some reason, it's taboo.
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
Are we comparing InputEdge vs SourceInputConfig here?
Is it OK to assume that neither of these can be null? Couldn't a user easily create a ref entry which only has one of these defined? Perhaps you don't really support this case in the code, but perhaps it should be supported? I can easily see a project wanting to override one without overriding/specifying the other.
Toni, could we please choose better variable names here? equals and equals1 do not say much for newcomer to the codebase. Or we could avoid storing partial results by: java if(!Objects.equals(editorPlaceRequest, event.getPlace())) { return false; } if (!Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier())) { return false; } return true;  Please let me know what do you think.
Should this code also check for null on total, maximum, minimum, average or maybe use Objects.equals for comparison on these fields?
what about the more readable: return Objects.equal(leftTraversal, other.leftTraversal) && Objects.equal(rightTraversal, other.rightTraversal) && Objects.equal(originTraversal, other.originTraversal)
otherGl should be changed to otherGroupLevel
Minor: suggest moving port == that.port && xid == that.xid to the position close to Objects.equals(sslPort, that.sslPort). We can compare instanceName first. The port and xid are usually same.
The object with empty links and null links should be considered as equal
Since the command is a list that can be initialized by getter method, I would revert this line.
is logics correct here?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
nit: was gonna point out this should stop matching the parameter value at # to avoid including the fragment value, but probably all the querystrings passed here wouldn't have fragments.
static?
nit: these patterns can be made private static final and reused.
suggestion Pattern argPattern = Pattern.compile("^\\$(?:\\{(.*)\\}|(.*))$");  Align with start and end of the string. Otherwise you would also match bla$ad or ${foo}bar
why relaceFirst instead of replace
Pattern.compile() is normally meant to compile a pattern once, and then re-use it. If you don't do that you can just define a Matcher directly.
Move this into static field
ChannelClosed needs to be added to (though not strictly necessary)
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
Unsigned types are not used in the current implementation. So, you can omit them.
This list needs to include soul lantern.
1. _1 suffix almost everywhere means that error code has one parameter. Use different names for exceptions. They are also expected to be self-descriptive. 2. Vendor-specific codes can't start with '0', '1', '2', '3', '4', 'A', 'B', 'C', 'D', 'E', 'F', 'G', or 'H'. Don't use 42S here, add some plain 90*** codes instead.
What type of view will TIMEX3 be? Right now, it is of type NULL. Move the case to the block that contains the correct view type.
For consistency, I think this should be "properties" plural to match the class name.
Put ITEM in front of OTHER_FUNCTION
What in the... Please no. You can do better <3
It is probably worthy to make sure this class only gets instantiated once per language. I would abstract it to its own file that enforces that class is a singleton and just use it from the UDF, if you call it from the "initialize" method *i think* the application environment ensures that only once instance would exists but regardless that can be explicit on the code too.
can move ListVersionView object construction in ViewFactory? this will replace publicBodiesConfiguration dependency by ViewFactory to make it consistent with other resources.
Possible NPE here unless I am mistaken -- there may be no defaultValue.
Could throw IllegalArgumentException instead.
space
We have a removeConfiguration so let's not allow null value here?
Should add the rule to config file?
Avoiding to nest the for loop inside the if would make it more readable:  java if (labels == null) { returns names; } for (Map.Entry<String, String> label : labels.entrySet()) { ... }
why do the values "true", "yes" and "1" equal true?
Class and constructor can be package-private as only used internally.
Shouldn't the key() and value() method also be renamed? Same in async client too.  return setSetting(new ConfigurationSetting().setKey(key).setValue(value), Context.NONE).getValue();
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
One more unnecessary "save and restore" of system property value. Please remove it to be consistent in the entire test suite and use clearProperty below.
Since this a string, safer to use StringUtils.isBlank
Change to: tenantId = injector.getInstance(Key.get(String.class, Tenant.class));
How about remove the property, rather than set it.
As noted above, just put the init code in init() unless there is a reason not to.
is super.init throwing the parents class Exception? Whats throwing Exception within the init method ?
super.init() method never throw an exception.
System.clearProperty can be used instead.
If we are going to use System properties shouldn't we reset them when the test tears down? We don't want any unexpected side effects when other tests run.
rename to child or childItem
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
suggestion list.setSourceList(new ArrayList<>());
This empty check can be removed if you add one element to values in the constructor.
missed two
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
create a member for ClusterServiceModel
You get it right. Per code conventions, I like to see brackets around if and else clauses.
Since the VM subtab always uses this query, I would encapsulate it inside VmAffinityGroupListModel and make its constructor no-arg.
Could write this as  final List<Integer> list = Arrays.asList(1, 2, 3);
That is not clear, why do we have "Save" is not adding alarm item is enough? Actually, it is saved in Realm but not scheduled in Alarm manager?
This is just a quibble given that the entire thing is private and the class is tiny. Still we could separate the loading of the preference and turning it into a ScaleInterpolation from the side effect of updating the menu selection. On the other hand I guess this is never going to be pure function anyway given that it reads from mutable source (Preferences), but it still might be an improvement. Regardless, we should log the exception instead of just printing it there so it shows up in the log. Since it isn't critical it could just be at INFO priority I guess.
getItems().length > 0 implies menu.getItemCount() > 0, so menu.getItemCount check can be removed. getItems().length is not sufficent, it should be checked that any of these items is visible, e.g. Stream.of(getItems()).anyMatch(IContributionItem::isVisible)
The last argument here is wrong, it should be swapped with the "..._changeto_all" of above. It's the tooltip that is shown when hovering over the icon and tells the user what the *next* thing will be when clicking on it.
Could you please create a new enum for the Menu and Button constants (I don't like magic strings).
This is not right, take a look and see how was implemented on TripListFragment, you have to make TravelGuideActivity implement OnLoginLogoutListener and inside LoginFragment use attach and detach method properly, that way you don't need make it Parcelable.
In the other class you use a JBMenuItem. Any special reason to use a JMenuItem here ?
We actually _do_ want to remove the "Search Wikipedia" item, because we're already in the Wikipedia app. And we can reliably check for R.string.search_hint because it will match in all languages. (The intention of the "Search Wikipedia" item is to invoke Wikipedia from other apps where text is highlighted.)
DEREncoder shouldn't be referenced from ASN1Encoder - the implementation of this method should just be moved to DEREncoder.
While we're here, looking at this I realize that to be consistent, we shouldn't be hiding the sub-menu if its menu item matches and is returned by the method. So I believe this should be: } else if (!matches) {
should we use ObjectUtils.nullSafeEquals here as well?
It might be a tiny bit more readable to call this.sortFileSizeConditions as well. Ditto on line 359.
Good catch. Should be the same for initCond on the next line. It's a bit unnerving that this is not a compile-time error :( EDIT -- I checked with a structural search: Objects.equals($o1$, $o2$) with a constraint on o2's expression type java\.util\.Optional. This is the only occurrence.
Better to throw NullPointerException?
Isn't this... just a re-implementation of natural ordering? I don't think you actually need this.
can you use Integer.compare() here, or just inline it as written here: <LINK_0> the x - y trick has issues w/ overflow
Most of this should be replaced by a call to the base equals check via super.equals(obj). Take a look at any of the existing DTOs that extend TimestampedCandlepinDTO for an example.
Following the implementation with other nested objects, we should change this such that we only examine the certificate IDs rather than the whole certificate objects. You can do so by tossing a comparator on here that pulls the IDs from both sides and only uses that.
Isn't the use of the Util.collectionsAreEqual unnecessary here and on all other DTOs (manifest ProductDTO, ProductData)? @Ceiu am I right in thinking we only need to use this method in hibernate entity classes, because hibernate collections don't implement .equals properly?
we can't do this as we only include authoritative data reported to us (as opposed to deriving span's timestamp from annotations). The prior data incorrectly tried to merge authoritatively set timestamps (which was the bug). The better way is to prefer the client as mentioned before.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
This message should be included in our Log class (with a parameter for the service name and a @Cause, you have tons of examples in the code). The message should also probably be something like "An error occurred while loading an instance of service <service class>.".
I still don't understand why the key cannot be the session id
Simple for-each?
log this
Note that all references to CoreRegistry.get(class) need to be replaced with either @In annotations (best idea) or context.get(class) codes (find-and-replace). You'll probably need an @In annotation to pull in a context.
Missing @ Override
I see this method does something similar to execute minus the optional processing with the rowProcessor
....and then you don't need to call it on every other method
assert Hola
Move this else if just after the } above
Have we tested this with a song that is currently being played
should call super.onClick() here?
are the tabs here misformatted?
Camel case
Call provideAppName() from SalesforceSDKManager instead for appName.
Is this really needed if there is no code inside ?
Instead, use <code>android:textAllCaps</code> property for the <code>TextView</code> in XML. This is good, if this dialog class is supposed to show some other contents where buttons do not have text in ALL Caps.
Instead of comparing the text, which seems error prone, can we just check the visibility of the optionalFieldsLayout?
@theJenix look at this
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
Delegate to isNonCodedDrug() when making the check.
Please use <br /> instead of <br>
better use query(QueryRequest) method
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
Like Sille said: Please note that this is not possible, the first- and lastname are not set here.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
The part "authz.facility_id=facilities.id" is the same like in the first left outer join. I think it is not needed here.
The value here is null right? If so why we try to print the value? I think it should say Empty userID. Also, can we use StringUtils?
WOW, length(), avg() that's why SQL beats NoSQL
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Why not override visitClass() method?
If you clear the list at the end of the scan, no need to clear it before.
This one should not be necessary... safe to keep it but a bit defensive.
To always be safe please use context.getApplicationContext()
Please remove the public modifier
Constructor can be package now.
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
Is there any particular reason to call getMuteReason instead of just checking the value of muteReason directly?
constant?
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
For simplicity, this can just be return getChildren(inputElement);
Toni, could we please choose better variable names here? equals and equals1 do not say much for newcomer to the codebase. Or we could avoid storing partial results by: java if(!Objects.equals(editorPlaceRequest, event.getPlace())) { return false; } if (!Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier())) { return false; } return true;  Please let me know what do you think.
remore this case
should atleast check o being non-null and instanceof IdentityExtractionFn .
replace with return this == other;
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
![MAJOR](<LINK_1> Remove this call from a constructor to the overridable "fireEvent" method. [![rule](<LINK_2>](<LINK_0>
Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?
All uses of from/join on ExaminationConstraintConfiguration should theoretically be removable when converted to penalizeConfigurable().
Why fromUnfiltered(), if you then filter anyway?
Math.pow does long to double conversation, which is inaccurate, try (double) 9007199254740993L <LINK_0> then just to convert it back to long (again, inaccurate) Lets simply do r.getDrivingTimeFromPreviousStandstill() * r.getDrivingTimeFromPreviousStandstill() ?
Can we use the variable name "employee" in such cases? (Same for a above constraints) lamdba's don't have an explicit type written down. (It says "e", not "Employee e"), so for readability (most users start from one of these examples), let's use a full variable name. In general, in optaplanner-core only the following short var names are used: int i, Object o, Exception e.
I guess "visit -> visit" is better than "Function.identity()"? Should we experiment with thisEqual() or equalToThat() ? I guess that's overkill...
Use SimpleLongScore.ONE
For these very large numbers, I suggest you use _ to separate thousands. 1000000000 becomes 1_000_000_000.
code style: space after //
return constraintFactory.from(Exam.class) .ifNotExists(Exam.class, equal(Exam::getPeriod), equal(Exam::getRoom), lessThan(Exam::getId)) But that won't change much, if anything.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
can you explain why this change ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Fix indention (should align with following code).
Copy paste code block? Split it out into a function please.
should we have an "unsupported" status instead of successful? successful seems misleading to me.
We are trying to remove the Globals class (in the long term). To facilitate this, could you please extract the themeLoader and preferences, and initialize them by passing the global objects as dependencies through the constructor (i.e. move Globals from this class to the caller)
Doesn't work as expected as this message is never displayed, whatever is the type of media.
This looks like it would have different behavior from what was there before. If this is based on the path, I'd expect needing to go through getFormFilePath (the method that builds database paths based on whether or not scoped storage is used).
Why don't we set the certificationstatuses filter of the searchRequest here? Then the DB could filter the results rather than having to put the logic in java below
This is a test for the userRepository in my opinion and should not be here.
no need for type cast
This line should be placed before the thrown.expect... calls, because the exception must be thrown by tempFolder.newFolder.
None of these error cases need to post events
agreed :) Shall we rename the field "thrown" to "expectedException" so the link with expected is more clear?
if exception is thrown by validateRequest, thrown configuration should be done right before validateRequest is called
wait I'm sorry. Shouldn't all the 400 ones be false?
Probably fine... as long as the remaining body of the constructor doesn't try to trace anything. Also, instead of moving this, we could try to make the setting of the hostname more standardized by moving it into the AbstractServer constructor itself.
Not necessary. See quality rule : MITRE, CWE-397 - Declaration of Throws for Generic Exception
Don't you need a super.tearDown() call here at the end?
super() can be spared here.
Do we really need this? It's implicit
this("Safety Command")
personal style on my part - have only one constructor do super() - so have this one do this(true or false).
CalDavConfig has no super class (except of java.lang.Object). Do we need a super() here?
I think this will be called automatically.
There is no need to call super explicitly. Same applies to other constructors.
can be spared, it will be called implicitly anyway
This public constructor is unnecessary because the compiler will generate it.
It might be more readable if you have one setter per line.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Don't initialize to empty when null.
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
Simpler as ImmutableMap.<String,String>of().
suggestion return Collections.unmodifiableMap(tags);
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
what if length is not 2 ? Can you split by the first : and have the remaining as the second element ? Also a tag with only a key is valid
We'll need to extract the ifIndex from the resource to be able to get everything we need.
suggestion String[] tagItem = tagList.get(i).replaceAll(" ", "").split(":", 2);
Why not Map here?
Shouldn't this message be changed to "Should be 500"?
instead of calling an extra method for just one if statement (seems a little overkill), why don't you do one if statement to determine the validation status Status status = condition ? passed : failed and then one more line for setting the status if it needs to be set => 3 lines of code
This doesn't look like a recoverable scenario, should you be re-throwing this one? Or is there some default/fallback VipAddressResolver if the instantiation fails here?
Let's make sure that no project uses this resolver. If there is a project using this resolver, let's throw an exception and tell the user, he can't remove the resolver because it's used.
why do we need this setter exposed? Should constructor handle this automatically?
annotate this instead
I think this can be set by spring application.properties without creating bean explicitly.
I think it's nicer to call the AnnotationCommandTargetResolver constructor here, with, as suggested earlier, this as the sole parameter, so that the AnnotationCommandTargetResolver constructor can pull the identifierAnnotation and versionAnnotation from it.
It might be more efficient to do: java this(new DefaulBearerTokenResolver());
Should this perhaps return null on error or something? Otherwise, the following resolver = ... line could be partially initialized which doesn't sound right to me. Or should it use the default configurator like in line 658?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
Please group mr, ms, and mrs together
Hi @diegolovison , I think the message here should be not stopped but: Pattern.compile(".*\\[org\\.jboss\\.as\\].*started \\(with errors\\) in.*"); (at least this is how it was before Gustavo's changes) Would be great if you will fix that too. Then I will rebase the PR as I am facing this issue too.
Why is this needed?
This may become static member of the class.
It would be nicer/easier to debug if you extract the numbers with this regex: "^(\\d+)\\.(\\d+)\\.(\\d+)" Then do a comparison separately. java int result = ComparisonChain.start() .compare(1, Integer.parse(matcher.group(1)) .compare(14, Integer.parse(matcher.group(2)) .compare(0, Integer.parse(matcher.group(3)) .result(); assertTrue(result <= 0, "Expected BigtableVersion.getVersion() to be at least 1.14.0")
please no if one liner if(!pattern.matcher(viewNameEditor.getText()).find()) { ... }
Why does the newline have three backslashes in front of it, but the other control characters only two?
It's too bad we have to resort to regex for this, is this format considered fairly stable and unlikely to change in the response?
This breaks the handling of Youtube URIs shared from the youtube app. These URIs are of the form <LINK_0> Didn't test sharing from the website.
nit: param doesn't need final
Collectors.toList()?
Would return builder(SecurityLink.resolved(security)); be simpler?
No lambda param type needed, we use the simple form result -> ...
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply);  (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
You could just use: java return RxJavaPlugins.onAssembly(new SingleToObservable(mapper.apply(t)));
"update__s__"?
Can't we use containsKeyAsync?
This can be removed now.
I want to method accessor to be package private :eyes:
Please use the more compact one-line syntax:  java if (defaultUI == null) return;  for consistency with the other blocks of code in these here parts.
Also this: parent.syncScroll(DisplaySide.A); // match A's viewport
Why not use the builder syntax here?
You can create a new method to show the snackbar, with the error message as parameter.
Extra line
Import View
This looks like the meta-data panel would first be initialized to display the meta-data for a structure, and then reset to show the meta-data of a media unit. Could you please clarify that? For example:  Optional<IncludedStructuralElement> structure = getSelectedStructure(); if(structure.isPresent()){ metadataPanel.show(structure); } else { metadataPanel.show(getSelectedMediaUnit()); }
Show description can be null.
You can call Arrays.stream() directly
Add log.info "connecting to ATSD at host:port"
Why are we eating the exception here?
I think it's unnecessary, method is synchronized?
Add the info log back after this line?
I don't think this is going to work reliably. The read may have split a multi-byte sequence at the end of content and then creating a string from it is going to break. Is there any reason you want to use a stream when reading the temporary file rather than a reader?
Why delegate the closing to an executor?
@rvansa I think stop() should release all the semaphore permits. Threads trying to read from/write to the store after it was stopped should throw an exception immediately, they should not block forever.
We are doing nothing here. Bad practice. We should let the caller know.
should this be synchronized?
could put the loop inside if block? i.e. java if (!WAKEN_UP_UPDATER.compareAndSet... ) { // Busy loop ... while (wakenup != WAKEUP_NOT_ALLOWED) { } }
rename to comply java standard name convention. validateEmail
Avoid ByteSource in API. byte[] is ok here
format should default to "tar.gz" is null or empty and not throw an exception.
I'm pretty sure this is a breaking change. Certain libraries like Kragle and I believe our UI expect the dates in the previous format with the Z at the end.
This is strange that this method throws SizeTooLargeException and not the new one. Are you sure that this exception is always necessary?
format is a noise, let's use simple message make an assertion on it
Same here with length() == 0 -> isEmpty(). I'll stop mentioning for the rest of these :)
maybe use clusterName.pid to not conflict with instances from other nodes?
one-time variable port
suggestion event.setMessage(FormatUtil.formatMessage(user, "essentials.chat", event.getMessage())); if ((ChatColor.stripColor(event.getMessage())).length() == 0) { event.setCancelled(true); return; }
70-75: extract method (see following methods)
i would add additional check to make sure we will never make it to more then 100 :)
if the max stream tail moves, it calls prepareSiteRoleChange(), which call queryStreamTail() one more time, and will update totalNumEntriesToSend. Then it call queryEntriesToSend() again, will get a pretty close result as currentNumEntriesToSend. So percent calculation will always return a 0.
there is no need to declare it public
just call this percent
You should save the list to a variable
extract 0.5 as a final static member constant
zoomIn and zoomOut code differe only in single line 'plot.zoom[Out](zoom)' please avoid code duplication
The method could have a few "else" statements added and reduce the number of return statements.
I think we should have a failsafe to not lose metrics data.
Maybe wrap in an immutable map.
Maintenance of the map will be simpler than that of the list
no need to say "public" here, it is always public in an interface. "static" is important though.
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
try using getOrCompute instead. Besides delaying creation of the collection to the moment where a key actually wasn't found, it also stored the result in the map, making it somewhat faster for consecutive invocations.
Could just do CalculationFunctions.of(wrappedFunctions)
Maybe make it unmodifiable?
Let's use stream API instead of a loop.
Same deal here: use this version as the base, and have the extended versions just call into it with each arg.
Perhaps even simpler (and certainly a little more efficient) would be: addSymmetrically(map, boolean.class, Boolean.class), where addSymmetrically = map.put(a, b); map.put(b, a);
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Can this be private, or is there another use case for default attribute outside the builder's call?
add this selector to UI mapping at the beginning
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
Current code doesn't detect port 8080 is used by my local EAP. The only way it works for me is if it's implemented as  java try (Socket socket = new Socket("localhost", port)){ return true; } catch (IOException e) { return false; }
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
Let's add a message here: "Checking if port XXXX is in use...".
Could use port 0 to avoid someone else stealing the port.
Should be > I think, as we _could_ have found port 65535 was available.
typos Used, ..
I believe it's actually possible to verify that the port is unused, rather than just hoping that incrementing will give us an unused port.
maybe  java public ServicePortAdapter(ServicePortAdapter port) { this((IServicePort)port); this.routePort = port.isRoutePort(); }  would be better here. It becomes clear what the new constructor does additionally
I believe this line is incorrect and should be removed
ohh.. actually we should default to 443 if https!
Why is this still using the Id?
format should default to "tar.gz" is null or empty and not throw an exception.
Why is this still using the Id?
I think this is ripe for unit tests, along with removing relations to make sure the tree is pruned.
A design where this is side effect free would be most desirable.
minor: this v == null check is unnecessary.
To me, mixing String.format() and concatenation IMHO does not make the code particularly crystal-clear :-) You should either use  String fileName = String.format( "%s%s_ExportedPersonnel.%s", //$NON-NLS-1$ campaign.getName(), campaign.getShortDateAsString(), format.getRecommendedExtension() );  or  String fileName = campaign.getName() + campaign.getShortDateAsString() + "_ExportedPersonnel." //$NON-NLS-1$ + format.getRecommendedExtension();
Use getClass() in these two places.
Calling String.format with 1 parameter is a no-op.
Try using dateInLocaleFormat instead
Unfortunately, you cannot delete this method. This is how we initialize our Indices when they are created via reflection in the AccumuloRyaDAO.
Just let the exception bubble up, otherwise it can be confusing to debug IOException ' s.
I would not print anything to stderr. I would suggest using a logger and use it in both cases (cleanMethod or invokeCleanerMethod)
I think the following variant would be simpler  } catch (IOException | ApiException | MachineTokenException e) ... }
no need for this double nested try/catch, move this block to the cleanMySqlCleanupThreadsThreadFactory method if want to log that this particular cleanup failed. Is more cohesive to handle the exception for logging in the method that has the logic that failed.
Same as DaemonOp: Awkward construction with the try/catch+switch/case
why should we use the getter to access the field ?
I don't think you need this check. Just return size * 1024 ?
I believe you could refactor this code snippet to a method and reuse the same code for both switching on and off.
I think this is cleaner  public long size() { return writeOutBytes; }
rename
not all listener
maybe rename?
rename
not all listener
not all listener
not all listener
Darn, I had overlooked that. Might be worth creating package org.eclipse.egit.core.internal; public final class SafeRunnable { public static void run(Runner code) { SafeRunner.run(code); } @FunctionalInterface public interface Runner extends ISafeRunnable { @Override default void handleException(Throwable exception) { // logged by SafeRunner } } } Then we could do here simply SafeRunnable.run(() -> listener.indexDiffChanged(repository, indexDiffData));
Previous line can be removed
Thanks for checking, have you considered the trade-off of toggling the timeout to be something very short, like 5ms?
Should we return immutable list here?
@v-stepanov Is method marked as @Nullable ?
Is there a reason to create an ArrayList here instead of using Collections.emptyList() ?
Why empty? It supports ALL streams!
use the interface here
Add the @Override annotation, and change the implementation to call emptyIfNull() if you accept my suggestion in ListObjectsResult
Could you at least make this return a non-null value?
-1 having asserts, if it called twice it wont error but simply proceed. Is this really a good idea, risk breaking or erroring
since elements of the stream come from ImmutableList, they cannot be null, can they?
Please use TimeUnit.MINUTES.toMillis(15)
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
This is a bug
This is wrong.
![MAJOR](<LINK_0> 'Severity: MAJOR') Constructor has 12 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
suggestion
user is never null - if user is null, canDelOthers is true and returns on 61.
This is an overloaded method, why change the name?
This doesn't look right.
this is the spotbugs issue, you're building a new object but not assigning it anywhere
Concatenation of e.getMessage() is redundant
this should be config.get("path-style-access", boolean.class, false)
It is good to have a method to convert config.get(Config.TOPOLOGY_RELIABILITY_MODE) to enum and then compare two enum values. Comparing two Strings is error prone.
This code should use instead entrySet
please remove or decrease log level to TRACE
Nits: use Map as the variable type, and omit the generic types after HashMap. You're also missing spaces before arguments as in ",hints)" instead of ", hints)"
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
Can we use IndexFig here to set the default? Same with initial creation.
It seems we create and fill a temporary ArrayList here that we drop after filling without using it. I guess we miss a config.setPartitionLostListenerConfigs() call here.
I haven't looked if it's true for AbstractBindings, but for AbstractActiveBindings it has side effects to setProperlyConfigured(false) and then setProperlyConfigured(true). A different pattern could be:  java if (config != null) { boolean properlyConfigured = false; try { // parse and throw as needed... properlyConfigured = true; } finally { setProperlyConfigured(properlyConfigured); } }
java import static org.apache.commons.lang.StringUtils.isNotBlank;  for easier to read code
This method should first attempt to get it's result from a file stub.
@ivandalbosco This method should be annotated withjavax.annotation.CheckForNull.
That's wrong. Please see org.intellij.erlang.psi.ErlangSpecFun#getReference and isReferenceTo() method.
java if (function.isDeterministic() && hasInputs(function) && allConstantInputs(function) && !evaluateDeterministicFilterFunctionWithConstantInputs(function)) { return false; }
xor should take care of these two checks
Always use blocks! :-)
please don't reassign method parameters. use this.baseIteminstead and the elsecase for the other assignement.
Why did you do that? That's incorrect.
maybe you should use the decorator name (if available) in the synthetic function name (more readable when debugging). Else, I think __$$_decorated_foo_0 is a better name.
why not just return if function == null?
Please add ioe to the exception.
Please add ioe to the exception.
we should pull the ObjectMapper out as a static final and use Afterburner, to avoid thrashing and testing too much serDe  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().registerModule(new AfterburnerModule());
Yes. I would say this is an api change. So we should deprecate the old method first
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
Does this need to be done atomically for all data within the base dir?
You need to apply this method over the duplicated methods. so you need to remove getChatter, getCampaign, ....... etc and also this method should be static
Sorry did not get. How AtomicBoolean is different compared to boolean wrt repeated roll possibility. In the past we used to keep the Boolean state in a Map. Now in this object.
rename local variable
nit: I think in other places we use PtBytes#BYTES_COMPARATOR shim to this method. Just something I noticed.
Ahhh, the speaking check is here. Calling speakNames() to have to sometimes not speak names is confusing and wastes a method call. I think we should just pass the boolean into presentation manager.
null != settings
I think the existing code is correct for the "jump" plot behavior - this should advance the plot as time marches on. Although this change would result in desired behavior for the non-changing historical data, it would result in incorrect behavior for live/streaming data. The issue comes from the fact that settings.getMaxTime() is returning system time in the first place. This makes sense as a reasonable default only in the absence of a time service, but should be overridden if a time service is available. Some care should be taken to ensure that only defaults are overridden in this manner (e.g. to avoid overriding when getMaxTime() is returning a persisted user-specified value.)
Since both annotations define a default value when is this ever 0?
Looks like you forgot to pass ignoreTrailingAndLeadingWhitespace to CsvParserSettings.
you should catch EbodacLookupException too
Still confused about this line. Shouldn't SystemTestData use the default, which is to not included the prefix? I would expect this to break existing tests, unless i am misunderstanding something.
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to remove it altogether, no?
no need to explicitly create an array for var args
What about to log only in info level? Warning is for me like something that I should fix, but this is gonna be intentional in most cases.
This doesn't honor the contract of an iterator's remove. In fact, i'm not sure you can support this atomically with only a single file.
How is this changing how it used to work previously?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Should the override annotation be on a separate line (not sure of the convention in this codebase)?
As this operation is optional, just say it won't be supported because it's not mandatory.
Instead of "Not implemented yet", I would suggest "Iterator is read-only"
UnsupportedOperationException
nit: UnsupportedOperationException (java.lang) is more descriptive.
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
Static string constants
Could you please replace this boilerplate pattern with a single method registerSerde(String, Supplier<ComplexMetricSerde>) thoughout the code?
How did this happen?
No tests to cover this method! :open_mouth:
Could use .get instead of .getOrDefault
prefer entrySet() for (Entry<String, FileModule> entry : typesToRename.entrySet())
This method's logic is not limited to just typeArgumentTokens, you can reuse this method call in other places in your code to reduce the duplication of your checkstyle logic.
type_ID -> type_id
Add final keyword.
Shouldn't we use empty list here ?
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
minor: can you regenerate toString to reflect the renamed variables.
This should also flag whether the binary is reused.
please use org.ovirt.engine.core.common.utils.ToStringBuilder
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
toString() not needed
Why the super.toString()?
I prefer short log messages for events. Would suggest to change it to  return itemName + " changed from " + oldItemState.toString() + " to " + itemState.toString() + " through " + memberName;
Should have a space after add
Another space after add
binding -> bindings
@prachidamle you shouldn't need to quote the string. The nature of program arguments is that they are passed as a whole string.
This doesn't feel like an improvement; the original form was easier to follow, IMO, despite the ugly lack of whitespace around the binary operators ;o)
This should use the Guard methods to also check for empty strings.
We can probably replace this with Paths.get(srcDir)
This might not make sense on all platforms
I'd rather not. I hope to kill these in the future. If you need a URL to the change, you instead should use: $BASE_URL/r/$change Where $BASE_URL is the URL you would access the server from in your browser and $change is the event.change_id that is being passed in as the --change flag. Or.. have the server generate the URL and pass it down with a --change-url flag.
use the constant here?
I'm wondering why we even need this class; can we not simply add a boolean property to the base class called "appendPartitionId" ? Also, the ticket description says "If SingleFileOutputOperator is partitioned into **more than one** physical instances then it should append partitionId to file name" (my emphasis), I don't see any check for that condition before appending the partition id.
context.PROCESSING_MODE => OperatorContext.PROCESSING_MODE (to get rid of "The static field Context.OperatorContext.PROCESSING_MODE should be accessed in a static way")
I'm thinking if we could provide an automatic way to call these method by set annotation on the field just like those IoC frameworks do
You could simply do super.setClazz(CommonLog.class)... You don't need to have a vaeiable pojoClass.
As it is a new behaviour, should this be exposed as a new method in the operator interface? This allows us to identify the operators that actually make use of this feature.
The setup of updatedKeyStorage is not needed if fireOnlyUpdatedPanes is false.
When is ps not null?
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Why did we switch out the old code back to this?
Similar to above, why have these redundant calls?
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
Remove this
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
when doing enum comparison the double-equal operator (==) is a bit nicer to use :)
Missing StringUtils.isNotNullOrEmpty() check
(optional) likewise [and so on in other files]
these setters should not be public
Can we make it final?
Can you separate out the 4lw call onto it's own line?
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
My problem here is that the timeout is coming from another place (that will override this). I don't like properties coming from two places. I don't have the best answer but I don't think it's a good idea.
What is this test for?
I think we could reduce this constructor to a call to another constructor:  java this(configuration, null);
this is perhaps incorrect. This queue should be Multiple publisher single consumer
I think buildBigtable*Settings should just return built settings and you can the InstanceAdmin one return null if the emulator is enabled
Worth reporting what was null?
this.configuration = Assert.requireNonNull(this.configuration, "this.configuration"); We should use this pattern for each final param that is created by the constructor. By doing so exceptions in case of a null value will be thrown as early as possible
Path also offers other API at <LINK_0> You can specify both of the params as String
There is another constructor that would require this initialisation.
As iirc a HC can not spontaneously become a DC, I wonder if we could cache this data. Otoh, this is a relatively light-weight call and not done often, so probably does not warrant the hassle of cache invalidation checks.
F.isEmpty()
What about skipping parenthesis, so that we still raise issue for the following: conn.setRequestProperty("Authorization", ("Basic " + encoding + encoding))
It seems this check is not necessary because it is covered by the scheduled.compareAndSet logic.
[minor] This return value from safeUri() should be reused a few lines below.
you're testing binary branching, i.e. an if. A switch is meant for more branches. java's switch can be linear or can sometimes binary search or a lookup table. Javaslang's is always linear. Please test them properly.
you should parse the response and use the parse values for comparison
IMPORTANT res = pipe.waitForCompletion(timeoutMillis) && res otherwise after the first fails to complete the boolean expression will short-circuit and the other waits won't get executed..
The bug fixed with commit <LINK_0> has not been reported here
Can getProjectClassLoaderStore() return null? It should never do that because it returns a map (which can be potentially empty). So we shouldn't need this null check. Also if it never returns null, you don't need to check if the map is empty. If it's empty you just assign empty map to this.projectClassLoaderStore and don't need to do it separately in the else branch.
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
@tsurdilo take a look at org.jbpm.kie.services.impl.CommonUtils.getAuthenticatedUserRoles(IdentityProvider) that does some additional logic in case roles are empty list. There is an issue with some dbs handling empty list as part of in clause
getStorageDomain is the TARGET domain - you should get the SOURCE domain according to the storageDomainId parameter passed.
This block is repeated here: <LINK_0> It could be refactored as a private method to avoid repetition: > @Override public Collection<CaseInstance> getSubCaseInstancesByParentCaseId(String parentCaseId, List<CaseStatus> statuses, QueryContext queryContext) { List<String> ids = Arrays.asList(parentCaseId); return getSubCaseInstances(ids, statuses, queryContext); } @Override public Collection<CaseInstance> getAllDescendantSubCaseInstancesByParentCaseId(String parentCaseId, List<CaseStatus> statuses, QueryContext queryContext) { // this will iterate foreach level. It will do as much queries as levels in the hierarchy List<CaseInstance> cases = new ArrayList<>(); List<String> ids = Arrays.asList(parentCaseId); do { List<CaseInstance> processInstances = getSubCaseInstances(ids, statuses, queryContext); cases.addAll(processInstances); ids = processInstances.stream().map(CaseInstance::getCaseId).collect(Collectors.toList()); } while (!ids.isEmpty()); // empty means there are not more leves to go return cases; } private List<CaseInstance> getSubCaseInstances(List<String> ids, List<CaseStatus> statuses, QueryContext queryContext) { Map<String, Object> params = new HashMap<>(); params.put("parentCaseId", ids); params.put("statuses", resolveCaseStatuses(statuses)); applyQueryContext(params, queryContext); applyDeploymentFilter(params); return commandService.execute(new QueryNameCommand<List<CaseInstance>>("getSubCaseInstancesByParentCaseIds", params)); }
> public abstract class ExecutionStrategy { this super(); call doesn't need to be here
should be named resource
should be called resource
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
setupCreateMandate
It would be cleaner from an OO point of view to pass an instance of SortSpecifierContainer that contains no sort item. This ways, several _null_ checks can be avoided. This special instance of SortSpecifierContainer could be cached in a static field that is publicly available.
collect to a set that can preserve order?
I don't think it's necessary to create a set here since it accepts collections and then tries to figure out the fastest way to check them.
We should check whether the variant context in the output vcf is filtered. The output vcf in testDreamTumorNormal has one filtered site (20:38245275, alt_allele_in_normal) and it's counted as a false positive. This applies to calculateConcordance in HaplotypeCallerIntegrationTest also.
pico-optimization: dataStreams not needed until after templateName is confirmed to exist
Method newTargetGroups has a Cognitive Complexity of 8 (exceeds 5 allowed). Consider refactoring.
You may want to drop the logging level in a follow-up PR.
Fine with me (although it does slightly detract from the opt-out possibility). WDYT about adding a retry backoff though? I'm a bit concerned we might just end up stuck in a loop of useless rebalancing, and waiting the full probing.rebalance.interval doesn't feel right either
suggestion if (highAvailabilityEnabled) { taskAssignor = new HighAvailabilityTaskAssignor<>(clientStates, allTasks, statefulTasks, assignmentConfigs); } else { taskAssignor = new StickyTaskAssignor<>(clientStates, allTasks, statefulTasks, assignmentConfigs); if (!lagComputationSuccessful) { ((StickyTaskAssignor) taskAssignor).preservePreviousTaskAssignment(); } }
maybe hostInfo would be a clearer name.
Ideally, we'd use the Time#milliseconds() here instead of System.currentTimeMillis(), but you'd have to pass the time instance in through configure. It would aid in testability, but it's not strictly necessary. I'll leave it to you.
Once again, just use getMonth(calendar), which embeds the knowledge of the +1 difference in its body. DRY.
But existing rows use null not "" for the parentUuid.
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
This would never return a fully qualified host name.
Same as before, you can bump this up to "1.8".
@jrdalpra we also need negative test cases here like e.g. it is still not allowed
Is there a way to share code between tests? Presumably DownsampleSam shouldn't actually take the X:Y coordinates into account so maybe this isn't necessary?
Use Local variable start time created on top instead of new Integer(0)
CheckReturnValue?
style: extra parentheses
we need good docs here
remove throws OseeCoreException
Swap the order of modifiers, like it in all other methods in this class.
Does it have to be public?
Please add @since 2.8 here to indicate when method was introduced. Also, for backwards compatibility, please make this throw UnsupportedOperationException, so that existing non-json implementations will not fail to load with 2.8.
I'd like to suggest rollbackOutputCommit.
Same final question.
Should these all be final then?
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Remote exception handling changed a bit, so I think you can make this more specific: if (throwable instance of RemoteException && throwable.getCause() instanceof RetryPrepareException).
I think you want isPossiblyOkHttpTimeoutBug(cause) otherwise it will SO.
Do we want to include the original throwable so it can be shown in stacktrace as "caused by"?
Again, we shouldn't do this.
This can be simplified java if (throwable instanceof AmqpException) { return new ServiceBusReceiverException((AmqpException) throwable, errorSource); } return throwable;
List<Throwable> list = new ArrayList<>();
this line can be removed
This can be condensed. java if ((throwable instanceof ServiceBusAmqpException) || !(throwable instanceof AmqpException)) { return throwable; } return new ServiceBusAmqpException((AmqpException) throwable, errorSource);
nit: extract the logger into a constant
Optional.map
Optional.map
You should pass here message not group converted to string.
These might look a bit tidier as static imports
There should be an assertion around this.
Possible race condition.
that's invalid anyway, isn't it? what's the meaning of CLUSTER_DEFAULT on cluster, you can never set it. autodetect==null, and then only concrete values are allowed
The only reason you had to override next(), expose pendingObjects, and duplicate all of this code was for this r.has(BOUNDARY) test? Any way we can skip that flag test on the commit?
Could also do:  ApiDate lastSeen = Optional.ofNullable(r.getLastseen()).map(ApiDate::new).orElse(null);
make a "give me a random long" helper function.
remove
NPE if header missing.
How about to use here NamedParameterJdbcTemplate as you've done in the JdbcChannelMessageStore#doPollForMessage ?
formatting
unused variable
if (!selectedItemList.isEmpty()) { selectedItems = selectedItemList.stream().filter(o -> o instanceof Integer || o instanceof Long).map(o -> (Long) o).collect(Collectors.toList()); if (selectedItems.isEmpty()) { return null; } }
you can change it to: if (!timeRequestedList.isEmpty()) { timeRequested = timeRequestedList.stream().filter(o -> o instanceof Integer || o instanceof Long).map(o -> (Long) o).collect(Collectors.toList()); if (timeRequested.isEmpty()) { return null; } }
This assert should be executed before trying to access the first element in the list.
You will see a problem: nullable annotations go bananas. :(
- This is why EnableAutomaticHostPowerManagement sould be Boolean and not string. - Please use code blocks even for a single command. - Please log why you return null, so we'l be able to tell why we're not balancing.
Add here if (outlinePage != null) { outlinePage.setSelection(new StructuredSelection(selected)); } to make the normal outline page follow the selection in the quick outline.
How about return ((List<?>) ((IStructuredSelection) selection).toList()) .stream().allMatch(e -> e instanceof RepositoryNode); ?
boolean canExecute = false; if (selection != null) { canExecute = Iterables.all(selection, Predicates.instanceof( AbstractToolDescription.class)); } return canExcute;
Why do you not return directly the condition value ?
If the argument selection is a NodeSelection then the method brakes it's contract and doesn't create a new instance. I'd remove the if statement.
you can use IStructuredViewer::getStructuredSelection
looks superfluous, since the type check in line 96 will already deal with non-fitting objects
Shouldn't you compare the start/end of the segment with the selected one? You could have a segment overlapping the selection start, with the same aspects.
You are in the middle of on iteration of selection, why pass all the selection to this method?
This condition is wrong: CompartmentEditPart is a GMF classes and not a specific class to handle Sirius compartment & region.
Is there a subclass? I'd like to see these protected methods be private if possible.
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
unnecessary parenthesis?
nit: String.format may allow this read better ? (opinion)
Can be replaced by: return script != null ? "" + new String(getHash()) + "\n" + script : "" + new String(getHash()) + "\n" + url;
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
I assume these tests will never run on Windows, right?
Should check if the Counterparty that should be updated belongs to the logged AppUser
A validation should be made to compare the oldCategory.getUser() to current authenticated user. Maybe...what do you think?
See UseCase.
remove unnecessary { return x; } around wrapBlocking
remove unnecessary { return x; } around wrapBlocking
remove unnecessary { return x; } around wrapBlocking
throw RestException with Status.NOT_FOUND instead
createTileOverviewForm()
@ResponseStatus(HttpStatus.NO_RESPONSE) Then you can change return type to void and remove the return statement
Same as affiliationsController if condition.
Add not-null check here.
@aklish what do we expect if both initializer and injector are defined?
Maybe some not-null check should be added here.
Is this code well-covered with tests? The spot where it moved to is different in ways that I don't entirely understand (like where did line 715 go, and why did the set turn into an inc?).
Maybe this should use makeUnknown instead of getUnknown. I think the difference is that makeUnknown will create a new one, and the new one will have its own insert date and user. I think getUnknown will cause all placeholders to have the same insert date and user.
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs, ...)?
Please kill this empty line.
you could directly call updateServerHookStatusInDb() here. Also remove the unused serverHooks.
Please don't remove the Network, just add another "else if" for the NetworkView. This procedure can be useful to get the id of a Network entity in a generic way.
I think this can be deleted
Why change the name the property? Accident due to mass refactor/rename with IDE?
Translate this RuntimeException message in English please
space before {
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
this.fragment = fragment, no need for the ternary ? operator
Can be simplified to the following to prevent unneeded conversion to a list. Sets.newHashSet(splitPreserveAllTokens(eventFieldsOpt, NULL_BYTE));
Hudson.util has an static method for fixing empty collections <LINK_0> suggestion this.mesosAgentSpecTemplates = Util.fixNull(mesosAgentSpecTemplates);
This can reference SamRecord.NO_ALIGNMENT_REFERENCE_NAME to make it clear what the * is
Hey @drealeed thanks for the PR! Could we move this check to the beginning of finishFetch() and call close directly and return if dis is null?
Let's use the same logger we use for the rest of Baragon rather than System.out, for example <LINK_0>
nit, Collections.EMPTY_MAP?
what if the subExpr is empty ?
Now that this will be returning an object that is never null, refactor Optional return to Map<String, String>
s/on name. But got:/by name but got:/
Might just be a personal taste, but I'd also prefer a for loop here:  for (Filter f : filters) { ArrayList<String> parameterValues = f.getParameterValues(parameter); if (parameterValues.size() != 1 || (commonValue != null && !commonValue.equals(parameterValues.get(0)))) { hasCommonValue = false; break; } commonValue = parameterValues.get(0); }
The code that creates the referenceInterfaces should only consider the references included in the definition of the component with kura.service.pid=pid. The getPidsFromTarget() method seem to ignore the pid argument completely. This might cause incorrect interfaces to be added to the set and included later in the search.
You should call 'updateBondOptions()' also before registering to the listener, to align with the changes were done in the model initialization before you added the listener.
The 'list' is never used. Please remove it.
I think that EntityChangedEvent is more suitable here. EntityChangedEvent is a private case of PropertychangeEvent, when the changed property is 'Entity'.
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
How about remove the property, rather than set it.
super.init() method never throw an exception.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
can't be null?
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
Should be removed if empty
If we are going to use System properties shouldn't we reset them when the test tears down? We don't want any unexpected side effects when other tests run.
immutable copy!
Should make sure the constructor and this method follow the same pattern around ensuring the internal values list isn't mutable. Right now the constructor will clone the list, effectively a deep clone based on how Strings work, ensuring it is immutable if the original list changes but this will return a reference to the internal list that could be mutated.
Can't this be further improved to just Arrays.asList(values)?
This seems like a mismatch, maybe you should not include the @Nullable here?
Nit - just return Arrays.asList("createSockets", "getInsecure") instead?
You probably could directly do  Collection<RuleTemplate> toReturn = new LinkedList<RuleTemplate>(values);
I think it is better to use static import here
Instead of null, we can do StringUtils.hasText() or something related to avoid empty string.
I think Local.ROOT is probably a better choice.
Just asList is enough no ?
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Do same for this one
> new Date(mExpiresOn.getTime()) [](start = 15, length = 30) why are we returning a new object? #Closed
I wouldn't fix this in the same PR. Probably a separate PR for this fix would be better. It's not related to this change.
Why you are using diffrent methods here? 1 . new Date(onsetDate.getTime()) 2. (Date) endDate.clone() Better to keep the consistency among the code, and provide your feedback why did you select that among others.
Aren't you changing the original logic of this method?
wouldn't be better if we returned next date directly like: return generator.next(new Date());
@dmzaytsev you could use getRawMetadataValue(Headers.DATE) here
Couldn't we always use Instant.ofEpochMilli( value.getTime() )? That would spare us one instanceof.
One of our helper classes must/should have a utility method to get a time relative to current time. If not, add one?
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
I think the annotations should be on separate lines
Immutable fileinfo
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
Is it really filter name?
This should stay final
Should this method be final?
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Why do we return the parents name instead of the name we store a few lines above?
please also add the GUID which is important.
Do we need String.format here? Seems like String concat would be fine.
Wouldn't it be better to use the transitionMap to group by from state?
Currently we know that close doesn't throw, but just to make the code future proof we can use guava Closer here to make sure that both readers get closed.
If the first orchestrator throws an exception when closing, the second one will never get closed. Please use a closer instead; see org.hibernate.search.backend.elasticsearch.impl.ElasticsearchBackendImpl#close for an example.
Why not closer.register(...::close), as above?
close should invalidate the iterator, but you are reliant on the internal iterator for this. You should have a flag isOpen (or isClosed) that is checked for the various methods. Take a look at htsjdk/samtools/util/CloseableIterator.java You should also (evidently) call close() if hasNext is about to return false.
I think it will be better to close the other store as well.
This shouldn't be closing the underlying store since it may be shared with other 'NamespaceAwareCoordinatorStreamStore' instances.
rpcClient.close()?
You don't call unlock() here?
Build failed: Need to throw IOException or catch it  public void close(){ try { if (input != null) input.close() } catch (IOException e) { // ignored } }
Could you please add a null check and isClosed() check (if available)?
lockRefreshToken should be set to Optional.empty() here, otherwise isHeld() will still return true. There should be a test for this.
This seems needlessly complex. You're using a boolean supplier to assertTrue. Why not just call doSomething() directly?
fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)
Yeah, unfortunately the FunctionalInterface->Object conversion doesn't usually go well.
Do we not want to filter on isInstance first? (even just to protect from wierd bundle reloading errors?)
hmm.. we need to double check if it works as expected if child stage get CANCELLED / ABORTED / FAILED .. :) Update: ABORTED / FAILED shouldn't be a problem, since the query will fail: <LINK_0>
I think we should check for admin and group admin. Because the storeId is something that a user needs in the pipeline config.
can we add mimeType? This won't honor Accept header.
Should we try/catch here and return a 500 when the delete fails?
Did you test this? Why is it different from the lines above (LocationDto, TextEditDto, etc.)?
We don't need this, the ConfigSaved would handle this already.
Typo
as a suggestion you could remove the followup NPE check and use Objects.requireNonNull suggestion org.eclipse.core.resources.IProject project = Objects.requireNonNull(getProject(referencePoint), "No project found for reference point: " + referencePoint);
I disagree that this is the right place for it, it's hiding this logic in an unrelated place, I think this call needs to be done explicitly where the remove is called (as is the case for statistics)
Just thrown an Exception.
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
It it better to put it in finally block to ensure it is removed.
check not needed as HashMap.get(...) returns null if mapping for given key is not present
Your map is already concurrent so no need to synchronize. Instead check the result of the remove and if it does return something other than null than invalidate it.
Ah no, I didn't think. It's of course possible because we're removing the same instance and equals therefore works...
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_1>
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
Need to use parameterized logging instead of string concatenation.
Also not comfortable with this.
May or may not be necessary to e.getMessage() as well as , e ... you're going to get the message duplicated in logs.
spacing
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Should include 'e' when throwing exception? Like "throw new IdentityOAuth2Exception("Error in bootstrapping the OpenSAML2 library",e);" Also better to use specific error msg other that e.getMessage() for logging
More specific error message, e.g. error loading runtime environment props + e.getMessage()?
Can't we use a one try catch block here? or throw exception and wrap the method inside a try catch block? WDYT?
Missing codes.
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
@Nadahar Right, text/vtt, i was too fast...my bad.
Should maybe other countries be added here?
this method should probably be final. Also it is missing the @Override annotation AFAICT
These arrays could be defined statically in this class, as to not create a new array every time this method is called.
URL Decode would be necessary for parameter name and value
Consider returning a constant
we should have a test that involves multiple tokens (an input with a space) to properly test the position increments
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
same here simply inline the attributes variable
if you do not need the variable to make assertions just inline it patientService.getDuplicatePatientsByAttributes(null);
Encapsulation
non -> not
Encapsulation
hello, is it possible to grab the latest version from the registry instead of using 1.0.0 ? the same for machine exec plug-in ?
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
Nit: The level of try nesting and call to get representation (lines 1690 - 1698) could be simplified to: suggestion UserRepresentation userRepresentation = UserBuilder .edit(createUserRepresentation(userName, "joe@average.com", "average", "joe", true)) .addPassword("password") .build(); try (Creator<UserResource> u = Creator.create(realm, userRepresentation); Creator<GroupResource> g = Creator.create(realm, GroupBuilder.create().name(groupName).attributes(attributes).build())) { String groupId = g.id());
The binding shouldn't refer to the currently selected entry because this might change in the future and then the binding needs to be reevaluated. The following should work suggestion ObjectBinding<BibEntry> entry = Bindings.valueAt(selectedEntries, 0); return Bindings.createBooleanBinding(() -> { if (entry.get() == null) return false; else return entry.get().getFields().stream().anyMatch(fields::contains); }, entry, entry.getFieldsObserable());
I think entry.getFields().stream().anyMatch(fields::contains) is slightly better performance wise (as disjoint needs to check if *all* elements of fields are not contained in entry.getFields())
does queryNextPage need the query string again?
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
Not sure if this is a good place for the current limitation for window functions. The same limitation applies for non-aggregate functions so we'd have to limit that elsewhere anyway. I'd remove this limitation at the parser level.
There is something wrong with the button text. You set it to default here but it's not set to R.string.replace_bearing when we record bearing (only if we create the widget from scratch and there is an answer).
do you need to make it public?
Why did we switch out the old code back to this?
I think the logic should be more like:  if (context.isRoot()) { fetch root object } else { if (field is attribute) { fetch attribute } else { fetch relationship } }
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Can you avoid duplicate code here? (PreferenceManager.getDefaultSharedPreferences)
you can directly put .commit() at the end of this. Editor calls always return the Editor again ;)
java @Override protected void setUp() throws Exception { super.setUp();
It is best practice to use editor.apply() as commit() should not be called from the UI thread.
Instead of assigning the variable here, update the variable in the CrashReporter.initialize method itself.
Rather than make all these static, I'd be tempted to have a singleton object. Mainly because it's a little bit neater, but it would also make it easier to implement a "hide subscribed subreddits from /r/all" in the future, as the object could be user-specific.
I am not a fan of using null as a meaningful value that will change the behavior/flow of the product. For instance, variants could be just an empty JSONArray if there are really no variants. The SHARED_PREF_CHANGES_KEY could always be in the device, just with empty variants.
We can now use apply() instead of commit(), which will save the preference outside of the UI thread.
Looks like these two typeTextIntoEditor commands can be united into the single command:  editor.typeTextIntoEditor("\n\nobject = MyClass()\nprint(object.");
Why it was removed? It was an important check - ensure that there are no error markers just after the **AppController.java** has opened, wasn't it?
We are always in a case of an AbstractDiagramElementContainerEditPart host here?
This API is only reliable when the notifier is known a priori to be of the 'expectedClass' type. Usually we just check whether notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED The getFeatureID API is usually only employed for notifiers that aren't Objects, such as Resources and ResourceSets.
rename fileInfo to ledgerInfo
event.equals("clear")
Nitpick: the instanceof check is redundant here.
Nitpick: the instanceof check is redundant here.
Here handleEviction is not synchronized with getFileInfo which will cause race condition. Race Condition: 1. Thread A just successfully get a FileInfo from cache but haven't increment the refCount yet at line 221 "fi = readFileInfoCache.get(ledger, loader);" 2. Thread B is trying to get another FileInfo for read and cache is full, so it triggers eviction to evict the fileInfo which is referenced by Thread A. 3. Thread B continues to evict FileInfo and find out the refCount=0, so it close the FileInfo. 4. Thread A now returns the FileInfo which is already closed by Thread B. 5. java.nio.channels.ClosedChannelException will be thrown and cause serious issues
Yep, consequence of the new stereotype notifications design. :-) Even better would be, e.g., if (notification.getFeature() == UMLPackage.Literals.LITERAL_INTEGER__VALUE)
To be honest, I would keep the default here. Makes it more consistent with the rest of the system.
Would it be worth changing this log to log the transaction id we couldn't find, so we can look into why this might be? It seems odd that we would get notifications for charges that don't exist, it might be interesting to see what gateway account they're from, maybe someone has set up their notifications incorrectly...
EchoParametersDao.getEchoParameters() already returns a list.
this variable may make more sense just as itag given it isn't only for items.
I am not familiar with the script cache stuff, but this will delazify the cache contents and hold it all into memory. Is this okay?
Idem about null list
.forEach(intervals::add) avoids materializing extra list
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
use Map interface instead
What do you think about Comparator.naturalOrder() instead of null ?
nit: we don't generally declare unchecked exceptions suggestion public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {
wrap with unmodifiableSet in constructor and then just return field reference from get* methods.
We can use guava Closer to make sure we close all of these clients (just in case if one of them throws a runtime exception in the middle of the loop)
rename to breakpointRequest
can't foreach be used here?
Empty line.
Please let's use getUploadQueue() here instead - as mQueue could be null and we're using it like this elsewhere in the Service code
Can be info log.
Hmm, is this missing the .incrementVersion() call?
Seems like a good candidate for Guava's find to reduce the loops and increase readability.
<LINK_0> Let me know if you have any issues managing or adding items to the project
Log string concatenation
This might throw exception
make this private and move it after public constructor
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
Please add the cause here.
if (max < min) ??
nit: should be && rather than &?
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
Why so? There could be empty partitions.
This seems controversial to me. If I had a for loop:  for (int x = 0; x < 5; x += 0) { }  I would expect an infinite loop (except for the case of the upper bound being the same as the initial value which we handle separately anyway) rather than the compiler optimizing it away to a no-op. So the previous early detection and exception makes more sense to me. Groovy does often give shortcuts to handle cases that might be errors in a more elegant way but this seems to be a bigger magical step than normal.
Hi, I stumbled about your change by accident. This statement can lead to wrong behaviour if max is very big. Assume you have max = Integer.MAX_VALUE and min will be set to the middle position: min = guessI +1. In the next iteration guessI will have an overflow (max = Integer.MAX_VALUE + min = Integer.MAX_VALUE / 2) You should use guessI = min + ((max - min) / 2)
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
I know this is not introduced in this PR, but could we consider not allocating the buffer multiple times (here we would allocate three times, each in different levels of the object's serialize() function).
if you want to be Really Fancy, you could rewrite this as:  java final Optional<TimeZoneHistory> timeZone = this.timeZoneHistoryDAODynamoDB.getCurrentTimeZone(accountId); final Optional<DateTime> nowForUser = timeZone.transform(new Function<? super TimeZoneHistory, DateTime>() { @Override public DateTime apply(TimeZoneHistory history) { return DateTime.now(DateTimeZone.UTC) .plusMillis(history.offsetMillis) .withTimeAtStartOfDay(); } }); return nowForUser.or(new Supplier<? extends DateTime>() { @Override public DateTime get() { return DateTime.now(DateTimeZone.UTC).withTimeAtStartOfDay(); } });
both filtering methods should also be abstracted I believe. edit: by both I mean this one and the one above. the only difference being && or ||.
Is it better to get the value out to some variables so debugging could be easier?
Pass a new Properties() file here.
it's better to explicitly declare which DateTimeZone this is in.
Use try with resources.
Nested try here too.
is it intentional that dayOfWeek == 6,7 here, but dayOfWeek ==5,6 for caffeine alarm?
Does it still make sense to use forkJoinPool? The tiles are no longer downloaded at this point, so it would add an overhead to run this in parallel.
Could you check for null or empty? Via StringUtils.isBlank
Why do we need this constructor? It doesn't use the 2nd parameter...
can these parameters be grouped into smaller and more meaningful objects?
Symmetry (throw)?
![MAJOR](<LINK_0> 'Severity: MAJOR') Constructor has 12 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
The responsibility of this method is only cleaning up a task and cancel requests are not related to this method, I think. This method can be used by non-cancel operation in the future. So maybe this message shouldn't mention cancel requests.
validate channel name
Why a new random per MergeOp? Why not make a single static final Random and reuse that RNG for all of the backoff?
What you should be sending is the cluster compatibility version, not a constant version.. You could send the host's version but that would be confusing to the users. The norm in oVirt is to restrict version specific features by either cluster or DC - since this is clearly related to cluster (and not related to storage), the restriction should be by cluster level.
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
when can it be null?
can be simplified to: ValidationResult.failWith(VdcBllMessages.PLUGGED_UNLINKED_VM_INTERFACE_WITH_EXTERNAL_NETWORK_IS_NOT_SUPPORTED) .when(RequiredAction.PLUG == getRequiredAction() && !nic.isLinked() && isVnicAttachedToExternalNetwork());
would you mind reverting the condition into a positive form ? return FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion()) ? ValidationResult.VALID: new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
The message is- NETWORK_ATTACHMENT_NOT_EXISTS=Cannot ${action} ${type}. Given Network Attachment (id '${NETWORK_ATTACHMENT_NOT_EXISTS_ENTITY}') does not exist. You should pass the id as replacement.
please replace those lines with call to the method you added..
is the VM null too perhaps? maybe just move the condition from line 63 up?
you can use here also Boolean.TRUE.equals()
you can replace lunDisk.isUsingScsiReservation() != null && lunDisk.isUsingScsiReservation() with Boolean.TRUE.equals(lunDisk.isUsingScsiReservation())
Lists obtained from a message are immutable. No need for extra copying.
Maybe unmodifiable
does this have to be a list or can it be an iterable?
Style issue: @Override shuld be on line above the method declaration
We don't need another ImmutableList.copyOf. You are doing this when parsing.
why don't you provide a builder for DefaultDomainBundle ? Wouldn't it be nice to:  new DefaultDomainBundleBuilder("AccountDomain", new AccountDomain()) // as ctr args if mandatory ? .withQueryHandlers(new SomeQueryHandler(), new SomeCollectionQueryHandler())) .create() ?
Why is it a list of lists, not just a list?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
could it be final?
When will retainAssignment return null? If there is no difference between a null and an empty Map, let's just return an empty Map to avoid the null check here?
I don't see where we handle HibernernateException.
it would be nice if we could instead use a class called Wait, that would keep trying until a certain condition was reached in the server. This type of sleep will certainly eventually fail. i'm looking for a case where the test always pass.. with this we will still have eventually a failure.
I think we should add this datum to the frame and confirm that the session also successfully moves on (just to ensure the end-to-end is also still working)
Oh yes, can change this back to formatDateTimeForSessions and delete this method from TimeHelper? It's a workaround for this issue.
why are we changing the visibility of these methods?
I would say that it should return ColumnType.STRING since it's always going to be a String.
I don't think it adds real value to put these constants into the xxxColumnType variables, especially since they're only used once. It doesn't make the code more understandable or more elegant.
I guess here we are trying to test the grace period? java public boolean isClosedWithinPastHour() { Instant now = Instant.now(); Instant given = endTime.plus(gracePeriod); return given.isBefore(now) && Duration.between(given, now).compareTo(Duration.ofHours(1)) < 0; }
This pattern has been used for a long time in old tests, but it's better to use an explicit "/testFolder1" rather than folderDoc1.getPathAsString(). It's just more readable.
Why the revert of explicit paths?
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
From the code it appears that 'nulls' may be in the Iterable<TokenCacheItem> returned. Because we create the collection as ArrayList<TokenCacheItem> tokens = new ArrayList<TokenCacheItem>(results.values().size()); If decrypt fails, we will not add the tokenCacheItem.
we never use NULL, it is a bad practice in general.
List
nit: line to long (break each parameter in it's own line)
If you make the EMPTY_EXPIRES, you could use it here.
I think Local.ROOT is probably a better choice.
Missing the separator
Exception#printStackTrace goes to stderr by default.
Suggest retaining [] brakets
suggestion return new SearchHitsImpl<String>(hits.size(), TotalHitsRelation.EQUAL_TO, 0, "1234", hits, null);
nit, Collections.EMPTY_MAP?
- s/userPassCollection/userPass - s/userPass/userAndPassword - s/lastIndex/atPos - s/firstIndex/colonPos  for (String userPass : userPasses) { int atPos = userPass.lastIndexOf('@'); checkArgument(atPos > 0, "Invalid Credential format. Requires user:password@collection"); String userAndPassword = userPass.substring(0, atPos); String collection = userPass.substring(atPos + 1); int colonPos = userAndPassword.indexOf(':'); checkArgument(colonPos > 0, "Invalid Credential format. Requires user:password@collection"); String user = userAndPassword.substring(0, colonPos); String password = userAndPassword.substring(colonPos + 1); builder.add(createCredential(user, collection, password.toCharArray())); }
Why this change?
0 is the default value for an int field. We do not make assignments to default values in constructors.
this could be static final since Patterns are immutable
Might be a good place for a string builder
Might just be a personal taste, but I'd also prefer a for loop here:  for (Filter f : filters) { ArrayList<String> parameterValues = f.getParameterValues(parameter); if (parameterValues.size() != 1 || (commonValue != null && !commonValue.equals(parameterValues.get(0)))) { hasCommonValue = false; break; } commonValue = parameterValues.get(0); }
You should call 'updateBondOptions()' also before registering to the listener, to align with the changes were done in the model initialization before you added the listener.
The 'list' is never used. Please remove it.
Could use assertEquals?
maybe also add?:  java mapper.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, false);
Does this need to be a perpetual change or is it bound by this method? If it is the latter, I'd reset the context classloader to its original value in a finally block in this method.
final
I believe that we want this test to return a UnsupportedEntityIdValue too
Can we make ObjectMapper instance static final and reuse it instead of new instance for each execution?
Do we use IVdcQueryable somewhere in AAA?
As Ryan mentioned, you may not want to implement locks like this on static methods. I'm guessing he is checking mappers for null in order to instantiate them only once, as well as set their SimpleDateFormat. Someone else can chime in, but one easy and simple way, while keeping the methods static, is to implement the default constructor with no arguments, then call a new static void method from the constructor called something like setMappers(). Inside setMappers() is where you would instantiate the mapper1 and mapper2 ObjectMapper instances. Then you can get rid of the null checks on the mappers, and instead just return them from their respective static get() methods.
Remove this (ORDER_MAP_ENTRIES_BY_KEYS).
@aheritier I think a custom Jackson deserializer for CustomFieldValue makes more sense instead of changing the mapper used for all dtos.
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Sure thing. Though I still think there is an interesting case to be made for a "heavy-handed" view even in this case... my intuition is that it's odd that the view output's root and all strings originate in the middle of a SQL query. It smells like action-at-a-distance between layers. Oh well, a debate for another time if anyone is interested.
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
you may want to get into a good habit of using guava builders (Lists.newArrayList)
random? really? I would have used idFor(). public ObjectId insert(int objectType, byte[] data) { return idFor(type, data); } public ObjectId insert(int type, long len, InputStream in) { return idFor(type, len, in); } or something like that. I forget which of the insert methods is the "bottom" of the call stack before punting to the InputStream version that is required, but I would implement both in terms of idFor and return the actual SHA-1.
Please remove TODO and check that result is not broken.
I think we might want to separate out the concepts of hasIndex and isQueriable. In gatk we have a datasource that has no index but supports random access. I also think supportsRandomAccess might be clearer name. I'm not sure how granular we want to go though, you could potentially imagine a stream with an index that supports fast forward skipping but not rewinding, which wouldn't be easily described here either.
Doesn't seem to be universal to use specifically MapCache (CaffeineCache is also an in-memory, local cache) of the specific size. Maybe replace Appendirators with something like AppendiratorBuilder, which allows to configure those batteries of arguments one-by-one using named configuration methods? It may distinguish between "realtime" and "offline" on different stages, e. g. in the beginning of the chain:  java AppenderatorBuilder.offline() // or .realtime(segmentAnnouncer) .setIndexMerger(...) .setCache(...) .build();  or in the end:  java AppenderatorBuilder.create() .setIndexMerger(..) .setCache(..) .buildRealtime() // or .buildOffline()  Or in some other way
You'll need to save the object first to flush these changes to the database.
A variable with the same name as it's type - is this more Java 8 craziness I haven't seen before? :)
Shouldn't this be set to false?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
No, this. when you call methods.
Can this be private, or is there another use case for default attribute outside the builder's call?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
You probably want to disable some view components in the event of a failure!?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
Well, with the squash GH doesn't see changes and don't notify via email. I have missed this change therefore :cry:
finally?
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
The agg function here should be adjusted to support the optional compression param like in the quantile version
This looks like it would have different behavior from what was there before. If this is based on the path, I'd expect needing to go through getFormFilePath (the method that builds database paths based on whether or not scoped storage is used).
Doesn't work as expected as this message is never displayed, whatever is the type of media.
can you explain why this change ?
Why don't we set the certificationstatuses filter of the searchRequest here? Then the DB could filter the results rather than having to put the logic in java below
We are trying to remove the Globals class (in the long term). To facilitate this, could you please extract the themeLoader and preferences, and initialize them by passing the global objects as dependencies through the constructor (i.e. move Globals from this class to the caller)
should we have an "unsupported" status instead of successful? successful seems misleading to me.
secretLabels = Arrays.stream(labels) .map(l -> l.split("=", 2)) .collect(Collectors.toMap(p -> p[0], p -> p.length == 1 ? "" : p[1]));  ?
We shall trim at the final values level but not the above layers. What do you think?
Consider returning a constant
@Nadahar Right, text/vtt, i was too fast...my bad.
Should maybe other countries be added here?
this method should probably be final. Also it is missing the @Override annotation AFAICT
Usually we use i, j or k to iterate through array instead.
Missing codes.
we should have a test that involves multiple tokens (an input with a space) to properly test the position increments
This array is the same for all cases, you can use a static final constant to avoid creating the same array multiple times.
Fair enough. I don't think it was meant as a cost saving thing, just to make it easier to understand when something did or did not have caught-up clients. If you find this logic easier to follow, go for it
suggestion private MockClientState getMockClientWithPreviousCaughtUpTasks(final Set<TaskId> statefulActiveTasks) {
Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?
I'd just like to say what an awesome tool for optimization this class is. Kudos to you and @cadonna .
This doesn't really make sense, onPartitionsRevoked is always called before onAssignment
Missing final before CanceledJob
I like immutability. Should we call this allExpetcedChangelogPartitions and introduce allExistingChangelogPartitions = allExpetcedChangelogPartitions - newlyCreatedChangelogs
I think the offset and limit are miss-leading here with the method name searchPayments. The client uses them to restrict the result payments size, but the plugin will use them on the transaction level. So it would be the case that, the client sends a limit of 100, but only get 1 payment in the page with 100 transactions embedded. Or a payment may cross 2 consequent pages. Are we considering to have the plugins returning a more proper list instead of PaymentTransactionInfoPlugins?  class PluginPayment { private UUID kbPaymentId; private Collection<PaymentTransactionInfoPlugin> transactions }  Just a thought, I'm happy it's not changed in this PR.
The responsibility of this method is only cleaning up a task and cancel requests are not related to this method, I think. This method can be used by non-cancel operation in the future. So maybe this message shouldn't mention cancel requests.
prop: It seems like we do not need statefulTasksToRankedCandidates anymore. We could directly build tasksToCaughtUpClients from statefulTasks, clients, and configs.acceptableRecoveryLag. Also in assignStandbyReplicaTasks(), we only use the keySet() of statefulTasksToRankedCandidates. So, we can remove statefulTasksToRankedCandidates.
should be VOT.Storage
this should be the disk id, not the image id
would you mind inverting the condition to simplify it and skip the negation ? if (isImageProvided()) { ... } else { ... }
CommandBase.checkPermissions will always return true for this, meaning will authorize the user to perform this action. It would be better assign null value to dataCenterId.
need to change to copy/move on disk
I think that if the network exist you should be able to edit the (attach) parameters if you have permission on the network or if you have permission on the cluster
this will always fail, what you ask here is that the user will have permissions on the quota he did not create yet. add quota should ask for permission on parent, which is storage pool
i think handling null SP should not be part of this method
Can we use getActionType().getActionGroup() instead of CONFIGURE_VM_NETWORK?
Please use TimeUnit.MINUTES.toMillis(15)
No need for the *31 here.
bad hashcode.
static
Use Guava hashCode function
typically, you don't use getters when inside the same class
Could probably be shortened to double orbitalPeriod = 48D*Math.pow((Math.pow(orbitalDistance, 3)*Math.pow(Math.PI, 2)*10D)/solarSize, 0.5D);
@decarbonization: i think this should be Math.round(0.25f * temperatureScore + 0.25f * humidityScore + 0.50f * soundScore) coz right now Math.round(0.25f * 90) + Math.round(0.25f * 90) + Math.round(0.50f * 90) returns 91
Any particular reason to use 100_000 ?
You need to calculate the righ margin to account for the width
Remove
nit: Maybe more explicit:  Only function definition classes (classes annotated with @ScalarFunction) can define SQL functions via non-static java function. Function set classes can only define SQL functions via static java functions. Thus constructor in function set classes is used to define SQL functions.
this can be done with a stream, filter & collect so it'd look something like this return film.getPeople().stream() .filter(crewMember -> crewMember.publisher() != Publisher.RADIO_TIMES) .collect(MoreCollectors.toImmutableList);
This should probably be private.
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
I fail to see any reason why an ImmutableList would be needed here. You know it's just an ArrayList internally right?
If you change this to be a VariableReferenceExpression builder it will save me a few lines of code when I get to this part for symbol to variable refactoring, lol.
Why not just have the property be a JSON array of strings?
I would like this instead for simplicity  switch (arity) { case 1: return ImmutableList.of(valueType); case 2: // weight return ImmutableList.of(valueType, BIGINT); case 3: // weight and accuracy return ImmutableList.of(valueType, BIGINT, DOUBLE); default: throw ... }
This method has an external annotation now.
Missing final
You can use CollectionUtils.toImmutableList
this.
This variable name is misleading. These bounds are _not_ verified at the time this call is made - they are the candidates you want to verify. In the previous model it was correct (because that's where you start the query from).
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
This is quite a heavy class and it feels like the last two parts on translating PaxosHistoryOnRemote to CompletePaxosHistoryForNamespaceAndUseCase seems a bit of a separate concern from getting the data which the first three parts here do. We should split this up, though I'm fine with getting this in first as long as we track doing this when we return to this project later on.
you don't need to collect inside getMachineNames if you stream it again on next line. Just return Stream or maybe getMachineNames is not necessary here and just inline it. If you want to split the long stream chain I would maybe do something like  Stream<String> machinesInPod = containers.stream().map(c -> Names.machineName(podMeta, c)); return machinesInPod .map(....
I am not convinced that using the stream API here is the right choice. What we are doing is to do computations with side effects. For that I would always prefer a traditional for-each loop.
And if this sub-stream were extracted into its own well-named static method, the code would now be perfectly readable and self-explanatory.
nit: rename tasksPerInstance to dependencyTasksPerInstance (since this is doing the actual filtering logic, and the final list consists of dependency tasks left behind in the assignment)
nit: we don't generally declare unchecked exceptions suggestion public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {
Couple more static imports here?
Another static import?
Statics
Static imports again?
...and again... ;-)
...and again? ;-)
This must be implemented.
Replace arg0 with something more meaningful? And why are we planning to blow up here when, in similar functions below, it seems that we would silently ignore the null?
does this need to be calculated on the fly each time or can we save the iterable?
if (idsByConfiguredRegions.isEmpty()) { return ImmutableSet.of(); } instances = pollRunningInstancesByRegionsAndIds(idsByConfiguredRegions); ...  ? I agree that this is basically just a style preference, but to me it makes the "special case" of isEmpty() clearer.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Immutable fileinfo
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
You could probably use the same URL as in getResultById here.
I think the annotations should be on separate lines
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Can this be private, or is there another use case for default attribute outside the builder's call?
add this selector to UI mapping at the beginning
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
Should be ClassNotFoundException. Catching all exceptions and disposing them may miss unexpected exceptions.
This is the wrong method to update, replace the one that was called here. For a global check if the patch was successful check for references like registerDeploymentPlan, instantiate, they should we restricted to the EntityManagementUtils class only (outside of camp projects).
How about narrowing it to ClassNotFoundException and fail with other exceptions?
Can this case happen? We initialize app in onCreate(). If so, can we initialize app in onAttach instead?
combine these two lines -> OwApplicability app = artifact.getAppId();
same what if find returns null
Where do we actually wait for the callback to be called? We just check unfinished below, but it's unlikely this proc will be done. The old version uses a latch. Why use the async api at all? Why not just use the sync API?
Is there reason behind how you access this wrt to property or accessor function? Perhaps we should change all these uses to getters/setters?
Might need add below after line 211 here, since if this process is gone, the other app's procstate/adj could get impacted due to this if (oomAdjAll) { updateOomAdjLocked(oomAdjReason); }
here it could be if(Android.SDK_BUILD >= 19) { static function to create that class (and specify full classpath to the class without imports) }
Can StringUtils.fromUtf8 be used?
@nielsbasjes Is making this method public really necessary? Do we need to expose this method in the public APIs? Can't it be package private?
final float sleepDuration = (int) ((double)  feels odd.
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
skipId
These inner edits should be BaseEdits not LineEdits.
why? is this related to this PR? or an unrelated bug?
NIT: Maybe refactor this a little cleaner to: java final List<String> dataStreams; if (in.getVersion().onOrAfter(DATA_STREAMS_IN_SNAPSHOT)){ dataStreams = Arrays.asList(in.readStringArray()); } else { dataStreams = Collections.emptyList(); }
This will fail when node is Optional.absent()
nit: make this final
Methods in Preconditions should be imported statically
This can be removed.
Do you think we can use an [unmodifiable map](<LINK_0> here?
just return "" instead of new String()
Just a small note: the add(...) method on Set<T> returns false if the element already exists in the set so the contains check here is actually superfluous. The code could be changed to:  if (!items.add(name)) { LOGGER.warn("Overriding the existing {} registered with the name: {}", type, name); }
To make this a little simpler (and less bug-prone), it might be wise to rewrite this method along these lines (it means you aren't duplicating the same code which is a good way for bugs to creep in at a later date): java return withContext(context -> getKey(name, version == null ? "" : version, context));
Can't we avoid this and use a static function below?
Do you need to use the "text" constant?
currentType doesn't seem to be used, so it can be removed from here.
Why doesn't this method use getNotebookService()?
StringPool.EMPTY instead
I think there is some findbugs issue with not using {} not sure.
Generic type not used, remove.
1. what if value is not bool? exception? you should be able to recover from it nicely 2. you doing unneeded boxing, by returning class where primitive expected, use Boolean.parseBoolean() instead 3. please cache the value of the header, there might be few queries during the hit calling isFiltered(), - you don't need to preform header retrieval and casting every time.
I think it is better to throw exception
Nit: I would dispense with the elses since you return in the ifs.
you could do: if (length > 0) { matchingFrames = Lists.newArrayListWithExpectedSize(length) ... } else { return Collections.emptyList() }
getInitialValue() and numberValue() both need null checks.
is this missing a toLowerCase() ?
We usually don final local variables.
Why are you looping here? Can you give a use-case?
Should we return true at some point? It looks like the old code could.
I think a foreach loop here would be shorter and easier to read - or a lambda expression in future
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
Shouldn't we throw a NoSuchElementException instead?
Implementation of this method looks exceedingly complex. I'm not sure how to simplify it since it is not clear to me what this method is trying to achieve.
Simple for-each?
I would suggest making this method synchronized
taking out the verify statement will eliminate the captor.capture, causing a null return - noticed from the build failure
assert Hola
Do we really want to always assume Latin-1?
Could just use Arrays.fill(max_byte_arr, (byte) 0xff); here
please remove TODO and printStackTrace() and use proper logging instead
use Bytes.memcmp()
Could you explain the contract here in a docstring? If two arrays are different lengths why are they equal if they have the same content up to the length of the smaller array?
Do you want to make the check that portFields is of size 2?
suggestion throw new RuntimeException(String.format("Failed to parse geometry from bytes: %s", BytesUtils.toHexString(argumentValues[i])));
My mistake in my recommendation, it should be fileName.length, actual[i].offset. then same switch with the next assert.
Consistently use:  for (int i = offset; i < offset + length; ++i)  or  for (int i = 0; i < length; i++) {  in all copyPositions
nit java for (BlockLease blockLease : blockLeases) { if (blockLease != null) { blockLease.close(); } }
Why don't we make inDegrees to ConcurrentHashMap also?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Why is no this. used in lines 320-321 but this. used in lines 322-326?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
KETTLE_LOGGING_REGISTRY_PURGE_TIMEOUT should probably be a constant in Const.java for consistency with most other kettle params. I know KETTLE_MAX_LOGGING_REGISTRY_SIZE was already there before, but should probably also be defined in Const.java.
Then should we just use it to save the update items?
Prefixing with this is unnecessary for most member variables in this constructor.
Tangentially, we should likewise install the backup service as ACTIVE, so that it toggles to NEVER instead of ON_DEMAND as well.
perhaps pass along the entire BaseIndexOptions to be more future-proof?
Calling this in finally means that the flow status may not have been updated properly... is it wise to do it in finally *and* still rely on flow status to mark the right metric?
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
A for each loop on the listeners can be used here instead.
should this count be parameterized?
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
shouldn't we use Builder here. coz, no one outside the package will have access to constructor.
unnestChannelInputBlock -> newInputBlock
Again, constants would be nice for readability.
I realized that this is incorrect counting. Next thread can finish first before the first thread finishes. You need completedTaskCount as well as runningTaskCount
You can have this separate extend till the end of all columns. (We have the longestWordSize and number of columns)
setSelection takes an ISelection, no need to cast what you get from the viewer. you also do not need a local variable
you can use IStructuredViewer::getStructuredSelection
remove assertion and change ISelection to IStructuredSelection
change to IStructuredSelection
Why do we need a snapshot of the world? Isn't it possible to just use getCurrentState() to get the selection?
The last 4 lines of this method should be extracted as new method, because they are a duplication (see 10 lines above).
Even if it's very unlikely in this context, you could test whether the getViewer() return null or not (the return contract is "the EditPartViewer or null") before calling deselectAll()
Set the message in the plugin.properties and the key in org.eclipse.eef.ide.ui.internal.Messages
Are we sure that selection is not null? Otherwise, a null check before we call getFirstElement() is in order.
Why do we need a snapshot of the world? Isn't it possible to just use getCurrentState() to get the selection?
I am still in favor of removing this static. I don't think its necessary. I think if tserver wants to keep one instance, then it should keep a reference to it. All the current static stuff we have is troublesome and we would like to move away from it. Could rename this method to newInstance if you drop the static.
The cause should really have an abstract method for this instead. And return EnumCause rather than Enum<EnumCause> from its method.
Return this enum from the Target instance.
These seem to be covered by NUMBER_TYPES already?
Why you will need substring() when Class.getSimpleName() would only return the class' own name without package? Please remove.
If you remove the condition, the retry analyzer instance will never be null. Better: DisabledRetryAnalyzer should be the default value if clazz == null unless you think the null value is important.
Ok, I see why you want to pass in null. But instead would be better to have a super constructor that takes just class, so if someone calls the other constructor with a null entity instance we can fail fast.
style nit: add a space after if
Can we combine the two? I don't see the point to have a different annotation for multiple functions and single function. We use @ScalarFunction to annotate both class and method. It's also quite confusing to user since it's very hard to notice the difference of the two (so very easily to use the wrong one).
I think that the following check works, but could you test it please? suggestion if (Enum.class.isAssignableFrom(clazz)) {
This should be part of the try-with-resources block.
This is ok but can be made more compact: java try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()))) {
we can use try-with-resources statement and avoid the finally clause
use FileUtils.createNewFile() instead in order to check return value
Please move the write down, so that it is performed only if the file has been created and the permissions changed.
Please create a utility method getWorkflowConfigurationParser that contains these 3 lines ^, and also use it in makeDefaultScheduler.
It'd be better to throw the exception here. If there's a problem with the download, a stack trace will be printed but junit won't know anything about it. The failure would come later when the file is not found. With the exception thrown, the junit report will be a lot clearer and a naive user that knows nothing about this test will understand better what went wrong.
Pass a second argument as false to FileOutputStream constructor, it'll overwrite instead of appending. No need to delete the file first.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "read". [![rule](<LINK_0>](<LINK_2>
This function is being updated by #3161, so I'd remove this change as it will cause a merge conflict.
Item dropped should be a hopper
my guess is that this should be: return receivedStatus[0] == statusCode[0] && receivedStatus[1] == statusCode[1];
this for is exactly the same in all the array tests, let's move it to a private method
This seems redundant to me as we are logging in as the current user in the base class.
final
The default should be updated to return 8 parameters to the test
Use the enum Dark...
Here and below...switch the order of ValidateXmlInterceptor TransformXMLInterceptor. When the ValidateXMlInterceptor is enabled (should only be in dev) it will pick up any malformed XML and wrap it as an error and then pass it through the TransformXMLInterceptor.
Can you make the two above 'final' to make it clearer why you use an array? Maybe it is just that I'm not very exposed to lamdas yet.
can we make this the conditional for the while loop?
is this still needed?
This will throw redundancy warnings in IntelliJ
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Style issue: @Override shuld be on line above the method declaration
Why is it a list of lists, not just a list?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
null? why not just a () -> {} ?
either if (!storageDevicesListCalls.isEmpty()) or storageDevices != null below
invokeAll on an empty list returns null. So you may want to handle that
I know it's trivial, but would be much nicer if this mapping was extracted to a separate function.
The this. in getters are unnecessary too.
public @Nullable String...
Why do we return the parents name instead of the name we store a few lines above?
You should use toLowerCase(Locale.ROOT) as using using "toLowerCase" by itself will use the default locale (which may lowercase incorrectly depending on the language)
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
bleep
suggestion super(() -> name);
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
String name = StringUtils.EMPTY;
This may produce incorrect results if the name of the service contains the "Resource" word, and we do have one of those: ExternalComputeResource. As what you want to do is to remove the "Resource" word only if is at the end you can use the following: String name = node.getName().replaceAll("Resource$", "");
assertTrue or assertFalse but never equals. Also add a message so if it fails you know what has failed.
When using suggestion Assert.assertThat(testRealmResource().users().search("a", true), Matchers.hasSize(0)); Assert.assertThat(testRealmResource().users().search("apollo", true), Matchers.hasSize(1)); Assert.assertThat(testRealmResource().users().search("tbrady", true), Matchers.hasSize(1));  the output on failure shows the search results which is better for debugging potential failures.
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Shouldn't this also test an Array that is empty, i.e []? Instead of a String that is empty, ""? Also, I am wondering about multi-dimensional arrays which is kinda the point of deepToString... If the array contains other arrays as elements, the string representation contains their contents and so on. <LINK_0>
You can use assertTrue and assertFalse instead of assertEquals, that will give better error messages when the tests fails :)
I've noticed that some values are not checked, for example patient.display here, is there any reason for that ? I think it would be better to verify all used values
cannot be empty
@tmarzeion This code crashes the app. You got NPE in getPatientID method due to asyncs problems probably.
use -1L constant
what is the difference between verification in both cases (client and server). If most of them are same, can you consider having a utility method for verification purpose
Missing types
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
We were going to avoid signatures like IgniteFunction<Stream<UpstreamEntry<K, V>>, Stream<UpstreamEntry<K, V>>>, right?
Actually do we need the return type to be Seq, than just a Map? It seems we do not need to rely on any keyset ordering at all in the remaining handling logic.
Can you please revert this file. It will cause bunch of conflicts with my changes.
The MockNearCacheService name is a bit confusing: if the near cache is a mock then why would we test its size/contents at all?
wrap with unmodifiableSet in constructor and then just return field reference from get* methods.
doesn't seem related to this PR :)
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
any special characters to block in webhook name?
you should probably check Item.Configure here
Catching a generic Exception is poor practice.
According to <LINK_0>, while _most_ of the --security-opt arguments are of the form "name=value", there's at least one that isn't: > --security-opt="no-new-privileges:true|false" : Disable/enable container processes from gaining new privileges ...and this is then further confused by the example: > docker run --security-opt no-new-privileges -it centos bash which doesn't have a :true or :false at the end. As-is, this code would complain to the user if they specified that option in either form.
Not .warning?
We don't want to get into tunneling for this.
use split(":", 2) for correct ipv6 handling
This line is ultimately my concern. I believe some users will want to enter with newline characters rather than whitespace. We'll need to catch those in the form validation. So I'd want a test for that. Does that make sense?
Can you replace that with a localizable message?
Single or double pipe?
I think a compare between capacity and maxPageBytes is still reasonable here - even through the capacity > maxPageBytes is always true here. Because we cannot ensure the private HeaderChannelBuffer constructor is always called in create. Maybe it will be called somewhere else someday? A compare here may seem redundant now but will decouple the private constructor and the create
Might be nice to list valid dio pins out in the message?
This code should be:  this.channel.close();
Did it help in any scenario or is it a defensive programming?
it can be replaced with Objects.hashCode(channel) (since java 1.7)
Add a new line after the @Override please :)
if this method knew what phase it was in you could eliminate half the comparisons, right?
channel.ensureIneventLop()
This transferToInterpreter() shouldn't be done here, because it interferes with the VM.callerNeedsToBeOptimized a few lines below. Perhaps initializing serializationRoot should come afterwards. Either way, we expect this code to be executed only on the slow path.
Can we make logger a private static final
You don't need to save an ObjectReader; you can call readValue directly on the ObjectMapper.
nit: Suggest renaming iterations and its getter as well here
this and m_ is redundant
How about adding this log message to CheckpointManager?
not sure if this is needed but we should check if lot is null in case that it is nullable in ims_transaction...
You can remove this call and also remove the public default constructor: it's not used.
use of raw class, should be new ConcurrentHashMap<Long, Boolean>()
maybe it's better to tag them with the status so that we can break them up that way?
Mind replacing this with Boolean.parseBoolean(metadata.get(Constants.HeaderConstants.DIRECTORY_METADATA_KEY)), it does the same thing.
what does compare and hascode mean for datanode if they have different ssl ports?
how could contributions be null? Create it at the field level if you want. It should also be final. There are minor style violations in this file, no spaces around operators
This can never be null given the code in setData above?
This branch is not needed
do {   } while (current == null) is more natural here.
This.
Similar question: is this really better?
Please use TimeUnit.MINUTES.toMillis(15)
@ropalka @fl4via Should this be the default impl in the interface? AFAICT it's entirely using calls to interface methods, so it could be a default impl. Doing it that way avoids making an incompatible change in a public interface.
Can you put this into a private method to give this if construct a title.
why this change?
I think the current state of the art is to do something like: int hc = key.hashCode(); hc *= 31; hc += value.hashCode(); return hc; But actually for an attribute there aren't too many that can can be multi-valued, are there? So just using the key's hashCode as our own hashCode might be sufficient here.
this client side GWT compiled classes needs a sort of sanitized hashCode implementaiton using our utility class HashUtils. Should look something like this @Override public int hashCode() { return HashUtil.combineHashCodes(super.hashCode(), executionSet.hashCode()); }
add requireNonNull for bytes
HashUtil.combineHashCodes
generate hashcode again, it doesnt account for caseSensitive.
value is never null
The bytes can only be cached if the backing buffer isn't reused. If it is reused, then the backing buffer might change and cachedBytes could be stale.
what classes are we accounting for with isAssignableFrom?
once ByteBuffer becomes the canonical representation of a Binary we should implement an equals directly on ByteBuffer without copying to byte array
Currently we don't have PERUNOBSERVER role assignable by config to specific credentials (unlike perun admin). This mean, we will always have User, related to this role. So anywhere, check on SELF (without specifying user or where passed user is only own) will let PERUNOBSERVER pass too. Only if it would filter result, we would have to separate them. What do you think @stavamichal @licehammer @martin-kuba ? Will we need PERUNOBSERVER role for accounts without User in Perun or not ? I suppose not, it is always safer to have account with contact info etc.
Since this method process any type of attributes, exception text is misleading. You can get eg. facility attributes with non-null value from all facilities specified by attribute definition.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
Please add also VOOBSERVER.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
This String should correspond to the name of the called method. suggestion throw new PrivilegeException(sess, "getResourcesWhereUserIsAdmin");
The second parameter should be "removeResourceSelfServiceGroup".
The second parameter should be "removeResourceSelfServiceUser".
The second parameter should be "addResourceSelfServiceGroup".
The same like in the method before. Filtering after removing groups. The last step will be returning of array.
type might not always be a Class. If the API method returns List<User> this will be a ParamterizedType which isn't not a Class.
space after ,
It's not a good design pattern to close resource-parameters in methods. There are the following converntions (which may violated in certain cases) - If you pass in a resource, the caller is responsible to close it - If you wrap a stream (e.g. new BufferedInputStream(is)), closing the outer stream will close also the inner. You should fix that resource leak at the caller side, there is only one in io.ebean.config.properties.Loader: java void loadYaml(String resourcePath, Source source) { if (yamlLoader != null) { try (InputStream is = resource(resourcePath, source)) { yamlLoader.load(is); } catch (Exception e) { log.warn("Failed to read yml from:" + resourcePath, e); } } }
you have lost the cause e
close already done in Util.read(..)
This can in theory throw a NumberFormatException. This is caught in similar case in ListBoxByteSingletonDOMElementFactory, might be good to catch it here too.
Minor: same as in other number check, WDYT about checking for the decimal point?
same as above, is it necessary?
Why would you not start with "BigInteger value = BigInteger.valueOf(0);", and leave out the null check inside the for loop? If this is because null should be returned for an empty bitStringValue, that maybe should come first.
I wouldn't recommend changing the method accessibility only for testing purpose. In this case it means we can't unit test the method directly but it can still be tested on a higher level.
should be debug and consider moving logging to checkData()
Could be written on one line RemoteService.getRemoteService().doRemoteFunction(value)
we don't need to change the Creation classes.
please decrease log level to DEBUG
Would it be clearer using _routingTableChangeListenerMap.entrySet().forEach((k, v) -> k.onRoutingTableChange(...));
What's the advantage of creating the scheduler in the factory instead of in the service itself?
This looks like a help string that really is intended to go to stdout
why requestWorkerCount > 0 is an error state? Since this two members are important for the the handler to start, I suggest add them into the constructor instead of have separate "setRequestWorkersCount" and "setBlobStorageService" apis. It will also make the caller code concise.
change message to "Service marked as up" or similar. Add a similar message in shutdown().
you can probably start nettyMetrics before restServerState.markServiceUp();
please keep style changes separate from PRs (or better just don't create them at all)
Should reset the values in the config file too?
Alternatively you could have a static constant Set<String> and do a contains(). It would go nicely when we can use a Set.of.
I thin we should create a new method httpMethod() that will return the enum and then deprecate this one to be removed on feign 12!?
please extract key as constant
Should add the new rule to the config file? (Parse could put directly to ruleConfigs in that case,)
if a deployment config is selected, shouldn't a IReplicationController be returned in the 1st place? In other words, why would it return the selected element with a more precise type if rc == null?
Good thinking to report this case. Would be nice to have a test for it (e.g. in the _erroneous_ package).
This needs to do rc.setStringList(p.getParentNames()).
Move this into loadGitChecks()? Its the same section of the config, RECEIVE.
Please extract this string
It'd be safer to put EXTRA_SUBJECT only if !TextUtils.isEmpty(subject)
I would try to reduce the code duplication by something like that  final Class... activity; if (PreferencesHelper.getCreateAccountStatus() == CreateAccountStatus.WAITING_FOR_SMS) { activity = VerifyNumberActivity.class; } else { activity = AgreeActivity.class; } startActivity(new Intent(this, activity).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP));
Use strings.xml
Should be Localized in Android framework.
FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET is deprecated, and why is needed?
Do we want to put these content strings in strings.xml?
May be we should add the title? OH, and what about "Shared from Pumpkin Reader for Hacker News. Download Pumpkin Reader for free here"?
suggestion /* package */ Intent buildIntentForUri(Uri uri) {
Minor nit: this can be shortened to if (multiSelect && Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2)
static imports
static imports
In general we use == to compare classes (Cf. *AdapterFactory implementations for example)
You can use StringUtils from the commons.lang3?
This method can be static, as all the methods it calls.
Any reason not to use computeIfAbsent here?
This doesn't seem to work internally, FYI. :-)
please fix the whitespace. You just need to return the options here.
you could have merged the expression of this if with the previous one.
Maybe Boolean.valueOf to avoid ClassCastException.
does this have to be a list or can it be an iterable?
why public?
What about :  names = new ArrayList<>(attributes.keySet());
You can seed the size since it it known.
will this skip empty strings?
null? why not just a () -> {} ?
Replace Logger with LogManager
Style issue: @Override shuld be on line above the method declaration
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
Not sure if there is an "internal" profile any longer, or if its name has any relation to ConfigValues.AdminDomain. I'd suggest to abandon the idea of displaying "internal" last.
innerInterfaceOrClass checks parentType, but in line 236 similar check is performed. They can be merged in one method
When is it not identifier? And does this cover things like new OuterClass.InnerClass() or new package.Class().
Please split this if into two and revert else if. The condition will be easy to read. Or, the whole condition can be inverted: java final DetailAST parametersNode = ast.findFirstToken(TokenTypes.PARAMETERS); if (parametersNode != null) { TokenUtil.forEachChild(parametersNode, TokenTypes.PARAMETER_DEF, super::visitToken); } else if (ast.getParent().getType() != TokenTypes.SWITCH_RULE) { super.visitToken(ast); }
This can be  return nextSibling != null && nextSibling.getType() == TokenTypes.SLIST && nextSibling.getFirstChild().getType() != TokenTypes.SLIST;
vmIsDown() == true than vmIsUnlocked() == true vmIsDown() == false than vmIsUnlocked() will not be checked.
wrong place for lock
/s/verifyShareableDisksMoving/validateShareableNotMovedToGluserDomain() regardless i think that this check should reside in validateDestStorage() method
This validation should be in LiveMigrateVmDisksCommand since in this command we only move disks that their VMs are down (checkCanBeMoveInVm should verify this). LiveMigrateVmDisksCommand is the command that is responsible to move the disks inside a running VM
Why 500 why not 100, if the issue was previously it was taking too long surely we want this as small as safely possible?
would it be better to throw here?
createObjectFromMap(name, NAME_TO_FULL_MODULE_NAME); should be the first thing we try. It will be the fastest and the most common scenario. pure createObject(name) should probably be used last when user supplies full package as name. Order of finding module should be, imo: 1) our module map test 2) 3rd party map test 3) full package (or raw) test 4) fail. We can probably discuss skipping 1-2 if given name has a period in it. 3 is only really needed if we don't examine maps for the full package. I don't really see a benefit from doing this.
just return "" instead of new String()
This check is useless as the customParams can never be null.
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
style nit: since quite a while we use curly braces around single line blocks so missing braces should be added when touching old code not following this rule
Don't initialize to empty when null.
You need it to check if it extend itself or for something more?
No key for encryption? ;-)
Simpler as ImmutableMap.<String,String>of().
when I read this code .... I do not understand what is brute force mean here.... it is naming desing problem. searchModuleInAllPackages ... createModuleByTryInEachPackage(packages, name) ?
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
please inject the DAO
try to consolidate with the previous method
shouldn't there be any validation to the cron expression correctness ?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
the image is being copied to another domain, where does it's profile is set to a profile of the new domain?
I'd change it here only for consistency if we already pass it by the paremeters.
how about replacing those with: getVm().setUseHostCpuFlags(false);
note that the VM compatibility version may be different than the cluster compatibility version - this assumes they are the same, right?
This field can be moved to 'RunVmParams', and then it would not be needed to copy it here.
What do you think about changing to stripContextPath(request)? So stripContextPath ask for contextPath and requestURI internally.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
nit: s/upload/upload ID/ I was thinking of consistent log keywords so taht for any retry log we can search "upload ID" or "commit ID"
I think it's time to key on a proper object
suggestion
We could just always use the body instead of flipping based on the payload size.
Safer to call: getFirstHeaderOrNull("Signature") == null
this duplicates code with RequestUtils and RequestMetadataInterceptor , we could extract this out by creating some method that takes HttpServletRequest as a parameter, returns a Map, then add the info where it is required
the basic can be at application context, so we have one place to read, parse and store.
Move both to variables for consistency.
extension can't be empty or /
extension.toString()
Why don't instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
Could be protected instead (and it could be defined before the nested class).
I would change this to if(url == null) { return null; } less indentation, code looks a lot cleaner
Might be better to throw the Exception instead of swallowing it. I'd write something like: java public static String getFileExtension(File file) throws Exception { return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase(); }  This new method might deserve also some unit test in FsCrawlerUtilTest.
You could remove the braces around the first check.
Technically it's the connector (jr://file vs. jr://file-csv) that differentiates between the two. I think this is ok, though.
Missing { }
See above, we could probably switch this round to just add the two factories we care about and so make this simpler
I understand the purpose of the change is to make sure we streamline the value change in the class variables to happen as late in time as possible, and issue the notifyDatSetChanged() signal right after that. Can we then enclose these 3 below lines in a synchronized block to make sure these 3 are packed together in an atomic action?
Should this be as in OzaBag?  @Override protected Measurement[] getModelMeasurementsImpl() { return new Measurement[]{new Measurement("ensemble size", this.ensemble != null ? this.ensemble.length : 0)}; } @Override public Classifier[] getSubClassifiers() { return this.ensemble.clone(); }
needs US-ASCII charset, or some other simple ascii encoding conversion
delete the old file when a new one is generated? It's nice behavior to clean up our mess. Or use .deleteOnExit, if some tests might still be using the old file.
![MINOR](<LINK_0> Remove this unnecessary cast to "LaunchManager". [![rule](<LINK_1>](<LINK_2>
This looks like a bug fix that's not related to the feature of this review
this is opentracing specific.Thoughts?
Good idea here to avoid copying the same list we'll return, but you also want to do this in the case that the list size is less than or equal to the limit, so you might consider moving this down and integrating with the other list logic. (Also we should consider using a sublist rather than a new list and a bunch of adds.)
This should be indexOf("Mac OS X")
add a try/catch block for the String -> int conversion? Put an assert in the catch, so we are alerted when this fails?
use 'waitForElementByElement(newestVideoDeleteIcon); and use 'waitForElementByElement(deleteConfirmButton); before each click
this method suppose to return instance of DiffPagePageObject class, because its redirecting to diff page beginning of the method should be: public DiffPagePageObject goToDiffPageFromHistoryPage() and last step should return new object: return new DiffPagePageObject(driver);
log () here and after
wait.forElementClickable() should be used before
log()
log()
wait.forElementClickable() should be used before
wait.forElementClickable() should be used before
Now this method does not do as it's named...
is there a reason why this method isn't implemented?
Are there mandatory parameters which require validation?
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
Let's keep the usage of force aligned with the rest of the backend commands: action.isSetForce() ? action.isForce() : false
no need for the failover treatment, this is done by the infra, just return doAction()
This should be "isSetReboot". The reason is that we don't even want to call the backend method if the user didn't explicitly provide the value, as the backend method may have side effects (very unlikely in this case).
I think that this check makes more sense in the "getClusterId" method. Can we move it there?
And then else if this
I think it would be clearer inside the previous 'if' clause. I.e. if (action.isSetLease()) { ... if (action.getLease().isSetStorageDomain()) {
implement dedicated validateEnums(Action.class, action); it will validate AuthenticationType for you (see validateEnums(VM.class, vm); for details)
This won't invoke the additional interceptors, is that okay?
you could invert the if to avoid negate the condition.
Wouldn't Arrays.asList() be enough here? Arrays.stream seems to have a lot of memory overhead.
From the point of async store, it is not necessary to have the *function* serializable but the resulting entry. So the check does not belong here. The same holds for compute commands.
some invocations could be optimized. we can skip the read when ignore return values flags is used for example. Although, it may need to check if the key exists to trigger the correct notification.
I think you could have removed the RecipientGenerator completely and passed the key directly.
super is a BaseDistributionInterceptor, I think it would be clearer if its methods had NonTx in the name and only its subclasses would override the visitXxx methods. WDYT?
Why is only a remote unlock acceptable? I know right now we don't actually need local unlock commands because we only use them for remote tx cleanup, but would it complicate things to allow them anyway?
"we ask the coordinator to retry the transaction" - like I said, this is not always true: if a node just joined, it could receive the PrepareCommand asynchronously, after the originator finished the sync broadcast, so it couldn't tell the originator to retry. Edit: We actually have a check in place to ignore commands sent before the node joined, but that check doesn't work if the node "re-joined" via a merge.
wouldn't be andExceptionally more appropriate?
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
the instanceof check includes a null check
Compare with null not necessary since null instanceof FileModelSource is false
please add braces for the else block.
please add braces for the else block.
this is redundant with next instanceof check
@timler I think that we should use do a class comparison using getClass() here instead of doing an "instance of" check so that different subclasses can't be considered equal e.g. a Donor and a Donation with the same id.
Please use curly braces for conditionals
You can simplify the if-else block to Java if (path == null) { return other.path == null; } else { return path.equals(other.path); }
Can you add the curly brackets to the if calls.
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
Check if there is an appropriate constant for "no metakeys" mask.
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
volumeEntity.getStatus()
I think this should be replaceFailed = false instead.
Which tests fail if we don't have this line?
This could fail if in two cases: 1: if no values added to the builder, this fails in index array out of bound... 2: if someone changes the PROPERTIES_DELIMETER to a different one which has more than one char this would cut only the last part. I'd write it somehow like this: if(builder.toString().endsWith(PROPERTIES_DELIMITER)) { return builder.subSequence(0, builder.length() - PROPERTIES_DELIMETER.lengt()).toString(); } return buildet.toString();
what if multiple volumes are selected? You might need to add else block
duplicated
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
Why don't we make inDegrees to ConcurrentHashMap also?
Why is no this. used in lines 320-321 but this. used in lines 322-326?
0 is a legitimate option value for min. selectable choices. Why not -1?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
Can you just make this constructor to call the other one?
Tangentially, we should likewise install the backup service as ACTIVE, so that it toggles to NEVER instead of ON_DEMAND as well.
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
KETTLE_LOGGING_REGISTRY_PURGE_TIMEOUT should probably be a constant in Const.java for consistency with most other kettle params. I know KETTLE_MAX_LOGGING_REGISTRY_SIZE was already there before, but should probably also be defined in Const.java.
Then should we just use it to save the update items?
perhaps pass along the entire BaseIndexOptions to be more future-proof?
Hey @oguzkocer , should this array include VIEWERS_TABLE as well?
IMO, return (int) Math.min(size, Integer.MAX_VALUE); looks better (as you did above)
In other places we use java.util.Math.toIntExact(long).
same about exception and doc Also resources might never be closed
I am a bit confused that this check will be called on almost every line of code.
reuse getAcceptableTokens()
(not related to this issue) Should AutomaticBean issue a warning when a deprecated property is specified in the configuration?
This is super wrong. zzUnpackAction populates result.
Could we use IgniteUtils.EMPTY_INTS here?
I would recommend dropping size var and just calling timeStamps.size() ... this way do not have to keep this thing correct... for example should set this to zero when calling clear
I think it makes sense to use builder and return ImmutableSet...
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
probably don't want to keep filling this map up as we browse around. could just use getOrDefault?
Selenium already has a org.openqa.selenium.Cookie. There will be lower friction with other parts of the Selenium APIs if we return extant Selenium types. I think it's fine to extend those types to be more meaningful if necessary.
Shouldn't this be == ?
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
This is a good candidate for computeIfAbsent.
wrap with unmodifiableSet in constructor and then just return field reference from get* methods.
These loops could be combined, no need to iterate over the servers twice.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
pls use addStatus(new WarnStatus(message,this)); or addError(...) to report failures
Use Logger instead of System.out.println
Use Logger instead of System.out.println
This is not how it should be. This should be:  if (log.isDebugEnabled()) { log.logDebug( message ); }  Do not use "if (debug)" because this is hardcoded and will never be enabled. Do not use "setLogLevel()" because you're overriding the system administrator's configuration.
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
I would ignore empty notifications and would log warning.
This sounds strange, can you please explain why do we need this synchronized block?
The output should be as before. That means you should print what the sysout was printing: String.format( "%s %s %s", GdbPlugin.getDebugTime(), TIMEOUT_TRACE_IDENTIFIER, message )
Should the E2E really fail when the log cannot be printed to the console? Maybe it's better just to print "log could not be printed" or something like that, including the Exception message. <review, testing, logic
Reads nicely if this is written as if (isBinaryValueAvailable()) {.
this.sourceType
throw -> failure or exception?
diff - source.readInt() == 1 ? true : false + source.readInt() == 1
An empty message is OK.
Consider using the built-in parsing in the URL/URI classes
How about this instead? suggestion return (boolean) sourceStatusOptional .map(s -> s == Status.AVAILABLE) .orElseGet( () -> { LOGGER.debug("Unknown source status for source id={}", source.getId()); return false; });
Casts should have a space after the closing parentheses. There's a couple to fix here. Ex.: ((GlowTntPrimed) source).getPlayer() != null Also you can store the GlowTntPrimed instance before returning because you are casting it multiple times: java GlowTntPrimed tnt = (GlowTntPrimed) source; return tnt.getPlayer() != null [...]
This gets the configuration from the system properties, intead get the configuration from the BundleContext. Something like: boolean explicitInitRequired = Boolean.valueOf(Activator.getContext().getProperty(REQUIRES_EXPLICIT_INIT)); This is important if multiple equinox instances are embedded in a single VM. Each should have the ability to be configured independently.
How about: letting the state to transit to UNINITIALIZED inside resetProducerId (since it will only execute successfully if not transactional). By doing this we still have a single transition path to INITIALIZING?
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Should this use RANDOM_PORT_INDICATOR instead of 0?
Please keep this.cell near the related fields (previousFamily & cell count) below
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
have a default constructor with reasonable default values
Please don't reuse the same dictionary instance to register multiple services.
you can avoid the stream here: fSeries.forEach(s -> aggregator.accept(s.getXConsumer())); slightly less characters! This will also force you to use separate variables for the X and Y aggregators, which is not a bad thing.
do we also need to call lifecycleManager.onError(....) on this case to make it consistent ?
for all the "waiting" items, I think we need to add "resource" otherwise people will ask "why am I waiting after I was queued".
redundant invocation of specificArgs
maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.
we can replace all these with getTxBuilder()
Why an event ID is built around project UUID?
nit -> Skip update of current version {} to {}, as they are the same.
Why?
I would prefer not to use null ... just a empty set and then assert that its not null
Can we move both of these under projectId so users don't missing filling them in?
What happens if failoverSafe == false? I'm thinking, if user opted for semaphore that explicitly throws exceptions if something goes wrong, do we need to inform him that new state has been created? Also I think we should write to log if new state is created.
lots of duplication of boilerplate constants and before() logic in each of the stateful storage tests and in CheckpointManagerServerTest. Can we share this code in some test helpers?
Why use this stream/list creation instead of adding the single info type like in the other examples?
nit: I'd prefer warn, this is probably not super actionable for us?
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
is there no common place (at the broker level) we can add the unioning query runner?
This can be static
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
Shouldn't be a separate config, there's already a fetchThreshold Samza config.
This timestampTable arg is always empty
Is this allowed to return Collections.emptySet()?
let's split some things into variables, the multiple layers of nesting makes this quite unreadable
Why do we need this separate mapping? Doesn't the mapping below carry the same information already as the DivolteSchema contains the ID?
Why not create the taskExecutionDAoFactoryBean in the ctor?
Should pass parameters along instead of doing null checks.
Instead of making it a singleton, why not create the connector in setUp?
setStarred would be a better name imo
What does "received" mean here? Please rephrase the message.
Can refresh be used intead of the the call to these 2 methods?
what about outWriter? Move this stuff up into the blocks, so you cannot forget adding it here.
Consider iterating through entrySet() instead
this job should have setUser(false), setSystem(true) so that it doesn't appear in the progress view.
There are some project types that are not AbstractProject like Build Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstractProject that causes problems in these scenarios but those should be fixed as time goes on (hopefully) and maybe we could try to avoid those problems here. Can we find a better class or interface to check for that also has getTriggers?
if we continue with this convention, please init to true also here
casting to Integer is redundant. IDE shows warning
not so readable. looks like good candidates for parametrization
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?
you don't want to check that images are legal and exist?
would be good to mention TestMojo#getTestDependencies() here as it has to be kept in sync
Why did you rename this? Semantically, this is a step backwards
![MINOR](<LINK_1> 'Severity: MINOR') Split this 227 characters long line (which is greater than 150 authorized). [![rule](<LINK_0>](<LINK_2>
nit: UNBLOCKED would read better than NONE
You probably want checkNotNull here - assertNotNull is no op if assertions are disabled resulting in a NPE below, checkNotNull will always fail on null leading to a consistent error message.
This bit of code needs the same treatment as lines 120-122 I think. If the evidence type is PasswordGuessEvidence, then return the result of getCredentialAcquireSupport for any algorithm (pass in null for the third argument).
I'm not a reviewer but FYI  CredentialModel.PASSWORD.equals(credentialType) in that order can't throw a null pointer exception, usually always the constants first because equals accept "null" but null don't have equals function.
What's the point of adding a copy here?
You can do credentialType.cast(...) here instead of the unsafe (C) cast which generates a warning.
I don't quite understand the credential store reference, which is something we should talk about, however I will say that in this particular case there are a couple of problems... First, credentialType can not be null for CredentialSource. Second, you can't cast Class objects like this safely; instead you would do something like this: credentialStoreReference.getType().asSubclass(credentialType); which will yield a Class<? extends C> which would be good enough for this particular case.
I don't think this 'if' is correct - we still need to verify that this identity does have the set of OTP attributes associated with it even though we don't care which algorithm is in use.
this piece of code is copied 3 times. maybe it is worth to create a checkNotClosed method?
This can cause a ClassCastException if (for some reason) the user of this CredentialSource tries to query some other credential type. A better option is to: * Create the PasswordCredential outside the anonymous class to avoid allocation pressure, and * Use return passwordCredential.castAs(credentialType, algorithmName, parameterSpec); as the body, which will return null for any unsupported requests as per spec.
Same as above in otpTest.
can be replaced by List.of
Collections.addAll saves the wrapper object... although we don't need to go full-on nit picky on allocations like we would something in a library.
Please use Collections.addAll(Collection<? super T>, T...) instead.
The options are input only
use ImmutableList
Let's make the thread a daemon thread, and let's also give it a name so that it is easy to identify when investigating thread dumps.
Can you use new ArrayList<String>();?
- static import - why is having no delegates an error?
I've been doing all asserts in the build method to prevent the duplication you have here (for the null check). If the user passes in null, that's ok as long as they don't call build until they call it with something else...
new HashMap(delegates) - don't keep a reference to the caller's map - he might change it.
why not an empty map?
@ILikeToNguyen Why the change in visibility here?
You can use Map.of
please extract as constant
This can be static.
I'd add an always-printed log message here too to make sure it's remembered.
You can probably use EntityPredicates.id(), which gives back Function<Identifiable, String> (rather than just for entities).
I'd prefer to see the whole sub-select statement as a separate variable. At the very least, have the balancing bracket for the SELECT in the second string.
why not null as value?
not that critical , but why not for (Entry<String,object> entry: tasksMa.entrySet() ) instead of using iterator?
Rather than calling run here, make run() call out to a no-args method like this: java public void onClick(View view) { // ... if (id == R.id.button_done) { nextWithEmailAndPassword(); } // ... } // ... @Override public void run() { nextWithEmailAndPassword(); } private voidNextWithEmailAndPassword() { next(mEmail, mPasswordField.getText().toString()); }
the if and else clauses here will both result in the same behavior below
I think you can remove the surrounding if, it's quite safe :]
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Why do you use a static newInstance Method? Just do it f.e. like this: AboutDialog aboutDialog = new AboutDialog(); aboutDialog.show(getFragmentManager(), "dialog");
It's better to use #isLegal because that sends an IllegalArgumentException. Also, it is more elegant to first check the argument and then execute the code. That gets rid of the 'if'.
Uh, IllegalStateException?
As no transformations are happening to id, why not make checkForeignIdLimit void
Can we make it final?
return id;
Before go through the loop make sure that position and symbol parameters are not null.
Extract this into method getTotalSellAmount. The refactoring tool can do it automatically. Code smell Overly long function
needs to be named something more relevant like market
Returning an empty string when an invalid position is passed could hide some bugs. What do you think about skipping this position check so an ArrayIndexOutOfBoundsException occurs if an invalid position is passed?
Since this is a separate check anyways, I don't see a benefit in comparing with FFFD instead of 10000. Use >= Character.MIN_SUPPLEMENTARY_CODE_POINT instead. It's also more evident what the code is trying to do that way.
Variable 'o' should be more descriptive.
o should be capital! sumOfBuy
Refactor this into its own function called placeNewSellOrder.
Since some of the code for checking invalid orders, is common to placeNewOrder() and placeNewMarketOrder(), you can move the common piece of code into a new method and reuse the method
name the sets something related to buy or sell so that they are easy to distinguish later on in the method
What does the magic number 2 mean?
Do you have unit tests? Again you need to use equals
Did you take a look at HibernateDiagnosisDAO? The service layer will delegate to the data access layer which fetches directly filtered data from the database instead of fetch it all and then filter in the application memory.
Was this implemented like so in the emrapi module?
Why is it a list of lists, not just a list?
uniqueDiagnoses is a Set and by design it doesn't allow duplicates, all you need to get rid of duplicates is the call below: uniqueDiagnoses.addAll(diagnoses);
null? why not just a () -> {} ?
Instead of calling encounterJson.add(..) three times, can't do it once?
either if (!storageDevicesListCalls.isEmpty()) or storageDevices != null below
I know it's trivial, but would be much nicer if this mapping was extracted to a separate function.
name it github config
If you get something like an InterruptedException, this will just catch it and move on.
This line and the line above is migration code so that no db-script is needed, right? That's fine! Why not doing it in one place (maybe also together with the if-statement), so here or in SW360Utils?
What you have done is sensible and should speed things up by hitting the database less. But, the logic is now duplicated between ConvertUserDOToUserDTO and converUserDOsToUserDTOs. Changing the body of convertUserDOToDTO to just call the other with a list of size one will eliminate this duplication and avoid future bugs where we update one and not the other. Same goes for getAuthenticationProvidersByUsers and getSegueAccountExistenceByUsers.
it's more like initUsersAndOrganizations instead of Coduno ?
Log the exception as a second param.
remove; useless debugger output.
Is there right message? Because this one is same like for UserSyncFailed.java event.
Why do you use package-private access for this constructor?
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
Idem this could be handled with an Optional...
If we are changing this code, then relying on Optional could be a good move.
If we are changing this code, then relying on Optional could be a good move.
If we modify this changeset, then we could give a try to using Optional here
Use Integer#valueOf(int), or delegate the work to the method above, so we can benefit from Java's internal int cache.
This can fail on NumberFormatException. Is it handled somewhere?
Here, you can simply call the other constructor: this(Integer.MIN_VALUE, Integer.MAX_VALUE);
nit: return isEffectivelyNull(val) ? null : val;?
Looks like a null check on sourcePort is missing here because sourcePort is Integer and therefore can be null. If sourcePort is null then the comparison "== 0" will cause problems when trying to debox sourcePort to int. Just tried the following similar code and it crashed with NPE: Integer sourcePort = null; int x = (sourcePort == 0 ? null : sourcePort);
Please use TimeUnit.MINUTES.toMillis(15)
Wouldn't this test be more "accurate" if the only thing that changed in each entry was the timestamp (and not the value)?
exists is statically imported.
Unlike other tests, this test does not compose the chain using expected.
Wouldn't this test be more "accurate" if the only thing that changed in each entry was the timestamp (and not the value)?
Why 0,8 if all we are setting is 7?
You should do not need this one. You can annotate the class with a jUnit runner
@vilchik-elena You could factor the list of kinds into a static field Kind[] kinds = {Kind.EQUAL_TO, Kind.NOT_EQUAL_TO} in the enclosing class.
I would use Tree.Kind.Method here in order to avoid the import of org.sonar.plugins.java.api.tree.Tree.Kind (L#30)
nit: you can do mLGNames = Sets.newHashSet();
hasSize()
Call I18N.getString(String) (there are no parameters in the resource messages).
Can we use url building here, to avoid problems with / at the end of the server.
this is confusing, it is called router but actually it is routerUrl.
Not provided the Locale in the first argument can cause issues depending on which user the Locale has the app set to. I ran into this with the Simperium library.
Probably should crash if bad format string
Better to add checkNotNull for the arguments.
We can make this inline. suggestion return ";" + USER_AGENT_SUFFIX;
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
This logic needs updating to handle non-deterministic filters. See latest BooleanSelectiveStreamReader.
use filter.orElse(null) with requireNonNull this.filter = requireNonNull(filter, "filter is null").orElse(null);
Maybe add a requireNonNull for filter and outputType. Missed that before.
like in direct reader make this: checkArgument(filter.isPresent() || outputRequired, "filter must be present if output is not required");
isn't this already done by makeFiltersModifiable()?
"stream is null" -> "streamDescriptor is null"
!isEmpty() ??
The filter could be very complex, a anded/ored mix of spatial and attribute filters, better check if the filter is supported right here, using both the property names, and a filter capability object/visitor that can decide if the combination is worth testing. (e.g., "bbox and propertyIsEquals" is probably supported, "bbox and intersects and propertyIsEquals" too, but I guess "bbox or propertyIsEquals" maybe not).
Shouldn't the checkArgument line be the only thing removed?
This needs to be .equals
I think the annotations should be on separate lines
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Same backward compatibility concern as in EC2AbstractSlave.
You could probably use the same URL as in getResultById here.
Why can't you just return value here?
Integer.parseInt
Better to return "";.
This is another behavioral change that I don't want to see in an unrelated PR.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
remove static
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
Looks like this function is never used. Do we need at for this feature?
why not build this behavior right into TypeHelper.isA?
nit: suggestion if (HeaderParam.class.equals(annotation.annotationType())) {
I think the interface Map is enough as return type. Also, sorting the methods by first usage would be clearer.
Name is no longer used
nit: flip the logic and save the indent for readabililty
So I believe they want to know what was the last valid test script that covered the test point. This seems like it will just save the last resolution regardless of what it is.
This could be enhanced for
Instead of FileHandler, you should use the PropertyConfigurationLayout to save it to a FileWriter.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Imagine we have 2 KIE Servers. None of them are up and running when we do the first round of client creation. So they both fall back to async creation. First KIE Server client creation then succeeds and it then forbids the scheduling of next possible tasks for other KIE Servers. I think we should just cancel the periodic task just for the KIE Server which we were able to connect to. So we should hold all tasks in a separate collection. Moreover, after the last task is removed, we can shut down the executor service.
i don't think its a good idea to include password in exception message
You could use try with resources here like this:  try (InputStream in = Config.class.getClassLoader().getResourceAsStream(fileName)) { config.load(in); }
I think better to use string concatination, as info log level this might called lot many time and string concatination has better performance the String.format. Another place where place I could think we can make more use of make logging, if present the file full path instead of file object.
Mistaken commit?
different value 50 versus 1. Is that intended?
This is a very nice check. Could drop You from error message Must stop the oracle server to remove an application
Should we throw IllegalStateException?
I believe this line is incorrect and should be removed
This will only work if Jenkins is running on the same host as the docker daemon. It won't work in the general case where Jenkins is on a separate host from the docker hosts/swarms that it's talking to.
It seems cleaner to make this private, and add 2 static constructors: ServerFrontEnd.udp(adapter, port) ServerFrontEnd.tcp(adapter, port)
this could be moved to field level (practical reason next to one line less is we don't have to take care of it if we introduce a new constructor)
Is it a good idea to give access to the view directly to the page? Wouldn't it be better to have an inner class for the sheet page to access the contents?
Should be > I think, as we _could_ have found port 65535 was available.
maybe  java public ServicePortAdapter(ServicePortAdapter port) { this((IServicePort)port); this.routePort = port.isRoutePort(); }  would be better here. It becomes clear what the new constructor does additionally
We need to get GdbLaunch#disconnect() to do what we want the proper thing, because right now it just terminates. This is the same situation we faced for GdbLaunch#terminate() which was fixed in bug 434645. Once that is done, we could choose to not retarget IDisconnectHandler here and let getAdapter return the platform adapter DisconnectCommand which simply calls GdbLaunch#disconnect(). But changing the adapter is good too. I'm not sure what is better. Your choice.
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "SERVLET_PARAMETER_ENABLE_PNPM"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
hasAnnotatedAllParameters is already checked in the super class, right?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
What if extended SherlockActivity contains android MenuItem or vice versa? I haven't tried, but it seems that the user will get an error in generated folder.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
The super() returns "" on null. Why should we differ?
You could maybe use enclosingClass to save a few hops...
I would not recommend a publish workflow for this, especially not a one-way publish workflow. In practice, developers will create a revision, publish it immediately to test with, and then create a new revision, resulting in a myriad of unused revisions. This is the same reason we ended up removing the publish workflow from schemas. It would be better to just always allow elements to be mutable.
This method might be the one in public.
Do we want a test case that you can create an element with any revision?
We know "ordinalStr" is null, this will fail in NPE. The content of this if should be "logMissingAttribute(element, ATT_ORDINAL)" and another if should be added with condition " != null" to log a potential malformed integer.
you can either remove else or add pair of curly brackets
why this double usage of URL? Wouldnt be using URI instead of URL be fully sufficient? (URL is known to have severe flaws and should be avoided if possible)
As per bug 487713#c11, the previous revision used to return the path in case of IOException. Do you think it makes sense to add that return statement?
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
As part of the bigger picture to eventually have checked exceptions, I think this should be specifically a runtime exception. We shouldn't hit the MalformedURLException, since the url is the same that was provided to us, minus the user info. So I think we should just throw a RuntimeException directly.
can we do a shortcut here and return null if url == null, to avoid that deep nesting?
Note File.toURL() is deprecated and known to cause issues (though I don't quite recall which ones). The recommended way to do this is through File.toURI().toURL()
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
this.url = checkNotNull(url, "url");
I think this is an accidental duplicate check (checks the same thing twice, no modification in between).
Is there a chance of a NPE? could be getFile() null?
Looking at the usages better throw in this case.
We need to keep the throw exception as we are not changing the existing behavior
Why do we return the parents name instead of the name we store a few lines above?
Use another name here. My suggestion is: Asset Options
Maybe we should include the class statement in the code sample.
Is this supposed to be <code>return "Bump"</code>?
This fails for, e.g., 1.1 < 1.2.
It's not your doing, but this line cannot be reached because of line 171/169. And, in fact, CLASSVARIABLE is never used. (Also not your doing.)
why no violation ?
@dmzaytsev let's inline this
Maybe expectThrowable for consistency?
Although your change enables editing the right-hand side if the left-hand side is read-only, the changes on the right-hand side still won't be saved; I assume you need to modify the check here too: (isLeft && getCompareConfiguration().isLeftEditable() || !isLeft && getCompareConfiguration().isRightEditable())
Don't initialize to empty when null.
Simpler as ImmutableMap.<String,String>of().
Oh please, no! Don't ship a null object! :cry:
we never use NULL, it is a bad practice in general.
![MAJOR](<LINK_0> 'Severity: MAJOR') Constructor has 12 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
this is the spotbugs issue, you're building a new object but not assigning it anywhere
Thank you for cleaning this up! I think this is carryover from the .net LL since Dictionary is the commonly used map type
Add { and }.
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
I can't believe I let this line of code get in. Terrible.
hm, how about "...".equals(intent.getAction()) or TextUtils.equals(intent.getAction(), "...")? [fyi, commit amend + force push are fine]
Why did you only do this for HealthReportBroadcastService? AnnouncementsBroadcastService uses a similar paradigm.
Change this conditional to an early return.
add a null check in 597
cool, structurally I think it might be better to handle this case in the preceding if-else as that is for discerning actions. Works well though
Needs to be changed to "org.autocrypt.PEER_ACTION".
Not sure why you are redirecting the name to the EditAccountActivity. That activity is not doing anything with that name anyway.
Debugging code?
The system properties that we access from Java (as opposed to Maven-only) usually start with infinispan.test
just return ListeningExecutorService
I think we should change this example to call 2 minutes with TimeUnit.SECONDS instead
nit: typo UNKNOWN_VM_VENDOR ?
let's make a meaningful constant for 5
static
yeah, I think definitely add a numberOfHosts field, that's @Value.Derived on each of the impls.
can we remove this method and simply have the poolsOfString.take() where this method is called?
this can be simplified a little: public static Integer getInteger(String nm, int val) where val is the default (so no null check needed)
same here for node
as above for cache
super nit: make string task a public final variable.
nit: as above for external, and entity here and below
unnecessary parenthesis?
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
I think in KIP-444 this metric would be replaced with the task-level dropped-records right?
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
IIRC nc needs to be 0 padded to 8 digits. Which is what I was trying to do with 8.8x.
return id;
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
JDT uses compact assignement, e.g. i= 3;
Missing StringUtils.isNotNullOrEmpty() check
It's better to use #isLegal because that sends an IllegalArgumentException. Also, it is more elegant to first check the argument and then execute the code. That gets rid of the 'if'.
no static
Should getValue() be tested for emptiness as well, due to subsequent .get(0)?
I think you can remove the surrounding if, it's quite safe :]
Can we make it final?
What circumstances can cause a message to not have a key "id"? (Just noticed this is preexisting code)
Should be added the Override annotation.
When do you ever use the above service? And if you do, is it more than once?
Can we remove these empty new lines?
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
This assertion should remain - when caching just Channels, there is only one connection (default). I suppose we can allow it to be set as long as they set it to 1. Will change during merge.
super.init() method never throw an exception.
@aschworer same with this test
Should be removed if empty
I think this part is redundant with the settings in setupModuleExportsOnly below, isn't it?
Maybe take the opportunity to set index = null here?
If storageManager gets a value in constructor, then we don't need to check null.
cannot be null.
Does it make sense to cache the result?
See below; there is no reason for this that I can see.
Shouldn't it rather throw an UnsupportedOperationException? Alternatively, it could return new ByteArrayInputStream(buffer).
Not your change - we should actually set this to the saved stdOut - ideally saved around L85 (now L97) System.out
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
Should be a static class to be safely serialized.
Same as above: I think it is clear enough without the id variable same for below too
The names should be consistent. As suggested, cancelAddInstructorLink is preferred over addIntrCancelLink.
I think can just use the @FindBy defined at the top instead of findElement() againt
i think you can replace browser.driver.findElement(By.id(id)) with inputBox?
i think you can replace browser.driver.findElement(By.id(id)) with inputBox?
Can you add getId() and mark id() as deprecated?
Missing StringUtils.isNotNullOrEmpty() check
these setters should not be public
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
I think should align the && with [e]ditInstructorName...
I think it will be better to close the other store as well.
Could you please add a null check and isClosed() check (if available)?
Build failed: Need to throw IOException or catch it  public void close(){ try { if (input != null) input.close() } catch (IOException e) { // ignored } }
This shouldn't be closing the underlying store since it may be shared with other 'NamespaceAwareCoordinatorStreamStore' instances.
close should invalidate the iterator, but you are reliant on the internal iterator for this. You should have a flag isOpen (or isClosed) that is checked for the various methods. Take a look at htsjdk/samtools/util/CloseableIterator.java You should also (evidently) call close() if hasNext is about to return false.
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
remove this
Should this be shutdownNow as any pending reactivate commands should be terminated?
factory must close its cursor (which is closeable)
The default implementation of close() is to wait forever. What's the reasoning for using Duration.ZERO here?
Check command and status null.
Check if address is null.
Not sure if we want to print out the exception.
os.write(command.getBytes()); ?
If we already generate the checksum field in the constructor, the reset over it would be enough to regenerate.
Should this return Flux.error instead of throwing?
Multi catch here and below ?
needs US-ASCII charset, or some other simple ascii encoding conversion
if you don't have header and footer you don't want to move + copy the file
Can metadata or event type name possibly contain something that should be escaped? (probably not, just to ensure that you checked debug calls)
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
suggestion return new BridgePath(virtualFile.parent(), fileSystem);
we could prevent this if the color is "white"
You don't need to cast to an EntityLocal to call getAttribute() on parent.
!(parent instanceof MGenericStack) || parent.getSelectedElement() == part
Please, respect surrounding code style (() {).
Maybe worth removing the call to Objects.equals() here too, as both child and parent can not be null.
Resource leak: this allocates a new SWT Color on every refreshVisuals() and they are never disposed.
Test of .some() instead of unguarded .get() followed by != null.
I think the chart viewer should be responsible for its own presentation provider. The tree viewer could ask the chart viewer for a series appearance directly, perhaps through the ITreeViewerInterface? (could be renamed ICounterChartViewer).
Does TYPICAL_LOG_MESSAGE need to be a local variable? You can hard-code /typicalLogMessage.json here if only used once.
check if getters1 is null and remove firstTimeStream
Style issue: @Override shuld be on line above the method declaration
null? why not just a () -> {} ?
Why is it a list of lists, not just a list?
Why is this not using getPartitions()? They seem to do the same thing.
can you pull this from a static string?
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
Hmm, shouldn't we break the processing and return the error? If we fail to submit search for one server, we may not return correct results ...
I think we don't need to log anything when we throw RuntimeException with original exception included in it
null != settings
A check for settings.getConstructorArgs() != null is not required if we check that null can't be passed to MockSetting.useConstructor(Object ...args) as described above.
return settings == null || settings.isChatColours()?
I think the existing code is correct for the "jump" plot behavior - this should advance the plot as time marches on. Although this change would result in desired behavior for the non-changing historical data, it would result in incorrect behavior for live/streaming data. The issue comes from the fact that settings.getMaxTime() is returning system time in the first place. This makes sense as a reasonable default only in the absence of a time service, but should be overridden if a time service is available. Some care should be taken to ensure that only defaults are overridden in this manner (e.g. to avoid overriding when getMaxTime() is returning a persisted user-specified value.)
you should catch EbodacLookupException too
Still confused about this line. Shouldn't SystemTestData use the default, which is to not included the prefix? I would expect this to break existing tests, unless i am misunderstanding something.
Since both annotations define a default value when is this ever 0?
Looks like you forgot to pass ignoreTrailingAndLeadingWhitespace to CsvParserSettings.
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to remove it altogether, no?
I'd like the constructor doing as little work as possible. In ImapConnection we have open() for that.
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
Please check that the data buffer has at least 2 bytes to avoid a NPE.
why is this necessary?
Why you convert short to int and then to Integer here and below?
these should be closed?  try (ByteArrayInputStream bytein = new ByteArrayInputStream(body); GZIPInputStream gzin = new GZIPInputStream(bytein); ByteArrayOutputStream byteout = new ByteArrayOutputStream();) { ... }
Parenthesis missing.
You may use 8 * data.length - ByteUtil.numberOfLeadingZeros(data). And check the residual against 0 or 1
I think you should be using uint32ToByteArrayLE() here. Kind of inlining the logic from the method is a step back imho.
Please, remove all of these changes from this PR. We have figured out that the solution to this problem is more complicated and I will create a separate PR resolving this problem.
Don't wrap individual sections of the data byte array into ByteBuffers to decode them. Wrap the whole thing, and then navigate the ByteBuffer to read sections of it.
emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet()
this.
Does this mean that we get an additional object per invocation? If so, then I'm not in favor of merging this pr.
I think this can be:  m.put(key, ImOption.apply(m.get(key)).map(lst-> lst.append(elem)).getOrElse(() -> create(elem));  Though maybe not any better.
Are you intending to be able to call DataRegistration.of(Keys.FOO)? because the varargs can have a length of 0 by omitting the argument altogether in this case (this is why Cause historically always had an Object, Object... method signature, to ensure there's at least one argument passed in.
I had missed this usage of Map.Entry as a tuple. I am pretty sure there is a type hiding there which would make sense ... or an indication that something is not right and needs refactoring.
That message is confusing. Just say that it should not be thrown here as sizing is not happening.
preferAsync means that async ops should be _preferred_ to native getAll operation. If there's not native getAll operations, it should still do the async version, not retrieve the values sequentially.
Why is this here?
I think it better to remove generic type.
suggestion return new Intent(context, CustomTabsManagerActivity.class);
Move the intent instantiation code inside the else branch, as it is not needed otherwise
I think we should set isBound = false here. onServiceDisconnected is not called when the client is unbound normally. According to the docs, onServiceDisconnected is only called when the process hosting the service is killed/crashed.
Travis is failing due to this empty line. Removing it will fix the checkstyle.xml exception.
can we be sure that context is a ScriptActivity?
These empty implementations can be removed I guess
can we check the action from the intent here? it's common practice to:  if (intent.getAction() == ...) { }
When connect is called we should update the connectState to ConnectState.CONNECTING
ServedService.class should be replaced with WifiService.class as it was before in both the lines.
You may also use this to access real primaryColor of the theme. I am not really sure which is the best. We are using different colorPrimary for DevFest, StudyJams etc.  ThemeUtils.getThemeAttrColor(context, R.attr.colorPrimary);
Should be here ac.stateChangingCheck(); @zlamalp?
List<User> -> List<Facility>
Please change the return type of the method to Long: suggestion public Long call(ApiCaller ac, Deserializer parms) throws PerunException {
Again please fix all occurrences of this exception message.
Where are exceptions? We are describing all exceptions except InternalErrorException, PrivilageException and RpcException. You can check in AttributesManagerMethod (It is missing here in this manager)
This change is not correct. Role can't be null for this method. Please return back the state before your change there. It was deprecated but functional.
You can use params.contains("sponsor") to check if the parameter is available. Using that, you don't have to deal with the exception anymore.
this is not used anymore
Maybe you could use isDirectGroupMember() which is currently present only in impl/dao layer (GroupsManagerImplApi). Just add such method to the BL and API (entry) layers and then use it here.
You updated docs key -> type, but actual reading of param is still using old name (same goes for exception text few lines below).
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
how do we utilize timeout?
why this is in vmCommand? should be in stopBase command
isErrorIfHostDoesntExist => isNewHost
Changing this to true would still be useful to solve the unreported bug that I described.
How come the job request is added to the parameters automatically, but the list of resources is not?
Since such an empty container could be used at several places it would make sense to create it once and store it as a class instance.
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
In context it doesn't affect anything, but we might as well make this a primitive long.
Can we pass the error "e" also into the poll status to give an idea what the "unexpected" status might be?
@Before / @After could overwrite System.out :-P
When the view is closed you need to stop the build thread
Will need a @since tag.
you should have here setSucceeded(true) IIRC.
audit log ? setSucceeded(true) should be added IIRC
Would it make sense to add something this.caches.clear() to the stop ?
No parameter in setter method?
Recommend throwing UnsupportedOperationException if the disk methods are called.
this doesnt do anything
DEREncoder shouldn't be referenced from ASN1Encoder - the implementation of this method should just be moved to DEREncoder.
Which type would be assigned in this case?
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
Then should we just use it to save the update items?
Do the traits have to be ordered? Could you use a hashset instead?
Rename to "dependency"
minor: initialize this at declaration
I also removed StoreKeyFactory in PR #1025 . However, I introduced StorageManager into the constructor. This is used for dynamically shutting down store if IO error kept occurring.
Rename to "scheduler".
perhaps pass along the entire BaseIndexOptions to be more future-proof?
s/all/internal/
You could just use Closeables2.closeQuietly(azureBlob);
Remove by dn/key.
Let's keep it as it is for the being.
If you'd like to get telemetry how frequently this error occurs use ClientAnalytics to log this event and information that might help you to investigate what happened
Throw it; we want to fail fast rather than wait for auth failures talking to the far end.
an expensive way to check if it exists ... if there's no other way, then this will probably do
Unused
throws NakadiRuntimeException
Don't do this. Consider initializing this helper class with the compute logger instead.
Overkill. Just hardcode HtmlPublisher.class. (The original code would have triggered a FindBugs violation, BTW; it is not safe for subclassing from another package.)
The original version is more precise?
[If a player is targetable becuase VANISH_PREVENTS_TARGETING is false](<LINK_0>, should spawning also be unaffected?
are you still creating new contexts here?
Once you switch back to the Apache commons collection 4.0, it would be unmodifiableMap
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
it is not related to your change but it seems unnatural to have to check if krunOptions is null
why was this done?
The duration variable should be qualified with the this keyword.
That would be great!
+1 for exposing an instance of the log formatter in InternalDriverContext. This is a simple class so the context can build it directly, no need to have the class name in the configuration. See how getNettyOptions() is implemented in DefaultDriverContext, it should be exactly the same.
reference equality?
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
I guess you forgot "other." prefix
missing { and }
nit: Take a look at QueryConfiguration for this part, for consistency
Could use o.j.s.util.EqualsUtil here.
In most places you've changed using of getter to direct access to the members, here you didn't do that, was that intentionally?
do we really need all of them here? looks like messageId is unique..
No need for a null check here, instanceof would allow both the class and null check as one.
nit: move ordinal position before isList, which is the case for other usages in this class.
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
I am not following here - why do we want this in sync block?
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
Are we guaranteed that we will always have a ZK connection when EmbeddedServletContainerInitializedEvent is raised?
Use fire(event); for all EventHandler based events
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
This class has no superclass, so I'm not sure we need to call super() here.
In ContainerRegistar (where this code originated), updates to runtimeAttributes was performed in a synchronized block to protect against one thread updating the attributes while another writes them to ZK.
Did we intentionally remove this warning?
The %2$s is positional and needs to be adjusted since payload type moved from position 2 to position 4. Or, alternatively keep this the same, but move getQuoteString to the end and use %3$send%3$s above rather than %send%s.
I think the <zookeeper> argument comes after the other arguments. Also, it'd be good to add one more example with your -d flag.
alias is count but the function is sum
This nice plan nesting looks like you mean a specific query plan (joining tree) shape. Is it guaranteed? See com.facebook.presto.SystemSessionProperties#REORDER_JOINS
Can you use an anonymous name for the maintainer? Not something from production
I fail to see the difference to the previous test. Is there any?
Would you mind improving this test to use executeFile() instead of executeString()?
at a quick glance this looks contradictory to me: how can we know that Marker is a type annotation and not know the annotation type?
Maybe I've misunderstood something here Tom - but wasn't the problem here the buffer being null, rather than the length being 0? Also - whichever if the fields you pull out it's probably worth putting into a local variable in the generated code.
Let's put this implementation on Unbinder itself and call it EMPTY
should atleast check o being non-null and instanceof IdentityExtractionFn .
Instead of reference equality, we should change the implementation to use the query field in equals and hashCode computations.
Cannot we simply use equals twice instead of relying on reflectionEquals? ;) Or if underlying Table does not have proper equals implemented it there instead of hacking it here?
It looks like equals:ImmutableDruidDataSource is not the Java convention. At least I'm not familiar with it. Would you tell me where this convention came from?
This is a bug IIUC. This must be an &&, or any GitHubPushCause instance will be seen as equal?
could be simplified as return (o instanceof LFUEvictionPolicyComparator);
Help me understand the change below more. The one on the left seems simple.
Use another example of expression than a return statement... That example is hard to follow.
nit: space after if before (.
Don't this is a good idea to use toString() for equality, since we may modify toString() to include the hashCode and now we are screwed. Introduce an asString() method or toURI() with a clear semantic and use those.
Can we please add limit to the exception message? So it will be much easier to see the problem!
Use checkArgument instead to throw an IllegalArgumentException?
We don't need to cast to int.
I don't think you need this new flag. You should immediately return null from fetchNextReady() if the child has already been closed, which you can test with child.isOpen() or child.eos(). @jingjingwang do you agree?
You may want to say something like "Items per page limit cannot be..."
You might want to remove this one :-)
checkState
Do you need to worry about whether the ByteBuffer has a limit?
Deprecation of ReverseComparator -- use Comparator#reversed
I can see there's a big confusion here. Basically, offset and limit should be treated the same way. So here, it should be "if both the old limit and the old offset are same as as the new ones specified, we return this; otherwise we create a new object."
This was purposely catching both checked and runtime exceptions, hence catch of Exception, because if this were to have a fundamental flaw causing a runtime exception it could conceivably kill all sling resource fetches.
Maybe we can improve the message further by checking if null == operation and show a different message in case it is. Something generic (like Unable to complete operation on "event-type-name" + reason. What do you think?
@NielsCharlier this is a strange idiom. Does your intent differ from !resource.path().isEmpty()? Can resource.path() return null?
@AlexOreshkevich : I don't think I quite agree with the try/catch here... Could you please remove it, unless there is a good reason I'm missing?
using this approach only root collections will have validatorLocator, all sub-collections/resources will get NPE, when you'll try to use it, you need to inject it in runtime to every resource.
I don't think we need this.
You can use "resourceExists" method which works in the same way as checkResourceExists, but it returns boolean instead of raising an exception.
Very nice!
why do you set it twice?
Unable to update the index. %s is not a supported file path.
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
can we use messageFormat instead of string-concatination? String result = MessageFormat.format( "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.", planet, new Date(), event);
As discussed; are there character or length limits on the string returned? Also, although nothing wrong here, these are fairly structured strings. The first is a fully qualified class name and the second and third are uuids. Such there is opportunity for a simpler format; e.g. "%s|%s|%s"
unnecessary parenthesis?
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this useless assignment to local variable "serverName". [![rule](<LINK_3>](<LINK_4> ![MINOR](<LINK_1> 'Severity: MINOR') Remove this unused "serverName" local variable. [![rule](<LINK_3>](<LINK_2>
Probably it is worth to change return type to Optional<String> and return Optional.empty() here. This will force to implement "null check" in client code.
I might misunderstand what's going on here but it appears we're doing the sort of string formatting and escaping that RDMS APIs already have methods to handle, such as prepared statements.
nit: maybe merge the lines as the formatting looks a bit strange.
This is a bit weak when it comes to IPv6 addresses, as it assumes "hostname" is properly enclosed in [ ].
I guess we can use the following instead of both lines? suggestion ensureNotEmpty("hostName", hostname);
Nit: this consistency.
hostname = DOMAIN_NAME_FIRST_CHAR_MATCHER.negate().trimLeadingFrom(hostname); return DOMAIN_NAME_MATCHER.negate().trimAndCollapseFrom(hostname, '-');  This would be better, it only removes disallowed characters from the start, and replaces anything else disallowed in the body of the string with -. There's length restrictions too, 63 characters per segment and 255 characters overall maximum.
Nitpick: use Strings.isNullOrEmpty() as we do that throughout the rest of the code.
better use a local variable for the return value instead of modifying the argument
Hi @kkrugler, I had forgotten about forbiddenapis but that shows that the automated checks with PRs are very useful. I'll have a closer look at the PR on Tuesday. Are you happy with me releasing 0.9 before merging it? we could release 0.9.1 shortly after that
check that charAt(1) is a . ? (and is also at least length 2)
Mind replacing this with Boolean.parseBoolean(metadata.get(Constants.HeaderConstants.DIRECTORY_METADATA_KEY)), it does the same thing.
@inverno Why public?
Only null check here, so empty string will go through. Shouldn't we check for blank strings ?
Given there is no caching going on and lazyEntriesView is not exposed externally anyways would it make more sense to remove lazyEntriesView all together and just do lazyEntries.keySet() (with the remainder of the line being as it currently is).
no need to instantiate this hashset (not being used?)
Nitpicking: would have been more compact with a constructor KeysSupplier(Collection<Object>, boolean).
you don't need to collect inside getMachineNames if you stream it again on next line. Just return Stream or maybe getMachineNames is not necessary here and just inline it. If you want to split the long stream chain I would maybe do something like  Stream<String> machinesInPod = containers.stream().map(c -> Names.machineName(podMeta, c)); return machinesInPod .map(....
This isn't consistent with the instanceof above, nor with the other convert methods we have in the same class. I'd be in favor of leaving this as-is.
Objects:nonNull is useless.
This doesn't need to be inside the try/catch block. Consider moving the persistentStore.get() call and error handling to a separate function so this one can be simplified.
nit: rename tasksPerInstance to dependencyTasksPerInstance (since this is doing the actual filtering logic, and the final list consists of dependency tasks left behind in the assignment)
can we use sysprop or something for url?
version is protected. I don't think we need to access it via its accessor
options -> version
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
@qqmyers this is used by the ActionLogRecord; there is a generic implementation in AbstractCommand.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
String.format might make this a little neater and easier to read.
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
why not using ID_REGEX?
use Long.valueOf() instead of new Long() - always for performance reasons
456L
use 'L'
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
Bananna
Can't you declare this variable inside the loop?
Is start check needed? Could it be problematic (somehow delay/miss the start when it should be immediate)?
Would it not be enough to only catch MergeException here?
Can this be private, or is there another use case for default attribute outside the builder's call?
Break this line a bit earlier?
Needs to be a constant
These should at least be logged so an admin has something to investigate after seeing no commitMessage field in a stream.
I think it is a bit easier to understand if you add the logic to enable / disable the input field after the while loop. I guess inputTextField.setDisable(!tags.isEmpty()) should work.
performance: 1. it is a bad practice to call a dao inside a loop. 2. ideally the generation would have been in the vm_dynamic table, where it belongs, and then we could have updated the hash and the generation in the same call. unfortunately, it is defined in the vm_static table so it requires more calls to the database. correctness: sorry for nitpicking but it is possible that the engine restarted after persisting the hash and before updating the db generation. in that case, when the engine will start again, the ovf will not be created until the devices will change again. I don't care much about the correctness part in this case (msivak - do you?). but the performance part bothers me. I can suggest the following realistic options: 1. to introduce another procedure that increment the generation of multiple VMs, like updateDevicesHashes (this improves performance) + move this call to be in the same transaction as the call to updateDevicesHashes (correctness) 2. to increment the DB generation inside the stored procedure that is called from updateDevicesHashes - less readable I know, so maybe we'll need to rename it. I prefer #2 because I don't see the point in updating the hashes in a transaction - it seems like a mistake. by updating the generation in the same stored procedure as this of the device hash - we'll achieve the desired atomicity and be able to drop that redundant transaction.
next version of apollo-client will provide an api like appConfig. addChangeListener(someListener, someInterestedKeys) so that the listener will only be called when the interested keys are changed. Right now, we could use ConfigChangeEvent#isChanged to check whether some key is changed in this event.
You are missing db.commit();
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
This should be package scoped, not public.
Did you test the response == null branch? I believe login returns either error or a valid access token, never a null response.
It's better to check/assert that callback is not null in execute instead of sweeping the problem under rug and simply do nothing.
add curly brackets
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
From the 'validateEmail' method you have removed the check for the '@' character in the e-mail address. This method is only used from the ValidateEmailScreen and doesn't play a role for the feature that you are implementing. This is why I think this method should be reverted, so that it stays as it was.
Lame.
isn't that path testing the "empty source" case? ie. if the ref wasn't set to null previously, it means that we completed directly, aka. the source is empty. this is not an error. note that a well-formed source MUST guarantee onNext-before-onComplete order.
I think this change is actually less clear. Workers (members of the cluster) can be leaders, while connectors and tasks are assigned to workers. But connectors/tasks are not workers (members), so it's actually incorrect to say "Cannot restart task since it [the task] is not a leader". About the only improvement to the original message that adds value is to change "member" to "worker", though the value is debatable since we do sometimes use "member" in other log messages (including in this class!).
Why we return AsyncClient here?
Don't we have to say that this is uniqueId JDBC?
- log warning that option is not supported by SNMP
usually data objects never return null where collections is met
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
You forgot this!
Based on how it's used, it's more like a listener not callback.
why not null as value?
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Suggest druid.host instead of 127.0.0.1
Not sure about coding style, but I wouldn't use an else here ("else after return").
Don't put any logic in the descriptor, it should be pure data. Do everything in the caller.
By convention, files in Jenkins home indicate what they were based on class names. Maybe jenkins.install.InstallUtil.lastExecVersion?
Are you sure this is right? Please double check.
dare to extract a constant which increases visibility for this hard-coded value?
This isn't right given the method signature of the base method -- name should be used in some way. If you want to pass in the full path to the db file, then I think DatabaseContext needs to be redesigned.
I think we should TRY to move before we update the file path
.. does not exist or is not a directory. Also: put %s and take /meta/credentials from the constant.
Please create a temporary directory and remove it in @AfterClass.
photonDirectory should be created before esDirectory
Nit: it is a good practice not to reassign the input parameters so I would change this to something like the following: Map<String, String> mapToUse = (map == null) ? emptyMap() : map; JSONObject pathPartMap = new JSONObject(mapToUse);
you can use  return CollectionUtils.map("inode",contentlet.getInode(),"languageId",contentlet.getLanguageId()+"");
My feelings for using exceptions as flow control aside, this log statement is forgot to include the exception e.
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
We really should define an order here. Right now you might get a random localized name, if I understand the code right. I suggest: housename, int, loc, reg, alt, old Also, note that again only NAME has other names than the default and localised ones. So a special handling of the name would be a good idea.
Method could be compacted to one-liner using computeIfAbsent.
Please use braces
java Iterator iterator = value.iterator(); if (!iterator.hasNext()) { // ... } for (int i = 0; iterator.hasNext(); i++) { Object o = iterator.next(); // ... }  is more effective.
PARAM_DATA is used to retrieve the data, but PARAM_SELECTORS is used in the error message.
How about AM's memory mentioned at Line 111?
shardSpecFactory -> partialShardSpec. Lombok would be nice and hide all of this away :)
should this have a ,  to match the rest of the pattern?
This is missing maxTotalRows
Why do we print a secret systemUserPassword here?
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Seemed better before? More readable
the idea of using a builder is a bit off here :-)
I am not sure the changes here improve the situation. It would probably be best to change this into a String.format(...) call... or at least to format the code to remove the many line breaks.
one param per line; leave the first line empty
Ah, if (null) is not compiling, thanks for this fix!
Should delete this empty line?
This is no longer needed if MVs dont support indexes.
This still seems to use the fieldbuffer byte buffer. Can we remove this completely and just use a nested JSON object?
copy/paste error this should be model
Use ReplicationArn instead of Role - arn:minio:replica::28285312-2dec-4982-b14d-c24e99d472e6:exampletargetbucket
Use .append() instead of concatenation.
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void ...) This avoids extra sync objects (and saves one level of indentation!)
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
These should change to store the names in the attributes map so that you don't need special handling for all the places that handle the tags.
Try to use constant non null values in front for comparison methods, as their is less chance for a NPE. "COOKIE".equalsIgnoreCase(name)
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
They are mutually exclusive? Or is that a micro optimization?
return null to make this more explicit ?
This constructor should call the more general one with a default value (3 in this case)
Can header name and value be null?
null checks?
@weisebrazil all indentations should be 4 spaces, not 8.
It's an obvious code duplication. We can save this new request with a modified URI into this.request, and use it in all methods. This is how it works in other classes, take a look
it's more natural to use String.format() here
refs is also a one-time variable
better do .path("/gitignore/templates").path(name)
No need to use UriBuilder
No need to use UriBuilder
@sadovnikov This could be put on the line before
No need to use UriBuilder
Why is this file changing? I'm concerned that changing domain objects will have far-reaching effects. As well, there's no id that this.id can be set to in this method
If environment accepts null, mark it as <code>@CheckForNull</code>
Maintenance of the map will be simpler than that of the list
Is this first else-if dead code? It seems to have the same condition as the initial if() statement.
Maybe wrap in an immutable map.
is this something like /system/tasks ?
isPresent() is expected to be used here.
Binary-incompatible, I am afraid, so you will need to do something like java @Deprecated public AbstractProject getProject() { return project instanceof AbstractProject ? (AbstractProject) project : null; } @Exported(name="project") public Job<?,?> getProject() { return project; }
Same deal here: use this version as the base, and have the extended versions just call into it with each arg.
shouldn't we add a loadFromContext to PackageData - as there will be more place duplicating this code...
Please use Map#enteySet. You can use findbugs to see those warnings. Run mvn findbugs:findbugs after compiling your codes.
Create date once and use it twice. That way the acceptance time will be the same for both.
Matchers.is
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
have you thought about using the builder pattern to follow the code line in the other projects?
This line and the line above is migration code so that no db-script is needed, right? That's fine! Why not doing it in one place (maybe also together with the if-statement), so here or in SW360Utils?
User.isActive() should return a boolean instead of Boolean since UserMetadata states that active is required.
Maybe use Objects.requireNonNull since this is built into Java 8 instead of using Guava.
do not assing parameter! nowhere!
@wisogetnid why are you removing this block?
From reading this line I'd expect this test to pass. We should probably name this CONFIG_WITH_KEYSPACE_2, or make CONFIG_WITH_KEYSPACE receive KEYSPACE and compare it to KEYSPACE_2.
Nit: Make "content" a constant?
I wish there is a good place to have these convertor util methods so that it's more discoverable. Not sure, may be as static in GsonJsonSerializer type, just a thought.
Whoa, this looks wrong. The query doesn't have a native query and it returns an empty result set. I think that probably, this query should return an error, because it represents a kind of query structure Druid can't do right now (aggregation on top of a non-aggregating subquery).
no need to catch exceptions. just let them propagate.
Add markInitialized() after assertion, in case of "-ea" is disabled ducktape hungs while waiting service.
Would be better to use jsonNode.isMissingNode() here.
Minor thing, but actually the message should say "list or map was expected"
this could be: assertThat(jsonNode.get("typeNameMap")).hasSize(1);
Format
no braces around single line block
oops, I missed to merge with Stefans fix for annotated tags (calling getPeeledObjectID()). I'll add that again.
It shouldn't be public
It's better to mention name of the method here like "commit()".
Move this into the block above: if (blob == null) { updatePath(commit); blob = getBlob(commit); if (blob == null) { markSessionBound(); return false; } }
formatting (<LINK_0>
Can you explain why is it better to use o prefix in variable name?
I think we should use a WorkspaceJob here in order to ensure that resource change events triggered when rebase moves HEAD will be batched until the end of the job execution
why do you tick here? To be consistent with commit() or is there any requirement I don't see yet?
See lgtm-bot's notice: the local variable timestamp does not need to be changed into a Long value, we just need to be able to return null at the end.
Let's do return fDetailedLoad; even if it is always null for now
not related to this PR but wondering if returning null or an Optional.empty() in case of corrupted data shouldn't be better.
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
I'm a bit sceptic about this type of changes. @gunnarmorling what's your take on this? I'm not worried about these occurrences but more about how it will be frustrating when we write new tests.
Shouldn't we use empty list here ?
It's written nowhere, but I'd prefer to have curly brackets even for single line.
For consistency with the rest of the code, use brackets in this if/else clause e.g.  if (childName == null) { children = val2.getChildren(); } else { children = val2.getChildren(childName); }
This array is the same for all cases, you can use a static final constant to avoid creating the same array multiple times.
This should be part of the validation in the constructor. By the time we enter this function, encryptionPath should be valid.
Extraneous whitespace
using compareAndSet() might be better since you need not execute the rest of the statements if this is already false, right?
I would guess that the work queue itself listens to the stop event and cancels the tasks. But this would have to be verified.
what happens if the future is already completed?
the null check isn't needed when having the taskScheduler final an being set in the constructor.
By default, it's enable, I didn't see you set it false. So, you can remove it.
No if check needed, just always set the reference to null.
Just in case if user haven't set errorMessageVariable in the BPMN, shall we populate this error message to default variable called ERROR_MESSAGE, ERROR_ACTIVITY_ID variables?
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
Check shutdown in catch block above. If shutting down, log error (failed, shutting down) and return the instance. If not, log error (failed, retrying) and go to sleep. And check for shutdown in run method catch block also. If shutting down, log error (failed, shutting down) and stateProcessingFinished = true, else log error (failed, retrying) and got to sleep.
minor but for readability i may break the setting of the exit status up a little
To clean up properly, please place the Builder in a try-with-resource block java try (Builder b = new Builder()) { // test }
It doesn't really matter, but could be: java return new byte[] { (byte) (val >>> 24), (byte) (val >>> 16), (byte) (val >>> 8), (byte) val };
Check if byte[] b is null.
This could break existing users... perhaps deprecate, and add nextByteBuffer()?
style nit: missing braces, more of these below
CodePointIterator might be a better choice here?
Why are you changing this constructor to public? We have a PosDataCode.valueOf(byte[]) factory method. I'm OK with the null validation, but don't understand why we need the public constructor.
Sometimes the variable lenght int will take more than one byte, so can't just add 1. I think another method that calculates the expected length of the vint could be called here. This method would be a simpler form of writeVint that basically returns the number of times writeVint would increment offset in its implementation.
Magic number? The intend was more clear with Opcodes.V12 + 1.
Avoid lots of small allocations by returning a static EMPTY_LONG_LIST? Also below.
what about location ? we do not need LocationSerializer ?
this is redundant
Will this have any effect to legacy data (i.e. those existing before this PR)?
why you remove this 'full' option ?
Yes, please add these asserts back.
Add yourself here? If you do could you also change my email to the vogella.com one?
Replace Boris?
Maybe add Hendrik, yourself and myself? :-)
Converting to Java 8 is fine with me Would improve the readability quite a lot for this.
Returns an Optional..
Used to be fileSystem.deleteFileOrThrow underneath.
there is no case in which httpClient become null, right ?
the second parameter can be removed
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
one param per line and leave the first line empty
you don't need to do it, testDirectory does that for you already
note: Generally having a composition based factory is preferred. However since the ORC writer is already implemented this way - let's keep it so for consistency.
Should you set the iis to null here so that it is immediately known that this is closed if you try to re-use it? I'm just concerend about someone using one of these and not realizing that it wasn't being used correctly.
You need a CachingInputStream in order to make cache work.
If it is possible that provided URI is relative and this line throws NPE, argument can be used on the left side instead
Shouldn't we call removePropertyChangeListener, BEFORE we call doEdit, since doEdit will change the current object?
isn't it true by default?
Please have result variable.
If we can't get a model-set, will anything work? Perhaps this should throw an appropriate exception in that case.
This is not required, already take care presenter
not sure about this for this reasons: - using HTML with fromSafeConstant is risky unless you control the message directly like in localize() method here. If you take them like here from the DB, if any of the fields in the getChangedFields() would be a html special char (e.g. '<') the whole page would be broken. Not to mention that there is a (small) potential for an XSS if someone would be able to control the name of any of the fields here (not today, but can imagine in future). - would look nicer to have it visualized as list items. If the VmNextRunConfigurationModel.getChangedFields() was a list of strings, you could do something like this: SafeHtmlBuilder changedFields = new SafeHtmlBuilder(); for (String field: object.getChangedFields()) { SafeHtml escapedField = SafeHtmlUtils.htmlEscape(field); changedFields.append(templates.listItem(escapedField)); } changedFields.setHTML(changedFields.toSafeHtml()); Here the setHTML is safe because the fields are already escaped.
This is not clean. If this method now returns an absolute path, you should also change the method name from "getName()" to "getAbsolutePath()". Also, you will need to change the messages. With your change, the FSOperation_ConfirmFolderReplaceMessage would now say "This folder already contains a folder named /foo/bar/target/file" . Which is not accurate. Instead, the message should now say something like "Folder '/foo/bar/target/file' already exists. Do you want to...' Or you could change the code even more, to say "Follder /foo/bar/target" already contains a folder named "file". Do you want to..." Please make sure that you test the workflow, and validate that your final message makes sense.
This could use the instance instead of class method.
This looks like a leftover and it hasn't any usage. Can we remove it?
Could we not leverage method overloading here. Instead of toFalse((AtomicBoolean)object) we use close(object) and then have a close(AtomicBoolean) in the CompletionUtils?
I think we should at least log this exception here before throwing other one
log.trace if at all
log.tracef
Might be cleaner in terms of minimum visibility to just return the timestamp from the transaction task.
In general throughout this class, is isNotNull() really needed? I imagine the isEqualTo check should be good enough. Transaction#getTimestamp returns a primitive long, so non-null.
same here. NEVER do anything with null, it's a bad practice
log.tracef
log.trace if at all
This doesn't actually make the transaction additive, it just changes what we think the current representation of that transaction is. It needs to be made additive when the transaction is created.
can we lower this number?
I believe this method should be getServerMetricConf()
I would prefer not to use null ... just a empty set and then assert that its not null
Please extract some values to make this more readable.
Please think of other test names.
Why an event ID is built around project UUID?
nit: Nesting builders like this can hamper readability. I generally prefer to build anything that isn't a single line (or sometimes two) prior to building the request.
lots of duplication of boilerplate constants and before() logic in each of the stateful storage tests and in CheckpointManagerServerTest. Can we share this code in some test helpers?
lots of duplication of boilerplate constants and before() logic in each of the stateful storage tests and in CheckpointManagerServerTest. Can we share this code in some test helpers?
Why use this stream/list creation instead of adding the single info type like in the other examples?
Can we move both of these under projectId so users don't missing filling them in?
This is a local variable, should be camelCase not fCamelCase
There's no packet data, this contains partial NRB data amputated by what was read in 28 bytes of packet header (incorrectly).
I think 28 bytes have been read into the packet header (incorrectly...), so it will read too far into the next block?
That is Original Packet Length. According to spec, the included packet length is minimum between this and SnapLen (for Interface ID = 0).
Where are you trying to position the file channel? I think it is already at the end of the packet data?
This is impossible, blockLength is an int.
This code assumes that the first 8 bytes of pcapPacketHeader have already been read... It's true in practice but not very safe.
This code assumes that the first 8 bytes of pcapPacketHeader have already been read... It's true in practice but not very safe.
This is impossible, blockLength is an int.
tab to space
Sort of believe We should have MetricManager in parameter given this case.
can we avoid this null check and instantiate it on fields directly (+private constructor if we don't want to create it in any other way) - it's potential race condition if we need that for tests we could have it package scoped reset method
sync
nit: do you need double checking here? if (INSTANCE == null) { synchronized(this) { if(INSTANCE == null) { ... } } }
Please use atomics instead:  java private static final AtomicReference<Schedulers> INSTANCE = new AtomicReference<Schedulers>(); private static Schedulers getInstance() { for (;;) { Schedulers current = INSTANCE.get(); if (current != null) { return current; } current = new Schedulers(); if (INSTANCE.compareAndSet(null, current)) { return current; } else { current.shutdown(); } } }
wrap INSTANCE = new IndexClient() in another if (INSTANCE == null) { check - this is known as the double locking technique
I feel that these services are kind of "hidden" in the registry implementation here. In ORM there is StandardSessionFactoryServiceInitiators apparently for a similar purpose. Maybe it wold be more transparent to do it similarly? Or could these entries be registered in the integrator instead?
prefer the Initialization on Demand Holder pattern to cope with singletons <LINK_0>
other getInstance methods do a null check on INSTANCE and construct it themselves to avoid those race conditions. Are you sure the synchronized here is enough?
This is not the number of threads. It is the queue size. The metric name doesn't look right.
log message is about "attach" in the "detach" method. this is misleading.
Did we want to have this normalize the path also by returning the normalized version from Path?
It seems duplicate code. We can also put the exception throwing into checkIfPathBelongsToZkRealm or validateZkRealmPath() so we don't have to have the duplicate exception throwing in each method. Update: Maybe I would just wrap this into a method getZkClient(path) and put this check logic in it. So just getZkClient(path).operation()
See my previous remark regarding _GenericUtils.length(...) > 0_
I prefer:  java if (GenericUtils.length(owner) > 0) { throw ... }  The assumption is that there is not such thing as "empty" owner - and if there is, then we assume no violation since we cannot determine the user.
Minor: This message would sound alarming in logs. Possible to add more context here about what might be wrong?
Any reason for doing this?
Args.notNull
There is different configuration for persist and recover. This change is combining both. Needs revert
While looking at this, I started wondering if it'd make sense to have this retry forever when Fedora is not available or throws an authentication/WebServiceIOException exception. The reason being that the failure isn't an issue with the job, but with the environment, so skipping over the job won't help. What do you think? Would it make sense to maybe increase the delay and make it retry forever in the two cases I mentioned? For startup of the work daemon i think its fine for it to have max retries before giving up since nothing from the queue would be lost. It'd be kind of nice to get notifications of some sort when these things are failing, but I don't really want to over engineer this since it's not going to be used for that long. So lets hold off on that until the need comes up.
This is duplicated
make it final
To be super clear, wdyt about renaming mTryAgainButton to better match its new functionality?
We don't really need this log string anymore.
You don't need the variable here. You could directly return inflater.inflate(fragmentResource, container, false)
dont do this. this makes this a "tagged class", doing two completely different things with different layouts in a single class. the next guy will again just add behaviour here with help of some boolean flag. <LINK_0> <LINK_1> <LINK_2> this should be a separate fragment.
I'm floundering on where toolbar code should live but it seems if it's going to access the Activity and has no dependencies on the Fragment, perhaps it should live in the Activity?
I don't think this is needed.
Good to mention story reference here
Nitpick: AS is complaining about the unnecessary rootView variable.
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikiPage object/browser info.
Please remove extra line
I never knew you can do typeof(...) although it's a little misleading because typeof is not a function, it's an operand, adding () makes it look like it's a function. How about triple =?
Thoughts: it is better now - but in ideal world I would like to see something like this:  java AdSlot topLeaderboard = page.getSlot(AdsFandomContent.TOP_LEADERBOARD); Assertion.assertNotNull(topLeaderboard); Assertion.assertTrue(topLeaderboard.isVisible()); AdSlot floatingMedrec = page.getSlot(AdsFandomContent.INCONTENT_BOXAD); Assertion.assertNull(floatingMedrec);  _(pseudo-code)_
I see that 3 = pageviews from the method description, but avoid using magic number '3'.
do we need NTI in this test?
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused private "verifyUapBtf" method. [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AUnusedPrivateMethod)
No assertion in this test
Consider moving wiki-page-header to static var
alighment
Why include the name in the comparison? fullName should be enough.
Aside: I'm assuming this was generated. What IDE are you using? Most of them should be able to generated Java 7-style equals that use java.util.Objects.equals(Object, Object) to avoid these null checks.
since you are changing this, I would use:  return addressNum == that.addressNum && Objects.equals(name, that.name);
please fix this one
consider to put && at the beginning
This seems wrong to me because different objects may yield true. Same for hashCode.
Why are these probably incorrect?
Is there a need to move from getters to fields here?
So it is allowed that user to create a read-only realm in thread A, but writeable Realm in thread B? I don't think this matches the behaviour from Object Store -- we need to ensure the behaviour is the same after we migrate to the Object Store schema, otherwise there is going to be a breaking change.
Whoa, it takes me a deal of concentration just to check those two variables represent the same property. Now I know when the bigger is not better regarding the variable naming.
Check if byte[] b is null.
style-nit: avoid braces for simple constructs
could use writeInt(Float.floatToIntBits(v)) to avoid code duplication.
Style-nit: We don't use curly braces around simple loops.
this would not be necessary if we made RunLengthBitPackingHybridDecoder depend on InputStream instead
StringConstants.Minus
I believe guava and commons-lang also have string padding functions, how do these compare to those implementations? (Not a suggestion to use either of those, just curious about the choice)
I would move the last BufferUtil.fillArrayANDNOT in another test that would have the expected exception annotation, just to make the test more robust. Indeed, if the first BufferUtil.fillArrayANDNOTis throwing the IllegalArgumentException because of a new regression, then the test will pass and the regression will go unnoticed.
Short.BYTES is actually Short.SIZE/Byte.SIZE and is only available in java 1.8 and up
Did you mean status2.read()?
SHOW+DATABASES? looks strange.....
formatting
viewers > 0 implies page is non-null
unused variable
Here too, using at least two different timezones would be nice, be it only to check that the timezone is not retrieved as "Europe/Paris" by chance, because it happens to be the JVM default time zone.
Maybe use an RLE block
suggestion return new SearchHitsImpl<String>(hits.size(), TotalHitsRelation.EQUAL_TO, 0, "1234", hits, null);
We normally put private methods at the end
I would prefer to see this logic broken up into a couple of lines, it is a bit hard to parse. As well, then you could avoid the need to create the empty set to pass in for the other getProducts(page) call.
assertNotNull can be used.
Same as above, this looks like an error.
I don't think the process deploy should fail in the case of temp file deletion fail
You can safely remove the file.exists()(implicitly done by isFile
You've got some auto formatting thing on which basically adds "this." everywhere. You may like it, but it makes for a very noisy diff :-( This diff Should be a 2 lines fix. There's no need for the incremental approach here either, given that it's a trivial change. Making it an incremental PR just delays it's acceptance.
The initialization of length needs to be done only once and not all the time getClonedStream() is called. If we would like to handle file length changes it does not work (IIRC) as the file size could change also after the file input stream has been created. So, I think this line could be moved above after file = new File(outputFile); Or is it because you don't want to handle FileNotFoundException twice? But reset the size all the time... Hm WDYT?
if we expect the file to be available, how are we planning to go about during pre-allocation? Are we not planning to use the same constructor during allocation too ?
Is there any reason to add the this. prefixes? Seems redundant when the member variables are already prefixed with m_.
why not use File#getName() for the name?
What will happen if file is absolute?
why is that needed?
targetValues is a List<String> so we don't need to use toString. Could use String.join(", ", targetValues) instead.
suggestion return Arrays.toString(value);
Please use - StringUtils.join(Entities.objectNames(networks), ", ")
consider to inline uris
I think we should sort the tags in a specific order here. Otherwise we could have tests excluded for the same reason, but the strings will not match if tags are not in the same order.
If these are user-facing messages, shouldn't this be turned into platform-specific newlines?
Wouldn't it be better to use the transitionMap to group by from state?
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
suggestion List<Type> skippedTypes = getSkippedTypes(); if (skippedTypes.isEmpty()) { return; } String skippedTypes = skippedTypes.stream().map(Type::toString).collect(Collectors.joining(", ")); getLog().info("Formatting is skipped for types: " + skippedTypes);
And if this sub-stream were extracted into its own well-named static method, the code would now be perfectly readable and self-explanatory.
events can't be null
please use {}
Why are these probably incorrect?
Is there a need to move from getters to fields here?
I don't think it can be null?
Objects.equals()? It's not clear to me if _errorMessage can never be null.
name should also be checked.
is this used anywhere?
This should include the new field - you can regenerate this and hashCode with IntelliJ
This will have some issues if timezone is null.
Would you mind if we kept our privates on bottom? I'm a class client (reader) of more code than I author, which means the most relevant source is almost always the public API. It's quicker to get to on top since codes read from top to bottom.
A Repository can be opened through the RepositoryCache or in a standalone way. We cannot change the close method to not close otherwise we will affect the standalone use case. The repository will never be closed because evict will not be called in standalone. I see 2 options here: Repository opened through the repository cache could be wrapped in a class holding the usage counters (useCnt and lastUsed) and overwrite the close method to do the logic done in evict method. The problem with that approach is that wrapping repository in not possible when repository is added to the cache using the register method. For this solution to work, we would need to remove the register method (and break backward compatibility). Another option is when repository are opened through the RepositoryCache, we leak one usage counter(as it was originally implemented) so useCnt=1 would mean that repo is not used but still in cache. In the therminator thread we do: Runnable terminator = new Runnable() { @Override public void run() { try { for (Reference<Repository> ref : cacheMap.values()) { Repository repository = ref.get(); if (repository.useCnt.get() == 1 && (System.currentTimeMillis() - repository.lastUsed.get() > 20000)) { RepositoryCache.unregister(repository); repository.close(); } } } catch (Throwable e) { LOG.error(e.getMessage(), e); } } };
we don't need to change the Creation classes.
minor: change SocketNetworkClient to LocalNetworkClient in line 98 and 102
I think that this is not a clear way to reset values to default - I think, that there should be something like: System.setOut(System.out);
One of these two trace lines should be removed.
<LINK_0> Let me know if you have any issues managing or adding items to the project
format: extra space
Ha I see what you are trying to do with with the lock. You probably don't need a lock why not synchronize the entire method and use methods that provide atomicity for multiple operations for example compareAndSet ...
please decrease log level to DEBUG
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Please use Optional.ofNullable()
Don't we have to say that this is uniqueId JDBC?
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
It appears that we're invoking StringUtils.isNotBlank immediately after <serde>.fromBytes(). Is it possible to create a Util wrapper for serde and call this method there. Then you check like so:  String locationId = new MySerdeWrapper(valueSerde).fromBytes(valueBytes); public class MySerdeWrapper { public Deserializer deserializer; public MySerdeWrapper(Deserializer deserializer) { this.deserializer = deserializer; } public Optional<String> fromBytes(byte[] bytes) { return StringUtils.isNotBlank(deserializer.fromBytes(bytes)) ? Optional.of(deserializer.fromBytes(bytes)) : Optional.empty(); } }
why not null as value?
Suggest druid.host instead of 127.0.0.1
should be edit
why add?
Similar to start, stop, etc. I think the name of the action enum can be more generic (VAR__ACTION__ENABLE)
It seems that the HotPlugUnplugVmNic Command is being used for both Plug ("Activate") and UnPlug ("Deactivate") actions. Therefore, I think that the ActionMessageParameters should be set according to the "Action" property within the HotPlugUnplugVmNicParameters class: If getAction() is PlugAction.PLUG, then the CanDoActionMessages array-list should be added the "VAR__ACTION__ACTIVATE" message ("activate"). If getAction() is PlugAction.UNPLUG, then the CanDoActionMessages array-list should be added the "VAR__ACTION__DEACTIVATE" message ("deactivate"). [worth consulting with an engine-core maintainer about this]
perhaps change to import instead of move
Since the "TYPE" describes the target of the action, the "ACTION" should just describe the action being performed i.e. I think a better name for this enum is VAR__ACTION__START_PROFILE (excluding _VOLUME_)
Add canDoAction to verify that the session is in paused state. You can only resume if the session is paused.
Please change this to VAR__ACTION__DISABLE
this method should only contain the parameters for the generic messages, means var-action-x and var-type-y and it is called automatically inside commandBase, so no need to call it again the specific failure messages should be added inside the canDoAction so in the canDoAction you should only have: if (somethingIsWrong) { result = failCanDoAction(msg); } (just a note - usually we use 'quick-return' in canDoActions, means once you found an issue, return. so it makes the method more readable (no need ti check the value of 'result' or complicated if-else, but here its not a must since its a short one)
call super.setActionMessageParameters();
why don't you just use a node here that does the right thing? There should a node to read outer, no need to duplicate that logic here, or is it somehow special?
To avoid confusion, rename the variable to sessionId.
entry
could be set via the constructor?
Too much nulls in arguments, please make variable content = null and use it in constructor. Please apply the same for all other test method you changed
It's written nowhere, but I'd prefer to have curly brackets even for single line.
wont this be a breaking change removing the old api's if anyone is using CORE api directly? I appreciate its hidden for JMS users.
it was good for quick testing ... I agree. But please redo it test to make it more functional , load java file, some config, validate it, recheck output.
It seems like we should add some new constructors to help make this cleaner...
Use Local variable start time created on top instead of new Integer(0)
RuntimeException would be sufficient
RuntimeException will be sufficient
Should the scanner be closed after the call ?
Can this affect the other versions that don't specify any families, like flush(TableName tableName)? Because region.flush(true), internally, loads all families before delegating to flushcache(List<byte[]> families, boolean writeFlushRequestWalMarker, FlushLifeCycleTracker tracker), but it doesn't seem we are doing this now.
Changing the region should also invalidate the client like above.
Maybe the interval can be a bit longer since maxWait is in seconds.
I think this is not the correct way here. You should add the executor for this event type to the executorService in startServices method.
nit: if the only usage is to find diff b/ end and start, directly using System.currentTimeMillis() might be preferred option?
good.
suggestion region.equals(US_EAST_1) ? null : new CreateBucketConfiguration(region),  This would be simpler
This change could break people.
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
public isn't needed
nit: you can merge both lines above as checkNotNull will return the given argument
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
OOC, in what ways does findSpecial differ from unreflectSpecial? are the two functionally equivalent (ignoring the JDK bugs), except one stards with reflect data (Method) and the other with a signature (MethodType)? if so, is it worthwhile simplifying this to _just_ use findSpecial? also: does this change have any impact on the calculus of who has access? if the types (args or return) are private, package-private or protected, will unreflectSpecial|findSpecial fail whereas the reflected approach would have succeeded, because we explicitly set the modes to all access levels?
I think the method return type should also be checked here beforehand for assignability to type, and then the failure message could be a fuller sentence like > Given method "Foo.bar" is not a valid factory method
We can remove resultsIf() and argsIf() and use method.getAnnotationsByType(Result.class) and method.getAnnotationsByType(Arg.class) instead. If we applied this change, the following tests fail. - shouldErrorWhenSpecifyBothArgAndConstructorArgs - shouldErrorWhenSpecifyBothResultAndResults Those usages look weird, for sure, but we don't have to throw exception if we can handle them properly, I think.
personally I avoid names like o, i, l etc... Even obj is better. Also ... where is it used ?
While this fixes the reported issue, unfortunately, I think it needs to be more sophisticated; we need to examine the generic parameter(s) Map<String, Foo> should match Map<String, Bar> if Bar is a subclass of Foo.
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
The operator should be && not ||
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
done for patch3.
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
@pinaf could you explain purpose of these asserts?
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
have a default constructor with reasonable default values
for all the "waiting" items, I think we need to add "resource" otherwise people will ask "why am I waiting after I was queued".
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
suggestion return new PgClassTable.Entry( OidHash.relationOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name(), info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
..and if it does equal null do we want to put the view into a state that prevents erroneous manipulation (and further errors)?
this log seems useless, remove it
Unrelated change.
We should either use DataSize for these or add the appropriate unit in the log message.
I assume the 0xffff is to deal with the down casting from long to int and making sure that it's a valid positive value?
Let's create a new ArrayList and copy the attachments. If the "client" needs to alter what is in the attachments, that would be logic they would need to implement. A clone should be a full copy.
This is wrong map, one from change info and not one from revision info, that you need. The right one would be the code that you have removed: RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { NativeMap<ActionInfo> actionMap = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo> create(); }
i would add additional check to make sure we will never make it to more then 100 :)
@decarbonization: i think this should be Math.round(0.25f * temperatureScore + 0.25f * humidityScore + 0.50f * soundScore) coz right now Math.round(0.25f * 90) + Math.round(0.25f * 90) + Math.round(0.50f * 90) returns 91
Under what circumstances (given the validation you do) could index.equals(indexInterpolated) be true?
We maybe want to use ColorMode.HS.toString() in this case too - which is default and you do not need to set it.
tab can't be null at that point.
verify is probably more trendy
This effectively turns the flag to "false" but now we have an instance variable that is null even though the child fragment might still be included in the FragmentManager. That's a confusing state to have the variable in and maybe we should work on removing the child fragment (right here or elsewhere, on child fragment's work finish perhaps).
If we had sent some other Color command meanwhile, is it guaranteed that the state.getColorTemperature() is changed? What value does it e.g. take if I send a "green" to the bulb?
Remove
just reset to null
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Should this constructor one just delegate to the new one with Function.identity()?
I would prefer to avoid any dependency from UriComponentsBuilder on UrlPathHelper. The latter is more of a Servlet API specific component while the former is more general. Even if the re-use in this case doesn't touch on anything Servlet specific, it seems very minor and not worth the gain.
Ensure path is non-null
Args.notNull
Putting a method call to an overridable method in a constructor means that you can end up calling a method in an object whose constructor hasn't been called yet. This can lead to some very hard to debug errors. One way to avoid this kind of dependency is to make a field lazily initialized, e.g. in its getter.
What if we don't want to set it? How does the UI know that this has happened?
this if/else is equivalent to this.path = Optional.ofNullable(path);
Try using StringUtils.isTruthy(this.path)? <LINK_0>
If we want to match the old behavior we should probably use path.getFileName() instead of toString()
Why U don't want to consider id in equals and hashCode ?
Please remove the unused method.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
I think I'd rather store the instance as a field than to have to loop through the projections with instanceof attempts? You can easily store the EntityInstance during populateWithEntityInstance.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Most callers are assuming that this method returns a non-null DBCollection, so there's no point in having this check.
Log the conflicting classes found for easier tracking.
I think it should be NegativeLocationFilter (like the class name), as there is another class called NegativeNodeLocationFilter
Cosmetic. Extra space between BinaryObject and ).
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
You should output the session id in the message to aid debugging. Also, I would use this form log.error("An error occurred while removing session", e);
Do we need this else block?
catch throwable in activate method
@rvansa I think stop() should release all the semaphore permits. Threads trying to read from/write to the store after it was stopped should throw an exception immediately, they should not block forever.
Oh! I see the issue with that failed test. What was the reason to change it to generic Exception? From other side may be there is need to check the type of e and rethrow it as is if it is MessagingException ?
why are we changing the visibility of these methods?
This is where i think the connection would come into play: this.connection.getSenderSession()
Shouldn't we re-throw in this case? That is, catching RuntimeException is right, but this method throws Exception so we'll be swallowing a lot more.
This isn't right - it might be another thread that's running in an invoke. See invokeScope variable in rabbit template's doExecute
We don't need to cast to int.
checkState
Can remove the first clause if you change maxWriteSize to Integer.MAX_VALUE
You can reassign to offset, we don't forbid assignment to method parameters and in this case it's more readable.
I don't think you need this new flag. You should immediately return null from fetchNextReady() if the child has already been closed, which you can test with child.isOpen() or child.eos(). @jingjingwang do you agree?
You may want to say something like "Items per page limit cannot be..."
Use checkArgument instead to throw an IllegalArgumentException?
Can we please add limit to the exception message? So it will be much easier to see the problem!
could create a constant for -inf and +inf in JedisConverters.
Perhaps we should introduce a Null Object like: Limit.ALL or Limit.NONE to get rid of those null checks.
DoubleMath.isMathematicalInteger?
I prefer short log messages for events. Would suggest to change it to  return itemName + " changed from " + oldItemState.toString() + " to " + itemState.toString() + " through " + memberName;
final field to it's computed once and for all, as most values should be constants
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
Instead of string concatenation, better to use String.format("%s %d %d", ...)
.toString() isn't necessary. + will call it for you.
Printing the query as keys will look something like: ... keys=[IndexQuery.ExistsPredicate[propertyKeyId=0]]. I think it is worth extracting the actual keys from the queries and only print those.
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
StringBuilder, or Joiner.on(" ")... something
Should be public.
Should be public.
Should be public.
Should be public.
Should be public.
Should be public.
Should be public.
It would be good inline the logic of isConcatCall() here and use it to pull apart n into the bits you'll need and early exit if it turns out n isn't a concat call. Then the utility methods that do the work would take the pieces, which you could check the validity of with not-very-bright checkArgument() calls etc. This reduces redundant logic and improves readability. java Node calleeNode = checkNotNull(n.getFirstChild()); if (!calleeNode.isGetProp()) { return n; // not an array.concat() call } Node callTargetNode = calleeNode.getFirstChild(); String methodName = calleeNode.getLastChild().getString(); if (!"concat".equals(methodName) { return n; // not an array.concat() call } // etc.
Same here, I think it can be static.
pulling out n.getFirstChild() into a variable condition would make this and the code below more readable.
In fact, I don't think it's a good idea to allocate a Long. This function should be fast. Thus, a three branch if seems to be the solution. if (a < b) ... else if (a > b) ... else ... The domain trick works to avoid the "sign" hack.
can use org.apache.commons.lang3.StringUtils.isNotEmpty(value.textValue()) ??
Add parens on (value - 1)
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
Bug is here. You shouldn't have = here. Think about it and understand why this bug only affected negative test case, but not the positive test case.
vmIsDown() == true than vmIsUnlocked() == true vmIsDown() == false than vmIsUnlocked() will not be checked.
/s/verifyShareableDisksMoving/validateShareableNotMovedToGluserDomain() regardless i think that this check should reside in validateDestStorage() method
This validation should be in LiveMigrateVmDisksCommand since in this command we only move disks that their VMs are down (checkCanBeMoveInVm should verify this). LiveMigrateVmDisksCommand is the command that is responsible to move the disks inside a running VM
IllegalState?
This means I can no longer override the maximum time for an intermissions from the operator screen, which is often required when the schedule needs moving forward.
throw exception
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
As a nit, should have a null guard here.
Perhaps I am a bit slow, I thought these tests do clean up activities (like dropDataTypesTable) in the teardown method, and in the setup method prior to setting up the data (incase there was a previous failed run).
could use a better error message like "Failed checkForChrashes call" also could dump the stack with a line "e.printStackTrace();"
new String() is redundant.
Missing a blank after "if" If propertyToList returns empty list, check if (!includeLists.isEmpty())
This can be wrapped into another function for clarity purposes.
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
can you call it first, just for consistency..
This can be simplified to model.getCommands().addAll(uiCommands).
This is a status field. It should not be mapped from REST-API to Backend. The way that the user changes this status is by running activate/deactivate action. So please remove this mapping. The mapping in the other direction is ok (REST-API should show the status, so the status should be mapped from Backend --> REST)
potential NPE, please check if element was set before assignment.
this setter is no longer relevant, recompile the project so will be generated new setters/getters according to schema change
potential NPE on .getNetwork().getName(), you have also to check if network is set before using it
most part of this method could be extracted to a parent class. It could be called like this: setupNewVmModel(new UnitVmModle(new NewVmFromTemplateModelBehavior(template)); and than some specific setups, but not too much...
should be done via mapper of string->enum
This looks like a different and more severe issue. Shouldn't it have its own patch? And its own bug?
System.out.format instead?
Symmetry (throw)?
can these parameters be grouped into smaller and more meaningful objects?
Could you check for null or empty? Via StringUtils.isBlank
I think we can reuse GWTDateConverter java static String format(final Date value) { return GWTDateConverter.getInstance().format(value); }
![MAJOR](<LINK_0> 'Severity: MAJOR') Constructor has 12 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
It might be good to still show the IOException handling at the end to demonstrate the difference between FailedRequestException and IOExcepton. Though probably not explicitly required.
Why a new random per MergeOp? Why not make a single static final Random and reuse that RNG for all of the backoff?
Although the forward slash in this case is the same as SEPARATOR, they are being used differently. They are separating different content. I would undo this change.
true=>false
There is no point of having separate variable. Why not to use it directly in method call or even hard code it in pollWhileWaitingForTaskCompletion.
may want to externalise to constants..in a separate patch maybe? call it GEOREP_ROOT_USER or similar
I hate these additional constructors - just add it to the signature, and pass false in the places that call it. IntelliJ should be able to do this pretty easily.
that's unneeded..it will be false by default.
no! we need to stop polluting our code with overloaded ctors. There are just a handful of callers - just explicitly add the new false argument to all of them.
same here as well - on failure to stop vdo service, activate and move host to original status
but there's no reason to change this method now, no?
should be private. Also, move it below the executeQueryCommand() - it's not the "public contract"
Collections.emptyList().
I don't think we ever use this method again
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Move both to variables for consistency.
We could just always use the body instead of flipping based on the payload size.
suggestion
Same question as above, do we need the fully-qualified name?
![MAJOR](<LINK_1> 'Severity: MAJOR') Call "org.isPresent()" before accessing the value. [![rule](<LINK_2>](<LINK_0>
this duplicates code with RequestUtils and RequestMetadataInterceptor , we could extract this out by creating some method that takes HttpServletRequest as a parameter, returns a Map, then add the info where it is required
This can be rewritten as: java boolean exemptionEngine = request.getGatewayAccount().isRequires3ds() && Optional.ofNullable(request.getGatewayAccount().getWorldpay3dsFlexCredentials()) .map(Worldpay3dsFlexCredentials::isExemptionEngine) .orElse(false);  However, I wonder if we actually need this flag to consider whether or not 3DS is enabled. Presumably it's just going to be used inside the template and we can nest it inside a check that 3DS is enabled.
Wouldn't the usual request contain either the alternate base OR the variant type?
I think the code will be easier to understand like that: java Object object = getInstance(); if (object == null) { clazz = getConstructorOrMethod().getDeclaringClass(); } else { clazz = object.getClass(); } ITestOrConfigurationclassAnnotation = getAnnotationFinder().findAnnotation(clazz, annotationClass);
Use a builder method from TestNG Collections
we don't use braces around single line blocks
Maybe remove the package name as it is already in the import statements.
Can be simplified to: java return Arrays.stream(groups.split(",")) .map(String::trim) .filter(s -> !s.isEmpty()) .collect(Collectors.collectingAndThen(Collectors.toSet(), Collections::unmodifiableSet));
replace with List interface
replace with List interface
groups.isEmpty() is a little better
Any way to remove the cast here?
Its a bug this isn't Collections.unmodifiableList or something. Please fix it while we are mucking with the code.
@paulodamaso the braces and return are not needed here
@fanifieiev the same above.
@super132 please use Collections.emptyList()
@fanifieiev the same above.
@fanifieiev You can inline all this
@fanifieiev the same above.
@fanifieiev the same above.
@fanifieiev the same above.
you can use RsWithHeader(res, "Content-Length", length), will be better
@Bertram25 I think we can move contents of extend method in here now.
We only set thisReadSequence and mateReadSequence in the ReadHead, right? Why don't we have set(long uuid) for those kmers which aren't ReadHead?
for write and getActiveMessageFields, you can check if the lists are null OR if their length is 0. If either of those cases, don't write/read them.
At a high level this is what I meant.  java // member variable AtomicBoolean shouldRotate = new AtomicBoolean(); ... In the TimerTask shouldRotate.set(true); in save() if(shouldRotate.get() == true) { // do the file rotation ... shouldRotate.set(false); }
next time you can leverage switch case for ENUM
I'd prefer to require these be empty sets.
We should close the FileOutputStream, relying on finalizers is very finicky
This should have been:  this.out.close();
is the null check necessary?
I don't think the overall encryption strategy should be serialized into the files. The pluggable encryption strategy could change, and the current strategy should be required to be able to interpret anything previously written. So, I don't think it's necessary to serialize the name of the strategy here... but perhaps we should permit it some opportunity write some magic values/parameters that it (or its future replacement, if swapped out) could recognize?
Is there a reason to use getUNF() and UNF in the same block?
public?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
add this selector to UI mapping at the beginning
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
could metric == null?
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
why do we default to one minute everywhere? just get higher multiplier for travis, but don't make me wait one minute for test to fail (x 100) while i'm developing
Let's keep things reactive and functional and return either Observable<Void> or (preferably) Completable instead of void.
instead of reading first, then adding, can we just call add directly? The result of add will be true if it successfully add the new item, and false if it already exists. Then, if it didn't exist, we can "update" the metric value itself but setting it or incrementing it. I think if we make these changes, we can even remove the synchronized block from the put methods above.
Haven't looked at Cassandra metric client code yet - is this a remote call?
progress.addStage() is not required, progress already has it.
Looks like only IllegalArgumentException can be thrown from the method
Codahale metrics are typically a read only thing, I think we can certainly go this route but then we have a 1 value in all of Cassandra set this way and I would prefer to see us move to Virtual Tables than to work to refactor all our JMX MBeans. The JMXEnabledThreadPoolExecutor also already has a setMaximumThreads so this will be confusing.
Null comparisons can be replaced by UtilMethods.isSet(object)
All actions from
cannot **be** empty
It is the same in this line, leave a blanck space before "+"
Shouldn't we throw here?
Will queueSpinTake() ever return a null?
Maybe use constructor for this?
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
You should use perun.getFacilitiesManagerBl() to avoid creating unnecessary new transaction, this way you also don't have to deal with PrivilegeException.
Even for moved code: Should here not an exists() call added or on a local variable an exists() call executed? I would prefer last option.
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
"else if" maybe?
this requires a declared logger in ActiveMQRALogger and logger code
This could be made static
Weird sentence structure. Why not Illegal choice for parameter foo: bar?
What does "column name" refer to? The plan IR shouldn't have any references to column names, but should be using column handles, instead.
I assume this is a time value, let's indicate its units in the member and column name.
Do we need to handle BigDecimal as well?
use switch instead of if else?
Same as above. this is deprecated and should no longer be used.
This is deprecated, we should use MoreObjects.ToStringHelper(this) instead.
Should just be dimensionId, ToStringHelper automatically formats and uppercase keys look odd.
Change toString method to include both
tableScanSchedulingOrder
Should just be world, ToStringHelper automatically formats and uppercase keys look odd.
We don't have MoreObjects on 1.8, use Objects.toStringHelper instead
Maybe it would make more sense to use only omitNullValues() (and remove NONE) so that an empty TextStyle would be simply TextStyle{}
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
reuse getAcceptableTokens()
I am a bit confused that this check will be called on almost every line of code.
@romani Should it be possible to specify different naming conventions between parameters and lambdas? If so, this shouldn't be a required field, but be acceptable and default.
(not related to this issue) Should AutomaticBean issue a warning when a deprecated property is specified in the configuration?
This is super wrong. zzUnpackAction populates result.
Item dropped should be a hopper
Change this to == and I'll merge it.
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
I'd use DIST_SYNC here explicity...
verify(positions.length == counts[index])
Replacing "\" does not require regular expression, use replace("\\", "\\\\\\\\") or replace("\\", "\\x5C") instead of replaceAll().
Why is this needed?
input and expected output should be copied to test's input folder.
Why does the newline have three backslashes in front of it, but the other control characters only two?
Does this class exist by magic or ?
Why not use 'i' flag?
Please group mr, ms, and mrs together
This breaks the handling of Youtube URIs shared from the youtube app. These URIs are of the form <LINK_0> Didn't test sharing from the website.
Unneeded since it is in teardown.
same here, not best practice in normal code, but as a test its ok (or do assertTrue(first.isPresent()))
Use getSimpleName instead?
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Why do we print a secret systemUserPassword here?
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Seemed better before? More readable
For increasing stability "wait" is better to use than "Assert":  waitUrlStartsWith(testRepo.getHtmlUrl()); } private void waitUrlStartsWith(String expectedUrlPart){ seleniumWebDriverHelper.waitSuccessCondition(driver -> seleniumWebDriver.getCurrentUrl().startsWith(expectedUrlPart)); }
<LINK_0>
projectExplorer.waitAndSelectItem(PROJECT_NAME); projectExplorer.openItemByPath(PROJECT_NAME); projectExplorer.openItemByPath(PATH_TO_GO_FILE);  Can be changed to "ProjectExplorer#expandPathInProjectExplorerAndOpenFile(String path, String fileName)"
We could shorten a code if we will have the method: projectExplorer.waitVisibilityByName(String... names) projectExplorer.openItemByVisibleNameInExplorer(String... names)
need to remove downloaded package here
PATH_FOR_EXPAND > PATH_TO_EXPAND
it's better to divide action part ffrom and verification part of test by empty row to make test scenario more obvious.
Isn't there a condition we can wait for?
they should be "final"  final int timeoutToOpenInfoPanel = 120; final int timeoutToClosingInfoPanel = 2900;
It's better to localize exact single command which throws an exception because of issue.
could this hide bugs? Would it make sense to throw an exception or simply remove the check? Also because 0x0 is a valid code point this makes this return value a bit ambiguous. I'd be in favor of just accessing the array and let the JVM throw an error if this is possible.
this creates a hard dependency on the outer class and will make future refactoring a bit harder if you want to extract this class to its own file. Perhaps tokenSep should be passed or made a member of this class?
seeing this, I am a little worried that these checks are not always at the same abstraction level in the code. Why is it checked here at the level of the callee, instead of the caller as for instance in the Actor class? Not sure which version is better, also because I don't know how many callers these methods have. But, would be good if it is done somehow uniformly, if possible/sensible.
@xupyprmv it's better to use %d when printing numbers
Use [StandardCharsets.UTF_8](<LINK_0>
This loop will never execute as condition is >.
Does this need to be public?
I suggest providing a more informative message about which bounds were broken, how to avoid this message to be generated and how to fix it. At least message may contain min/max bounds we broke here. This suggestion is related to current message and all following exceptions
We'd have to work on this some more, I don't think we can just embed a constant in here ("additions" was different).
Should this create an empty bitmap if only one of the dims has no values? Should the condition instead be that all dims have no values? e.g., what if the predicate is (dimA == null && dimB == 'X)?
Hum seems we are already setting this listener
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
I'm missing the new field in the toString method.
public?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
scheduleTimes --> scheduleTime
Shouldn't we use setName() here?
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
nit: you can merge both lines above as checkNotNull will return the given argument
As for me, brokerConfig variable name would be simpler here
I generally don't have an issue wit bitshifts when they are actually useful but here it only obfuscates the code for people who don't know much about them
Sorry, I was thinking of this:  java private void handleBadgeResetPN(Bundle data) { if (data == null || !data.containsKey(PUSH_ARG_NOTE_ID)) { // ignore the reset-badge PN if it's a global one return; } removeNotificationWithNoteIdFromSystemBar(this, data); //now that we cleared the specific notif, we can check and make any visual updates if (sActiveNotificationsMap.size() > 0) { rebuildAndUpdateNotificationsOnSystemBar(data); } EventBus.getDefault().post(new NotificationEvents.NotificationsChanged()); }
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
trivial: you can remove the isDebugEnabled wrapper
not public
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
_cough_ You might want to remove the println. ;) FYI, you don't need to create a new PR, just make a commit to your branch.
let's just rename everything related to SubTitle to SubText
What do you guys think about setting this method to Evolving, at least for one release.
Can we weaken the signature to throws Exception?
...this change really doesn't make sense. > Changed off screen limit for unlocks to 1(on unlock it was 2 and once activity open it would report usage of all 3 fragments, so to add little more accuracy I moved to 1 off screen as on SoldierStats) Are you really considering to give the user a WORSE experience, just so that we can get a bit more accurate analytics? I for one would rather get analytics with a known misrepresentation (all three fragments) than a random misreprentation. Example in your current implementation: 1. User opens unlocks 1.1. Fragment A and B are downloaded (A=1,B=1) 2. User scrolls to fragment B 2.1. Fragment C is downloaded (A=1, B=1, C=1) 3. User scrolls to fragment C 3.1. Fragment A is cleared (A=1, B=1, C=1) 4. User scrolls to fragment B 4.1. Fragment A is downloaded (A=2, B=1, C=1) 5. User scrolls to fragment C because he forgot something 5.1. Fragment A is unloaded (A=2, B=1, C=1) 6. User scrolls to fragment B again 6.1. Fragment A is downloaded again, third time now (A=3, B=1, C=1) So, basically, what that would generate would be... three hits for A, one for B and one for C. How is that more accurate? If we load all fragments at the same time, we get one for each, which is a more viable representation. I'm just trying to make sure that we don't do stuff that makes the app worse for the users (and the experience). For example, I would rather look into if we can use the ViewPager "hooks" and send a "trigger" once we switch to a given fragment. That way, if we go from A -> B -> C -> B -> C, we'll instead notice that the user used fragment B and C twice, and A once. This seems both possible and more useful to me, instead of causing people to re-download information just because we're doing it wrong. :+1: @peter-budo
This method is only ever relevant for when writing snapshots and not used on restore. Therefore, this should always be the latest version, and not the read older version. suggestion return VERSION;
Can we use enums or constants instead of hardcoded numbers here? Also, making RAMP_STAGE_MAX protected should be good enough and avoids having this function.
do we want to make these abstract?
suggest configurable
nit: might want to rename it as signalShutdown or something to indicate that this method will be called before shutdown.
remove throws OseeCoreException
Should these all be final then?
remove 'driver' parameter (yes, a know you didn't write this line, but please change it :) )
I know its not your line, but please remove "driver" parameter. This parameter is not needed here, because screenshot is not needed in verification methods.
why is there "waitForCongratulationsLightBox " in PageObjectLogging.log, if you don't wait for lightbox? Maybe it should be waitForElementByElement method or in PageObjectLogging.log method should be "closeNewWikiCongratulationsLightBox" and "Congratulations lightbox closed".
Could consider removing the word verify from the logging description.
Could consider removing the word verify from the logging description.
click on element
As I see that in the other method, the parameter is also in the log. Consider adding pinDescription into the log?
if scrolling if not necessary, change to .click(), if yes, leave as is
please add space before {
These should probably be "verifyElementsOnPage". The logging seems to always use the complete method name for the first argument.
IMO it's better to use different values, e.g. 0 and 1 to be sure, for example, that the "delegated" method is not simply using the first parameter twice...
If your initial value is Double.MAX_VALUE, then this reset must be the same
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.
After having a look at the entire class, all tests require this to be present. Throw a SkipException here to automatically skip all tests in this class, showing the reason?
It might improve readability a little bit if the expected score was a variable instead
Package private constructor, rather than just public?
maybe you can set it here to some value and write a test in EventTypeControllerTest to check that header is actually set?
For sake of readability, I'd rather write that this way:  return Collections.nCopies(96, 0);
I'd suggest creating a private DeviceData withHourOfDay(int n) instead of copy pasting the same line.
use execute i mentioned above
replace (String) js.executeScript(script) with js.executeScript(script).toString()
use js.execute(script).toString()
please add line above to separate 'block'
Why asserting this?
you can use .toString() instead of casting
please use method directly, you don't need to store it in variable
before accessing it's property, wait for element
[JavascriptActions.scrollToBottom()](<LINK_0>
Do we need the toString() here?
Looks like both XmlTest and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
Two "parallel"?
let's call it updateCodeMinings() instead.
Pls, use InvokedMethodNameListener
I believe we can remove the try/catch wrappers. No checked Exceptions are thrown. Is there a particular Exception you are anticipating?
can we improve this by giving some meaningful exception message ?
if at all possible let's try to avoid introducing more mess:)
As far as I can see, this could be replaced with: return this.merge(level) == this; This could avoid duplicating information available in the mergeTable
why this change is part of this PR? Is that necessary?
Did you mean get(i) here?
Or even better, this.mName = Objects.requireNonNull(name);. To be check everywhere else.
Will this inject all instances of Task on the classpath?
Clarify doc. Returns a proxy not a real result set, and throws NPE if not initialized.
This seems a bit profligate... and the stream construction around a spliterator seems a bit unusual.
We always put "XXX is null" as the error message for requireNonNull
message
You don't need to create dedicated fields now. A reference to the receiverOptions is held by the class.
null check?
This will change once we introduce the method: suggestion this.indexSelector = new IndexSelector(getModifiedIndex(), indexStrategy, maxFlowDurationMs);
This seems to be changed by accident. summarizeTaskInfo is boolean :D
Why do we print a secret systemUserPassword here?
Oh yuck. ;)
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Update labels to go with method names. Alternately, call super.toString for super attributes
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Seemed better before? More readable
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
StringUtils.isBlank(nodeId)
Style-nit: We avoid curly braces on single statements.
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
you could just do setConfirmWindow(null); like above method
This could be confusing here. How the user know the all fields?
After discussions with @beeender, I believed we agreed that we need to catch all exceptions in callbacks from the OS and log them to logcat instead of throwing them, since it is close to impossible to make C++ terminate correctly for the Java session to actually terminate the app (instead of being swallowed in JNI causing other crashes). Also other libraries like RxJava have similar policies.
service id check?
Should we log a warning if the syncSession doesn't exist?
wouldn't it be enough that one of these is null?
Item dropped should be a hopper
Change this to == and I'll merge it.
The default should be updated to return 8 parameters to the test
final
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
Do these strings all need to include the escaped newline? Everything seemed to work ok for me if I replaced all occurrences of \\n with a simple \n? On a related note, would that change make the matrixAsString.replaceAll("\\\\n", "\n") lines removable too?
I wonder if it might be possible to format the matrices here in a more intuitive way? Something like the following (last row example): java @Parameterized.Parameters(name = "{index}: checking first row of matrix constructed with string \"{0}\".") public static Collection<Object[]> data() { return Arrays.asList(new Object[][]{ {"0", new int[] {0}}, {"0 1", new int[] {0, 1}}, {"0\n1", new int[] {0}}, {"0 1\n2 3", new int[] {0, 1}}, { "0 1 2\n" + "3 4 5\n" + "6 7 8", new int[] {0, 1, 2}} }); }  I find it a little easier to draw the connection between the input and the expected output with that formatting, but others might disagree...?
this for is exactly the same in all the array tests, let's move it to a private method
can we make this the conditional for the while loop?
I'd use DIST_SYNC here explicity...
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
should be setSucceeded(true)
return flagdown; ?
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
* shuoldn't we call super? * worth adding some log..
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
Comparing the effects of destroy. Previously this was invoked: java clearMapStore(); clearLockStore(); clearIndexedData(true); NodeEngine nodeEngine = mapServiceContext.getNodeEngine(); NativeMemoryConfig nativeMemoryConfig = nodeEngine.getConfig().getNativeMemoryConfig(); boolean shouldClear = (nativeMemoryConfig != null && nativeMemoryConfig.getAllocatorType() != POOLED); if (shouldClear) { storage.clear(true); mutationObserver.onClear(); } storage.destroy(true); mutationObserver.onDestroy(true); storage.destroy(false); mutationObserver.onDestroy(false);  Now this is invoked: java clearMapStore(); clearLockStore(); clearIndexedData(true); storage.clear(false); mutationObserver.onClear(); storage.destroy(false); mutationObserver.onDestroy(false);  So I guess that now, instead of conditionally clearing and then destroying twice, we now clear (even if the allocator is not POOLED) and destroy. Is this right?
Does it fire event only when it is changed to true?
The first argument can be random.
Why do we use iterators? I know the base class does, but why in the first place?
Get it from the model now that we have one?
I don't think this can return null. We should probably add an external annotation.
You could use a Multimap instead
I recommend using Collections.emptyMap() instead
Externalize
Externalize
you do not need the @NonNull
Externalize
not used yet, I think we should add some basic tooltips before merging this
Why the change? This is going to cause a memory leak if the SaveSmartLock fragment is rotated since it's a setRetainInstance(true).
I dont see any reason for adding this to string.xml. It is not really a string resource, it is more of an id. We wouldn't want this to change if we decide to translate the App strings later. A better way would be to move it to the Constants class.
Same here, better in the constant class.
I think that there is no need for a full package path as we already have import on the top of the file?
This should be done generically in BaseSingleFragmentActivity I guess, instead of needing to have the Fragments query the Activity's launching Intent extras. This would make the Fragments much more modular, as can be seen here.
Removing onPositionObserverUpdate() breaks the progress bar in the external player (it won't ever update)
Could we DRY up the first few lines from showProgress and hideProgress into some getActiveFragment method or something?
I think I put a bug in the OverhaulFragment where we should be using the child FragmentManager instead of just getFragmentManager(). Please change the ViewPager adapter instead: new NavTabViewPagerAdapter(getChildFragmentManager()).
I have mixed feelings about this. On one hand, this won't interfere with a conventional callback. On the other, it seems like really bad practice to start Fragment C from Fragment B and manipulate it from Fragment A or Activity. I would prefer we don't support this callback pattern. Is there another way we could fix this?
nit: isRecoveryEligible Is this only checks input? -- maybe isRecoveryEligibleForTableScans?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
The agg function here should be adjusted to support the optional compression param like in the quantile version
This looks like it would have different behavior from what was there before. If this is based on the path, I'd expect needing to go through getFormFilePath (the method that builds database paths based on whether or not scoped storage is used).
Doesn't work as expected as this message is never displayed, whatever is the type of media.
can you explain why this change ?
Why don't we set the certificationstatuses filter of the searchRequest here? Then the DB could filter the results rather than having to put the logic in java below
We are trying to remove the Globals class (in the long term). To facilitate this, could you please extract the themeLoader and preferences, and initialize them by passing the global objects as dependencies through the constructor (i.e. move Globals from this class to the caller)
should we have an "unsupported" status instead of successful? successful seems misleading to me.
Is this already protected by a lock?
How about to check whether workersToCheck is empty or not before notifying?
Does it make sense to set globalMinimumClock as 0 when workerClockMap is empty?
We are using snake case, so workerId should be worker_id.
What does rcvMsg stand for?
It'd be helpful to remind what's going on here, especially mentioning that _In case when a worker's local state is behind the globally synchronized state, this implies the worker is added by EM. If so, the worker is replied to continue until it reaches the global state_.
Let's explicitly check whether numBlockOwnershipByEvalIdForWorker contains workerId. Same for storeServerMetrics().
We use synchronized block when accessing *Params map. How about to use simple HashMap instead of Collections.synchronizedMap?
this is the spotbugs issue, you're building a new object but not assigning it anywhere
This log looks irrelevant to its location. You should move this line after L242 or remove this. Same for L272.
I would suggest that it checks the count of the entries to see if it increases one after the recovery happens.
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
Is this the recommended way in Karaf - do they not have an equivalent of JCA I wonder? I guess for the dummyxaresource it has to be this way but can we try a H2 datasource somehow?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Underscore looks a bit odd
shouldn't you rollback here?
assertTrue avoids the double negative
This looks like it would have different behavior from what was there before. If this is based on the path, I'd expect needing to go through getFormFilePath (the method that builds database paths based on whether or not scoped storage is used).
Shall we fail the test here?
java assertTrue(xaRecoveryModule.isPeriodicWorkSuccessful());  avoids the double negative.
If createParams should always have commonParams and commonServerParams, why not just define it that way to start with? And I think you could make the collection a static final variable at the class level.
why uniqueKey, be consistent call it keyField
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
Maybe use a logger ?
Not sure, why not use @NotNull?
assert.NotNull ?
I think you should be able to pass config in directly
i think you should be able to pass in config directly
pleass add @SuppressWarnings( {"deprecation", "java:S1874"} ) to method declaration
should we warn the client user that config.m_topologyChangeAware is ignored when config.m_useClientAffinity is false?
@cvrebert maybe MkIssueEvents.class.cast(?
this doesn't looks good at all :( let's log the exception using Logger.warn().
Please, add the opposite case  other.compareTo(commit)
@Iprogrammerr Please use IsEquals from hamcrest in these two assertions
@Iprogrammerr Same as above, use new IsEqual to these two assertions
@dskalenko yes - test confirming that only one suppression is enough to suppress - previously we needed two
Looks good, but it will work only once. If I run it twice, the second execution will fail, because a repository with this name (test-repo) already exists. There are two options: 1) generate a unique name on every test run, using RandomStringUtils, for example, 2) delete the repository after test execution in finally block. I would recommend to use both options.
I believe this is the cause of your failures as you are setting up a Java17 project which will be called TestSetup17project or something like that.
Extra space again
We could do one single fireTestFinishedFor() after the if statement I suppose. The docs say a fireTestFinished event should be executed for every fireTestStarted event.
Remove useless assert
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
This test is exactly the same as testPublishWithNullUsername. I think you meant to pass in a non-null username into resource.publish()
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
This line is redundant.
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
that class would be better with a builder, though I wouldn't ask changing it now
Use same order as the field declarations.
since we construct a default conf already, better to use it rather than call defaultValues.  internalConf = ClientInternalConf.fromConfig(conf)
Shouldn't we use empty list here ?
don't use finalize, it's a bad practice
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
can you enclose this in { } ;
"witing list" vs "waiting list"
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
trace
java LOGGER.info("Groovy console stopping...");
needs filling in :)
Why Level.CONFIG?
This check will be needed in case of every single widget button. If so it would be better to create our own WidgetButton class that will extend com.google.android.material.button.MaterialButton (then you can use it in your layout file). In such a class we can then override:  @Override public boolean performClick() { if (MultiClickGuard.allowClick(getClass().getName())) { return super.performClick(); } else { return false; } }  what do you think about this approach?
I'm not convinced that showing the context (Workbench, etc.) is particularly meaningful to most end-users and adds a lot of visual "stuff" that in most cases you'll train your brain to ignore? Plus when using a screen reader it causes that context to be read at the start of every command as you scroll through the list, significantly slowing down the time and cognitive load. At the very least, maybe an option to turn it off both visually and audibly? Or maybe it has more value than I realize.
Ah - guessing that we are using static Bugsnag everywhere to make this whole interface possible. Any workarounds you can think of that would avoid depending on the static class?
what's the intent of this change?
it means that subscription will be switch to the dead state and then will be returned back here to finish clean up state. it brings behaviour when subscription is switched not from cleanup to dead state, but from inside cleanup state we go to the dead state + all the things in taskQueue for execution will be executed anyway. does it make sense to clean the taskQueue, and add fresh task, if you need immediate switch?
user will definitely not need it, it is quite internal exception, which we could track in the logs
I believe that in case of any problems with zk unregisterSession() will throw exception, and client won't be closed.
why are you setting the same property twice? #Closed
Return Node from getRequiredContext and skip both the null check and the getNode conversion.
Ditto for this trace statement
use the constant defined earlier (moreover, aren't jdo connection options available from some sort of options class)
Could have @VisibleForTesting annotation. Also could public be removed?
Add this to WireMessages localization resource
one more method where it can take file location of properties would be good.
How do locations look like in Azure? These looks more like Regions? I mean, zones in providers are usually in the form: northeurope-1, northeurope2, etc.
As per the OAuth changes, these two properties shouldn't be required anymore, as they're specific to the JWT token flow used in Google Compute Engine specific.
Sorry, there is a bug in Foot and HikeFlagEncoder: can you use speed_bits and speed_factor instead of camel case here?
This has already been set before.
Minor: Looks like we calling addSSLProperties with null argument a lot of times. Can we just overload the function and call one from another?
This ignores the exception from fail("exception expected"), we should catch the specific exception ValidationException here.
Do we want to include data= (since it's required) similar to how we include connection= for SQL? It would also be nice if the cursor was placed at the end of data= (as we do for connection=)
I assume there is no suitable interface/class that could be used here instead of Object?
why does this test need to change ?
why does this test need to change ?
@dmzaytsev try to use org.apache.commons.lang3.StringUtils#join() here. It could be more visual
Put a new line in after every \n to make this readable. Or alternatively put the blueprint in a file in src/test/resources/path/to/file.yaml and load it with new ResourceUtils(this).getResourceAsString("classpath://path/to/file.yaml").
Also here it's still Image010 and in test above
We should also test what happens when you ask for it to compute here. It should return a,b,c,d unmodified since these aren't exact renames.
That's a bug in JGits merging. Somehow when we are doing content merge on last line we are adding a newline. To be fixed.
Should log text say guid instead of hrid?
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
Isn't that should be setWriteRate
Error message needs updated.
Creation date and last modified date should not need to be set here since the database sets them. You may need to mark them as insertable = false, updatable = false in the entity.
@rishabh-997 there is one in the application constants that convers this
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
Maybe this should use makeUnknown instead of getUnknown. I think the difference is that makeUnknown will create a new one, and the new one will have its own insert date and user. I think getUnknown will cause all placeholders to have the same insert date and user.
This will probably disappear when you rebase.
It looks like we need to modify ContainerAttributesResource to simply take a Map in its constructor. That way it's not only simpler, but it would also mean that all attribute values (including user-provided ones beyond those available OOTB) would be represented by the resource representation.
This will probably disappear when you rebase.
Can we rename from exonCollection to something more appropriate, like targetCollection?
Could this be delegated to one of the classes that deals with HDF5 specifically?(like **HDF5AllelicPoNUtils**) Seems like some other classes might want to use it too
Should we return true when file does not exists ?
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
(optional) likewise
Should we hard code file extensions or use a static variable from somewhere else?
why is this public?
isn't used...so perhaps do not set?
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
It would be a bit cleaner to construct the RealMatrix and check readMatrix.getColumnDimension() == numCols.
@ILikeToNguyen Why the change in visibility here?
I think it is not only the platform name. W3C defines a bunch of keys, which must be supplied without prefixes and Selenium has this list somewhere in constants
Should this variable name be updated as well?
I don't see clusterId being used in sync-job. Is this required?
Shouldn't it be key:value for cases where value != ""?
why not null as value?
![Codacy](<LINK_0> Issue found: [Local variable 'indexStatsMap' could be declared final](<LINK_1>
why do you use TreeMap here? Do we rely on the order of brokers?
How about getting a buffered reader from Files instead of a stream?
Not sure if this is described in any conventions (DDF or otherwise). @shaundmorris might know, but for consistency with the rest of the code (including this file) I think this should be at a warn level:  java logger.warn("There was an error while trying to access the application", e);  It looks like you're using warn for other exceptions so it would be good to have them all the same. This might be something different and more severe though, so if it is just let me know :)
can you explain why this change ?
Does transform need a null check here?
should we have an "unsupported" status instead of successful? successful seems misleading to me.
It might be best to add more context to this logging statement by stating that it failed to create the buffered circle from a point.
should we move line 339 to 333 (after the IF's closing bracket right before the catch)? Otherwise the intersects=true at line 336 will be overridden by the intersects operation at line 339 (which may also involve different geometry's CRS right?)
Throw a service exception in this case, indicating that the content of "clip" is invalid. Something like (untested): throw new ServiceException("Clip must be a polygon or multipolygon", "InvalidParameterValue", "clip")
This should be ActionParamsException since we don't pass the cause and either way that might not be too interesting.
Doesn't work as expected as this message is never displayed, whatever is the type of media.
might want to rename to "getExtent" or "getCRSExtent"
This looks like it would have different behavior from what was there before. If this is based on the path, I'd expect needing to go through getFormFilePath (the method that builds database paths based on whether or not scoped storage is used).
can't we just store filename = String.format("%s.%s", filenameBase, "values"); and not have makeFilename called in multiple places?
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Raw type; needs <?>.
Why call setScrollBar() twice? (L157)
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
It's good practice to use getters (like getPerunBl()) than directly accessing attributes.
Please catch GroupResourceMismatchException from conversion method here and wrap it to ConsistencyErrorException. Because on input, there is no group and we retrieve groups assigned to resource - hence from the same VO and there shouldn't happen any Group-Resource mismatch.
Why is it a list of lists, not just a list?
When adding members to group, VO is null and call createMemberCandidates() ends with null pointer in members manager impl layer. You should re-get VO from a Group and pass it to createMemberCandidates() since its behavior doesn't differ on VO and is expected non-null.
I guess checking, that group and resource are from the same VO, would be more interesting. Since when it's true, there is no chance, that member wouldn't be from the same VO as resource. Hence you should catch MemberResourceMismatchException thrown by conversion method and wrap it as ConsistencyErrorException. Then you can add explicit check on group and resource and throw necessary exception to API layer.
I'm not sure this is consistent with the rest of our API. Like this you always return all member-group attributes, even if caller specified eg. single group attribute in the outer API call. So you should probably check emptiness only on outer attrNames param and not on filtered values. But maybe you have different expectations for this specific method.
shouldn't this return at least the group ?
I don't feel confortable with this exception treatment.. but I don't see another option unless changing Handler.java to throw a specialized exception instead Exception which is out of this feature scope...
Be careful, this is not the same as "isMemberAllowed", because this will return also "disabled" members which are also not allowed.
Better use "member_group" naming consistently, since we have also "group" namespace and it's confusing, if it contains group attributes or not. So, something lik: memberGroupAttributesDef
- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
Calling cancel method like this will not actually cancel the task. You have to do this through task driver.
I'd make these numbers constants
should be tied in to the FileSystem instance lifecycle too: an FS instance should really have a weak ref to all leases created under it, and fs.close to stop them all
Definitely use parameterized logging here instead of string concatenation, because otherwise this method will be generating garbage objects on every call!
Once things get stuck, do we need the logging at every polling interval? Maybe use this <LINK_0>
What does description contain ? If it is very long, probably you can replace it with System.currentTimeMillis(). If it is short and concise you can ignore this.
This is not "error" level. It should be at debug.
I would do something different, if logger.isDebugEnabled() then print this message (in warning) if logger.isTraceEnabled() then print the full exception
TracheEnabled is not checked anylonger ?
I am a bit confused that this check will be called on almost every line of code.
reuse getAcceptableTokens()
@romani Should it be possible to specify different naming conventions between parameters and lambdas? If so, this shouldn't be a required field, but be acceptable and default.
(not related to this issue) Should AutomaticBean issue a warning when a deprecated property is specified in the configuration?
This is super wrong. zzUnpackAction populates result.
Item dropped should be a hopper
Change this to == and I'll merge it.
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
I'd use DIST_SYNC here explicity...
verify(positions.length == counts[index])
shouldn't we return a new or immutable copy of our internal list? just returning the list allows plugins to fully modify the list. @WonderCsabo wdyt?
I think the lambda expression could be passed directly to Comparator.comparingInt
That's good to know.
Although the returned Map is unmodifiable, the values are modifiable lists. Please change to:  public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotation) { return Collections.unmodifiableList(fMethodsForAnnotations.get(annotation)); }  (though I would prefer that the values for fMethodsForAnnotations to be unmodifiable lists)
...and change this to getAnnotatedFields(Class<? extends Annotation> annotation)
it would be nice to have toImmutableList collector. Airlift/Presto have one. If you have some time you may copy it from them :)
This AnnotatedType implementation needs to also override the following method: getAnnotation(Class<T> annotationType); Otherwise there is a mismatch between what isAnnotationPresent() and getAnnotation() returns.
Why this change?
should be wrapped in an appropriate SecurityAction
Could probably further reduce the duplication here, although the generics might get hairy.
Is there a need to have log.debug within transaction scope?
it appears that this change can be reverted.
also should be warning
Why do we need double logging here? One when logException is called and later in 101-102.
Since we never try to recover from the error later on it would be best to let exceptions be thrown from the init(). That way the ActionHandler is not available for use by the frontend and we don't need to check if the services are initialized correctly for every request on preProcess().
Do we need two debug logs here?
catch throwable in activate method
remove the unnecessary space, catch throwable
I really don't like the user of instanceof. Why not overload the method to recive VDSExceptionBase? In both places this function is used, you already have that information.
The stack trace should be sent to the log with the same level than the error message.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
return Collections.emptyList();
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Change to use Iterables.partition and return an Iterable
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
> That "TaskList" is copy'n'pasted from your method ;-) Oh, I see ;) Would you please correct both then?
wrap with unmodifiableSet in constructor and then just return field reference from get* methods.
Do you want distinct or distinctUntilChanged?
please decrease severity to "debug"
just wondering, w/ slf4j do we still need the custom format() ? I hope/think that's done by the slf4j logging library
lets use loggers
for logger.info, partitionName is same as message.getPartitionName
Use guard conditions to deal with the low hanging fruit first. It reduces the complexity of the execution paths.  java if (!confirmNewBoardCreation()) { logger.info("New board creation cancelled"); return; } panels.closeAllPanels(); onBoardSaveAs();
@maria-farooq with the current implementation the requestee will always be null. Shouldn't we protect the code for this?
log exceptions at ERROR level.
What I meant is that we can log something like "Force triggering a callback for the new listener" here. So the log does not care about the name of the parameter "isTriggerCallback".
List
This looks like a help string that really is intended to go to stdout
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
Init should only be called one single time when constructing the controller. That is done in OnStart. Please add a space between if and (
no need for an ArrayList
No need to put before/after annotation since the class is extended from TestCase, We can simply remove the inheritance from here and use the annotation, I favor annotations over inheritance in test. Don't remember why I've extended it at the first place
Result.SUCCESS
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
In separate line ?
If you instantiate a DefaultUserStatusListener then you could omit all those empty methods.
Good catch -.-
Nit: Private method can be made static so therefore probably should since it makes lack of side effects clear.
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
add this selector to UI mapping at the beginning
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
suggestion mapper.orElseGet(ObjectMapper::new).convertValue(this, new TypeReference<Map<String, String>>(){});
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
Encapsulation
suggestion recommendedLayout.keySet().retainAll(newServices.keySet());
Don't we have to say that this is uniqueId JDBC?
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
same with return here
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
use return ... ? ... : ...?
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
use constant for UTF-8
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
This restriction only applies to the event name and parameter name. Parameter values can be any string, long, or double.
Rather than hardcoding this string path, shouldn't we be using ExternalSourceRest.CATEGORY and ExternalSourceRest.PLURAL_NAME?
use QualifiedName
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Let's create a new ArrayList and copy the attachments. If the "client" needs to alter what is in the attachments, that would be logic they would need to implement. A clone should be a full copy.
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
also, at this point in the code, the plugin is not loaded, only PluginInfo is read from the jar metadata (correct me if I'm wrong). The loading actually occurs on line 74. The log could be misleading.
suggestion return new PgClassTable.Entry( OidHash.relationOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name(), info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
We should either use DataSize for these or add the appropriate unit in the log message.
I assume the 0xffff is to deal with the down casting from long to int and making sure that it's a valid positive value?
Unrelated change.
Did you try running the integration tests? These might kill the integration tests.
This is wrong map, one from change info and not one from revision info, that you need. The right one would be the code that you have removed: RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { NativeMap<ActionInfo> actionMap = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo> create(); }
I would add a check here: if the ID contains the suffix, throw an IllegalStateException or InvalidParameterException, otherwise, there's a chance that you'll have an ID like abc-client-client, which is never appropriate.
You could probably use the same URL as in getResultById here.
This is not needed anymore... now you can just return id
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Should we check if address is empty before return? Or compute address like before when address is empty?
Add "this" qualifier
Just noticed, you should have an @Overrides annotation here.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
not all listener
not all listener
not all listener
not all listener
rename
Darn, I had overlooked that. Might be worth creating package org.eclipse.egit.core.internal; public final class SafeRunnable { public static void run(Runner code) { SafeRunner.run(code); } @FunctionalInterface public interface Runner extends ISafeRunnable { @Override default void handleException(Throwable exception) { // logged by SafeRunner } } } Then we could do here simply SafeRunnable.run(() -> listener.indexDiffChanged(repository, indexDiffData));
I'm sure those are not all listener ;) 'l' would be enough
You could use Void instead of Object here to make it clear what the intention is.
rename
rename
@erikdw MESOS_SANDBOX is set by Mesos correct? Wondering if we should override System.getenv("MESOS_SANDBOX") with logdir only if storm.log.dir is configured?
unecessary test : less is more.
Returning the process seems really weird to me. I would make the method void unless there's a good reason otherwise.
do we need setupStreams()? Also, return;
No need for this.
Platform specific code should be isolated into scripts like unix-kill.sh etc. (prefix + "kill" + extension)
would this have been a different exception without the \u0000 ? (i.e, because "command with.." doesn't exist..) for avoidance of doubt, could we use a command that does exist ?
This should use Assume to correctly skip the test.
should be renamed, is also used for opens.
this is a failure to build the image not start it.
Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.
new AssertionError -> new UnsupportedOperationException
As this operation is optional, just say it won't be supported because it's not mandatory.
Instead of "Not implemented yet", I would suggest "Iterator is read-only"
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
So we lose the typing on CacheContainerAdmin, should we define that on this method or as a generic on CacheContainer at least?
Could you please make the exception message more descriptive?
Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.
This doesn't strike me as reasonable. Just add a field for it and call set :D
Should the override annotation be on a separate line (not sure of the convention in this codebase)?
Lol! You're going to remove that, right :)
do not assing parameter! nowhere!
Optional<String> ?
Summary: 1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(<variable> == null) {. 3. Add a space between if and (. Should be if (<variable> == null). 4. Add . (full stop) at the end of "... is null" -> ... is null. 5. Do the same for the other methods.
Summary: 1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(<variable> == null) {. 3. Add a space between if and (. Should be if (<variable> == null). 4. Add . (full stop) at the end of "... is null" -> ... is null. 5. Do the same for the other methods.
The else is unnecessary, the above returns (same for the following else).
-1 The jgroups-channel and jgroups-stack does not allow expressions in the new messaging-activemq. We can not copy them. We can neither resolve them before copy because there is no guarantee that the resolved value on the DC would be similar to the resolved value on any domain servers.
What happens if you just remove the project from the sharing ? I guess there will be inconsistency warnings and I think there is also no broadcast.
suggestion if (hasVersionProperty() && hasSeqNoPrimaryTermProperty()) { logger.warn("Both SeqNoPrimaryTerm and @Version properties are defined on {}. Version will not be sent in index requests when seq_no is sent!", getType()); }  We can remove then the duplicate warning from line 254.
What is the use of this empty line?
This can be java return valueOf(value.toUpperCase(ENGLISH));
nit: Unsupported byte value ' + value + ' for row kind.
You could save a few lines by moving the return null into the default case instead of break.
This case is the same as default...
Why are we casting thiis to a timestamp?
Same suggestion here about consolidating like cases
It should be new TajoRuntimeException(new UnsupportedDataType(...).
We may want to handle this to IllegalArgumentException, and change above forEach to catch IllegalArgumentException and wrap with SchemaValidationFailedException. Bubbling up NullPointerException or IllegalArgumentException to the REST API response would be bad for end users. If you just want to ensure denying null, I'm OK to leave it as it is, and I could handle it.
Please avoid changes unrelated to the actual improvement we're trying to fix.
why not use [Decimal123.parse](<LINK_0> instead of the BigDecimal?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
You could probably use the same URL as in getResultById here.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
I think the annotations should be on separate lines
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
Maybe for cases like this where the list is only consumed once it would make sense to add a mapLazy that is based on something like this: java static class LazyMapList<I, O> extends AbstractList<O> { private final List<I> list; private final Function<? super I, ? extends O> mapper; public LazyMapList(List<I> list, Function<? super I, ? extends O> mapper) { this.list = list; this.mapper = mapper; } @Override public O get(int index) { return mapper.apply(list.get(index)); } @Override public int size() { return list.size(); } }
As I said in #1208 : In driver 4.0 we don't have any specific exception for codecs except CodecNotFoundException. When a codec cannot serialize or deserialize something, we use IllegalArgumentException. I don't think you need to introduce a special exception in these examples.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
I would only create a different exception if the request returns a 404, otherwise, I would not catch this exception.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
SpScheduler already does that in SpScheduler.shutdown(), you just need to offer a null task to MpScheduler. MpScheduler owns m_tasks which can be used to offer null task.
Could move this also into the if brach below, so that it is not created for KILL ALL
I think the 3 catch clauses can be combined for clarity.
![MAJOR](<LINK_0> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
final?
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Seen proxies before that didn't parse multiple entries on a Cache-Control line. Do we need both, or can we just use max-age?
NB: no-cache is a value usually found in requests, not responses. I'm not sure of the effect in this case. To be on the safe side, I'd update this to read private, max-age=0 instead.
Why not in-line 'enc'?
Worth doing a flush here as well?
@fanifieiev the same above.
This seems to be a recurring pattern. Should we pull up into an abstract parent and then let subclasses merely handle serve(req,res,true/false)?
It seems like this would obscure any error returned by the server (body().getError()). Do you think we should throw IOException(body().getError()) in the case where body().hasError()? (ditto for RbPageService)
Isn't this backwards? :-)
Use a pattern like this to populate the plugin array in HostPageData dynamically on each request. That means we will always be writing some portion fo HostPageData dynamically, so you may want to refactor this entire block a little bit and forget the page.full block in the else here and always use concat to build the 3 sections of the page up.
I think we need to check validation of the state transition diagram. Let's handle it in a separate issue. Please create an issue for this.
please move the isEmpty methods to the scimSchema
let's call it updateCodeMinings() instead.
This could be confusing here. How the user know the all fields?
Don't think items can be null, and ArrayList (as well as List and Collection) has an isEmpty() method itself...
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
small thing - filterList.isEmpty() is shorter
can we improve this by giving some meaningful exception message ?
Could return ModuleType here per @ghillert
this looks wrong to me. We already have visitors elsewhere which check the correct information about the autoincludes and add an "imports" statement.
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Is this reload really necessary?
Switch order and as well in other similar cases.
Please close client at the end.
Is restart necessary here? Even the check takes some time in the test run...
If resources are not dependent on each other, reload after adding isn't needed. One reload after adding endpointConfigurationAddress and one after adding both preHandlerChainAddress and postHandlerChainAddress should be enough.
Are consecutive reloads necessary or will be one reload at the end sufficient?
These 2 conditions can be merged into 1 condition
Please call this one time and also check only one time.
This line can be combined with previous line.
Please make this a string resource and change it to "Unable to display nearest place that needs pictures without location permissions".
Seems that empty elses are generated now (at least in Java)
Yeah or risk of memory leak?
Soft suggestion: UnsupportedOperationException could be more suitable in this context.
how about "Object with pid: \<pid\> cannot be added to destination"
<LINK_0> Let me know if you have any issues managing or adding items to the project
how come we are not using the username and password here?
upt.unifyGraph(graph) is double code. Better use this structure: new ReferencePositionTraverser(reference).referenceMapGraph(graph);. The graph = isn't needed.
same for thos changes
assertThat(graph.getEdges()).isEmpty() looks better
I don't like that we're setting it on the CheckpointConfig that the user gave to us. I think it's in general not good that we just pass this through but now is the first time that we modify it here, I think. Maybe we should do an internal copy of the checkpoint config and then we can modify it?
Why is this change necessary?
The status of the prototype has to be "new", draft is the first status that the editor can apply to a content
We can return the json string of oAuth2AuthorizedClient, and output json string in logAuthorizedClient.
I know this is old, but I've often wondered what the effect of this is on the overall process. Might be worth adding a little more context to the warning. Thoughts?
hmm. perhaps better to add getNodes and getEdges methods to Graph and then use getNodes().stream() instead of the clunky range(0,7)?
rename: addNoticeAssignments
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
A little wasteful when all you need to do is just set the fields and return this...
BlockPos.ORIGIN
It might improve readability a little bit if the expected score was a variable instead
What's the point of the 6 trailing zeros ?
Revert
Package private constructor, rather than just public?
We normally put private methods at the end
For sake of readability, I'd rather write that this way:  return Collections.nCopies(96, 0);
I'd suggest creating a private DeviceData withHourOfDay(int n) instead of copy pasting the same line.
s/policies/policy
Use getSimpleName instead?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Why do we print a secret systemUserPassword here?
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Seemed better before? More readable
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
why object? lets change it to the particular time we expect to receive so we could catch potential failures here
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Should we check for systemConfig.isOutdated() as well?
Consider using getField() instead, ~~it's implementation in OpenJDK 8 seems more performant.~~ Also the semantics of that method apply better in this case, since it is a public field. _Edit: can't confirm first claim_
Extract this try-catch block to a method to avoid code duplication
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
You should use multi catch in here to make all of these catch blocks be just one line - much cleaner. Or since you are simply wrapping the checked exception in a runtime exception, perhaps you want to simply catch Exception, and rethrow it as RuntimeException. Please read here. <LINK_0>
This is strange, I don't think we can get constraint violation for relationships when setting a property? When removing I guess we could violate a existence constraint, but that's anyway not checked until commit. In general it feels like here are way more catch clauses than necessary...
Should we break the for-loop early if the condition is not met?
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
in the case where the Bytes object is immutable, it would be nice to store this after computing. This way it does not need to constantly recompute for case when Bytes are used in hashset.
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
if the advantage of this compare to 0 <= b && b < 256?
I would retain the existing indexOf body to to avoid indirection in the most common case.
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
with 10 threads I can almost always reproduce the bug.
Style nit: int i = 0 (missing space)
maybe extract function getExpandedRow() ?
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.
suggestion return stage.thenCompose(ignore -> awaitQuiescence());
+NonNull for return type
Nitpick, but if you made this have an else block you can remove the thenCompose lambda allocation.
Unnecessary, can remove.
use simple thenApply(...) instead.
return Collections.emptyList();
Same question here: no start and end, means only one continuous, never ending pane?
Change to use Iterables.partition and return an Iterable
Can't we use containsKeyAsync?
entry
entry
entry
entry
entry
Try to fill more of these methods bodies by copying ideas from that pull request or even the classes i pointed you to in the ticket description.
rename to entry
Can you look at the resource test i pointed you in the ticket description and then put some thing in these method bodies? You can even just copy some ideas from the pull request i pointed you to done by one of your team members.
Here can you assume that the value contained in uniqueId is the internal integer id and hence fetch by it?
Which exception has been observed here? Please don't catch exceptions when we don't actually know what they are.
delete
Use [Bundle.putInt(String, int)](<LINK_0>,%20int)) instead, no need to serialize a base type.
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
Use a streaming version here
Hi Amos, Its probably worth doing a begin/commit on the transaction here too, just to check the reference is valid even though we know its not null
I don't think we should muck around with this in this part.
Bundle state checks are best written as bit mask tests. java if ((host.getState() & (Bundle.ACTIVE | Bundle.STARTING)) != 0) {
Here you are using synchronized for the queue handling, but you don't do it below if you add something to the queue.
can you formatted this expression? It is tricky to read. Please write every operation on a new line.
directly return
here we'll also have changed from ConfigException.BadValue to IllegalArgumentException I think; a toBytes that takes the origin/path could solve.
should this filter out null resources? (ie. bad paths)
Should this constructor one just delegate to the new one with Function.identity()?
Set.of(...)
Bad format. You can probably remove the brackets here ;)
Putting a method call to an overridable method in a constructor means that you can end up calling a method in an object whose constructor hasn't been called yet. This can lead to some very hard to debug errors. One way to avoid this kind of dependency is to make a field lazily initialized, e.g. in its getter.
remove else
I would create a private static checkArgument method for these checks
Args.notNull
Do we need to make sure these file names are also Windows-compatible? If so, we should include a few more characters to the list. - Linux/Unix: / (forward slash) - Windows: < (less than) > (greater than) : (colon - sometimes works, but is actually NTFS Alternate Data Streams) " (double quote) / (forward slash) \ (backslash) | (vertical bar or pipe) ? ( question mark) * (asterisk)
Codacy found an issue: [Use explicit scoping instead of the default package private level](<LINK_0>
style guide
previous naming was more clear.
Double* variant of this class uses object == null ? null that is better
remove redundant ; it will only cause static analysis to complain
From the code of extractValue(), it could also be Memory.
public @Nullable String...
suggestion + "NoncurrentVersionExpiration, NoncurrentVersionTransition or Transition) must " + "be specified in a rule");
save the null check - use "".equals...
Default should be false
Default should be false
It could be useful to factor out this constant, which is also used by org.nuxeo.connect.client.jsf.AppCenterViewsManager.shouldValidateStudioSnapshot
Default should be false
When migrating isBooleanPropertyTrue  the default must be false.
If the value was blank it used to return false, now it returns true.
I'm wondering if we can do something to simplify these very long expressions.
- should we use pushInlineDeployments here ? - use of deployContrib with a test contribution
Wouldn't it be more efficient to track the case of the first character then break and return false on the first occurrence of the other case? Saves iterating the rest of the character sequence if it has mixed case.
How about just commandspy?
return Promise just to symmetric with start()...
Should this also set engine to null in a finally block? If not, I'm not sure why it checks for null (line 177).
Need to check those variables are initialized or not to avoid NPE.
After shutting down the Executor, we should explicitly set it to null which is more friendly to the GC.
What's with the suppression? Also what happens when you call shutdown twice?
you're right, not sure how I missed that thanks!
see in Volt how to properly shutdown an executor service
is it intentional to not have the suthdownLatch.countDown in a final clause? Current behavior is for server to keep running in face of error and for awaitShutdown() to continue blocking (i think). Not sure if this is intended behaviro or not.
shut this down first. General rule of thumb to follow - whatever starts last shuts down first. Otherwise, stores may shutdown and stats manager can still be calling getStatsSnapshot()
this can be null if start() is never called but shutdown() is. Also, is the cluster map created even if getClusterMap() is not called?
This method is no longer waiting for the refresh operation to complete. Not sure if that is important for the test flow or not.
I would prefer IllegalStateExceptions in such cases.
This will NPE if BundleRevision.getSymbolicName() returns null, I would reverse the equals target to be symbolicName.equals(bundle.adapt(BundleRevision.class).getSymbolicName()) This does not scale well if you have large numbers of bundles. If this is a hotspot of your code you can consider using org.osgi.framework.wiring.FrameworkWiring.findProviders(Requirement) using an "osgi.identity" namespace requirement. If I recall correctly virgo uses Equinox regions. That can end up hiding bundles from a BundleContext perspective. Using FrameworkWiring.findProviders would bypass the equinox region hooks so you need to be aware of that.
bundles.size not logged
Use ImmutableList.Builder to construct a new collection.
We might be able to fix the smoke tests if we filter for resolved bundles and avoid refreshing these if they are already resolved.
"your _thing handler_" doesn't make sense then, right?
this should already be T so no cast necessary later
Please use #0, #1 as variable substitution
why ConfigurableApplicationContext, not ApplicationContext?
This will probably be permanently unsupported.
MemStore is used for tests, so we need to implement this function.
This should be implemented for consistency.
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
Don't we have to say that this is uniqueId JDBC?
In my opinion, we do not need this log. WDYT?
Local variable could be declared List instead of ArrayList. Is this worth caching?
unnecessary default implementation
Eh, use TreeMap here. There are only a few tables with broken primary keys. It will make more sense to process them in name order than in a random order implied by the hashing function and the hashtable's internal structure.
should return false if the validation fails
You can remove all the following code: if (!(.... return false; } return true; With simply : return super.canDoAction() && canRemoveVm()
We should also check the servers which we want to update the hook content is in UP state.
this should be in super as well.. even first
using command line user can provide a wrong id (say, by mistake), so its better to check for getVdsGroup() == null here as well
How about the user trying to enable a hook which is already enabled? Also if there are no up servers, command should fail
you are calling super.canDoAction twice, i guess here it should be return true
ACTION_TYPE_FAILED_GEOREP_SESSION_ALREADY_RESUMED
Volume should be UP for fetching advanced details
needed?
The operator should be && not ||
done for patch3.
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
The exception message doesn't reflection reality:  "no query or collectionCallback is specified"
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
have a default constructor with reasonable default values
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Please keep this.cell near the related fields (previousFamily & cell count) below
for all the "waiting" items, I think we need to add "resource" otherwise people will ask "why am I waiting after I was queued".
please use (1 << priority) instead of priority + 1
This can be static.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
I'd add an always-printed log message here too to make sure it's remembered.
I don't see clusterId being used in sync-job. Is this required?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
This could be null, we should probably handle this if the JIRA api changes again
String key -> String columnQualifier, and also update its subclass
as this isn't static, you should use lower case cache
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
looking at the gson code base, remove also could return null if element not exists hence we might want to guard aganist NPE here as well.
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
Better assume immutable parameters. Don't modify references to an input variable.
return null to make this more explicit ?
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
They are mutually exclusive? Or is that a micro optimization?
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
I think we can avoid this .INSTANCE. business by putting the fromV1APIJson method inside a companion object.
We mix two different comparisons styles here: "expected".equals(actual) vs. actual.equals("expected"). I would prefer to use the first one only as it is NPE safe.
Can be simplified as: return Strings.isNullOrEmpty(valueInEnvironment)? getPropertyValue(properties, defaultValue, property) : valueInEnvironment;
System.out.format instead?
Don't you think there's a need to add a constructor with final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier
we never use NULL, it is a bad practice in general.
![MAJOR](<LINK_0> 'Severity: MAJOR') Constructor has 12 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
can we define these as CONSTANTS? do we have these contants defined in stack in another placem so we can reuse?
These implementations are fine, but I wonder if the code wouldn't become a bit simpler if the defaults were stored as String values, and instead of the parameters.containsKey(String) you would do something like: return EventLogCategory.fromValue(Helpers.getString(parameters, PlatformSmartmeteringKeys.EVENT_TYPE, DEFAULT_EVENT_LOG_CATEGORY)); as a one-liner.
I would prefer to use String.valueOf(value)
I would prefer to use String.valueOf(value)
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
we never use NULL, it is a bad practice in general.
suggestion return format("metadata[%s]", key);
you should probably cast to a string or call toString also could be shortened to return (String) get( key );
Log in logger, not just print in console.
Any reason for prefering KEY_MAP.keySet().contains over KEY_MAP.containsKey()?
It seems more appropriate here to throw an error so the user knows what happened. Otherwise they just get an empty list with not indication that something went wrong.
inUse is set twice in this constructor
unnecessary
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
Maybe extract this if-else in a method like createResponseHandler(Logger), otherwise it is duplicated in both constructors.
We create a new map-operation for every call, so moving evictions here doesn't make any difference.
I suppose make it private and create via static method. To make it easer to support compatibility in the future)
unneeded if clause
Missing an argument
3 days of hollidays, and I do not remember the way the messaging works. Do we have one listening thread per application? I will take a look at it on tomorrow.
Calling this in finally means that the flow status may not have been updated properly... is it wise to do it in finally *and* still rely on flow status to mark the right metric?
remoteVolumeName passed twice. I feel remoteHost to be passed as second arg
Instead of catching NullPointerExceptions, it's better to check if session.getRemoteAddress() returns an object (and only call .toString() in that case).
Would this method stop the rebalance as well? I can not see stop call here.
@Override
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
a matter of test - but the return value can be inlined here
I think Boolean.valueOf() is redundant here since it's a primitive field, don't you agree?
I think you should put the volume id in parentheses after the volume name
is volumeName optional parameter?
You probably want to measure non force and force separately right otherwise the histogram would be incorrect as it is measuring both metadata fsync and non-metadata fsync (fdatasync) right?
Can you just change the return type of this method?
Shouldn't this be member? I think there are a bunch of places below where you have it as session, too.
Should this be false or true?
Change this to  java Member me = (Member) session.getAttribute("member"); MemberDao memberDao = new MemberDao(); me = memberDao.getMemberById(member.getId()); if (me == null) { return "redirect:/denied"; }
Like above, using the absolute path should accomplish this properly
Style issue: @Override shuld be on line above the method declaration
Ok now that I reread the final code I think we can keep the old name getChildrenIds, as the new method with the "exclude" args is distinct enough. Sorry about changing my mind several times. Also applies to other getAll* methods we renamed...
I think it's impossible for people other than the team leader to be on the team at this point, so the loop should be unnecessary
Is this the same as the one above?
minor: you can return Collections.emptyList() instead
Just want to double check that the following null check is correct:  if (mScrollDirectionListener != null) { mDetector.onTouchEvent(event); }  I think yes, since mDetector is always not null, and it fires updates on mScrollDirectionListener.
why are you using getAdapter() and not directly mAdapter?
why getAdapter() and not mAdapter?
Generally agree + good find. This method probably should return false to indicate that we have not handled the event. <LINK_0>
@manuelplazaspalacio I have a doubt here. This Listener is in the main and affects also the rest of the variants. returning false wouldn't it make the rest of the variants to stop working? The feature I'm concerned about is the previous/next swipe in Laos, for example. I guess that we would need to create a Strategy here, moving the common behavior to a common method and separating the difference into a per-variant answer?
Can the plugin manager listen to the event bus, get the event from the bus and use it? It might be able to get access to other types of events as well by listening to the bus.
There's a lot of code in here concerned with the Slider. I think it might make sense to try and extract a custom view to handle all this. Maybe a RangeSlider?
probably just to be a little more defensive we could put this call just after 'super()' call since we want to treat EntityModel as our ancestor (as was before)
later we can switch this in order as ifs are short-circuiting and the traces will more likely have the second option.
This call will make Jenkins to create a user even if a bogus security realm didn't load/report it properly. It is not a big deal, but I would recommend to get user without creation and use if (u == null || ev.equals(u.getFullName())) in the next clause. .
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
Since the varargs parameter of String.format(...) is of type Object for which toString() will be called if non-null, it's a bit safer to do the following in case the key schema or value schema are null: suggestion return String.format("<SchemaPair: %s, %s>", keySchema, valueSchema);
Should we just use MoreObjects.toStringHelper() for this?
Should this method be final?
This should stay final
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Can you add the case of the constructor with String parameter?
this does not handle the empty 'lists', it will throw an exception
This is already done in the other method.
Why are the problems not enough?
This would not be a performance improvement. (And a tab character has appeared in the file.)
Simpler: ArrayList<T> result = new ArrayList<>(collection);
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
save an iterator by using index loop?
This makes it technically possible to break usage of this method. (Calling it with a class that is not a Frame). Is that what you really wanted to do?
why is this return null??
Unnecessary Optional wrapping. Replace this code with:  java for (Map.Entry<Node, Optional<T>> entry : result) { return entry.getValue().orElse(null); } throw ClusteringServerLogger.ROOT_LOGGER.noResponseFromMaster(this.context.getServiceName().getCanonicalName());
This should follow the normal exception handling path and let the caller handle the printing of the exception.
To avoid confusion, rename the variable to sessionId.
Missing the substitutions for the {}'s. suggestion LOG.error("Failed to parse value of system property {}='{}' to an integer. Using default value.", sysProp, val);
Too much nulls in arguments, please make variable content = null and use it in constructor. Please apply the same for all other test method you changed
entry
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
wont this be a breaking change removing the old api's if anyone is using CORE api directly? I appreciate its hidden for JMS users.
I can't believe a method with so many parameters exists ;-)
Use Local variable start time created on top instead of new Integer(0)
Is this local variable used?
So, if the xpath query matches event than this method will return true, right? Than the event will be propagated to TreeWalker. This java if (!filter.accept(event)) {  will be evaluated to false and the message will not be removed from the set. Thus, what is the sense of the suppression? What do you filter? Look at testMatching. The user writes the query /CLASS_DEF[@text='InputSuppressByXpath'] in order to suppress the violation, the filter should deny the event, but your filter will accept it.
we should only handle non-transient values, or?
@prondzyn Let's use UnsupportedOperationException instead, to avoid importing from commons-lang library.
If you run checkstyle, it will complain you the access modifier order. You should do public final instead of final public.
@dmzaytsev ThreadInfo can read currentThread in Ctor, no need to pass static
I thought there was going to be a separate monitor for this CM integration descriptor, the handling of which would be contained in the cm-integration module.
didn't you want to in-line this asWildcard() call ?
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
this is the spotbugs issue, you're building a new object but not assigning it anywhere
This is an overloaded method, why change the name?
Please use assertThat (result, failsWith(NAME_OF_FAILURE))
You can make this method private
we should not care about LOC metric. We should care about expressions without side effect. ~~ Ideally if test should not have modify anything, unless actually needed. Please update result variable, and only after that proceed with testing it.
We actually don't need this line at all. The test check something else
run already called tally, so do you need to call it again?
I think lowercase l should also be considered
Missing finals
That should be toHtmlForAnthology. You mixed those two up.
At this point I would just return allDomainsHaveSpaceForDisksWithSnapshots.
Use a JUnit assumption instead so that the test is properly marked as skipped.
StringUtils.isEmpty
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
This branch is not needed
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
I don't understand this change?
Missing space after 1.
Should this also handle the suffix 'es'?
simplify to return idx == -1 ? null : handlers.get(idx)? (same for other similar places)
Better with query than quest.
queryIndex
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
This will throw redundancy warnings in IntelliJ
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Collections.emptyList()
nit: plural naming on list?
if (! finalize) Check if first future is done. If yes then process it and break. If not, then break. if (finalize) Then process everything irrespective of future is done or not. In this case this is breaking out of the loop without doing anything...
If this situation happen, I need to know some information to be able to investigate why. For this reason, I would add at least Audit event to the log.
Why did we make this public?
We should validate that's non-null (to fail sooner).
My point is about consistency between different codecs. Protobuf codec assumes the callback handles the flush, while this code has to call it explicitly. We should make it consistent and set the expectation that the traverse callback should handle flushing/closing the generator. Then the codec's would just close the traverse callback.
Should be switch (type)?
Does this make sense? I didn't think bare repositories have an index so repository.readDirCache() would already throw an exception at this point since repository.getIndexFile() throws an exception for bare repositories as is called by DirCache.read
Please add braces on the while-block. I initially thought the 'return null' is done inside the while.
I believe calling this every time is equivalent to this on the factory .enable(SerializationFeature.INDENT_OUTPUT);
Cannot. This message is somewhat vague, probably Unknown special form operation?
This seems a little magical rather than just maintaining a mapping from enum to string value, IMO.
Perhaps we could use a constant for that or maybe give a way to set this name in some sort of configuration
I think 15, 11, and 4542278 should be named constants.
It would be great to rename the variable to isParamCountValid.
This wouldn't take the precision into account so if the other method would return a fully qualified host name, this would always return that instead of a substring of it.
excluded. isExcluded is name for a getter.
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
@mariebawanan I think the proper fix for this is to remove the duplicates in variables VariableTypeList instead of just filtering out the duplicates here.
I think it'd be better to throw an exception if the user sets isForceGuaranteedRollup=true but it can't be applied, otherwise it may be confusing if the task succeeds but they later notice that rollup was not "perfect"
This would never return a fully qualified host name.
If you run checkstyle, it will complain you the access modifier order. You should do public final instead of final public.
this is the spotbugs issue, you're building a new object but not assigning it anywhere
could be simplified: Collections.addAll(refsSpecs, specs);
same thing, while you are cleaning, other thread could store other key.
Is this idiomatic? In fact expect that won't be true, it's just that will be interrupted before the assertTrue returns? Would be clearer to omit the assertTrue?
In the utils package there is a class called ConverterUtils that has isEmpty and hasContent functions. I suggest using these when you want to check if lists, sets, maps, and strings are empty/null vs full.
You'll want this inside the lock
If we choose to add this method to the superclass (instead of having mapRuleDescription) then here we can ovverride.
Hm... maybe we can just call this resource range? The range looks sort of self-explanatory..
This error message is showing up twice in the console in my test, but they both refer to the same syntax. Is there a way to get rid of the duplicate error message? It might also be helpful for the error message to state which package has the duplicated ID.
Druid's coding convention is breaking each line to not exceed 120 characters. Please follow it. Same for other long lines.
we should revert this change. Private port can never be null, and it should be primitive.
Formatting issues. Please use appropriate spaces between string literals.
static
sounds like it could be set on error level
not necesary
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
![MAJOR](<LINK_0> 'Severity: MAJOR') Extract this nested try block into a separate method. [![rule](<LINK_1>](<LINK_2>
remove this,we dont want stop a service as it can effect other streams being processed by same thread
Comparing to the old code, there is a race condition now where two threads could create two streams and assign it to the stream field. That will cause one of the streams to be dangling. The questions is whether this is a significant issue and whether the contract for this class disallows concurrent calls to connect(). If we decide this is significant, we could wrap this function in an additional lock.
lets wrap all these conditionals into a method to improve readability. Something like: private boolean useHadoop2Reads() { ... } ?
Why not just throw e;? (granted, this one has a slightly nicer stack trace)
unneeded throws Exception
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Wouldn't the below code be more readable and correct? public static boolean isStatusOk(Map<String, Object> response) { String error = (String) response.get("error"); if (error != null) { String errorCode = response.get("error_code"); String errorDescription = response.get("error_description"); StringBuilder sb = new StringBuilder(); sb.append(error); if (errorCode != null) { sb.append(", Code: "); sb.append(errorCode); } if (errorDescription != null) { sb.append(", Derscription: "); sb.append(errorDescription); } throw new RuntimeException(sb.toString()); } return true; }
I think the annotations should be on separate lines
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
String key -> String columnQualifier, and also update its subclass
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
Shoudn't this be in VaadinServletRequest instead ? VaadinRequest is the basis for VaadinPortletRequest (not in this project though) so it should not be having API about servlet
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
or more simply: if (forceRemote != null && forceRemote)
I think you should be able to pass config in directly
i think you should be able to pass in config directly
Not sure, why not use @NotNull?
Should be a SamzaException with a message, not NPE.
pleass add @SuppressWarnings( {"deprecation", "java:S1874"} ) to method declaration
It seems we create and fill a temporary ArrayList here that we drop after filling without using it. I guess we miss a config.setPartitionLostListenerConfigs() call here.
should we warn the client user that config.m_topologyChangeAware is ignored when config.m_useClientAffinity is false?
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
We have a globally defined separator for this
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Use map.forEach
filename
why not null as value?
cant we directly remove from table.getParameters() ? why need a copy ?
I'd add an always-printed log message here too to make sure it's remembered.
This key ("properties") is used at multiple locations. I'd make it a constant.
Why not Map here?
We cannot use empty schema names. A classical object hierarchy is catalog -> schema -> object. Every such an object should have a definitive name for several reasons: 1. They need to be displayed somehow in tools that will talk to us through JDBC 1. It should be possible to reach any object from any naming context. With empty schema name, some objects may become unreachable Other vendors typically have a default schema name PUBLIC or alike.
Mentioned above: this functionality recommended to be resided in OQueryDataProvider
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
If this should never happen throw an IllegalArgumentException instead.
Unsigned types are not used in the current implementation. So, you can omit them.
Gson doesn't run on these versions so I don't see any reason to include them.
This list needs to include soul lantern.
maybe just replace all these error codes by default block since we are doing nothing for any other error code
What type of view will TIMEX3 be? Right now, it is of type NULL. Move the case to the block that contains the correct view type.
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
What in the... Please no. You can do better <3
It is probably worthy to make sure this class only gets instantiated once per language. I would abstract it to its own file that enforces that class is a singleton and just use it from the UDF, if you call it from the "initialize" method *i think* the application environment ensures that only once instance would exists but regardless that can be explicit on the code too.
Is it necessary to call this again?
As there is no else branch you seem to allow unknown/unexpected fields. Is this always allowed (i.e. per setting on the mapper/parser)?
Minor, but "extra".equals(tagname) would make this more concise. Java and its endless checking for nulls...
Are you sure that you should check value on null here?
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
I presume this part was a straight port of the old one.. I forget the precedence of ipv4 vs ipv6
Minor: maybe just move this a line up so it's after the bracket.
why is this loop inside the if-statement?
Do we need to close in a finally block just in case?
Should we be throwing any sort of error or warning if the fixture schema wasn't actually included in the restore? Right now it looks like IndexedFixtureXmlParser just silently creates no indices in this case.
Argument name
Argument name
MarketData.getValue never returns null
MarketData.getValue never returns null
There are no tests for these two new methods
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
I think we should also check for empty or whitespace only strings.
I think this is up to embed the current index into the message but this will result in a message like where no index is printed. The escaped ' also seem useless.
@Suseika let's clone the list instead assignment
Looking at the CommandCache#reset() method you pointed me to, it made me realize that we should check here that ctx is not null first, to avoid any risk of NPE.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
So this will be used for quantity and duration too or you need separate ones?
fCommandCache stores the MI command we sent to GDB for a particular context. My guess is that it can also be associated to an IMemorySpaceDMC. In that case, I believe it should also be cleared when its parent IMemoryDMC resumes. If I'm right, you should be able to trigger this issue by requesting the exact same memory after a resume or suspend; my guess is that a cached MI command will be returned with old values.
This will trigger for thread exists also. We should make sure we are dealing with a process using: if (event.getDMContext() instanceof IContainerDMContext)
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
context.getEntityType().equals(EntityType.FEED.name()) should do.
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
Why did we switch out the old code back to this?
I think the logic should be more like:  if (context.isRoot()) { fetch root object } else { if (field is attribute) { fetch attribute } else { fetch relationship } }
+ NUM_HEADERS + NUM_FOOTERS;
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
.add("noShutdownOnExit", noShutdownOnExit) (was shutd **wo** n)
Add .omitNullValues() before the toString() call
"Clean orphans from PROPERTIES" to be exact ?
minor: key_type instead of key type
this migration becomes useless since analysis_uuid can be null
This looks like it's just for card payments so don't think we should add these her.e
Add new catalog options.
Should we really accept steps?
No interest in removing the stageTimeoutMs value?
I feel like there is a case here where there isn't an existing pipeline (via the save entrypoint), which should probably be legit from a stale checking perspective. I also suspect the submitted payload in that case would not have a last modified (unless that is magically set somewhere along the way with a default value).
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
Planning on making the number of retries configurable?
lets change this to pipeline.hasLeaderID().
This can now be deleted.
should this be else if?
Same question as above
For consistency, can you move this between passport and http handlers (line 65) and change the method to addLast?
should this be assigned to something? like orcaResponse?
Can you add getId() and mark id() as deprecated?
Can we make it final?
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
Missing StringUtils.isNotNullOrEmpty() check
use default, no need public.
Remove this
these setters should not be public
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
Would this be a good place for some debug logging?
Is this method used?
Not good to use Optional for collections, just return empty collection
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
Why absent?
We should at least resolve the Type at construction, so that exceptions are thrown as early as possible. The qualifier lookup can still happen in the build method though, and satisfy the purpose of this refactor.
We shouldn't use class names in JSON serialization. These are serialized permanently in the file metastore and thus can't rely on current implementation details like the Java class name. It's probably also a security hole. Anytime you see a remote exploit for Java and wonder how that could possibly happen, it's some deserialization feature involving class names. Since we only have a small, fixed set of classes, using @JsonSubTypes with logical type names should work.
This can be static
Same deal here: use this version as the base, and have the extended versions just call into it with each arg.
hey guys, here it is what I should do by doing some initial casts (not great code I know, had to review at some point...), but this way the stream and functions to apply seams more clear... up to you!  protected boolean isConnectionAlreadyFormed(final Node<? extends View<? extends Definition>, ? extends Edge> source, final Node<? extends View<? extends Definition>, ? extends Edge> target, final Edge<? extends View<? extends Definition>, ? extends Node> connector) { final String connectorDefId = getDefinitionId(connector.getContent()); final List<Edge<View<? extends Definition>, Node>> outEdges = (List<Edge<View<? extends Definition>, Node>>) source.getOutEdges(); return outEdges .stream() .filter(e -> connectorDefId.equals(getDefinitionId(e.getContent()))) .map(Edge::getTargetNode) .filter(n -> n.equals(target)) .findFirst() .isPresent(); } private String getDefinitionId(final Definition definition) { return definitionManager.adapters().forDefinition().getId(definition); } private String getDefinitionId(final View view) { return definitionManager.adapters().forDefinition().getId(view.getDefinition()); }
With the other change this all goes away. suggestion .flatMap(new StatePathExtractor())
That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead.
This should occur before setInput(input);
![BLOCKER](<LINK_0> 'Severity: BLOCKER') Refactor this method to not always return the same value. [![rule](<LINK_1>](<LINK_2>
According to the reference bellow, a UserProfile may not have a reference to a Person, hence the getPerson method may return null, which will lead to a new NPE. <LINK_0>
This name, EMacroContext, needs to change and be in line with other services in the workbench (i.e., XXXService).
This hides feedback.
As noted above, just put the init code in init() unless there is a reason not to.
You're invoking generateEvent twice
The problem with this is that the iterator gets consumed once and you then benchmark how fast an empty iterator comes to completion through the operator.
How to checkpoint the states of union operator?
this change is no longer needed.
Check other tests in this class. Replace startGrid(1); by startClientGrid(1);.
Field should be named the same as the resulting JSON object to reduce confusion (if possible).
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this null-check of an "Optional". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this null-check of an "Optional". [![rule](<LINK_1>](<LINK_2>
I _think_ you intended to negate these two?: || (g instanceof Point) || (g instanceof MultiPoint), like in, looks like all geoms are being caught due to the !g.isEmpty() but you wanted to bypass points? If so, what about if( g != null && !g.isEmpty() && g.getDimension() > 0){...
Minor suggestion to change this exception to:  throw new IllegalArgumentException("g may not be null.");
Is this used anywhere?
where are the tests for getShortestDistance()?
This could be replaced by Server.getLabel().
Is payeeIdL a typo or intentional?
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Why do we print a secret systemUserPassword here?
You might want to not over-complicate it and keep the toString of the Optional perhaps?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Seemed better before? More readable
make this synchronized.
This assumes the webcam res == screen size... Not the case. height:width set in reporter seems to be ignored
Worth reporting what was null?
Can you specify the exception/message being thrown on this call? Otherwise you could use the Assert#nonNull(T, Supplier<String>) function contained in the framework. Doesn't return the field like requireNonNull() though. :/
this.configuration = Assert.requireNonNull(this.configuration, "this.configuration"); We should use this pattern for each final param that is created by the constructor. By doing so exceptions in case of a null value will be thrown as early as possible
I think we could reduce this constructor to a call to another constructor:  java this(configuration, null);
Why are you adding this twice?
Shouldn't this check be at the top of this method. Should we ignore working copies all the time?
use a final boolean in <LINK_0> to the redundant check again
We could also throw an exception if the transport client is configured with a user name and password, as that is only supported in the x-pack version.
Here it would be nice to use a static import - that would make it more consistent with the other code
Shouldn't there be an assertion checking that the shipping method was actually set, price and all?
Here it would be nice to use a static import - that would make it more consistent with the other code
Do we need the two lines above? Or are they left overs from testing?
Here we should add an assert to make sure that the value is set correctly.
How about replacing the first randomSlug() call to a new method SphereTestUtils.randomLocalizedString()?
Add a check here that the country isnt DE already
Looks like this line is a debugging left over We should remove it.
Nice example
Same as above, I would suggest to add an assert here.
Why is this necessary? This should probably use the generic updateBiometicListeningState(). I think you're doing this to turn on the iris scanner? If so, you should leave it authenticating state, like we do for fingerprint, and send another signal to go into high power mode to complete authentication. This is what we do in fingerprint.
Same question.
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
Pull this into a static final variable
I would retain the existing indexOf body to to avoid indirection in the most common case.
In the #valueOf(int,int) method, we could simplify the resulting bytecode slightly by eliminating i and using fromIndex as the index variable within the loop. As in: java for (; fromIndex < count; fromIndex++) { ...
Welcome to the world of limited packet sizes. This will explode and explode fast. Do not hijack the vanilla packet.
use Arrays.fill instead for loops
You should have this loop also under the childStart loop
It's a bit more semantically clear if the condition here is reversed. That way it reads: "if the distance is positive AND it's lower than the current best match."
Please add a java Objects.requireNonNull(computation, "computation is null");
Please add a java Objects.requireNonNull(computation, "computation is null");
java Objects.requireNonNull(callable, "callable is null");
In case self is a BufferedIterator should this return self instead of re-wrapping?
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
sleep?
I think it makes sense to use builder and return ImmutableSet...
This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
It's a good update
use the optional, luke! ![image](<LINK_0>
Use fire(event); for all EventHandler based events
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
else if, to prevent double affectation
This class has no superclass, so I'm not sure we need to call super() here.
I know its nit-picky but for future expansion, it is better to re-use twice or more often used fields and methods by binding them to variables. If you will get a NPE, it is easier to identify which variable had the NPE. Same as variables down below
check if you can use fluent api to add the storm tag
Not sure of the coding standards, but this looks kinda strange. In my opinion, it should be with brackets or only consume 2 lines.
Program to interface, not to implementation - please change return type to Map<String, Object>
technically speaking... :) the user agent header value could be stored in a static field and not computed each time getDefaultHeaders() is called. I'm sure the performance difference is negligible, but I couldn't stop myself from mentioning it :)
I'm seeing most of the string literals used for property names, etc are re-used in quite a few places. Let's introduce appropriate constants upon them to be able to make the code more maintainable.
Missing space between ) and !
In migration case, we shall validate if stats are associated with correct writeId. I think, in our tests, it should be pointing to last allocated writeId.
check
Please put this test case near the bottom of the file so line numbers in test aren't changed.
I think there's root because we don't have a "user" box in the UI. we shouldn't just deliberately add a user (cloud use case is not the only one, not even the main one in our case, IMO)
I'm not sure why but in this case the type inference didn't work, and we have to repeat <@NonNull String, @NonNull String>
Use Map for the declared type
Maybe wrap in an immutable map.
Maintenance of the map will be simpler than that of the list
What do you think about Comparator.naturalOrder() instead of null ?
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
I'd like to see direct unit testing of withService and updateServices . There appears to be a fair amount of indirect testing of withService but updateServices gets little to no coverage.
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
This a fix value, you can move it to the field declaration (as it was before)  java protected final Iterable<Text> childrenIterable = () -> this.children.isEmpty() ? Iterators.singletonIterator(this) : new TextIterator(this);  or change it to check for isEmpty() before it is set.  java if (this.children.isEmpty()) { this.childrenIterable = () -> Iterators.singletonIterator(this); } else { this.childrenIterable = new TextIterator(this); }
Add null check?
ImmutableSet.Builder for injectionPoints. newInjectionPoints seem to be unsued - remove pls.
this is a moot set to even bother using. It's a temp registry that gets dropped as soon as the game has finished loading.
Can we have a thread name here?
please validate ledger id
you could use Exceptions.expectExecutionException();
close should be implemented with asyncClose()
This should happen within the future
nit: In the absence of type information I wouldn't mind spelling variable names out. So instead of dj one could name it dispatcherJob. This will give the reader of the code a bit more information about the type of the parameter.
Since I already have implemented allOf in CfUtils, it had better to use it:  return allOf(futures).thenApply(x -> futures.stream() .map(CompletableFuture::join) .collect(Collectors.toList()));
Return a failed future
Use <LINK_0> instead
I guess this case is one of the downsides of the checked exception. supplyAsync would already handle the exception correctly :(
must be package local
Minor: Ideally we should avoid doing work in the constructor. Pas apiRooUrl and Client to the constructor, and provide a factory method receiving apiRootUrl, username and password and creating the constructor dependencies.
There are keystore types which don't require a password or gets it from another channel (e.g. WINDOWS-MY type).
suggestion this.authentication = new AuthenticationContext(username, password.toCharArray(), null);
tests method could only throws Exception, since you already expect which one will bo throwned
The "encoded" field should remain null. There should be a "byte[] hash" field instead. Also, charset encoding should not be used for hash password types.
remove
Dont' forget to remove the user at the end of the test
duplicated code
duplicated code
suggestion connectionFactoryList.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
We can strip this down quite a bit to just java this.eventReceivers.forEach(EventReceiver::close);
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
remove this
better do the close in a finally block.
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
Typically I do all the Spec only visible for the factory methods to instantiate. Is there any purpose to let this be created directly from end-user level?
Sonar will bark about a "magic" number; should be a constant.
I think for safety and clear code we have to use  instanceof DisposableBean here as well
I think we don't need this change. We have similar structure in the UdpSyslogReceivingChannelAdapter below but you don't override the onInit() logic there.
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
no need to call super explicitly. Any construction implicitly always starts with a super() call (unless it's a this() call to another construction).
please remove empty c'tor
Can we make the type of this field ProblemFactChange instead of Object?
Do we really need this? It's implicit
This public constructor is unnecessary because the compiler will generate it.
super() can be spared here.
It might be more readable if you have one setter per line.
Should be a SamzaException with a message, not NPE.
Not sure, why not use @NotNull?
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
I think you should be able to pass config in directly
i think you should be able to pass in config directly
Perhaps you should keep this, and at the close of the pool, then also close the PRNG object to avoid re-seediing in background when not needed.
would be nice to show an error and return if you're trying to monitor a rowId that doesn't exist
It seems we create and fill a temporary ArrayList here that we drop after filling without using it. I guess we miss a config.setPartitionLostListenerConfigs() call here.
Why not something closer to the original limit, which was 20x bigger?
should we warn the client user that config.m_topologyChangeAware is ignored when config.m_useClientAffinity is false?
use ShellIsAvailable
use ShellIsAvailable
use ShellIsAvailable
add wait condition for shell
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
What's the point of the 6 trailing zeros ?
It might improve readability a little bit if the expected score was a variable instead
Package private constructor, rather than just public?
For sake of readability, I'd rather write that this way:  return Collections.nCopies(96, 0);
I'd suggest creating a private DeviceData withHourOfDay(int n) instead of copy pasting the same line.
DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now
nit: plural naming on list?
This class has no superclass, so I'm not sure we need to call super() here.
Use fire(event); for all EventHandler based events
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
The same DEBUG concern is here, too, for otherwise
I am not following here - why do we want this in sync block?
We can take benefit of the super call in this case to populate the event object instead of applying the properties other than contentDescription ourselves. Following code would be better as compared to the code above: java super.onInitializeAccessibilityEvent(event); if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SELECTED) { final Map<String, CharSequence> map = new HashMap<>(); map.put("rating", String.valueOf((int) getRating())); map.put("num_of_stars", String.valueOf(getNumStars())); event.setContentDescription(ResourceUtil.getFormattedString(getResources(), R.string.rating_bar_selection, map)); }
This could be moved to VampirePlayer#onEntityAttacked. But I guess it is fine here too
else on new line. It is Spring code style rule.
Just curious, why do we need to change the access qualifier to protected?
so if you make this private that would prevent subclasses other than Some, right?
Why does a utility class need a protected constructor?
Should this method be in the account object instead? Something like isRegistered():boolean?
I think the setMaterializableResourceProperty should handle the materialized scenario itself. This means that this method can simply invoke setMaterializableResourceProperty(ACCOUNT,account); and then, the internal code of setMaterializableResourceProperty will check whether the account is materialized or not and then will relay on setResourceProperty(ACCOUNT,account); internally.
I would do a !TextUtils.isEmpty(account.authToken) here instead just to be on the safe side.
remove mRoles
Minor: Any particular reason we use the timestamp variable for two of these setters, but call DateUtils.getCurrentDateTime() for the third?
is the adjusting of the version required after the removal of snapshot version from equals()?
Values seem to be of a particular user. Change them for notNull asserts or something that can be run by anyone.
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
The code can be simplified to rely on autoboxing.
if these Boolean methods can never be null why not have the return type be boolean instead of Boolean ?
can you add to Builder as well
boolean
Don't you need a cast to byte: "byteBuffer.get() == (byte) 0"?
No need to get the property from System, the property is in the server-config.properties, so you can inject the property value in the class (${crafter.engine.preview}).
Same potential NPE as above.
Do we want that potential NPE in there? the first if checks if collection != null, so we "can" be here with a null collection. And that one is not caught by the catch below. I'd also argue that "if lambda == null" then the result is FALSE in all cases, whether the collection is null or not.
Add note of parameter [PostGIS DataStore](<LINK_0> doc page.
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
casting to Integer is redundant. IDE shows warning
not so readable. looks like good candidates for parametrization
you don't want to check that images are legal and exist?
would be good to mention TestMojo#getTestDependencies() here as it has to be kept in sync
maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?
@Suseika how about to check PsAll.enter() returns Identity from 3-rd Pass?
Why did you rename this? Semantically, this is a step backwards
![MINOR](<LINK_1> 'Severity: MINOR') Split this 227 characters long line (which is greater than 150 authorized). [![rule](<LINK_0>](<LINK_2>
nit: UNBLOCKED would read better than NONE
We need to check offset + length <= arr.length?
My expectation here is by the time the code is JITted the JVM will be able to predict ConverterHolder#getBestConverter() is both monomorphic and returns the same value for every invocation. There will be a bit of extra code to typecheck and branch (and de-opt) if the prediction fails, but I believe the branches will have the right prediction hints. The generated code will have the same performance characteristics as previous. If this is a concern, a jmh-based microbenchmark could confirm.
@njhill just to be 100 % safe should we better use: ?  System.arraycopy(array, index, copy.array, copy.arrayOffset(), length);
do we care to check for the length to be positive here?
Not very readable. Also, did you consider DictionaryBlock constructor that takes idsOffset instead of copying the array?
typo
do we care to check the length to be positive here?
Nit: no need for parenthesis
nit: What about name parameters as  byte[] destination, int destOffset, byte[] source, int sourceOffest, int length  The name source and destination is inspired by arraycopy in Java and memcpy in C.
This is what caused the problem. Please change the message.
We usually don final local variables.
before:-20160923, timeFormat:YYYYMMdd is misleading as the reader may think the value for before should match timeFormat, while in reality a value starting with a - indicates number of days and timeFormat is not used to parse it. Something like before:-10000 would be better.
I think it is better to throw exception
Please import assertThat statically here and in the other places.
Lets keep these methods internal for now (package accessible).
I think there is some findbugs issue with not using {} not sure.
filters.addFirst(filter) ? <LINK_0>
define variables below
Also, this whole method could be shortened to a single line: return (INTERVALS != null) ? filter.getFilteredRecords() : filter.getFilteredBases(); Oh, and another thing: protocol in this codebase is to put spaces after the 'if' and before the braces. Otherwise, you risk incurring the wrath of @nh13.
Generic type not used, remove.
I thought you wanted to end this practice, Adrian?
Even if this was copied, we should fix the this.m_ references here :)
You should use assertNull.
minor: this. does not appear to be our convention for fields. Use it (or don't use it) consistently for all fields
assert.NotNull ?
nit: I think this was accidentally left in
Accidental leftover :)
Unused?
we don't have to inject optional right? can't we just get an empty list?
I see a pattern and a lot of copy-paste code here ;)
Use Guava hashCode function
Yeah this should be return set.get();
This isn't correct; it defers to the default implementation of Object::hashCode, which will be different for different instances, but the contract of hashCode requires that two objects' hash codes be the same if equals is true. It would be better to return a constant.
hashCode and equals are inconsistent.
you didn't use methodName here, is it intended?
What I'm missing here is the check if the element is null. I know that the probability is very low, but still...
I think we should use HashUtil.combineHashCodes(definition.hashCode()), WDYT?
Very slow way of computing a hash code, but perhaps less important than for Line since we have fewer
I think you need to add a null check; code in SourceFile assumes content can be null
...so don't pass the "intial hashcode" into location.hashCode(...) but instead mix the various hash codes yourself here. Guava Objects.hashCode() can help.
!reason.isEmpty() can be used
They are mutually exclusive? Or is that a micro optimization?
The 'if' check isn't needed here, right? replaceAll will only match if these are true?
return null to make this more explicit ?
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
you need call addColorSettingsListener on the new instance.
Qualify this.uri
public
When can the name be null? If not possible, then add an assertion.
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
can be delegated as: putByteProperty(key(key), value)
can be delegated as: putCharProperty(key(key), value)
can be delegated as: putBytesProperty(key(key), value)
am i missing something this seems like a duplicate method call.
That's in the hot path of any send operation and rollbackIds would be contended by all the producers/consumers using the same AMQSession and it create a Long instance on any call of it. There are other ways to implement it?
Class and constructor can be package-private as only used internally.
Would it make sense to convert the return of CFDictionaryGetValueIfPresent directly to a boolean?
I prefer incrementing and decrementing on separate lines; it makes it easier to read and update the code. So maybe something like  ++mMessageId; MessageKey key = new MessageKey(mMessageId, priority);
do we need new Array here? You can just use ImmutableList
nit: it seems a bit weird that we are passing around the implementation type. Is there a reason that we are not using the interface?
use a constants in PicsConstants for page.png
Is this an artifact or intentional? It's not in the interface.
Should it be internationalized ?
Select Gradle Project to Import
Should we also check isVisible here?
I am unsure about this one. Will DLNAThumbnailInputStream.toThumbnailInputStream still get what it wants after this change?
I18N.tr("Add WMS layer") ?
re-use stuff?
Can you use the TAG = HierarchyElementView.class.getSimpleName() pattern instead of "HEVTYPE"?
ProcessEditorFactory should be a service at the first place so you would not have to call editorManager.addEditorFactory
On iOS I chose to not ignore this error since it makes the data structure useless and should require some action from the API consumer.
Should this return the AzureTable?
is there a reason why this method isn't implemented?
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
you may add the error message as an additional third argument here, in order to give the users a chance to understand why that is
java * @param error a potentially empty error message. * @param errors the List of error messages, which @code{error} is appended to, if @code{error} is nonempty.  @damithc errors description stills seems too verbose, ideas for a better one?
Why make these public visibility? I don't think the requests need their own subpackage so you can move them into the main package and reduce visibility here.
Same localization issue here.
As per above this can be simplified if we're just getting the error string.
Use Collections.singletonMap for a much more space-efficient implementation of a single-element Map
This should stay final
Should this method be final?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
just use values
filename should not be null according to interface (or do we want to allow it?)
There seems to be too much tabulators in my opinion. Please use 1 instead of 2 or even 3. And also there is probably no need to use new line on the row 943. You can inspire yourself in VoEntryManager on the line:97 method getAllVos. Thank you.
Why all the empty strings here instead of null?
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
This check is redundant because you check this in handleSelection()
I'm pretty sure we use IllegalArgumentException for these everywhere else.
unsubscribe()
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
Something to think about: if all of the DataModel types have a specific view type, then you could add an additional generic parameter to MockChartDataModel for the view type in addition to the dataset. This would allow you to move the view field up to the superclass.
Merge conflict. This should be comparing width to x and height to y
is to possible to catch some Exception sub-type? I mean some ParserException..
ErrorCallback to close "busy indicator."
backspace (bracket should be one tab back)
space
1. openHistoryPage() method should be named like openFileHistoryPage() 2. method looks better if parameter consist only from one variable e.g. historyPage.openHistoryPage(URLsContent.fileName);
Please use Yoda DateTime.now().getMillis() for a timestamp
it would be mighty fine to clean this up into a string format or the like if you're feeling up to it
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Why do we print a secret systemUserPassword here?
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Seemed better before? More readable
Wouldn't it make sense to at least log a warning? I mean, in the end it's the user who accidentally made a mistake/typo, the service silently "accepts" this configuration but it somehow does not really work as expected. Or did I miss anything?
@ILikeToNguyen Why the change in visibility here?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
Nit: Consider adding the default to defaults.yaml instead of here. That way it's obvious to users what the default is.
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
why not null as value?
I think we already have a utility for this. Can you try MapUtils or ConfigUtils?
Since it's very much a one-off thing, you may just inline it: java Collections.sort(options, new Comparator<Map<String, Object>>() { public int compare(Map<String, Object> m1, Map<String, Object> m2) { return ((String) m1.get(OPTION_LABEL)).compareTo((String) m2.get(OPTION_LABEL)); } });
It seems we create and fill a temporary ArrayList here that we drop after filling without using it. I guess we miss a config.setPartitionLostListenerConfigs() call here.
I know this is not your code, but maybe we can fix it in this patch(or following), but same problem is in newly created method below. maybe we could rename this. I have little understanding of this, but 'bond' seems to be placed in 'iface' variable, which I think should be named bond. This is (probably) bondParameters?
@slubwama provide an error message description of what has failed in addition to the stack trace
some other Executors wait here and see if the task exits immediately. Maybe we should do that too?
Should we be concerned that the expireTask can be reset after this synchronized block completes? Whose cancels the Future in that case?
Should we abort for all exception or only for OOM?
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
can we add more info in this error log?
host is always localhost
It is the same in this line, leave a blanck space before "+"
Null comparisons can be replaced by UtilMethods.isSet(object)
Even for moved code: Should here not an exists() call added or on a local variable an exists() call executed? I would prefer last option.
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
nitpick: just return <cond> sufficient
This is a little peculiar - does the index represent the position in super interceptors or executor interceptors? Maybe we should only support 0 as the index here?
Either null or empty
When using short-circuit operands such as "&&", placing less complex calls first (when that doesn't change expected result) improves performance. getVm().isCreated() is just 2 really simple calls, while getBroker().equals(getVm().getBroker()) is 4 calls (that are simple too). suggestion return isBoundToVm() && this.getVm().isCreated() && this.getBroker().equals(this.getVm().getBroker());
[If a player is targetable becuase VANISH_PREVENTS_TARGETING is false](<LINK_0>, should spawning also be unaffected?
Maybe use getType() here instead?
Is there any reason not to pass these in to the constructor?
I don't like these new calls here... but ok
Why is there a fromByteArray method? Why not call the constructor directly?
When you extend the abstract class that you use here, you shouldn't need to override these methods. Is there some special reason for doing that? I worry that any new method addition will be forgotten here and would rather that we just used the abstract class'es methods.
But existing rows use null not "" for the parentUuid.
I assume this is a time value, let's indicate its units in the member and column name.
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
Typically lock() before try.
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
final float sleepDuration = (int) ((double)  feels odd.
Minor point, but it seems like the reading should be in a separate outer try-with-resources, rather than nested in side the writer.
Nested try here too.
Could we reuse instances? Perhaps justified if getCoder is frequently called.
static imports
static imports
we'll never reach break;
The philosophy of simple-mode is to work soundly on most code, with very minimal restrictions (using around reflection). We shouldn't be using type-based optimizations in simple mode.
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
I wouldn't change the default.
could you instead change the flag from nextOp.afterDelete to nextOp.checkDeleted. Then, we wouldn't need to have check the GetOptions type here.
You could use TypeAnnotationUtils.unannotatedType(type).toString();. This would make sense to break out into a separate PR.
I would suggest using local variables instead of testing a getter return to null and then invoke the same getter again.
This should say "LocalTime".
This should say "OffsetTime".
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable length second fractions. An example of this is here: <LINK_0>, along with adjustments to the tests to make sure they are consistently truncated (H2 supports milliseconds but the tests were comparing it to microseconds on my machine).
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
please replase MojoExecutionException for a new generic DeploymentExecutionException
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
please use try-with-resources notation
Cleanup: Remove all **throws MiddlewareQueryException** clauses
Same error issue. I'd just fail rather than return a partial list.
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
we don't use curly brackets for single line bolocks
Why do we need a snapshot of the world? Isn't it possible to just use getCurrentState() to get the selection?
This not really a good name
Please don't downcast. I'm pretty sure this will result in a CCE in 4.x. Use HandlerUtil's getActiveMenuSelection(ExecutionEvent) method instead.
Ternary expressions are discouraged according to the EMF Compare checkstyle config. Checkstyle is disabled for this project for some reason (and I know this has been there before ;)), nevertheless, I'd stick to the common if expression just to be consistent.
Just wondering what was with the random "getClass();"?
final
PlatformUI.getWorkbench().getDisplay() seems to be the recommended way. See IWorkbench.getDisplay(). Alternatively use getShell(event).getDisplay().
return an Optional<Integer> instead, then you can probably also get rid of JMXServer#getInstance
what's the intent of this change?
please fix whitespace
Em, what does spotbugs say on Boolean?
no public
Should this be compared with || instead of &&?
Might this field connectClientTsApiFolder  ever be a null? it's created in CTOR and has a final.
could write this as this.qualifier.compareTo(other.qualifier) for clarity.
Maybe we could avoid the code duplication from super if we had methods compareMajor, compareMinor, etc. that we could override here.
Please add missing braces, here and also above and below.
Huh? :-)
I think this should have its own integration test as this is nth_value specific stuff only
Would you mind improving this test to use executeFile() instead of executeString()?
StringBuilder, or Joiner.on(" ")... something
Can you use an anonymous name for the maintainer? Not something from production
Usage of StringBuilder would be more readable IMO
This is not how you make an [unordered list](<LINK_0> in HTML. Example:  html <ul> <li>Coffee</li> <li>Milk</li> </ul>  produces - Coffee - Milk
Seemed better before? More readable
are a.exitstatus and a.pid meant to be variable interpolations?
Can we improve this error message? @jyotisingh or @juhijariwala would know how :)
have a look [<LINK_0>](here). This class should be deprecated and no longer be updated, at all.
Same here, with respect to bad exception handling.
quit can be made public, to be more explicit.
ATDServiceHost
Line wrapping usually happens before the period.
This seems somewhat brittle to me but this can be improved as the need arises.
Revert this change?
Move this down to before onStateChange?
this can go also into there...
hmmm... just an idea... move all these to the EngineExtensionsManager? so it initialize the builtins as well?
return symbol != null ? symbol.qualifiedName() : "";
It is useless to test before marking as ignored, as only the symbol which are already known could be marked. Note that to be known the symbol have to pass the "isSymbolRelevant" test, which is equivalent.
This can only happen if semantic is not present (symbol method is not annotated as returning null). As such you should test if semantic is present and not raise an issue if it is not the case.
Use JavaSymbol.MethodJavaSymbol rather than simply MethodJavaSymbol. This class is a nested class from JavaSymbol and we usually prefer to limit the number of imports.
remove final modifier.
symbol.name() called 3 times? maybe worth a dedicated variable.
Why not checking for usage.kind().equals(Usage.Kind.CLASS_DEF)? What if there are more than one binding usages?
"Modifier 'private' is redundant for enum constructors"
I'm not sure that's correct: what about code like alias\foo\bar?
maybe extract a method isAlias(symbol, ftype) to make the code more readable?
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
This will create a new instance every time. Cache the instance in a member variable?
It would be cleaner to have this set as part of the UnitTestModule() at the guice level so people don't need to remember to do this themselves.
Do we need to do this here? This seems like it's creating a circular dependency of the EMF into Guice, but the EMF depends on Guice.
Can this also go where zookeeper.root_key is configured?
Remember to default to something reasonable (false) in these cases so we can avoid crashing unnecessarily.
I don't think these casts are needed. The code worked when I removed them.
Let's make 2500 and 2 as variable.
rename to "security-filter" or similar?
nit: s/passwordAuthenticator/passwordAuthenticatorManager/
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
why not just return it directly?
Can you replace IDs with names in this log message?
Enforce immutability
If you make the EMPTY_EXPIRES, you could use it here.
Immutable?
if the Set in uris() had more than one elemnent, Iterables.getOnlyElement() will throw an exception. Is it really necessary to fail if there is > 1 URI?
This key ("properties") is used at multiple locations. I'd make it a constant.
Ideally, we'd use the Time#milliseconds() here instead of System.currentTimeMillis(), but you'd have to pass the time instance in through configure. It would aid in testability, but it's not strictly necessary. I'll leave it to you.
Suggest retaining [] brakets
I think you want to do this in the reverse order
empty finally block
why we don't swallow exception here for close?
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
please refactor code a bit more like:  do{ String line = lnr.readLine(); if (line != null) { readerLines.add(line); } } while (line != null)
We are now compatible with java 7 so you should probably use a try with resource.
I'd do checkNotNull(is, "is") at start of method, before creating the temporary file.
Can you use try with resources here?
Rather than have a handleSplitRegionBoundaryFailureDuringInitialization, would it work to always throw it and let the caller deal with it? When a variable name gets beyond 50 characters, it's a sign that it may be too special of a case. :-)
why don't you just use the copy constructor?
Can we have a message assert on this? I think the point here is that the exception thrown by the runner close isn't the exception that happened inside the shutdown operation
You should use deadline. Furthermore what the interest to change it ?
Does it still work on Windows?
If the path is null it should be set to "/apps/" + name.
StreamApplication app = new WikipediaApplication();
Do we actually need to do config rewriting? Any new configs that we add? If not, maybe we should remove it?
Use closeQuietly from Airlift Closeables. It handles null.
Possibly unnecessary to start two new threads for this test when one sits around waiting for the InterruptTestRunner to complete. Most of InterruptTestRunner could be inlined here (if you wanted). There may be some purpose I'm missing - I initially thought it was to stop the test hanging, but we join() indefinitely here.
I expected stream creation here. Where is that happening?
Shouldn't we be testing spy.runTask here?
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
Remember to revert this file, it should know about the transport class.
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
add mScanner to the Closer when it gets initialized. The way you have it now could potentially NPE
InputStream.close() doesn't contain any implementation so you can drop that call (but it doesn't matter). But I am pretty sure that the base class close will not get an implementation some time because it would break all previously working subclasses.
Exception isn't thrown by consumer.close(), it should be removed.
you should yield here (return). Operator shouldn't do a ton of work within single call, otherwise a query might be "unkillable"
We may also want to cancel our subscription.
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
This shouldn't declare throws Exception.
final
"Path validation" instead of "Request validation"
RuntimeException will be sufficient
Is this a list of file names or fully qualified file names? Not trying to nitpick but it does make a difference and with the need to build XML and .done files based on what we initially get, it might make it more clear which one we are dealing if with more explicit variable and parameter names were used; especially during maintenance. Thoughts?
RuntimeException would be sufficient
same as others: log should have Exception as arg
log. warn
Whether to checkpoint is determined by the application, so checkpointing here isn't safe. This should use a similar dispatch mechanism that processRecords uses. It might be possible to shortcut the dispatch at this time, and just make whether to checkpoint a configuration flag. The [dispatch code for processRecords](<LINK_0> for reference.
log.warn
Would you need the similar thread join pattern for the container placement handler thread , similar to the container allocator thread?
Why are we doing double math here? This should be: return Math.max(1L, nano / 1000L);
> In Java the / operator has a higher predence that the cast operator. actually, no, [cast has higher precedence than division](<LINK_0> <LINK_1>
Maybe Ints.checkedCast() for sanity
this is a confusing name for a function - why rename?
lock user_point
Why not declare GLOBAL_ID as a long?
lots more finals
Why don't you send the visible entries to this method in parameter, it would be thread safer
[minor] ~~How about memoization of this value in terms of performance?~~ Do you think we need to memoize this value in terms of performance?
Shouldn't this be Caffeine<String, Entries<E>> ?
Should this have output partition too?
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
Camel case here too
should we have srcBlockId and dstBlockId?
Change toString method to include both
why is this (and others) ""?
weight is missing from toString()
Add .omitNullValues() before the toString() call
If you don't think we want to expose it to the user, then I wouldn't include it at all. We can always add it later if there does seem to be a need for it. However, if this is part of building the response, then don't we need to include the version so it can be used for choosing prior versions to roll back to? Or at least, you need some kind of unique identifier for each version to enable that feature. If we don't want to expose the real primary key of that table, you could use sequential integers for each version (sorted), or something of that nature.
Add new catalog options.
Consider Arrays.asList("xxx","yyy", "zzz");
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
Why this change?
why do we remove internal? internal should be as any other.
Eep, does null actually happen? We should figure out where that's coming from and replace it with "".
What about :  names = new ArrayList<>(attributes.keySet());
Is this supposed to check if names is empty or if it has more than 1 element?
Should this accept Collection or maybe even Iterable? It looks like @BindList supports them.
Following is true only if we omit initialization to "now" in lastAccess: We should probably handle NULL case here. While non-null date is created in DB on insert, returned object from addUserExtSource() call might not have this property set at all and it could be used to create auditer messages.
This should probably be an orElseThrow with a descriptive message instead of get.
filter could still be null when this line is reached - we should check it isn't null
Generic type not used, remove.
StringPool.EMPTY instead
Also, this whole method could be shortened to a single line: return (INTERVALS != null) ? filter.getFilteredRecords() : filter.getFilteredBases(); Oh, and another thing: protocol in this codebase is to put spaces after the 'if' and before the braces. Otherwise, you risk incurring the wrath of @nh13.
I think there is some findbugs issue with not using {} not sure.
nit: remove else {}, throw exception after if block.
I think it is better to throw exception
getInitialValue() and numberValue() both need null checks.
Nit: I would dispense with the elses since you return in the ifs.
Remove unnecessary blank line
- log warning that option is not supported by SNMP
Based on how it's used, it's more like a listener not callback.
suggestion recommendedLayout.keySet().retainAll(newServices.keySet());
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
You might also consider adding constructor that passes k8s environment instead of internal one
Remove this conditional + exception. Uniqueness is guaranteed here.
This can be collapsed to a single line.
why not null as value?
It's a bit weird to convert an immutable map to mutable and never convert back. Could we refactor the logic to push up the modification logic?
Suggest druid.host instead of 127.0.0.1
nit: remove brackets to be consistent with 2 lines below.
I think you missed updating the parenthesis on this one
do we care to check for the length to be positive here?
We need to check offset + length <= arr.length?
shouldn't you do a defensive copy?
My expectation here is by the time the code is JITted the JVM will be able to predict ConverterHolder#getBestConverter() is both monomorphic and returns the same value for every invocation. There will be a bit of extra code to typecheck and branch (and de-opt) if the prediction fails, but I believe the branches will have the right prediction hints. The generated code will have the same performance characteristics as previous. If this is a concern, a jmh-based microbenchmark could confirm.
typo
I don't think this works. This will just set the latest emitted offset to the offset that was most recently emitted. I think you want the highest offset that has been emitted.
How about checking here if the sum of offset + length doesn't exceed size?
suggestion public Long offset() {
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Should check if errors contains error with key "Concept.conceptClass.empty"
Should check if errors contains error with key "Concept.datatype.empty"
this should be true.
I haven't looked at messages.properties, but this seems like an odd message code. (Other?)
this should be suggestion return errors == null ? Collections<ProcessingError>.emptyIterator() : errors.iterator();
Typically, in this case its best to throw an IllegalArgumentException saying obj can't be null
I think if a field has a value and has an associated units columns, then we need to require the units e.g whenever quantity is set, quantity units gets required
:ant: Should use Throwable.addSuppressed on the others.
Can this assertion be done using the Argument annotation?
To increase readability of this test I would just drop this statement, and move ifCond block inside if condition
It is a bug! Please notice that there is sort in array_agg(orderstatus ORDER BY orderstatus).
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Why do we print a secret systemUserPassword here?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Seemed better before? More readable
isInfoDebug
Why change the name the property? Accident due to mass refactor/rename with IDE?
Technically setting closed = false isn't needed since this is the default for a boolean
The original constructor can delegate to your new one, i.e.: java public KafkaRecordSupplier( Map<String, Object> consumerProperties, ObjectMapper sortingMapper ) { this(consumerProperties, sortingMapper, getKafkaConsumer()); }
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
can we split this into multiple lines and add tab support?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
The number of parameters is extremely large -- creating a brittle interface and difficult to comprehend client client. Please refactor to the Builder pattern.
This can reference SamRecord.NO_ALIGNMENT_REFERENCE_NAME to make it clear what the * is
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
INITIAL_SIZE is misleading because this constructor creates a fixed-capacity queue. So this value is actually the maximum size.
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "createExecutor" a "static" method. [![rule](<LINK_2>](<LINK_0>
Just out of curiosity: does this test fail with 60 seconds timeout?
Because the failureCounter is incremented at multiple places, it would be easier for test fixing to use a failure log which you push a message to. It doesn't matter much for the completeness of the test though.
This should probably use an injected ManagedExecutorService. At the least this ExecutorService needs to be shutdown.
Why 3 * numThreads for semaphore permits? Just wondering...
nit: was hoping to have a programmatic way of generating this, though definitely non-blocking
Does it matter if this println remains? Given what the harness does I'm inclined not to really care if this is here.
Why is secondStartIdx a long variable?
rename
rename 'listeners'
not all listener
not all listener
not all listener
Can you please elaborate on why we need a concurrent list and a SafeRunner in this case?
not all listener
rename
maybe rename?
rename
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need anything to be added to DB.
cannot be null.
We can directly use updatedVolumeList instead of copying it to a local variable.
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
invoking combinations of close and releases here looks strange
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
Include a failure message argument.
no public
I prefer to separate the daemon thread from the OM double buffer, so that this class will be more flexible to use.
But we have already clicked the button in the command before, haven't it?
What we are waiting here on?
just reuse this method where you need  public void selectAutocompleteProposal(String item) { seleniumWebDriverHelper.waitAndClick( By.xpath(format(AUTOCOMPLETE_CONTAINER + "/li/span[text()='%s']", item))); }  <LINK_0>
Might to replace on the exist _waitAndClick(By elementLocator)_
Are we really need to wait 2 seconds if we are waiting on web element anyway later?
Can we avoid sleeping here?
These three commands could by replaced by one: seleniumWebDriverHelper.setText(...)
Looks like here we should have 'seleniumWebDriverHelper.waitVisibility(By.xpath(format(Locators.VOLUME_PATH_XPATH, **path**)));' in second line.
Can we wait for non-empty attribute and return it then? It will avoid using WaitUtils.sleepQuietly(1);
Can we be more specific here, not to cover unrecoverable exceptions, but timeout exception?
If you instead call this lastItemPositions and subtract 1 here, does that save you from having to subtract 1 from the final return? I think it reads clearer not to have a "- 1" on the last return.
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
== RHS_NULL?
This should never be null; let's not check against that. Nesting makes the code less readable, so we have nothing to gain here and something to lose.
At this point I know we can assume mOnLoadMoreListener isn't null, but if this fragment gets used elsewhere we can't guarantee it won't be null. How would you recommend handling that?
it seems that getItemCount() - 1 == position condition is useless
As this method is duplicated thrice, should make it static util function, int getLayoutPosition(boolean isRTL, int count, int position)
suggestion @Override public int getItemViewType(int position) {  Can we move the @Override annotation to a separate line than the method declaration for code style consistency?
I would suggest to replace the 2 with a constant named something like EMPTY_VIEW_COUNT_ON_END...
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
I'd rather use Money here.
Let's adjust the formatting :)
Please avoid duplications. Rename this method to just create.
LOG.debug
error
this can be replaced with your function
We have Command/EventIdToStringConverters registered in the converter registry, so I think we can remove explicit command/event ID conversion from idToString().
this should be error and use the constant
I'm wondering if there should be a helper for the above three lines. They appear a lot.
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
I would recommend an else if here to avoid comparing against a string unnecessarily.
I think lowercase l should also be considered
That should be toHtmlForAnthology. You mixed those two up.
Tabs
I think it will be more graceful to use a private final String.
Let's set this to true in fixtures.xml so we make sure we properly load a non-default value?
the backup flag of the result will be false for 72e3a666-89e1-4005-a7ca-f7548004a9ab
It's not pool..
Args.notNull
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Not sure that it's good. If path is not setup - this.dir will be still null - and we just pushing NullPointerException one level down.
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
this if/else is equivalent to this.path = Optional.ofNullable(path);
Is this change still necessary? Is it only used in tests?
Putting a method call to an overridable method in a constructor means that you can end up calling a method in an object whose constructor hasn't been called yet. This can lead to some very hard to debug errors. One way to avoid this kind of dependency is to make a field lazily initialized, e.g. in its getter.
I would prefer to avoid any dependency from UriComponentsBuilder on UrlPathHelper. The latter is more of a Servlet API specific component while the former is more general. Even if the re-use in this case doesn't touch on anything Servlet specific, it seems very minor and not worth the gain.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
think you should add it as method somewhere
FindBugs finds this line not to it's liking it seems: Exception is caught when Exception is not thrown in org.jboss.weld.probe.Reports.getDesc(ConfigurationKey) ["org.jboss.weld.probe.Reports"] At Reports.java:[lines 78-370]
Nitpick: Can probably remove both the if and the else (saving three lines) by starting with description = MoreObjects.firstNonNull(description, "") right at the top.
Please restore the original formatting.
Can we reuse the existing converter?
I don't know the internals, so likely the case were "Form (Preview)" is returned is never reached. But i18n is appreciable in other case.
set your feature as transient
Don't call getMethodName twice. See the implementation. It is slow method!
nit: how about we just use the class name of input strategy by default
[minor] can yo rename it availabilitySet?
I don't think we need this catch - this is handled by the boolean return value.
This should be handled by the nodeDelete return value, so we don't need this catch.
Revert back to sessionFactory.getCurrentSession()
I believe it will be nicer to just generate a String containing either an 'On instance of...' or 'Of class: ...' and add that to the message.
Use final variable declarations
what what? When did we add addsTo ?
please also add the GUID which is important.
Just use Clients.log ?
While looking at this, I started wondering if it'd make sense to have this retry forever when Fedora is not available or throws an authentication/WebServiceIOException exception. The reason being that the failure isn't an issue with the job, but with the environment, so skipping over the job won't help. What do you think? Would it make sense to maybe increase the delay and make it retry forever in the two cases I mentioned? For startup of the work daemon i think its fine for it to have max retries before giving up since nothing from the queue would be lost. It'd be kind of nice to get notifications of some sort when these things are failing, but I don't really want to over engineer this since it's not going to be used for that long. So lets hold off on that until the need comes up.
make sure that e is logged before throwing it to the client.
same here. In case you want to open an ErrorScreen, you can do so by using one of the reportError() methods from <LINK_0>
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
log the exception ?
specify charset?
Why not throw IOException and let caller handle and log etc.
the code duplication of the sendXXX methods is quite huge. Could you rather make use of the HttpUtil class? Would that help reducing the amount of code here?
I guess that works too, but this string should be declared statically. Or see in os.linux.core.tests: Activator#getAbsoluteFilePath, to not have to write the plugin name (in case somebody decides to move the plugin around and change the name, I know someone who does that sometimes :p )
We have a utility for it in Pipe  UrlUtils.appendToBaseURL(serverUrl, pipePath);
Do you need to close the input or output stream? WRT: Invoking the close() methods on the InputStream or OutputStream of an URLConnection after a request may free network resources associated with this instance, unless particular protocol specifications specify different behaviours for it.
If there's a lot of data we could add a Accept-Encoding: gzip header here and call IOHelper.readString(HttpURLConnection) instead.
can you make all of these as just Query and not org.hibernate.Query?
Please use the positional parameters.
We can't filter by closing time?
Also for the next few methods, just return (List<CourseStudent>) q.execute(...); directly.
I'd lean mildly toward using uppercase for overlapping keywords. But would be okay leaving it as is.
Maybe use [SQL code style](<LINK_3>, with [all caps for HQL/SQL reserved keywords](<LINK_2>, [newlines for new statements](<LINK_0>, and [explicit aliasing](<LINK_1>
shouldn't this be ArticleRelationship?
What is wrong with Arrays.asList(getItems()) (which avoids the use of the builder which will generate the same / more temporary objects on the heap) ?
We should create a separate, generic class for this execution, since the body of the method is always the same.
Any reason why we are packing the results of queries into ArrayLists?
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
If an implemented class uses this default group method, does it work with returned null or it has to override with some implementation?
I think these methods should throw exceptions (might need to create one). They can't return false, and having the impl throw IllegalStateException on any failure doesn't feel right.
Why not result.removeAll(b)?
probably don't want to keep filling this map up as we browse around. could just use getOrDefault?
Seems like this should all be in a constructor since the class isn't useful without this data being passed in.
Selenium already has a org.openqa.selenium.Cookie. There will be lower friction with other parts of the Selenium APIs if we return extant Selenium types. I think it's fine to extend those types to be more meaningful if necessary.
Class scanning is really time consuming. We don't want to scan 100% of the classes three times to do this. In the past, this has caused build times to go through the roof. We should make maybe a new method in ClassScanner that looks for the classes we need in one pass.
replace with lambda statement?
studentsWhoRespond -> studentsWhoResponded
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Don't we have to say that this is uniqueId JDBC?
These two lines get called repeatedly in (i.e., 87-88) several of the methods that follow. Would it be worth creating a private method that returns the objAcls?
I think Local.ROOT is probably a better choice.
why not null as value?
Arrays.asList is varargs so you shouldn't have to have the new ExportConfig[] {
I'd add an always-printed log message here too to make sure it's remembered.
Update to use Security.doAs
Might just be a personal taste, but I'd also prefer a for loop here:  for (Filter f : filters) { ArrayList<String> parameterValues = f.getParameterValues(parameter); if (parameterValues.size() != 1 || (commonValue != null && !commonValue.equals(parameterValues.get(0)))) { hasCommonValue = false; break; } commonValue = parameterValues.get(0); }
This should be removed - it's absolutely fine for entity data to be empty. It's only during serialization to native format that it should not be empty (ie adding the EntityType field)
You can static import the checkState method.
return this.toInteger() == 6;  Since toInteger never returns > 6, I find the >= a bit confusing (even though it's more future-proof).
this.
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
@pinaf could you explain purpose of these asserts?
I really dislike how this confuses things. Most of the /s are in the templates, but then this one special slash is being added here. This is a really good opportunity for future mistakes. Maybe this is a case for changing from using String.format() with templates that all do essentially the same thing for varying numbers of parameters to say just using String.join().
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
Could you change the message here ("Unable to connect..."? It's confusing as the actual error is likely a parse error instead of a connection issue.
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
Use same order as the field declarations.
that class would be better with a builder, though I wouldn't ask changing it now
This line is redundant.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
since we construct a default conf already, better to use it rather than call defaultValues.  internalConf = ClientInternalConf.fromConfig(conf)
Shouldn't we use empty list here ?
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
What are those values? Extract to some properly named constant?
just reset to null
does this need to be calculated on the fly each time or can we save the iterable?
Should we throw an exception instead if a DimFilter was null?
Can these 2 functions be constants? So we don't need to create new instances every time these methods are called
There are 2 issues with this line: - It's long & complicated due to chaining several method invocations and cause reader hard to realize the purpose. If we can break it down to multiple lines, it will be great. - The Function object can be refactored into a method to be reused in the next getAllProgramLead function.
Can you make these final?
filteredProgrammes is a bad name for this, and as far as I can tell, these should be Episodes, not Programmes by now.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Strange logging "cursor[input.getTime()]". Also maybe just remove this debugging line
we can remove the null check ?
This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.
We should call the init() method first, instead of letting the KerberosAuthenticator do that for us.
I don't think we need this catch - this is handled by the boolean return value.
Is it for sure targetName will contain @. I mean in case of serverName null, and when targetName is not under server control entirely.
This should be handled by the nodeDelete return value, so we don't need this catch.
One more very, very minor point: We should be wrapping these exceptions properly (IE: initializing the throwable source in the new exception) rather than just adding the same string message, otherwise we lose the most relevant part of the stack trace. This is a general habit we should get into with error handling
you can catch this in getChecksum and have only one crash.
What? We catch an UnknownTokenException and then are doing a string check on the error message? Why?
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
Why not just throw e;? (granted, this one has a slightly nicer stack trace)
This should be done in a finally block
Unsure this addition is useful.
Is there a reason that allocationPools, dnsNameServers, and hostRoutes are missing here?
Omit nulls or not?
.add("noShutdownOnExit", noShutdownOnExit) (was shutd **wo** n)
weight is missing from toString()
If you don't think we want to expose it to the user, then I wouldn't include it at all. We can always add it later if there does seem to be a need for it. However, if this is part of building the response, then don't we need to include the version so it can be used for choosing prior versions to roll back to? Or at least, you need some kind of unique identifier for each version to enable that feature. If we don't want to expose the real primary key of that table, you could use sequential integers for each version (sorted), or something of that nature.
Add new catalog options.
This looks like it's just for card payments so don't think we should add these her.e
this migration becomes useless since analysis_uuid can be null
Should we really accept steps?
Remove all "null" cases. There is a default case for that.
If this should never happen throw an IllegalArgumentException instead.
Gson doesn't run on these versions so I don't see any reason to include them.
You should not duplicate code here. Add second switch case for exiting SOS alarm option.
Unsigned types are not used in the current implementation. So, you can omit them.
What type of view will TIMEX3 be? Right now, it is of type NULL. Move the case to the block that contains the correct view type.
This list needs to include soul lantern.
Can we avoid this switch/case block?
What in the... Please no. You can do better <3
It is probably worthy to make sure this class only gets instantiated once per language. I would abstract it to its own file that enforces that class is a singleton and just use it from the UDF, if you call it from the "initialize" method *i think* the application environment ensures that only once instance would exists but regardless that can be explicit on the code too.
static
The null check is now redundant since now we do literal.equals(variable).
remove
calendar.setTimeZone(new SimpleTimeZone(timeZoneOffset, Integer.toString(timeZoneOffset))); ======== don't use string concat
Variable names must start with lower case. Also make this hostId, instead of host because that is more accurate.
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
please remove this, if this isnt true, the next assertion will fail anyways and also give you a pointer on why the length is wrong.
Seemed better before? More readable
Could you update task variant with these? <LINK_0>
This is in IdGenerator, so can be deleted from here.
ctx.close()
replace with ReferenceCountUtil.release(msg)
maybe log an error message here if numConnections ever goes less than zero
Why wasn't this left as-is? I'm fine with it, but it just didn't follow the pattern of the rest of the PR.
if there is possibility of writabilityStates to be null, it might be better to write this as "".equals(writabilityStates)
I understand that PromiseComibner() constructor is deprecated, maybe we could extract this as a method and do deprecation inside of it? Then we will not need that duplication(<LINK_0>, and if someone will need to construct this class, he could call this method that encapsulates the logic?
imho it should just be write(...)....
suggestion assertTrue("Original state should be cleared on access", ctx().isOriginalEmptyValue());
The debug logging can be removed
Should this be configurable?
is the server name mandatory still ?
assertNull? And the withTx... though I know you've just moved this code from another test.
Could you please use Map interface here (and not the implementation)?
you can use try-with-resources to automatically close the client when finishes. java try (RemoteCacheManager cacheManager = new RemoteCacheManager(builder.build())) { ... }
Good one! :)
These tests don't seem very safe... if the first commit fails, safeCommit() will try to commit the second transaction again, instead of resuming and committing the first transaction.
This test isn't exhaustive. The point of this commit was to ensure that they were all part of the iteration, right?
what is wrong with cache.getTransactionManager()
The same here... There are more places like this in this commit. Could you please update them also?
shouldn't be assertNotInCacheAndStore(cache, store,...)? (note you have cache in the first and second parameters)
replacing this with helper method would be great
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
You could probably use the same URL as in getResultById here.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
If component is null, this will have NPE'd by this point if typeMapping does not happen to be a type that allows null keys (most don't)
Part of this method throws IllegalArgumentException and another part returns the error message. Please make all branches throw an exception.
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Isn't that racy?
nit suggestion String quotaProjectId = (String) json.get("quota_project_id");
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
It should be "path".
This is three minutes. An since FAT is two seconds we require only larger than two seconds. On many file systems that is three seconds, but 2.001 would do. With a Unit test you would have found this out. Do we break anything because the ObjectDirectory had two /minutes/ as fudge?
Return sizeInByte instead, if available.
Path and Package will NOT be available in Submarine.. is this meta-data essential?
checkArgument looks like the wrong function here -- should it be checkState? Also, missing informative message in the case when the check fails.
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
Can you remove this first case for FileNotFoundException and just let it fall through to the general case.
Since read is a pretty common term - I count three different uses in as many lines here - maybe this should be something like bytesRead for easier reading?
Add a blank here, please.
I think it is better to add this to the generic 'Request' interface. To make it easier to use I think also that we should have several 'header' and 'query' methods in that interface, at least two: one to set just one header/query, and another one to set a map (I'd consider this optional), that way the user can do the following: vmService.start() .header("My", "header") .query("my", "parameter") .send(); We should also probably have a new 'BaseRequest', or similar, implementing that interface and providing the implementations of those methods.
Same, 4 spaces.
Is this really needed? What if the exception throws by the target isn't a RuntimeException?
This method can be static, as all the methods it calls.
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
you could have merged the expression of this if with the previous one.
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
This has nothing to do with your contribution. I would keep the class name as a String as it is clearer and avoid to import Serializable which is not required. Same remark for the other arguments.
Throwing NoSuchElementException is part of the contract of the Iterator.next method, but this isn't an iterator, so we don't want to throw that exceptions. When there are no more values we should just stop the process.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
I guess I'm out voted on using this. :-(
If an assignment strategy doesn't implement movePartitions and if the operator calls movePartitions, It is better to throw rather than silently return. This way it is clear to the operator that movePartitions is not supported for the connectors using this assingment strategy.
Make a copy of the keySet like ImmutableSet.copyOf(modes.keySet())
redundant ";" character
The doc needs to specify what the keys of the map are used for. From a quicklook I think it's the type of user but I'm not sure.
Is order important here? Should the 2 collections correlate each to another?
if static, should be initialized outside the ctor.. maybe make it final static.
I think these all should go into your symbol table class eventually.
If you are using synchronization to control access to the session data, than I would suggest reverting the map type to a simple HashMap and synchronizing around the map as opposed to this whenever you read, put, remove, or alter it.
Avoid the intermediate variable and directly assign selfID.
suggestion Assert.notNull(id, "Labelset ID must not be null.");
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
Can you add getId() and mark id() as deprecated?
need to pass Locale.ENGLISH here don't you?
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
these setters should not be public
Missing StringUtils.isNotNullOrEmpty() check
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
Try pushing methods such as getAuthorization().getViewConfig().isAdmin and getAuthorization().getAdminsConfig().isAdmin to Authorization class
Any reason for logging and throwing the exception. Normally, we log or throw.
In my opinion, we do not need this log. WDYT?
Is there reason for throws Exception in signature?
Any reason why we need a constructor that gets both username/password and an access token? This is reflected also in other constructors in the code.
I think we have now changed the term "service group" to "cartridge group". Might be better to use lower case letters inside the sentence.
This seems more readable, giving the same result (if I'm not missing something):  for (Entry<String, List<String>> en : pathEntries.entrySet()) {
Seems to be a compilation issue here, new ArrayList<>() should be new ArrayList\<String\>()
There should be a null check on the identityProvider, prior to calling its getRoles method. Maybe something like... List<String> roles = (identityProvider != null) ? identityProvider.getRoles():null;
Should be externalized.
Externalize
Externalize
Externalize
you do not need the @NonNull
super-method only
please remove "Performance"
NIT: move these to separate lines?
Get it from the model now that we have one?
I recommend using Collections.emptyMap() instead
Which tests fail if we don't have this line?
I think this should be replaceFailed = false instead.
Silly think but can we call this workbenchPage, wPage and Ctrl+K lands frequently on the method sho(wPage) and I like to use Ctrl+K to follow a variable
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
5 or 10 minute schedule?
If the AuthorizationManager is produced from the ConfigAttribute mappings, then this line can be removed.
compositePolicy.getDeletionPolicies().putIfAbsent(clazz, predicate); It's also a bit unexpected (for me) to see a builder on CompositeComponentDeletionPolicy, suggesting that the result is immutable, then proceed to pull a writable Map out via the get method and inject extra entries. A factory method could be added to the builder that starts with an existing CompositeComponentDeletionPolicy.
Maybe better to use default access modifier, like in the other classes, e.g., FilterModelCheckListener.
shouldn't check exception message
Type for Field + config.field + must be String
use log's parameter here
Fix logging level here (error)
suggestion logger.warn("Failed to do decode hash using base64! " + ex.getMessage());
Each of these catches should use a logger statement.
Again, please don't catch Exception. Code compiles fine without the try catch but you might want to replace it with catch for NumberFormatException.
this is redundant here.
Please remove blank lines and format code.
Optional: no need to log if we rethrow exception (<LINK_0>
[minor] Throwable#getMessage returns String, so we can remove the first empty string literal.
It's ok to pass a null input stream here?
hmm, why don't you verify the type ?
None of the tests in CaseDbQueryTests handle the condition where this Lookup is actually valid (and neither of the other two tests cover this code path)
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
The blank lines before and after method bodies are quite strange. We don't have rules about that but it seems inconsistent to me. It could be valuable to have feedback from others.
remove static
I think the logic should be more like:  if (context.isRoot()) { fetch root object } else { if (field is attribute) { fetch attribute } else { fetch relationship } }
Does the StringUtils.isEmpty function work here? I usually use that and expect it to handle both the null and empty cases (you'd still need to trim it I think... which brings up another issue I've been thinking about where we probably need to trim all input from the user but don't do it consistently).
NEW_TASK_CREATED --> BUILD_INFO_AGGREGATION
That would be great!
you can simplify it with a single line by replacing the method's body with: return validate(hostExists()) && validate(hostStatusValid());
to get variable replacement you need to use the idiom: if (!validate(isClusterSwitchTypeOVS()) && !validate(...)) { return false; } where the predicate methods return a validation result instead of a boolean (which will encapsulate test+result nicely) there are lots of examples in other commands
Please use StorageDomainValidator.isDataDomain()
note that here we will initialize imageToDestinationDomainMap. Maybe now we will be able to send it to ValidateDiskNotAlreadyExistOnDB and avoid the filterInvalidDisksForImport in excecuteCommand. please try this change and then: 1. create a template 2. detach the SD with the template 3. register only the template disk 4. register the template 5. try to watch the template disks (if something wrong UI exception occurs) 6. Remove the template and verify that the disk remains in the environment
please add dc compatibility level
We require complete input validation here. I miss the validation of the network and an error message if validation fails. Please use NetworkValidator.networkIsSet(), you could create a Validator like UpdateNetworkValidator
this is now outside of the if (isImagesAlreadyOnTarget()) scope. is it on purpose?
I'd recommend showing disk alias rather than diskId
Probably not part of this patch, but the MSD should be created from a list that contains diskList and cloneDiskList below
Shouldn't this be inside the diskList.size() > 0 if?
this is 3.3 feature, not 3.2
This should be as it used to be, no need to convert to lower case as that should already be part of the "value()" implementation of SELinuxMode.
This should be 3.6, even if the "quota mode" concept was available sinnce 3.2.
Is it needed to wrap the exception in a RuntimeException, can we just remove the catch?
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
nit: you can merge both lines above as checkNotNull will return the given argument
This println can probably be removed.
Please use the form given before
EAP_7_2_0
EAP_7_2_0
This check feels a little weird for a few reasons. It behaves like a factory (in that it returns new instances) but sLock is not assigned here. It also initializes a static field from an instance method and that feels strange. I suspect that if the lock is not being acquired in one method and released in another, and there aren't any waits involved a more primitive synchronization technique may be sufficient (such as a synchronized method or block, without the use of a ReentrantLock) -- I'll leave this up to your judgement but this looks dodgy
Please remember this ctor changed.
ooh! I ...Connector, here!
could this block be simplified?  java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; }
I guess we can remove the unnecessary this. accessor from these getters as well.
So we change the default conflict detection engine when calling EMF Compare through API, but not when invoking EMF Compare through the UI. Isn't that inconsistent?
@xpdavid is this the right thing to do?
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
have a default constructor with reasonable default values
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Can this be private, or is there another use case for default attribute outside the builder's call?
should the message include "command _with options_:" + this.options ?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
scheduleTimes --> scheduleTime
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
When concatenating the log message it would better to pass every parameter into the Objects.... rather than concatenating the string which is inefficient.
Raw type; needs <?>.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
Why call setScrollBar() twice? (L157)
why don't we have "readItem" span name here?
Don't need toString()
Can you add getId() and mark id() as deprecated?
Missing StringUtils.isNotNullOrEmpty() check
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
these setters should not be public
If you add setHasSubtypes(true) then different types of wires won't stack
Translate this log message in English please
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Translate this log message in English please
Is this kind of thing done elsewhere? Seems a bit unusual but won't debate it if that's how we treat other list parameters.
unused field
the attribute is not used
Can this be private, or is there another use case for default attribute outside the builder's call?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
scheduleTimes --> scheduleTime
Even though it's safe to do so, I'd prefer we called this.next() only once.
This is unnecessary. I would rather we keep the history intact than bother about the order.
Better use isEmpty
I know these mocks were already in an array, but wouldn't it make the code more readable to have a named variable for each of the bundle mocks? This is more evident when using the array itself in the tests. For example, what is this mock supposed to represent?  Bundle mockBundle = this.mockBundles[5]; If we used a named variable such as externalStaticResourcesBundleMock instead of this.mockBundles[5] it would make the test conditions easier to understand. Is the array itself iterated somewhere?
For stand-alone applications we have started just creating the endpoint directly rather than using the factories and having to deal with managed-beans.xml etc. Take a look at the pattern used in this sample: SocialSDK\samples\java\sbt.sample.app\src\main\java\com\ibm\sbt\sample\app\ExportWiki.java. This is a simpler pattern to use.
It's beeter to used int type.
Would be better to have all these methods return a primitive long rather than an Object Long.
I propose to log the actual timeout used if it differs from the default.
maybe replace this with a @NamedQuery using JPQL.
valueOf() can directly take a String argument. And I think many of the other instances can be removed due to autoboxing.
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
use 'L'
456L
Hehe, this is exactly the pitfall I pointed out :D If currentTimeMillis + timeout is actuall greater than Long.MAX_VALUE, you will get a overflow and the sum will become negative. Instead you should probably test, if Long.MAX_VALUE - currentTimeMillis() < timeout and if so, throw an error.
Maybe catch Exception? Otherwise propagation stops.
if target is already updated or expiration time = -1, in either case we can skip update
For debugging: Would it make sense to log the exceptions here?
This code creates a HashSet object even though v exists.
As there is only one element, we don't need to use an object array.
Misses closing backtick. Would make it a second sentence: Set -D{2}=false to no longer show this message.
Generally this string comparison is not correct (foo string will be false as well), SystemProperties.getBoolean() should be used instead to cover all false strings. Same for the comparison above.
invert this.  java if (List.class.isAssignableFrom(target.getClassType())) { return multiInstantiator.instantiate(target, parameters); } return conver....
Remove this check, right? We still want to add this constraint if hostID == null. It would be solely based off of hostIds returned by findHostsWithVolumeInUse Though, we'll still use v.hostId as a fallback if their are no mounts and furthermore if there are no mounts and v.hostId is null, we dont add the constraint at all.
Lookup the host here and add host name too. Can just use the objectManager
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
Put suppress warnings annotation to method and change to direct returning the getted value to avoid temporary store the return value.
You can remove the unchecked warning by doing:  T service = clazz.cast(services.get(clazz));
I would recommend componentType.cast(new GlobalSecurityManagerImpl()); instead.
why is this return null??
Hm, maybe this should return bitmapResultFactory.wrapAllTrue(Filters.allTrue(selector)); and return true for supportsBitmapIndex. As-is, TrueFilter shouldn't be returning true for supportsSelectivityEstimation since it doesn't support bitmap indexes, but not supporting bitmap indexes would potentially interfere with use of bitmap indexes for other subfilters when an And/Or filter contains a TrueFilter (See makeCursors() in QueryableIndexStorageAdapter and getExecutionPlan() in AutoStrategy).
rather than static, why not make it an instance method? (default method since it's an interface)
I know I may be late to the game with this (the unchecked cast is everywhere), but is there any reason we don't use  return componentType.cast(clustered ? new DefaultPendingLockManager() : NoOpPendingLockManager.getInstance());
Is what you want Class.getEnumConstants(), rather than doing reflection here?
Can be simplified to return observable.timeout(1, SECONDS).toBlockingObservable().last();
Can you please move the Preconditions up to the constructor? Also perhaps check for matching with " projects/(projectId)/instances/(instanceId)/clusters/(clusterId)"?
Just return checkNotNull(id, "id").split("/");
Let's have these conditions one below other:  if (parts.length != 2 || parts[0].trim() .isEmpty() || parts[1].trim() .isEmpty()) {
What does this do? The result is passed directly into Datasets.load above so it should produce a dataset or view URI. But it appears to check if the URI is absolute (assuming that it has a scheme) and remove the beginning '/' if so?
@viczhang861 This class cannot possibly know that it is used to describe a non-builtin function. Can you give an example of a query that is failing?
:ant: double check of a single field.
I would explicitly write throws NumberFormatException here.
Good point
Missing codes.
jps and jstack will only work if the Java process is started by the current user unless you are running command as super user. Is it possible to try running it using sudo first?
it needs to be protected against concurrent modification
again I think you can use the diamond operator
There must be a more succinct way of doing this using streams.
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
/s/else/elseif
nit, Collections.EMPTY_MAP?
why not null as value?
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
Ah, it's a Multi-API thing. There's probably a way to make this a nice aspect since it's in every call.
Suggest druid.host instead of 127.0.0.1
why not replace these two lines with return (getState(key) == State.SET)
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
OPTIONS could be more suitable here, since we don't want to transport the whole value
Should this method be private or protected?
make the constructor package private instead of private to avoid going through a generated synthetic constructor.
This check can be removed, <code>getAdminEmailsInTrashBin</code> already does that check. Anyway, <code>isDeleted</code> should only be called for Entity classes, not EntityAttributes, I think
call equal on constant
Can you write this as a single if-statement?
existingStudentProfile and existingProfile might need renaming to distinguish between the attributes and the non-attributes version.
Using Objects.equals will result in less code and is IMHO better readable. Missed I the reason you don't use it? <LINK_0>,%20java.lang.Object)
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
Can you assert the container has the right name?
Doesn't List as a Collection have a defined method to check whether it's empty or not?
Highly suggest isEmpty
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
You get it right. Per code conventions, I like to see brackets around if and else clauses.
@slubwama I do not think we should do this since it may be possible that the backlog for a patient has not been entered - so will give wrong data
equalsIgnoreCase for SERVICE_PREFIX to be consistent with WORKFLOW_PREFIX? Or is that there for workflows for legacy reasons, and we won't allow different casing with services?
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
final
throw e will never be executed.
Why do we need this change?
is this needed?
Use the new String(byte[], Charset.forName("UTF-8")); form to avoid the try/catch. Constify the UTF-8 Charset elsewhere for extra points ;)
if (args.length > 0 && "stop".equalsIgnoreCase(args[0])) { ServerLauncher.shutdown(true); return; }
I think we need to read stdout and stderr of command here. Otherwise it can never exit.
Consider using getField() instead, ~~it's implementation in OpenJDK 8 seems more performant.~~ Also the semantics of that method apply better in this case, since it is a public field. _Edit: can't confirm first claim_
nit s/argsCount/expectedNumArgs/g
Is this worth an error? Might just warn and continue?
I don't think this would properly handle the case where the tree element selected in the active page doesn't correspond to the element that is about to be evaluated, or if no tree element is selected but the eval should be done remotely. I think there needs to be a nicer way to determine whether the eval should be done locally or on a remote system.
Should this return the AzureTable?
is there a reason why this method isn't implemented?
These two lines probably can be combined into one.
Should we throw an exception here, or just replace the null value with an empty string?
I think the annotations should be on separate lines
You should use a consistent method naming paradigm within your class. I think this is the only setter that says "set" on the start. Either have all of them say set, or none of them. This might also be a good opportunity to change "rya prefix" to "rya instance name" since the prefix is Accumulo specific.
Just using plus + operators would be easier to read (and actually perform a little bit better). Also, inline this prefix.isEmpty() ? key : prefix + "." + key to the caller would save a method dispatch.
Can we move this out to a private static field?
I don't think this warning should be here for system-defined prefixes, because it's essentially is informing the user about something they can't change. If somebody does override schema: (which I still think is crazy, but ok, let's leave this possibility) then there's no point warning them about us not overwriting it back. We just should ignore our setting then.
You need to provide the 'id' of the property that has been removed - or maybe the last value - but atleast the id.
Remove by dn/key.
We need configuration property persistence-manager-remove-count: 1000
final
Please consider using "debug" as far as message reject is a valid option of a client.
"Path validation" instead of "Request validation"
I agree that just logging warning for the duplicate confirm is ok. But what if developer invoked confirm and then reject? I think it clearly indicates some problem in microservice's logic and we should have some more evidence in logs then just a WARN message
Why log and re-throw? Isn't the caller of this method not handling/logging the exception?
There is conditional remove, no need to fetch everything before removing.<LINK_0>
log.warn
Should be "Could not initialize sync structures due to parsing error"
please use String.format to concatenate strings
whole expression should be wrapped into toIntExact not only rebase( index ) % entriesPerPage
shouldn't it be- (index +1) % numberOfMacsInRange ?
not super sure about this.
Is it correct that it is assumed that localToGlobal will always be called before globalToLocal?
We should be able to disable bounds checking - this should be a property. I believe there could be a property netty uses for its bounds checking - we might want to use use the same one.
I believe these 3 lines should be moved to BMT, it's his logic
I don't think that's going to work: the index was 11 (should be 10) in the crash, but the original text is only 5 chars long. TBH, I'm confused as to how any of this works... how is the span 21 characters long? As a very ugly solution, we could just use the catch block to call super with index 0. Or we could multiply mOriginalText.length() by 2.
Can you compose this method into smaller methods where each method name explains what it does
I think this field were in seconds, not ms, or am I wrong?
Everywhere we call entity.getClass - we need to use the EntityDictionary.getTYpe instead.
The use of false here seems un-intuitive, in that we never update set the hash - even for new objects. Is this because we rely on the id being null in these cases in order to detect it is dirty? In any case I think it needs some tests around it.
Maybe rename idToChildResource or something along those lines.
Error message needs updated.
@rishabh-997 there is one in the application constants that convers this
You can probably use EntityPredicates.id(), which gives back Function<Identifiable, String> (rather than just for entities).
I'd do it without the AtomicInteger suggestion countPerEntity.merge(entity, 1, Integer::sum);
same with return here
Is there a reason to use an inline anonymous class here? It would probably be cleaner to have a this trivial class generated by Lombok (e.g. @Data)
same here - no reason to duplicate code
Why are you changing to patient 7 here too?
Maybe, but I like simple and dumb unit test, this test checks that the service is started and well initialized, we don't need to test that on all tests. I don't see cases where a Before something is useful to understand failure in this case.
Using == for object comparison? :)
You need to test for another openmrs object to understand why am insisting
Do we need to store this as a field, can't we just return that in the getIpinterfaceId() method?
This test does not expect the exception nor pass in an empty string.
Cast is not necessary.
There should be a null check here if it doesn't accept null values
Should this mention Dockstore? I could see it other way; as other fields mention it. Depends if this describes the API or the implementation.
What if you move this section below the declaration of cheService then you will be able to avoid buildConext variable e.g.  java if (service.getBuild() != null) { cheService.setBuild(new CheServiceBuildContextImpl().withContext(service.getBuild().getContext()) .withDockerfilePath(service.getBuild().getDockerfile()) .withArgs(service.getBuild().getArgs())) }  Moreover i think that creation of CheServiceBuildContextImpl should be replaced with constructor call
Log debug - not info.
method can be protected now (private if not isolated in tests).
Another option would be to use  log.debug("This is the execution root? " + result) to replace the lines 532 to 539.
Be careful when copy paste :). You are printing "bundle started" when stopping also. Another thing is when you have no string manipulations in debug messages, you don't need to check isDebugEnabled(). It is an extra if.
We do not need to check if debug is enabled since there is no string concatenation. The check will be done internally.
log.trace
Ideally we must be throwing this exception and its the client who can decide what to do with it. Lets change this to throw the exception and in authentication framework we can catch the exception, log it and continue.
Ideally we must be throwing this exception and its the client who can decide what to do with it. Lets change this to throw the exception and in authentication framework we can catch the exception, log it and continue.
If debug = true, log will just call itself recursively. Surely you mean if(debug) { Log.d(text); }
check isDebugEnabled()
could we check this without throwing an exception?
Resources is itself part of Guava, and is marked @Beta. Why not use GuavaCompatibility.class.getClassLoader()?
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
missing non-nls warning.
static
If we decide to keep this, then I'm wondering why you'd attempt URL loading. Never seen that being needed?
No, need for close here as you use try-with-resource?
please remove unsed code
Formatting issues. Please use appropriate spaces between string literals.
Maybe put this after the verify step? Do we print anything out there? We should
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Not an exception
here is where i mean
Test when no version is supplied?
suggest Assert.fail() here just to make sure the exception is actually thrown. Or, use the @Rule ExpectedException (example in FileTaskLogsTest)
This change looks not necessary.
nit: empty line
After more closer inspections I believe we have to synchronize the whole method. newValue and oldValue pair still races and the main reason we log the change is to know what's the current state is. Without the synchronization, the log messages are not guaranteed to reflect that since the order of log messages is not coupled with the order of the changes.
@benbosman : I'd still encourage us to start with minimal/basic unit tests rather than waiting for "perfection". As you'll see above, I already have concerns that the UUID parsing is very fragile. So, having unit tests to prove it is working at a basic level would be helpful here, especially since the client using the REST API can literally send *anything* in a text/uri-list...so we need to ensure the parsing works as we expect.
I think a special case should be made for an anonymous principal, to disallow the API in such a case.
this method is @NonNull, throw UnsupportedOperationException until we implement this ?
This should return the list of resources under it, see FileResource impl for more details
@o-alex can you replace this with the DistributedFsService.closeDfsClient()?
I think we might want to separate out the concepts of hasIndex and isQueriable. In gatk we have a datasource that has no index but supports random access. I also think supportsRandomAccess might be clearer name. I'm not sure how granular we want to go though, you could potentially imagine a stream with an index that supports fast forward skipping but not rewinding, which wouldn't be easily described here either.
You'll need to save the object first to flush these changes to the database.
beware of caching incomplete results
UUID
use the pm from the arguments?
What if we have only private static boolean isIncluded(String[] groups, Collection<String> includedGroups, Collection<String> excludedGroups) instead of 2 methods?
Maybe remove the package name as it is already in the import statements.
Use a builder method from TestNG Collections
we don't use braces around single line blocks
replace with List interface
replace with List interface
Can be simplified to: java return Arrays.stream(groups.split(",")) .map(String::trim) .filter(s -> !s.isEmpty()) .collect(Collectors.collectingAndThen(Collectors.toSet(), Collections::unmodifiableSet));
If you reverse the parameters order, it will be more like createListenerFactory
First group should only be ignored if it's length is less than other groups, i.e. 10000_000_000 should be noncompliant IMO. Other minor detail: using skip instead of subList would be more concise with streams
Its a bug this isn't Collections.unmodifiableList or something. Please fix it while we are mucking with the code.
I think on reason to wrap into isDebugEnabled() since we don't do any logic with argument to log.
RuntimeException would be better. Typically SI components check the exception and wrap it to MessagingException with "guilty" Message. If it is MessagingException already we lose the "guilty" Message context.
setErrorMessage
... and below.
why the double wrap?
I disagree with the decision to turn a side-effecting method into a boolean. It should be a separate method (or even a condition on manuallyClosed).
Did it help in any scenario or is it a defensive programming?
A MalformedURLException is redundant.
This is called twice, could that be your issue?
3 days of hollidays, and I do not remember the way the messaging works. Do we have one listening thread per application? I will take a look at it on tomorrow.
This field is written here but never read, can be removed (Findbugs)
I don't see any change that is related to elapsed-time, why is this change needed?
super.getVm() will do dao call...
We might want factory methods for these common exceptions. Having all these magic strings all over the codebase is likely not ideal.
Good, if there are no other places where it may be set to null. But I would rather fix the comparison.
minor: move the else up on line, together with the "}"
what is the new behaviour now that you don't setSucceeded to true ?
Not sure if vm can be null, it is already locked.
this-use case is not available here
Deep copy should be used to ensure stability of code. Can this.getGraphicsInfos() contain some mappings before the .putAll() is called? It can be source of the inconsistency.
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
is this necessary?
these error messages should use the name of the expected property. keyField
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
I don't understand why we need to make this ThresholdInputStream so configurable. As I understand, this class is going to be used only inside this package. I would make it package-only visible and remove this "runnable" injection.
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Nit: Wouldn't it be good to move the settings to new lines? suggestion Settings settings = Settings.builder() // .put(loadConfig()) // .put("transport.type", "netty4") // .put("http.type", "netty4") // .put("path.home", this.pathHome) // .put("path.data", this.pathData) // .put("cluster.name", this.clusterName) // .put("node.max_local_storage_nodes", 100) // .build(); node = new TestNode(settings, Collections.singletonList(Netty4Plugin.class))
You can drop these from the throws clause. Not only are they not thrown, but they are RuntimeExceptions.
whitespace / tab weirdness
Is there any specific reason for having two times the same check?
Please, use text "Project owner login" (Name was fixed after sending this pool request) thank you.
Please, use text "Project directory permission" (Name was fixed after sending this pool request) thank you.
Use "Mail" instead of "Mails". There is only one trusted mail.
Not your mistake, but please, fix it too. There is description for other attribute.
Please, use text "Projects base path" (Name was fixed after sending this pool request) thank you.
Again, not your mistake, but fix this description if possible. There is much better descrption on devel/gui in attributes. Then you can delete '//FIXME'. Thank you.
The correct name is 'IPAddresses' with upper case for IP part.
You need to change content of this method too (while changing the name).
"Account" instead of "Accoun"
Please add note to description how correct value look like (syntax).
This can be made static
You can chain this like  java return ImmutableList.<String>builder() .addAll(currentSeeds) .addAll(newSeeds) .addAll(oldSeeds) .build();
This can be simplified to:  java return ds3Requests.stream() .filter(this::isGetObjectAmazonS3Request) .map(this::toGetObjectCommand) .collect(GuavaCollectors.immutableList());
This should probably be a constant since it is used in other places.
Change this to say "No requests to split" to differentiate the error message from some of the others.
This builds the set on each lookup. It should be built once and then used.
Is this always null? I don't see this param being used in the above split functions.
If you want to simplify building the set, you can try:  ImmutableSet<String> secondaryBuckets = ImmutableSet.copyOf(MoreObjects.firstNonNull(corpus.secondaryBuckets, ImmutableSet.of()));
Might just be a personal taste, but I'd also prefer a for loop here:  for (Filter f : filters) { ArrayList<String> parameterValues = f.getParameterValues(parameter); if (parameterValues.size() != 1 || (commonValue != null && !commonValue.equals(parameterValues.get(0)))) { hasCommonValue = false; break; } commonValue = parameterValues.get(0); }
Dead statement? Loop will not loop if empty.
no need for an ArrayList
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
nit: ~Square formatting
You've overridden this method but dropped the @Nullable annotation.
get(). (Btw since inner is plain, this check may end up hoisted and you'd never see it turning null).
Hm, I would expect that if I call build on a fragment and I change the fragment after that, that it does not change the previously build reference...
A lot of code to express empty categories, I would prefer:  java final ProductProjection productProjection = SphereJsonUtils.readObject("{\"categories\": [], \"variants\": []}", ProductProjection.class);
Why do you have changes here? It does not seem to be any real change...
If you instantiate a DefaultUserStatusListener then you could omit all those empty methods.
getMXBean()
