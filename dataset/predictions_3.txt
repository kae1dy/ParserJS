Is this order guaranteed, ie ls-refs before fetch?
Is this order guaranteed, ie ls-refs before fetch? If so I'm wondering if it is a good idea to even check the return value of this method.
Is this order guaranteed, ie ls-refs before fetch
Why NON-NLS?
Why not use a logger?
Do not use sysout.
you're returning an empty request, maybe better to return an enum (I also prefer not null)
you're returning null, probably better to return an enum, or maybe return Request.class.
while?
Should use nextTag() and switch-case instead.
Since we use nextTag() and switch-case here, I think we should use this instead.
Here use nextTag() and switch-case instead.
Perhaps consider to change the condition to check that raw is not null.
Perhaps consider to change the check to check that raw is not null.
Maybe consider to change the check to check that raw is not null.
Could you please refactor the code to create a new method like this? protected static ConnectionFactory getConnectionFactory(IDatabaseConnection databaseConnection, String url )
Could you please refactor the code to create a new method like this?
Should the SSL enabled Timeout be hardcoded?
check for queue size <= 0
check the queue size <= 0
check for null here?
if (StringUtils.isNotEmpty(userCode, userSystem, userSystemName, userDisplay)) {
check for null and throw a SAMLAssertionBuilderException if the required user* is null
check for null, we don't need to check
This is the exception expected, not the entire stack trace.
This is not really the exception. It should be "expected".
This is not really the exception. It should be "expected"
Please use system.out.println() instead of System.out
Please use logger instead of System.out.println()
Please use logger instead of System.out.println
nit: why do we return null by default?
nit: why do we return null here instead of throwing an NPE?
nit: this should be final
I don't think this is useful.
I don't think this is needed.
I don't think this is required.
can you use forEach or forEach directly?
can you use forEach or instead of stream?
can you use forEach or instead of stream here?
This is File copy error not file system retry case.
This is File copy error not file system error
This is File copy error not file system retry case
I think you're right. If the connectTimeout are un-ordered with a read, it would make sense to me to assume that this does not imply a read-only state.
I think you're right. If the connectTimeout are un-ordered with a read, it would make sense to me to assume that this does not imply a read-only mode.
I think you're right. If the connectTimeout are negative (<LINK_0> this will force a second then you should still execute that first.
This is a little confusing, we need an move into _timeRangeMSToTimeRangeMSCache.
This was shared for when we move _segmentToTimeRangeMSToSegmentSearchTree into IntervalST. We need to keep the cache in memory.
This was shared for when we move _segmentToTimeRangeMSToSegmentSearchTree into IntervalST. We need to keep the cache cleared for similar segments in future.
check to make sure notificationUUID is not null before using it.
check to make sure notificationUUID is not null
See above about notificationUUID
public methods should be private.
public instead of protected
can it be private?
style nit: no braces here
brackets are wrong here
just return false
Seems like there's a spacing issue here, two spaces instead of 4.
Seems like it's more clear what's going on here, but two spaces instead of 4.
Seems like it's more clear what's going on here, but there's a spacing issue around the verb?
It's better to log the entire stack trace as well, if needed.
It's better to log the entire stack trace as well, and first pass the whole stack trace to the message dialog.
It's better to log the entire stack trace as well, and add the text of the exception.
I think I'd call that in the general purpose field.
I think I'd call that in the same name as the general purpose field.
I think I'd call that in the general purpose field. The goalResource is a rather general class.
should this be initialized in the constructor?
should this be null?
should be mFloppyPath
I'd rather use MavenProjectHolder.
I'd rather use MavenProjectHolder.getPushDefinition()
I'd rather continue if this breaks on a MavenProjectHolder.
Is there a reason we need this change?
Is there a reason we need this listener?
Is this constructor used?
this.redisTemplate
this is an internal method, should be ops.set(value)
this is an internal method, so should be ops.set(value)
Is there a reason we can't use [this](<LINK_0> instead of the thread class?
Is there a reason we can't use [this](<LINK_0> instead?
Is there a reason we can't use [this](<LINK_0> instead of the thread daemon?
This log statement should probably be removed.
This log statement should probably be removed
This is not needed since we have done in other tests
I think it would be better to create a Resources and then return it immediately, rather than creating a new List of ApplicationVertex objects. You can use something like this: java return graph.getVertices(...).stream().map(ApplicationVertex::new).filter(v -> searchCriteria.getCriteria().equals(ApplicationVertex::asGenericVertex)).collect(Collectors.toList());
I think it would be better to create a Resources and then return it immediately, rather than creating a new List of ApplicationVertex objects. You can use something like this: java return graph.getVertices(...).stream().map(ApplicationVertex::new).filter(v -> v.asGenericVertex()).collect(Collectors.toList());
I think it would be better to create a Resources and then return it immediately, rather than creating a new List of ApplicationVertex objects. This way we can have multiple resources associated with the same name.
Externalize all strings
Externalize
Externalize the strings
I'm not sure how this comparison is working, but I think it's better to just check for the type == CallNode.class.equals(pNode.getClass()) instead of pNode!= null.
I'm not sure how this comparison is working, but I think it's better to just check for the type == CallNode.class.equals(pNode.getClass()) instead of pNode instanceof CallNode.class.
I'm not sure how this comparison is working, but I think it's better to just check for the type == CallNode.class.equals(pNode.getClass()) instead of pNode!= null if ( aType == CallNode.class ).
Please add a TupleSource here
Please use Iterators.tryFind().
Please add a TupleSource here.
This is a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
This is not a related change... if you can move it to a separate patchset
This is not a related change... if you can move it to a separate patchset?
Could use DbUtils.getDataSource().getDataSource().getConnection();
Could use a stored in the SQLUtils.
Could use a stored in the SQL, for example
Please change the usage of ByteBuffer.allocate to support the buffer that is passed in.
Please change the usage of ByteBuffer.allocate to save the very large byte buffer.
Please change the usage of ByteBuffer.allocate to support copying.
According to which rules do we throw and InvalidSyntax or an IllegalArgument or an IllegalState exception. Sry, but this looks quite randomized to me
According to which rules do we throw and InvalidSyntax or an IllegalArgument or an IllegalState exception. Sry, but this is not clear.
According to which rules do we throw here, if there is an error here it should be logged before we return null.
Possible copy/paste bug in the order by clause.
Possible copy/paste error in the order by clause.
Possible copy/paste problem in the order by clause.
This method should return date. SimpleDateFormat might not work properly if a date is not a default locale. <LINK_0>
This method should return date. SimpleDateFormat might not use our own class, right?
This function can return null if a date is not a default locale. SimpleDateFormat has a problem here. <LINK_0>
Hash code
Hashcode.
Hashcode
Why is this assertion "model.getValue()"?
Why is this line removed?
Why is this assertion "model.getTime()"?
can you put the "query.isDescending()" into the method
can you put the logic of the query class outside the method?
can you put the logic of the query class?
Maybe it's better to name the cookie with the name LOGIN_COOKIE_NAME, but it doesn't exist anymore.
Maybe it's better to name the cookie in the message?
Maybe it's better to name the cookie with the name LOGIN_COOKIE_NAME?
fail
use fail(String message, Throwable)
use fail
Would it make sense to return a Publisher<Integer>?
Wouldn't it be better to throw UnsupportedOperationException instead?
Would it make sense to return a Publisher that extends Publisher<Integer>?
This should use a StringReader instead of a ByteArrayInputStream.
This should use a StringReader instead of a ByteArrayReader.
This should use an explicit locale.
Should there be a null check?
Should there be a check that it's not empty?
Should have a null check here.
I'm not sure if you want to require this extra object to be loaded. I would prefer to have a Yaml constructor with its original values. The returned map could also be an empty map if it is not null.
I'm not sure if you want to require this extra object to be loaded. I would prefer to have a Yaml as a static class. It is also not the responsibility of the caller to instantiate it.
I'm not sure if you want to require this extra object to be loaded. I would prefer to have a Yaml constructor with its original values. The returned map could also be an empty map if there is no other way to retrieve properties.
sleep?
sleep here is not needed
Thread.sleep(100);
WDYT about changing the message to: "count must be in range %s, was %s"
Would it be a good idea to have count as the count in the error message? We could simply say "count" instead of "count".
Would it be a good idea to have count as the count in the error message? We could simply say "count" instead of "count"
This should probably be a RuntimeException instead of catching NPEs.
This should probably be Log.logException(e)
This should probably be Log.logException(e)?
This line should be: root.hasChild(subsystem) && root.getChild(subsystem).hasChild(address));
This line should be: root.hasChild(subsystem) && root.getChild(subsystem).hasChild(address);
This line should be: root.hasChild(subsystem) && root.getChild(subsystem).hasChild(address)); right?
let's return a better name than sessionInUse
let's see if it's still needed.
let's return a better name than dao
This looks wrong. Can the monitor be null or empty? MonitorControlManager.getInstance().getMonitorControl(selectedMonitorId)
This looks potentially wrong. Can't you just check whether the selectedMonitorId is null and return false at the bottom?
This looks wrong. Can the monitor be null or empty?
discussed and decided to let it lie
discussed, how about also checking that it is in Stopwatch it would be more time for it.
discussed, how about also checking that it is in Magic Number?
@Serranya The same here. See above.
@Serranya Please, add the name "Stream" into the Body class. It's too much generic.
@Serranya Please, add the name "Stream" into the message to be more clear and specific. It's too generic.
Are you sure this is always true?
Are you sure this is always the correct URL?
Are you sure this is always the correct endpoint?
Shouldn't a journalDoiRegexList be a Set?
Shouldn't a journalDoiRegexList be an object?
Shouldn't we use a method on the journalDoi name?
consider checking the char content, as it might make sense to create a list and compare that?
consider checking the boolean that comes from the first iteration over the list
consider checking the char content, as it might make sense to create a list and compare that it's not aimee period
Is this line reachable in the gerrit client?
Style-nit: Maybe put this in the GerritService class and get rid of the constructor.
Style-nit: Maybe put this in the GerritService class rather than the implementation class.
If we have this method public, we may need to make it package private.
If we have this method in the parent class, we may end up with a race condition. Probably we need to make sure we do the incrementCacheRemovals() when the value is null.
If we have this method public, we may need to make it package-private.
please inject a static method rather than using this class.
please remove the method signature
please call the other constructor too
We should omit the colon in the next line.
We should omit the colon for now.
We should omit this in the repo
I'd change 'if' to 'else'.
I'd change 'if' to 'else', as it is more readable.
I'd change 'if' to 'else', as it is redundant.
Use logging instead.
Use logger please
Use logger please.
Can be simplified to return new String[] { "at3", "oma", "aa3", "oma", "aa3", "at9", "aa3", "at9", "aa3", "at9", };
Can be simplified to return new String[] { "at3", "oma", "aa3", "at9", "aa3", "at9", "aa3", "at9", "aa3", "at9", "aa3", "at9", };
Can be simplified to return new String[] { "at3", "oma", "aa3", "oma", "aa3", "at9", "aa3", "at9", "aa3", "at9", "aa3", "at9", };
SetSpecialDays should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetSpecialDaysRes on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetSpecialDays might be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
Hmm, this doesn't seem to be useful? When the getLongByField() is called, it'll throw an exception if the tuple is not in the map.
Hmm, this doesn't seem to be useful? When the getLongByField() is called, it'll throw an exception if it doesn't have a value.
Hmm, this doesn't seem to be useful? When the getLongByField() is called, it'll throw an exception if there is no state.
is there a case, if the wdlInputs is null?
I think this is a bad error message, we should log it to the user.
I think this is a bad error message, we should log it to the user
What's the purpose of calling t_order here?
What's the purpose of this query?
What's the purpose of calling t.t_order here?
Add the check for setName(FilterLevel.class) as well.
Add the check for setName(FilterLevel.class)
Add @Override annotation
Could you change all() to return Collections.unmodifiableList(dataTypes.values())?
Could change this to return Collections.unmodifiableList(dataTypes.values());
Could you change all() to return Collections.unmodifiableList(dataTypes.values());
This doesn't seem right. We could just refer to the ID of the active partition in flight.
This doesn't seem right. We could just refer to the ID of the active partition in flight. Or am I wrong?
This doesn't seem right. We could just refer to the ID of the active topic and use that value.
Is this assumption correct? For example, hdfs://localhost:8020/accumulo/tablets/2a3/src/main/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema.java:[183] [ERROR] } catch (Throwable t) { throw new RuntimeException(t); } }
Is this assumption correct? For example, hdfs://localhost:8020/accumulo/tablets/2a3/src/main/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java/org/apache/abref/data/index/DataSchema/java
Is this check necessary?
should be protected.
should be private.
should be set to true
"You do not have any buckets" or use a different encryption scheme.
"You do not have any buckets" or so should be a constant somewhere?
"You do not have any buckets" or so should be a constant somewhere.
let's drop this if and use mw.lengthLimit()
mapper should be changed to use generic type.
mapper[ --> signature]
Could you please rename x to something more meaningful?
Double x = wrapperClone.getX(); is redundant.
Double x = wrapperClone.getX(); is enough.
Consider verifying that the blob name is no longer set. I.e., blobName is not set, but blobName is not, or blobName.
Consider using the blobName instead of the hard-coded string here.
Consider using the blobName instead of the hard-coded string
Would the new Path, FIles API be easier to use than the old File API?
Would the previous tests be easier to use the old File API, File API?
Would the previous tests be easier to use than the old File API?
getUserIdIfExternal()?
getUserIdIfExternal()? Optional.ofNullable(getUserId()) : Optional.ofNullable(getUserId());
getUserIdIfExternal() is always null, what's the benefit of Optional.empty()?
Note that this should probably be (int) channel.get().
Note that this should probably be (int) channel.get() here.
What does this mean? Should we expose it to the first read through the network layer?
Don't you think you should introduce a ChangeListener interface?
Don't we need this?
Don't think we should cancel the service on the result.
Is it OK to change content to int here?
Is it OK to change content to int?
it may be makes sense to move content to UIObject class
This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though shutdown() is true.
This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though shutdown() is called.
This can be replaced with CollectionUtils.filter(streamInProgress.compareAndSet(false, true)).
@xupyprmv I think it would be nice to have something like WFieldLayout.add(Message) on the panel.
@Christopher-Chianelli I think it is easier to read than WFieldLayout.add(messages);
@xupyprmv I think it would be nice to have something like WFieldLayout.add(Message) instead of adding the buttons.
I think this should be protected.
here too, should be this.LibraryAliasGenerator(
here too, should this be the constructor?
This should return an immutable collection.
This should return an immutable set.
This should return an immutable copy of the collection.
wouldn't it be better to have a class (JobServicesClient) constructor as this class is the only class that needs to be loaded?
wouldn't it be better to have a class (JobServicesClient) constructor in the JobService?
wouldn't it be better to have a class (JobServicesClient) constructor available and use this one from the actual class?
suggestion try (InputStream in = new FileInputStream(source)) {
suggestion try (OutputStream out = new FileInputStream(source)) {
Should this be public?
Should this method be private?
Ok, I think this method can be private.
Ok, I think this class could be "public".
suggestion if (StringUtils.isNotEmpty(upload)) {
suggestion if (StringUtils.isNotEmpty(upload)) {... }
suggestion if (StringUtils.isNotEmpty(upload)) {...
You can just use java.util.ConceptService.getConceptService()
You can use java.util.concurrent.atomic.AtomicLongJob#observeOn.
You can use.getConceptService()
suggestion "Removes all {} brackets around words.");
Again, "Removes all" -> "Removes all"
Again, "Removes all" -> "Removes all", "
this sysout?
this System.out?
this System.out
Why do you pass the clazz to this method instead of simply passing it to the method?
Why do you pass the clazz to this method instead of simply passing it to method?
Why do you use the String version of createAllFromJson(Class), which is the same in your opinion.
I think this should be WARN or even INFO.
I think this should be in the finally block, otherwise the exception will be thrown in the super implementation
I would rather propagate this exception as a proper log.
Why do we have this constructor public?
Why do we need this constructor?
Why do we have this public?
No need to use else here.
No need to use else on the same line.
No need to use else on the right.
Consider using parameterized logging instead of string concatenation.
Consider a parameterized logging here.
Consider using parameterized logging
should be more specific, like "java.version"
should be more specific, like "java.version" -> "java.version"
should be more precise, like "java.version"
Shouldn't this rather be synchronized?
Shouldn't this just be synchronized?
Shouldn't this do something in the else block?
A public method without a public modifier is a good idea.
A public method doesn't seem to be used anywhere.
A public method doesn't seem to be visible.
This line is not necessary.
This line is not testing anything.
This line is unnecessary.
does this become e.g. long with value?
does this become e.g. long with one liner?
do we want to keep the other string?
should this be true?
should this be return true?
should this be return isReady();
Will need to be a variable outside the loop? I don't see a reason.
Will need to be a variable outside the loop? I don't see a point where this can be null
Will need to be a variable outside the loop? I don't see a point in keeping it.
remove unnecessary blank line
remove 'if'
remove unnecessary loop
As this is driven by the user I am not sure whether the plugin name is the plugin name.
As this is driven by the user I am not sure whether the plugin name is unique or not.
As this is driven by the user I am not sure whether the plugin name is unique.
This test will always evaluate to true or false if there is no method with the same name.
This test will always evaluate to true or false if there is no method with the same name
This test will always evaluate to true or false if there is no method with the same name. I think it's safer to test that there is only one test with a different class name and only test the two.
@vilchik-elena Why remove this line?
@vilchik-elena Why remove this check?
@vilchik-elena Why remove this case?
This is the same as in MILLIS_PER_DAY
This is the same as the method above.
Java 8 is allowed.
Do we want to assert here that the initial scan is valid before we start processing? I think it should be sufficient to assert the state in the entity itself (if not, and if not, don't think we should).
Do we want to assert here that the initial scan is valid before we start processing? I think it should be sufficient to assert the state in the entity manager
Do we want to assert here that the initial scan is valid before we start processing? I think it should be sufficient to assert the loaded model in the entity (if not, and is not enabled).
It's useful to keep a binary type when SqlSocket.binaryType is not null, and it will throw NPE when binaryType is not as null.
It's useful to keep a binary type when SqlSocket.binaryType is not null, and it will throw NPE when binaryType is not available.
It's useful to keep this patch as it was originally written.
Better to use SerializedSize() here
Better to use SerializedSize()?
Better to use SerializedSize()
How about adding a log statement here?
How about using the constructor with a default value?
How about using the _only_ class loader?
this is going to be breaking in the future for now?
this is going to be breaking in the functionality of the test, you should separate it to another method.
this is going to be breaking in the functionality of the test, we should separate it.
CompletionException should be thrown from supplyAsync
CompletionException is very Raw type, should be CompletionException
CompletionException is very generic and may be thrown by rollbackLocks()
isEmpty() should be checked for null and return empty if not.
isEmpty() should be checked for null and return empty if it is empty
isEmpty() should be checked for empty before the return.
Can you confirm that [System.out.println](<LINK_0> is what we want?
Can we remove this System.out.println?
Can you confirm that [System.out.println](<LINK_0> is not necessary?
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
Not sure whether worth doing, but since the only usage is "DownloadImageManager", it is possible to remove "public".
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible.
Style Nit: remove this.
This is a bit pedantic, but I plan to work on Drops wherever possible. It's more readable than this.
Style-nit: remove this.
Or have some more strict semantics than this one.
Or have some more reactive type cast: <LINK_0>
Or have some more reactive type cast?
suggestion return new StringBuilder(requireNonNull(filename));
suggestion return new StringBuilder(requireNonNull(filename).append(count));
suggestion return new StringBuilder(requireNonNull(filename).append( count));
I'm not sure what this method is trying to be. How about making isGenerative() private and having it return a boolean?
I'm not sure what this method is trying to be. How about making isGenerative() private?
I'm not sure why we should be using the equals() method, and not a java constant
As mentioned above, do we need to change this method?
As mentioned above, do we need to maybe change this to themeFolder.matcher(filename).find();
As mentioned above, do we need to maybe change this to themeFolder.matcher(filename).find()
the same as above, use Collections.emptyMap()
the same as above, can use buckets instead of LinkedHashMap
the same as above, can use buckets instead of LinkedHashMap?
Should probably be StringUtils.defaultString()
Should be StringUtils.defaultString()
Should probably be StringUtils.defaultString() here
Another log message would be better. Also, the exception message doesn't tell much about what the problem is.
Another log message would be better. Also, the exception message doesn't tell where the problem happens.
Another log message would be better here.
Is it necessary to use this feature? What is the reason for this?
I think this should be 204ExceptionMapper
Is it possible to use this way?
Instead of throwing a RuntimeException, why not have the method throw Throwable?
Instead of throwing a RuntimeException, couldn't we just have the constructor take date and SimpleDateFormat as parameter?
Instead of throwing a RuntimeException, couldn't we just have a method in Date?
Float.BYTES
Floats.BYTES
Float.BYTES?
This null check is not needed
return int?
return null
DEFAULT_LOADING_THROTTLE_LIMIT?
we should preserve previous order by default, since nothing else is setting it.
any clue on how this number was chosen?
Can this be called from the onPermissionGranted() instead?
Can this be called from the onPermissionGranted()?
Can this be called from the onPermissionGranted?
What is the purpose of this. With this change?
What is the purpose of this. With this one?
What is the purpose of this change?
You could create a new method for this, and use that in both places.
You could make this method :private and use a static method from guava.
You could create a new method for this.
would it be sufficient to test the call to isCurrentThread()?
would it be sufficient to print the height of the parent?
would it be sufficient to test the call to isCurrentThread()?
it seems like it would be better to use a regular for loop here, and remove lastSentStored.get()
it seems like it would be better to use a regular for loop here, and remove lastSentStored.get().iterator()
it seems like it would be better to use a regular for loop here, and remove lastSentStored from the variable?
warn instead?
warn instead of info?
warn instead of info.
I think the restart after the class is run should be restored.
I think the restart after the class is run should be restored before the test run (before deployment)
I think the restart after the class is run should be restored before the test starts.
Does this need to be public?
It's better to return a ContainerInfo directly.
It's better to return an exception.
I don't understand this change. the doc says "Creates a new ByteBufInputStream(data, null)" is not necessary here
I don't understand this change. the doc says "Creates a new ByteBufInputStream(data, null)" is not necessary here.
I don't understand this exception message. it says "entry content can be a recipe of stream"?
This can be package private, no?
This can be package private, otherwise it will be used in multiple places
This can be package private
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0> Please use fail(): <LINK_1>
Let's rename "ignore" to "ignired" Please use fail();
Not necessary.
Not necessary to have a new line.
Not necessary to have a new builder for this.
it seems that logic should be in presenter but not the presenter
it seems that "Given listPageItemHolder" is no longer used in this class, so it should be removed and this should be in NotificationListFragment, right?
it seems that "Given listPageItemHolder" is no longer used in this class, so it should be removed and it should be in NotificationListFragment.
To be safe, should check isEmpty() first.
To be safe, should this be!trigger.getTriggerConfigURL()
To be safe, should not check isEmpty() first?
Useless extra parenthesis
This is not necessary as it's just a random instance size.
Useless extra parentheses
There is actually a lot going on in this code, but I don't think we need to define it into a variable at all. You can use it in the for loop at this point.
There is actually a lot going on in this code, but I don't think we need to define it into a variable at all. You can use it in the for loop.
There is actually a lot going on in this code, but I don't think we need to define it into a variable at all.
Consider to use a builder for this.allowedSchemes.add(new String())
Consider this.allowedSchemes.addAll(new String()).toLowerCase(Locale.ROOT).toLowerCase(Locale.ROOT));
Consider this.allowedSchemes.addAll(new String())
This is the same as in the other files, why is this needed here?
This is the same as in the other files, why is this needed?
This shouldn't be the responsibility of invoking the decoder, as it may be anything other than debugging.
log the object idP
log.debug message
log
also check this
also remove this
also remove this method
Assert.notNull(persistTo, "ReplicateTo must not be null.");
Assert.notNull(persistTo, "ReplicateTo cannot be null.");
Assert.notNull(replicateTo, "ReplicateTo must not be null.");
we should consider to add a null check here too
rename to variable
we should consider to add a null check here
Why are you catching and ignoring? what's the advantage of ignoring?
Why are you catching and ignoring? Isn't this the same as that on line 79?
Why is this catching and ignoring? Isn't this the usual exception?
Not needed anymore but is there a chance it would be possible to rearrange the try block as follows? try { } catch (JSONException e) { Log.e(TAG, "Failed to add GeoJson layer", e); return; } catch (JSONException e) { Log.e(TAG, "Failed to add GeoJson layer", e); return; } } catch (JSONException e) { Log.e(TAG, "Failed to add GeoJson layer", e); return; } Then probably the code isn't needed anymore.
Not needed anymore as this is done in line 111
Not needed anymore as this is being done in line 111
final?
final
static?
You can use Objects.hashCode() to check hash code.
You can use ITuple instead of ITuple
You can use Objects.hashCode() to check hash codes.
:skull:
:ant: Space after comma.
:ant: Space before {
This should be a setRetainInstance(true) after we have the @Override annotation. This should be a setRetainInstance(true) after we have the @Override annotation.
This should be a setRetainInstance(true) after we have the @Override annotation. This should be a setRetainInstance(true) if we are going to use a different value for this.
This should be a setRetainInstance(true) after we have the @Override annotation. This should be a setRetainInstance(true) if we are going to use a default value for this.
we should not increment the success counter here. It will be incremented on every message on the handler.
we should not increment the success counter here. It will be incremented on every message on the handler. You need to have a boolean that is set to null.
You need to increment the successCounter before getErrorCounter().increment()
Minor: can we make this constructor private?
Minor: can we inject this in the constructor?
Minor: can we inject this in the constructor instead?
Any reason not to use the function call instead of this: return!MinecraftForge.EVENT_BUS.post(new LivingKnockBackEvent(target, entity, network, ratioX, ratio), ratio);
This could be changed to use the other onLivingKnockBack method, as you now have the EVENT_BUS call.
Likewise.
Let's use ImmutableList.Builder<HiveSplit> splits = ImmutableList.builder();
Let's use ImmutableList.Builder<HiveSplit> splits = new ArrayList<>();
Can you make this static?
submit?
inject this?
inject this directly
Please get the reportable from the REPORTING_DONE case.
Please get the reportable from the log.
Please get the reportable from the FINE.
This seems to be changing if you refactor'metadata'.
This seems to be changing the position of the file.
This seems to be changing the position of the 'UTF' part what was before
please add new HelpTag and HashName (as in StorageListModel)
please add new HelpTag and HashName (as in StorageFormatStatisticNames)
please add new HelpTag and HashName (as in StorageFormatStatisticType)
suggestion processInstanceIds.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceId, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance(processInstanceId));
suggestion processInstanceIds.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceId, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance(processInstanceId));
suggestion processInstanceIds.stream().filter(processInstanceId ->!hasParentProcessInProcessInstanceList(null, processInstanceId, processInstanceIds)).forEach(processInstanceId -> abortProcessInstance(processInstanceId));
This should check to make sure that notificationUUID is not null before attempting to create a job.
This should check to make sure that notificationUUID is not null before attempting to get a NPE.
This should check to make sure that notificationUUID is not null before attempting to create a job created notification.
requireNonNullElse is better
requireNonNullElse
check for empty array
Wouldn't it be better to use the previous variant as this: java Topology.builder().addComputation(() -> createComputation(size, timer), getIOs()).build());
Wouldn't it be better to use the previous variant as this: java Topology.builder().addComputation(() -> createComputation(size, timer), getIOs()).build();
Wouldn't it be better to use the previous variant as this: java Topology.builder().addComputation(() -> createComputation(size, timer), getIOs()).build());
Do we want to make this configurable?
Per IRL, I meant to say uploadApiStart().
Can we make this configurable?
I'm not sure this is good. Cosmetic: Could you please, follow the project's coding convention?
I'm not sure this is good. Cosmetic: Could you please make this a method (like appendDependencies())?
I'm not sure this is good. Cosmetic: Could you please, follow the project's coding convention for new code? (And remove this.)
suggestion return supplier.get();
then(ignored) -> supplier.get();
then(ignored) -> supplier.get()
don't think we should catch exceptions here as well, as we find the possibility to call updateWordArtifacts without any more information.
don't think we should catch exceptions here as well, we should let the caller handle the exception
don't think we should catch exceptions here as well, we should let the caller handle the exception -- we can catch them also as a fosee ServiceUtil.
for(String buffer : brRef.readLine())
Formatting.
should be tried with this
can this be removed?
should this be public?
I have a better idea to remove this case
Can we have a fail() after this? It also makes the test easier to read.
Can we have a fail() with a message instead of fail()?
Can we assert the exception message?
ImmutableList.of()?
ImmutableSet.of()?
ImmutableSet.of() makes the body more readable
This is a bit different from the line above, should we remove the high water-mark handling code that takes a long?
This is a bit different from the line above, should we remove the else?
This is a bit too long, please use the ternary operator
putIfAbsent returns a view of the value of the value, so remove() will be called at the end.
putIfAbsent returns a view of the value of the value corresponding to the ConcurrentHashMap.
putIfAbsent returns a view of the value of the value corresponding to the ConcurrentHashMap, which is not the case.
Why not just do the inverse of the two lines above this?
Why not just call Conditions.checkNotNull(attributeType, "attributeType");
Why not just call the method in the class?
This should throw an exception if the attribute is null.
This should throw an IllegalArgumentException.
This should throw an exception.
Change the text to "Remove is not supported"
Change the "protected" method to private.
Change the text to "Remove is not supported".
suggestion return Version_Field_Size_In_Bytes + Total_Size_Field_Size_In_Bytes + Total_Size_Field_Sizes_In_Bytes;
suggestion return Version_Field_Size_In_Bytes + Total_Size_Field_Size_In_Bytes + Total_Size_Field_Sizes_In_Bytes + Relative_Offset_Field_Sizes_In_Bytes;
Please put these magic numbers into constants.
Collections.emptyMap() will do the same thing as you did below.
Collections.emptyMap() would be better here.
Collections.emptyMap() will do the same thing, please use Collections.emptyMap()
Why? Is it better to use getActiveHost()?
Why do we need it? Are you planning to use it on a higher level?
Why? Is it better to use getActiveHost() instead of getting it twice?
rename to image
rename from image
rename?
Shouldn't the conditional be at the end of the if block?
Shouldn't the conditional be reduntant with the ifPresent?
Shouldn't the conditional be at the end of the if block? Perhaps the ifPresent would be more readable.
Can we use TIME_FORMAT instead of "HH:mm:ss"
This should use TIME_FORMAT instead of "HH:mm:ss"
This also should use TIME_FORMAT instead of "HH:mm:ss"
PullRequestSCMRevision should be changed to new PullRequestSCMRevision( prMerge, "8f1314fc3c828531212473c11828531212473db98f53a3553406f11c24d473db98f53a3553c (and similar line before).
PullRequestSCMRevision should be changed to new PullRequestSCMRevision( prMerge, "8f1314fc3c828531212473c11828531212473db98f53a3553406f11c24d473db98f53a3553c (and six).
PullRequestSCMRevision should be updated.
Why sync?
Why synchronized?
Why do you need to synchronize here?
The constructor can be package private.
The constructor can be private.
I guess this should be called constructor.
return INSTANCE_SIE;
return INSTANCE_SIE + 1, this is unused
This method is unused.
No need to use URI.create
No need to use URI, just String is enough
No need to use URI, just String will work
No need to make changes in this review.
No need to make it final.
No need to make changes in this method.
I would not call the leaderListener outside the lock since it is already checked and then the leader listener will handle the error.
I would not call the leaderListener outside the lock.
I would not call the leaderListener outside this block since the risk of making the actual LeaderRetrievalException.
nit: This exception message is not needed
nit: This exception message is not needed.
nit: This message has not include "true"
I'm not sure that we want to add this property for StorageHandlingCommandBase. If there is no storageDomain, it should be added to StorageHandlingCommandBase.
I'm not sure that we want to add this property for StorageHandlingCommandBase. If there is no storageDomain, it should be provided and the user should be able to override it
I'm not sure that we want to add this property for StorageHandlingCommandBase.
Do we need to check if refreshJob is null here?
Do we need to set refreshJob to null here?
Do we need to check if refreshJob is isCancelled here?
Ternary if? Seems like a reasonable check.
Should be isBlank()
Ternary if?
Why do you need to reset mActiveNetwork to null check this?
Why do you need to reset mActiveNetwork to null check?
Why do you need to reset mActiveNetwork to null check? ConnectivityManager should be always null.
This is why I missed,  aspects.size()
This is a private method, it will be thread safe
This is why I missed, this will happen on the VariantWalker.
Is this really needed? If so, this returns false.
Is this really needed? If this is the case insensitive command, then the constructor is not taken into account.
Override.
Nit: Wouldn't it be better to validate that the variable is actually created and then re-used?
Nit: Wouldn't it be a good idea to validate that the variable is actually created and then re-used?
Nit: Wouldn't it be a good idea to validate that the variable is actually deleted when this test is running?
Couldn't you throw the exception if the status is not DOWNLOADED?
Couldn't you get the same exception if you do this?
Couldn't you get the same exception if you do this? :)
What is the purpose of this line? (even though you don't have the special case)?
What is the purpose of this line? (or line 89)
What is the purpose of this line? (even though you don't fully understand it, it isn't even needed)
With setPartitionKey, partitionKey and partitionKey are the options that are passed to upsertItemInternal. If we do not have to pass PartitionKey.None then we should pass in the options here.
With setPartitionKey, partitionKey and partitionKey are the options that are passed to upsertItemInternal. If we do not have to pass PartitionKey.None then we should pass in the requestOptions here.
With setPartitionKey, partitionKey and partitionKey are the options that are passed to upsertItemInternal. If we do not have to pass PartitionKey.None, we should do the same here.
better to use constant java.util.List<AnalysisResult> s = scheduleBuildAndAssertStatusForBothTools(project, s.txt); assertThat(s).hasErrorMessages();
better to use constant java.util.List<AnalysisResult> s = scheduleBuildAndAssertStatusForBothTools(project, s.txt); s.add(s);
Again, we should use constant for this
I'd use a different puncher store with a list of replicas. ERO which we use in this case.
I'd use a different puncher store with a list of replicas. ERO and then use it to avoid changing the behavior of the two tests to use it since it's the default.
I'd use a different puncher store with a list of replicas. ERO and then use it to avoid progress.
Because there is only one argument, we can pass workerMetrics instead of an object array.
Because we have only one argument, we can pass workerMetrics instead of an object array.
The arguments are switched.
We must use Exceptions here as well.
We must be careful here, because Exception is actually thrown when a container isn't found.
We must be careful here, because Exception is not a runtime exception.
Missed port value.
Missed port
Missed the port
Are you sure to store it in a constant?
Are you sure to use TimberClient.waitFor?
Are you sure to use 000Diul?
s/i/i/
Also I'd prefer to keep the 0 as a constant and use it wherever possible
Also I'd prefer to stay consistent and if possible to avoid it
You can use directly return anyMatch(event -> event == ignoreKeyEvent)
You can just return the result of this method directly
You can use directly return anyMatch() instead of this 'if'.
Is there a better way to do this without checking patternsForStop.containsEntry?
Is there a reason to make this public?
Is there a reason to override this?
Use getType() instead of toString() when creating the type.
Use getType() instead of toString() when creating the object.
Use getType() instead of toString()
please set the ApplicationMode when done in the execute method.
please set the ApplicationMode here as well.
please set the ApplicationMode when done in the update() method.
@fanifieiev the same above.
@fanifieiev Let's use RsEmpty.
@fanifieiev Let's declare it inline
It doesn't look like this is necessary. If RestApiException is thrown, the RestApiException and the RestApiException are not thrown.
Missing test for e.email.equals(email).
Missing test for e.email.equals("email") before this change.
This should probably be "protected" or "protected"
This should probably return true;
This should return true;
if (!decisionTableIsEditable || cTableHasEditableColumns) { enableColumnsPage(); }
if it's a weird state, it sounds like it has a clear meaning.
if it's a weird state, it sounds like it has a useful method is something else.
I'm not sure I like the idea of making this nullable. It seems like it's fine for me to keep the same behaviour as before, but if you think it can be made more restrictive I think it should be done like this in a separate patch.
I'm not sure I like the idea of making this nullable. It seems like it's fine for me to keep the same behaviour as before, but if you think it can be made more restrictive I guess.
Can we keep this nullable?
execPath = null?
execPath = null is redundant.
Not sure if this is necessary.
Don't wrap any of these things in a new Vector, just return Collections.unmodifiableList(actions)
Don't wrap any of this things in the instance variables, you can just return Collections.unmodifiableList(actions);
Don't wrap any of these things in a new Vector, just return Collections.unmodifiableList(actions);.
@bgeVam why do we need this variable? I think the test should just fail because of the exception variable declaration
@bgeVam why do we need this variable? why not just inline it in the constructor?
@bgeVam why do we need this variable? I think the test should just fail because of the exception variable.
I don't think it is possible to have a user.get() method in this case, but if it is then it should be the same class. To be concrete, I would suggest to have a separate method for this, like String getUser(final Optional<User> user, final Version entry) and use it in the if.
I don't think it is possible to have a user.get() method in this case, but if it is, then the contract might be confusing. I would suggest to have a separate method for this, like your new method.
I don't think it is possible to have a user.get() method in this case, but if it is then it should be the same class. To be concrete, I would suggest to have a separate method for this, like String getUser(final Optional<User> user, final Version entry) and have this method be static.
You should probably call super.read() too, to avoid doing a double copy.
You should probably call super.read() too, to avoid doing this.
You should call next() too, to avoid doing this.
Duplicate in both createSubject and createSubject methods. Consider to refactoring into helper method.
Duplicate in both createSubject and createSubject. Consider to refactoring into helper method.
Duplicate in both createSubject and createSubject method. Consider to refactoring into helper method.
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one every time
Shouldn't this be a field so we don't have to create one each time?
On START_DATE, the discount factor for start date should be 1.
On START_DATE, the discount factor for start date should probably be 1.
On START_DATE, the discount factor for start date should also be 1.
The same can be applied to all List()() calls.
The same can be applied to all List() methods - you can have a stream directly
The same can be applied to all List() methods - once you have a List.
These 3 lines should be indented with tabs.
These 3 lines should be "get("q")
Can be removed.
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
minor suggestion: It is perhaps more readable to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
minor suggestion: It is perhaps cleaner to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
Why not get rid of this and use getProperty?
Why removed?
Why not get rid of this and use getInputSteam()
What's the reasoning behind this vs. setting the limit of the session to zero?
What do you think about changing this to the following? java LOGGER.entering(totalSessionsCompleted).maxSessionsCompleted();
What's the reasoning behind this call? It seems the exception message is misleading.
Would be awesome to rename it to something more descriptive like? java.wikia.com/szl/d/
Would be awesome to rename it to something more descriptive like "searchDiscussionsPost" or similar
Would be awesome to rename it to something more descriptive like? java.wikia.com/szl/d/");
This expects a localization key.
This expects a localization key
getUsage(...) expects a localization key
@Override is missing
UnsupportedOperatorContext.class?
@Override is missing.
Why do we need this?
Why do we need these lines?
Why do we need to explicitly set the getSessionsStatement fields?
This check is redundant in the instanceof and the check is already checking the separators.
This check is redundant in the get()
This check is redundant in the instanceof and the check is already checking if list.size() == separators.
Same here - you can remove the return statement.
Same here - you can remove the final keyword.
Same here - return directly.
@carlosmiranda we don't need this Visibility since you're already using Visibility in the line 98.
@carlosmiranda we don't need this Visibility since you're already using the Visibility in the previous line.
@carlosmiranda we don't need this variable
This DateTime.now() can be replaced with the latter because it's already immutable.
This is creating a new DateTime, can't you just use the original one?
This DateTime.now() can be made private
Similar to the one above: java logger.error("Barometer enable failed", e);
Similar to the one above, it would be good to log the error and continue here in a else case.
Similar
Can be transformed into an if statement. I don't think we need this code.
Can be transformed into an if statement.
Shouldn't this be handled?
L4-java already provides a proper class.
L4-java already provides a proper solution.
L4-java.jar
Maybe change this to  logging.debug?
Maybe change this to  LOGGER.debug
Maybe change this to  LOGGER.debug?
Same here, misspelling.
Check for value == null, since startsWith() returns "mvel: ".
Check for value == null, as above.
you can collapse these 2 lines
I would collapse these 2 lines
I would collapse these 2 lines into 1
style nit: no braces around single line blocks
style nit: no braces around single line block
else not necessary...
Needs to be in finally - we might get interrupted.
Needs to be in finally - this.active = false.
Needs to be in the finally - we might get interrupted.
Can you put this in the try clause?
Can you use java.nio.Files.delete() here?
suggestion logger.warning("Unable to check file: " + e);
It is sufficient to declare this class as final.
It would be nice if we could check this class is not present, as it is not required.
It would be nice if we could check this class is not initialized.
Why not add the tab to the page?
Why not add this method to PageFragment?
Why not add this method to the pageActivity?
Better to use constant for empty strings?
Better to use constant?
Better to use constant for empty strings
We are using accent90. It appears that the fact that accent90 is missing is the same concept as the fact that accent90 passed to the resourceUtil.getThemedColor() method. In my opinion, the ContextUtil.getThemedColor() should be replaced with a ContextUtils.getThemedColor() method.
We are using accent90. It appears that the fact that accent90 is missing is the same concept as the fact that accent90 passed to the resourceUtil.getThemedColor() method. In my opinion, the ContextUtil.getThemedColor() should be replaced with a Context.getThemedColor() method.
We are using accent90. It appears that the fact that accent90 is missing is the same concept as the fact that accent90 passed to the resourceUtil.getThemedColor() method. In my opinion, the ConfigValues class could have fields in the resourceUtil directly, without having to put this line here.
This is a breaking change I suppose.
This will throw a NPE if it was not part of the contract
This will throw a NPE if it is not part of the contract
We should add: java assertFullMapping(properties, expected); FileBasedAccessControlConfig expected = new FileBasedAccessControlConfig().setConfigFile("/test.json").setRefreshPeriod(Duration.valueOf("1s"));
We should add assertFullMapping(properties, expected) here if possible.
We should use [TimeUnit](<LINK_0> instead of [here](<LINK_1>
ah, yeah I'm not sure about this. It's a good idea to use findElements() only for interceptors, with getResponse that returns a EmptyMessage. Its less efficient than isPresent() and isPresent()
ah, yeah I'm not sure about this. It's a good idea to use findElements() only for interceptors, not for any other code.
ah, yeah I'm not sure about this. It's a good idea to use findElements() only for interceptors, not for any other logs. So the interceptors might be not supported by this class.
Better to wrap other RuntimeExceptions with NuxeoException.
Better to wrap other RuntimeExceptions with NuxeoExceptions.
Better to wrap other RuntimeExceptions with NuxeoException. Not only RuntimeException if someone may just want to.
Use this.key
Use this.key.
Use this.key to pass in
If you keep these increment, the switch will never reset the value.
Why increment at the end instead of re-rejecting message?
Why increment twice?
RealmCacheType.values()?
RealmCacheType.values().size()
RealmCacheType.values()
rename to container
rename to pack
rename
we should handle the exception rather than printing the stack trace
Won't work on Windows.
we should handle the exception rather than printing the stack trace.
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
Do we actually call init multiple times on a single thread? Just curious.
Do we actually call init multiple times on a different thread? Just curious.
If this is the refresh period, it would be good to log it somewhere, rather than just the IOException.
If this is the refresh period, it would be good to log it here.
If this is the refresh period, it would be good to log it.
Can this throw an exception?
Better to return accessToken.getPlainText() instead of getting article name.
Can we change this to: return accessToken.getPlainText();
This line is unnecessary. There is a default constructor that takes the workspace name.
This line is not needed. There is a default constructor already.
This line is not needed. There is a default value for the project.
Let's use the more descriptive table name than call applicationForKey and applicationForKey
Let's use the more descriptive field name rather than String.format
Let's use the more descriptive table name instead of hardcoding one
This should throw only if a file or file name is not found. Should throw from this method.
This should throw only if the file or file name is not found. Should use ContextUtils.getSafePath() here.
This should throw only if a file or file name is not found. Should use ContextUtils.getSafeText() which returns true.
Should be just this.marketName = name
Should be just this.marketName = name;
Should be final
can you also remove the "!" from if.
can you also remove the "!" from if statement
obsolete?
What should be the expected scenario? Is there any exception you can say?
What should be the expected behaviour?
What should be the expected scenario? Is there any exception you can do here?
If this is a debugging check, should we throw a some kind of exception?
If this is a debugging output, should we throw a some kind of exception?
If this is a debugging check, should we throw a some sort of exception?
Do we have a test for this? Breaking it up to uberfire.
Do we have a test that includes legacy reporting name?
Do we have a test for this? Breaking it out into a map?
nit: we can probably write this as return availableRanges.left.stream().anyMatch(token -> range.contains(token));
nit: we can probably write this as return availableRanges.left.stream().map(x -> range.contains(token)).collect(Collectors.joining(token));
nit: we can probably extract these to a method getAvailableRanges.
return.block() here, since the method does not throw an exception
return.block() here instead of blocking
return.block()
Should this be a constant?
Should this be a new TooltipTimeException?
Should this be a new TooltipTimeDialog?
Instead of comparing and hashCode, use Objects.hashCode(logEntry) instead.
Instead of comparing and hashCode, use Objects.hashCode(logEntry) instead of this.logEntry.hashCode().
Instead of comparing logEntry with logEntry it should be done by Objects.hashCode().
nit: this could just be if (logger.isDebugEnabled()) {... }
nit: this could be removed if we make this method throws an exception.
nit: this could just be done in makeQualified(path)
super.testEncryption() can be removed.
super.testEncryption() is missing.
super.
could be "warn"
could be "message":
could be final
invert the if condition
invert the condition
invert the logic
the'model.getName()' is redundant here, please remove this line
done in setup method
the 'if' is redundant, please remove this line
Likewise.
Likewise. If there's no server, it should fail.
Likewise..
return task == null? null : task.getSchedule();
return task == null? null : task.getSchedule()
add null check
please use WizardActionFactory.createAction() instead of replacing it.
please use WizardActionFactory.createAction() instead.
please use WizardActionFactory.createAction() instead of replacing it with extension
looks like a good candidate for a method reference.
looks like a good candidate for a similar method, it is much more readable
looks like a good candidate for a similar method, it is used to check whether the modifiers is equal to FINAL
Maybe add an assert to verify the message message what failed to verify?
Maybe add an assert to verify that the message contains a non-default connection on the annotation.
Maybe add an assert to verify that the message contains a non-default connection on the entity
what about a few lines above: if (library == null) { throw new IllegalStateException("A Reactive Streams Library has not been specified"); }
what about a few lines above: if (library == null) { throw new IllegalStateException("A Reactive Streams library has not been specified"); }
don't know if that should be null
You can use the new validateVersion(long version) method to validate the version.
You can use the new validateVersion(long version) method to validate the version
You can use the new validateVersion(long version) method to validate the version, with the message "Invalid version."
Does this need to be a public static String.format?
Does this need to be a public static String?
Does this need to be a String.format?
this will be executed in the end
this will be executed in the end of the loop
this will be an infinite loop
if you just want to be consistent with attachable, why not just use Objects.equal()?
if you just want to be consistent with isAttachable, why not just return false here?
if you just want to be consistent with attachable, why not just use Objects.equal()?
no! I would have put this in a field
no!
why not use the field directly?
The error message is a duration of zero. Would it be better to use checkState?
The message can be reused here.
The error message is a duration of zero.
This is OK to kill a scheduled task, but return the error message.
This is OK to kill the sender not the one before throwing an exception.
This is OK to kill a scheduled task, but return the error message from killMessage and return it.
Should this be public?
Lets make this private and deprecate it
Should we make this private?
this log message is not accurate.
this log message is incorrect.
this log message is not correct.
Could remove these lines, the authorizationHandler.setProperties(properties) call is inside the constructor
Could use IllegalArgumentException instead.
Could remove redundant code
use try-with-resources for FileReader
try with resources.
Reader is not close.
This should be done in the constructor, rather than here.
This is not necessary, since the @Mock method already checks it.
This should be done in the constructor.
This is usually bad practice. Using a constant here is cleaner, since it is a matter of personal taste.
This is usually bad practice. IllegalArgumentException can be used to indicate the user can't close.
This is usually bad practice. Using a constant here is cleaner, since it is a matter of personal preference.
:disappointed:
: lambda?
: lambda? :)
Is this really needed? Since the configuration isn't being passed into the request itself, it makes sense to have ChannelContext instance. Thus, the question is why I would prefer to have ChannelContext instance in the first place.
Is this really needed? Since the configuration isn't being passed into the request itself, it makes sense to have ChannelContext instance. Thus, the question is why I would prefer to have a ChannelContext instance in the first place.
Is this really needed? Since the configuration isn't being passed into the request itself, it makes sense to have ChannelContext instance. Thus, the question is why I would prefer to have ChannelContext instance in the public APIs.
Do you want to put the 2 in a constant in startGridsMultiThreaded 3?
Do you want to put the 2 in a constant or something here?
Do you want to make sure that startGridsMultiThreaded 5 is executed in parallel?
IronSource.isRewardedVideoAvailable() should be invoked on a separate thread.
"isRewardedVideoAvailable" should be invoked on a separate PR.
IronSource.isRewardedVideoAvailable() should be invoked on both the pre-action and the survey.
why are you removing testDirectoryServer.stopLdapService();?
Why are you removing testDirectoryServer.stopLdapService();?
Why are you removing the test directory server after stopping the test?
I'd put this into an else clause.
I'd put this into an else statement.
I would add an assertion to see if the result is not null.
Note that areDuplicatesAllowed() is private in the original test class, so it can be moved to the @Before method. Also, I don't see why it's outside of this test class.
Note that areDuplicatesAllowed() is private in the original test class, so it can be moved to the @BeforeTest class.
Note that areDuplicatesAllowed() is private in the original test class, so it can be moved to the @Before method. Also, I don't see why it's moved to the end of this test class. If it is private, it's even better to have a common test cases for it.
Let's make this private. I understand that it's only used from the class, but it's private.
Let's make this private.
return key.name();
same question as before
same consideration as before
same consideration as in the skipFields()
> "value", "noSelection" [](start = 30, length = 16) can this be renamed to something like "noSelection"?
> "value", "noSelection" [](start = 30, length = 16) can this be renamed to "value", "noSelection")?
Parameters should be "value", "noSelection".
I am not sure if we want to change this string. If not, I would use the view identifier only if it is marked as temporary.
I am not sure if we want to change this string. If not, I would use the view identifier only if it is temporary.
I am not sure if we want to change this string. If not, I would use the view identifier as the message and add it to the message.
If you don't want to do this line: java V ep = computeIfPresentLocally(key, null_KEY_IS_NOT_ALLOWED); if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) { return ep; } // no need to add the null check.
If you don't want to do this line: java V ep = computeIfPresentLocally(key, null_KEY_IS_NOT_ALLOWED); if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) { return ep.getOrLocally(remappingFunction, remappingFunction); } return computeIfPresentLocally(key, remappingFunction);
If we do this line, we can erase the type.
Will this method need to be public?
Will this method need to be synchronized?
Will it cause boxing?
@maria-farooq Maybe we should differentiate the log message
@maria-farooq instead of hardcoding number, just -1
@maria-farooq instead of hardcoding the log, just return the Conference object?
Instead of a hack like this, maybe we need (or have) an "updatePersistentParameters()" method somewhere that could be called to set the Data in the constructor, and then set it to 0 in updatePersistentParameters()?
Instead of a hack like this, maybe we need (or have) an "updatePersistentParameters()" method somewhere that could be called to set the Data in the constructor, and then set it to 0 in updatePersistentParameters()
Instead of a hack like this, maybe we need (or have) an "updatePersistentParameters()" method somewhere that could be called to set the Data in the constructor, and then set it to 0 in onCreate.
Need to check if the URI exists here.
Check if the URI is null here.
Check if this method exists?
Why public?
why public?
Why are these private methods public?
Missing the part of shuffling...
Missing the part of the shuffling...
Missing part of shuffling...
This is wrong. Breaks it up to have only one path.
This is wrong. Breaks the test content, so it should be cleanuped.
This is not needed, right?
This is a bit confusing. :D (is it possible to go back to the left)
This is wrong. Cmd line arguments.
This is a bit confusing. :D
:regionInfo.getRegionName will throw a NPE if the regionInfo is not the same.regionInfo.getRegionName will throw a NPE.
:regionInfo.getRegionName will throw a NPE if the regionInfo is not the same.regionInfo.getRegionName will throw an NPE.
no: remove the "UnrecoverableException while closing "
given/ execute/ assert
solrJudgmentsServer.commit() should be renamed to just judgmentReindexingJob_ONLY_SC_JUDGMENTS_COUNT
solrJudgmentsServer.commit() should be renamed to just judgmentReindexingJob, no need to reindex it.
Are you sure this is what you want to do?
Are you sure this is the correct approach? Will this file get written to the same as the SMT?
Are you sure this is what you want to do? Will this file get written to disk?
You might want to consider data_PREFIX and data_PREFIX to be consistent with data_PREFIX and data_PREFIX.
You should put the value in data_PREFIX and data_PREFIX before encoding value.
You might want to consider data_PREFIX and data_PREFIX to be consistent with data_PREFIX.
I am not sure if we should default this to SimpleLexiMetadataSerdeFactory. I think the factory should be used here.
I am not sure if we should default this to SimpleLexiMetadataSerdeFactory. I think this would be better.
Could pass in the factory to avoid creating the SimpleLexiMetadataSerdeFactory.
can you move it into ConfigurableApplicationContext.run()
can you move it into ConfigurableApplicationContext.run()?
can you move it into ConfigurableApplicationContext.run()?
should be SIE_OF_LONG * 2
Should be SIE_OF_LONG * 2
should be SIE_OF_LONG + 1
This should be closed in a finally block.
This should be run on one line.
This should be closed in a finally block of it.
Just a nitpicking: would be useful to return an empty string, if there's no branch found
Just a nitpicking: would be useful to return an empty string, if there's no project defined.
Just a nitpicking: would be useful to return an Optional<String>, and check for null after isPresent check
This can be simplified: return poolSize == 0? 0 : HConstants.HBASE_CLIENT_IPC_POOL_SIE;
This can be simplified as: if (poolSize == 0) { return 1; } return 1;
This can be simplified as: if (poolSize == 0) { return 1; } return Math.min(1, poolSize.length);
m_truncationHandleHandle?
m_truncationHandle.toString()
m_truncationHandle.toString()?
This should be simplified to just: this.durableNonTxMode = durableNonTxMode;
This should be package-private, since it's not used by anyone
This should be package-private, since it's not used by anyone.
'this.' please change
'this.' please?
please check
Should be final
Should not this return an immutable list?
Should be final.
I'm not sure whether this should be mutedTopics.contains(message.getStream().getId() + message.getSubject()); or even Strings.contains(message.getStream().getId() + message.getSubject());
I'm not sure whether this should be mutedTopics.contains() or mutedTopics.contains()?
I'm not sure whether this is a Mute!
This method could be reduced to: java return expression.stream().anyMatch(argument -> ArgumentBinding.contains(argument.getColumn()) &&!columns.contains(argument.getColumn()));
This method could be reduced to: java return expression.stream().anyMatch(argument -> ArgumentBinding.contains(argument.getColumn()) &&!columns.contains(argument.getColumn()))
This method could be reduced to: java return expression.stream().anyMatch(ArgumentBinding::isVariable);
instanceof Dataset is redundant
instanceof Dataset is redundant, I think you should remove it.
instanceof Dataset is unnecessary
need to return abfsStore here
need to return abfsStore
need this to be protected
Please use toLowerCase() instead of toLowerCase()
Please use toLowerCase() in all cases, even if you trim the value you can use Locale.ROOT
Please use toLowerCase() in all cases, even if you don't want to modify the header.
Do we need this to be a Set?
Could you use the Logger, and remove the "streamId" variable?
Could you use the Logger, and remove the "Invalid streamId "
check if the newTimeIn is positive?
check if the newTimeIn is >= newTimeIn
check if the new time is greater than newTimeIn
nit: this.
Should be package private, so only used by tests can be removed.
Should be package private, so only the tests can use it directly.
This should be extractionFn.hash()
This should be extractionFn.hash(...)
typo
oops, Robin, I think it's better to throw an exception instead of returning this. oldRevision = revision; for consistency.
oops, Robin, I think it's better to throw an exception instead of using a return value.
oops, Robin, I think it's better to throw an exception instead of returning this. oldRevision = revision; switch (type) { case DIFF: case... default: case...
Should we use org.apache.kafka.common.utils.Utils.closeQuietly?
Should we use org.apache.kafka.common.utils.Utils#closeQuietly?
Should we use org.apache.kafka.common.utils.Utils.closeQuietly?
Do we still have a waitActive method?
Do we still have a condition on the CI server?
Do we still need this.
i think it's a good practice to do this in one line
i think this should be simplier
i think it's a good practice to do this in a finally block
rename to sash
name sash
rename to sash?
I think this is not the right log message
I think this may be an error if the user doesn't have the app version. We should also report that the update log at this point.
I think this is not the right log message. We should also report the SessionUnavailableException.
We should probably log this error. e.g. return UUID.fromString(value);
We should probably log this error.
We should probably log this exception or just ignore it.
minor - pull the instance out of the if block so that it doesn't get called multiple times.
minor - pull the instance out into a separate variable and use that here. Also, please check what the method is doing and why it is declared.
minor - pull the instance out of the if block so that it doesn't get called twice?
unnervous you can use fail("Exception expected") :smile:
unnervous you can use fail("Exception expected")
Make the instanceOf check more expressive (e.g. TestEventContext)
This doesn't have to be public
This doesn't have to be public.
this.
This message is misleading, it should say "Only --list option is currently supported"
This message is misleading, it should say "Only --list option is currently supported".
This message is misleading, it should say "Only number of option is currently supported"
DTOs should represent what came from stripTrailingeros().contains(relativeTarget)
DTOs should represent what came from stripTrailingeros().containsHelper().
DTOs should represent what came from stripTrailingeros.containsHelper().
You may also want a test case for a search value that is non-blank but invalid.
Does it make sense to leave the test case for a search value that is non-blank but invalid?
Does it make sense to leave a test case for a search value that is non-blank but invalid?
Let's see if this method can be private.
Please add throws Exception here.
Let's see what happens when this file is being uploaded.
Could you add a check for dex dex and remove the dex?
Could you add a check for dex dex == null
Could you add a check for dex == null
Please use the @BeforeMethod instead of repeating the call in all the tests.
Please use the @BeforeMethod instead of this method.
Please use the @BeforeMethod instead of calling InternalCaseTest() with a single argument for all the tests.
since the RuntimeException is caught and wrapped in a runtime exception if it is not a RuntimeException, we should log and throw.
since the RuntimeException is caught and wrapped in a runtime exception if it is not a RuntimeException, we should log and throw the exception.
since the RuntimeException is caught and wrapped in a runtime exception it should be cleaned up to the end of the method.
redundant this.sense-processed
do we need to sense-processed?
do we need to sense-logs here?
In my testing on Linux I see another SWT.Selection between MouseDown and MouseUp. Maybe we can also do something like: notify(SWT.MouseDown, SWT.MouseUp, SWT.MouseUp, SWT.MouseUp, SWT.MouseUp, SWT.MouseUp);?
In my testing on Linux I see another SWT.Selection between MouseDown and MouseUp. Maybe we can also do something like: notify(SWT.MouseDown, SWT.MouseUp, SWT.MouseUp, SWT.MouseUp, SWT.MouseUp, SWT.MouseUp, SWT.MouseUp);?
I think you meant!(equals)?
Magic number - please fix this.
Magic number - please fix.
Magic number
We don't want to instantiate a new object if we aren't already initialized, just return it.
We don't need to cast here. Just inline it in the method signature
method should be static
Since you are using System.getProperty, you can use System.getProperty.
Since you are using System.getProperty it should be enough to remove it.
Since you are using System.out, use a logger.
Same here, need to restore the server.
Need to restore the server configuration.
Same here, need to restore the server configuration.
This is a really good place to clean up the configuration asynchronously. Won't the ConfigurationHolder.initFromProperties() be not called from anywhere else.
This is a really good place to clean up the configuration asynchronously. Won't the ConfigurationHolder.initFromProperties() be not called at all?
This is a really good place for final.
Prefer assertThat(installSource, containsString(installSource))
Prefer assertThat(installSource).containsString(...) as per testing.
Prefer assertThat(installSource).containsString(...) as per testing, which is more specific about the entire object.
I think Long.SECONDS.toMillis(mock.awaitTermination()) is more readable to use.
Does the executorService shutdown already wait(1, TimeUnit.SECONDS)?
I think Long.MAX_VALUE is too long.
Use a message with a meaningful message.
An fail() without any message is not thrown.
An exception must be thrown.
How about catch ( FSDataInputStream in = fs.open(filePath); try { return in; } catch (IOException e) { throw new RuntimeException(ex); } } catch (IOException ex) { throw new RuntimeException(ex); }
How about catch ( FSDataInputStream in = fs.open(filePath); try { return in; } catch (IOException e) { throw new RuntimeException(ex); } } catch (IOException e) { throw new RuntimeException(ex); }
How about catch ( FSDataInputStream in = fs.open(filePath); try { return in; } catch (IOException e) { throw new RuntimeException(ex); } catch (IOException ex) { throw new RuntimeException(ex); }
We do not need to call get() method here.
We do not need to call get() on tailSupplier here.
We do not need to call get() on tailSupplier here. It should be enough to call directly, as we have nothing to do with this.
[minor] You should call this asMessageAttribute(ChangeMessage)
Only reason to cache the message?
Only need to cache the message object.
Can't we pass this to the constructor?
Can't we pass this in the constructor?
Can't we pass this to the fluid handler?
newIEWithSamplingEnabled()
newIEWithSamplingEnabled() is better
newIEWithSamplingEnabled()?
Did you want to limit the SDK to something more than 20?
Did you want to limit the SDK version to something more than 20?
Did you want to limit the SDK to be something more than 20?
My suggestion to test the error message in case the test fails.
My suggestion to check the error message in case the test fails.
remove this.
add curly braces
missing @since 4.10 tag
style nit: add curly braces
@Override?
@vilchik-elena Override?
@vilchik-elena Minor:
What does this change do? It seems like it also adjusts the status of stopped workspaces. _The count of stopped workspaces is _RUNNING_.
What does this change do? It seems like it also adjusts the status of stopped workspaces. _The count of stopped workspaces" metric.
What does this change do? It seems like it also adjusts the status of stopped workspaces. _The count of stopped workspaces is _RUNNING or STOPPED_.
@Rikkola Why do we need this change?
@manstis I think you should check the Edit_VIEW right?
@Rikkola Why do we need this change? I think that maybeMove should already be the right place.
I think this would read a little better if this was a local variable: java public List<NameValuePair> extract(EpdqTemplateData templateData) { EpdqParameterBuilder parameterBuilder = new EpdqParameterBuilder(nameValuePairs).add(BROWSER_COLOR_DEPTH, getBrowserColorDepth(templateData)); parameterBuilder.add(BROWSER_COLOR_DEPTH, getBrowserColorDepth(templateData)); return parameterBuilder.build(); }
I think this would read a little better if this was a local variable: java public List<NameValuePair> extract(EpdqTemplateData templateData) { EpdqParameterBuilder parameterBuilder = new EpdqParameterBuilder(nameValuePairs).add(BROWSER_COLOR_DEPTH, getBrowserColorDepth(templateData)); parameterBuilder.add(BROWSER_COLOR_DEPTH, getBrowserColorDepth(templateData)); } return parameterBuilder.build(); }
I think this would read a little better if this was a local variable: java public List<NameValuePair> extract(EpdqTemplateData templateData) { EpdqParameterBuilder parameterBuilder = new EpdqParameterBuilder(nameValuePairs).add(BROWSER_COLOR_DEPTH, getBrowserColorDepth(templateData)); parameterBuilder.add(BROWSER_COLOR_DEPTH, getBrowserColorDepth(templateData))); }
I would prefer other methods to be private.
I would prefer other methods to be private
I would prefer other methods to be static.
Is this still needed?
Is this just a class member variable?
Is this just a class not a java class?
rename to contribution
Rename to contribution
rename to resolver
An alternative constructor should be private.
Please make this constructor private.
An alternative constructor should be package private.
Could we have a function with Presto simplify this? My only concern is the getImplementationType() is the correct generic type.
Could we have a function with Presto simplify this? My only concern is the getImplementationType() function might throw an exception if the function is not function.
Could we have a function with Presto simplify this? My only concern is the getImplementationType() and getImplementationType() is the correct generic type.
boolean?
boolean?
boolean not Boolean
I think it was wrong before, but there is no need to check for null on line 270. Shall we delete it, unless it is originally needed?
I think it was wrong before, but there is no test for try-catch-block in this test.
I think it was wrong before, but there is no need to check for null on line 270.
It seems that this line is duplicate of line 89, which is the same as line 89.
It seems that this line is duplicate of line 89, which is at the moment the site is not updated. Please could we move it out of the if (getSelectedSite()!= null) statement?
It seems that this line is duplicate of line 89, which is at the moment the site is not updated. Please could we move it out of the if (getSelectedSite()!= null) block?
I think we should give the limit of the two to be more generic. What do you think?
I think we should give the limit of the scan node as a parameter.
I think we should give the limit of the scan node as a parameter of this method.
Should this instead be setNeedsPrivateSection(false)?
Should this be setNeedsPrivateSection(false)?
Should this be setNeedsPrivateSection?
Should be private, put in UserAccount()
Should be private, put in UserAccountFactory
Unnecessary final
I know this is code throwing an exception but can we change the calling code to handle the null check and throw a proper exception?
I know this is code throwing an exception but can we change the calling code to handle the null check and throw a proper exception? Are all the other methods that do the same thing?
I know this is code throwing an exception but can we change the calling code to handle the null check and throw a NPE
You may also move list to CollectionDataViewImpl
You may also move list to constructor?
You could move array to constructor parameter as well
Can be private static final.
Can be private static final
Can be public static
The waitForPanelsToExpand method now does not do the job, it is named "collapse-panel-button". Can you please explain this?
The waitForPanelsToExpand method now does not do the job, it is named "collapse-panel-button". Can you explain this?
collapse-panel-button
@tmarzeion you shouldn't need this change
@tmarzeion you shouldn't need this change as well
this is not necessary
suggestion view.submit(versionRecordManager.getCurrentPath());
suggestion _super. submit()_ as a no-op call
suggestion view.submit(versionRecordManager.getCurrentPath(), null);
return Boolean.TRUE.toString( Preference.APPLICATION_SCOPED.get(BriefcasePreferences.BRIEFCASE_TRACKING_CONSENT_PROPERTY))
return Boolean.TRUE.toString( Preference.APPLICATION_SCOPED.get(BriefcasePreferences.BRIEFER_TRACKING_CONSENT_PROPERTY))
return Boolean.TRUE.toString( Preference.APPLICATION_SCOPED.get(BriefcasePreferences.BRIEFCASE_TRACKING_CONSENT_PROPERTY)) );
This should check the environment variable before returning true.
This should check the env variable before returning true.
Check the env variable before returning true.
shouldn't this be java this.out.println(out);?
shouldn't this be java this.out.println(newOut);?
shouldn't this be java this.out.println(err);?
As we discussed, let's make a default constructor instead.
As we discussed, let's make a private static final constant instead of public.
As we discussed, let's make a default constructor instead of using String.
I think it's a bit clearer to call this throwIfCrossFileScanner(javaCheck, syntaxNode, message, flows, cost);. This way we also report issueWithFlow in one place.
I think it's a bit clearer to call this throwIfCrossFileScanner(javaCheck, syntaxNode, message, flows, cost);. This way we would avoid the duplicate code from throwIfCrossFileScanner method. It can be refactored into a single method that calls few times.
I think it's a bit clearer to call this throwIfCrossFileScanner(javaCheck, syntaxNode, message, flows, cost);. This way we would avoid call to throwIfCrossFileScanner method.
I'm not sure about this, but it looks like it can't be implemented by a EGWalker. It is not clear to me. Perhaps because we're checking against a decimal point, but I think it would be better to abstract this method into a util class, and have something like: java public static long toDouble(BigFraction d) { return nanos.substring(0, d.length()); } private double toDouble(BigFraction d) { return nanos.substring(0, d.length()); }
I'm not sure about this, but it looks like it can't be implemented by a EGWalker. It is not clear to me. Perhaps because we're checking against a decimal point, but I think it would be better to abstract this method into a util class, and have something like: java public static double toDouble(BigFraction d) { return nanos.substring(0, d.length()); } private double toDouble(BigFraction d) { return nanos.substring(0, d.length()); }
I'm not sure about this, but it looks like it can't be implemented by a EGWalker. It is not clear to me. Perhaps because we're checking against a decimal point, but I think it would be better to leverage that.
@Before when hotRodClientTestingUtil.killRemoteCacheManager(remoteCacheManager) is called?
@Before when hotRodClientTestingUtil.killRemoteCacheManager(remoteCacheManager) is made?
@Before when can creation be avoided?
@yingsu00 Ying, could you make this private?
@ abstract
@ abstract?
final
final and add a newline before the field name.
final and add a newline before the name of the field
The EDGE.equals() doesn't make sense here.
The EDGE.equals() doesn't look right.
This is no longer used.
So we just set the value for the memory, do we want to still hit the revocable memory?
So we just set the value to 0 for spill to disk, we should still hit this condition.
So we just set the bytes to 0 here?
For this exception, the response entity is not populated, so there is no need to check for null.
For this exception, the response entity is not found. It is good to make sure the response representation of such a situation are not met.
For this exception, the response entity is not found. It is good to make sure the response representation of such a situation are not executed.
Do you need the builder on construction?
Do you need the builder yet?
requireNotNull
Could you please make this final?
Could you please make this private?
no need to store this variable. Just inline it in the declaration.
Is it a good idea to have an inner class for the DataTable() methods?
Is it a good idea to have an inner class for the DataTable in the page objects? If not, we should rather have the DataTable(table, table.getAttribute("id"))) directly
Was it a good idea to have an inner class for the DataTable() methods?
Should this be Mono<QueueMessageItem>?
Should this be Mono?
Should this be Mono or Mono?
could return logs.get(type)
if type is not null, logs.get(type) will throw NPE
could return logs.get(type);
this constructor should be private
remove this constructor.
remove this constructor
There is an assertNoException thrown here.
There is an assertException() for these two cases and an empty list.
There is an assertException thrown here.
can be simplified to return rsi!= null? rsi.getStatus() : null;
can you replace this with return rsi!= null? rsi.getStatus() : null;
can you replace this with return rsi == null? null : ruleManager.getStatusInfo(ruleUID);
Can be removed
Can be private
Maybe move this constructor to member variable
Why is this needed?
Why do you open this on every line?
Why not reuse the already created repo?
What is this better than adding mWorkDatabase.beginTransaction() inside the try block?
What is this id actually used for? It doesn't seem to make sense to me, only looking at the first time.
What is this id actually used for? It doesn't seem to make sense to me, I think.
Can we replace "." with correct domain name, and change it to orderByClause
Can we replace the *.id* in a constant with a meaningful name ("id")
Can we replace "." with correct domain name, and change it to inQuery?
I think we can use try-with-resources here
I think we could use try-with-resources here
I think we have not able to use DecisionTableFactory.loadFromInputStream to create the stream. How do we handle this?
Why is this necessary? If it is not, it is fine to not copy the segment if it's not empty, since it's not used.
Why is this necessary? If it is not, it is fine to not reuse the passed in value.
Why is this necessary?
Why can't this be extracted to a method? I don't see the rationale is this method.
Why can't this be extracted to a method?
Why can't this just return false?
Don't abbreviate variable names.
Don't collapse resourceSet
@DilanUA Will this cause NPEs?
Why is this method needed? If it is private, it should be an API.
Why is this method needed? If it is private, it should be an Immutable map.
Why is this method needed? If it is private, it should be an Immutable map instead.
Minor thing, can we add a more descriptive message?
Minor thing, can we add a more descriptive name?
can we add a more descriptive message?
I'm not claiming to be a spectacular speller, but just saying: <LINK_0>
I'm not claiming to be a spectacular speller.
I'm a bit afraid this should be synchronized
is this method used?
throws IOException can be removed
is this used anywhere?
We are not closing the writer before it is called.
We are not closing the writer before it is being closed.
We could remove all of these commits by using try/finally blocks.
Please add an overload for String join(String, String) as well.
Please add an overload for String join(String, String) that accepts a List<String>.
Please add an overload to String join(String, String) that accepts a List<String>.
We should pull this out into a setup method and call it here.
We should pull this out into a ConfigurationClass.
We should pull this out into a Configuration, and call it here.
name could be more descriptive
name could be more specific
name could be better!
Please log the actual url/url here.
Please add e as the cause argument.
Please log the actual url/url
This is not needed.
This check is not needed.
This could be initialized to Locale.getDefault().
The public constructor should call the other one.
Remove the public modifier
Remove the public modifier.
can we please move it to a constant?
clazz!= null check can be removed
clazz!= null check can be removed and also removed.
Minor: maybe just move this a line up so it's after the bracket.
Minor: maybe just move the depth++ to the end of the previous line?
Minor: maybe just an assert?
Why does the numbers have a meaningful name?
This does not have to be "/".
Why does the numbers need to be hardcoded?
This method is too abstract, it can be refactored to: public static <T> GenericMapMapper<T> getMapperForValueType(Class<T> type) { return config.get(ColumnMappers.class).map(GenericMapMapper::new).orElseThrow(() -> new RuntimeException("no column mapper found for type " + valueType))); }
This method is too abstract, it can be refactored to: public static <T> T getMapperForValueType(Class<T> type) { return config.get(ColumnMappers.class).map(GenericMapMapper::new).orElseThrow(() -> new RuntimeException("no column mapper found for type " + valueType))); }
This method is too abstract, it can be refactored to: public static <T> GenericMapMapper<T> getMapperForValueType(Class<T> type) { return config.get(ColumnMappers.class).map(GenericMapMapper::new).orElseThrow(() -> new RuntimeException("no column mapper found for type " + valueType)); }
Added because?
Added because of these?
Added because of click?
The output of this catch statement may be a bit too wide, but the function can't be synchronized. Something like this: java } catch (InterruptedException | ExecutionException ex) {
The output of this catch statement may be a bit too wide, but the function can't be called directly.
The output can be null
Won't this be a performance suicide given how many times the matcher was? Please correct the same for the testing.
Won't this be a performance suicide given how the matcher was already implemented? Please check for some description only, which is the same as the other methods.
Won't this be a performance suicide given how the matcher was already implemented? Please check for some description only, which is the same as the original code.
please say this is not mandatory but it would be nice to make a ForbiddenAttributeIncompatibility(jsonPathString(jsonPath), this.ATTRIBUTE)
Please say this is not mandatory but it would be nice to make a ForbiddenAttributeIncompatibility<SchemaIncompatibility>.
nit: this can be replaced with schema instanceof ObjectSchema
Check if s is null.
Check Bytes.UTF_8
Check Bytes.UTF_8.
backup = null?
backup should never be null and backup should be removed.
backup = null? If yes, backup can be moved into backup
You should use the more specific return value than the method declaration.
You should use the more specific return value than the returning one.
You should use the more specific return value rather than relying on Optional.
The add method loops through its input stream, and we are calling it in a loop over the collisions. So we have a quadratic algorithm here. How likely is that to be a problem?
The add method loops through its input stream, and we are calling it in a loop over the collisions. So we have a quadratic algorithm here. How likely is that to be efficient?
The add method loops through its input stream. So we are calling it in a loop over the collisions.
What is the purpose of 1000 here?
What is the purpose of 1000 and 1000?
We shouldn't divide by 1000 here.
Maybe we could use a permanent error message here: return removeItemWithName(type);
Maybe we could use this method in ControllerHelper as well?
Maybe we could use a permanent error message here: return permanent*.add(type);
This would create a function for each of the databases. instead of setting it to a list.
This would create a function for each of the database types. instead of setting it to a list.
This would create a function for each of the databases. instead of setting it to a default?
We could consider using e.getMessage() here instead of e.getMessage(). This would also allow the IOException.
We could consider using e.getMessage() here.
We could consider using e.getMessage() here instead of e.getMessage().
Pretty sure this is the only instance member.
why not have this constructor reference the same version?
duplicate line.
Instead of running this as a benchmark, it seems like we should change the default to QualityGateNameAvailable.
Instead of running this as a benchmark, it seems like we should override the isQualityGateNameAvailable method that takes a String and a String.
Instead of running this as a benchmark, it seems like we should override the isQualityGateNameAvailable method that takes the SQL string and parameters.
This toString() never returns null. The "TtyDev [portName]=" suffix is not a valid input.
This toString() never returns null.
This toString() output is not necessary.
This is the same as LimitedEntryActionRetractFactCol52, can we make it static?
This is the same as LimitedEntryActionRetractFactCol52, can we make it static and reuse?
This is the same as LimitedEntryActionRetractFactCol52, can we make it static and reuse it?
Please remove this
Please remove this empty line
Please remove this one too
s/test ok/test
Minor: it might be worth calling a method for these as well.
s/test ok/org/gondo
I think this should be return  "4".
final
return  "4".
If there is a problem with the apiUri it needs to be fixed.
If there is a problem with the apiUri it should be "<LINK_0>"
If there is a problem with the apiUri it needs to be fixed and this should be removed.
make public static
make sure exception is thrown
make static
Catch Exception.
Catch Exception here.
_nit: should this be externalized?
Is it necessary to have nested try-catch scopes? Can we make it simpler?
Is it necessary to have this here? Won't the factory take care of that?
Is it necessary to have nested try-catch scopes? Can we make it simpler and remove the above two lines?
This needs to be the last line of this method.
This needs to be the last line of this test.
This needs to be the last line of this test class.
I think that the coding style of this code is flawed on it so it's not that important. unless you're looking at this code you can pass the index into an ArrayIndexOutOfBoundsException method, which you can pass the index into the method. (I'm not sure of the purpose of this code)
I think that the coding style of this code is flawed on it so it's not that important. unless you're looking at this code you can pass the index into an ArrayIndexOutOfBoundsException method, which you can pass the index into the method. (I'm not sure of the coding standards)
I think that the coding style of this code is flawed on it so it's not that important. unless you're curious about it, this is code you're writing.
suggestion return String.format( "logical %s for execution vertex (id %s) from the physical %s", logicalSlotRequestId, executionVertexId, physicalSlotRequestId));
suggestion return String.format("%logical %s for execution vertex (id %s) from the physical %s", logicalSlotRequestId, executionVertexId, physicalSlotRequestId));
suggestion return String.format("logical %s for execution vertex (id %s) from the physical %s", logicalSlotRequestId, executionVertexId, physicalSlotRequestId));
style nit: missing braces
style nit: braces
braces
Would this still lead to a maskedAccessibility? If it's not clear what it means for accessibilityBlockOffset.
Would this still lead to a maskedAccessibility? If it's not clear what it means then why it should be a maskedAccessibility instead.
Would this still lead to a maskedAccessibility? If it's not clear what it means then why it should be a default and no mask?
nit: I'd use hamcrest matchers here and also below
nit: I'd prefer to have the min/max timestamp here, as it's clearer than the previous test.
nit: I'd use hamcrest matchers here and below
Shoudn't this be done in validateBeforeUndeploy?
The participant should still be deleted here.
D definition should be removed here.
I think we need to clear the element.sendKeys(input) here.
I think we need to clear the element.sendKeys(input) method
I think we need to clear() the element.sendKeys(input) method
getSortedDescriptorsForGlobalConfigNoSecurity()
getSortedDescriptorsForGlobalConfigNoSecurity() or getSortedDescriptorsForGlobalConfigNoSecurity()
unmodifiableList?
suggestion return fs.getUsableSpace(path);
suggestion return fs.getUsableSpace(path); I am not sure this is necessary.
suggestion return fs.getUsableSpace();
Did you intentionally ignore the patientProgram parameter?
Did you intentionally ignore the patientProgram parameter?
Did you intentionally ignore the patientProgram argument?
It would be better to return a copy of theEmitDate to keep the way it is. Else you can leave a copy of the list and modify it.
It would be better to return a copy of theEmitDate to keep the way it is. Else you can leave a copy of the list and do this.getEmitDate() in a private final field of this class.
It would be better to return a copy of theEmitDate to keep the way it is. Else you can leave a copy of the list and do this.getEmitDate() in a private final field.
Logically found that MARKED_ROLLBACK is not the right place to check if there is an ACTIVE or ACTIVE?
log() and return here to avoid nesting?
log statement
Why do we need to return null here?
Why do we need to check if the instance is a IDifferenceGroupProvider? Why not do it in the condition below?
Why do we need to return null here?
Not sure if it's a good idea to use a constant here.
Not sure if it's a good idea to use a hardcoded 3 here.
Again, it would be nice to have a small private method here that would be more efficient.
Did you mean to remove this?
does this need to be here?
remove this
I think this field name is misleading. It's not the gauge name.
I think this field name is misleading. It'll be the gauge name (and I believe we can rename it to be gauge)
I think this field names need to be prefixed with  and.
less error prone: if (ReflectionUtils.hasMethod(e.getClass(), "setGlowing", null))
less error prone: if (ReflectionUtils.hasMethod(e.getClass(), "setGlowing", null)) { e.setGlowing(glow); }
less error prone: if (ReflectionUtils.hasMethod(e.getClass(), "setGlowing", glow))
Value could probably be extracted as a constant. (I could also argue that getting the int value could be a constant)
Value could probably be extracted as a constant. (I could also argue that getting the int value could be a constant, but I sense that there would be some opportunities for the method.)
Value could probably be extracted as a constant. (I could also argue that getting the int value could be a constant, but I sense that there would be some opportunities for the RangeIV.)
/casedb_instance_structure.xml
It looks like you're re-throwing the same exception twice, so let's just remove the try clause
I think this is the same as the one in FormLoadingUtils.xml
Do we need to worry about this? TestContext.getSessions().stream().map(s -> new HttpGet(uri + "/" + s.getId())) should work the same way.
Do we really need to worry about this? TestContext.getSessions().stream().map(s -> new HttpGet(uri + "/" + s.getId())) should work the same.
Do we need to worry about this? TestContext.getSessions().stream().map(s -> new HttpGet(uri + "/" + s.getId())) should work?
@NotNull instead of @NotNull.
It's better to make the field final than it's field.
It's better to make the field final than field.
I think this can be improved. The name of the file should be changed from "to single Snapshot Format" to "to single Snapshot Format"
I think this can be improved. The name of the file should be changed from "to single snapshot" to "to single Snapshot Format"
I think this can be improved. The name of the file should be convertToV232)
public void setFontForHeight(int pixels, GC gc)
Consider adding a Preconditions.checkArgument check here to verify that the font is not null.
public void setFontForHeight(int pixels, GC gc) {
You could just use a hasAnnotation method in BlockDeviceTemplateGroup and have the Concat method directly
You could just use a FluentIterable.from(image.getCloudId()).
You could just use a FluentIterable.from(image.getCloudId())
You may find many examples in the future.
You may find many examples in the target.
You may find many examples in the existing code.
The only problem with this approach is that Nested views may appear as a search result even if there is TopLevel view with such small view. And as a user I would expect the list to be returned while there is no getAllViews() operation. Maybe it worth to check all TopLevel views before iterating?
The only problem with this approach is that Nested views may appear as a search result even if there is TopLevel view with such small view. And as a user I would expect the list to be returned while there is no view. Maybe it worth to reset the default view in this class too?
The only problem with this approach is that Nested views may appear as a search result even if there is TopLevel view with such small view. And as a user I would expect the list to be returned while there is no getAllViews() operation. Maybe it worth to check all TopLevel views first. I would also vote for making this a Set as a implementation of List.
this error message is not accurate, as in the method above, this parameter is not used.
this error message is not accurate, as in the case of IOException, this method is not called.
this error message is not accurate.
What does flumeConfiguration have?
What is the default value?
What is the default value for this?
Move this validation to PluginProperties.
Move this validation to PluginProperties().
Similar to above, please add a new method
Can you remove the public void waitForAsyncCompletion()?
Can you call.nextTransaction() here and remove the transaction call?
Can you call.nextTransaction() here and remove the secondTransaction?
the getConfiguration(Class) method always returns a non-null value, so this check is unnecessary.
this method is already called in getConfiguration(Class), so it can be removed.
this method must be private
change to return returnStatus!= VdcBllErrors.Done? getVDSReturnValue().setSucceeded(false);
if returnStatus!= VdcBllErrors.Done) { InitializeVdsError(returnStatus); }
change to returnStatus!= VdcBllErrors.Done()
Wouldn't it be more readable to just return java public static long getTtlInSecsFromExpiryMs(long expiresAtMs, long creationTimeMs) { return Utils.Infinite_Time; }
This should be private, right?
This method is being used multiple times. Consider calling it once in the constructor instead.
nit: space after if
else if
add braces
I don't think you need to synchronize on this.
I don't think you need to synchronize on this method.
I don't think you need to synchronize on this on the field storage.
Please put back the name of the exception message.
Please put back the parentheses around (like before)
Please put back the name of the exception message, it's a good idea.
- ImageData for current image needs to be updated in the else statement.
- ImageData for current image needs to be updated in the else case.
ImageData for current image needs to be updated in the array?
same again: do not create a new empty exception but reuse the old one.
same again: do not create a new IndexOutOfBoundsException but reuse the old one.
same again: do not create a new empty exception but reuse the old exception.
Now this will not work with the no-arg constructor. Is this the default behavior?
Now this will not work with the default no-arg constructor. Is this the default behavior?
Now this will not work with the no-arg constructor. Is this method currently only used in tests?
style nit: please add braces
Style-nit: Please add braces around the for loop.
rename to url
nit: I think it was better to have a constant for expectedColumnsType and expectedColumnHandles instead of trying to reuse it.
nit: I think it was better to have a constant for expectedColumnsType and expectedColumnHandles instead of trying to reuse it everywhere.
I don't think it is necessary to change this line.
there is a assertNoOrder fixture?
assertEquals(1L, result) is a good idea.
assertEquals(1L, result); is a good idea.
This is wrong. You need to make sure that the shift is zero. You can use getGeometryType().
You can make this private static.
You can make this private.
you could use just label.trim() to check whether the label is empty, or not.
you could use just label.trim() to check whether the label is in the text view
you could use just label.trim() here.
The second variable should be equals(tlv.getOui()).
The second variable should be equals(tlv.getOui()) also, the test is going to fail if the hashCode-method was changed.
The second variable should be equals(tlv.getOui()) also.
I'd like to see a couple of possible errors here.
I'd like to see a couple of possible errors here - should we have a test case that fails with IPv6?
I'd like to see a couple of possible errors here with environment variables
:+1: for creating an issue here.
:+1: for static analysis.
:+1: for static imports
I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.
I would suggest updating this to analyze the primary keys map, to verify that the record being sent in before returning the result.
I would suggest updating this to analyze the primary key field, to verify that the appropriate IDs are being sent in before returning the result.
this is a bad idea
this is a singleton
this is a bad practice
Missing no need for this, you can just test the size.
Missing an 'if'.
Missing an 'else'.
Typo, should be addImportMenuItem
Typo in addImportMenuItem
apMenuItem.notnull
Why using ConcurrentHashMap and not a ConcurrentHashMap?
Why using ConcurrentHashMap here and not below?
Why?
I'd split the try/catch into a separate method. The only thing I'd do here is to remove the exceptions from the first call to loadListeners in the method.
I'd split the try/catch into a separate method. The only thing I see is that you're catching is the very first exception.
I'd split the try/catch into a separate method
This function is being called from onSignInClicked(). I think this should be the super implementation of onSignInClicked().
This function is being called from onSignInClicked(). I think this should be an else-clause.
This function is being called from onSignInClicked(). I think this should be called from onSignInClicked().
suggestion if (user == null) {
suggestion "deleting User " + user.getUsername() + " (id: %s), accountId = " + user.getAccountId();
suggestion "deleting User " + user.getUsername() + " (id: " + user.getAccountId()) + " (id = " + user.getAccountId())
This should not happen.
This should not happen. If it is not in the scan, it will have some race condition.
This should not happen. If it is not already closed, please use clear()
please use Strings.isNullOrEmpty
please use String.format()
please add error message
Why not.filter(exam -> exam.getRoom().getRoom().getPenalty()!= 0)?
Why not.filter(exam -> exam.getRoom().getPenalty()!= 0)?
Why not.filter(exam -> exam.getRoom().getRoom())!= 0))?
This is not public.
This is never public.
This is package-private.
This is a bad pattern to use in tests. You should also mock the thrown object.
Better to use the expected exception here
Better to use the expected exception
The super constructor throws an IupnpDiscoveryException when a new one is created. Wouldn't it be better to leave the super call to the constructor?
no need to call super()
no need to call super
(nit) suggestion return index == null && idForNull == UNKNOWN.equals(index);
(nit) could be simplified to return index == null || index == idForNull;
(nit) could be simplified to return index == null || (value == null) || index == idForNull;
suggestion tagsToResource.forEach((fromTag, asResource) -> tags.remove(asResource));
suggestion tagsToResource.forEach((fromTag, asResource) -> { tags.remove(asResource); });
suggestion tagsToResource.forEach((fromTag, asResource) -> { tags.remove(fromTag); });
I don't think we should make a special user for the validation user, just to make sure that in the future we're not going to pull the email out of the project.
I don't think we should make a special user for the validation user, just to make sure that in the future we're not going to pull the email out of the server, and then make sure there was a valid user.
I don't think we should make a special user for the error case. If somebody does not provide the user, they will end up with a bad user error.
Rename to UNICODE_REGEXP
Rename to UNICODE_REGEXP.
Why public?
You can use Function0::of instead of Try.of(of(partialFunction)::apply).getOption();
You can use Function0::of instead of Try.of(of(partialFunction)::apply).getOption()
You can use Function0::of instead of Try.of(Optional::getOption).getOption()
Why not make the other static methods public?
Why not return the FRAGMENT_TAG directly?
Why not make the other static methods "show" methods return an immutable object reference?
Add the 'try' to the log, so the exception is easier to identify which Exception could be thrown.
Add the 'try' to the log, so the exception is easier to find and debug.
Add the 'try' to the log, so the exception is easier to identify which ledger manager failed.
If this method is called before _after_ the renderAsASource() call, we should call this method _after_ this.
If this method is called before _after_ the renderAsASource() call, we should not do this.
If this method is called before _after_ the renderAsASource() call, we should call this method _after_ this method call.
you should do this from the method...
you should do this from scratch.
you should be using the same monitor
static
public
public?
We could return this.numberOfConnections directly, no?
We could return this.numberOfConnections directly or count.
We could return this.numberOfConnections directly or 0 otherwise.
There is also "setReuseAddress" method which is used elsewhere. I think it is better to avoid code duplication.
There is also "setReuseAddress" method which takes a ServerSocket. So I think it's better to avoid code duplication.
There is also "setReuseAddress" method which takes a ServerSocket.
Why not using the ternary operator?
Why not String format(System.getCampaignOptions().getDisplayDateFormat())?
Why not using the ternary operator?
just Exception | IllegalAccessException | InstantiationException | InstantiationException e)
just Exception | IllegalAccessException | InstantiationException e)
just Exception | IllegalAccessException | InstantiationException e by its message
rename
rename?
rename listeners
this method should never be null, use Collections.emptySet()
this method should never return null, it's always false.
this method should never return null, use the linkedAddresses field.
Is this one "protected void" necessary?
Why does this one need to be public?
Is this one and the other change intended?
Can we not use AllSspToSingleTaskGrouper?
Can we not use getBroadcastSystemStreams() in the method name?
Can we not use getBroadcastSystemStreams()?
Is there a case where function is not null?
There is no need to check function!= null
There's no point in checking function!= null
Please add ioe to the exception.
Please make ioe a exception.
Please make ioe a ISE.
Do you need to update the outcomeSettings method to call these methods?
Do you need to update the outcomeSettingsController method?
Do you need to update outcomeSettings method to return the settings?
I am not sure that's the best way to check if the mod file exists.
I am not sure that's the best way to check if the mod list has a size or negative.
I'd like 2. If the list isn't empty, we keep the existing behavior.
Static string constants
nit: "gwtp.prebootstrapper"
Could you name this property "foo.prebootstrapper"?
you could just use "RuleImpl#toString(a, b)"
you could just use "RuleImpl#toString(boolean)"
you could use String.format("%s has been removed.", getRule());
Should have a space after add
Should have a space before add
Should be add"
Why do we have to wait for the operator to be started?
Why do we have to wait for the operator to be run?
Why do we have to wait for the operator to be initialised?
If this file doesn't exist, RawText. Here we should check if the file exists. If it exist but is not, return RawText(repo.openBlob(id).getCachedBytes()
If this file doesn't exist, RawText. Here we should check if the file exists. If it exist but is not, return RawText(repo.openBlob(id).getCachedBytes());
If this file doesn't exist, RawText. Here we should check if the file exists. If it exist but is not, return RawText(repo.openBlob(id).getCachedBytes()?
I'm not sure if we need to set the JMS Template here. In other words, it is possible for user to create a JMS Template with a JMS Template only when receiving JMS Template. We should create the JmsConfiguration with JMS Template.
I'm not sure if we need to set the JMS Template here. In other words, it is possible for user to create a JMS Template with a JMS Template only when receiving JMS messages. So, this block is redundant.
I'm not sure if we need to set the JMS Template here. In other words, it is possible for user to create a JMS Template with a JMS Template only when receiving JMS requests. So, this block is redundant.
why not boolean? It's false by default.
why 2_HOME variables are defined in the beginning of the command? It doesn't seem like a good idea to have too many static variables in this method and can be moved to a constant
why 2_HOME variables are defined in the beginning of the command? There isn't a good reason to have both, right?
It would be nice to change the parameters class so that it uses List instead of Set, then you could use just "toList".
It would be nice to change the parameters class so that it uses List instead of Collection, then you could use just "toList".
It would be nice to change the parameters class so that it uses List instead of Set and then sort.
Does this need to be public?
Minor nit: Does filter need to be public?
Minor nit: Does filter need a null check?
I think we should drop the index as it is not a member anymore, same applies to cancel
I think we should drop the index as it is not a member anymore, same applies to this.
I think we should drop the last argument, same applies to super
I'd prefer to make this method final.
I'd prefer to make this method protected.
Should this be protected?
Use static import
static import
use static import
Optional: findOneWith(group)
Optional: static import
Optional
if (appSupportedDomain.isEmpty()) {
can this be private? or at least package protected?
can this be private?
checkMapping should be moved into AbstractFBNElementEditPart
checkMapping is a FBNElementEditPart
checkMapping
Why public if it is only visible for testing?
Why public if it is only used here?
Why public if it is only used in tests?
Also, do we need the log.level property? Can't we use the ConfigurationCache instead?
Also, do we need the log.level property? Can't we use the Configuration object, instead of the whole method?
Also, do we need the log.level property? Can't we use the Configuration object, instead of string comparison?
Add final keyword.
Can we use AddDataQuery.INSTANCE instead?
Can we use final expectedException?
Instead of another hard-coded string, write it as a constant in the class.
Instead of another hard-coded string, write it as a constant in the class?
Instead of another hard-coded string, write it as a constant in the class
I can't remember why this assume is needed at the beginning of the test. We can remove it.
I can't remember why this assume is needed at the beginning of the test? About.createSectionFilter(section) below?
I think you can remove the () in the assume
This got out of sync when I reverted the PR, but I don't like that anymore.
This got out of sync when I reverted the PR, but I don't like that.
This got out of sync when I reverted the PR, but I don't like the removal of System properties in this test.
you can use methods like query.and(attrType, values) here
you can use methods like query.AndRange(attrType, values) here
you can use methods like this here instead of using the public interface.
suggestion return lit.value.toInstant(lit.value.toInstant());
suggestion return lit.value.toInstant(lit.value.toInstant())
The implementation of this method expects that lit.value is an OffsetDateTime, not an OffsetDateTime.now() method. Is this method used anywhere?
this should be package private?
this should be public String getTrialUntil()
This should return a boolean or a boolean
![MAJOR](<LINK_0> 'Severity: MAJOR') Make "toString()" a "static" method. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Make "toString()" a "static" method. [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AS1192)
break this line
memory account
close all three lines in runAll
If you have an error, the test will pass even though it's not existent
If you have an error, the test will pass even though it's failing
If you are expecting an error, you should use assertRemoteNotFoundException() instead of assertRemoteNotFoundException
Minor: Unnecessary log.
Minor nit: Unnecessary log.
Minor: s/fieldname/id
same here. not Random
same here. not Random.
same here. not Random..
10d String.valueOf(values[1]);
10d
:+1:
Please use PartitionAttributes.NO_LOG_ENTRY instead.
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String>()
Please use PartitionAttributes.NO_MAX_VALUE instead.
Maybe this could be more readable as java return statesManager.activeDatabaseProperty().getValue().filter(context -> context.getLocation() == DatabaseLocation.SHARED).isPresent(), stateManager.activeDatabaseProperty());
Maybe this could be more readable as java return statesManager.activeDatabaseProperty().getValue().filter(context -> context.getLocation() == DatabaseLocation.SHARED).map(stateManager::activeDatabaseProperty).filter(this::getLocation).orElse(null);
Maybe this could be more readable as java return statesManager.activeDatabaseProperty().getValue().filter(context -> context.getLocation() == DatabaseLocation.SHARED).ifPresent(stateManager::activeDatabaseProperty);
@metalnow FlightMapFragment's implementation is not nullable, so it can be removed.
@metalnow not a bug, but the value is set to null. You can just use checkVolumeBtn.
@metalnow FlightMapFragment's friends is a instance of this class so it can be removed, but the value is not used.
Should be switched to Optional.ofNullable
Should this be a.realm.internal.preferences.UserNotificationProperties?
Should this be a.realm instead of a Unavailable?
RulesDao.getRules() can return a list of rules, so we don't need to do a defensive copy of the list.
RulesDao.getRules() can return a list of rules, so we don't need to do a defensive copy of the DB.
RulesDao.getRules() can return a list of rules, so we don't need to do a defensive copy of the db.
I think there's no need to save these strings in a loop.
I think there's no need to notify tagsChanged event here.
I think there's no need to notify tagsChanged event since we already have a Set?
Link, are these checks really required? Would be nice to clarify?
Link, are these checks really required? Would be nice to have a small helper method to do this.
Link, are these checks really required?
Exception is never thrown
Can you use UTF-8 instead of Exception?
Can you write throws Exception instead?
I think this part should be placed in the generalisation class TraceResponseOutInterceptor
I think this part should be placed in the generalisation class TraceFragment
I think this part should be placed in the generalisation class TraceOutInterceptor
If this is false, getNetworkQosId() will always return null (if the QoS_NOT_EXISTS=TRUE) or ValidationResult.VALID: ValidationResult.failWith().when(). networkQos() == null
If this is false, getNetworkQosId() will always return null (if the QoS_NOT_EXISTS=TRUE). I think the following code is more readable. return ValidationResult.VALID;
If this is false, getNetworkQosId() will always return null (if the QoS_NOT_EXISTS=TRUE) return ValidationResult.VALID; or ValidationResult.VALID;
ImmutableList.copyOf(getWindows());
ImmutableList.copyOf is probably better than guava. suggestion return ImmutableList.copyOf(getWindows());
ImmutableList.copyOf is probably better than guava. suggestion return ImmutableList.copyOf(getWindows);
Let's make this variable final.
Let's make this constant.
Let's make this final.
This is a breaking change for anyone accidential usability.
This is a breaking change for this PR
This is a breaking change for anyone accidential getUsername() implementation.
I don't think this must be the last item in a tuple.
I don't think this must be the last item in a tuple
I would rather use a new TupleBuilder here.
nit: should be assertEquals(type, mapper.readValue(Mapper.writeValueAsString(est), SketchEstimateWithErrorBounds.class);
can this be simplified to assertJsonEquals(Mapper.readValue( mapper.writeValueAsString(est), SketchEstimateWithErrorBounds.class);
can this be simplified to assertJsonEquals(Mapper.readValue( mapper.writeValueAsString(est), SketchEstimateWithErrorBounds.class);?
I think it would be clearer to use a linkedHashSet here.
I think it would be clearer to use a sorted set here.
I think getAllFlags() returns an immutable collection.
this and port68Listener could be removed as well java DhchcSupplierImpl this.shutdown = true;
Nice, but can we use the lambda syntax here?
this and port68Listener could be removed as well...
FromUrl URL is a url, you need to weigher it's easier to read and also use: java url = getFromUrl("<LINK_0>" + shacommit + "/" + filename; if (json.isEmpty()) json = url.replaceAll(url, ""); json = url.matcher(json).replaceAll();
FromUrl URL is a url, you need to weigher it's easier to read and also use: java url = getFromUrl("<LINK_0>" + shacommit + "/" + filename; if (json.isEmpty()) json = url.replaceAll(url, ""); json = xml.matcher(json).replaceAll();
FromUrl URL is a url, you need to weigher it's easier to read and also use: java url = getFromUrl("<LINK_0>" + shacommit + "/" + filename; if (json.isEmpty()) json = url.replaceAll(url, ""); json = url.matcher(path).replaceAll();
Can this be replaced by StringUtils.isNotBlank?
Can this be replaced by <LINK_0>?
This can be replaced by StringUtils.isNotBlank
I think this could be too static.
I think this could be too static
I think this would be better if we use a TreeMap here.
this should be the disk id, not the image group id
should be the default permission, not the image group
this should be the disk id, not the image group
it's more correct to use equals instead of hashcode
it's more correct to use equals instead of getSortWeight. Or why equals is not?
it's more correct to use equals and hashCode for equality, rather than using equals.
This should be all going to be the same as the first parameter, so calling all the methods that returns a nice list rather than a recursive call.
This should be all going to be the same as the first parameter, so calling all the methods that returns a better list.
This should be all going to be the same as the first parameter, so calling all the methods that returns a nice list rather than a recursive List.
nit: we don't usually use curly braces around single line blocks
nit: we don't usually use abbreviations (unless you're doing it this way).
nit: we don't usually use abbreviations (unless you was doing it here)
More escaping opportunities
More escaping opportunities here
More static import?
We should probably create a factory method in the util class instead of using this class directly.
We should probably create a factory method in the util package.
We should probably take this out as an argument.
Add newline before return.
Add null check for newHostMetricsRegistry.
Add null check for the return value
@ivanarrizabalaga why log the exception?
Thread.currentThread().interrupt();
Thread.currentThread().interrupt();?
Use try-with-resources.
Use try-with-resources for all the methods.
Use try-with-resources for all the method signature
style nit: remove unnecessary blank line
style nit: remove empty line
style nit: remove unnecessary white space
I'd prefer using isEmpty() in all the places, to be consistent with the rest of the codebase.
I'd prefer using isEmpty() in all the other filters, rather than size() > 0.
I'd prefer using isEmpty() in all the places, to be consistent with the rest of the code.
Can you give a use-case?
You can remove this since next is a no-op.
Remove?
<LINK_0>
Use assertThat instead?
Use assertThat instead of System.err
I think this is a bug. If flow is null, this should not be treated as an assert.
I think this is a bug. If flow is null, this should not be an IllegalStateException.
I think this is a bug. If flow is null, this should not be treated as an IllegalStateException.
If we do this, we can make the old code concise. java this.start = checkNotNull(territories.get(0)); for (int i = 1; i < territories.size(); i++) { add(territories.get(i)); } }
If we do this, we can make the old code concise. java this.start = checkNotNull(territories.get(0)); for (int i = 1; i <= territories.size(); i++) { add(territories.get(i)); } }
If we do this, there is no reason to do the checkNotNull over here.
set IStructuredSelection
List<IStructuredSelection>
List
I don't think it's necessary. We can just use TSERV_CACHE_FACTORY_IMPL because if tserver is already passed in, we should use the same approach as tserver.get(CccumuloConfiguration.class)
I don't think it's necessary. We can just use TSERV_CACHE_FACTORY_IMPL because if tserver is already passed in, we should use the same approach as tserver.get(CccumuloConfiguration)
I don't think it's necessary. We can just use TSERV_CACHE_FACTORY_IMPL because if tserver is already passed in, we should use the same approach as tserver.get(CccumuloConfiguration.getClass())
Use logger instead.
Use logger please.
Use logger
This is a bit of an odd check, but what happens if the certificate is a self signed certificate?
This is a bit weird, I think you just return the result of the method.
This is a bit of an odd check, but what happens if the certificate is a CertificateX500Principal?
You are right, this method is protected. You are not supposed to access the nicsForUpdate from the parent class.
You are right, this method is protected. You are not supposed to access the nicsForUpdate directly, right?
You are right, this method is protected. You are not using the public apis in this class.
public?
public?
@Nullable
We should have a test for markPatientDeadPageController here.
We should have a test for markPatientDeadPageController that sets the visibility of patient class.
We should have a test for markPatientDeadPageController that sets the EntityLocalEntityEntity to true and false.
shouldn't we add COMPRESSED_COUNT here?
shouldn't we call this unzip(Function.identity())?
shouldn't we add COMPRESSED_COUNT here?
suggestion return FormValidation.error("Valid URL must be configured in the form <http|https>://url>/");
suggestion return FormValidation.error("Valid URL");
suggestion return FormValidation.error("Valid URL must be configured in the form <http|https>://<url>/");
Single or double pipe?
Single or double pipe? (I know it wasn't previously)
Single or Single?
It might make sense to make this constructor private and have people use the public ones with an instance of the class.
It might make sense to make this constructor private and have people use the public ones with an instance of the encoders.
It might make sense to make this constructor private and have people use the public ones with an instance of the evaluator constructor.
Can you just inline the skillCompare variable?
Can you just me get the default rounding in one of the team2?
Can you just me get the change back in to a safe cast here?
once ByteBuffer becomes the canonical representation of a Binary we should implement an equals directly on ByteBuffer without copying to byte array
once ByteBuffer becomes the canonical representation of a Binary we should implement a equals directly on ByteBuffer without copying to byte array
why this change?
You can simply write it as if(!AuthzResolver.isAuthorized(sess, Role.REGISTRAR or VOADMIN)) {
I would rather have it be VOOBSERVER role, because it is not really a VOADMIN.
You can simply write it as if(!AuthzResolver.isAuthorized(sess, Role.REGISTRAR or VOADMIN));
it might be better to use value.getBytes() here.
We could return the result as well.
it might be better to use value.getBytes() as serialization?
getAccountService() should throw an exception instead of logging it.
getAccountService() should be getName() not getName() to avoid confusion.
getAccountService() should be getName() not getName()
Let's rename "method" to "isAccessible"
Let's rename "method" to "isAccessible()"
Make "final" before loop.
I think we are missing the shareIntent.putExtra(Intent.EXTRA_TEXT, mlogs);.
I think we are missing the mShareActionProvider reference here.
I think we should be able to rename this activity as activity_settings.
static imports
static imports?
static imports?
this can be done more elegant: return Arrays.asList(name).stream().collect(Collectors.toList());
this can be done more elegant: return Arrays.asList(name).stream().collect(Collectors.toList());
Do we want to return only names if there is no reason to add the alternative names?
Is it possible to share some code between METHOD_DEF and METHOD_DEF? Should it be private/public static?
Is it possible to share some code between METHOD_DEF and METHOD_DEF?
Is it possible to share some code between METHOD_DEF and METHOD_DEF? Should it be private or can it be private?
We could have something like private Object createObjectFromMap(String name) { if (packageName == null) { return null; } final String packageName = SHORT_TO_FULL_MODULE_NAMES.get(name); if (packageNameWithSuffix!= null) { instance = createObject(packageNameWithSuffix); } } return instance; }
We could have something like private static Object createObjectFromMap(String name) { if (packageName == null) { return null; } final String packageName = SHORT_TO_FULL_MODULE_NAMES.get(name); if (packageNameWithSuffix!= null) { instance = createObject(packageNameWithSuffix); } } return instance; }
We could have a check on package name instead of the new one.
I think we need to check getParameters().getGeoRepSessionId()!= null, since geoRepSessionId is not null.
getParameters().getGeoRepSessionId()!= null should be inside the if statement
I think we need to check getParameters().getGeoRepSessionId()!= null, since geoRepSessionId is always null.
getRequestURI() can be replaced with request.getRequestURI()
please use "return StringUtils.substringAfter(request.getRequestURI()).build();"
Remove parenthesis, please
extension can't be empty or /
"%s can't be empty"
Static import
rename to process
you might want to call fireChanged() here to handle the intended behavior
needs to be synchronized
reopenAccount is not called after click, right?
log()
else {
iirc, if action is gluster service, we do not need to know anything about this.
iirc, if action is gluster service, we do not need to know anything about this action.
iirc, if action is gluster service, we will be able to stop it. Can you change the performAction() to perform this action?
Looks like this change is not necessary. RemoteTransactionCommitted doesn't have the transaction commit, so the commit will only push once, right?
Looks like this change is not necessary. RemoteTransactionCommitted doesn't have the transaction commit, so the commit will only push once.
Looks like this change is not necessary. RemoteTransactionCommitted doesn't have the transaction, so the commit will only push once.
Can be simplified to java return (obj instanceof FilterPath) || (obj instanceof FilterPath) && other.path == null
Can be simplified to java return (obj instanceof FilterPath) || (obj instanceof FilterPath) && other.path == null;
nit: you can use Objects.equals for comparison
set to true here, right?
set it to true here, right?
set to true here?
I'm not sure about the logic here. Why not just set the flag to false for all drivers, and then set it to true for all drivers?
I'm not sure about the logic here. Why not just set the flag to false for all drivers, and just set it to true for all drivers?
I'm not sure about the logic here. Why not just set the open to false, and use a throttledException?
This seems like it would be a lot better if we just use 'no' instead of...{Integer.toString(deleteCount), Integer.toString(deleteCount),...)
This seems like it would be a lot better if we just use 'no' instead of String[]. How about instead of this array?
This seems like it would return an array, not an array. How do we know the size is in advance?
This logic flipped?
This implementation seems to be duplicated with the logic.
This implementation seems somehow more generic.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
Maybe we should use a logger here, or print to a different file? In case there are issues with updating and we need to diagnose.
Maybe we should use a logger here, and print to a different file? In case there is a failure, we need to diagnose.
I would avoid these additional checks, since source is now used in this class.
I would avoid these additional checks, since source is now used by the serialization process.
I would avoid these two statements, unless they are very similar, or if they are needed.
You should load the file if the object has been created.
You should load the file if the test fails.
You should make this final.
This method has the same code from setNavigationOnStandby. Please extract it to a separate method.
This method has the same code paths as we're using.
This method has the same code from setNavigationOnStandby(). Can we extract it?
The concern here is that the preprocessKvsRuntimeConfig is only used for validation in the rest of the keys, so it's better to check whether there's a more specific type?
The concern here is that the preprocessKvsRuntimeConfig is only used for validation in the rest of the keys, so it's better to check whether there is a more specific type?
The concern here is that the preprocessKvsRuntimeConfig is only used for validation in the rest of the keys, so it's better to check whether there's a more specific type.
What is the purpose of logging here?
What does this log mean?
What is the purpose of logging it?
if we continue with this convention, please init to true also here
if we continue with this convention, please init saveMemory to true here
if we continue with this convention, please init saveMemory = true here
This is a good idea.
This is a good time to deal with my PR.
This can cause a NullPointerException.
Arrays.asList(delegates) would be a better fit
- static import - why is this necessary?
- static import - why is this public?
There is also a more specific exception message for findNodes.
There's also a missing import for findNodes.
There is also a more specific exception message.
This query could be used, right?
This query could be called twice, right?
This should be an else if, same for the below
Before the fix, please rename the variable to ownedQuantity
Before go through the loop make ownedQuantity final
Before the fix, please rename the variable to ownedQuantityQuantity
What is the use of getVoided() in this loop?
What is the use of that variable?
What is the use of getVoided() here?
Should be private.
Should be private
Should be WARN and not ERROR.
If the maxPings parameter is null, this could fail with a NullPointerException.
If the maxPings parameter is null, this could fail with an NPE.
If we are allowing a debug message, it could be an appropriate error. So set the maxPings value to 10 and check that there is no debug message.
the assertion is useless, as DependencyLinker.putTrace(trace) is already there.
the assertion is useless, as DependencyLinker.putTrace() is already internal
.hasSize()
Should be better to use static i.e., "fuzz.generator.json"
Should be better to use logError(String, Throwable)
Should be static.
suggestion LOGGER.isDebugEnabled();
A log message here would be nice
unused
@pynicolas I think it would be better to not pass null here
@pynicolas I think it would be better to not pass 0 to this constructor. You can get rid of this constructor
@pynicolas I think you should not pass null here
.equals( annotation.getName() ) is equivalent and may be faster.
This variable is never used.
.equals( annotation.getName() ) ).
You can use PropertiesConfigurationLayout: java StringWriter config = new StringWriter(); config.addConfiguration(config);
You can use PropertiesConfigurationLayout: java StringWriter config = new StringWriter(); configuration.addConfiguration(config);
You can use PropertiesConfigurationLayout to save you a lot of casts. <LINK_0>
Just use UdpServerAdapter.NO_ALIGNMENT_PORT()
Just use UdpServerAdapter.NO_ALIGNMENT_PORT() here.
Just use UdpServerAdapter.NO_ALIGNMENT_PORT) here.
Are we sure this should not be reverted?
Are we sure this should not be reverted? This should not be possible, but if we want to be more explicit, let's change the checks in the backend to not be required.
Are we sure this should not be reverted? This should not be possible.
We should only log this error if it is not a malformed URL. similar to how else do we log it?
We should only log this error if it is not an Exception
We should only log this error if it is not a malformed URL.
never "null"
never null
never null.
Diff should be out of sync with the previous patch
Diff should be interesting in this patch.
the check for null is in progress
Why do you need to check for null here? Can the annotation be removed?
Why do you need to check for null here?
Why do you use the public void onActionSync? Can the void method be called?
If you used 1.1 instead then you can no longer use System.version.
If you used 1.1 instead then you can no longer use System.gc() otherwise.
If you used 1.1 instead then you can no longer use System.gc().
as above for the private method
as above for the package, please remove it
same here for store
return id.getValue();
return id;
return id.getValue()
is this anonymous class necessary/intentional?
is this really needed/intentional?
is this needed/intentional?
This can be simplified to return EnvVars.getRemote(getChannel());
This can be simplified as return EnvVars.getRemote(getChannel());
This can be written as return EnvVars.getRemote(getChannel());
The id is used to identify the edit link. So it is misleading to put it in a local variable.
The id is used to identify the edit link. So it doesn't seem to be really used. findElement() can be used directly for logging.
The id is used to identify the edit link.
I'm not sure the cacheManager!= null check is necessary.
I'm afraid the cacheManager may not be initialized with the method reference.
I'm afraid the cacheManager may not be initialized with this method.
Check command and job null.
Check command and function null.
Check command and null.
I wonder if we can have a more neutral term. This is a K very specific concept
I wonder if we can have a more neutral term. This has a K very specific concept
I wonder if we can have a more neutral term. This is a () at this point.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Could you apply the same approach as for other exceptions too?
Could you wrap the name of the exception too?
null!= settings
If settings are null, the settings should never be null.
null = settings
Why not just return new BigInteger(data.length);?
Why is this condition required?
Why is this condition required? This is ERO
mapKeyForQueue -> key.hashCode()
mapKeyForQueue -> mapKeyForQueue
mapKeyForQueue -> mapKeyForQueue?
This code is a duplicate of the above. Can we pull it out into a method that explains the purpose?
This code can be reduced to: if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {... } else {... }
This code is a duplicate of the above. Can we pull it out into a method?
Please change all such methods to get the parameters of getGroupRoleNames.
Please change to List<String>, and change the signature of  getAllGroupsSize
Please change all such methods to List<String>, List<String>>.
I think you need to replace this with SpectraANode.createStreamAndNode(this, false, ExitCode.OK); (You already have a few places in the class).
I think you need to replace this with SpectraANode.createStreamAndNode(this, false, ExitCode.OK); (You already have a few line above).
I think you need to replace this with SpectraANode.createStreamAndNode(this, false, ExitCode.OK); (I didn't see why the hardcoded false is hardcoded in the constructor).
this.isLoginEnabled()
this.checkSuccess()
this.
Prefix the list with SCIMSchemaDefinitions.SCIM_COMMON_SCHEMA.getAttributesList()
Prefix the SCIMSchemaDefinitions as SCIMSchemaDefinitions.
Prefix the variable with the.equals() call.
You don't need to close the client, just return the return value.
You could just use Closeables2.closeQuietly(azureBlob);
You could just use Closeables2.closeQuietly(azureBlob); instead.
let's use else as this is more precise?
let's use else on the if block
let's use else on this block
nit: this.jws = other.jws;
Is this class used anywhere?
nit: this.jws
Need to check that the context is for this context.
Need to check that the context is this bean's context.
Need to check that the event is for this context.
I think this could be simplified by actually printing the data onto the file system. I'm not sure why VarSim.jar should accuracy be applied here.
I think this could be simplified by actually printing the data using the --w flag. WDYT?
I think this could be simplified by using a builder: build and not public.
return o == this;
return o instanceof AbstractObject;
return o == this;?
... this.limit = limit;
...this.limit = limit;
...this.limit = limit;?
I'd change the back to.zip() here instead of hardcoding the string.
Why it is so complicated? I'd prefer to follow the logic in a way so that there is a change in behavior here.
Why it is so complicated?
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if!ref.startsWith(oldPrefix)
I would feel more comfortable with this if you did something like throw new IllegalArgumentException("Unable to start with " + oldPrefix)
I would feel more comfortable with this if you did something like throw an IllegalArgumentException.
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "this.". [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "this.". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "this.". [![rule](<LINK_1>](<LINK_0> :)
Is this the best way to handle nulls?
Is this the best way to do it? It seems to me there is a way to get notifications of some sort.
Is this the best way to do it?
In this case, why do we need to close the file **and** the directories?
In this case, why do we need to close the file **after** processing?
In general, I would use File.separator instead of "/"
Curious why we want the value to be same as DASH?
Curious why you want the value to be same as DASH?
Curious why we want the same value if we have the same value
nit: Add requireNonNull for repoManager to avoid NPEs.
nit: Add requireNonNull for repoManager to avoid NPEs
nit: add requireNonNull for repoManager
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
Think this needs to go right below line 91. catch (Throwable e) { callback.onSuccess(parseResponse(response, bodyConverter)); }
Think this needs to go right below line 91.
The message should be included if the producer is supported
The message should be included in the Kafka subscriber.
The message should be included in the exception.
the system property name is the same, why use "logsTargetDir"?
the system property name is the same, why use "logsTargetDir"? If you want to change the users it would be better to change the System property.
I think it would be more robust to change the name of the parameter to getRootDirectory
suggestion return map.entrySet().stream().map(Pair::getKey).collect(Collectors.joining(", ", "[", "]"));
suggestion return map.entrySet().stream().map(entry -> e.getKey() + '=' + e.getValue().getFirst()).collect(Collectors.joining(", "));
Multiple points of the map.
This will just format "timezone" where it's an extra parameter. Can we just format it in the string to just do Boolean.valueOf(timeoneOffset.getTimeone(property(env, "timezone"))
This will just format "timezone" where it's an extra parameter. Can we just format it in the string to just do Boolean.valueOf(timeoneOffsetHours)
This will just format "timezone" where it's an extra parameter. Can we just format it in the string to save it?
I think we discussed this in #176
I think we should only increment if there is a query.
I think we should only increment if there is a bug.
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void...) This avoids extra sync objects (and saves one level of indentation!)
if you are synchronizing whole class, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void...) This avoids extra sync objects (and saves one level of indentation!)
if you are synchronizing whole method you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void...) This avoids extra sync objects (and saves one level of indentation!)
@weisebrazil all indentations should be 4 spaces, not 8.
@weisebrazil There is a bit of code duplication here. If we are using this.tagged.path(name) it is great to introduce a new method.
@weisebrazil There is a builder for this (tagged) method.
dublicate biz
dublicate biz part there
dublicate get this
Use a constant.
Use message "Description".
Use message "Description"
Is it relevant to the right check? Can't we just add this as a generic method in the base class for getting the JSON object?
Is it relevant to the right check, such as when the annotation is used? If so, should we be able to cover it in a test.
Is it relevant to the right check? Can't we just add this as a generic method in the base class?
Please fix the log message to be like: "The latest reviewers configuration is not updated at all"
Please fix log formatting.
Please fix the log message to be more explicit.
Should we add a null check here?
Should we add a null check here to prevent a NPE?
Should we add a null check here to prevent NPEs?
NotifierHandler::destroy is called at the end of this method, so I wouldn't call it, but also it would be nice to have a private method named addNotifierHandler, which actually makes the creation of the handler a no-op implementation.
NotifierHandler::destroy is called at the end of this method, so I wouldn't call it, but also it would be nice to have a private method named addNotifierHandler, which actually makes the creation of the NotifierHandler more complex.
NotifierHandler::destroy is called at the end of this method, so I wouldn't call it, but also it would be nice to have a private method named addNotifierHandler, which actually makes the creation of the NotifierHandler interface more complex.
I'd use new seeded byte[2048]; and be more explicit.
I'd use new seeded byte[2048]; instead (2048L)
I'd use new seed(2048L).
what about location? we do not need LocationSerializer?
what about location? we do not need LocationSerializer?
Should be.registerTypeAdapter(Person.class, Person.PersonSerializer()).create();
try-with-resources
check close()
check close() first
Shouldn't this be a noop?
Shouldn't this be a StateTransferEvent?
Shouldn't this be > ONE?
I think this is an improvement, but for now, txn.getStatus() == ACTIVE || txn.getStatus() == MARKED_ROLLBACK The code is only called once per transaction commit, so we might need to check if transaction is in transaction (I think).
I think this is an improvement, but for now, txn.getStatus() == ACTIVE || txn.getStatus() == MARKED_ROLLBACK The code is only called once per transaction commit, so we might need to check if transaction is in the same transaction as transaction (I think).
I think this is an improvement, but for consistency with the rest of the code in this class, can you put the check here?
Should this method be static?
Why do we need these properties?
Same as before.
There's no packet data, this contains partial NRB data amputated by what was read in 28 bytes of packet data?
There's no packet data, this contains partial NRB data amputated by what was read in 28 bytes of packet data.
This is a local variable, should be camelCase not fCamelCase
Since this is a public class, do we need a better way to setup all metrics? Putting it here feels a bit awkward.
Since this is a public class, do we need a better way to do this?
nit: do we need this line?
why do you need path.getValue()?
why do you need path.value()?
why do you use path.getValue()?
I don't think this is going to work. The default behavior should be to keep the parser and maybe the DataBindingUtil.trackScreenView(Analytics.Screens.ALL_SUBJECTS); when the new request is provided.
I don't think this is going to work. The default behavior should be to keep the parser and maybe the DataBindingUtil.trackScreenView(Analytics.Screens.ALL_SUBJECTS); even if the request is empty.
I don't think this is going to work. The default behavior should be to keep the parser and not the data binding.
do we need AdsFandomPage created inside getJquery() method? it will be more straightforward and easier to avoid duplication.
do we need AdsFandomPage created inside getJquery() method? it will be more straightforward and easier to avoid duplication
do we need AdsFandomPage created inside getJquery() method?
It's better to use (Label) that).name()
It's better to use (Label) that).name() too
Should use getClass() here.
This cast is bit suspicious. We can just use (short) (bytes[pos] << 8 | bytes[pos + 1] & 0xff).
This cast is bit suspicious. We can just use (short) (bytes[pos] << 8 | bytes[pos + 1] & 0xff);
This cast is bit suspicious. We can just use (short) (bytes[pos + 1] & 0xff).
If we are returning null, we should probably have a check for it.
If we are returning null, we should probably return an error or a warn.
If we are returning null, we should probably have a check for it
Maybe we can also return null if everything is not found?
Maybe we can also return null if everything is not valid?
Maybe we can also return null if it's not found?
.collect(Collectors.joining(", "))); please
.collect(Collectors.joining(", "));
.collect(Collectors.joining(", ")));
You can do return tags!= null? tags.equals(that.metric) : that.tags == null;
You can do return tags!= null? tags.equals(that.tags) : that.tags == null
You can do return tags!= null? tags.equals(that.tags) : that.tags == null;
check if trace is enabled
check if trace is enabled?
return this
Can you use Map<String, String> meta = new HashMap<>();
Can you use Map<String, String> meta = new HashMap<>();?
Can you use Collections.singletonMap to make it immutable?
why set the messages to NETWORK_ADD but not {action}?
why set the messages to 'Move '?
why rename?
Why are you doing this? There is a method that does the right thing to add to the lexical class, or something similar.
Why are you doing this? There is a method that does the right thing to add to the lexical class, or something similar that does the right thing.
Why are you doing this?
The caller will _fail_ if the region is empty.
The caller will _fail_ if the region is not null.
The caller can.
This method can be static
This method is static, so return null..
This method is static, so why not use static?
Why do we need this? I think it's already done in the constructor.
Why do we need this?
Why do we need this? I think it's already the case.
Shouldn't this condition never be true?
shouldn't this condition never be true?
Shouldn't this condition never be true??
please add a 'else if'
you could also use ColorMode.getColorTemperature() and Math.round() here.
you could also use ColorMode.isAlpha() here.
nit: consider using Matchers.extract(this). asText() instead.
nit: consider using Matchers.extract(this). asText()
nit: consider using Matchers.extract here
This isn't a good way to combine the 2 above, but it's a little more readable.
This isn't a good way to combine the 2 above, but it's a little easier to read.
This isn't a good way to combine the 2 above, but it's a bit more readable.
Shall we close the session here too?
1. You should close the session here and close it in finally block. 2.
1. You should close the session here and close it in finally block. 2. If an exception is thrown on close we will be closing the session.
Let's add a max(long parallelism) method to Function<Long, Long>.
Let's add a max(long parallelism) method to ExecutionUtils. If you need to ensure number of threads can use it.
Let's add a max(long parallelism) method to ExecutionUtils. If you need to ensure number of plugins pass a parallelism parallelism as well.
Double.toString((long) rate) rate);
Double.toString((long) rate) rate)
Double -> long
can be public.
cont -> cont
can be public
It's better to declare this Util.getLongLong() above and then use it in the call to Long.MIN_VALUE.
It's better to declare this Util.getLongLong() above and then use it in the conditional block. To avoid repeating it could be called in many places, something to think about.
It's better to declare this Util.getLongLong() above and then use it here.
It's a little odd to call super.runWork() here since it's already a lambda.
It's a little odd to call super.runWork() here since it's already a lambda to a function.
It's a little odd to call super.runWork() here since it's already a lambda. (I'm not sure if it's necessary though).
I think the intermediate SearchableListModel isn't needed, as it's not used anywhere else.
I think the naming makes sense, Parameters shouldn't have any effect.
I think the naming makes sense, Parameters shouldn't have any effect
debug, please
debug
debug please
This method could be private
This method could be private.
This method could be static
The indents have 2 spaces
The duplicate method has a separate pass.
The indents have 2 spaces.
Not sure the logic is correct here. getConstructorOrMethod() can return null.
Not sure the logic is better here. getConstructorOrMethod() can return null.
Inline this?
@fanifieiev the same above.
@fanifieiev the same above. please use RsOf.empty()
final
write all of these fields and mateReadSequence methods are identical.
write all of these fields directly into theReadHeadInfo and mateReadSequence fields?
write all of these fields directly into theReadHeadInfo?
should this throw an exception? [the same for all the other similar cases]
should this return [Schema.cast](<LINK_0> instead?
should this return'super.asAnnotationDeclaration(this);'?
nit: public void setMetric(Object metric) {
Would it be better to make this private?
Would it be better to add an @Override annotation here?
Same here, it is a bit hard to follow. Can you explain it in the future?
Log message at the end of this method.
Log message at the end of this method
Why do you need this change?
Why do you need this test? This method doesn't assert that numberExpected is an expected value.
Why do you need this test? This method doesn't seem to be used, what's the difference?
Same as above. Please use the description instead.
Same as above. Please use a description instead.
Same as above. Please use the spring class name.
I don't think we need this array.
I don't think we need this array. We can use Arrays.asList() here.
I don't think we need this array. We can ask the ENUM_DEF for this.
Why not put("\n", "\\\\f");?
Why not put("\n", "\\\\f") in this line?
Why not just put("\n", "\\\\f") in this line?
I would replace the original exception with a more descriptive message here.
I would replace the original exception with a more descriptive message.
I'm just wondering if we can make impactScore() more flexible given that the scoreHolder class will always have no weightMultiplier set to true?
We can replace waitItemOnContexMenuIsNotVisible with TestProjectExplorer.openContextMenuByPathSelectedItem(PROJECT_WITHOUT_GIT_FOLDER);
We can replace waitItemOnContexMenuIsNotVisible with waitItemInContextMenu(String) projectExplorer.openContextMenuByPathSelectedItem(PROJECT_WITHOUT_GIT_FOLDER);
We can replace waitItemOnContexMenuIsNotVisible with waitItemInContextMenu(String) to avoid code duplication.
Can it throw an exception, if condition is not met?
check if numEvents is negative?
check if numEvents < numEvents
I think there is a very good reason to make this public and move it to a private method
I would move the variables for the class and give the proper name
I think there is a very good reason to make the constructor public and move it to a 2 static methods
We should still have a call to MessageNano.toByteArray()
I think we should assert that data is null instead of throwing an exception.
We need to set a default value of networkMccmnc in these methods.
suggestion this.localPort = checkNotNull(localPort, "localPort");
suggestion this.localPort = checkNotNull(localPort, "remotePort");
Null check?
why is this method public?
why is this method static?
you can move "driver" to separate line
Maybe make createKafkaTopicRepository() to return a factory method in KafkaSettings.
Maybe make createKafkaTopicRepository() to return a factory method in KafkaSettings?
Maybe make createKafkaTopicRepository final?
use execute i mentioned above
use js.execute(script).toString()
use js.executeParam()
We can use XmlSuite.ParallelMode.FALSE for that case.
We can use it even in one line.
If it's deprecated it should be false even though we are in the future
is this change necessary?
is it ok to have the fields for these?
is this null?
Do we need to include versioningConfiguration here?
I'm not sure if we want to include versioningConfiguration here since we have them in the toString().
I'm not sure if we want to include versioningConfiguration here since we have it in the toString().
could you check for empty? i.e. check syncSession.isempty?
could you check for empty? i.e. "last session dropped" or something?
could you check for empty? i.e. "last session dropped" or something like that?
Item dropped should be a hopper
Item dropped is hopper
Item dropped should be a
you can just make this method final and use it in both places
you can just make this method private and call it from the generic method
you can just make this method final and use it in the AddVmCommand
there is no reason to use TmfEventTypeCollectionHelper.getEventFieldNames(getContainedEventTypes()) as the name of this method is already generic.
there is no reason to use TmfEventTypeCollectionHelper.getEventFieldNames(getContainedEventTypes()) as the name of this method is already generic...
there is no reason to use TmfEventTypeCollectionHelper.getEventFieldNames(this)
@Override required on this line
@Override required on a separate line
can be omitted
Leftover debug line? I know the old PR was only about this, but it may be still useful to ambigous.
Leftover debug line? I know the old PR was only about this, but it may be worth changing now, so we're renaming ldLibraryPath.
Leftover debug line? I know the old PR was only about this, but it may be worth changing now, so we're renaming ldLibraryPath as well.
Wondering if we should add a default case here too.
Wondering what's this?
Won't this cause problems with a globalMinimumClock as local time?
I think this call does not need to be public
I guess this could be an exception.
I think this call does not need to be public?
If you pass that that you also need to wrap it on a LibertyMojoDeploy, why not just call runLibertyMojoDeploy()?
If you pass that that you also need to wrap it on a LibertyMojoDeploy, why not just call runLibertyMojoDeploy?
If you pass that that you also need to wrap it on a LibertyMojoDeploy?
@cvrebert let's move this to package-private
@cvrebert let's inline this variable
@cvrebert let's move this to package private static final
Remove useless assert
Remove useless import
Remove useless assertEquals
Shouldn't we do this in the finally block?
Should we do a null check for the FINE log message?
Should we do a null check for the FINE log?
what is the purpose of this conditional?
I think this should be moved inside the try and remove the extra call to getContext().setWikiRef(wiki)
I think this should be moved inside the try and remove the logic and move it inside the try block.
type here. Need to check.
should this fit in one line?
should use return KeyVaultKey.
I assume there is no such thing as logWithFormat, except for the size of the object. This could be replaced by logWithFormat("ConfigObjects size %d\n", oldValue);
I assume there is no such thing as logWithFormat in the EResultData class?
I assume there is no such thing as logWithFormat in the EResultData class.
you can call after the test.
you can call just "put"
you can use putAll
Be careful, can you rename 1/v to targetWeights?
Be careful, can you rename 1/v to targetWeightsForProvider?
Be careful, can you rename 1/v to targetWeightsForCode?
Nit: there is no static reason to be package private. Just return the string instead.
Nit: there is no static reason to be package private. Same for the other wrap functions.
public
dont use magic numbers
Typo in unrecognized
Typo in error message
Probably should crash if bad format string
Probably safe to crash if bad format string
Probably should crash if bad format string is
When adding group attribute to voadmin, it's not possible to use list of group attributes.
When adding group attribute to voadmin, it's not possible to use list.create() here.
When adding group attribute to voadmin, it's not possible to use list.create() to enumerate attributes.
can you log the folder id here? I think it would be useful to have a log message in the log files as well
can you log the folder id as well? I think it would be useful to have a log message in the log files as well
can you log the folder id as well? I think it would be useful to have a log message in the log directory itself
Is this a bug? Should we throw an exception instead?
@romani Should we add some more information to this list?
@Override
This should be List<Annotation>
Wouldn't the contains() be simpler here?
Wouldn't the contains() be sufficient here?
catch(final RuntimeException ex) { log.error("Error during log command: {}. ", ex.getMessage(), ex); }
log.error("Error during log command: {}. ", ex.getMessage(), ex);
catch(final RuntimeException ex) { log.error("Error during log command: {}. Exception {}", getClass().getName(), ex.getMessage()); }
Is it good to have the nullable annotations on the method?
Is it helpful to have the exception in the log?
Is it helpful to have the exception on the log?
It seems to be either there should be some message argument in the log message - not that it's saying STANDBY.
It seems to be either there should be some message argument in the log message - not that it's either
It seems to be either there should be some message argument in the log message - not that it's the only case.
I am wondering if we should use a callback here. WDYT?
I don't think we need this listener. It should be called on a background thread.
I don't think we need this listener. It should be called on a non-Standby thread.
Simpler: java GaussianDistribution.DistributionModel.from_value(this.model_type));
Simpler: java GaussianDistribution.DistributionModel.from_value(this.model_type)
Simpler: java GaussianDistribution.DistributionModel.from_value(this. model_type));
nit: I think it's better to write mapper.orElseGet(ObjectMapper::new).convertValue(...) in the default mapper.
nit: I think it's better to write mapper.orElseGet(ObjectMapper::new).convertValue(...) in the same method.
nit: I'd extract this to a method reference because it's called multiple times.
You can use StringUtils.defaultString(string) here instead of String.format
You could use StringUtils.defaultString(string) here instead of String.format
You can use StringUtils.defaultString(string) here and in other places.
Should this be caught and logged as well?
You should be able to return void, and send it to client if there are no exceptions defined.
You should be able to return void, just like the other public methods.
can be private
can be package private
change to private
not all listener
rename 'listeners'
rename 'listener'
@erimerturk shouldn't this be configurable?
@dalifreire this should be System.out.println() or something?
@dalifreire this should be moved to public?
I believe we should throw ShutdownException instead of UnsupportedOperationException.
I believe we should throw UnsupportedOperationException.
Same as above. I believe we should throw UnsupportedOperationException.
if this is debugging help you might want to have a test that ensures that readResolve is called.
if this is debugging help you might want to have a test that confirms that readResolve is called.
if this is debugging, please put a line before the properties
I think this should be an AssertionError if the value is Terrible.
I think this should be an enum, so that the default case can be 0.
I think this should be an enum, so that the default case can be taken
why not just inline it?
Um, the variable liveness is never used.
why not just set it to UP first then getLiveness()
I think we should avoid throwing an exception here. We should probably handle it in the method signature as well.
I think we should avoid throwing an exception here. It is likely best to handle this.
I think we should avoid throwing an exception here. We should probably fix the IndexErrorAdapter as well.
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control:no-cache here?
Some proxies may not grok the comma-separated headers; any reason we can't just use Cache-Control: no-cache here?
Can you move the check for definitions.size() == 0 to a local variable? If not I read the way it's currently written, but I think we should be able to get rid of this first.
Can you move the check for definitions.size() == 0 to a local variable? If not I read the way it's currently written, but I think we should be able to get null values.
Can you move the check for definitions.size() == 0 to a local variable? If not I read the way it's currently written, but I think we should be able to get rid of the null check.
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads needed or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at all?
Shouldn't this be a setText()?
You can make this a bit more clear and also ensure the response comes from the incorrect url.
You can make this a bit more clear and still use the FormulaUtil.showMessage().
You can use the EquivalentContentUpdatedMessage constructor for this.
You can use the EquivalentContentUpdatedMessage constructor instead
You can use the EquivalentContentUpdatedMessage constructor for these objects too
you might want to call update() here (if there is a reason it doesn't)
I think there's a potential NPE here if we have cr.length==0 and it's to be set to 0.
you might want to call update() here (if there is a lot of them)
Here you could just say > policy is only for leaf queues. Please choose policies for that policy.
Here you could just say > policy is only for leaf queues. Please choose policies for this policy.
Here you could just say > policy is only for leaf queues. Please find a different name for this policy.
fbTansportField.get(frameBuffer) would be better here
fbTansportField.get(frameBuffer) would be better here.
ah, this is returning a null
Does it make sense to use getShort here?
Does it make sense to use getShort here? I don't think it's needed.
Does it make sense to flush the buffer when you go from the beginning?
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over once.
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there is no recovery.
static import removeRecoveryInformation
entry
entry is the proper ID
entry is the proper entry
Would be good to have a metric for this to be INFO level
Can we move this to debug?
Would be good to have a metric with the incremental tag.
Can we add this to this file the file?
Can we return List<BlockLocationInfo> here?
Can we return List<BlockLocationInfo> here instead?
Can be simplified to: if (object == null) { object = FilterRegistry.loadFilterFromNBT(name); } return object;
Can be simplified to if (object == null) { object = FilterRegistry.loadFilterFromNBT(name); } return object;
Can be simplified to if (object == null) { object = FilterRegistry.loadFilterFromNBT(name); } else { object = filterRegistry.readFromNBT(name); }
@kritika-singh3 @viraj2712 -- How about adding a constant to ConfigurationService and use that here for a name?
@kritika-singh3 @viraj2712 -- How about adding a constant to ConfigurationService and use that here instead of the boolean?
@vilchik-elena There's a way to do that.
It seems weird to stop when shutdown is called, but not when shutdown is called. Can we move it into ClusterManager.stop()?
It seems weird to stop when shutdown is called, but not when shutdown is called. Can we make the clusterManagerAdapter a private field?
It seems weird to stop when shutdown is called, but not when shutdown is called. Can we make the clusterManagerAdapter a member?
why not pull this out into a static method?
why not just use bundles.get(0)?
why not pull this out into a method?
No need for this exception.
No need for this exception. This method will throw one more specific exception.
No need to throw exception here.
should return false
should return false if the validation fails
should return false in case the validation fails
I guess we can remove this.endUser.hasProperties()
I guess we can remove this.endUser.hasProperties() to ensure that we are sure that the user is not null.
I guess we can remove this.endUser.hasProperties() to ensure that this.endUser is not null.
how about the following? disk.setDiskAlias((String) diskDescriptionMap.get(DISK_ALIAS));
how about the other public methods? It's a little bit more readable.
how about the other public methods? It's a bit confusing that the method doesn't throw IOException
In general, JsonNodeUtils.fromJacksonNode(jsonNode) method could be replaced by: JsonNodeUtils.fromJSONNode(jsonNode).replace(name, JsonNodeUtils.toJacksonNode(jsonNode)));
In general, JsonNodeUtils.fromJacksonNode(jsonNode) method could be replaced by: JsonNodeUtils.fromJSONNode(jsonNode).replace(name, JsonNodeUtils.toJacksonNode(jsonNode));
In general, JsonNodeUtils.fromJacksonNode(jsonNode) method could be replaced by: JsonNodeUtils.fromJSONNode(jsonNode), JsonNodeUtils.toJacksonNode(jsonNode));
Wrapping the lines 173 to 170 line can be simplified.
This is not true for UNSPECIFIED.
final?
You can't use parameters.containsKey(key) here.
You can't use the key as the auto-value for this.
You can't use parameters.get(key) as the auto-boxing.
why do you need to wrap this in a constructor?
why do you need to store this in the constructor?
why do we need to copy paste this and the constructor?
why not delegate to StatusReturnForXmlRpc?
why not public? I don't think this should be public
why not public? I don't think this should be private.
How about this? suggestion return (List<Member>) team.getPlayers();
Shouldn't this be member?
How about this one as well? suggestion return (List<Member>) team.getPlayers();
minor: no need to break the variable name here.
minor: no need to break the variable name here, since you're using it on the next line?
minor: no need to break this variable
Integer.toString(major), Integer.toString(micro), qualifier);
Integer.toString(major) is simpler
Integer.toString(major) is simpler.
You could just do this: java return Futures.all(workQueue.get(id)).filter(Objects::nonNull).map(Map.Entry::getKey).collect(Collectors.toList());
You could just do this: java return Futures.all(workQueue.get(id)).filter(Objects::nonNull).map(Map.Entry::getKey).collect(Collectors.toList());
You could just put the key in the map.
Since this isn't an exception, we should be using the java doc of the constructor.
Since this isn't an exception, we should be using the java logger here.
Since this isn't an exception, we should be ignoring the exception.
I would prefer to keep it as it was, but the old constructor will remove the need to modify it.
I would prefer to keep it as it was, but the message can be removed.
I would prefer to keep it as it was, but the old constructor will remove the need to modify the filter.
You might want to check the return value returned by validateMountOptions()
You might want to check the return value here too.
You might want to check the return value returned by validateMountOptions
We can use StringUtils.isBlank
We can use StringUtils.isEmpty instead
We can use StringUtils.isBlank here
I think this method should be called dragDetectedInAvailable() instead.
I think that this method should be called dragDetectedInAvailable() instead.
I think this method should be called dragDetectedInAvailable and restoreAll.
Why did you make this public?
Why did you move the parameter to a local variable if you want to change it?
Why did you make this cast?
Should be static
This is not included in the test
This is not included in the tests
could be simplified: Collections.addAll(refsSpecs, specs);
could you change this to Collections.addAll(refsSpecs, specs);
could you change this to Collections.addAll(refsSpecs, specs);?
Formatting issues. Please use appropriate spaces between string literals.
Please use appropriate error message in the string, so it is clear when the string is not included.
Please use appropriate error message in the string, so it is clear when the string is not initialized.
Kind of picky, but maybe this should be named epdqAuthorisedNotification_whenChargeInAuthorisationSubmittedState?
assertFalse(response.isSuccessful())?
assertFalse(response.isSuccessful()) also works better for me
Possible NPE here if config.getRefreshTokenCookieConfig() returns null.
Possible NPE here if config does not exist.
Add a new method to the ConfigResolver class that contains the config from the configuration.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(int, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
does this need to be public?
Isn't this missing an else clause?
Isn't this missing an else? Could we log?
suggestion throw new IllegalArgumentException();
suggestion throw new IllegalArgumentException("No number of ids can be 0");
suggestion throw new IllegalArgumentException("No number of ids have been changed.");
Is it necessary to check that value is a JsonToken.VALUE_NULL?
Is it necessary to check that value is not null?
Is it necessary to call this again?
Argument name
"Argument name
:)
Check that the memory cache is not null
Check that the dynamic cache is not null
Check that the memory cache is not null.
This should be with the rest of the findViewByIds.
If you want to clear the wikipediaLanguages by doing [all the servers of the app](<LINK_0>, it should be with the number of threads  wikipediaLanguages.
If you want to clear the wikipediaLanguages by doing [all the servers of the app](<LINK_0>, it seems to me that this should be if-statement.
Interns is a constant, so this can be replaced by Integer.MAX_VALUE
Interns is a constant, so this should be safe. If you want to use it, you should use a variable like numBlocksAllocated.
Interns is a constant, so this can be a Tuple.
.build() doesn't look right to me
.build() doesn't look right.
.build() is not needed
I'm not super familiar with this particular change. Does it really make sense to use the builder pattern here?
I'm not super familiar with this particular change. Does it really make sense to expose this method to the system directory in the BuildTarget? Otherwise, this will be hard-coded in the future.
I'm not sure about this change. Does it affect other people?
getTask().getTaskId() returns an optional and we'll get NPEs here. I think it's better to first check if the model is the active review and then return null.
getTask().getTaskId() returns an optional and we'll get NPEs here. I think it's better to first check if the model is the active review and then do this.
getTask().getTaskId() returns an optional and we'll get NPEs here. I think it's better to store the retrieval for the model instead of the local key in the UI.
This doesn't look like it's being used, are we sure that it's safe to use?
This doesn't look like it's an error, it's just an assert that there's no.
This doesn't look like it's been used, should we?
Why ack vs handleAckedMessage?
Why not add the messageId to the log?
Why we have to reset the message here?
@non-null-check
@lanwen the public modifier should be on the first line.
@lanwen the first arg should be on the previous line.
I would put this in another test, something like: public void addLineItem() { ProductFixtures.withTaxedProduct(client(), product -> { LineItemDraft.of(product, 1, 5); final AddLineItem addLineItem = AddLineItem.of(product, 1, 5); final AddLineItem addLineItem = AddLineItem.of(lineItemDraft, addLineItem); testOrderEditStagedUpdateAction(addLineItem); }
I would put this in another test, something like: public void addLineItem() { ProductFixtures.withTaxedProduct(client(), product -> { LineItemDraft.of(product, 1, 5); final AddLineItem addLineItem = AddLineItem.of(product, 1, 5); final AddLineItem addLineItem = AddLineItem.of(lineItemDraft, addLineItem); testOrderEditStagedUpdateAction(addLineItem); })); }
I would put this in another test, something like: public void addLineItem() { ProductFixtures.withTaxedProduct(client(), product -> { LineItemDraft.of(product, 1, 5); final AddLineItem addLineItem = AddLineItem.of(product, 1, 5); } }
I'm a little worried about when this test is invoked more than once. Is there any reason you can't add more than once?
I'm a bit worried about when this test fails. Wouldn't it be better to add another test that checks if the file is still there?
I'm a bit worried about when this test fails. Wouldn't it be better to add another test that checks if the file is still in the buffer?
Please add a java Objects.requireNonNull(computation, "computation is null");
Please add a java Objects.requireNonNull(computation, "computation is null")
Please add a note here as well.
This should return the string instead of a String.
This should return the string instead of a String
This should return the String instead of a String.
Are we sure that this is the best thing to do?
Are we sure that this is the best place? It's not generally a best practice to use package-private access.
Are we sure that this is the best place? It's not generally the best place to use Guava's ObjectMapper constructor.
Mmm, I'm not sure if there is a good reason to add the same message. Let's discuss it
this.
Set?
Should we have a thread name here?
Should we have a thread name here? "discovery-service" should be thread name.
Should we have a public constant for this?
constructors should be package private
constructors should be public
constructors should be package protected
suggestion this.connectionFactoryMap.forEach((ldap, connectionFactory) -> connectionFactory.close());
suggestion this.connectionFactoryMap.forEach((ldap, connectionFactory) -> connectionFactory.close();
suggestion throw new NullPointerException("ConnectionFactory is null");
> "Workflow all targets in project"
> "Compile all targets in project " + project
> "Compile all targets in project " + project + "
Is there a reason you set the timeSource to null here but then you could just do config!= null here? I'm not sure if the logic should be here.
Is there a reason you set the timeSource to null here but then you could just do config!= null here? I'm not sure if there's a real reason to use null here.
Is there a reason you set the timeSource to null here but then you could just do config!= null here? I'm not sure if it's a good idea to have null here.
use ShellIsAvailable
remove ShellIsAvailable
take out of test with false
I would create a StackEvent and reuse the same code: List<Selectable> chain = new StackEvent(partitionUpdateEvent.SALT_UPDATE_EVENT.event());
I would create a StackEvent and reuse the same code.
SaltUpdateEvent.SALT_UPDATE_EVENT
should be synchronized
How about moving the paymentId logic to LedgerTransactionTransactions?
How about moving the response code to LedgerTransactionTransactions?
Shouldn't this return Boolean.FALSE instead? We should get rid of the cast.
Shouldn't we return Boolean.FALSE here?
Shouldn't this return Boolean.FALSE instead? We want to get rid of the cast.
s/public//
Can we make this a constructor that takes only the boolean parameters?
Can you make this a constructor that takes only the boolean parameters?
Can you throw a more specific exception?
Can we throw a IndexOutOfBoundsException?
Maybe throw a general exception here?
I'm thinking that it should be able to test the max rows of the column in the table and it is already set via the column name.
I'm not sure that it's good practice to test the condition that is not set here. If someone has a user parameter it will get a list of columns, which is supposed to be returned.
I'm not sure that it's good practice to test the condition that is not set here. If someone has a default value of "email" then it's setting it right after the test.
Should this be "config.getTelemetryConfig().isEnableTelemetry()"?
I think this is a break, not sure what we want.
Should this be "config.getTelemetryConfig().isEnableTelemetry()"
Minor: We should be consistent with equals for hashCode.
Minor: We should be consistent with equals and hashCode.
Minor: We should be consistent with equals method.
Can this be done with [Resource.getResource](<LINK_0>?
Can this be done with [Resource.getResource](<LINK_0>?
Can this be done with.apache.commons.lang3.StringUtils.unmodifyableName(name))?
this method should be kept, I think.
this method should be kept to package private
this method should be kept to package
I would make this a bit more obvious, e.g. why this needs to be wrapped in a subclass, not in the one added final field
I would make this a bit more obvious, e.g. why this one needs to be wrapped in a subclass, not in the one added final field
I would make this a bit more obvious, e.g. why this needs to be wrapped in a subclass, not in the one who creates this.
Should showError be internationalized?
Should we show the error with a more useful message here?
Should we show the error with a more meaningful name?
suggestion return Destination.from(getOrDefault(DESTINATION, defaultDestination.toString()));
I think it would be better to use the map instead of getOrDefault.
suggestion return Destination.from(getOrDefault(DESTINATION, defaultDestination.toString()))
Should not we synchronize on this?
Should this also be synchronized?
Should not we add the same breaking change here?
This is wrong. I have only one element in the URL. Consider renaming to "file".
This is wrong. I have only one element in URLContent. Consider renaming to getUrl() instead of getUrl().
This is wrong. I have only one element in URLContent. Consider renaming to getUrl() or something like that.
buildStreamToRulesRuntime() is only called in buildStreamToRulesRuntime(), so I think it is better to inline
buildStreamToRulesRuntime() is only called in buildStreamToRulesRuntime(), so I think it is a better change.
buildStreamToRulesRuntime() is only called once in buildStreamToRulesRuntime() so it can be moved inside the method
onErrorInternal returns a value in case of no task listener, so you should check for nextTaskListener == null first.
onErrorInternal returns a value in it, so you can use dismiss() method.
onErrorInternal checks unneeded
This is a little peculiar - does the flag need to be true here?
This is a little peculiar - does the flag need to be in between 0 and 1?
This is a little peculiar - does the flag need to be true here? Maybe we should only check for -1 here?
getColumn should return the value rather than the value.
getColumn should be private, and called from somewhere else.
getColumn should be private.
Why first the connection, then the check and disconnect?
Why first the connection, the check and disconnect?
Why first the connection, then the if() statement should be first?
This should say "LocalTime".
Can we use UTC in the tests for this?
Can we use UTC in the tests for these?
selection may be null, as you checked it in the UI plugin.
selection may be null, should return null
No, we can return null here
Possibly shorter to just return id3v2Tag.getGenre()?
Possibly shorter to just return id3v2Tag.getGenre() an instance variable?
Never change this method, it's a public method.
Any reason for this?
Any reason why we want to set this?
Any reason for not using string literal here?
No need for this. The absolute formatter is not used.
No need for this. The absoluteFormatter is not used.
No need for this. The absolute formatter is absolute.
Why there's no ((ClassSymbol) symbol).hasUnresolvedTypeHierarchy();?
Why there.
Why there's no ((ClassSymbol) symbol).isOrExtends("BaseException")?
I don't think you need to do this. The whole method can be removed.
Cache environment variable.
I don't think you need this, and as a separate inject() method in the @Inject.
What is the need for the null check?
What is the exception handling for?
What is the need for the null check here?
nit: Our constructor can call this one instead of making it private.
nit: Our constructor can call this one instead of making this private.
One minor nitpick. It's better to make this constructor private.
We can't do this but in SamzaContainerTestManager?
We can't do this but in SamzaContainerTestUtils.
We can't do this but in SamzaContainerTestManager.
Why super.close()?
You are missing a super.close() here
You are missing the super.close();
Minor: please remove the curly braces.
Minor: please remove the curly brackets.
Minor: please remove the local variable processResults.
try to use CouponId for all coupons
try to use 'Long'
try to use 'Long', to avoid lock exception
Quality tools will complain about that statement because the string is not a string.
Quality tools will complain about that statement because the string is not a constant.
Quality tools will complain about that statement because the string is not constant.
@marko-bekhta Is this still a copy? Maybe we can use something like: names.append( String.format( "%n>>>>> ), "%n>>>);...
@marko-bekhta Is this still a copy? Maybe we can use something like: names.append( String.format( "%n>>>>> ), "%n>>>);...?
@marko-bekhta Is this still a copy? Maybe we can use something like: names.append( String.format( "%n>>>>> POSIImmn<>( names ) ) ); And we can remove some extra line after the ternary operator.
small small but we could have the regex as a static final constant, so you don't have to split it every time.
small small but we could have the regex as a static final constant, so you don't have to split it each time.
you are capturing only the first match, not only the second.
I'd like to have the 'this.' usages in the setter.
I'd like to see the semantics of this method.
Should we check the null here too?
move null check back as first action to not change behaviour.
move null check back as first action in the constructor, and move the check there.
move both checks to the constructor and make them static.
Our error messages have fields with the same name but it's not clear to me why they are the same.
Our test is complaining about the null object message as well, I think it would be better to create a custom assertion for the errors variable.
Our error messages have fields with the same name, please.
Why not just CHECK_NAME + ": " + getStatusMessage(CHECK_NAME).exceptions);
Why not just CHECK_NAME + ": " + getStatusMessage(CHECK_NAME).exceptions();
Minor: it's a bit strange to have this as a static method.
You could put these two lines in a private method.
Consider moving these properties to a single place.
Instead of setting these properties if you are using the default value.
I feel like this updateThreadPoolSize() can be part of the RetentionPolicyMgr
I feel like this updateThreadPoolSize() and updateThreadPoolSize() can be part of the RetentionPolicyMgr
I feel like this updateThreadPoolSize() can be part of the RetentionPolicyMgr?
rename
rename to listener
rename listeners
Here we need to check the OMResponse flag also. As before, we don't need to create new transaction.
Here we need to check the OMResponse flag also. As before, we don't need to add this new code.
I think we can move this inside the if block.
What if machine name is wrong?
What if machine name is zero?
If machine name is wrong, it will wait forever if machine is still zero.
Perhaps move the adapter.getItemViewType(position + 1) == HEADER_TYPE to a separate variable named HEADER_TYPE?
Perhaps move the adapter.getItemViewType(position + 1) == HEADER_TYPE to a separate variable named HEADER_TYPE.
Why is this needed? It would be guarded by a null check inside the if
Nit: I would change the string to "Payment info is here and use "Payment info is retrieved"
Nit: I would change the string to "Payment info is here and use "Payment info is too long."
Nit: I would change the string to "Payment info is here and don't have an integer division in the code.
The order of the arguments is reversed - it should be assertEquals("Test_123", result);
The order of the result is reversed - it should be assertEquals("Test_123", result);
The order of the arguments is reversed - it should be assertEquals("Test_123, result);
Assert.notNull()
Assert.notNull()?
IllegalArgumentException?
I don't think this is correct because getAnnotation( As.class ) returns an Optional<String> instead.
I don't understand this code. If Hidden.class is not defined, then we should implement it as a default value.
if(...
do we want to log the exception or use a more useful error here?
do we want to log the exception or use a more useful error message?
do we want to log the exception or do this somewhere more?
You probably need to close ins here.
You probably want to use try with resources, no?
You probably want to use try with resources here.
Please use the positional parameters.
Please use the positional parameters, this way you have it more easily.
Can you use the positional parameters?
As mentioned before, this method should return a SubMonitor.
As discussed offline, please add checks to these methods.
As mentioned before, this method should return a boolean.
Use assertEquals
Use the interface, assert, instead of assert.
Use assertEquals()
Won't this throw a NullPointerException if the config is null?
"Cannot call S3BlobStoreConfig.createInstance() is not enabled"
"Cannot call S3BlobStoreConfig.createInstance() is null"
Missing doc =...
remove that?
remove?
Can be just List<StandardDrive>.
Can be replaced with lambda.
Can be just List.of (or List).
This should be done in a finally block.
This check is done by the onLogin() method
This check is done by the onLogin() method.
Can you make this package-private?
Can you make the strings a private static final?
Can you make this package private?
Remove all " case" case. There is a default case for that.
You can't handle failure cases. There is a default case for that.
You can't really remove all " case" case. There is a default case for that.
suggestion if ( rndNum < rndNum - NUM_OF_NUM_COLUMNS){
suggestion if ( rndNum < rndNum - 10) {
suggestion if ( rndNum < rndNum - NUM_OF_NUM_OF_NUM_COLUMNS){
nit: you can change the logging message to debug
nit: you can change the logging order to debug
nit: you can change the logging level to debug
clientIntelligence -> clientIntelligence
clientIntelligence -> BASIC
Isn't the clientIntelligence a bit sparse?
To be consistent, please use isEmpty()
To me, it seems that this method is only called in the single place, how about returning UNKNOWN_PROVIDER directly?
To me, it seems like this is more of a workaround. If there are more than one method called remove(prvdr) and return UNKNOWN_PROVIDER.
Is there a reason why we need this method?
Is there a reason we need this method?
Is there a reason why we need this?
If we are going to keep this, maybe better to add a string literal instead of a JSON object?
this is basically unnecessary, see above for generateParseLink.
this is basically unnecessary
Should we add Args.notNull() here like we do in BindingDetails?
Should we add declaise variables here?
Should we add.equals() here?
If this is called from multiple threads, put it in the dataStores map, and if so, then this method can be synchronized.
If this is called from multiple threads, then this method should be protected.
If this is called from multiple threads, put it in the dataStores cache?
List<Role> roles = List<Role> roles = getRoles(username);
List<Role> roles = (add)? roles.toString() : null;
List<Role> roles = List<Role> roles;
put @NonNull on its own line
@NonNull should be on the line above
@NonNull on its own
Is this really necessary? I think this can be removed.
I think this can be private.
Is this really necessary? I think this can be set by spring application.
"return null"
Why'return null'
Why'return'
You should use the constant today, but not the other way around. rejectField(context, "day")
You should use the constant today, but not just the ending of that list. This is repeated elsewhere.
You should use the constant today, but not the other way around. rejectField(context, "day").
please, add a space before the if
please make a line before the brackets
please, add a space before the if.
this is 3.3 feature, not 3.2
this should be VersionUtils.greaterOrEqual and not hardcoded.
this should be VersionUtils.greaterOrEqual()
synchronized -- this class is thread-safe and guaranteed happens-before between producing readable code and consuming it
synchronized -- this class is thread-safe and guaranteed happens-before between producing code and consuming it
synchronized -- this class is thread-safe and guaranteed happens-before between producing value and consuming it
Change "Finished Tasks Output" to "Finished Tasks Output". E.g. Tasks Description"
Change "Finished Tasks Output" to "Finished Tasks Output"
May be an artifact of "Finished Tasks Output"
Is this what we want? The default pattern will be replaced for Platform and not Platform
Is this really needed?
Is this what we want?
Wouldn't be better to change variable name to nonSame?
Wouldn't be better to change variable name to nonSame here?
Wouldn't be better to change variable name to non-null?
It's beeter to used int type.
It's beeter to used int type
It'd be better to used int type.
rename to v
rename aV to tx
rename aV
Prefer return (T) parameter.getValue();
Exception?
RuntimeException
please refactor to a method for this
please refactor to a common method for this
please refactor to a common method for this function.
concurrency issue too
concurrency concern too
concurrency issues too
This method could be declared as return a!= null? a.getState() : false;
This method could be declared as return a!= null? a.getState() : false
This method is called at many places and can be potentially called multiple times.
Man, this test does not assert that the order of tables is 1?
Man, this test does not assert that there are two annotations (minimal columns)
Man, this test does not assert that the order of tables is correct.
final?
throws or exception
throws or exception?
You should call the "deleteAllMetadataRecords" method as it is called only once.
You should use the "public" annotation here.
Should be sync
please remove empty line or add space in log message
I would change this to throw an Exception.
please remove empty line or add space in log message.
can we add a message to the log, that way it is easier to debug if we want to update it while we are at it?
can we add a message to the log, that way it is easier to see what it is?
can we add a message to the log, that way it is easier to debug if we want to add more information to the future while we are at it?
Why are we changing the behavior?
Why are we changing the target codes?
Why are we changing the value of newRelationships here?
This method should be written in the more succinct way.
This method should be written in a more succinct way.
This method should be written in the more succinct way, i.e., if (void duplicated code) {... }
Log debug - not info.
Log debug - not debug.
Log debug - not error.
Shouldn't we throw an exception for any other exception?
Shouldn't we throw an exception if we get to a file already?
Shouldn't we throw an exception if we get a file already exists?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in GoogleAnalyticsSetting? If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in GoogleAnalyticsSetting.
Space after cast (several occurrences in this file).
Can you change this to Collections.emptyList(); and return an empty list?
Can you change this to Collections.emptyList(); as we are not using the return value?
it could be shorter: return isMemberOf(excludedGroups, groups);
@since Daniel suggested to make isExcluded(Collection<String> excludedGroups) a private method isExcluded(Collection<String> excludedGroups)
it could be shorter: return isMemberOf(excludedGroups, groups.length == 0);
It is better to log the exception to log.
We should log the exception to the log.
We should log the exception to log.
Maybe it's better to use the ComponentContext here?
Maybe it's better to use the component context here?
Maybe it's better to use the component context for all of them.
Simpler to do checkDuplicates(messageSetToWrite.getMessageSetInfo()).
Simpler to call logPutCountsPeriodically() now.
Simpler to do checkDuplicates(messageSetToWrite.getMessageSetInfo()) in exception handling.
please, use text "Name" instead of "projectName"
please, use text "Name of project" instead of "projectName"
please, use text "Name of project " + project.getName() instead of "projectName"
This could be made final
This could be made final.
This can be made final.
Consider making this check for null for awsSecretKey before returning new AWSCredentialsProvider().
Consider reverting this check into DefaultAWSCredentialsProviderChain and returning the object here.
Consider reverting this check into DefaultAWSCredentialsProviderChain and returning the extra object here.
wait for element before click
click on element
log method name here.
startTime = System.currentTimeMillis();
startTime = System.currentTimeMillis()
startTime =...
This is not necessary and will be handled by the method setDatabaseNameForCurrentThread()
This is not necessary and will be handled by the method setDBName(species) which is not necessary.
This is not necessary and will be handled by the method setDBName(species) which is not required and will be set.
I think we can avoid code duplication. If you think this should be simpler: java AnonymousSpec anonymous = new AnonymousSpec(); //... return this.anonymous == null? new AnonymousSpec() : new AnonymousSpec();
I think we can avoid code duplication. If you define anonymous as class variable, then you can use this.anonymous = new AnonymousSpec()
I think we can avoid code duplication. If you define anonymous as class variable, then use this.anonymous as the default variable.
please remove the public modifier
please remove this whitespace.
please remove the public modifier.
It's better to use static import here to improve readability of code.
it's better to use static import here to improve readability of code.
It's better to use static import here to avoid potential conflict with other tests
Use spaces from my variable names
Use of this.param1 = param2
Use of this.
printStackTrace is not needed
printStackTrace is not necessary
printStackTrace is missing
please update the method signature to be consistent with the entity commands framework.
please update the method signature and setCommand to true
please update the method signature also here and setCommand to true
Can we do this.virtualColumnsByExpression = Collections.emptyMap(); instead of all this.virtualColumnsByExpression?
Can we do this in AutodetectCommunicator::function instead of regular?
Can we do this.virtualColumnsByExpression = Collections.emptyMap(); instead of just using a HashMap?
Let's rename the variable too
Let's add this condition to the if too.
Let's rename the variable too.
I'd put new ArrayList<>() here, to be consistent with Spring Security's methods.
I'd put new ArrayList<>() here, to be consistent with the other methods.
I'd put new ArrayList<>() here, to be consistent with Spring Security's queryForObject, and leave this method signature consistent. also JdbcPageSink has a more general purpose.
I think this should be in 'RunInternalMultipleActions'. 'AdditionalHostSetupNetworks' can be invoked directly from 'BackendHostSetupNetworks'.
I think this should be in 'RunInternalMultipleActions'. 'updateParametersSequencing' can be removed.
I think this should be in 'RunInternalMultipleActions'.
You shouldn't depend on the expected value passed by the developer - you should go by MaskValidator.getInstance().isPrefixValid(mask).
You shouldn't depend on the expected value passed by the developer - you should go by MaskValidator.getInstance().isPrefixValid().
You shouldn't depend on the expected value passed by the developer - you should go by MaskValidator.getInstance().isPrefixValid(mask)
Eh, this is not an error.
The CustomAlert object is not used
The CustomAlert object is not used here.
Was just thinking about setting this to the Activity, but I'm not sure it's necessary to add a public constructor for the presenter.
Was just thinking about setting this to the Activity, but I'm not sure it's necessary to add a public constructor for this class.
Was just thinking about setting this to the Activity, but I'm not sure it's necessary to add a public constructor for the class.
Should this be on one line, or made it private?
Should be final.
Should be private, could also be made private
This is very nitpicky, but could you use a ternary operator here? localId = getLocalTableBlogIdForJetpackRemoteID(remoteBlogId, null);
This is very nitpicky, but might want to call localId = getLocalTableBlogIdForJetpackRemoteID(remoteBlogId, null); instead?
This is very nitpicky, but you could call getLocalTableBlogIdForJetpackRemoteID(remoteBlogId, null) instead, which will return the localId value.
to be sure, please always use the name jar, not the old one.
to be sure, please always use the name java.util.Optional instead of normalize
to be sure, please always use the name jar
If we want to keep the current state, we should move this to the finally block
If we want to keep the current state, we should move this to the finally block.
If we want to keep this code, we should move it to the finally block
I would prefer this to be a ConfigurationHelper.toJson(config, "allowedRecipients"), ALLOWED_RECIPIENTS_TYPE.getMessage()
I would prefer this to be a ConfigurationHelper.toJson(config, "allowedRecipients"), ALLOWED_RECIPIENTS_TYPE.toString()
I would prefer this to be a ConfigurationHelper.toJson(config, "allowedRecipients"), ALLOWED_RECIPIENTS_TYPE.getLocalizedMessage(), e);
because the name starts with colon, I'd prefer to use the {} for the name.
because of special, i'd suggest we use the name.replaceAll("") for the new string
because of special, i'd suggest we use the name.toLowerCase
can remove this null check and use getContentValuesPopulator.planAndAuthorize(contentValues, true) instead
can remove this null check and use getContentValuesPopulator.planAndAuthorize(contentValues, true).
can use getContentValuesPopulator.planAndAuthorize(contentValues, true)
Please add assertionError()
Please add assertionError() - with message default value
Please add assertion for exception cause type
Rename -> CosmosDbFactory to CosmosFactory
suggestion Assert.notNull(cosmosFactory, "MappingCosmosDbFactory must not be null!");
suggestion Assert.notNull(cosmosFactory, "MappingCosmosDBFactory must not be null!");
Please add @since 5.5 tag to each method and make this one line of code more readable. Also, please add a space after the {.
Please add @since 5.5 tag to each method and make this one line of code more readable. Also, please add a space after the return.
Can remove the throws IOException from the method signature.
we can return 'this' here as well.
we can't return a copy of the map
we can return PatientDataDefinition.this.omitNullValueDefinitions()
Why does the handler require a zkController? Same for the other one.
Why does the handler require a zkController here? Same for the other one.
Why does the handler require a zkController? Same for the handler.
These two methods can be private.
this can be Optional.ofNullable(uniqueIndex)
this can be Optional.ofNullable(fetchAtomic)
This can be removed since it's used in a nested CcToolchainProvider
This can be removed since it's used in an unrelated change.
This can be removed since it's used in an unrelated change
you could have a static variable for this.
you could have a static variable for this method
you could have a static variable for this method.
why not use assertArrayEquals instead?
why not use assertEquals?
why not use assertEquals on the values instead?
I do not understand the logic here. We create entries with every entry. And this will be invoked only once, since it will be backed by the map, which is not the case.
I do not understand the logic here. We create entries with every entry. And this will be invoked only once, since it will be backed by the map, which is not in the map.
I do not understand the logic here. We create entries with every entry. And this will be invoked only once, since it will be backed by the map, which is not the case. You should accept the original entries.
I think we should return true here instead of false.
I think we should return true here instead of false to indicate success.
I think we should return true here instead of false to indicate it was not found.
@erimerturk let's make this private.
@erimerturk let's remove this method and directly return the empty string.
This method is private.
Can we throw an exception instead of returning null?
Can we throw an exception instead of returning null here?
Can we throw an exception here?
Should this method be private?
Should this method return a stream or a class that contains both of these?
Please add some java docs to the method
Should this be.getWorkspace()?
Should this use getFullUrl()?
Should this be _project-with-a-rather-long-name?
You can do this in one line. try { return driverRecords.stream().map((OpcUaRequestInfo.requestInfos::add)).collect(toList()); } catch (Exception e) { log.warn("Exception while trying to retrieve driverRecords", e); }
You can do this in one line. java try { OpcUaRequestInfo.extract(record).ifPresent(preparedRead.requestInfos::add); } catch (Exception e) { log.warn("Error getting driverRecords", e); }
You can do this in one line.
why ColumnCheckConstraint here?
why cast this to a column?
why this cast?
There is no need for Objects.requireNonNull if it's null.
There is no need for Objects.requireNonNull if it is null.
We should handle it in the case where the future is null.
click on element not on page
wait.forElementClickable() should be used before
wait.forElementClickable() should be used here
@Happy-Neko it is better to catch AbstractCheckException and throw directly what is not correct.
@Happy-Neko it is better to catch AbstractCheckException when implementation is not abstract.
@Happy-Neko it is better to catch AbstractCheckException and throw directly what is not it.
Why the query? Why would you want to use the _ebeanServer here?
Why the query? Why would you want to use _ebeanServer.createSqlQuery?
Was the parens on purpose?
Perhaps add a log message here.
Perhaps add a log here.
Perhaps add a log line here, stating that we're failing the action query execution.
please rebase, arik removed the lock in a different patch.
I'm not sure we want to execute this code. if the engine is running in a different thread, the command might be during the run, so we should do not want to try to run the VM.
I'm not sure we want to execute this code. if the engine is running in a different thread, the command might be in the same thread, so we're safe to use that in case of an error
"valid times" seems to be redundant
"valid times" sounds better?
move this to the top?
What's the purpose of this info?
Same here (and the info below)
Same here about the info log.
fNumericCompilerSuffixes -> CharArrayUtils.EMPTY
fNumericCompilerSuffixes -> CharArrayUtils.EMPTY?
fNumericCompilerSuffixes -> CharArrayUtils.EMPTY / null
return Boolean.parseBoolean(getRequestParamValue(paramName));
Boolean.parseBoolean?
Boolean.parseBoolean
[minor] Consider using Preconditions.checkArgument here instead.
[minor] Consider using Preconditions.checkArgument here instead of the guava Lists
[minor] Consider using Preconditions.checkArgument here
I think we should add an assertion to the exception.
I don't think we should use exceptions.g. RuntimeException or Throwable here.
I think we should rather use an ExpectedException rule instead, and then catch and throw an actual exception.
You can return InetSocketAddress.create(...)
You can use OperationFailedException.
You can return InetSocketAddress.createEmptyMessage
Either remove the public modifier (i.e. make this method private) or give it a meaningful name.
Either remove the public modifier (i.e. make this method private) or give the "getMinGDBVersion" and the "getMinGDBVersion" methods.
Either remove the public modifier (i.e. make this method private) or give the "getMinGDBVersion" and the "offlineGDBVersion" methods.
This condition could be simplified to Assert.isTrue(action!= null, "action can not be null"); Assert.isTrue(action!= null, "action can not be null");
This condition could be simplified to Assert.isTrue(action!= null, "action can not be null"); Assert.isTrue(action == null, "action can not be null");
This condition could be simplified to Assert.isTrue(action!= null, "action can not be null");
I know this changes the legacy code, but as you removed the getStageReachedCounts from the SQL one, do you think we can de-dupe the code by modifying getStageReachedCounts from a single method?
I know this changes the legacy code, but as you removed the getStageReachedCounts from the SQL one, do you think we can de-dupe the code by modifying getStageReachedCounts from a single get call?
I know this changes the legacy code, but as you removed the getStageReachedCounts from the database, do you think we can de-dupe the logic of getting the returned Map<Map<String,Map<...>> instead?
For this value, use "tagId" instead of "tagId".
For this value, use "tagId" instead of calling getId() to make it more obvious what you're looking for
For this value, use "tagId" instead of calling getId() to make it more obvious what you're returning.
This should be private, and only be called by the super class.
This should be removed, and the removeSpectraInternalRequests accepts a boolean.
This should be removed, no?
Don't we want to keep this hardcoded?
Returning the name of the referenceactor was just a workaround for this PR.
Left-over?
please check here isSetPmProxies() otherwise you can get NPE
please check here setPmProxies() otherwise you can get NPE
please check here isSetPmProxies() otherwise you can avoid NPE
Why not 'instanceof' instead of creating an object for "get" as well?
Why not 'instanceof' instead of creating an object for "get-time" as well?
Why not 'instanceof' instead of creating an DateTimeAdapter here?
No need for the listener -> listener.layerDeleted(layerName);
No need for the parens on the listener -> listener.layerDeleted(layerName);
No need for the parens on the listener -> listener.layerDeleted(layerName).
Better to use UUID.randomUUID().toString()
Better to use Collections.singletonList rather than Arrays.asList.
Better to use UUID.randomUUID().toString() here too
Please consider adding a Preconditions.checkArgument to check that exists.
Fix indention (should align with following code).
Could the cipher suites be made configurable?
Aren't these two lines necessary?
I'm not sure that the Player cannot be null.
Add final keyword.
Remove for declaration.
Remove for consistency.
Remove for this
Can we have a more meaningful name for cause?
Can we create a constant for this magic number please?
use a constant for 300
This is the condition we need: if (_targetExternalViewCache = new TargetExternalViewCache(clusterName, customizedStateType)) { _customizedViewCaches.put(new TargetExternalViewCache(clusterName, customizedStateType)); }
This is the condition we enter from the condition. Let's move this to the condition.
This is the condition we enter to guarantee the _customizedViewCaches is non-empty.
Actually, I think you could just pass in new Gson().registerTypeAdapter(Person.class, Person.PersonUpdateSerializer).create();
Actually, I think you could just pass in new Gson().registerTypeAdapter(Person.class, Person.PersonUpdateSerializer()).create();
Actually, I think you could just pass in _new Gson().registerTypeAdapter(Person.class, Person.PersonUpdateSerializer).create();
maybe even log.debug("Query getEntriesByRecipient={}", query.toString()); better?
maybe even log.debug("Query getEntriesByRecipient={}", query.toString()); opposites of that.
isDebugEnabled
Please separate the declaration and remove the if statement.
Can be simplified to: java if (projectUploadController == null) { return new ProjectUploadController(); } return projectUploadController;
I'd remove the if here and in the @since clause.
does it make sense to send 2 versions of the verb to different hosts in the data center? (if one is older than 3.3 and other is 3.3) i think you should use storage pool compatibility version
does it make sense to send 2 versions of the verb to different hosts in the data center? (if one is older than 3.3 and other is 3.3) i think you should use storage pool compatibility version.
does it make sense to send 2 versions of the verb to different hosts in the data center? (if it is older than 3.3 and 3.3) i think you should use storage pool compatibility version
Uh, this is a CI test :)
Uh, this is a CI failure.
Uh, this is a CI failure!
But why do we handle 400 differently than all other errors?
But why do you handle 400 differently than all other errors?
But why do we handle 400 differently than other errors?
If we are here, should we be consistent with the default implementation or just use initSlabs instead?
If we are here, should we be consistent with the default implementation or just use initSlabs instead of read/write?
s/max//
You should use DBClient.shutdownGraceful there
The DbClient.shutdown() method returns a Realm. which you can use to insert a dbClient.shutdown().
The DbClient.shutdown() method returns a la database connection. It returns the truth value.
why is this called for every sessionReady?
why is this called in onSessionReady?
why is this called for every event?
Missing { and }
Missing no spaces around =
Missing { and } for the same statement
This is wrong. You should get the version returned by the constant in order to return a new one.
This is wrong. You should get the version returned by the command.
This is wrong. You should get the version from the tool.
If you have a static field, it should be reset in constructor.
What if ADE is null?
What if ADE is empty?
@vilchik-elena I think that line AnalyzerMessageReporter reporter = (AnalyzerMessageReporter) context; messagesPerPackage.entrySet().stream().filter(entry -> entry.getKey().contains(entry.getValue())).forEach(reporter::reportIssue);
@vilchik-elena Why not just test instanceof AnalyzerMessageReporter here and below?
@vilchik-elena Why not just test instanceof AnalyzerMessageReporter here and remove the test in the assertion?
The last object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
The last object in the database may not necessarily have an id of the type. We should return a list of Strings with the id of the query.
The last object in the database may not necessarily have an id of the type. We should return a list of Strings with the id of the item.
This is going to cause a NPE if the config is not available.
This is going to cause a NPE if the config is null.
This is going to cause a NPE if the config is missing.
This and the next two lines could be merged into one.
This is not going to format the logs as the 'flowIds', right?
This is not going to format the logs as the 'flowIds'
rename to affectedNamespaces
rename to val or var?
rename to ch
Use this.key
Use a constant for 200 please.
Use a constant for 200 IMO.
I would like to see this performance critical section in initialize() instead of this bind() method.
I would like to see this performance critical section in initialize() instead of this bind() line.
I would like to see this performance critical section in initialize() instead of this bind() method..
Should avoid use @ fail() as it doesn't throw an exception
Should avoid using fail() in tests.
Should avoid use fail() in tests.
Its probably not a big fan of returning a boolean type when there is a method, it really feels like that. The caller has care of handling exceptions differently, and maybe we need to know that.
Its probably not a big fan of returning a boolean type when we can return. We just look at containerPlacementMessage.StatusCode.STAY case.
Its probably not a big fan of returning a boolean type when there is a method, it really feels like that. The caller has care about the status/response value.
why not public?
why public?
Why not public?
s/DbFacade.getInstance().getDiskImageDao()/getAncestor.
1. what if the disk is not found? 2. why?
images
Please use org.jboss.as.test.util.Assert.assertEquals(tbm.getSize(), equalTo(300)));
Please use org.jboss.as.test.util.Assert.assertEquals(tbm.getSize(), 1)
Please use org.jboss.as.test.util.Assert.assertEquals(String, int)
We should show errors here, not return originalText.replaceAll(regex, "");
This regex can be made into a static final field to avoid repetition.
We should show errors here, not return originalText.replaceAll("this moment", "");
This condition also has to be fixed, since XPATH_1_0 is already a parameter
This condition also has to be fixed, since XPATH_1_0 is now a parameter
This condition is duplicated
I think we should have a null check here too.
I think we should have a null check for it before passing it to ResourceAccessChange.
I think we should have a null check on pm, before passing it to the constructor.
It should return ReadOnlyArrayInterface.
It should return ReadOnlyArrayInterface, not ReadOnlyArrayInterface.
It should return ReadOnlyArrayInterface. ReadOnlyArrayInterface is internal for Java.
@rui-castro Why not just bytes.length * 2?
@rui-castro why not just bytes.length * 2?
@rui-castro why not just bytes?
@highker : What's the reason for this change?
Is there a reason we don't just make this @VisibleForTesting?
Is there a reason we don't just use this if statement and below?
do we really need this?
I think "d" should be "mobile_remnant"} since the assertion fails.
I think "d" should be "mobile_remnant"} right?
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead?
This is a bit tricky, since this has to compare the eventHandlerName to fName. I'm not sure if this is a real case and when this has reached you are doing a unit test of the change. The empty string should be passed to the method, not the eventHandlerName.
This is a bit tricky, since this has to compare the eventHandlerName to fName. I'm not sure if this is a real case and when this has reached you are doing a unit test of the change. The only real case is this test case.
This is a bit tricky, since this has to compare the eventHandlerName to fName. I'm not sure if this is a real case and when this has reached you are comparing the traces that have the same event.
I wonder if this would be better as: public ValidationResult hasUniqueName() { return ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_MAC_POOL_OF_THIS_NAME_ALREADY_EXIST); }
I wonder if this would be better as: if (!macPoolNameUnique(newMacPool.getName())) { return ValidationResult.VALID; } return ValidationResult.VALID;
I wonder if this would be better as: public ValidationResult hasUniqueName() { return ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_MAC_POOL_OF_THIS_NAME_ALREADY_EXIST); } ValidationResult.VALID; }
style nit: missing space between if and (
style nit: no braces around single line blocks
style nit: missing space after if
Should true be true?
Should be true
Should be true.
This class implements equals. Please use Objects.equals(this, o) instead.
This class implements equals. I think you should use Objects.equals for comparison.
This class implements equals. I think you should use Objects.equals(this, object).
Why need to call runOnDisposalList()?
Why need to call runOnDisposalList()?
Why need to be protected?
I'd probably add a checkNotNull for permissions and just do this.targetId = checkNotNull(permission, "permission");
I'd probably add a checkNotNull for permissions and "id" to be consistent with other methods in this class.
I'd probably add a checkNotNull for permissions and just do this.targetId = checkNotNull(permission, "permission")
Should be an interface and avoid code duplication
Should be an interface or something.
Should be @Nullable
I think this should be removed
I'm not sure if this should be removed
I'm not sure if we should have this an external table with a name "Account allowed" or if we can just add a new name to the table with the user name. This is required if we have an integration test for that table.
@ivandalbosco Why not using getEnclosingConstructor() here?
@ivandalbosco Why not use getEnclosingConstructor() here?
@ivandalbosco Why not using getEnclosingConstructor()?
If i understand correctly, maybe this condition should be moved into the if block? It also checks for SSLClusterReady
If i understand correctly, maybe this condition should be moved to line 96 (or change the if test condition as well), and remove the check for zkCluster here.
If i understand correctly, maybe this condition should be moved to line 96 (or change the if test condition as well), and remove the check.
this should be private static final
this should probably be private static final
this should probably be private static
As a general point, I would prefer that we put a SamComparisonMetric directly into the array. This way you can avoid your array allocation, eg: comparisonMetricFile.addHeader(h).add(new MetricsFile()); comparisonMetricFile.addAll(Collections.singletonList(comparisonMetric)).
As a general point, I would prefer that we put a SamComparisonMetric directly into the array. This way you can avoid that your array creation, e.g. comparisonMetricFile.addHeader(h).
As a general point, I would prefer that we put a SamComparisonMetric directly into the array. This way you can avoid your array allocation, eg: comparisonMetricFile.addHeader(h).add(new MetricsFile()); comparisonMetricFile.addAllMetrics(Collections.singletonList(comparisonMetric))
the method name should be misleading as it's not a user name.
the method name should be misleading?
the method name should be changed to something like "myrobotlab.log"
no need for the 'else' word here.
any reason for the change to the following? > return Collections.emptySet();
any reason for the change to'map' to'map'?
Long.valueOf(1)
Long.valueOf(result.getDbGeneration())
**Long.valueOf(1)**
Please update the version of update method in UpdateNetworkOnCluster, in case of failure.
Please update the version of update method in UpdateNetworkOnCluster,
Please update the resource using in the assertUpdate(true)
Can you use SoftAssertions.assertThatThrownBy(() -> cause.getMessage().equals( "STARTED")))?
Can you use SoftAssertions.assertThatThrownBy(() -> cause.getMessage().equals( "STARTED"))?
Can you use [ScheduledStmt](<LINK_0>
LGTM = Looks Good To me, just added some static imports and removed.
LGTM = Looks Good To me
Aren't these logic duplicated?
If this method should never be called, then it should not exist.
If this method should never be called, then I would prefer to throw an exception if it's not being used.
If you should never call toString() in the logger, even if the logger is not being used.
The potential issue with the cluster registry being merged with other listeners. Do we need to keep both on the same thread?
The potential issue with the cluster registry being merged with other listeners. Do we need to keep both on the same transaction?
The potential issue with the cluster registry being merged with other listeners. Do you think it makes sense to keep the CacheInsert simpler?
You can use executeScript("ace.edit('cssEditorContainer').setValue('); here
You can use executeScript("ace.edit('cssEditorContainer').setValue('" + cssText); here
You can use executeScript("ace.edit('cssEditorContainer').setValue('" + cssText) here
I don't think we need this method at all. This should be inside the constructor.
I don't think we need this method at all. This should be private
I think this should be inside this method.
Better use Integer.valueOf(getAllForStoragePool(existingVds).size())
Maybe you could use "assertEquals(getAllForStoragePool(existingVds).size()), result);"?
Better use Integer.valueOf(getAllForStoragePool(existingVds).size()), it's much more readable.
Should we set the value of the OMElement object to null? Optional?
I think we should not return null here as the value of this method is not used.
I think we should not return null here as the value of this method is not used anywhere.
"http.responsecode" is the same as "http.responsecode".
I think "http.responsecode" is the best name for this field.
I think "http.responsecode" is the best name for this.
This means that a json content with {id} has been denied. This should be: /foo/{bar}/statusstatus
This means that a json path will change if no metrics are found?
This means that a json path will change if no metrics are provided?
Nit: s/public//
Nit: > public @Nullable String getRpmRevision() {
Nit: > Use s.o.VdsStatic.
Is it possible to skip the sharedIDEContext.isInitialized() part, which is empty? Maybe something like: if (sharedIDEContext.isInitialized()) { return sharedIDEContext.getProject(); }
Is it possible to skip the sharedIDEContext.isInitialized() part, which is empty? Maybe something like: if (sharedIDEContext.isInitialized() && sharedIDEContext.isInitialized()) { //... }
Is it possible to skip the currentSession == null? : null
You could add a variant of this function that takes a CacheEntrySet, and returns a new set if the entry set is not null. This would help avoid some bugs in the future if someone needs to know what to do with it.
You could add a variant of this function that takes a CacheEntrySet, and returns a new set if the entry set is not null. This would help avoid some bugs in the future.
You could add a variant of this function that takes a CacheEntrySet, and returns a new set if the entry set is not null. This would help avoid some bugs in the future if someone calls these method with a null values.
Minor: you can use.booleanValue() instead of 'operation'
.add(aggregate)
Discard.
This plays the current, not the next station.
This plays the current, not the last station.
This plays the current, not the current,
It would be cleaner to extract a method that is used by assumeJavaVersion(JavaVersion, version) to make it a bit more readable
It would be cleaner to extract a method that is used by assumeJavaVersion(JavaVersion, version) that is used only once
It would be cleaner to extract a method that is used by assumeJavaVersion(JavaVersion, version) that is deprecated.
@antonini again, use String.format() to combine these two assertions and remove the duplication.
@antonini again, we can use this message to combine it with the one above and remove the duplication
@antonini again, use String.format() to combine these two lines
Since you are doing this only once, please add a new method on VDS that will be used in all cases, there is an 'else' statement missing in this nested if statement.
Since you are doing this only once, please add a new method on VDS that will be used in all cases, there is an 'else if' for this condition.
Might as well add an else if to the above if.
Shall we remove this null check since this is an internal class.
Shall we remove this null check since this is an unchecked exception?
Cleanup?
Use Throwables.propagate(e) to wrap the exception.
Use RuntimeException(e) since it's swallowed.
Use RuntimeException(e) since it is already caught.
These two could be simplified to assertNull.
These 2 could be simplified to assertNull.
These could be simplified to assertNull.
return Arrays.asList(ERepositoryObjectType.PROCESS);
return Arrays.asList(ERepositoryObjectType.PROCESS, ERepositoryObjectType.PROCESS);
return Arrays.asList(ERepositoryObjectType.PROCESS)
Update the message to something like "executeQuery may not be used for delete:"
Update the message to something like "executeQuery may not be used for delete: " + this
Should these be error message?
final?
Would it be worth changing this method to private?
Would it be worth changing it to private?
It looks like this one is being used in multiple places. What about extracting it to a helper method?
It looks like this test is doing a lot more than once. What about extracting it to a helper method?
It looks like this one is being used in multiple places. What about creating a helper method to disable the singleton pattern?
This is too general, it might be useful to have a method where it is called it or not (to allow it to be in a public method).
This is too general, it might be useful to have a method where it is included?
This is too general, it might be useful to have a method where it is called it or not (to allow it to be in the public surface).
please remove the public modifier
please, remove the public modifier.
please remove the public modifier.
Could you sync up the command on a device without a timeout? I'm not sure it's necessary to be sync'ed.
Could you sync up the command on a device without a timeout? I'm not sure we do even want a timeout, but I think we're trying to see it blocking.
This method can be simplified to mDMList.init(context)
I think that only the revoked token is revoked.
I think we can just use headerCache.get(headerCache) here.
I think we can just use headerCache.get(headerCache)
Fix message, it is not started
Fix message, it is better to use NetworkDashboardVisitsPresenter.
Fix message
It is not enough to have public methods without arguments. Could you please explain why we need them?
It is not necessary to have a new line.
It is not necessary to have a new line after the return.
This is not related to the PR, but I think we should fix it in the creation of the collection.
This is not related to the PR, but I think we should fix it
Not necessary.
Logic: Similar change to LazyFluentIterable#first()
Logic: Similar change to LazyFluentIterable#first().
Similar change as first(count).
@lautarobock I think you can use querydsl instead (already in master)
@lautarobock I think you can use EntityCollection.class.getSimpleName()
TypedQuery<String> can be used here.
Check for the html element before using it. That way, the assertion will fail.
Check for the html element before using the assertion assertion
Check for the html element before using the assertion assertion.
should use {} instead of string concatenation
should use {} instead of string concat
should we add the clause or the id part?
Change to if (folders == null) {
Change to if (folders == null || path.isEmpty())
break;
Why is this necessary?
Why.toString()?
Why.toString()??
Is it a good idea to swallow an IllegalArgumentException here? So we can't use a try-catch?
Is it a good idea to swallow an IllegalArgumentException here? So we can't use a try-catch block here?
Is it the same as catching the NPE?
What happens if we have no longer use full index?
What happens if you don't use full index?
Nit: no need for if statement
The check for existence of Optional is only done in line 143 but not here.
The check for existence of Optional is only done in line 161, so this file needs to change as well
The check for existence of Optional is only done in line 161, so this file needs to change as well.
static import
why do you want to keep the first test?
static import?
Why not just let the exception bubble up and add the stack trace here?
Why not just let the exception bubble up and let the stack trace know what happened?
Why not just make it protected?
Should we check for null here?
Should we check for the id property?
Should we check for the entity we expect?
why do we need this line?
why do you need this line?
why do you need to check for getTeam here?
I think it makes sense to store the User type as a static final and reuse that in every method.
I think it makes sense to store the User type as a static final and reuse that in each of this method
Remove this
As withExtensibleChannelTypeIds should be a Set, it should be returned from the operation.
As withExtensibleChannelTypeIds should be a Set, it should be more correct.
As withExtensibleChannelTypeIds should be a Set instead of a List.
if(length(user())>0, sleep(10),2) is the same as in SQLUtil
if(length(user())>0, sleep(10),2) is the same as in SQLUtil?
if(length(user())>0, sleep(10),2) is a better test?
@vilchik-elena Why synchronized?
while you're at it, can you change this to "skip not supported"?
while you're at it, can you please change the "skip not supported" method to return long?
IDE says this is redundant.
IDE says this is redundant
IDE says this block is redundant
It would be worth moving the JSON::binaryMarshal into the next line.
It would be worth moving the JSON::binaryMarshal to the next line.
It would be more readable if you just write the json string.
This property should be set if its not empty in the sample.
This property should be set if its not empty in the list.
This property should be set if its not empty.
nitpick: I think we should never state "Notification" in the class, and the setRadius and the text says "Notification".
nitpick: I think we should never state "Notification" in the class, and the setRadius and the text says "Notification"
nitpick: not sure if it's not a big deal, but I think we should better fail if the list of radius is not the same.
nit: Remove this.
nit: Pull out the configuration first.
nit: Remove the assignment to limit value creation.
Maybe we could use BATCH instead of sleeping here?
Maybe use thenAnswer instead?
Maybe we should use BATCH instead of 500 ms?
You don't need to check for null here. Get it from the storage manager.
No need to cast to Profile here.
You don't need to check for null here. Get it from the storage manager?
Do we want to use the org.hibernate.search.util.EclipseUtils#getSchemaNodeComponent(String, Object...) to build the predicate builder?
Do we want to use the org.hibernate.search.util.EclipseUtils#getSchemaNodeComponent method here? We could just pass the static field field directly and avoid the the builder altogether.
Do we want to use the org.hibernate.search.util.EclipseUtils#getSchemaNodeComponent(String, Class<? extends ElasticsearchIndexField>) constructor?
getActiveInstance is deprecated, use hudson.util.fixEmpty
getActiveInstance is deprecated, use hudson.model.branch.None
getActiveInstance may return null
The methods should be on the interface, not the implementation.
The method should return a VideoInfo, not a VideoInfo.
The method should return a VideoInfo, not a data type.
nit: public DefaultRecord(int sizeInBytes, byte[] attributes, int offset, int sequence, ByteBuffer key, ByteBuffer value, Header[] headers)
nit: public DefaultRecord(int sizeInBytes, byte[] attributes, int offset, int sequence, Header[] headers) { this(offset, offset, value, sequence, headers, headers); this(headers = requireNonNull(sizeInBytes, "sequence!= null"); this.headers = sizeInBytes; }
nit: Why public?
static
static?
static import
can't this be simplified? java if (auth == null) { return null; } return auth.clone(auth.required());
can't this be simplified?
can't this method be private?
and the binary needs to be binary compatible.
and the binary representation of this byte array might be a byte array
and the binary representation of this byte array might be a byte array?
Adding this to a field is good manner.
Adding this to a field is good manner. In that case you can access the class directly.
Adding this to a field is bad manner.
instead of returning a list, wouldn't it be better to throw an exception to the caller? wouldn't it be better to throw it?
instead of returning a list, wouldn't it be better to return a common interface? wouldn't it be better to have a common interface?
instead of returning a list, wouldn't it be better to return a common interface? wouldn't it be better to throw an exception to the caller.
Shall we re-use the ConfigurateTranslator.instance().translateFrom() method and add it to ConfigurationNode instead?
Shall we translate the whole value to 'translateFrom'?
Shall we translate the whole value to 'b'?
I guess the id cannot be null, this can cause NPE. also can be thrown from the runAction
I guess the id cannot be null, this can cause NPE.
I guess the id cannot be null here
It would be better to private methods for the file type, instead of public.
It would be better to private methods for the file type, instead of protected.
It would be better to private methods for the file type.
This testValueOfJmsConnection() should be replaced by TestUtil.waitForRequestOfValue()
This testValueOfJmsConnection and testValueOfNode should be replaced by TestUtil.createWriteLists()
This testValueOfJmsConnection and testValueOfNode should be replaced by TestUtil.waitForRequestOfValue/contains
We should extract this in a constant.
We should add a encoding check here, otherwise we're going to use the actual encoding.
We should add a encoding check here, otherwise we're going to use the actual encoding for those
Does this need to be public?
Do we need to add a null check here?
don't need to pass this class. Just return a GuiceBundle.
I don't really understand this.
I don't really understand this. Let's discuss.
Should be removed.
This field doesn't seem to be used.
This field isn't needed.
This field isn't used.
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE);
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE());
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE));
can we have more concrete type instead of new SimpleModule("Firehose module")?
can we have more concrete type here? (new SimpleModule("Firehose-based")
can we have more concrete type instead of new SimpleModule("Firehose related interfaces and use registerSubtypes(...)?
This looks like it's the same as the one in SchemaSchemaKey above. Is it correct? And is this still correct?
This looks like it's the same as the one in SchemaSchemaKey above. Is it correct? And is this still needed?
This can be private.
I wonder if we should be consistent and more consistent with the order of these ifs.
I wonder if we should be more efficient if we put this if statement in order to be able to perform the instanceof check.
I wonder if we should be more efficient if we put this if statement in order to be able to perform the instanceof checks.
minor: I don't think we need an else block here.
minor: I don't think metrics should be in the annotated type.
minor: I don't think metrics should be in the method name but that is only used here.
If we include the file name in the.properties file, we won't need to change the default charset.
If we include the file name in the.properties file, we don't need to change the default charset.
Why we don't need to change the charset?
suggestion if (rowIdx >= rows.size() && requested > 0)
suggestion if (rowIdx >= rows.size() && requested > 0) {
suggestion if (rowIdx >= rows.size() && requested > 0) downstream().end();
i don't think it is needed.
Null check
This should be synchronized
this method is never called. This is the default implementation, which means RetrySleeper.sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS);
this method is never called. This is the default implementation, which means RetrySleeper.sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS); It's possible for this to return true.
this method is never called. This is the default implementation. Re-interrupts this or just return true.
we could avoid the conversion by declaring value == null ||!value.isEmpty()
we could avoid the conversion by declaring value == null ||!value.isExpression(expression)
we could avoid the conversion by declaring value == null ||!value.isExpression(expression)?
same again: do not create a new empty exception but reuse the calling class.
same again: do not create a new empty exception but reuse the old one.
same again: do not create a new IndexOutOfBoundsException but reuse the original exception.
In the other class you use a JBMenuItem. Any special reason to use a JMenuItem here?
For the other class you use a JBMenuItem. Any special reason to use a JMenuItem here?
In the other class you use a JbMenuItem. Any special reason to use a JMenuItem here?
I think we should try to avoid using 'Spaces' for Strings. The only 'getBytes' is changing the encoding.
I think we should try to avoid using 'Spaces' for Strings. The only 'getBytes' is the default charset.
I think we should validate that the payload is non-null. The test is about "skipping".
This is now also needed for testing, please remove it
This is now also needed for the mapping above, please remove it
This is now also needed
I modified unparseCall so that an unparse call would have an resulting code sneaked into the UNparseCall().
I modified unparseCall so that the state of the connection is squashed into the 2/3 switch.
I modified unparseCall so that the state of the object is squashed into the 1.
This will need to be wrapped, since it was not in the list.
This will need to be reverted, because it was not the master branch.
This will need to be reverted, since it was not the master branch.
return a copy of the data to avoid modifications outside.
return a copy of the data, callers are never changing this method.
return a copy of the data to avoid modifications outside of this class.
can you throw the exception and log it.., maybe the slowReplicationResponse() should just return false?
can you throw the exception and log it on failure to stop also stop the flow work?
should this be trace or debug?
errors can be null
errors cannot be null
errors is not used
Could we remove this if? Since we don't allow else, I think it would be better if we just return directly.
Could we remove this if? Since we don't allow for null, I think it would be better if we just return null.
Could we remove this condition? Is it useless if the info is not null?
If you're already making an overload of this constructor, changing the defaultWatcher makes that clearer.
If you're making the changes to defaultWatcher every time, is it null?
If you're making the changes to defaultWatcher every time, is it null? In that case?
It would be better to have a null check after the call to reporterFactory.close()
It seems like this would be better as well.
It would be better to have a null check after runListener
Why do we need this change?
Why do we need this catch block?
Why do we need to catch here?
I thought I already implemented this for the MavenArtifactGenerator...?
I thought I already implemented this for the MavenArtifactGenerator, so this method should be private.
I thought I already implemented this for the MavenArtifactGenerator, so this method should stay private.
why you do not use java assertKeyPair(file, null);
why do you need this?
why do you need to wrap this in RuntimeException?
does this method need to be public?
does this method need to be synchronized?
@rsearls better enforce the return value here.
public
public?
public too
Why is title and value not public?
Why is title and value not private?
+1 for consistency.
Not sure whether you want to do this, but is there a way to do it if the _consumerMetrics is not null? Why not just use UpdateType.PAUSE_RESUME_PARTITIONS
Not sure whether this will work, but is there a way to do the rebalance check in onPartitionsAssigned() instead?
Not sure whether you want to do this, but is there a way to do it if the partition is not in the list after creation?
Do we want to default to set for default? If we do not want this, Objects.requireNonNull(monitor) will be better
Do we want to default to set for default? If we do not want this, Objects.requireNonNull(monitor) will be better.
Do we want to default to set for default? If we do not want this, Objects.requireNonNull(monitor) will be thrown.
What about String.format?
What about String.format()?
What if the string is empty?
rename to contribution
rename 'cache'
rename'result'
Is thiz.toString() the same as.get( thiz)?
Is thiz.toString() the same as.get()? Or is it too much work?
Is thiz.toString() the same as.get()? Or is it too generic?
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "early return" [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Specify a "Function<I>" parameter instead. [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Change this condition to: [![rule](<LINK_0>](<LINK_2>
Cache this?
Needs Override
Won't this cause perf issues?
Is this error message accurate? Maybe "Cannot cast from " + castFrom + " to " + stateSchema.
Is this check necessary? getLeft().getOutputType(schema, stateSchema) is already known as a type.
Is this error message accurate? Maybe "Cannot cast from {}"?
Why do we need to cast to SCMMaterialConfig here? Cant we directly cast to SCMMaterialMaterial?
Why do we need to cast to SCMMaterialConfig here? Cant we directly cast to scmMaterial?
Why do we need to cast to SCMMaterialConfig here? Cant we directly cast to SCMMaterialMaterialMaterial?
You should use the getClass().getSimpleName() instead of.get("org.persistence.EntityNotFoundException")
Do you really have to catch  ClassNotFoundException?
Do you really want to use the RuntimeException here?
Hmm.. Can we use a more descriptive name for everything?
Hmm, I think it would be better to have this in the waitUntilFlowPreparationEvent() method. Do you think it would make sense?
Hmm, I think it would be better to have this in the waitUntilFlowPreparationEvent() method.
No need to check for the existence of the route. The idea is that, if the route doesn't exist, the following will throw an error: <LINK_0>
No need to check for the existence of the route. The idea is that, if the route doesn't exist, we will retrieve the route by a /
No need to check for the existence of the route. The idea is that, if the route doesn't exist, the following will throw an exception, and that will be considered wrong.
Same in Alientype2.java (add type of alien)
Same (add type of alien)
Same as in Alientype2.java (as of alien)
Is this a html flag?
Is this a string?
Add the html flag in the tests
unnecessary else after return.
Log a more descriptive message.
unnecessary else after return
Can we change the /etc/ to a constant?
Can we delete the /etc/ properties and use the /etc/?
final
We should use a specific exception for all exceptions that aren't "swallow" the exception message.
We should use a specific exception for all exceptions that aren't "unknown" because of the chance of catching an exception.
We should use a specific exception for all exceptions that aren't "unknown" because of the chance of exception handling for RuntimeExceptions.
It's not necessary to add systemProperties.get(key) to the line above
It's not necessary to add systemProperties.get(key) to the line below
It's not directly related to the file.
Recommend using a local variable so it can be shared as a constant. Alternatively, we could use it as a data type of the object.
Recommend using a local variable so it can be updated in one place. Alternatively, we could add a \n to the final static field of the class.
Recommend using a local variable so it can be updated in one place. Alternatively, we could add a \n to the final static field so it can be shared by one place and used in local.
please use @Test(expected=...) instead.
please use @Test(expected=...) instead of.class
please use @Test(expected=...) instead of.
key and value should probably be constants.
key and value should probably be constants, for consistency.
key and value should be constants.
Problem: shouldn't this be protected.
Problem: shouldn't it be protected to allow domainCreditsProgressDialog == null?
Problem: shouldn't it be protected.
How about throwing a NPE here if local is null? The caller of this method doesn't have an NPE.
How about this: java return RepositoryBuilder.create(GitBuilder.class);
How about throwing a NPE here if local is null?
I think this check should be inside of the for loop.
I think this check should be inside of the for-loop.
I think this check should be performed under the annotatedTypes list ofAnnotatedTypes, not as is.
This is a deadline long. Maybe put deadline!= null && System.currentTimeMillis() > deadline.getTime()) { return false; }
This is a deadline long. Maybe put deadline!= null && System.currentTimeMillis() > deadline.getTime()) to a final variable.
This is a deadline initialized by deadline.
nit: space after 'if'
nit: should this be calling TimelockServices.timelock()?
nit: should this be calling TimelockService#timelock(), or maybe the test code?
please make sure that the updateOvfStoreContent return the storage domain value if it's missing diskCount.
please make sure that the updateOvfStoreContent return the storage domain value if it's not null
please make sure that the updateOvfStoreContent return the storage domain value if it's missing diskCount
This is like double lock checking. You may also want to check it before synchronized which also improves performance. Considering namespace is not changed, you don't have to check it in within synchronized block.
This is like double lock checking. you may also want to check it before synchronized which also improves performance. Considering namespace is not changed, you don't have to check it in within synchronized block.
move it before synchronized
I'd prefer to use the constructor of this form instead of making a mutable field
I'd prefer to use the constructor of this form instead of passing null.
Why is this needed?
Safer to read <LINK_0>
Safer to use it.
interceptor?
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(Class.getSimpleName()); // Or sanitizeTag or normalizeTag, etc...
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(getClass); // Or sanitizeTag or normalizeTag, etc...
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(Class.getSimpleName()); // Or sanitizeTag or normalizeTag, etc...
I would expect the white-listing rules to have changed and match app user
I would expect the white-listing rules to have changed and match app user id by the new property now
I would expect the white-listing rules to have changed and match app user.
Is this change supposed to be part of the SDK version?
There should be a version of some kind of test for jackson. This is not the same.
Is this change needed?
this seems like it should be a try() with resources
this seems like it should be a try with resources
this might be a try with resources
Why is the name being HTML encoded? Wouldn't it be much easier to overwrite this?
Why is the name being HTML encoded? Wouldn't it be much easier to overwrite this alert
Why would the name be HTML?
Suggest renaming this to tallies
1. This array is too small, 2. You can use Arrays.stream(intervals.length) instead.
Suggest renaming this to tallies, since this is not very descriptive.
@adyach are you sure that we need to parseBytes here?
@adyach are you sure that this introduces a bug?
@adyach are you sure that we need to specify charset?
isn't this supposed to be readNext(message)?
isn't this supposed to be readNext?
isn't this public?
Is it needed that is already true?
Is it needed?
Unnecessary.
repositoryAccess alreadyRegistered?
alreadyRegistered?
repositoryAccess alreadyRegistered
I think we should at least log this as ERROR.
I think we should at least log this as ERROR
I think we should at least log this as INFO since it's "info" but not "info"?
don't need this. Builder will be enough
don't need this if, just initialize it with null.
don't need this if, just initialize it with empty list.
I think you can simplify this to: java return String.format("%s", (long) (double) d) d;
I think you can simplify this to: java return String.format("%s", (long) (double) d) ;
I think you should use Long.valueOf(d)
I'd have said leaderElectorExecutor a bit easier to read here. Then we could get rid of the!isLeadership.
I'd have said leaderElectorExecutor a bit easier to read here. Then we could save the runAsync() call.
I'd have said leaderElectorExecutor a bit easier to read.
This is an implicit ELSE 0, right?
This is an invalid parameter.
This is an error
Should this be delegating to a different method than encodeLink, above?
Should this be delegating to a different caller than encodeLink, above?
Should this be delegating to another method than encodeLink, above?
Could you extract this bit into a function? getAttribute(index)
Could you extract this into a method? getAttribute(index)
Could you extract this into a method
return Collections.<Object>singletonList(this.receiver);
Collections.<Object>singletonList(this.receiver) should be enough.
Collections.<Object>singletonList(this.receiver) is sufficient.
It might be a little cleaner to use e.getErrorCode() here.
It may be a little cleaner to use e.getErrorCode() here.
For error codes, we are trying to get K, Hm, this is not the right place. It should be a separate JIRA for this.
Use [StringJoiner](<LINK_0>
Please add a check that the value is not null
Use [StringHelper](<LINK_0> Or, better option.
LSM cannot compute the position of the first packet, thus, it might be necessary to add more calls to this method.
LSM cannot compute the position of the first packet, thus, it might be easier to read.
LSM cannot compute the position of the first packet, thus, it might be easier to read if we add more methods.
Please move this method to the first line of the method.
Please move this method to the bottom of the class (or maybe rename the method to "hasAnnotationAnnotation")
Please move it into method
Yep, what Leo says is what I meant.
Yep, what Leo says is to use.
Yep, that's what I meant.
Shouldn't need a system.out.println in case of failure, I think it should be enough
Shouldn't need a system.out.println in this test
Shouldn't need this check.
One more thing, but I'd prefer to pass null (OrderDirection) null instead of empty string.
One more thing, but I'd prefer to pass null instead of empty.
One more thing, but I'd prefer to pass null instead of empty to the API.
I would probably add a getBulkMaxRowKeyCount() here
I think we should have a BigtableTableName tableName as a public static method in BigtableTableName to get the interval. Perhaps a toString()?
I would probably add a public method in BigtableTableName to get the retry retry retry.
Should this method be renamed to use the other one?
Should this method not be static?
Should this method not use AbstractReplyManager?
this method can be reduced to: java @Override public List<String> removeSavedPlainCommands() { if (saved.isEmpty()) { return Collections.emptyList(); } synchronized (saved) { List<String> result = new ArrayList<>(saved); saved.removeAll(result); if (result.isEmpty()) { log.info("{} commands are removed from saved list", result.size()); return result; } return result; }
this method can be reduced to: java @Override public List<String> removeSavedPlainCommands() { if (saved.isEmpty()) { return Collections.emptyList(); } synchronized (saved) { List<String> result = new ArrayList<>(saved); saved.removeAll(result); return result; } return result; }
code style
You should always call super.close()
Not sure if it would be better to always call super.close() here
You should always call super.close() here
Here you can use "verifyTableScan(table, expectedPhysial, employee]]" instead.
Here you can use "verifyTableScan(table, expectedPhysial)"
Here you can use "verifyTableScan(table, expectedPhysial)" instead.
What if volumeSize is smaller than 10?
What if volumeSize is a smaller than 10?
What if volumeSize is < 10?
Make these constants static final in the project
Make these constants static final
Make this constants
Style: Always use curly brackets for single line blocks.
Style: Always use curly braces, and space after if. There is also a space after if
Style: Always use curly braces, and space after if.
Please extract to constant.
Use.hasToString() instead.
Use constant.
You don't need to call clear() since we have pendingCallbacks_ as well.
Missing brackets
Missing brackets.
This doesn't seem to be an expected way to test.
This doesn't seem to test this?
This is never used
Why don't we just use the string comparison? Here we know you're not comparing the float to a float.
Why don't we use the keyword float here? Here we use float.compare(float a, float b)
Why don't we just use the keyword float here? Here we use float.compare(float a, float b)
You could break out of the if statement.
You could probably use a foreach loop here for more safety on the code.
You can probably use a foreach loop for this ts.
Shall we print the entire test case to log.info in case of fail?
Shall we print the entire test case to a different file? e.g. "test" is not helpful
Shall we print the entire test case to a different file? e.g. "test" is not helpful.
why is this needed?
Why is this needed?
why is this necessary?
why is this required?
you should probably add mode = null here
why is this needed?
Small typo: handleCallbacks()
Suggest to use a Map and not a HashMap
Suggest to use of generics
I think pauseDepth becomes negative.
I think you should change pauseDepth becomes negative.
I think pauseDepth becomes negative?
Given that we are in the process of runningCommandsMap, are we sure that this is safe and we don't need to do this? I think that is good.
Given that we are in the process of runningCommandsMap, are we sure that this is safe and we don't need to do the extra synchronization? I think that is good.
Given that we are in the process of runningCommandsMap, are we sure that this is safe and we don't need to do the extra synchronization? I think that is safe but the private method is still accessed by this class.
This is called when the revertAnrReporting is false.
This is called when the revertAnrReporting is called. But what about if you move the enableAnrReporting into the if block?
This is called when the revertAnrReporting is called. I guess you can call the logger to do that.
You can use Validate.notNull here for a null check.
You can use Validate.notNull here (and below)
You can use Validate.notNull here (or just return null).
s/setRunning/stopAsync()/
s/setRunning/stopAsync/?
s/setRunning/stopAsync/
It seems this method has no side effect. Is it possible to strip _ here?
It seems this method has no side effects. Is it possible to do it in another PR?
It seems this method is not needed anymore.
Either way, you can have an else statement with the colon enabled.
Could you please extract this condition into a method?
Could you please extract this condition into a function?
The method is only used in this class so I would prefer to have it return true instead of false.
The method is only used in this class so I don't think we need to check for nulls.
The second return statement is not needed.
So my guess is that this method returns null. I don't think we should return null.
So my guess is that this method returns null. Can we just return null here or throw IllegalArgumentException in my tests?
So my guess is that this method returns null. Can we just return null here?
You can make this more compact by using return path!= null? super.toString() : super.toString();
You can make this more compact by using return path!= null? super.toString() : getAbsolutePath();
Nit: I'd rename path to something like this: java return path == null? super.toString() : getAbsolutePath();
remove empty line
static import
remove empty lines
Couldn't we just use a simple for loop here?
Couldn't we just use a simple for loop here? I think it's a bit simpler to understand.
parallelStream() is not necessary here, but I think it would be nice to avoid a stream altogether, below below.
This class has always been called multiple times in the file, so its safe to always use the "final" keyword here.
This class has always been modified so its constructor is obsolete now.
This class has always been subclassed so its super() method can be removed if the class is inside the package
We should put this logic in getConfiguration(IgniteQueryProcessor.idxCls = DummyQueryIndexing.class
We should extract this logic to a shared method.
We should extract this logic to the getConfiguration(IgniteQueryProcessor) method.
This can be simplified to: java Collections.singletonMap("name", name);
This can be simplified to Collections.singletonMap("name", name), which is one less key-value and might be shorter.
This can be simplified to Collections.singletonMap( "name", name), which is one less key-value and might be shorter.
I think we should not use a null AtomicBoolean
I think we should not use a null AtomicBoolean as a default value.
I think it will be better to pass in a boolean rather than a null boolean
Likewise..
Likewise.. Should the outer try catch be unnecessary.
Likewise.. Should the outer try catch be unnecessary?
can be shorter with Collections.singletonList(values)
might be more efficient to iterate over the values.values() to avoid the add value
can be shorter with Collections.singletonList
Seems to me like this is a filter function.
I would merge the two if statements into one.
Seems like this is a filter function.
return get(name, bounds)
No need to make this @Nullable
needs to override
could be simplified to: assertEquals(expectedTags, actual.isEmpty());
could be moved to org.junit.Assert.fail and avoid the real bug.
could be moved to org.junit.Assert.fail and avoid the unchecked warning.
Leftover debug statement?
s/New/New/
s/New/NewPage/
This should be private.
shouldn't this be private?
This should be changed to "generalConfig"
minor: change 42 to 42
Class name could be default
public?
Please replace getVds().getVdsGroupCompatibilityVersion() with getValue()
Please, return void
Please, return void.
there is no need to stream on the left side
Note that there is no need to stream on a list: you can use Optional.ofNullable()
Note that there is no need to stream on a List suggestion public void selectByValue(String value)
Remove this line.
Remove this line, and move the call to the "buildBaseParticipantObjectIdentificationForRequest" method.
Remove this line, it's not needed;
You should keep the other methods like this. ooKeeperClient client = provider.get("getDeploymentGroupResponse");
You should keep the other methods like this in this class.
You should keep the other methods in this class.
java public static <K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) { return map; }
I think we should have an explicit factory.orElseThrow( ) here.
I think we should have an explicit factory.orElseThrow( () -> new IllegalArgumentException("Factory must not be null"));
Would be good to get rid of CountDownLatch here.
Would be good to get rid of CountDownLatch in this test too
Would be good to get rid of this wait time in test.
Having the getQualifiedName() method here feels wrong. It should be something like: public String getQualifiedName() { return StyleResolver.getQualifiedItemName(mySelectedValue.myValue); }
Having the getQualifiedName() method here feels wrong. It should be like: public String getQualifiedName() { return StyleResolver.getQualifiedItemName(mySelectedValue.myValue); }
:+1: for this...
Same here with freeUniqueName(name)
clean up this is done automatically by callers
clean up this file
is this method used anywhere?
is this method used?
is this supposed to be a constant?
Could you get rid of the above two lines and just the println? Also, it might be better to log this in a debug message and leave it off if we don't have any outputs.
Could you get rid of the above two lines and just the println? Also, it might be better to log this in a debug message and not just print it.
Could you get rid of the above two lines and just the println? Also, it might be better to log this in a debug message and leave it off if the file is leak.
Minor: since locateMemberTests(String version, boolean enterprise) has been renamed to locateTestsArtifact(String version, boolean enterprise)
Minor: since locateMemberTests has been renamed to locateTestsArtifact, maybe downloadMemberTests should be renamed, too?
Minor: since locateMemberTests(String version, boolean enterprise) has been renamed to locateTestsArtifact(String version, boolean enterprise) maybe?
We should always use a fallback here (there is already a requirement)
Should we check that it is not null?
We should always use a fallback here
org.hibernate.search.kafka.common.impl.SearchService.performCommand(Object, Object[])
org.hibernate.search.kafka.common.impl.SearchService.performCommand(String, Object[])
org.hibernate.search.kafka.common.impl.SearchService.processAsync(Collection<Runnable>)
It's a bit odd to log event.getException() here.
It's a bit odd that this exception can be logged as a message.
It's a bit odd to log event.getException() twice.
I agree, the!getMapGenerator().requiresInternetConnection().![CRITICAL](<LINK_0> 'Severity: CRITICAL') Refactor this method to reduce its Cognitive Complexity from 18 to the 15 allowed. [![rule](<LINK_1>](<LINK_2>
I agree, the!getMapGenerator().requiresInternetConnection().![CRITICAL](<LINK_0> 'Severity: CRITICAL') Refactor this method to reduce its Cognitive Complexity from 17 to the 15 allowed. [![rule](<LINK_1>](<LINK_2>
I agree, the!getMapGenerator().requiresInternetConnection() &&!getMapGenerator().isMapDatabaseSwitchSupported() is also redundant.
Meaning for this one - we could just return the max?
Meaning for this one - we could just return 0?
Meaning for this one - 38
null check
@Nullable
null check?
Wasn't there a check for mntByAttribute.isEmpty()?
Can you check if mntByAttribute is not null? :P
Can you check if mntByAttribute is not null or not? :P
Can you add as a variant for this method?
Can you add a variant that accepts a OperatorExpression<Number> with a default value?
Can you add a variant that accepts a OperatorExpression<Number>.
Style-nit: This method can be private.
Style-nit: This method can be static
Style-nit: This method can be static.
"general.accessTokenValidation" -> "general.accessTokenValidation
"general.accessTokenValidation"
Thanks for the value of this.
should we use pub.subscribe(...)?
should we use pub.subscribe()?
should we use pub.subscribe(..)?
Might as well make the path separator the /voltdbroot/.xml file and use that here.
Might as well make the path separator the /voltdbroot/.xml file just to ensure it's stored.
String.format
Info log spam!
1. This is not an error condition. 2. There's a candidate for DEBUG
Magic number
If two objects are added, we should also remove from either of them.
If two objects are added to the same list, we should also remove from either of them.
This is not thread safe.
Move String values used more then once to a constant.
Move String values used more then once to a constants.
Use a constant for this path.
add null checks
You should check for null.
You should check for null
This probably should not be necessary
This commands are not handled by anywhere else.
Missing ()
Are you sure that you don't need the nonNull(o.getParent()) check?
Are you sure that you don't need the nonNull call?
Are you sure that you don't need the nonNull(o.getParent()) here?
suggestion return this.getClass().getSimpleName();
suggestion return this.getClass().getSimpleName(), mode);
suggestion return this.getClass().getSimpleName() + mode;
As discussed, this method will be called on the async side.
As discussed, this should be package-private (no modifier)
As discussed, this should be package-private (no modifier) instead.
The last assert is different from the first 2
The first assert is different from the first 2
The second assert is different from the first 2
If you want to keep the long variable name, please wrap this line to make it readable: ExpectException expectException = new ExpectException(new PassingStatement(), AssumptionViolatedException.class);
If you want to keep the long message, please wrap this line to make it readable: ExpectException expectException = new ExpectException(new PassingStatement(), AssumptionViolatedException.class);
If you want to keep the long variable name, I'd prefer to have the new invocation to fail() as it is to make the assertion failure message clearer.
can we use toString() to make it safe?
can we use.toString() to make it safe?
can we use toString() to make it more readable?
Could we invalidate the targetDomainName to be null?
s/targetDomainName is set to null.
Missing invalidate() call.
This message does not reflect the exception.
This message does not match the exception message.
This message does not reflect the exception. Because it is more than a valid value, the exception should be thrown.
What about replacing "%PREFIX% with "%PREFIX%" with "%PREFIX%?
What about replacing "%PREFIX% with "%PREFIX%"?
What if the cache contains the query name? Is there a way to make sure there is no entry in the cache?
You can use StringUtils.isBlank
you can use StringUtils.isBlank
You can use StringUtils.isBlank instead
These two assertions are redundant, you can just use Drugs(...)
These two assertions are redundant, you can just use hamcrest matchers
These two assertions are redundant, you can just use Drugs#size()
Can we revert this?
Can't we just use a concurrent map?
Can we have a NullResult here?
Should this be LONToSlope(heading.getValue());?
Should this be LON_DEMAND?
Should this be LON_BAND?
I have some doubts about the use of.newInstance() on the line above.
I have some doubts about the use of.newInstance() on the line above. Testing it is not a good practice.
I have some doubts about the use of.newInstance() on the line above. Testing it is not a good idea.
this can be static
This can be static
This can be static.
@vmaletta Why is the throws Exception?
@vmaletta use camelCase naming
Why is it called questionList and not simply return the list?
@fanifieiev the same above.
@CarlosGines Let's inline this.
@HmRqTextBody Let's inline this one.
can we add here more descriptive name instead of element? Maybe element?
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
can we add here more descriptive name instead of element? Maybe 'element' or 'element'?
Redundant StringHelper.join()
Minor: can you add a check for null?
Minor: can you add a one-liner with the assertTrue(...) here?
Why don't you just set the total here?
Why not use the I18n Logger here?
Why don't you set the total here?
Can we remove this line?
This is safe to me. We should store the result of a session.
This is safe to me. We should store the result as a local variable.
use longValue()
use Integer.parseInt
use longValue() on long
move this to inside the try block
move this to outside the try block
move this to inside the if block
suggestion if (type==Jenkins.class) {
suggestion if (type ==Jenkins.class) {
{}
This line is hard to follow. I think it would be better if we move the calculation of EnvironmentEdgeManager.currentTime() + operationDelay in the queue and if it is null then there is a chance it might be null
This line is hard to follow. I think it would be better if we extract this logic into a method.
This line is hard to follow. I think it would be better if we extract this logic into a separate method.
Do you need this System.out?
Do we need this System.out?
Do you need this line?
requestParams(Map<Object, Number>) params[0]);
Easier to understand if you set the parameter array to an array.
Easier to understand if you set the parameter array to the expected size.
With this changed to : org.apache.commons.lang3.Assert.assertEquals(Bytes.toBytes("abc", scan.getStartRow()), scan.getStopRow())
With this changed to : org.apache.commons.lang3.Assert.assertFalse(Bytes.compareTo(Bytes.toBytes("abc"), scan.getStartRow()) == 0);
With this changed to : org.apache.commons.lang3.Assert.assertEquals(Bytes.toBytes("abc"), scan.getStartRow())
Change to: conf.put(FileOutputFormat.OUTDIR, String.format("gs://%s/%s", config.bucketKey, config.path));
Change to: conf.put(FileOutputFormat.OUTDIR, config.path);
Change to: conf.put(FileOutputFormat.OUTDIR, String.format("s/%s/%s", config.bucketKey, config.path));
Maybe a good opportunity to refactor this into a method: LOGGER.log(Level.FINE, null, new Throwable("deserializing is with AUTO_FLUSH=" + AUTO_FLUSH);.
Maybe you could use AUTO_FLUSH here.
Maybe a good opportunity to refactor this into a method: <LINK_0>
return a null value? (the dimension is not being used)
return a new instance? (return null)
return a new instance each time (dimension.getNewValue via long dimension)
don't you mean to have this?
don't you want to have this?
putting
could you please remove throws IOException as it's not thrown in readNetworkStatsDetail()?
could you please remove TAG_ALL from here and use it in readNetworkStatsDetail?
could you please remove throws IOException as it's not thrown anywhere?
Please use FlinkRuntimeExceptions.StringFormat instead of string concatenation.
Please use FlinkRuntimeExceptions.StringFormat instead of string concatenation
Please use FlinkRuntimeExceptions.StringFormat for such things.
Should we make TestToolUtils package private?
Should we make TestToolUtils public?
Should we make TestToolUtils.class package?
Wouldn't it be better to call this(label, property, property)?
Wouldn't it be better to call this(label, property)?
Wouldn't it be better to call the super() method and have this(label, property)?
This is very dangerous, as the connectionAttemptState.websocket.disconnect() does not do anything with the call to connectionAttemptState.websocket.disconnect().
This is very dangerous, as the connectionAttemptState.websocket.disconnect() does not do anything with the call to connectionAttemptState.websocket.disconnect(). The same goes for the next 3 occurrences in this file.
This is very dangerous, as the connectionAttemptState.websocket.disconnect() does not do anything with the call to connectionAttemptState.websocket.disconnect(). The same goes for the next 3 methods.
I know that this is a matter of taste, but _sb_ is not a good variable name :P
I know that this is a matter of taste, but _sb_ is also not used.
I know that this is a matter of taste, but _collection_ could be made more readable after using ternary operator.
Make this a static?
Make this a static final constant.
Make this final?
so we don't need the UnmodifiableMapEntry field here
so we don't need the UnmodifiableMapEntry field in this class
so we don't need the UnmodifiableMapEntry field in the class
Why not just return if the file exists?
Needs a null check here to be consistent.
Why not just return null?
@RomanNikitenko just FYI - please add [this](<LINK_0>
@xstefank, this should be return new Nullable();
@Nullable
ValidationResult has a lot of methods that would look better..
This method is barely readable. what about caching the result?
This method is barely readable.
I think we could simplify this if statement by using: java defaultone = ((TimeCSVHeaderInformation) fieldsFromHeader).zoneSupplier( defaultone );
I think we could simplify this if statement by using: java defaultone = parse( TimeValue.class, PATTERN, CSVHeaderInformation.parse, text, defaultone );
I think we should also change the field access type to one.
I would close the try/catch (i.e. does the same thing)
I would close the try/catch (i.e. <LINK_0>
I would close the try/catch (i.e. inside calculateInvocationTime).
We should not be throwing RuntimeException
We should not be throwing Exception
We shouldn't be throwing Exception
You could use String.format here, it would be clearer.
You could use String.format here, not concatenation.
You could use String.format here.
Wouldn't it be better to check here that the other object is a ElementNode?
Wouldn't it be better to check here that other is a ElementNode?
Wouldn't it be better to compare the children before the object?
I don't understand this test. We regenerated it later.
I don't understand this test. We may want to write a test with column name this schema: java Schema schema = new Schema(); schema.addColumn("1", "1", "2": "1" }
I don't understand this test. We may want to write a test with input file or column input in the generated code.
The return type should be long.
The strategy.getEstimatedSize() method should be used as well
The return strategy.getEstimatedSize() does not seem to be used?
If VM's custom compatibility version is set, cluster's compatibility version is ignored. That means we don't need to check all VMs that have custom compatibility version.
If VM.getCustomCompatibilityVersion() is null, then the check VM.getCustomCompatibilityVersion() is not necessary.
If VM.getCustomCompatibilityVersion() is null, then the check VM.getCustomCompatibilityVersion()!= null is redundant.
This check should be done before we check the getActivity() to null. We should only create the activity if we're in the activity list.
Since this is the only line of code, we should remove the activity parameter from the presenter. It can be done in the layout file as well.
This check should be done before we check the getActivity() to null. We should only create the activity if we're not hitting it.
The method should be protected, not Vanilla(){}.
The method should be protected. I guess, we should have another one :)
The method should be protected. I guess, we should have another one.
childDir should be deleted.
childDir should be deleted
childDir can be deleted.
Use assertEquals() and remove assertion.
Use assertEquals and remove from tests.
Use assertEquals() and remove assertion output
I think we should only attach the adapter if we sign in in the app.
I think we should only attach the adapter if we sign in, not the app.
I think we should only attach the adapter if we sign in in the background, not the app.
Lets remove the call to cleanUp as it may be called by other tests
Lets remove the call to cleanUp as it may be called by multiple tests
Lets move the deleteAPIByID to the View before it is deleted.
What does this mean?
What does the constant mean?
What does the constant mean here?
[minor] public void onJointAngles(Map<String, Double> angleMap) { for (String name : angleMap.keySet()) { if (si instanceof Servo) { ((Servo) si).moveTo(angleMap.get(name)); } } }
[minor] public void onJointAngles(Map<String, Double> angleMap) { ServiceInterface si = angleMap.keySet().stream().map(name -> ((Servo) si).moveTo(angleMap.get(name)); }
[minor] public void onJointAngles(Map<String, Double> angleMap) { ServiceInterface si = angleMap.keySet().stream().map(name -> ((Servo) si).moveTo(angleMap.get(name)); }
suggestion if (charset == null) { charset = charset.split(",")[0]; }
As per the other discussion, please use [StringUtils](<LINK_0>
suggestion if (charset == null) { charset = charset.trim(); }
wait for this to work on windows?
can you create a constant for this magic number?
unnecessary
This should be public static
This should be public.
This should return the empty string
As a StudyDataManager is not @Override public void setStudyDataManager(final StudyDataManager studyDataManager) { this.studyDataManager = studyDataManager; }
As @md678685 said: void setStudyDataManager(final StudyDataManager studyDataManager) { this.studyDataManager = studyDataManager; }
As a StudyDataManager is not thread-safe, you are making a synchronization here.
<LINK_0>
see method where public is used
see method above
Better to add a new exception to the constructor.
Better to add a new exception to the new one: FetchException.
Better to add a message to the new exception. Something like FetchException.
Just a small micro-optimization here: If you swap the ItemSetting and the Material check, then this statement can be moved into canMineakedDebris.
Just a small micro-optimization here: If you swap the ItemSetting and the Material check, then this statement can be rewritten to return type.name().endsWith("_ORE")
Just a small micro-optimization here: If you swap the ItemSetting and the Material check, then this statement can be rewritten to return type.name().endsWith("_ORE").
I suppose there is nothing wrong with this, but there is no need either, is there? (other cases of the same marked with ditto3)
I suppose there is nothing wrong with this, but there is no need either, is there? (other cases of IT) where the monitor is null?
I suppose there is nothing wrong with this, but there is no need either, is there? (other cases of IT) submonitor.split(1)?
Maybe you could use new LinkedHashSet< INTEGER>(type, new HashSet< INTEGER>()) instead of the raw type?
Maybe you could just use new LinkedHashSet< INTEGER>(type, new HashSet<>() instead of the raw type?
Maybe you could use new LinkedHashSet< INTEGER>(type, new HashSet<>() instead of new LinkedHashSet<>() to prevent the cast?
Shouldn't this be < 0?
Shouldn't this be < null>?
Please use!getWorkTree().isEmpty().
This is a change of behavior. The first poller maps to json and can only be used in the poller-id={}, which is not the same. Can we change those to return true instead?
This is a change of behavior. The first poller maps to json and can only be used in the poller-id={}, which is not the same. Can we use that? And please update the poller to use the first poller to do the conversion. The second poller doesn't have any conversion to json.
This is a change of behavior. The first poller maps to json and can only be used in the poller-id={}, which is not the same. Can we use that? And please update the commit message to use that instead?
I think we should use the public setProperties(String urispec, String remaining, Map<String, Object> params) method, so we can remove properties
I think we should use the new WekaConfiguration(this) method instead of setting params here.
I think we should use the new WekaConfiguration(this) method instead of setting the parameters.
You should test for both instructor and student?
You should verify the student is access?
You should verify what the instructor is access?
Is there a more complex way to do this?
Is there a more dynamic way to do this?
Is there a more need to do this?
setErrorMessage
setErrorMessage which says "Error while generating image.". Maybe just " showImage".
Create a new log message and then immediately log the error.
can u extract a final constant with a readable name out of "<[ ]*%s[ ]*>"?
could u extract a final constant with a readable name out of "<[ ]*%s[ ]*>"?
can u extract a final variable with a readable name out of "<[ ]*%s[ ]*>"?
why is probeRenderer initialized in the constructor?
why is this needed?
why is probeRenderer initialized to null?
should be assertThat(output.endsWith("-") || output.endsWith("NormF0000"))
should be assertThat(output.endsWith("-"), equalTo("deprecated"))
should be assertThat(output.endsWith("-") || output.endsWith("Normilized string")
Looks like a compilation error here. At least an IDE should be able to infer this.
I think the canonicalOutFile.toPath() can return null if it's not defined.
Looks like a compilation error here.
We can add more specific exception like "Unexpected exception while waiting for mint here".
We can add more specific exception like "Unexpected exception while waiting for the specified action"
We do not know about the timeout here.
curly braces around single line blocks
curly braces around "for" blocks
HashSet
This may not fail. Because it's a normal situation, which would be essentially invalid. However, in the case of user types this would fail with an exception.
This may not fail. Because it's a pre-existing index.
This may not fail. Because it's a pre-existing Index, but the message may be confusing.
Really minor, but this could be written as return iterator(getOrCreateStream()) instead of going through the loop twice.
Really minor, but I think it would be clearer to use forEach rather than relying on the stream.
Really minor, but this could be written as return iterator(getOrCreateStream()) instead of going through the loop below.
This should be a checkNotNull(this.operatingSystemToOsFamily) check
This should be a checkNotNull or checkState (and return null).
This should be a checkNotNull(this.operatingSystemToOsFamily)
This should be in the ctor.
This should be in the StripeAuthHeader method.
This should be in the constructor to avoid instantiation.
/a/b/l3/dd should be replaced by constant.
/a/b/l3/dd should be better for readability.
/a/b/l3/dd should be replaced by arg "toFile"
This mapping should be in the API, see BackendResource for examples
This mapping should be in the API, see BackendResource for example.
This mapping should be in the API, see BackendResource for examples.
calling endSuccessfully directly instead of endSuccessfully
calling endSuccessfully directly is not needed. Please remove the 'log' method.
calling endSuccessfully() instead
How does this relate to removing the TTL? I think it should not be in the constructor.
How does this relate to removing the TTL? I think it's only being used by the JMX client.
How does this relate to removing the TTL? I think it's only being used by the application thread.
Why do we have to test 100L * 1024L?
Why do we have to cast here?
Why do we have to test 100L here?
I'd suggest getting rid of the pkg types and using the.entrySet() block.
I'd suggest getting rid of the pkgtypes altogether.
I'd suggest getting rid of the pkg types and using the.keySet().
Is there a rationale for exposing this method?
Check for at least one of the thrown exception.
Check for at least one of the thrown exception?
suggestion throw new IllegalStateException("Cannot terminate process. Not a UNIX system.");
suggestion throw new IllegalStateException("Cannot terminate process. Not a UNIX system please.");
suggestion throw new IllegalStateException("Cannot terminate process. Not a UNIX system please."));
Not sure if this is the correct fix for this PR. If you think the default retry handler would be a new LBClient to get the retry handler of the clientConfig map, and we would need to get the retry handler from the map i.e. if clientConfig is the default retry handler of the current LBClient we would need to adjust the verification of all clientConfigs and readTimeouts.
Not sure if this is the correct fix for this PR. If you think the default retry handler would be a new LBClient to get the retry handler of the clientConfig map, and we would need to get the retry handler from the map i.e. default retry handler.
Not sure if this is the correct fix for this PR. If you think the default retry handler would be a new LBClient to get the retry handler of the clientConfig map, and we would need to get the retry handler from the map i.e. if clientConfig is the default retry handler of the current LBClient we would need to be able to figure out how many clients are mapped to.
Braces.
Braces should be set
Braces
It would be better to add a boolean flag to unkownSubsystems and check it here, and add the model of the richSubsystems to the logger. Then we could also log the error, and log the error at the trace level.
It would be better to add a boolean flag to unkownSubsystems and check it here, and add the model of the richSubsystems to the logger. Then we could also log the error, and log the error at the debug level.
It would be better to add a boolean flag to unkownSubsystems and check it here, and add the model of the richSubsystems to the logger. Then we could also log the error, and log the error then throw it.
Should return the empty list, not null
Is it the same as return null? The null value is returned in the method, so it is safe to return the empty list.
Is it the same as return null? The null value is returned in the method, so it is safe to return an empty list.
Missing'physicalKeyRow.setRowKind(RowKind.DELETE);'
RowKind.DELETE
Writer the iteration in the following way will be simpler and easier to understand.
null should be lhs
@bxf12315 there are no null checking in this constructor
@NielsCharlier there is no need to pass null for username and clientAddress
Should be debug or warn
Should be "Model run complete"
Should be debug
Maybe use the new verifySignatureFor(String algorithm, byte[] secretBytes, String payload, byte[] signatureBytes) method, which would be more robust
Maybe use the new verifySignatureFor(String algorithm, byte[] secretBytes, String payload, byte[] signatureBytes) method, which is more robust
Maybe use the new verifySignatureFor(String algorithm, byte[] secretBytes, String payload, byte[] signatureBytes) method, which would be better.
If I understand correctly, if success == true, then writeUnlockAll will be called before writeUnlockAll, so other callers are not expecting the IOException to be thrown.
If I understand correctly, if success == true, then writeUnlockAll will be called before writeUnlockAll. If it was already called after writeUnlockAll, then it will be skipped.
If writeUnlockAll() throws an exception, then other callers are not expecting to call writeUnlockAll().
Should we use a specific drive letter for a word?
Should we use a specific drive letter for a colon?
Should we use a specific drive letter for a colon in the strings?
If you use scheduleDirect, then you can use it directly here.
If you use scheduleDirect, you can use it directly here.
If you use scheduleDirect, you can use it directly here, too.
I know this is pre-existing, but it would be good to include the stack trace as well.
I know this is pre-existing, but it is worth mentioning that txTable.prepare(externalXid) can throw an Exception if the transaction fails, the Xid would be already loaded. Since the txTable no longer logs the exception, the Xid after it was completed.
Same here - could you undo this change?
nit: this method could be private?
nit: this method could be made private
nit: this method could really be private?
[DEVELOPER](<LINK_0>
/s/Commit Org/ Is this a bug?
/s/Commit Org/ Is this a misleading name?
This seems like it could be private since it's only used in this class.
This seems like it could be also called after the fireEventsFor() call, which is not necessarily the case where the event list is updated. Would it be possible to call the remove() method at the end of the loop as well?
This seems like it could be also called after the fireEventsFor() call, which is not necessarily the case where the event list is updated. Would it be possible to call this instead?
suggestion void setCustomFields(Map<String, Object> fields) {
doesn't this method need to be public?
suggestion void setCustomFields(Map<String, Object> fields);
This is the default implementation.
This is the default behaviour.
This is the default impl.
Please remove the extra line.
Please remove the extra line. Otherwise looks good otherwise.
Please remove this line.
These methods can return void
These methods can be private.
These methods can return void.
does this need to be called from the clean up?
does not need to be public
does this need to be called before onCreateView?
Call this.key here.
Use ImmutableSet.of()
You should use ImmutableSet.of() here.
Can we update the message to reflect the cause of the exception? suggestion throw new RuntimeIOException("Invalid index file '%s'", source, ex);
Can we consolidate into a single catch block?
Can we consolidate into a single catch?
new DirectoryException("Invalid data loading policy: " + dataLoadingPolicy + ", it should be one of: %s", dataLoadingPolicy, schema);
new DirectoryException("Invalid data loading policy...");
"schema is null"
Is it possible to have a constant for this?
Is this really necessary?
Is it possible to have a constant for this in the class?
Why change the method name?
Let's remove the public modifier from the class.
Let's remove this.
seems we already have a Neo4jRealmCoordinator(TransactionCoordinator owner, options ) method above. I'd be tempted to move that to the startTransactionCoordinator method and have all the logic in one method.
seems we already have a Neo4jRealmCoordinator(TransactionCoordinator owner, options ) method above. I'd be tempted to move that to the top.
I'd also rename it to txCoordinator.
Should we get a try-with-resources here, since we don't wrap it in an OutputStream anymore and avoid the synchronization?
Should we get a try-with-resources around this? I don't see a reason to wrap before it's an exception.
Should we get a try-with-resources here, and remove the explicit close() call?
return ok(systemConfig.getApiTermsOfUse());
return this?
return this
is it possible to use nulls here?
is it possible to have a null language here?
is it possible to have a null language in the future?
rename to element
rename to element?
rename to element or element
I think this can be static
I think this is a bit misleading, as it doesn't really matter what.
I think this is a bit misleading, as it's not called from anywhere.
Should be outputln(" ");
It should be better to have the method autoGenNote(String) and autoGenNote(String) method
It should be better to have the field called autoGenNote.
The message should be "Timed out" not "Timed out".
The message should be "Timed out" not "Timed out"
The message should be something like "Time out of CancelledException"
Why do you need to catch VdcBLLException here? Did you really want to log the exception, or should it be a warn?
Why do you need to catch VdcBLLException, you may want to log the exception message, or something like that.
Why do you need to catch VdcBLLException here? Did you really want to log the exception, or should it be a warn instead?
s/vdsId/cluster
Shouldn't it be inside decreasePendingVms?
s/vdsId/vdsId
In general it is not a good idea to check currency directly. We should only do that for getCurrency and then compare the actual getCurrency to be equal to getCurrency.
In general it is not a good idea to check currency directly. We should only do that for getCurrency and then compare two different currencies.
In this case I would just call the field directly.
call notFound
call this notFound
call notFound instead
what about java return Objects.requireNonNull(externalUserPassword);?
what about java return Objects.requireNonNull(externalUserPassword);
what about java return Objects.requireNonNull(externalUserPassword);?
I would use Integer.valueOf to avoid to import from guava.
I would use Tree.Kind.SWITCH_STATEMENT here.
I would use Integer.valueOf to avoid SWITCH_STATEMENT.
this fails for me, although I'd be in favor of removing it if it fails. I'd delete it in the test case, leaving it in for now.
this fails for me, although I'd be in favor of removing it if it fails. I'd be more comfortable to just delete the original code in your tests, leaving it in for now.
this fails for me, although I'd be in favor of removing it if it fails.
Should this method return an Optional?
Should this method return a null or throw an exception?
Should this method return a boolean, or maybe throw an exception?
Would be good to move this exception handling into the try statement. Then you do not have to do it twice. The following would be good enough.
Would be good to move this exception handling into the try block. Then you do not have to do it twice. The following would be good enough.
Would be good to move this exception handling into the catch clause.
I don't think it's a good idea to change this in this PR, but since this is a pull request, it should be in a separate pull request.
I don't think it's a good idea to change this in this PR, but since this is a test, it can also fail if the ws parameter is null.
I don't think it's a good idea to change this in this PR, but since this is a test, it can also fail if the ws parameter is null, since it is a deprecation error.
It is file, not url. how about "url cannot be null"? that would be a completed sentence
It is file, not url. how about "file cannot be null"? that would be a completed sentence
It is file, not url. how about "Url cannot be null"? that would be a completed sentence
Nitpick: It's just a personal preference, but I much prefer to have the super constructor call this(targetUriAsString).
Nitpick: It's just a matter of personal preference, but I much prefer to have the super constructor call this(targetUriAsString).
Why?
Better use Collections.singletonList() here.
static import
static import?
Would be good to introduce a local variable for this return value as be a final variable. Also, would be good to correct my taste, also ValueArray[] values = r.getList(); for (ValueArray row : values) {... }
Would be good to use Long.MAX_VALUE here as well.
Would be good to use Long.MAX_VALUE here as well?
See my previous suggestion about using a thread safe map to do the check: CachedConnections ccl = getCache().get(cacheKey); if (ccl!= null) { cache.put(cacheKey, ccl); } return cachedConnection.transport;
See my previous suggestion about using a thread safe map to do the check: CachedConnection cachedConnection = getCache().get(cacheKey); if (cachedConnection!= null) { cache.put(cacheKey, new CachedConnections()); } return cachedConnection.transport;
See my previous suggestion about using a thread safe map to do the check: getCache().get(cacheKey).reserveAny();
add brackets to make this expression more easy to understand
add brackets to make this statement more easy to understand
add brackets to make this more easy to understand
This is a really strange case. gwtorm should return the value anyway, rather than the null check.
This is a really strange case. gwtorm should return the value anyway, rather than null?
This is a really strange case. gwtorm should return the value anyway, but null isn't a very bad thing
We should add curly braces even for single-line statements.
We have some race condition here. onRebalanceKeyReceived only is good. Maybe it's better to have single synchronization?
We have some race condition here. onRebalanceKeyReceived only is good when there is async operations, but the IgniteCacheContext is AutoCloseable.
Not an exception
Not an error
Not an NumberFormatException
This is a lot of code duplication, maybe we could maybe have a method for * to take a list of Samples to get the Samples to this section. The views here are my main concern.
This is a lot of code duplication, maybe we could maybe have a method for * to take a list of Samples to match the Samples in this file. The views here are my main concern.
This is a lot of code duplication, maybe we could maybe have a method for each of these? I would also be a lot of this here.
I think we should consider having this method public void deleteAsyncTaskPlaceHolder(String taskKey) { if (taskKeyToTaskIdMap.containsKey(taskKey)) { return; } else { void deleteAsyncTaskPlaceHolder(String taskKeyToTaskIdMap.remove(taskKeyToTaskIdMap.getTaskId(taskId) } }
I think we should consider having this method public void deleteAsyncTaskPlaceHolder(String taskKey) { if (taskKeyToTaskIdMap.containsKey(taskKey)) { return; } else { void deleteAsyncTaskPlaceHolder(String taskKeyToTaskIdMap.remove(taskKeyToTaskIdMap.remove(taskKeyToTaskIdMap.getTaskId(taskId)); } }
I think we should consider having this method public void deleteAsyncTaskPlaceHolder(String taskKey) { if (taskKeyToTaskIdMap.containsKey(taskKey)) { return; } else { void deleteAsyncTaskPlaceHolder(String taskKeyToTaskIdMap.remove(taskKeyToTaskIdMap.remove(taskKeyToTaskIdMap.getTaskId(taskId) } }
I think this could be more readable if we return contains(otherId) == false
I think this could be more readable if we returned contains(otherId) == true
I think this could be more readable if we returned contains(otherId) == false
I don't know the version of this PR, but why did you change it to org.kie:kie-server-client:6.2.0.Final?
I don't know the version of this PR, but why did you change it to org.kie:kie-server-client:6.2.0.Final to org.kie-server-client:6.2.0.Final?
I don't know the version of this PR, but why did you change it to org.kie:server-client:6.2.0.Final?
Curious why this field is not public.
Curious why this field is not public?
Redundant initialization.
suggest using 'this' in it
suggest to add null check.
suggest to add null check
might be useful to print it, no?
Some of the public methods in the first class could be package-private.
Some of the public methods here seem to be in the immediate type!
I don't think this is correct. If you have a builder that does this, you still need to modify the gson field.
I don't think this is necessary for the delete.
I don't think this is necessary
What's the purpose of this change?
What are you creating this executor service?
What's the reason for using this constant?
This should be protected, and the other should be protected.
Should disableCliSchedule be the Action so that it can be disabled by other modules.
Should disableCliSchedule be the Action so that it can be disabled by other components?
1. you can get the vm from db already 2. please use getVm() instead of db call here
detach the user from the pool
detach
Can you explain why this is necessary?
Can you explain why the thread context class loader change?
Can you explain why the thread context should be assigned to the class loader?
listeners are not notified?
listeners are missing in this method.
listeners are missing in this listeners.
![MAJOR](<LINK_1> 'Severity: MAJOR') Call "Optional#isPresent()" before accessing the value. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Call "Optional#isPresent()" before accessing the value. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> 'Severity: MAJOR') Call "current" before accessing the value. [![rule](<LINK_2>](<LINK_0>
Can you make this private?
Can you make all of these methods private?
Can you make this public?
this can be 'long' instead of 'Long'
this can be 'Long' instead of 'Long'
this can be 'Long' instead, right?
Get the service based on null, this method should return a null.
Get the service based on null, this method should return a void
Get the service based on the current state, this method should return a void
Please use GTK3.21 instead.
Please use GTK.gtk3.10. GTK3.21 instead of 3.14.0.
Please use GTK_VERSION_1.
How about to call super.updateApplication(getApplicationByName())?
How about to call super method in the context that is deliberate?
How about to call super method in the context that is deliberate?
Can we use com.google.common.base.ObjectMapper#toJson instead?
Should we use com.google.common.ObjectMapper#toJson instead?
Can we use com.google.common.ObjectMapper#toJson instead?
@exper0 let's use HmRsHeader class here
@ekondrashev the same above.
@exper0 let's use HmRsHeader instead of Matchers.
minor thing - there is a constructor with just this signature so it can be private.
minor thing - there is a constructor with just this signature so you don't need to duplicate it.
minor thing - there is a constructor with just this signature so you don't need to duplicate the logic.
I would go with if (firstChar == '{') and return firstChar + unary.equals(firstChar);
I would go with if (firstChar == '{') and remove semicolon
I would have preferred an else without the '[' check...
prerequisite.isInitialized() -> manager.getTimestampService().isInitialized()
prerequisite.isInitialized() -> manager.getTimestampService().isInitialized()?
prerequisite.isInitialized()?
this method can be private.
selectedItem can be null
selectedItem is never null
Remove 'public'.
Please make identifier final.
Remove 'this'.
why not field?
why not re-use getField() instead?
why not re-use field?
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage?
It does not look to be a good public API. Why would you need it here? Could it be just moved to Job?
It does not look to be a good public API. Why would you need it here? Could it be just moved to storage?
This doesn't need to be public, it can be removed.
This doesn't seem to be a safe cast.
This doesn't seem right.
Please, use cast.
This cast is redundant.
Please, use cast instead.
While the code here is correct, consider using.map(startupPage -> startupPage.getPath()) here instead of stream()
While the code here is correct, consider using.map(startupPage -> startupPage.getPath()) instead of stream()
nit: do you think it would be nice to use method reference for startupPagePath here?
What's the purpose of this method?
I think this method can be private.
I think this method should not have public
This should be called only if showMigrationEvents is null and the method is called only when showMigrationEvents is null.
This should be called only if showMigrationEvents is null and the method is called only when showMigrationEvents is true.
This should be called only if showMigrationEvents is null and the method is not called from anywhere else.
Add the name of this message.
Add the name of this message. Also you can use the log message as the second argument.
Add the name of this message. Also you can use the log message as the second parameter.
That's a different error message, as the default is a different one.
That's a different error message, as the default no longer is a different one.
@Override
These should use the classes that are created with static methods - remove them from the constructor and add them to the method reference.
These should use the classes that are created with static methods instead of calling this method.
These should use the classes that are created with static methods - remove them from the constructor and add them to the factory class.
@since 3.13 missing
@since 3.13 on old line.
@since 3.13 on old code
I'm wondering whether the project is visibility when the delete operation is invoked. For example, the first project is on a different package and the second one is a no-op. I would prefer to keep the visibility in the class, so you don't have to expose the public modifier on the constructor. For example, the first project is default, the class is package private.
I'm wondering whether the project is visibility when the delete operation is invoked. For example, the first project is on a different package and the second one is a no-op. I would prefer to keep the visibility in the class, but I prefer to switch to a separate field
again, I would hide the visibility in the constructor as well.
The Streams reference is a bit tricky here, because it represents a poor human-readable construct for a cluster of a given format. It is not clear to me that this is an explicit null check instead of a null check.
The Streams reference is a bit tricky here, because it represents a poor human-readable construct for a cluster of a given format. It is not clear to me that this is an explicit null check.
The Streams reference is a bit tricky here, because it represents a poor human-readable construct for a cluster of a given format. It is not clear to me that this is an API that can follow up more clearly.
Why is this needed?
Why is this needed? I don't think this is needed.
Looks like this is wrong.
Same here, you can simplify and remove the ternary.
getUserIdIfExternal() is never null, you can remove this.
getUserIdIfExternal() is not null, you can simplify this to getUserId().
do we need to call.build() here?
assertNull
assertNull?
bonusType can only be 1
bonusType can only be 1 here
bonusType can't be null
Does it need to be public?
should be public as well
should be public
This assertion no longer passes if I am parsing this?
This assertion no longer works if we are using this equalTo
This assertion no longer passes if I am parsing this? Why don't use assertThat?
This should be a null check for this.groupId.getContent()!= null && this.groupId.getContent()!= null, since it is always non-null.
This should be a null check for this.groupId.getContent()!= null && this.groupId.getContent()!= null
This should be a null check on the value.
Probably should call Thread.currentThread().interrupt() when handling InterruptedException toTop
Probably should call Thread.currentThread().interrupt() in this catch block
Probably should call Thread.currentThread().interrupt(); here
I think this is an improvement, while you are at it, could you please change the logic to use the other registerOperationWithHeapSize function?
I think this is an improvement, while you are at it, could you please change the logic to use the old one?
I think this is an improvement, while you are at it, would it be possible to change the logic to use the old one?
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
THREAD-SAFETY You need to make up your mind here (lol), use thread safe collection OR use the lock. Please also use the try-finally idiom when using explicit locks as well.
THREAD-SAFETY You need to make up your mind here (lol), use this thread safe collection OR use the lock. Please also use the try-finally idiom when using explicit locks as well.
This seems wrong - use Objects.hash(name, name).
This seems wrong. It should be Objects.hash(name, name).
This seems wrong - use Objects.hash(name, name);
can you make this method final?
can you change the method name to something like roundStorageSize?
can you change this to java return new Pair<>(new Pair(Environment.getDataDirectory().getTotalSpace()));
Be careful of nullable fields!
In Java 8, it seems like better to use [FormFieldId.values()](<LINK_0> to make this more readable.
In Java 8, it seems like better to use [FormFieldId.values()](<LINK_0> instead of repeated the loop.
Could we just call SalesforceAnalyticsManager.clearCaches(userAccount); from here?
Could we just use SalesforceAnalyticsManager.removeUserAccount(userAccount); here?
Could we just call SalesforceAnalyticsManager.clearCaches(userAccount); here?
This needs to be done with Override annotation.
This needs to be done with return getDefault().useBase();
This needs to be done with return getDefault().useBase;
@Nullable
"this." is not necessary; you can just use Collections.addAll(iter)
"this." is not a good name.
This method can be package private.
This method can be private.
This method can be package private
if this is running it will not make sense to do it.
if we are not running it will make sense to make it an infinite loop.
if we are not running it will make sense to make it an IllegalStateException.
Can be private.
Can you remove the equals implementation?
Can you remove the equals statement?
nit: You can use PreviewEditModePageObject here.
nit: You can use PreviewEditModePageObject(driver) method
nit: You can make this method private
This should be return new ViewerCell<E>((ViewerRow<E>) clone(), column, getElement());
This should be return new ViewerCell<E>((ViewerRow<E>) clone(), column, getElement(), null);
This should be return new ViewerCell<E>((ViewerRow<E>) clone(), column, getElement().getType());
Maybe add something like DetailAST result = node; while (true) {... }
Maybe add something like DetailAST node = node; while (true) {... }
Maybe add smth like,..
Why return null?
Why?
Why null?
I would suggest either leftOperand.verifyEliminateNots or leftOperand.verifyEliminateNots(), or just leftOperand.verifyEliminateNots().
I would suggest either leftOperand.verifyEliminateNots or leftOperand.verifyEliminateNots(), or just leftOperand.verifyEliminateNots()?
I would suggest either leftOperand.verifyEliminateNots(), or just leftOperand.verifyEliminateNots().
Since this change is not needed, Chinese can be modified directly.
Since this change is not needed, Chinese can be modified while it is used.
Since this change is not needed, Chinese can be modified while it is not.
I think it would be better to take a look at the implementation of waitForWritesCompleted in a more general way, something like: for (StoreObjectAccessor writer : writers.values()) { writer.waitForCurrentWrites(timeout); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
I think it would be better to take a look at the implementation of waitForWritesCompleted in a more general way, something like: for (StoreObjectAccessor writer : writers.values()) { writer.waitForCurrentWrites(timeout); }
I think it would be better to take a look at the implementation of waitForWritesCompleted in a more concise manner: for (StoreObjectAccessor writer : writers.values()) writer.waitForCurrentWrites(timeout); writeLock().unlock();
nit: why is this called groupByColumns?
nit: can we add a log message here for aggregation on such columns?
nit: can we add a log message here for aggregation on this?
Same here, don't need to check partition index as well.
Same here, don't need to check partition-INDEX as well.
Same here, don't need a null check
please add values that you have done in the same order you declare and initialization.
please add a brickPosition here and have them in the same order you can use it
please add values to the position
There is no need to call query.query(0)
There is no need to do this.
I'm not sure it's related to this change.
rename to file
Why is this necessary?
rename to file or directory
Now that we wrote this into CrashlyticsCore, in which case logt and logt. Wouldn't this be sufficient?
Now that we wrote this into CrashlyticsCore, in which case logt and logt. Wouldn't this be simpler?
I think it's cleaner to make this non-static
the while condition can be dropped
the while condition can be removed
the while condition can be removed now
Wondering if we can use a method that accepts a List<String>.
Wondering if we can use a method that accepts a String.
Wondering if we can use a method that accepts a List<String> > as return type.
Can this be reduced to: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return true; }
Can this be reduced to: java if (!capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return true; }
Can this be reduced to: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return true; } That captures the logic of subscription licenses having unlimited offheap by default quite succinctly I think.
What about the null case?
For consistency with the rest of the class, maybe we should enforce that when the field is null, we can avoid an NPE in such case
For consistency with the other getters, maybe remove the field?
This is major, so why not make it configurable?
This is major, so why 10 seconds?
This is major, as 2.
I think the caller would do the following: java public static SamplerConfiguration getIteratorSamplerConfigurationInternal() { SamplerConfiguration scannerSamplerConfig = getSamplerConfiguration(); if (scannerSamplerConfig!= null &&!iteratorSamplerConfig.equals(scannerSamplerConfig)) {... } }
I think the caller would do the following: java public static SamplerConfiguration getIteratorSamplerConfigurationInternal() { SamplerConfiguration scannerSamplerConfig = getSamplerConfiguration(); if (scannerSamplerConfig!= null &&!iteratorSamplerConfig.equals(scannerSamplerConfig)) {... } } return scannerSamplerConfig; }
I think this check can be simplified as the following if (scannerSamplerConfig!= null &&!iteratorSamplerConfig.equals(scannerSamplerConfig)) {
Why does this need to be public?
Why does this need to be public? I'm not a big fan of private methods synchronized
Why doesn't this need to be public?
Can we make the tryLock method return int, so that we don't have to specify the sort of "finally" block? Also, for the tryLock() call, it's not "finally".
Can we make the tryLock method return int, so that we don't have to specify the sort of "finally" block?
Can we make the tryLock method return int, so that we don't have to worry about the order of the states?
The code looks strange, can you please explain why do you have copy here?
The code looks strange, can it be combined into one line?
please move the code outside the try block
can we remove this?
we can remove this one too
we can rename the field to one of them?
Objects.requireNonNull( checkpointMetadata)
Objects.requireNonNull(partitionMetadata)
public
It would be nice to pass an empty map instead of null (which would make the test no-op if not null).
It would be nice to pass an empty map instead of null (which would make the test not fail).
It would be nice to pass an empty map instead of null (which would make the test more compact).
I think there is some better way to do this instead of threadContext.execute().
I think there is some place in this class that looks better than threadContext.execute().
I think there is some better way to do this instead of threadContext.execute.
Why do we need the Wonder if we can make sure we are adding the CCC descriptor below?
Why do we need the CCC descriptor here?
Why do we need the Wonder if we can make this a CCC object?
Should this be a warn?
I wonder if we should throw an exception here, instead of logging the exception.
I wonder if we should throw an exception here, instead of logging the exception to the caller.
token -> skipTransaction?
token -> cache?
token -> skipTransaction()?
Is this method used?
Is this method used anywhere?
Is this correct?
isCheckstyleModule should be tested here, I think...
you should call the method isCheckstyleModule() to not sleep for a number of modules in the tree.
you should call the method isCheckstyleModule() to not sleep for a bit the test.
Ditto: "No page sink provider for catalog"
"No page sink provider for catalog '%s'"
"No page sink provider for catalog"?
Again, we should use braces
Again, we should use braces here.
Again, we should use braces here
No need for getInstance(), the container can be passed
No need for getInstance() since the container can be passed
No need for getInstance(), the container can be passed.
Does this class have any state?
I'd keep this package-private
Does this class have any state?
Can be simplified to return a lambda.
Can be simplified to return a collection.
Can be simplified to return EntityMap.from(getMembers()).
@NielsCharlier there is a org.apache.commons.nio.charset.StandardCharsets#UTF_8
@NielsCharlier there is a org.apache.commons.nio.charset.StandardCharsets#UTF_8.name()
@NielsCharlier great opportunity to wrap this code in an try-with-resources, to avoid the default charset.
I don't think we should return true if cache is not null.
I don't think we should return true if cache is not enabled
I don't think we should return true if cache is not present.
5 => insert between checkstyle and %s
5? dont you want a constant?
5? dont you want to make it a constant?
This should use super.sendMessage(chatRoom, toSend); instead of super.sendMessage(chatRoom, toSend);
This should use super.sendMessage(chatRoom, toSend); rather than super.sendMessage(chatRoom, toSend);
This should use super.sendMessage(chatRoom, toSend); instead of super.sendMessage(chatRoom, toSend));
here should be replaced with StringUtils.isEmpty()
here you can use StringUtils.isEmpty()
StringUtils.isEmpty() checks for null and empty string
Don't know why it's true, it's false.
Don't we need this. it will be set to false and then return RebaseCommand?
Don't we need this. it will be set to false and then return this?
Why calling forceLoad() here and not on the DataLoader<D>? This is consistent with the StoreManager pattern above.
Why calling forceLoad() here and not just calling it immediately? It's necessary to take a single thread to do it.
Why calling forceLoad() here and not just calling forceLoad()? This is different naming convention.
Should we merge this into BitmapUtils?
Should we split this into multiple lines?
Should we split this into several lines?
Can we use the diamond operator?
Can't we just add the original exception as a cause?
Better to use the diamond operator: new ArrayList<>()
This should be OperationFailedException.
WFLY-4294 says this method should be called in a separate patch.
WFLY-4294 says this method should be removed.
No need to consider final
Remove this call
Remove this
If you're using this file system property, I don't think it's necessary.
if you agreed on using this file system property, I don't think it's necessary.
if you agreed on using this file system property, I don't think it's necessary. If the user has it and "no" the property is set, and the user has not updated the prop file.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message instead of ignoring
I think we need to get rid of the String here.
I think we need to get rid of the path variable by calling the String.format() method.
I think we need to get rid of the path variable since we already have a getter to get it
Move String values used more then once to a constant.
Move String values used more then once to a constants.
String values used more then once to a constant.
Label should be reporting.parameter.onOrAfter
The name of the onOrAfter parameter should be reporting.parameter.onOrAfter
The name of the onOrAfter parameter should be renamed as well, although I would favor exposing some sort of understood by our reporting framework.
Should this be forReplaced?
Would be nice to have this test different from the one in a sub method.
Why is this needed?
As we discussed, lets change the _violations to be Iterator<ConstraintViolation<ConstraintViolation>>.
As we discussed, lets change the _violations to be Iterator<ConstraintViolation<RemoteDataSetDef>.
As we discussed, we need to be careful about performance of to Iterables.getOnlyElement in this validator class.
no need to check for the constructor, this is already done by [this](<LINK_0>
no need to check for the constructor to not be null - the method already checks if header is empty.
no need to check for the constructor to not concatenate strings.
while you're at it, perhaps you can please rename the "endAction" to "ignored"
while you're at it, can you please rename the "endWithFailure" to "ignored" so that the verb is more clear?
how about createSnapshotForVm?
please use NotImplementedException()
please use NotImplementedException()()
please use UnsupportedOperationException()
does this not work?
Does this not work?
does this mean that you have to override the default thing?
I'm not sure if this is the right thing to do here. It looks like numOperations / getExecutingSlaves() is the same as numOperations / getExecutingSlaves().size(). So this should be numOperations > 0.
I'm not sure if this is the right thing to do here. It looks like numOperations / getExecutingSlaves() is the same as numOperations / getExecutingSlaves().size(). So this should be moved outside the if block.
I'm not sure if this is the right thing to do here. It looks like numOperations / getExecutingSlaves() is the same as numOperations / getExecutingSlaves().size(), so it should be more accurate.
I think it's ok to remove this check. If setEntries is not null, do you want to check it for null?
I think it's ok to remove this check. We may want to have a test that confirms that the new key-value pair is not set.
I think it's ok to remove this check. We may want to have a test that confirms that the new key-value pair is correctly set.
Any reason to add this change here?
Any reason to add this change?
Any particular reason to add this change?
old app.controller.shutdown();
This is wrong. Workers (members of the map) has been called for shutdown. "Kill" is not an instance method, so it is a mock app.
This is wrong. Workers (members of the map) has been changed for what is not the case.
I think using save(new Message(message, "", intramurals, member).setSent(true)); should be consistent with other methods.
I think using save(new Message(message, "", intramurals, member).setSent(true)); is more robust (and safer) so you don't have to create a new MemberDao object for this.
I think we should use MigrationValidator
you should be able to use the list directly here
I would use ArrayList<Order> here.
you should be able to use the new ArrayList<>() here
Should be 'public'
Needs Override
Should be static
Do we need to keep this method public?
can be replaced with: return getStudents();
can be final.
You should do a null check here as well.
I'm a bit worried about this, as there may be a memory leak. I mean, each object is a Java object, so why do we need to retrieve it as a fromJson? The only usage is that, as you get the fromJson(String, Class, MappingParser, Class) is very complex. It is better to catch and reset it as null as possible.
I'm a bit worried about this, as there may be a memory leak. I mean, each object is a Java object, so why do we need to retrieve it as a fromJson? The only usage is that, as you get the fromJson(String, Class, MappingParser, Class) is very complex. It is better to catch and reset it as null.
Use the solution in the large Overall/Manage PR instead, please.
Use the solution in the large Overall/Manage PR instead of in the solution.
Use the solution in the large getTarget() instead.
You should create a new MockSCMSource here. Then you can just set the setId method on the builder.
I think we should create a new MockSCMSource here. Then we don't have to create these objects in the builder.
I think we should create a new MockSCMSource here. Then we don't have to create too many objects, but we should only use it once.
Since we are improving this code anyway, I think we should switch to using [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, since lowercasing a string is not always the same for non-ascii characters.
Since we are improving this code anyway, I think we should switch to using [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, since lowercasing a String is not always the same for non-ascii characters.
Since we are improving this code anyway, I think we should switch to using [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, because lowercasing a string is not always the same for non-ascii characters.
Can you add curly braces please?
suggestion if ( value instanceof Rollup || value instanceof String) {
Better to add curly braces for the subsequent if statement.
It seems that you can safely remove all the accessor rows and check for that condition and throw an exception and if what you want to do work with it.
It seems that you can safely remove all the accessor methods from this class and if what you want to do future proofing. For example, if what I use 0 instead of getMaxCapacity() and getMaxCapacity(), you can safely keep this as private and check.
It seems that you can safely remove all the accessor methods from this class and if what you want to do future proofing. For example, if what I use 0 instead of getMaxCapacity() and getMaxCapacity(), you can safely keep the same behavior and check for that.
Did you check that it's not already null?
Did you check that it's not null?
Did you mean to remove this?
Maybe you could use a [Optional](<LINK_0> to trigger the assertion
Maybe you could use a [Optional](<LINK_0>
Maybe you could use a [Optional](<LINK_0> instead? Not only supports null here
missing'return'
missing <code>this</code>
missing 'this'
It seems redundant to have a copy-and-paste error here.
It seems redundant to have a copy-paste error here.
Can we make the constructors public?
I don't think you need to call closeBraceToken() if you are using a stream as you're already doing this for you.
I don't think you need to call closeBraceToken() if you are using a stream as you're already touching the code.
I don't think you need the if.
java catch (IOException e) { throw new IgniteCheckedException(e); }
I think we should move the logic of deleting index files into the IgniteCheckedException, so it doesn't throw an exception.
I think we should move the logic of deleting index files into the IgniteCheckedException rule as well.
suggestion logger.info("Scheduling criteria to run every {} seconds (will start in {} seconds)", interval, initialDelayInSeconds, threadNumber);
suggestion logger.info("Scheduling criteria to run every {} seconds (will start in {} seconds)", interval, initialDelayInSeconds);
suggestion logger.info("Scheduling criteria for {} seconds (will start in {} seconds)", interval, initialDelayInSeconds, threadNumber);
This DiscardAttributeChecker.UNDEFINED is a valid value for VERSION_2_0_0 and VERSIONOVERY_USERNAME_ATTRIBUTE.
This ValueValueChecker.UNDEFINED is never VERSION_2_0_0 but the attributeBuilder.create() is never used.
This DiscardAttributeChecker.UNDEFINED is a valid value for VERSION_2_0_0 and VERSIONOVERY_USERNAME_ATTRIBUTE. I think we should be able to remove completely the Unsupported behavior for this attribute.
We should leave it like this. If the node dies after this call, we won't have marked it. Better to have an erroneous mark than to miss it completely.
We should leave it like this. If the node dies after this call, we won't have marked it.
We should leave it like this. If the node dies after this call, we won't have marked it. Better to have an erroneous mark than to miss it,
The @Override is not needed here.
The convention in the codebase is to include the @Override in the signature.
The convention here is incorrect, and the following is not correct.
Have you considered to make a defensive copy here? Don't we want to write and handle the null argument prior to calling getEntities?
Have you considered to make a defensive copy here?
public?
Why not call ExportFileName.decodeAnnotationClassNameFromExportFileName()?
Does this need to be public?
Why not call the function exportFileName and exportFileName?
Just a thought, don't set this to BioWorkflow.class
Just a thought, don't set this to BioWorkflow.class::cast
Just a thought, don't you think we want to use createQuery() here?
This needs to use justOrEmpty as the response value can be null which is an illegal value in a Reactor stream.
This needs to use justOrEmpty as the response value can be null which is an illegal value in Mono.
This needs to use justOrEmpty as the response value can be null which is an illegal value in a submap.
Why do we need to keep the same check as before?
Why do we need to keep the same close around close?
Why do we need to keep this check?
java return getAttributes().get(name);
java return (A) getAttributes().get(name);
java return (A) getAttributes().get(name));
I think this is wrong. The method already returns what the value of the wait has failed.
I think this is wrong. The method already returns what the value of the wait has after this line.
I think this is wrong. The method already returns what the value of the wait was set to 0.
I'm not sure what this one is going to do here, but it's better to just use count.get() without assertTrue
Same here, it's better to use equalTo(0)
I'm not sure what this one is going to do here, it's better to just use count.get() without Matchers.
@dmzaytsev let's call it bytes for clarity.
this should be final
Silent failing
possible NPE? fValue is null
possible NPE? fValue is @Nullable so no need to check for null.
possible NPE? Maybe it should be final.
What is the reasoning for having the file descriptor leak here? The example below does not reproduce the issue, but in the test cases, it's a bad idea to let the trace be aborted.
shouldn't the file get deleted too?
shouldn't the file get deleted here?
Will need to be changed to...
Will need to be reset on the action when it's being converted
Will need to be...
Please use static import.
Please use static import for simplifying the code.
Please use static import for simplifying the expression.
I think it appears that Parser.xmlParser().parseInput could be made into a static method somewhere, perhaps in CommandStringBuilder.
I think it appears that Parser.xmlParser().parseInput could be made into a static field.
I think it appears that Parser.xmlParser().parseInput could be made into a static method somewhere, perhaps in the tests if needed.
You are not supposed to have any fields here.
You are not supposed to have any fields in the class, not in the statistics.
You are not supposed to have any fields here. If not, please change to String.format().
You could do the same thing by doing @Test(expected =...), see above.
You could do the same thing by doing @Test(expected = BluefloodServiceStarterException.class) I would say checking for exit code equals -1 is not that important here.
You could do the same thing by doing @Test(expected=...), see above.
Is there a reason not to use DefaultUpdaterIssuesSelector at the top?
Is there a reason not to use DefaultUpdaterIssuesSelector at the top? I might be wrong though...
Is there a reason to be not using DefaultUpdaterIssuesSelector at all? I might be wrong though...
Should those hashcodes be hardcoded? They depend on HashCodeBuilder.toHashCode() implementation.
Should those hashcodes be hardcoded? They depend on HashCodeBuilder.toHashCode().
Should those hashcodes be hardcoded? They depend on HashCodeBuilder#toHashCode() implementation.
Could you add a log message here for easier debugging?
Could you please add a log message here for the rare case when skipEvent is called.
Could you please add a log message here for the rare event that we're about to skip event?
Cache this value.
final InsightsLastSeen
final
don't you need to check for null here?
don't we need this one off?
don't we need to do this one off?
Use try-with-resources?
Use try-with-resources.
Use try-with-resources, to remove finally()
We could add an assertion that the value of this object is same as the expectedNumberOfAllowedRequests value. That way we would not need to test multiple methods.
We could add an assertion that the value of this object is same as the expectedNumberOfAllowedRequests value. That way we would not have to test that we're using Hamcrest against the builder.
We could add an assertion that the value of this object is different than the expectedNumberOfAllowedRequests value.
suggestion return "Abort and restart the build";
suggestion return "Abort and restart the build");
Make it localizable?
That's not really a good idea, but should this be: autopacklimit = repo.getObjectDatabase().getPacks().size() > autopacklimit?
That's still a bit strange. Can't you just check the value of the constant here and use that?
The value should be >=.
externalize
externalize.
not needed
This is where that clear method <code>getMockStudy()</code> can be called. This is what is doing. We also have to handle the case where the original study is not present.
This is where that clear method <code>getMockStudy()</code> can be called. This is what is meant to be. We also have to handle the possibility of the study not being present, since this won't be called more than once.
This is where that clear method <code>getMockStudy()</code> can be called. This is what is meant to be. We also have to handle the case where the original study is not present.
Minor: Should this test be changed to check the exception message?
Minor: also verify the exception message?
Minor: also verify the exception message, as expected.
Put.map(fieldType -> fieldType.toMap()) in a local variable
Put.map(fieldType -> fieldType.toMap())
Put.map after the return statement
why not just return?
why not use Collections.emptyMap()?
why not use Collections.emptySet()?
suggestion RestRule not found = ruleTransform.appToRest(input, user);
getRuleInternal returns a RestRule instance, so you can use that instead of throwing an exception.
getRuleInternal returns a RestRule instance, so you can use that instead of throwing NotFoundException.
After giving it some thoughts, can you please choose a case where it returns void and throw an exception here?
After giving it some thoughts, can you please choose a case where it returns void?
After giving it some thoughts, can you please choose a case where it returns void and throw an exception here? When the consumer fails, it looks like this exception should be thrown.
@Override public String toString() { return getName(); }
@Override public String toString() { return getName(); } }
@Override public String toString() { return getName(); } };
return Status.BACKUP_FAILED.equals(status) || Status.RESTORE_FAILED.equals(status);
I think this should be: return Status.BACKUP_FAILED.equals(status) || Status.RESTORE_FAILED.equals(status);
return Status.BACKUP_FAILED.equals(status) || Status.RESTORE_FAILED.equals(status);?
should we just check that the size is 32 or > 0?
should we just check that the size is 32 or not?
should we just check that the size is 32 or > 1?
Wouldn't it be expectThrows(null, runnable)?
Wouldn't it be expectThrows(null, runnable) instead?
How the change of this method is actually superfluous?
missing @since 204 None
missing @since 204 status.
missing @since tag
Consider using query(Query.getId())
Consider using queryFactory.getTuple2E1ListRaw instead of parsing Long
Consider using queryFactory.getTuple2E1ListRaw instead of converting to Long
return unitFrom * unitFrom.convert(1, unitTo);
return unitFrom * unitFrom.convert(1, unitFrom);
1D
use ShellIsAvailable
use ShellIsAvailable(this)
use ShellIsAvailable (this is not safe)
throws
nit: throws
can this be @Override
write stream
write lock?
write stream()
Please use warnf instead of error.
Please use warnf instead of info.
Please use warnf for logging.
URL Encode
url =
URL is not hardcoded.
Very minor: this log line should be adjustedValue = cachedAdjustedValue.get();
Very minor: this could be adjustedValue = cachedAdjustedValue.get();
How about changing this to debug? it doesn't log it. (we do not know how to use it in the rest of the file)
OPAQUE
I don't believe it should be OPAY_ON_DEMAND. Maybe you should replace it with something like OPAY_ON_DEMAND.flush()
I don't believe it should be OPAY_ON_DEMAND. Maybe you should replace it with something like OPAY_ON_DEMAND.
I think this is wrong. It should be FROM_100_TO_23.
I wonder if we should just use the builtInMetricsVersion.FROM_100_TO_23 constant and not use it here. I can't find any references to it though.
I wonder if we should just use the builtInMetricsVersion.FROM_100_TO_23 constant and not worry about the value, right?
Could you move this into the field declaration?
Can you move this into the field declaration?
Could you move this into a field?
Why not use ImmutableList.builder?
Why not use ImmutableList.copyOf?
Why private? There is a single collection.
I'm really not sure if there is a reason to have a DoubleStream.of(elements).
I'm on purpose to have a cache on size, so I'm not sure if it's safe to cache.
I'm on purpose to have a cache on size, so I'm not sure it's safe to cache.
The (post) syntax is more robust (you can actually check that the options are passed, if you want to change the signature of the test method).
The (post) syntax is more readable (I could also use [this](<LINK_0>
The (post) syntax is more robust (you can also use [.id]/ for the build)
Why are you blocking here? this should be async throughout.
Why are you blocking this? this should be async throughout.
Why are you blocking this?
Yes, you can just use the ImmutableSet here.
Yes, I can't think of to work.
Yes, you can just use the constructor with a Set.
Can't we just set without compare?
Can't we just set without thread synchronization?
Can we just set without compare?
suggestion "Namespace is longer than "+ MAX_NAMESPACE_LEN+" characters");
suggestion "Namespace is longer than "+MAX_NAMESPACE_LEN+" characters");
suggestion "Namespace is longer than "+ MAX_NAMESPACE_LEN +" characters");
Debug code?
This log statement should be removed.
This log statement can be removed.
It's odd that we're creating a new object array for each test, and then testing that the ColumnTypeResolver resolves it to a well-known class. I would suggest renaming the test class to something like "patientenfederatie-nederland", and then test cases in the Uppercase FEEL.
It's odd that we're creating a new object array for each test, and then testing that the ColumnTypeResolver resolves it to a well-known class. I would suggest renaming the test class to something like "patientenfederatie-nederland", and then test cases in the GroupsAdapterTest class.
It's odd that we're creating a new object array for each test, but the test should use Arrays.asList()
The code here should be replaced by: Ref tag = getRepository().getRefDatabase().getRefDatabase().exactRef(R_TAGS + tagName);
The code here should be replaced by: Ref tag = getRepository().getRefDatabase().getRefDatabase().getRefDatabase().exactRef(R_TAGS + tagName);
The code here should be replaced by: Ref tag = getRepository().getRefDatabase().getRefDatabase().getRefDatabase().getRefDatabase().exactRef(R_TAGS + tagName);
Map.get can return null.
nit: can we just return previousValue?
nit: can we just return previousValue here?
There do not be formatting rules in the project.
There should be spaces around the assignment of currVal.
There should be spaces around the!=
suggestion return Objects.equals(this.getClass(), o.getClass()); The reason for this suggestion in general is that it handles nulls properly, e.g. if this.getClass() returns null the previous implementation would crash
suggestion return Objects.equals(this.getClass(), o.getClass()); The reason for this suggestion in general is that it handles nulls properly, e.g. if this.getClass() returns false, the implementation of equals method would return true.
suggestion return Objects.equals(this.getClass(), o.getClass()); The reason for this suggestion in general is that it handles nulls properly, e.g. if this.getClass() returns false, the implementation of equals method will return true.
suggestion timer = getMetrics().timer("key-create");
So, we should skip this timer here?
suggestion timer = getMetrics().timer("key-create"));
Is this really needed? Maybe this should already be removed for efficiency reasons (but I don't know how often this method is actually used...)
Is this really needed? Maybe this should already happen in the first place...
Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know what the performance impact would be of doing).
is there any reason why this method should be public?
is there any reason why this is not public?
is there any reason for not using this method as well?
This is probably a LAUNCHING constant, but maybe pass it into the tag param here. It's not really required for any usePidFile.
This is probably a LAUNCHING constant, but maybe pass it into the tag param here. It's not really required for the usePidFile.
This is probably a LAUNCHING constant, but maybe pass it into the tag if you want.
I don't think you need to check if the view is empty. Not sure if this is the case, but I think the previous implementation was more explicit.
I don't think you need to check if the view is empty. Not sure if the list is empty, but I think the previous implementation was more explicit.
I don't think you need to check if the view is empty. Not sure if the list is empty, but I think the previous code was more readable.
There should be a message that will be shown in the UI
There should be a message here for which it failed to create snapshot.
There should be a message here for which it failed to create snapshot
Shouldn't it be just columnIt.close() here and below?
Shouldn't it be just columnIt.close() here?
Shouldn't it be just columnIt.close() here as well?
I think this can be simplified to java return (o == null ||!getClass().isAssignableFrom(o.getClass()))
I think this can be simplified to java return (o == null ||!getClass().isAssignableFrom(o.getClass())) &&
please use braces
You can use:.result(true).timeUTC(DateTime.now().toInstant().atOffset(oneOffset.UTC));
You can use:.result(true).timeUTC(DateTimeUtils.nowoneOffset.UTC).toInstant().atOffset(oneOffset.UTC));
You can use:.result(true).timeUTC(DateTimeUtils.nowoneOffset.UTC).toInstant().atOffset(oneOffset.UTC)
It seems that you are making the constructor deprecated, but you should use that to be consistent with the other two in this class.
It seems that you are making the constructor deprecated, but you should use that to be consistent with the other methods in this class.
It seems that you are making the constructor deprecated, but you should not use the new constructor.
return StreamletUtils.require(false, "build() in StreamletShadow should NOT be invoked");
return StreamletUtils.require(false, "build() in StreamletShadow should not be invoked");
return StreamletUtils.require(false, "build() in StreamletShadow should NOT be invoked")
Now that we have the number of filters, we can use the count for filters.
Now that we have the number of filters, we can use the number of filters.
we can make the condition more clear.
This should not be enabled. Pull this up to the constructor and store it in a field
Is it always worth it?
This should never be true. Pull it out.
Better to use Collections.singletonList(files) here.
.asList(files) is generally more efficient.
Collections.singletonList(files) is better.
@ivandalbosco You can combine these two lines with && PURE_FUNCTIONS.contains(name).
@ivandalbosco You can replace it with: context().newIssue(this, issueLocation,...)
@ivandalbosco You can combine these two lines with && PURE_FUNCTIONS.contains(name)
I don't think this condition is needed here
I don't think this condition is needed here - you're already doing that in line 71.
I don't think this condition is needed here - you're checking the status of the service that is supposed to be HTTP or not.
Can be NullPointerException
Can be better.
Can be NullPointerException.
The order of the arguments is reversed - it should be assertEquals(expected, result)
The order of the arguments is reversed - it should be assertEquals(expected, actual)
The order of the arguments is reversed - it should be assertEquals("%", result);
would be nice to have the separator in the message here ("Storage Engine and Shutdown Failed - Everything : ")
would be nice to have the separator added here instead of adding the keys to the string.
should not the empty string be added?
requireNonNull
suggestion this(newSimpleAggregatedMemoryContext());
requireNonNull?
I think these should be constants
Should be "Lambda vars"
Should be "Lambda vars".
Are these strings not already defined in string resources?
Are these all strings used for consistency?
Are there any exceptions that want to be caught?
We might want to do a logger.info here too.
We might want to do a logger.debug here too.
Not sure why the system out.
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we can say "don't do that."
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same error, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we can say "don't do that."
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same string. Merge semantics would be preferable. On the other hand we can say "don't do that."
Just return the result of findFirst().orElse(false);
Just return the result of findFirst and re-use it later.
why not returning the boolean?
should this be private?
why is this private?
why is this method public?
Probably should use org.jboss.weld.environment.se.Assert.fail or org.eclipse.wst.core.runtime.Assert.fail by default.
Probably should use org.jboss.weld.environment.se.Assert.fail or org.eclipse.wst.core.runtime.Assert.fail by default
Probably should be wrapped in a more descriptive message.
This should be private, and the constructor can be private.
This should be private, and the constructor can be protected.
This should be private, and the constructor should be private.
No need for Optional here.
You can use Optional.ofNullable here.
Instead of using Optional here, may be use an automatic parameter parameter in the requestResolver<ServletRequestAttributes>?
ServerSocket implements AutoCloseable which means you can use try (ServerSocket socket =...) {} might be better?
ServerSocket implements AutoCloseable which means you can use try(ServerSocket socket =...) {} might be better?
ServerSocket implements AutoClosable, so try (ServerSocket socket =...) {} might be stylistically better
I do not understand why we need to catch this exception, is there a more specific way to handle it?
I do not understand why we need to catch this exception, is there a more specific exception we can catch?
I do not understand why we need to catch this exception, if it is a method that throws the exception, the method can be named.
This will break for projects that are not in the list. It is not valid for projects to contain multiple projects.
This will break for projects that are not in the list.
This will break for projects that are not in the list. It is not valid to check for a project type.
version can't be null
version can be null
guava
Double check before reading. I would reserve BRE for exceptions that will ultimately return false if it is not true here or not. Here and elsewhere.
Double check?
Double check before reading. I would reserve ipEntry for methods.
method name can be absolutePath
method name should be absolutePath
method name should be escaped
use waitForExecute() instead?
use waitForExecute()?
use super.mConnectionFailed();
Does this test really need to be public?
Does this test really matter? If not, I'd prefer to use isEmpty()
Does this test really matter?
else not needed
else not required
seems like you can remove this.
Utils.validateArg
Is this constructor used?
Is this constructor used? 'validate' is redundant.
maybe 0,8%?
not insecure - but can be used here.
not insecure - but can be used.
this method can be private
this method can be static
this method can be private.
Can this be null?
Can this be null? (the input is null)
Can this be null? Either way, use a self-contained.
but this doesnt solve the issue, even if events are disabled in the config eventsRefresher will be created because it will pass the first 'if' statement (above) why not adding the check for events to the line above?
no need for the extra '()' and missing space before '{'
but this doesnt solve the issue, even if the events are disabled in the config eventsRefresher will be created because it will pass the first 'if' statement
why is this needed?
Utils.copy
Utils.createTempDirectory
Safer to check if entry already exists for the given table. If yes, re-use else put new one.
Safer to check if entry already exists for dbName exists. If yes, re-use else put new one.
Safer to check if entry already exists for SafeSink. If yes, re-use else put new one.
I wouldn't replace this with return new QuantityType<>("0")
I wouldn't replace this with return new QuantityType<>("0");();
I wouldn't replace this with return new QuantityType<>("0");
It would be better if rewrite this to use [HttpHeaders constant](<LINK_0>
[optional] Consider using a [appendQueryStringTo](<LINK_0> instead of the URLClassLoader constructor.
[optional] Consider using a [appendQueryStringTo](<LINK_0> instead of rewriting this manually.
to be aware, maybe we can rewrite this code to use the new Indexed<String>((row, Indexed<String> encodings) method
to be aware, maybe we can rewrite this code to use the new Indexed<String>(int) method
to be aware that checkstyle is not happy
Suggestion: Would you please extract the common logic in this method? Either we could do the same in both places, or we could make it clearer.
Suggestion: Would you please extract the common logic in this method? Either we could do the same in both places, or separate methods.
Suggestion: Would you please extract the common logic in this method? Either we could do the same in both places, or we could make it more readable.
The exception is only re-thrown if the error is lost. It's better to suppress it, not suppress it.
The exception is only re-thrown if the exception is lost. It's better to suppress it here.
The exception is only re-thrown if the exception is lost. It's better to suppress it for now.
If we want to be sure that the permission level property is not set, we should be set to this.permissionLevel so that the first permission is set.
Should we be able to change permissions in this method after throwing the exception if the permission level property is not set?
If we want to be sure that the permission level property is not set, we should be set to this.permissionLevel.value.
isVerifiable?
isVerifiable seems redundant
isVerifiable seems unnecessary
TODO found
TODO and remove TODO
TODO
Is this the right way to do this? Assertions.assertThat(slave.getLog().contains(message))
Is this the right way to do this? yesterday.
Is this the right way to do this? Assertions.assertSo
All these should be ConfigurationException
All these should be NonNull
All these methods should be private.
suggestion assertEquals("The correct page range is from 0 to 0 to 0 to 0 for the given page size", response.getStatusCode());
suggestion assertEquals("The correct page range is from 0 to 0 to 0 for the given page size", response.getStatusCode());
suggestion assertEquals("The correct page range is from 0 to 0 to 0 to 0 to 0 for the given page size", response);
you can extract configuration.get("refresh") into local variable to avoid duplication
you can extract configuration.get("refresh") into local variable and reuse it in the method below
you can extract configuration.get("refresh") into local variable to avoid parsing it twice.
Why do we need to write this test? I don't think we should just assert that mae is assigned.
Why do we need to write this test? I don't think we need to write a different test case.
Why do we need to write this test? I don't think we need to write a new test.
Shouldn't we return null here, and in other places?
This is returning null, so the value of the method should be changed to returning null.
Shouldn't we return null here? :)
It's better to log the exception instead of the message.
Another log message, can you please move it to the new exception instead of String.format?
Another log message, can you please move it to the new one?
Could you rename this to indicate that this is a Context?
Do you need to reset this?
Could you rename this to indicate that this is a Presenter?
suggestion assertErrorEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion assertErrorEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE());
suggestion assertErrorEventExecutionSet(emptySub process.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
This looks weird, I don't think we should get this exception. It looks like we're catching the exception and just returning something.
This looks weird, it looks like we don't expect the element but the exception is thrown. I think we should have a failExceptionally call instead.
This looks weird, it looks like we don't expect the element but the exception is thrown. I think we should have a failExceptionally call on line 66.
I think this should be a constant
I would like to see this used anywhere, so this might be just moved to a constant
I would like to see this used anywhere, like this.
Same here, this method should be private
Same here, this method should be a value that is passed to the constructor.
Same here, this method name looks a lot better.
This should also define a method for the old methods.
This should also define a map.
This should also define a method for the old methods, right?
This should be public
Lots of new methods, are they tested?
Lots of public methods should be package protected.
Do we need a builder for the various constructors?
The builder pattern is normally used by the other constructor, but in this case, it is usually better to make the constructors private and public.
The builder pattern is normally used by the other constructor, but in this case, it is usually better to keep the consistency between the constructors.
This could be simplified to a single return statement
This could be simplified to a single return statement.
This could be final
rename to signature
rename to result
rename to definition
I think this should be.withRel("related")
Instead of this if statement, I think it would be better to have a setter for the title.
Instead of this and the withRel("related") call, I think it would be better to have a setter for it.
Format the string in strings.xml file can be removed.
Format the strings.xml file can be removed.
Needs a null check for App.getActivity()!= null
This test doesn't seem to verify that the returned status CREATED is Status.CREATED
This test doesn't seem to verify that the returned status CREATED is FAILED.
This test doesn't seem to verify that the status CREATED is returned.
Can you please extract this into a method and reuse it in both tests?
Can you please extract this into a method and reuse it in the test?
Can you please extract this into a method and reuse it?
Shall we change the variable name as well?
Shall we change the variable name as well? As is, it's not a particularly cryptic error message.
Shall we change the variable name as well? As is, it doesn't look like the notification is formatted incorrectly.
This data has to include 'long jobIdSubSets' in front. The reason is that the loop occurred when we have a conflict. You could already include a new line after the loop.
This data has to include 'long jobIdSubSets' in front. The reason is that the loop occurred when we have a conflict. You could already include a new boolean into the loop to indicate if this data is present.
This data has to include 'long jobIdSubSets' in front. The reason is that the loop occurred when we have a conflict. You could already include a new boolean into the loop to indicate if this data is present, or if it is not a long often.
Can we simplify these two lines?
Can we simplify these two lines to: java return getCachedBytes(requestVersion);
Can we simplify these two lines to just java return getCachedBytes()?
why you remove client? Please remove client.close()
why you remove client?
Why you remove client? Please remove client.close()
Why not have this in the setup() method?
Why not have this in the AddNetworksCommand?
Why isn't this protected like in the master?
I feel like this should be just something like "return gov.hhs.Mhinc.myStatic" or similar
I feel like this should be just something like "return gov.hhs.Mhinc.... place where we have to check this is...
I feel like this should be just something like "return gov.hhs.Mhinc.... place where we have to check if this is relevant
The catch block would be already visible to the caller, so if localSegments was added to the segmentsLost and continue, it would be better to make it clear that it was not necessary.
The catch block would be already visible to the caller.
The catch block would be already visible to the caller, right?
Better to use Collections.singletonList rather than guava for this.
Collections.singletonList
Better to use ImmutableList.of rather than guava for this.
Suggestion: Should return something like this: @Override public void setSpmMap(String spId, Host host) { if (spId == null) { map.put(spId, host); } else { // update the map } }
Suggestion: Should return something like this: public void setSpmMap(String spId, Host host) { if (spId == null) { return; } else { // update } }
Should return something like this, not void.
As I understand, this constructor should also require some action, not set it with all parameters.
As I understand, this constructor should also have getter for some field
As I understand, this constructor should also require some action, not set it via the default.
This method is called in two places. I'd prefer making this method private, and have it be private.
This method is called in two places. I'd prefer making this method private, and have it be private
This method is called in two places. I'd prefer making this method private, and have a separate method for it.
Please use Collections.unmodifiableList here or other similar places.
Please use Collections.unmodifiableList here.
Please use diamond operator.
the result of this is : String.format("[\\x0000-\\x1F\\x7F]" )
the result of this is : String.format("[\\x0000-\\x1F\\x7F]" ); right?
the result of this is : <LINK_0> so we should remove the line above
I think i=1 should be at the end of the line, otherwise the default is "endfor".
I think i=1 should be part of the "for" style, not the "for".
I think i=1 should be at the end of the line, otherwise the default is 0
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
You should check whether the type is assignable in all cases. Just, if the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class), and when expecting it to be checked.
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Please use our self constructor (I also saw this several times).
Please use our self-defined constant for this.
I would prefer to have a insert and the details as parameter to this dao call. Also, it does not need to be protected against the public API.
I would prefer to have a insert and the details as parameter to this dao call. Also, it does not need to be public.
I would prefer to have this constructor private or protected. This way it is free to use the public API as well.
I think "saved search" is not necessary, as it's already loaded in the DB.
I think "saved search" is not necessary, as it's already an instance variable defined in BaseContext.
I think "saved search" is not necessary, could be made more clear to call it rather than "saved search"
Can be replaced by: return (null!= rhsQualifiedName) && resolvedNamespace.startsWith(node.getQualifiedName()))
Can be replaced by the single line return (null!= rhsQualifiedName) && resolvedNamespace.startsWith(node.getQualifiedName()))
Can be replaced by the single line return (null!= rhsQualifiedName) && resolvedNamespace.startsWith(node.getQualifiedName());
Why is protected?
Why is public?
Why is private?
To be consistent with the rest of the class, I suggest to revert back to the old style. Not sure if we want to since it is a connection but it is not.
To be consistent with the rest of the class, I suggest to revert back to the old style. Not sure if we want to since it is a connection but it is not (unclear) sake of consistency.
To be consistent with the rest of the class, I suggest to revert back to the old style. Not sure if we want to since it is a connection but it is not (unclear) sake.
Could we return Locale.forLanguageTag("en-GB").toLanguageTag(); instead of relying on defaultBrowserLanguage to be null?
Could we return Locale.forLanguageTag("en-GB").toLanguageTag()); instead of relying on defaultBrowserLanguage to be null?
Could we return Locale.forLanguageTag("en-GB").toLanguageTag(); instead of relying on defaultBrowserLanguage to stay null?
I don't think it's a good idea to use "" instead.
I don't think it's a good idea to use "" instead of null, but I would just use "" to match the style
I don't think it's a good idea to use "" instead
I think it would be better to cache the results of PARSED_SQL_CACHE as is if map is not cached.
I think it would be better to cache the results of PARSED_SQL_CACHE as is not used anywhere. This is used only in this class.
I think it would be better to cache the results of PARSED_SQL_CACHE.get(sql, ctx) and then parse to that map.
Will the parameters need to be _public_?
Will the parameters need to be _public_?
Will the parameters be _public_?
Move this to loadRootFolder
Don't we want to load the folder at all?
Don't we want to load the folder at the end of things?
I think this can be replaced with java return subject!= null? subject.getUserName() : nameIfNoUser;
I think this can be replaced with java return subject.getUserName();
This code is very hard to read. I think it would be better to have a variable for the subject.getUserName()
If you want to store this in the Config class, then please use div.getDescription() instead of this param.
If you want to store this in the Config class, then please use div.getDescription() instead. This way the code is simple.
If you want to store this in the Config class, then please use div.getDescription() instead. This way div.getDescription() is simple.
judgmentSearchResult.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgmentSearchResult.getJudges()
nit: judgmentSearchResult.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgmentSearchResult.getJudges()
judgmentSearchResult.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgmentSearchResult.getJudges().stream()
Why do you return a Principal here?
What is this supposed to be used?
Why is this return true?
This optimize method is not needed anymore.
This optimize method is called only in the postBuildIndex() method. This check should be moved to above.
This optimize method is called only in the postBuildIndex() method. This should be updated to use the actual start time.
What if type == null? DefaultFileOperations.INSTANCE : null?
What if type == FileOperations.INSTANCE?
What if type == FileOperations.INSTANCE? DefaultFileOperations.INSTANCE : null?
Why "Whatever" here, is this a left over, or final?
This is a left over, but final.
Why public?
suggestion throw new IllegalDataException("This operation is not implemented.");
suggestion throw new IllegalDataException("This operation is not supported.");
Spacing is off here, Ctrl+Shift+F this method is missing
What if AccountService is closed?
What will happen if the account name is null?
What is the purpose of this exception?
i think this might need to encdoe the name and bitmap type too.
I think this might need to encdoe the name and bitmap type too.
i think this might need to encdoe the string too.
Log the IOException here
Log the IOException here?
Log the IOException?
Why is this final?
please send this as a separate PR
please send the Telephism directly to the diver
When using a byte[] buffer, I believe we need to capture the returned byte count because it will likely be less than the full array on the last read. As in: int byteCount = 0; while ((byteCount = in.read(charArray)!= -1) { byte[] byteArray = new String(charArray).getBytes(StandardCharsets.UTF_8); out.write(byteArray, 0, byteCount); }
When using a byte[] buffer, I believe we need to capture the returned byte count because it will likely be less than the full array on the last read. As in: int byteCount = 0; while ((byteCount = in.read(charArray)!= -1) { byte[] byteArray = new String(charArray).getBytes(StandardCharsets.UTF_8); out.write(byteArray); }
When using a byte[] buffer, I believe we need to capture the returned byte count because it will likely be less than the full array on the last read. As in: int byteCount = 0; while ((byteCount = in.read(charArray)!= -1) { byte[] byteArray = new String(charArray) at the end; byte[] res = new char[byteCount]; out.write(byteArray, res); }
rename to isSimilarMethod
rename to useEsInputPlugin
rename to useEsInputClass
Use assertFalse()?
Use Stray empty line before this
Use assertFalse()
I think it's better to use queryString(timestamp, key) instead of query, it is not needed. Also, the logic already returns the value, not only the timestamp.
I think it's better to use queryString(timestamp, key) instead of query, it is not needed. Also, the logic already returns the value, not only the query.
I think it's better to use queryString(timestamp, key) instead of query, it is not a huge performance issue. Also, the logic should be inside the if statement
This should be: if (!(c instanceof RevCommit)) { RevObject c = super.parseAny(id); if (c instanceof RevCommit) { throw new IncorrectObjectTypeException(id.toObjectId(), Constants.TYPE_COMMIT); } return c;
This should be: if (!(c instanceof RevCommit)) { initializeShallowCommits(); }
This should be: if (!(c instanceof RevCommit)) { initializeShallowCommits(); } Same goes for the other parse* methods.
Throw the proper exception if something is not supported: - NullPointerException if frameID < 0 or if frameID > 255.
Throw the proper exception if something is not supported: - NullPointerException if frameID == null or frameID == null. - IllegalArgumentException if frameID < 0 or if frameID > 255.
Throw the proper exception if something is not supported: - NullPointerException if frameID < 0 or if frameID > 255. - IllegalArgumentException if frameID < 0 or if frameID > 255
Same as above for otherNonCodedConceptUuid
same as above for otherNonCodedConceptUuid
Same here for otherNonCodedConceptUuid
I guess that this will only cause machinesToTearDown to throw an exception
I guess that this will only cause machinesToTearDown to fail because of an exception
I guess that this will only cause machinesToTearDown to throw an exception.
Can we check that syncMode and mapperSyncMode are non-null
Can we check that syncMode and mapperSyncMode are null?
Can we check that syncMode and mapperSyncMode are not null?
Should be "Optaplanner".
Does this mean we can use the existing planner even if we are not returning null?
Should be "Optaplanner"
MemStore is used for tests, so we need to implement it.
UnsupportedOperationException?
UnsupportedOperationException
Add slotName as argument to waitForVideoStart
Add slotName as argument to LogMethod.
The method name should be in a different patch.
You don't need to call.getValue() here, just return it directly.
You don't need to call.getValue() here, just use the value from the API and leave it at that.
You can invoke the API and leave it at that.
Pull "cache" into a static final field to avoid repetition?
Do we want to configure an empty string here?
Pull "cache" into a static final field to avoid expensive expensive lookups.
I would prefer if you change it to return Optional.ofNullable(FrameworkUtil.getBundle(getClass())) since that is always an Optional.
I would prefer if you use Optional.ofNullable instead of Optional.ofNullable
I would prefer if you change it to return an Optional instead of an empty Optional.
We should have static import for these.
we should have static import for these
we should have static import for these.
This is not executed for FP, as it's driving the analysis.
This is not executed.
Let's catch only the RuntimeException here.
hope you know the difference between this change and the previous commit?
hope you know the difference between this change and the other patch?
hope you know the diff between ceilingKey() and higherKey intentionally
why don't you return null?
why don't you return null as a default?
why don't you return null on the key?
I think we should be checking the path.length == walker.getRawPath() here. It should not be possible to have a null length check here.
I think we should be checking the path.length == walker.getRawPath().length. This should be done separately.
I think we should be checking the path.length == walker.getRawPath().length. This is not going to work.
This should not be registered on an HC.
This handler should not be registered on an HC.
This should be registered on an HC.
does this need to be public?
It may be safer to set 'true' to 'false' in this case
It may be safer to set 'true' to false in this case
The IF clause is not needed and **else if** is only needed.
The IF clause is not needed and **else if** clause.
The IF clause is not necessary.
The second parameter can be ignored.
The second parameter could be ignored.
The second parameter could be Optional.empty().
This should be package private. Also it's not used outside the package
This should be package private.
This isn't necessary now.
Should we remove this check and/or let the thread do the shutdown?
Should we remove this check and/or let the thread do the shutdown() call?
Should we remove this check and/or let the thread pool rename?
I think these should be package protected because we don't want people to use it.
I think these should be package protected.
I think this should be protected.
It would be better to log an error message in this case.
It would be better to log an error here.
It would be better to log an error message in this log.
+ desc
return new ArrayList<>(getDescription());
return new UnimplementedException();
any reason for the double slashes here?
any reason for the double slashes here? I think it's a bit confusing to me.
any reason for the file path?
safeName -> safeNull
safeName -> shouldEcoreOperation.getName
safeName -> shouldEcoreOperation
LexoNumericComparator() can be used here
LexoNumericComparator is part of the public API, so we can make it static.
LexoNumericComparator() can be used here.
What happens if someone calls stop on a lock?
What is the purpose of this synchronization?
What is the purpose of this lock?
Print checkpointId, Partition: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index:
Print checkpointId, Partition: %d, Event Index: %d, Partition: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %
Print checkpointId, Partition: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Index: %d, Event Partition:
This should becases/EmptyCase.bpmn2
This should becases/EmptyCase.bpmn2");.
This should becases/EmptyCase.bpmn2?
Style-nit: PublicKey should be declared as private (PublicKey) and not public.
Style-nit: PublicKey should be initialized with the default value. The default should be false.
Style-nit: I'd have implemented this with two-space indents.
There's a strange way to make the call to super.merge(other), since this in the constructor is the only other call to merge.
There's a lot of copy-paste code here
Nit: Could you add braces here since we're touching this code?
Add a message to the assertion.
Add a message that says as well as not null.
Add a message to the assertion?
...and setAdviceChain(Objects.asList(adviceChain))
what is the reason for using Arrays.asList()?
what is the reason for using Arrays.asList()?
please reuse the constant
please reuse the getResourceName method
please reuse the local variable
It looks like a paragraph and an empty line should be removed. I think it can be removed.
It looks like a paragraph and an empty line should be removed. If so, consider adding an assertion for that.
It looks like a paragraph and an empty line should be removed. If so, consider adding an assert for that.
@eg04lt3r we should use here method for such a method, something like this: @Override public void accept(final Socket socket) throws IOException { if (this.origin.matches()) { // Ignore } }
@eg04lt3r we should use here method for such a constant, like MAXIMUM_TIMEOUT.NO_TIMEOUT
@eg04lt3r we should use here method for such a constant, like MAXIMUM_TIMEOUT.NO_TIMEOUT which is a constant in this class
Minor: This is not thread safe. There should be a cache.put().
Minor: This is not thread safe. There is a cache..
missing space after =
please rename to failedVolumeIds
please add final
please add final modifier
This should be "for (Action action : failedActions)"
This should be done in a for-each loop.
This should be "for (Action action : failedActions.values())"
We should probably remove this constructor and make it package private.
Can you please explain why we still need this constructor?
We should probably remove this constructor and make it package protected.
I'm not sure how this should be displayed in the UI.
I'm not sure how this should be translated, but if it does, it's still a common status so should be "Run Status".
I'm not sure how this should be translated, but if it does, it's still a common status so should be a FAILED like "unknown".
This seems to be the wrong thing to me. It should be NONE, not NONE.
This seems to be the wrong thing to me. It should be NONE, not true.
This seems to be the wrong thing to me. It should be NONE, not true if the task has no effect.
nit: suggestion this.inputOperators = graphSpec.getInputOperators();
nit: fluent API would be nice to have a builder for this: java this(inputOperators, graphSpec.getInputOperators()); this.outputOperators = graphSpec.getInputOperators();
nit: fluent API would be nice (no need to have a builder)
![MAJOR](<LINK_0> Remove this unused method parameter(s) between the methods. [![rule](<LINK_1>](<LINK_2>
Don't use a constant for this.
![MAJOR](<LINK_0> Remove this unused method parameter(s)
o
you mean p
o?
We can also validate the cluster name?
We can use the same pattern as the other assertThat() checks.
Null?
Please add cmd.getNetwork() to the log message to assist with operational debugging.
Please provide the exception to assist with operational debugging.
Please add identifying about the Nuage VSP device that failed.
Don't forget to update this
Don't forget to update the refund_id here too
Don't forget to update refund_id here too
suggestion return index.read();
suggestion @NonNull InputStream stream = index.read();
extra line
Don't create new array. Use checkIfBrickAtPositionShowsString(String, String) instead.
Don't create new line.
Don't understand why you have to add the check here.
Please check that os3Server is null and mockServerType is not set.
Please check that os3Server is not null and mockServerType is not set.
Please check for empty array.
This is a stylistic nitpicking: please revert this change and other similar lines in the PR #641
This is a stylistic nitpicking: please revert this change and other similar lines that follow the existing code.
This is a stylistic nitpicking: please revert this change and other similar lines in the PR #127
Maybe pull this out into a constant?
Maybe log the error message here too?
Maybe return null?
Same here regarding the messages.
Same here regarding the text.
Same here regarding the AssertJ
Can be moved to inside the if block.
Can be removed.
Can be moved to the inside the if block.
You can make this method private since it's only used by this class.
You can make this method private since it's only used by this class
You can make this method private since it's only called by this class.
since capacity is not a real capacity you can use a LinkedList
remove
remove this
Diff should be private.
Diff should be private, not public.
Diff should be protected.
Is this case really needed?
Is this case because there is no rollback?
Is this case really intended?
This should be done in the constructor.
This should be done once in the constructor.
This should be done in the constructor or in a separate class.
Assert.notNull()?
Assert.notNull()
Unpublished
If we are not using i for the annotation's type, then we can remove the public modifier.
If we are the first 'for' loop we should account for the annotation's length for each annotation.
If we are not using i for the annotation's type, then we can remove the public constructor.
Should this be spelled out in the loop?
This doesn't work correctly on the case where multiple files exist.
This doesn't work correctly on the case where multiple files exist, the user want to delete the file.
nit: those names are a bit lengthy, also it would be good to extract those names in a constant.
nit: those names are a bit lengthy, also it would be good to extract those into a constant.
I think those four lines could be merged into one.
java Assert.assertEquals(result, getBytes(UTF_8));
Java Charsets.UTF_8 is default charset, not a charset.
Java Charsets.UTF_8 is default charset. Please use the explicit encoding here.
Is there a reason for the default.directory_provider to be a string?
Is there a reason to explicitly define a constant and use it?
Is there a reason for this?
Can you make this method private?
I think you need to set this in the class as well.
Only this method is required
I think calling a method CheckpointFailureManager.values().iterator().next() would be more readable and concise.
I think calling a method CheckpointFailureManager.values().iterator().next() would be more readable.
I think calling a method CheckpointFailureManager.values().iterator().next() would be more readable
Here and below: public PullRequest getPullRequest(String payload, GitHub gh.class) throws IOException { return PullRequest.parseEventPayload(new StringReader(payload), _getClass()); }
Here and below: return PullRequest.getPullRequest(payload, GitHub gh.class);
Here and below: return PullRequest.getPullRequest(payload, GitHub);
Why not just: return responseTypes.stream().allMatch(s ->!s.isEmpty())?
Why not just: return responseTypes.stream().allMatch(s ->!s.isEmpty());?
Why not just: responseTypes.forEach((s) -> { if (s!= null &&!s.isEmpty()) { return false; } }
I wonder if we should do this in a different strategy. For example, a retry will wait until we're in the background thread that will be interrupted, but we're not in the state of the next request.
I wonder if we should do this in a different PR. For example, a coordinator you're already in-sync with the next request, but then the TM gets re-read of the old coordinator.
I wonder if we should do this in a different PR. For example, a coordinator you're already in-sync with the next request.
Why not return;?
Can't you return false by default?
Why not return false here as well?
Minor: Does this need to be public?
Minor: Does this need to throw a runtime exception?
Minor: make it private.
What happens if Environment.Variable is a byte array?
What happens if Environment.Variable is longer than HEAP_SIE?
What happens if Environment.Variable is longer than microseconds?
Why is this outside of the loop? Any reason we can't just do: List<Object> removed = new ArrayList<Object>(); if (getItem(i).getIdentifier().equalsIgnoreCase(event.getDiscussionThread().getIdentifier())) { discussionPostsAdapter.remove(i); }
Why is this outside of the loop? Any reason we can't just get rid of it?
Why is this outside of the loop? Any reason we can't just do it once?
ConflictException.class.getName()?
ConflictException.class.getName() would be better.
s/ex/exception
This can be declared final
This should be declared final
This doesn't seem to be needed?
CompoundInterpreter.INSTANCE.getAllNewEmtpyExpressions()?
s/At least one interpreter should be declared/creation
s. at least one interpreter should be declared
static import utf8Slice
Nit: you probably want to specify a charset (e.g. UTF-8) as it is UTF-8
Nit: static import utf8Slice
You can also verify the initialization of the UserManager.
You can also verify the initialization of the UserManager class.
suggestion User user = new User().withEmail("test@email.com");
are the sortLeftOverAgencies in fact the unsorted ones? I am wondering if there is a better name for what goes in this list
are the sortLeftOverAgencies really intended? I am wondering if there is a better name for what goes in this list
are the ordering in this list
This should use NotImplementedException instead of NotImplementedException.
This should use NotImplementedException instead of Exception.
This should use NotImplementedException instead
Is this an error condition or just timing?
assignedPartitionIds.remove(partitionIdStr)?
assignedPartitionIds.clear()?
I'm not sure if this is needed or not but it seems like the list should be created in every request.
I'm not sure if this is needed or not since the list will be created in every single request.
I'm not sure if this is needed or not but it seems like the list should be created in every single group.
dataTypesPage.disableShortcuts();
dataTypesPage.disableShortcuts(); should be called before super.onClose()
dataTypesPage.disableShortcuts(); should be called before super.onClose();
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId().toString());
suggestion info("Consistent id: " + ignite.cluster().localNode().consistentId());
@manuelplazaspalacio this class is a AutoCloseable. You can't use IOUtils.toString(this.getClass().getClassLoader().getResourceAsStream("warnings.json"))
@manuelplazaspalacio this class is a AutoCloseable. You can't use IOUtils.toString(this.getClass().getClassLoader().getResourceAsStream("warnings.json") instead.
@manuelplazaspalacio this class is a AutoCloseable. You can't use IOUtils.toString(this.getClass().getClassLoader().getResourceAsStream("warnings.json")) here.
This toString() isn't necessary. A simple toString() would be sufficient.
This toString() isn't needed, the compiler will automatically print the errors to the console.
This toString() isn't needed, the compiler will automatically print it to the console.
Consider renaming the method as well, i.e. MarkupFormatter getMarkupFormatter().
Consider renaming the method as well, i.e. MarkupFormatter
Consider renaming the field as well.
@nmirasch this one also needs to be updated to use the event.
Make the event removeDefaultFilter method synchronized
Make the event removeDefaultFilter method private
Please extract this out to a separate method.
Please extract this out to a method and make it more readable.
Please extract this out to a method.
This function should be private
This function is called from multiple places. It should be private
This function is private as it should be private
errorMsg is used in several places, I would suggest to use NLS.get("RequiredCheck.errorMsg") instead.
errorMsg is used in several places, I would suggest to use NLS.bind() here.
Objects.requireNonNull
Shouldn't this be more like "Operator is expected to be blocked"
Shouldn't this be more like "Operator is expected to be blocked"?
Shouldn't this be: java } catch (InterruptedException | ExecutionException e)?
this is what I meant. why do we need this check?
this is what is meant to do with shutdown?
this is what we meant to do, not call it removeAction
why the need to declare a var?
why the need to return -1?
why the change?
I'd prefer to keep the firstNonNull.
I'd prefer to keep the firstNonNull. It's only used for logging.
I'd prefer to keep the firstNonNull. It's only a matter of the coding style.
I think this should be a warning instead of info.
I think this should be error
I think this should be a warning
Please add @Nullable to the constructor.
Please add @Nullable to the return type
Please add @Override annotation here.
can't we use the empty string here?
can't we use the empty string in this test?
can't we use the empty string in this case?
You confused "expected" and "actual". Usually it's first "expected" then "actual". Please change, to avoid missleading Error messages" As I see it, it's in the whole test-file
I see "expected" and "actual". Usually it's first "expected" then "actual". Please change, to avoid missleading Error messages" As I see it, it's in the whole test-file
I see "expected" and "actual" in the whole test-file. Please change, to avoid missleading Error messages" As I see it, it's in the whole test-file
Need to remove codec from here too, right?
Need to remove codec from this file, right?
Need to remove codec from the file, right?
I think this whole method could be simplified to return session.isVoAdmin(voId) && session.isGroupAdmin(groupId);
I think this whole method could be simplified to return session.isVoAdmin(voId) && session.isGroupAdmin(groupId));
I think that this method could be left out of the isGroupAdmin method.
suggestion if (cacheCommand instanceof FlagAffectedCommand) {
return createRemoteInvocationContext(origin);
the method name is misleading, it's not deleting the cache command.
Instead of checking for owningElement here could we check for eContainer()? Vertex seems to me that the same check is used for owningElement.
use DiagramEventBroker.create
use DiagramEventBroker.getInstance().create
I think 0x is a valid IPv6 here
I think 0x is a valid IPv6 here.
I think 0x0 is a valid IPv6 here
there are 4 instances of stop being called. Can you use Line 124 instead?
there are two things here. If the container is unavailable you might get an NPE
Line 138 needs updating
This should also be a handlers that are added to the ordered list.
This should also be in the synchronized block
This should also be synchronized
Use.filter(Objects::nonNull) for readability.
Use.filter(Objects::nonNull) for readability
Use.filter(Objects::nonNull) so that we can remove the annotation.
You could do this in one line: return slice!= null? srcBuf.slice(srcIdx(offset), length()) : srcBuf.slice(srcIdx(offset), length());
You could do this in one line: return slice!= null? srcBuf.slice(srcIdx(offset), length()) : null;
You could do this in one line: return slice!= null? srcBuf.slice(srcIdx(offset), length()) : srcBuf.slice(srcIndex(offset), length());
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified flag, and he selects "yes" on this option?
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified flag and he selects "yes" on this option?
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified flag, and he selects "disabled" on this option?
Can you please add some docs on why this exception is thrown?
Can we not be more specific? The exception message is either a RuntimeException or a generic one
Can you please add some docs to this exception
It should be unique across maven repo. Please change it to org.openmrs:openmrs-sdk-server-{version}:1.0.0-SNAPSHOT.
It should be unique across maven repo. Please change it to org.openmrs:openmrs-sdk-server-{version}-1.0.0-SNAPSHOT.
It should be unique across maven repo. Please change it to org.openmrs:openmrs-sdk-server-{ version}:1.0.0-SNAPSHOT.
note from discussion: wdyt about calling toString() here?
note from discussion above about using enhanced for loop.
return directly
Can this be LogicalServerStateMBeanImpl.class?
Can this be LogicalServerStateMBeanImpl.class, or can the @Transactional annotation?
Can this be done in LogicalServerStateMBeanImpl?
Loud be _callToActions = callToActions;
Loud be _callToActions instead of callToActions.
I think callToActions could be a better name. It should be _callToActions.
Please bring the braces back.
Please bring the brackets back.
Please bring the braces back
ShellIsAvailable
ShellIsAvailable(this) is because ShellIsAvailable is default method available in New ShellIsAvailable
ShellIsAvailable. ShellIsAvailable
Another place where we could note that the boolean is unused.
Another place where we could note that the boolean is unused (see above) and this one will always be unused).
Another place where we could note that the boolean is unused (see above) and this one will always be initialized.
Could be final?
Could be final
This method is too complicated...
Shall we rename this to something like supportsDefaultSynapseHandler and use it in multiple places
Shall we rename this to something like supportsDefaultSynapseHandler and use it in a single call
Shall we rename this to something like supportsDefaultSynapseHandler and use it in multiple places?
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/ update pattern in child classes?
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case)
I wonder if this should be replaced with a Set too as it is not being used. Having some as many add() calls in the future, it would not be clearer to change the implementation to return a set.
I wonder if this should be replaced with a Set too as it is not being used. Having some as many add() calls in the future, it would not be necessary to add new fields if add() was replaced with a set.
I wonder if this should be replaced with a Set too as it is not being used. Having some as many add() calls in the future, it would not be clearer to change the implementation to add all of them to add.
Needs null checks
Needs a null check
Provider.requestId
suggestion Timber.w("Null formController");
suggestion Timber.v("Null formController");
I think it'd be better to make this a warn instead of a log.  verbose.
Why change this?
Why is this inline?
Why remove this?
Why are you using ipImporter.create() here?
Are you sure the relative path is allowed to be set by default?
Are you sure the relative path is allowed to be enabled programmatically?
&& apiTokenValid.equals(request.getComponentName() == null)
&& apiTokenValid.equals(request.getParameters().getRestResponse())
&& apiTokenValid.equals(request)
Here one could : case AppLanguageLookUpTable.TRADITIONAL_CHINESE_LANGUAGE_CODE:
Here one could : case AppLanguageLookupTable.TRADITIONAL_CHINESE_LANGUAGE_CODE:
Make non-static @NonNull
this test is not sufficient. You need to do something similar to a junit test that checks it.
this test is not sufficient. You need to do something similar to a junit test that checks the existence of a transaction.
this test is not sufficient. You need to do something similar to a @Before method that you can use to set the database explicitly.
These should be defined as constants.
These should be declared as constants.
These should also be declared as operation=
Should be checked just in case.
Should be checked just in case
Should be checked just for presence of a security manager
This is the replacement for [this](<LINK_0> We might want to consider --non-interactive at least.
This is the replacement for [this](<LINK_0> We might want to consider using the replacement for this.
This is the replacement for the previous line.
This doesn't seem to be backwards compatible.
This isn't now obsolete.
This doesn't seem to be backwards compatible as ctl.getRefName() should be obsolete now
@m-g-sonar you can drop this condition.
@m-g-sonar you can skip this if statement and remove the firstArg variable.
@m-g-sonar you can drop this if statement and use the  expression on the previous line.
Can you rename this method to something like setOrHideNodeActions?
Can you rename this method to showOrHideNodeActions?
Can you rename this method to something like 'EventuallyHideNodeActions' or something similar?
Received *tries* to minimize sound cleanup. <review, logic
Received *tries* is not changed. <review
Received *tries* is not changed. <review, logic
This should be final
This should be final.
This should be a IntervalListWriter.
@ekondrashev let's move this joiner logic into a private method
@ekondrashev let's move this joiner logic into a private method for readability
@ekondrashev let's move this joiner logic into the final field
This should be immutable. Same with item().
static import
static import?
No need to go through a map here.
No need to go through a map here?
Missing assert that the path comes from a Map
suggestion assertThatThrownBy(() -> ImmutableRocksDbPersistentStorageConfig.builder().storagePath(TEST_FOLDER.newFile().getAbsolutePath()).build()
nit: Assertion could be made static
nit: Assertions.assertThatThrownBy is a bad practice; better to use it.
checkNotNull?
checkNotNull()
checkNotNull() instead.
Can you make the qualifier string a constant?
Can you make the qualifier string only once in the constructor?
Can you make the qualifier string resources?
Why do you return null here? And why do you need to return an empty String?
Why do you return null here?
Why does this return null and not throw an exception?
use exot message
use exot in message
use expe
Shall we move this to a constant?
Prefer catching Exception instead of SamzaException. If any other exception is thrown, then you'll need to log the exception.
Prefer catching Exception instead of SamzaException. If any other exception is thrown, then you'll need to add a SamzaException to the map.
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i =...; if (i == -1) { return false; } mRoutes.remove(i); return true;
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i =...; if (i == -1) { return false; } mRoutes.remove(i); return false;
Suggest unindenting for clarity: if (Objects.equals(mIfaceName, route.getInterface) { return false; } int i =...; if (i == -1) { return false; } mRoutes.remove(i); return true;
@mehtyd can you explain why, maybe?
@mehx Can you explain why, maybe?
@mehturt Maybe rename this to something like isRingTimeFromWorker?
I'd prefer to make this so that we don't have to expose the API into the annotation (ie. at the moment there's not as API).
I'd prefer to make this so that we don't have to expose the API into the annotation (as we may have some option in the future).
I'd prefer to change the implementation so that we don't have to expose two different implementations.
We should throw a runtime exception here.
We're not asserting that the imported node is an instance of the configuration.
We should throw a ParserConfigurationException here.
The logger could use this pattern for logging.
The logger could use this pattern for logging. Or do you prefer that pattern for logging?
The logger could use this pattern for clarity
nit: I would prefer Jenkins.get().allItems(AbstractProject.class, i -> i instanceof TopLevelItem && this.equals(i.getAssignedLabel())))
nit: I would prefer Jenkins.get().allItems(AbstractProject.class, i -> i instanceof TopLevelItem && this.equals(i.getAssignedLabel()).
I would prefer to declare this as final and introduce a new variable to use it for declaration.
minor static import isWhitespace for readability
if you make the code more readable, please use TextUtils#isBlank here.
if you make the code more readable, please use isEmpty() instead of string.length()
I'm also wondering if we can throw an exception here? I haven't looked into the implementation yet, but there is a lot of callers. The method, how about returning an Optional<ProxyConfiguration>?
I'm also wondering if we can throw an exception here? I haven't looked into the implementation yet, but there is a lot of callers.
I'm also wondering if we can throw an exception here? I haven't looked into the implementation yet, but this looks quite a bit scary.
I think this is actually easier to read if you split the operations into two lines.
I think you should be able to use steps.stream().filter( step -> step.add(step)).forEach(this::withStep);
I think you should be able to use steps.stream().filter( step -> step.forEach(step::add); here.
Hum, it seems like the extractors should be removed from the cache now.
start and end of thing?
can be removed
It would be better to make it more efficient to compare the keys as well, i.e., compareKeys(original, marshalled)
It would be better to make it more efficient to compare the keys as well, i.e. if (isIntanceOf(originalKey)) { compareJSONObjectKey(original, marshalled); }
It would be better to make it more efficient to compare the keys as well, in case the exception was thrown.
s/n//
Why is the test for the specific flow?
Why do you need to test this?
How about returning an Optional<ImmutableFlyingData> instead?
How about returning an empty list instead?
Why absent?
suggestion PowerMockito.spy(KubernetesConfig.class);
This is the exact opposite of what the tests are verifying here?
suggestion
The rate limiter doesn't need to be created each time you create a rate limit. Also, should we cache the result in a field?
The rate limiter doesn't need to be created inside the if block.
The rate limiter doesn't need to be created each time you create a rate limit. Also, should we cache the result in a variable?
Collections.emptyList() can be used here
Collections.singletonList
Collections.emptyList()
I think I would prefer something like: if (disableCaching) { persistence.disableCaching(); } else { persistence.disableCaching(); }
I think I would prefer something like: if (disableCaching) { persistence.disableCaching(); }
I think I should be able to remove the persistence field altogether.
Again, a constant or something.
mWriter.write(keyValue.getValue()); will be good enough
mWriter.write(keyValue.getValue()); will be better
Shouldn't this be an access modifier?
Shouldn't this be an error?
Shouldn't it be an access modifier?
still need to set it to final
still need to set it to protected field.
it's returning the same data twice.
return Collections.EMPTY_LIST;
minor: this should return Collections.emptySet();
this should return an empty list.
if(bases.length <= 1 )
if( bases.length <= 1 )
if(
why not just delegates.stream().flatMap(Optional::map)?
why not just delegates.stream().flatMap(Optional::map)
why not just delegates.stream().flatMap(Optional::map)?
For this to work, we need to create a new instance of Context in the callback, and close it in here.
For this to work, we need to create a new instance of Factory in the callback, and close it in the callback. Otherwise, this could be a problem in the original code, since the process is not working in the callback.
For this to work, we need to create a new instance of the JobResult and call it here.
Please use more descriptive names, e.g. jobsGridPortlet.
Please use more descriptive names, like "finishColumnsFirst" or something more descriptive.
Please use more descriptive name, like "searchColumnsFirst" or "destColumns".
Use resilient.
Use Consts.MODEL_APPLICATION_header_view.
Use getRimberrr()
Maybe we should use Objects.requireNonNull here?
You can use Objects.requireNonNull to avoid this warning.
Maybe we should use Objects.nonNull(sourceType, "sourceType") here?
Could we add this to util class so that we don't need to specify param all the time? Maybe two versions throwing original UnsupportedEncodingException and RuntimeException wrapping UnsupportedEncodingException.
Could we add this to the util class so that we don't need to specify param all the time? Maybe two versions throwing original UnsupportedEncodingException and RuntimeException wrapping UnsupportedEncodingException.
Could we add this to util class so that we don't need to specify Patterns.getArtifact()//
Not sure if creating source is a good idea.
NotBounded is actually the default.
NotBounded is actually used.
java segments.stream().mapToDouble(ACNVModeledSegment::getSegmentMeanInCRSpace).filter(x -> Math.abs(x + meanBiasInCR) < 0.1)
java segments.stream().filter(x -> Math.abs(s.getSegmentMeanInCRSpace() - 1 + meanBiasInCR) < 0.1).toArray();
java segments.stream().mapToDouble(ACNVModeledSegment::getSegmentMeanInCRSpace).filter(x -> Math.abs(x + meanBiasInCR) < 0.1))
This should be private, since the constructor is not static.
This should be private, since it is only used in tests.
This constructor can be private
throw Exception to allow user to prepare enum
Why are we keeping the return type of ordinal?
Why do we need ordinal?
this shouldn't be removed
I think this shouldn't be removed
I think this shouldn't be removed.
please remove empty line
please remove xpath and use method selectors instead
please remove xpath and use method selectors directly
This if statement is not needed.
I think you can remove this else.
I think this should be an else if statement.
I think this.url + this.url + firmwareIdentification
I think this.url is not necessary.
I think this.url + this.url isn't needed.
@sebing assertFalse(containsClass(TestLoggingEventListener.class, eventListeners)); was already imported.
@sebing  assertions, please below.
@sebing assertFalse(expectedException) may be better
Style nit: I think we don't use Locale.ENGLISH in this case. We should add it in the panels array.
Style nit: I think we don't use Locale.ENGLISH in this case. We should add it to our own constant to make it consistent.
Style-nit: I think we don't need to use Locale.ENGLISH here.
return itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class));
return itemClass.isAssignableFrom(MavenModule.class) && itemClass.isAssignableFrom(MavenModuleSet.class));
return itemClass.isAssignableFrom(MavenModule.class) && itemClass.isAssignableFrom(MavenModuleSet.class);
Could you please Camel case TextArea.
expected test case
expected test name Camel case
add a message
return this.
return this....
Please throw notNullValue() for this
Please throw notNullValue() for this statement.
AssertJ.
Why do we need it instead of adding the data to the flag? Also, isn't this the functionality you wanted in the Facade layer?
Why do we need it instead of adding the data to the beginning of the method? Also, isn't this the only place where this is relevant?
Why do we need this list rather than just return true?
Can you change this to: return this.properties.getProperty(name); or make it private?
Can you change the return type of this method to String?
Can you change the public modifier to private?
import this too
import this
import
Make this warn level.
Unsynchronized access to the "resource"
Unsynchronized access to the underlying resource here.
Capitalize Thrift (or remove this)
Capitalize Thrift (or remove word)
Capitalize Thrift
In other files too, add the checkpointedPosition.getOffset() + checkpointedPosition.getRecordsAfterOffset() to the reader.
In other files we use [this method](<LINK_0> where this is not necessary.
In other files too, add the checkpointedPosition.getOffset() + checkpointedPosition.getRecordsAfterOffset() and keep the offset in the variable.
Should be List<PlanNode>.
Should be List<PlanNode>
this.
why public? Are we planning to use it outside of this class?
why public? Are we planning to use it outside of this class? It seems like it should be private.
why public? Are we planning to use it outside of this class? It seems like it should be private
Shouldn't this return Flux.empty() instead?
Same here. This should probably return a new IllegalArgumentException.
Shouldn't this return Flux.empty() instead? Same for setSecret.
I think this is a good idea to use something like: menuItem.getTitle() (note you'll have to change the textToShow to something else, which may confuse the user when something goes wrong, but something else).
I think this is a good idea to use something like: menuItem.getTitle() (note the label, etc)
I think this is a good idea to use something like: menuItem.getTitle() (note you'll have to change the textToShow)
I think you can remove the "iterations" variable.
I think you can keep the logging here.
can you remove the "iterations" prefix here?
Would it make sense to move the -1 into the variable, since it's the convention we're using -1 to represent the -1.
Why not make -1 the number part of the check instead of -1? It's because the semantic is a bit odd to read.
Would it make sense to move the -1 into the variable, since it's the convention we're using -1 to represent the delimiter?
List#isEmpty()
List#isEmpty().
Collection#isEmpty()
That's even more complicated than that. If Object is not a EObject, then you should use org.eclipse.ecore.runtime.ISE.
That's even more complicated than that. If Object is not a EObject, then you should use org.eclipse.ecore.runtime.compatibility..
can be wrapped in a jclouds feature.
Is it needed to call dismiss() here?
Why not override dismiss() that is called only once?
Why not override dismiss() to return true?
Shouldn't these be moved to the presenter's hide method?
Shouldn't these be moved to the presenter
Shouldn't these be moved to the presenter.show() method?
Why do you need to catch RuntimeException here?
Why do you need to catch Exception here?
Why do you need to get value from String?
This can be final, i.e. () -> ()
This can't be null, see below.
This can't be null, it's Nullable..
> 0 is the default for the scale, this should be > 1
> 0 is the correct default for the scale, this is the same as INT-23:38
> 0 is the correct default for the scale, this is the same as 1.
new ArrayList<>(other.pattern);
the type should be List<Integer>.
type inference (synchronized)
public?
revert public
access modifier?
This is the default behaviour.
This is the default behaviour. It should be > 1.
This should be > 1 as well.
I think we can replace this by an int constant.
I guess you can replace all these conditions with a single setter call.
I guess you can replace all these conditions with a single function call?
This could be replaced with!element.isValid()
This could be replaced by: return element.isValid()? null : element.getContributor();
This could be replaced by: return element.isValid();
Please check GoInspectionUtil.getExpressionResultCount(e)!= 0
Please check GoInspectionUtil.getExpressionResultCount(e)!= 1
Please check GoInspectionUtil.getExpressionResultCount(e)!= 1)
Make sure you have your own quick list of TIME_LEFT_UPDATER entries. Take a look at [this](<LINK_0>
Make sure you have your own quick list of TIME_LEFT_UPDATER entries. Take a look at how TIME_LEFT_UPDATER is used.
Make sure you have your own quick list of TIME_LEFT_UPDATER entries.
this method can be private
no need to call this method with different signature.
no need to call this method with different signature
Please verify the "cmd" parameter is being passed.
Please verify the returned command.
Please verify the "cmd" member variable.
note that the reason for test is now to not use public.
note that the best practice for test is now to not use public.
note that the test is now unused.
Lets use IgniteUtils.waitForAsyncCompletion()
Lets use IgniteUtils.waitForAsyncCompletion(..) here
Lets use IgniteUtils.waitForAsyncCompletion(..) here.
We could add some logging in the next test, to make sure it fails.
Can we add some logging in the case?
We could add some logging in the next test.
No need for this.canvas.
No need for this.canvas
This seems tricky...
nit: this could be more readable by using ternary operator?
nit: this could be private static
nit: this could be private
minor: You can use Collections.emptyMap() instead of creating a new anonymous class.
minor: You can use Collections.emptyMap() here.
minor: You can use Collections.emptyMap() instead of creating a new empty HashMap.
I wonder if we could use a method on Optional here
I wonder if we could use a method reference here: java.findFirst().orElse(defaultRecoveryDecorator);
I wonder if we could use a method reference and method reference instead of stream + filter here
this can be made more functional style by using: return!s1.isPrivate() && ((JavaSymbol) s1).flags() == (JavaSymbol) s2.flags();
the name of the two expressions could be better s1.isPrivate()
this can be reverted
Should this be incAtomicLong?
Should this log at info level?
Should this log at a higher level?
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on text decorator is better than nothing but can we not ascertain the values that should be being set?
can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
For a ton of discussion, should we use a different Error type (e.g. RuntimeException) instead of Error?
For a ton of discussion, should we use a different Error type (e.g. RuntimeException) rather than an Error?
For a ton of discussion, should we use a different type of error here?
Should this be an AssignmentMap?
I think the conversion of the AssignmentExpressionTree to a Map in this case seems unnecessary.
I think the conversion of the AssignmentExpressionTree to the assignment loop is rather unnoticed.
Perhaps we can use Locale.getDefault() here instead?
Perhaps we can use Locale.getDefault() here instead of TextUtils.isEmpty() or something like that.
There's no reason to use TextUtils.isEmpty() here, because you're trying to do the null check.
Guid should be used here, as Guid
Hmm... now that you're returning id
Guid should be used here
Please, do the instanceof check, or add an explicit null check.
Please, do the instanceof check before casting. We'll have to make sure there are no NPEs.
Please, do the instanceof check before casting. We'll have to fix that elsewhere.
Please implement toString() to provide debugging state information for debugging purposes.
Please implement toString(). This may provide debugging state information for debugging purposes.
This hashCode implementation should include attributes from the Answer super class.
if service is not present it should throw exception?
if service is not present it should throw error?
if service is not present it should throw SecurityException?
I'd just use a lambda here: requestExpression, level, session?
I'd just use a lambda here: requestExpression -> new NoopExpressionOptimizer(), TestingSession.SESSION);
I'd just use a lambda here: java.util.Optional.ofNullable(metadata).map(FunctionResolution::::).orElse(null);
I don't think action can be null here makes sense, since it would probably be marked as Nullable.
I don't think action can be null here makes sense, since it would probably be marked as UNSTABLE
I don't think action can be null here makes sense, since it is annotated by @Nullable.
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE());
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE");
it's weird that this method has to be public. I would prefer if we make it protected, and just have an internal class that doesn't have access to it.
it's weird that this method has to be public. I would prefer if we make it protected, and just have an internal class that doesn't have access to the member variable.
it's weird that this is not null delimiter, is it preferably the same as the list text?
nit: consider testing st_is_empty(st_geometry_from_text('POINT (1.5 2.5)'))", "select false".
nit: consider testing st_is_empty(st_geometry_from_text('POINT (1.5 2.5)'))" for example.
nit: consider testing st_is_empty(st_geometry_from_text( 1.5 2.5)".
boolean?
why is this method private?
why is this method public?
It looks like the subtab of the new executeCommand() method is for the same purpose. Wouldn't it be better to have a single call to super.executeCommand(command) and have the same code in both subclasses?
It looks like the subtab of the new executeCommand() method is for the same purpose. Wouldn't it be better to have a single call to super.executeCommand(command) which is more similar to the old one?
It looks like the subtab of the new executeCommand() method is for the same purpose.
we should log a warning here so that users who have wrong permissions on /.gitconfig by mistake have an issue
we should log a warning here so that users who have wrong permissions on /etc/
we should log a warning here so we don't lose the problem
I don't think we should override the responseStatus() method to return a RepeatLastCall. This method could then appear in the runOnce() method and have it return true.
I don't think we should override the responseStatus() method to return a RepeatLastCall. This method could then appear in the runOnce() method above?
I don't think we should override the responseStatus() method to return true. I think that makes it more obvious that the status of the call is what we want.
@CheckForNull
@CheckForNull?
@CheckForNull return an Optional?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_1> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant 'public static' modifier? [![rule](<LINK_1>](<LINK_0>
Is this method supposed to be called 'categoryInput'?
Is this method supposed to be called / not ready?
Is this method supposed to be called'select text'?
@sebing space before opening parenthesis
@sebing please avoid using this.
final
You can use getResources().getColor(R.color.emphasis), it will be more readable.
You can use getResources().getColor(R.color.emphasis), it will be more efficient.
You can use getOrDefault(parent, false) instead.
This is unnecessary, parents can be null.
This should probably be Arrays.asList(parents, parents)
This is unnecessary. parents can be null here.
String.format?
Should be declared as a constant?
Should be declared as private.
Don't need this assertion otherwise.
Don't need this assertion otherwise. Direction can not be null or empty.
Don't need this assertion. Direction can not take a double or double.
should this be public?
should this method be private?
please make this method synchronized
This doesn't seem right.
This can be a boolean value, right?
This can be a boolean value
First of all, setting the new value to true and then checking the new value. Secondly, one of the new methods with an if (remove_ == true) check.
First of all, setting the new value to true and then checking the new value. Secondly, one of the new methods with an if (remove_ == true) call out of this method.
First of all, setting the new value to true and then checking the new value. Secondly, one of the new methods with an if (remove_ == true) check. Why did you take the chance of that? I would argue that setting the value of the new flag is different from the current behavior of the method and should be ignored here.
This should return an Optional<RequestCreator> instead.
This shouldn't be deprecated.
This shouldn't be deprecated, right?
was this meant to be "UNKNOWN"?
was this intentionally changed?
was this meant to be "notable tagDisplayNames"?
Don't use nullsFirst, why not simply use row.getRaw()?
Don't use nullsFirst() in new code
Don't do this. Please static import.
For consistency, this should come from the Builder
For consistency, this should come with the Builder
Builder
Please extract the above two statements into a private method.
Please extract the query variable to a local variable and use it here.
Please extract the above two statements into a separate method, please.
It'd be more clear to use new ReadOnlyTableException("message", message).
It'd be more clear to use more descriptive names instead of underscores.
It'd be more clear to use new ReadOnlyTableException(message).
Use StringUtils.isNotEmpty instead
use StringUtils.isNotEmpty instead
Use StringUtils.isNotEmpty instead?
What do you think about.clear() instead?
What is the point of having a flush method instead of in the constructor?
use closeQuietly instead.
maybe we can do something like: java if (messageHandling == null) { return null; }...
maybe we can do something like: if (messageHandling == null) { return null; } else { return handle(...); }
can we make this code more readable?
Code style for if statements is no braces
Code style for if statements is braces
Code style for this method?
Do you really need a mock here? Couldn't you use an instance of MetaDataService instead of using a mock?
Do you really need a mock here? Couldn't you use an instance of MetaDataService instead of hardcoded strings?
Do you really need a mock here? Couldn't you use an instance of MetaDataService instead of using the constructor?
This should probably be using the constructor, but maybe CHelper.getInstance()?
This does not require to be public, it is visible to the constructor.
This does not require to be public, it is visible only in tests.
I think we should not log an error if the logger.error is called only.
I think we should not log an error if the logger.error is called only for logging.
I think we should not log an error if there is no s.
Should this be [{}#{}][{}@{}][{}]:end"?
Should this be [{}#{}][{}@{}][{}]:end"?
Should this be [{}#{}][{}@{}][{}]:end"?
Can we do this in the constructor rather than public void initiate() { for (int i = 0; i < lh.getLedgerMetadata().currentEnsemble.size(); i++) { if (lh.getLedgerMetadata().currentEnsemble.get(i), BookieProtocol.LAST_ADD_CONFIRMED, this, i, BookieProtocol.FLAG_NONE) { } } } public void initiate() { if (lh.getLedgerMetadata().currentEnsemble.get(i), BookieProtocol.FLAG_NONE, FLAG_NONE) { } }
Can we not do this in the constructor?
Can we not do this in the constructor, rather than in the constructor?
Please add curly braces
Please add the 'v == 0' check.
Please add curly braces java if (v == 0) { return 1; } return 1;
declare throws please
declare throw please
declare and assign
Do we need a throws declaration here? It seems to be inconsistent in the existing methods.
Do we need a throws declaration here? It's not a good practice to throw an exception on the method signature.
Do we need a throws declaration here? It's not a good practice to throw an exception from the method signature.
I think this could also be: java if ( hasNext() ) { return next( currentIterator().next(), currentIterator().currentScore() ); } else { throw new NoSuchElementException( "The iterator is exhausted" ); }
I think this could also be: java if ( currentIterator().next() == 0) { throw new NoSuchElementException( "The iterator is exhausted" ); } return currentIterator().currentScore() );
I think this could also be: java if ( currentIterator().next() ) { return Pair.of( currentIterator().next(), currentIterator().currentScore() ); } else { throw new NoSuchElementException("The iterator is exhausted" ); }
warn maybe? and re-throw exception?
warn maybe? and re-throw the exception?
warn maybe? and re-throw the exception.
IndexNotApplicableing is not needed.
IndexNotApplicable.
IndexNotApplicableEvent()?
Why is this returning null?
The break is useless here.
Why is this returning null? I thought it is always returning from the method.
why not return iterator?
why would this be iterable?
why not return ImmutableList.of();?
getContentLengthLong() is nullable, so we should handle null as well
getContentLengthLong() should return -1 if the size is -1 (I think we should return zero if we are no longer displaying this to the user).
getContentLengthLong() should return -1 if the size is -1 (I think we should return zero if we are no longer displaying this to the user.
should this be moved into the first catch block?
Should this be moved into the first catch block?
should this be part of the public method please?
To enforce immutability, I would prefer to have this logic in a second place as it is not needed.
To enforce immutability, I would prefer to have this logic in a second place as well.
To enforce immutability, I would prefer to have this logic in a second place as it is not in the planner part.
Let's use EnumProperty(String) directly, as we're creating a value object.
What does the empty line mean?
Let's add a line below the 'if'
Wondering if we should use Objects.equals for this.
rename to pathObject for clarity
Wondering if we should use Objects.equals for this comparison.
setLevel(Level.WARN);
This isn't an error. It should be logged at least.
setLevel(Level.WARN)
Remove 'throws RuntimeException'
Should we change equals to equals?
Should we change equals to equals here
does this mean that symbol.gSymbol() will be null?
do it in one line?
do we really need this?
Maybe check the message is inserted to this method.
Maybe check the message is better? It looks that this test could use custom message
Maybe check the message is missing.
addFailedAttempts is an element of the list of attempts. Should we just addFailedAttempts to invalidLoginAttempts and removeFailedAttempts?
addFailedAttempts is an element of the list of attempts. Should we just addFailedAttempts to invalidLoginAttempts, and removeFailedAttempts from entirely?
addFailedAttempts is an element of the list of attempts.
Is this thread good enough?
Is this thread good enough? I was thinking about creating thread pool for each listener.
Is this thread really needed?
Nice, but I guess getCodecA is not camelCase, so CNFE is not camelCase.
Nice, but I guess getCodecA is not camelCase, so CNFE is not camelCase. The latter is to return false.
Nice, but I guess a more readable method would be (String.endsWith(getCodecA())
can be inlined
can be simplified to final boolean expected = false;
can be simplified to true?
debug.
debug level
debug
I don't think we should override the equals method.
I don't think we need this.
I don't think we should override the method.
I would assert that it's not null
I looked at this and it looks like an assert.
I looked at this and it seems you have an issue.
This should be package private.
This should not be public
This should be package private
Nit: UrlParseRequest is not used in tests.
Nitpick: UrlParseRequest is not used in tests.
Nitpick: UrlParseRequest is not used in this test
Why there are no logic here?
Why is this necessary?
Why there are no changes?
it should have a static factory method.
all these literals should be static final
it should be in this class.
suggestion if (StorageService.instance().isGossipActive()) {
suggestion if (!StorageService.instance.isGossipActive()) {
suggestion if (!StorageService.instance().isGossipActive()) {
@yingsu00 Can this method be implemented as System.out.println(result)?
@yingsu00 Can this method be implemented as System.out?
@yingsu00 Can this method be implemented as System.out.println(message)?
Here we should use something like ".bsp/.jar" so we can see it more easily in the future.
static import
static import?
Should this be using the 'App-Startup' message?
Should we be using the constant here?
Should this be using the constant ENABLE_MANAGEMENT_FILE instead?
We should probably check for empty string too
We should probably check for null here
We should probably check for null here.
To be honest, I'd feel more confident if this was not the case in the line above: java return valueOf(name.toUpperCase());
To be safe, you should throw an exception if name is null.
To be honest, I'd feel more confident if this was not the case in the line above: return valueOf(name.toUpperCase());
Same as above with terms of import
Same as above with terms of delegate.
Same as above with terms of signature
@aljoscha We should probably use [try-with-resources](<LINK_0> on that to avoid a warning
@aljoscha We should probably use [try-with-resources](<LINK_0> on that instead.
@Nullable
there is no need for this parameter
No need for this method
No need for this method.
can be putIfAbsent
can't we use computeIfAbsent here?
can be collapsed to a single line.
suggestion.until(() -> j.jenkins.getQueue().isBlockedByShutdown(task));
suggestion.until(() -> j.jenkins.getQueue().isBlockedByShutdown(task)));
suggestion.until(() -> j.jenkins.getQueue().isBlockedByShutdown(task))
Use || instead of duplicating the logic.
Use || instead of duplicating the logic?
Use || instead of duplicating the logic here.
Do we need a catch block for these?
Do we need a catch block here?
Do we need a catch block to prevent that?
Do we want to use SparqlUpdateHelper.createSparqlReplace() here?
I don't like this sparqlUpdateHelper at all, but instead, can you use the variable SparqlUpdateHelper.createSparqlReplace() and saveTripleToFedora()?
Do we want to use SparqlUpdateHelper here?
Gson.json() instead of Json.createObjectBuilder()
Gson.json() instead of Json.createObjectBuilder().
we could use org.hpccsystems.ws.core.client.model.HashCode.Builder instead
Small suggestion: " This function is not longer useful, use send_resourcepack()"
Small suggestion: " This function is not longer useful, use send_resourcepack() will call it, and use send_resourcepack()
Small suggestion: " This function is not longer useful, use send_resourcepack() will call it, and use send_resourcepack()"
return text;
please rename the field to transliterate
return text;?
this is going to get the cache for a key in the map. Instead get it once before the map and use the result to check.
this is going to get the cache for a key in the map. Instead get it once before the remove.
this is going to get the cache for the key in the map. Instead get it once before the map lookup, you can do something like resolveKey(key).
Is this a private method? It's only used by the super class.
Is this a private method? It's not used outside this class.
Is this "protected" necessary?
a) greater than (1L << readNofBits)
a) greater than (1L << readNofBits") is more readable
a) greater than (1L << readNofBits") is better.
I'd rather use Optional.ofNullable, something like: java public void openPortForwardingAndAdvertise(EntityAndAttribute<String> loadedEndpoint, Optional<EntityAndAttribute<String>> m) { getPortForwarderAsync().openPortForwardingAndAdvertise(acPort, Optional.of(whereToAdvertise), Optional.<EntityAndAttribute<String>>absent()); } public void openPortForwardingAndAuthenticated(EntityAndAttribute<String> loadedEndpoint, Optional<EntityAndAttribute<String>> loadedEndpoint) { getPortForwarderAsync().openPortForwardingAndAdvertise(acPort, Cidr, EntityAndAttribute<String> loadedEndpoint); }
I'd rather delegate this to the new method openPortForwardingAndAdvertise(EntityAndAttribute<String>)
I'd rather delegate this to the new method openPortForwardingAndAdvertise
This is a legacy expression - you should be able to directly return this.successfullyParsed == false
This is a legacy expression - you should be able to do this.successfullyParsed == false
This is a legacy expression - you should be able to directly return this.successfullyParsed == false.
This is kind of confusing. I think the whole point of itinerariesForPathTemplates is to rename it. Only the mangled point is to keep the old version of the whole thing.
This is kind of confusing. I think the whole point of itinerariesForPathTemplates is to rename it. Only the mangled point is to keep the old version.
This is kind of confusing. I think the whole point of itinerariesForPathTemplates is to rename it. Only the mangled point is to keep the old version of the whole thing clearer.
This should be Context.context.getApplicationContext()
This is wrong. ConnectivityManager should not be enabled on the app thread. You can use ConnectivityManagerManager.EXTRA_DEFAULT_APPLICATION_URL() to get the instance.
This is wrong. ConnectivityManager should not be enabled on the app thread. You can use ConnectivityManagerManager.EXTRA_DEFAULT_APPLICATION_URL() to access the instance.
The same Arrays.stream() can be applied here as well.
The same Arrays.stream() can be applied here too
The same Arrays.stream() can be applied here too :)
I think this needs to be updated to track the version name here.
I think calling code like this will reformat the code that needs to be updated in the future.
Extra line
Could you explain why we need the 'this'?
Could you please remove this, I think.
Could you explain why we need the 'this'? I think it would be better to be'static'..
Please update these string to say "developer mode" instead of "debug build".
Please update these strings to say "developer mode" instead of "debug build".
Please update these strings to use a constants from the AppConstants.
misspelled. plus why are you doing this?
Change this to be!useHyphens?
misspelled.
Why are we calling Keywords.getRawSignature() twice?
nit: add space after if
Why are we calling getRawSignature instead of Keywords.CONST?
There is no reason for public.
There is no reason for returning an array here, returning a new String[principal.getName()] already returns a list.
Any reason for public?
Check for null instead of "something <operator> null" convention.
Check for null instead of "something <operator> null".
Check for null instead of the empty string.
suggestion return File.createTempFile("OPENNLP_DATA_DIR", System.getProperty("OPENNLP_DATA_DIR"));
suggestion return File.createTempFile("OPENNLP_DATA_DIR", System.getProperty("OPENNLP_DATA_DIR"));
suggestion return File.createTempFile("OPENNLP_DATA_DIR", StandardCharsets.UTF_8);
Use parameterized logging instead of string concatenation.
Please remove this statement or enhance it to something more context/meaningful
Please remove this statement or enhance it to something more context/meaningful.
Remove
nit: remove blank line
nit: Remove blank line
I would prefer AssertionError since it gives error message to the user.
I would prefer AssertionError if all methods that return void, and wrapping them in an IOException would be much more explicit.
I would prefer AssertionError since it gives error message to the reader.
> Passwords don't have a label
> Passwords
> Passwords. Shouldn't this be public?
Please use parameterized logging instead of string concatenation
better to use parameterized logging
Please use parameterized logging
It seems like the power of Math.pow() is _ reasonable_, but if we're going to log the sleep, then why not just do the min / max?
It seems like the power of Math.pow() is _ reasonable_, but if we're going to log the sleep, then there is no need to compute it every time. If the sleep is in the middle of sleep, then there is no need to compute it every time.
It seems like the power of Math.pow() is _ reasonable_, but if we're going to log the sleep, then there is no need to do it.
I don't know if we should have this anymore.
I don't know if we should have this anymore. But that would be great.
Like.
not related to this PR though
it would be better to move this to a constant.
it would be better to move this to a constant
ThreadPoolTaskScheduler.shutdown()
H-m. Why do we need to call ThreadPoolTaskScheduler.shutdown() in this class?
H-m. Why do we need to make it public?
That would overflow maximum instructions per method before atLeastOnce() and it is reached by default.
That would overflow maximum instructions per method before atLeastOnce() and it is reached by default. This can be improved by using a couple of lines.
That would overflow maximum instructions per method before the size of the class. Can you check it again?
We don't need to wait for this. The panel is closed before press on the PanelControl.
We don't need to wait for this. The panel is closed before press on.
We can try to wait for the whole panel to stop waiting for a single panel to complete.
Please remove unnecessary white space
Please remove unnecessary whitespace
Please remove unnecessary semi colon
I'd prefer throwing an exception instead of using printStackTrace() here. In my opinion it's better to leave the code as is because this method is only called by AxonServer() which is executed by AxonServer() and AxonServer() because this method is only called by AxonServer() which is defined by AxonServer() and AxonServer() because AxonServer() is synchronized and AxonServer() is also not visible to the AxonServer() method.
I'd prefer throwing an exception instead of using printStackTrace() here. In my opinion it's better to leave the code as is because this method is only called by AxonServer() which is executed by AxonServer() and AxonServer() because this method is only called by AxonServer() which is defined by AxonServer() and AxonServer() because AxonServer() is synchronized and AxonServer() is also not visible to the AxonServer() class.
I'd prefer throwing an exception instead of using printStackTrace() here. In my opinion it's better to leave the code as is because this method is only called by AxonServer() which is executed by AxonServer() and AxonServer() because this method is only called by AxonServer() which is defined by AxonServer() and AxonServer() because AxonServer() is synchronized and AxonServer() is not the same as AxonServer() (which is the case now). Thus, I would prefer the latter.
This function is very similar to the sanitizeForRichText, can we make it simpler?
This function is very similar to the sanitizeForRichText, can we make it more common?
I believe the Sanitizer call is not needed here.
Should we throw an exception instead?
Should we throw UnsupportedOperationException here?
Should we throw IOException here?
Should we log errorMap here? There are other places in this code where this is happening.
Should we log errorMap here?
Should we log errorMap here? There are other places where this is happening.
Can you move this out of the if block?
Can you move this out of the if block?
Can you move this out of the if block, please?
Why don't you just use.getDurability() instead? No need to define a separate long type for this.
Why don't you just use.getDurability() directly? No need to define a separate long type for this.
call destroy instead
If customers send retentionTimeout is less than 45 days, we should use that value instead of 45 days (default value). This is to let customers have a way to expire earlier than the default 45 days. For cases where they deliberately send test metrics and then want to delete them from discovery after a week. The check we should have is, to cap the retention timeout by default.
If customers send retentionTimeout is less than 45 days, we should use that value instead of 45 days (default value). This is to let customers have a way to expire earlier than the default 45 days. For cases where they deliberately send test metrics and then want to delete them from discovery after a week. The check we should have is, to cap the retention timeout at that point.
If customers send retentionTimeout is less than 45 days, we should use that value instead of 45 days (default value). I suggest to cap the retentionTimeout to the max_retention
@adyach are you sure this is not null?
@adyach are you sure this is not null?
@adyach are you sure this is not null while ROUTER_CLOSED_EXCEPTION is a good idea to add an assertion to check if the result is null? I think it would be better to use the same message for both operations, i.e. throw an IllegalStateException.
removeRef()
I think this should be: packCache.remove(pack.getPackDescription());
I think this should be: packCache.remove(pack.getPackDescription())
Nice catch. I'd like to avoid it and use a little bit more than this.
Nice catch. I'd like to avoid it and/or add a little bit of safety.
Nice :)
also assert that totalConnectionsCount > 0
just a note here - Assert.assertCounts
also assert that totalConnectionsCount > 0 are good
The last claim task should be "TASK_DEPLOYMENT_ID"
The last claim task should be "TASK_DEPLOYMENT_ID".
the field should be removed as well
The memory alignment should not be public, because it is private, so if someone change it, he cannot change it, right?
The memory alignment should not be public, because it is private, so if someone change it, it should go into the constant.
The memory alignment should not be public, because it is private, so if someone change it, it should go in the future.
Can be replaced by : suggestion Object instance = this.constructMessageHandlerInstance(msg, new ArrayList<>());
Can be simplified to: suggestion Object instance = this.constructMessageHandlerInstance(msg, new ArrayList<>());
Can be replaced by this.constructMessageHandlerInstance(msg, new ArrayList<>());.
Minor: IllegalStateException is more appropriate here.
we should throw IOException instead of returning from the method.
we should throw IOException instead of returning from this method.
I would add a method singletonMap(String, String> devfileFileLocation) which does the null check
I would add a method singletonMap(String, String) which does the null check
I would add a method singletonMap(String, String> devfileFileLocation) which does case null, rather than adding the check.
In this case, we should be using the same address as root.file.ext.java. Anything that is relative paths will be cleaned up.
In this case, we should be using the same address as root /etc/
In this case, we should probably use a MYSQL_USER_PREFIX and just use the same string from the current locale.
+2
return static constants
return static constant
I think this test (and the ones below) should be TriState.UNSET
I think this is fine, but it's up to you.
I think this is fine, but I wouldn't set it to true. The problem is that I think the TriState.setEmailMe() would have been that it's called more than once.
How about using MetricsManager.meterRegistry() for this?
How about using MetricsManager.meterRegistry() instead?
How about using MetricsManager.meterRegistry() for a better example?
How about computeIfAbsent?
How about 'final'?
How about 'final'?
Can't we use the parserContext.getWriter() here instead of the hard coded port?
Can't we use the parserContext.getWriter() here instead of storing it in local variable?
Can't we use the parserContext.getWriter() here instead of storing it in local variable?
I wonder if we should change the arg from TIMEOUT to TIMEOUT.
I am not sure we need the cmChannel3.close() invocation.
I'd rather we test the case where the TIMEOUT is not the last argument and returns a value.
I would do this: java if (coll!= null &&!coll.isEmpty()) { return; }
I would also do this: java if (coll!= null &&!coll.isEmpty()) { return; }
I would also do this: java if (coll!= null &&!coll.isEmpty()) { return; } buffer.append(coll); return;
Is this caught somewhere? It's only used in the first place.
Is this catch needed? It's only used in the first place.
Is this catch needed?
if it is not null, we should throw here here.
if it is not null, we should throw here?
if it is not null, then we should throw here?
this.intersectingTypes[0].isClass() && this.intersectingTypes[0].isJava();
this.intersectingTypes[0] is completely unnecessary
this.intersectingTypes[0], it should be ()
log the exception here.
log the exception.
Log the exception to warn
I don't think this is necessary (and the requestPinReset() method below)
This is now also in requestPinReset I would expect to do the same. This method would be more consistent with getHostOrConfirmationMessage.
This is now also in requestPinReset I would expect to do the same. This method would be more consistent with getHostNetworkId
assertSame(x, y) might be nice.
also assert that a + b is in the output
assertSame(x, y)
See above about formatting issue
This means that for clarity I would not expect a configuration file in that case.
See above about formatting issue.
mark.getTimestamp()
You don't need to do this.
mark.getTimestamp()?
Take a look at [Java-82](<LINK_0>
Take a look at [JavaUOsError](<LINK_0>
Same here, if you're checking for an admin already, you shouldn't need to search for it.
Return an empty CommandException for all aggregates.
Doesn't this cause an NPE if the envelope.getOuterObject() is null?
Doesn't this cause an NPE if the envelope.getOuterObject() returns null?
Returning the first endpoint may be null, this method is not called from anywhere.
Returning the first endpoint may be null, this method is not called at all.
Returning the address may be not needed.
@vmaletta private method can be private
since the default case can't be in the patch, create a new method in this class instead of having this abstract class in the system.
since the default case can't be removed
Hmmmm... now that you have something complete like this.. we need to think of a way to reuse this logic into ActiveMQServerImpl:: displayDetails
Hmmmm... now that you have something complete like this.. we need to think of a way to reuse this logic into ActiveMQServerImpl:: displayDetails and replace them with logging if needed
Hmmmm... now that you have something complete like this.. we need to think about it still being used here.
I would prefer "WPS request process for NAME:..."
I would add an error message to the log.
I would prefer "WPS request process, without output column name"
negotiate?
If we're doing this more than a throw, don't we want to explain what it means?
If we're doing this more than a logging statement, not a message that makes more sense.
No need to test if storeExists is not null since we cancel it.
No need to test if storeExists is not null since it is the same in the constructor.
No need to test if storeExists is not null since it is the same in the method.
Should this be records.size()?
Should this be IOException?
Should this be records.isEmpty()?
See above. If this is too long it would be better to use new FormulaShifter(externSheetIndex, sheetName, firstMovedRowIndex, lastMovedRowIndex, numberOfRowsToMove, ShiftMode.RowMove, version);
See above. If this is too long it would be better to use new FormulaShifter(externSheetIndex, sheetName, firstMovedRowIndex, lastMovedRowIndex, numberOfRowsToMove, ShiftMode.RowMove, instance);
See above. If this is too long it would be better to use java.util.Random instead and check for null if it's empty?
You might also need concurrencyGoal here, and in the other tests?
You might also need concurrencyGoal here, since this is asserting that a while loop was running on the common thread
try-with-resources
Can we use the URL in Utils.java?
This should return the first time it's used - i.e. use the xml from the xml.
Can we use the URL in Utils.java?
What if one of these is null? Shouldn't we return false if it's not null?
What if one of these is null? Shouldn't we check for that?
What if one of these is null? Shouldn't we return false if it's not?
Could use ternary operator here
Could use StringUtils.equals here
Could use ternary operator here.
I was thinking the idea would be to move the auth check inside the configuration object. Configuration#get() to be called with a default IP address. and check the IP address in the configuration. Does hostName need to be the caller calling this method
I was thinking the idea would be to move the auth check inside the configuration object. Configuration#get() to be called with a default IP address. and check the IP addresses in the configuration object
I think the message should be hostName.
I think you should clear existing clients too, not just clients.remove(client)
I think you should have done this at the end of the method, not at the concrete level.
I think you should have done this at the end of the method, not at the concrete implementations.
you do not need to cast it in order
you do not need to cast it on every call.
you do not need to cast it in every call.
Returning isActive from a method is not necessary. This should only be called by the time of the method.
Returning isActive from a method is not necessary. This should be made package local
Returning isActive from a method is not necessary. This should only be called by the time of the function.
suggestion bean.setSourceSet(new HashSet<>());
suggestion bean.setSourceSet(new HashSet());
suggestion bean.setSourceSet( new HashSet<>());
Idea for improvement ;)
Idea with a small helper method
Idea with a small helper method and reuse it
let's make it protected.
what if you have a table to read it?
what if you have a table to overwrite it?
if you want to pass the plugin name in the plugin it will be to the cli parser module
if you want to pass an exception, should it be logged with the exception?
if you want to pass the plugin name in the plugin it should be localized
This should be private.
This should be extractionFn.getInput()
This can be private.
if you prefer to use Tomorrow, you might also consider replacing "-rc.5" with "-rc.5".
if you prefer to use Tomorrow's tutorial, you might also want to change it to return BuildConfig.VERSION_NAME + release_name + "-rc.5"
if you prefer to use Tomorrow's tutorial, you might also want to change it to return BuildConfig.VERSION_NAME + "-rc.5"
We do not remove provided types!
We do not add a default constructor with these names
We do not use 15 levels for constructor arguments
Shall we just use PRESTO_CLI_HISTORY_FILE?
Shall we just use PRESTO_CLI_HISTORY_FILE instead?
Shall we just use PRESTO_CLI_HISTORY_FILE here?
The combination of "force" and force is not clear to me. I think this will return true if "action.isForce". What do you think?
The combination of "force" and force is not clear to me. I think this will return true if action.isForce() will be false and the call to "isForce" will still pass to the backend, and add the following statements: if (action.isForce()) { return false; }
The combination of "force" and force is not clear to me. Can we pass both null and " force" here?
The message should be "cacheValidationEnabled = cacheConfig.isValidationEnabled();"
The message should be "cacheValidationEnabled"
The message should be "cacheValidationEnabled = cacheConfig.isValidationEnabled()"
The way you handle this is that it needs to be changed. You need to update the commit.
The way you handle this is that it needs to be changed. You need to cover it with a test.
The response headers should be stored in the <LINK_0>
Three more assertions: java assertThat(actual.toCompletableFuture().isCancelled()).overridingErrorMessage("Expected completion stage has cancelled")
These validations don't seem to be necessary. We're checking the PR's formatting.
Three more assertions: java assertThat(actual.toCompletableFuture().isCancelled()).overridingErrorMessage("Expected completion stage to be cancelled")
pls format (>120 chars)
pls format (>120 characters)
so do not resolve groups and no recursive as well.
do you really need to log every time? you could just put it in a variable
do you really need to log every time?
I am not sure if you could just log the entire tab and get the tab for the first time, and put it in the log where it is called
This change is not necessary now.
This change is not correct. If i understand correctly, parameter name and parameter name are guaranteed to be the same as "listener".
This change is not correct. If i understand correctly, parameter names will always be the same, right? Why is the change here?
FAILED_ENV_STACK_CONIFG_UPDATES_EVENT.name()?
FAILED_ENV_STACK_CONIFG_UPDATES_EVENT.name()
Safer to check event name before calling.
Can this method be private? It is not used outside of this class.
There is no need to invoke toString() in each method.
This is redundant in the method signature.
This is one of the reasons you don't use java.util. ShortDOIServiceException.
Why not just throw this exception?
This is one of the reasons I don't like that you can't just use the class name.
How do you feel about this one: return timeoutCache.getIfPresent(TransactorID.getNodePath(config, transactorId));
Should we really care about timeoutCache.getIfPresent?
Do we need sync here?
I think you need to throw InternalErrorException.
I think you need to update the message in the else case.
I think you need to throw N/A here.
The aforementioned "never return null" rule would be good for all the string getters here.
The aforementioned "never return null" rule would be nice for all the string getters here.
The aforementioned "never return null" rule would be good for all these methods.
Just a thought. This testConnection() method can be private.
Just a thought: Did you test this with a production connection?
empty implementation please
Should this "app-" be replaced with a constant to avoid NullPointerExceptions?
Another nit, better to leave "app-" to a constant.
Another nitpick: Should this be synchronized?
Should be a constant.
Should be a constant for the name.
Should be a constant for "async"
This message could be updated in a private static method that is called many times.
This message could be updated in a private static method and the stack trace would be pretty important.
This message could be updated in a private static method and the stack trace would be the same.
I think this part is redundant with the settings in setup method?
I think this part is redundant with the settings in setup method above, isn't it?
I think this part is redundant with the settings in setup method below, isn't it?
getTitle() is redundant here, it's not being used.
getTitle() is redundant here, it's not being used in the code.
getTitle() is redundant here, it's not being used in the label
the superclass implementation seems to do nothing. override this method.
the superclass implementation seems to do nothing.
@Override
No need to change this.
No need to change it.
No need of this.
I'd go with the suggestion return Flowable.fromPublisher(acl.publishEntries(filter, false, false)).map(MarshalledEntry::getKey).collectInto(new HashSet<K>(), Set::add));
I'd use the same suggestion return Flowable.fromPublisher(acl.publishEntries(filter, false, false)).map(MarshalledEntry::getKey).collectInto(new HashSet<K>(), Set::add));
I'd go with the suggestion return Flowable.fromPublisher(acl.publishEntries(filter, false, false)).map(MarshalledEntry::getKey).collectInto(new HashSet<K>(), Set::add))
it's better to divide verification by empty row to increase readability.
It's better to divide verification by empty lines, e.g.
it's better to divide verification by empty lines, e.g.
PageObjectLogging.log("appendNewLine", "text "+content+" added to the source mode in new line", true);
PageObjectLogging.log( "appendNewLine", "text +content+" added to the source mode in new line", true);
PageObjectLogging.log("appendNewLine", "text +content+" added to the source mode in new line", true);
nice - thanks!
no need for the empty line
no need for the assertion
Maybe make this private?
Would suggest to make it safer to make this method synchronized
Maybe make this synchronized?
this can be simplified to throw new UnsupportedOperationException()
this can be simplified to throws IOException
this can be a junit exception
Should not this return a Config?
return new Config(configInput)
make method private.
MessageQueue.RegisterBankAccount_PushMessage
MessageQueue.RegisterBankAccount_TEXTMessage
MessageQueue.RegisterBankAccount_ pushMessage
I think this test might be more readable by moving the code to a separate method that takes a string and a StringBuilder object.
I think this test might be more readable by moving the code to a separate method that takes the code string and the code would be less error-prone.
I think this test might be more readable by moving the code to a separate method that takes the code string and the code would be less readable.
This should maybe be a RuntimeException?
This should be a RuntimeException, since it's more likely to be visible.
This should be a RuntimeException, since it's more like a user.
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
you can use the new Hashtable<String, String> props = new Hashtable<String, String>(context).toFile();
you can use the new Hashtable<String, String> props = new Hashtable<String, String>(context).toFile(); to avoid the if else as you prefer.
should this be the byte array?
should this be a byte array?
should this be the byte[]?
Please extract getRoles() into a variable and use the lambda expression in both places.
Please extract getRoles() into a variable and use the method reference here.
Please extract getRoles() into a variable and use the lambda expression in both places
Use assertFalse() instead?
Use _column_ with base-style.
Use _column_ with base-case column
why is this void?
why does this have to be public?
why is this void? who doesn't want to know that this is annotated as @Before
I would use to have: case "java/net/BindException": case "java/lang/Error": case "java/lang/Error": return false;
I would use to have: case "java/net/BindException": case "java/util/common/causes/MissingResourceException": case "java/lang/Error": case "java/lang/Error": return false;
I would use to have: case "java/net/BindException": case "java/util/common/causes/MissingResourceException": case "java/lang/Error": return false;
Could we please replace this by.filter(shape -> shape.getDmnElementRef().getLocalPart().equals(id))?
Could we please replace this by.filter(shape -> shape.getDmnElementRef().getLocalPart().equals(id))? This would allow us to get a doubles for the null case.
Probably better to use.filter(shape -> shape.getDmnElementRef().getLocalPart().equals(id)).findFirst().orElseThrow(() -> new RuntimeException(Level.INFO, "Could not find shape by DMNDiagramElement");
@JonathanGiles, was there guidance in the past to use the guidance?
@JonathanGiles, was there guidance in the past to use Flux or Mono for chaining?
@JonathanGiles, was there guidance in the past to use the collection type to find the language?
We should not invoke this Utils.bumpAnalyticsForStatsWidgetPromo(); but I didn't catch it.
We should not invoke this Utils.bumpAnalyticsForStatsWidgetPromo(); but I didn't for the others.
We should not invoke this Utils.bumpAnalyticsForStatsWidgetPromo(); but I didn't for the rest.
This is not autoassignment, right? reassignmentsInfo could be used as well.
This is not autoassignment?
This is not autoassignment.
Maybe add a static import for this?
Maybe add a static import for it?
Maybe add a static import for the method?
You should use some sort of synchronization here, because you use a concurrent collection in the middle of the method, can we change it to just one method call in the other? It is really ugly since you do it in a block, but it does make the code easier to follow.
You should use some sort of synchronization here, because you use a concurrent collection in the middle of the method, can we change it to just one method call in the other? It is really ugly since you do it in a block, but it does make the code clean as it is
You should use some sort of synchronization here for the polling of the task.
Guessing that the default is Object but I would really prefer to write a WARN log here.
I would add a method *getIngressTimestamp()
Guessing that this should be Object?
suggestion if (value == null ||!isFalsy(value)) {
suggestion if (value == null) {
Could return in one statement
I think we should be able to replace this with System.lineSeparator()
I think we should be able to do this by using a StringBuilder instead of a String.
I think we should be able to do this by using a StringBuilder or a String.format()
Please use {} instead of string concatenation.
Please use {} instead of string concatenation
Please use {}
should we also log the corresponding log message when it fails to complete or?
should we also log the corresponding log message in the other log files?
should we also log the exception?
This needs to be the last line of this method.
This needs to be the last line of this test.
This needs to be the last line of this test class.
There is only one log for the _all_ files. This will throw an exception if the directory doesn't exist.
There is only one log for the _all_ files. This will throw an exception if the directory already exists.
Please use log formatting
"0"?
nit: just name all the vars here?
nit: just name all the variables here?
We need to be careful with this as well. Was it intentional?
We must try to understand and use AtomicReference rather than.
We need to be careful with this as well. Was it intentional to have a separate shutdown method?
Slightly confused by the code if the hashtag is the same as the one we have in the code. Can we just move it to the if block and do the checks? The code seems to be easier to read.
Slightly confused by the code if the hashtag is the same as the key. Do we have the same in different ways?
bucket?
Put this in a static member, as it's used twice.
Put this in a static member, as it's used multiple times.
Put this in a static member, as it's used 3 times.
Doesn't this mean we can't verify the z3Loads at all?
Doesn't this mean we can never actually handle the exception?
Doesn't this mean we can't verify the z3Loads at every test case?
I don't think we need the _else_ here.
I think public methods should be removed.
I think public is not needed here
I think this is a better place to initialize the executor, since it's called in a finally block.
I would prefer that this method was renamed to shutDownDBExecutor and then it's called in a try/catch block.
I think this is a better place to initialize the executor, since it's already initialized in the constructor.
Why not just use fixture?
Why use JsonFixture?
Why use fixture?
List<String>
List<String>? :)
List<String>?
it isn't a matter of personal preference, but I would prefer this to be called as many times in the command.
it isn't a matter of personal preference, but I would prefer a static method on the parent
it isn't a matter of personal preference, but I would prefer this to be called as many times in the command and only contain the dynamic identifier.
Don't use the internal toString method.
Don't use toStringHelper as we avoid good state!
Don't use toStringHelper as we avoid good practice in tests.
@vilchik-elena Why not get rid of the accountId of 'Container'?
@vilchik-elena Why not get rid of the accountId?
@vilchik-elena Why not just get the inserted row from the function and return it instead of having the same result?
There's a "this." method which could be made private. Or we could add a new "EntityConstructor" constructor that's only used internally.
There's a "this." statement somewhere. It might be a good idea to see this one.
There's a "this." prefix elsewhere.
Can we and should we check that indexInterpolated is never null?
Can we and should we check that indexInterpolated is never null or not?
Can we check that indexInterpolated is never null and indexInterpolated is never null?
Minor: path.hashCode() can be made non-null.
Minor: you can use path.hashCode() here and below
Minor: you can use path.hashCode() here and below.
This should be: messageLabel.setVisible(logEditor.asCheckBox().getValue());
This should be: messageLabel.setVisible(logEditor.onTab().getValue());
The check should be done before the super call here.
This is not directly related and should be reverted, I think.
This is not directly related to this PR. If we change it in, let's try to create an instance of PhysicalIdTableExporter and then use it. Otherwise, this is not clear.
This is not directly related to this PR. If we change it, I think it should be in a separate commit.
Did you check this prints messages with decent grammar? Not sure, but did you mean "cluster name... service name..."
Did you check this prints messages with decent grammar? Not sure, but did you mean "cluster name..."
Did you check this prints messages with decent grammar? Not sure, but did you mean "cluster name... service name...
This is a change of behavior, but we need to make this method public since we are using it in other tests.
This is a change of behavior, but we need to make this setter for now.
in tests we use Collections.singletonList() to make it a bit cleaner.
remove local variable
remove local var
remove local variables
Let's check the exception message as well.
Let's verify the exception message?
Let's verify the exception message
I'd add braces {} to this even if it's a single line statement.
I'd add braces {} to this even if it's a single line block.
I'd add braces {} to this even if it's a one-liner, but I'd like to prefer.
Do we need the null check here?
Maybe we should check the IkStateListener too, to avoid race conditions.
Do we need the null check?
Again, I'd prefer more descriptive errors here.
Again, I'd prefer a more descriptive error message here.
Again, I think this should be: throw new UnprocessableEntityException(context, id, patch);
Wouldn't it be better to call call super.createPatientDiscoveryProxySupport() and then call AbstractPatientDiscoveryProxySupport?
Wouldn't it be better to call call super.createPatientDiscoveryProxySupport() and then call super.createPatientDiscoveryProxySupport?
Wouldn't it be better to call call super.createPatientDiscoveryProxySupport() and then call AbstractPatientDiscoveryProxySupport#createProxySupport?
Why not to use random.nextLong()?
Why not use random.nextLong()?
Why not to use random instance of ThreadLocalRandom and reuse it?
Please revert this change: this would result in the request on the UI instead of the UI because it was present in 2 different places.
Please revert this change: this would result in the request on the UI instead of the UI because it was present.
Please revert this change. This would cause errors when show warning.
@vkuchyn Thanks, @xurxpadro @viraj talked about this one, can you add all the tests?
@vkuchyn Thanks, @xurxi talked about this one.
@xupyprmv can you add all this arrays?
no reason to explicitly set to null, its default behavior
no need to explicitly set to null, its default behavior
no need for public
Not to be a little female dog, but generally good style to include the else in the same line.
Not to be a little female dog, but generally good style to include the else in the return statement: if (nullHandling.ERO_FLOAT!= NullHandling.ERO) { return NullHandling.ERO; }
Not to be a little female dog, but generally good style to include the else if in the beginning
Add ioe to the exception.
Add ioe to the return value.
Add ioe to the log.
nit: make this a final
nit: make sure the format is a /....
nit: make sure the format is a /.
Minor: can be private.
Minor: can be private?
Minor: can be private
Can you please add isDebugEnabled check?
nitpicking: You could add 'name' to the output of this filter.
nitpicking: You can use CollectionUtils.equals here and in other places.
We should only catch Exception here, and then handleAuthenticationFailure(). Please change the logging level to debug.
We should only catch Exception here, and then handleAuthenticationFailure() in the catch block.
We should only catch Exception here, and then handleAuthenticationFailure(). Please change the logging message to debug level.
The parent isn't really a member of the cluster.
The parent.list() method should not be public.
The parent.list() method should not return anything, and return notFound()
It would be better to have a method checking correctness of the lawJournalEntry that could be used here and outside the class.
It would be better to have a method checking correctness of the lawJournalEntry that could be used here and at the beginning of each test.
It would be better to have a method checking correctness of the lawJournalEntry that could be used here and at the implementations of the class.
I'm not sure if this works. Can you explain me why do we need this? I mean, this operation should be pushed into the ShortcutsService.
I'm not sure if this works. Can you explain me why do we need this?
This should be at debug.
casting to OnkyoConnection?
Definitely to put curly braces around the multiple lines, but this method becomes a lot cleaner.
casting to an OnkyoConnection?
You should be able to do this via the following: long response = executeCommand("SIE\r\n"); long currTotalSize = Integer.parseLong(response.substring(0, response.indexOf(' '));
You should be able to do this via the following: long response = executeCommand("SIE\r\n"); long currTotalSize = Long.parseLong(response.substring(0, response.indexOf(' '));
You should be able to do this via the following: int currTotalSize = response.indexOf(' ');
return new LinkedHashMap<>(fieldDirectivesMap);
We can use Collections.singletonMap here
checkNotNull
We can use getPathName(snapshotRoot) as it's a method.
We can use getPathName(snapshotRoot) as it's only used for the same path.
We can use the getPathName method as well.
I think you can avoid this method by using the Concur ReportService#getOptionals(String) method to do the actual logic.
I think you can avoid this method by using the Concur ReportService#getToo many lines.
I think you can avoid this method by using the Concur ReportService#getOptionals(String) method.
PS: If this is what the order is important, the test fails.
PS. For what its worth, the test fails here.
PS: If this is what the order is important, the test fails here.
What's the purpose of this change?
What are the implications of checking the strategy from being null?
What happens if we deprecate SweepStrategy.
The AbstractHistogram::reset method is already calling reset() and the method validates the number of elements in allHistograms, isn't it?
The AbstractHistogram::reset method is not needed.
The AbstractHistogram::reset method is already calling reset() and the method validates the number of elements.
Yup
I think this will be simpler if we change the default plot instance to Function.identity()
Yikes!
Did you mean to use null?
Did you mean to use the null case here?
Did you mean to use the null comparison here?
this two things are special afair cc @lanwen
Should we use ANTLR.DEFAULT_DOMAIN?
this doesn't seem to be possible
With the teamWfField codebase, the string in the assertion is not thread-safe and we'll have an extra _thread_ cast exception. Can we have a more descriptive name for the exception? That will not be hard to debug with the JVM optimize.
With the teamWfField codebase, the string in the assertion is not thread-safe and we'll have an extra casing effect.
With the teamWfField codebase, the string in the assertion is not thread-safe and we'll have an extra _thread_ cast exception. Can we have a more descriptive name for the exception? That way the user can easily see the problem in future.
Between should be beforeCall, not afterCall.
Between should be beforeCall.
Why do you need this?
This can now be deleted.
This can now be removed.
This can be deleted.
In other cards, title is english, so it doesn't make sense to have them in strings.xml instead.
In other cards, title is english, so it doesn't make sense to have them in public constructor.
In other cards, title is english, so it doesn't make sense to have them in strings.xml like this.
currentBundle.getId() could be null. Please add a check for null before calling getVersion.
currentBundle.getId() could be null. Please add a check for Objects.equals(currentBundle, candidateBundle.getVersion())
obsolete when naming loopvar 'currentBundle'
we can make this a static inline class
no need to make a static inline class
in a future pr we should consider moving this to the cas side
I think it should be public RouterServerSSLTest(boolean testEncryption)
I think it should be!testFramework.isTestEncryption(true)
I think it should be public RouterServerSSLTest(boolean testEncryption) to avoid code duplication.
analysisMetadata.setOrganizationsEnabled is already called on line 117 and it really does not belong to the method
analysisMetadata.setOrganizationsEnabled is already called on line 117 and it really does not belong to the method name. Should be protected.
analysisMetadata.setOrganizationsEnabled is already called on line 117 and it really does not matter. Because you are not calling it twice, maybe you should inline it?
Should probably be a warning?
Should probably be a warning or debug?
Should probably be a warning or warn?
Redundant space after cast.
As above, the alternative can be null.
Redundant empty line.
No need to call copy() here
No need to call copy() here.
No need to call copy()
add "this" qualifier
add this(this.report)
add this to field or something.
I don't think this would work. You need to add the color to GerritTask above.
I don't think this would work. You can get the state of the GerritTask.
Why did you change this to return Color?
Is this line needed?
I would remove this line, if it's no longer needed
I would remove this line since it's not doing anything?
better return action!= null && doExecute(action, false)
better return action!= null && doExecute(action, false);
better return action.isExecute(action, false);
suggestion if (prev.compareTo(shortened) >= 0) {
suggestion if (prev.equals(shortened) >= 0) {
suggestion return null;
What is the purpose of this line?
messageEt.getText() is null safe. You should use a TextUtils.isEmpty method.
messageEt.getText() is a String.
Should remove, and use similar functionality in CoreAuthenticationTestUtils
remove, and use similar functionality in CoreAuthenticationTestUtils
Remove, and use similar functionality in CoreAuthenticationTestUtils
I think we have some constraints regarding the target URI? (e.g., exactly one? at most one?)
I think we have some constraints regarding the target URI? (e.g., exactly one, exactly one? at most one?)
I think we have some constraints regarding the target URI? (e.g., exactly one? at most?)
Move this logic to a method and call remove
Move this logic to a method and reuse it.
Move this logic to the Config class instead of duplicating it.
nit: this can be static
nit: this is static.
nit: this is static
should be synchronized
should be void
should be private
no need for public
no need for public please
no need to implement this?
Would be better to check that the field is final.
Would be better to make the constructor private and have a static factory method
Make final.
It should beHSMGetStorageDomainsList, but not the CoAP.
It should beHSMGetStorageDomainsList, but not the List
It should beHSMGetStorageDomainsList, but not the CoAP
You'd better use {} for the string message
You'd better use the enum here.
You'd better use {}
Suggestion: Once you make these asserts before the call to the method, you'll be able to remove the redundant assertions.
Suggestion: Once you make these asserts before the call to the method, you'll be able to get rid of the redundant null checks.
Suggestion: Once you make these asserts before the call to the method, you'll be able to get rid of the redundant Assert.
I'd use try-with-resources to make it cleaner
I'd prefer to use a string constant instead.
I'd prefer to use a stringbuffer instead. We will get rid of the FileReader in other places.
Better to use isEmpty()?
Better to use isEmpty (or isEmpty) rather than!= 0.
Better to use isEmpty (or isEmpty) instead of size checking.
Do we need the BlueIdentifierGenerator here?
Do we need the BlueIdentifierGenerator?
Do we need to use BlueIdentifierGenerator?
Unnecessary call to super
Unnecessary call to super()
Unnecessary call to super();
this can be simplified to probeIndexBuilder.reset();
this doesn't need to be public
java probeIndexBuilder.reset();
Could do project.getGroups().forEach(Group t -> tags.add(t.getName()));
project.getGroups().forEach(Group t -> tags.add(t.getName()));
Could do project.getGroups().stream().map(Group t -> tags.add(t.getName()));
Again, you're OK with this, but I was trying to point out why.
Again, you can use one string literal here.
Again, you're OK with this, but I was trying to point out why _ twice_ in one line.
This looks like it should be reused.
Should this be reused.
Should this be reused?
the vds load blanacer
the same, why not use vds load balancer here?
the same, why not use vds load blanacer
This assertion should also be inside gcDeletedTarget
This assertion should be inside gcDeletedTarget
This assertion should also be inside gcDeletedAction
No need to call hasDlmsMessageListener here.
No need to call hasDlmsMessageListener() here.
No need for lines 89-90.
then test will fail?
is this test going to work properly?
is this test going to work right?
Why is this needed?
Why does this need to be synchronized?
Why does this need to be done?
Maybe just return TVAElementType.BRAND;
Maybe we should make this private.
Maybe just return TVAElementType.BRAND?
why 40 as a limit?
why 40 as an default limit?
Why 40 as a limit?
You have the builder pattern already for this.
You need to validate the tokenCredential is not null, otherwise you'd get an NPE anyway if you send it to the builder.
You have the builder pattern already for your builder, but you're still using it in the builder pattern.
If we call this method 3 times and 20 times, we want to call it even if there is some sort of constant.
If we call this method 3 times and 20 times, we want to call it even if there is some sort of constant called TAG_VALUE.
If you call this method 3 times and.clear() you should call it in.finally block.
suggestion createGrantAuthorization(PROCESS_DEFINITION, ONE_INCER_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY); Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
suggestion createGrantAuthorization(PROCESS_DEFINITION, ONE_INCIDENT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY); Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
suggestion createGrantAuthorization(PROCESS_DEFINITION, ONE_INCE_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY); Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
The following code would be better readable if you change the method to be like this: try { fieldStateValidator.validate(field); fail("IllegalStateException expected"); } catch (IllegalStateException ise) { fail("IllegalStateException expected"); }
The following code would be better readable if you change the method to be like this: try { fieldStateValidator.validate(field); fail("IllegalStateException expected"); } catch (IllegalStateException ise) { //... }
The following code would be better readable if you change the method to be like this: try { fieldStateValidator.validate(field); fail("IllegalStateException expected"); } catch (IllegalStateException ise) { // This must be tested. }
Why change this to 20 seconds?
Just use 20 seconds?
Why change this?
suggestion return influxDB!= null && (influxDB!= null) || isConnected() && influxDB!= null;
suggestion return influxDB!= null && (influxdb!= null) || isConnected() && influxDB!= null;
suggestion return influxDB!= null && (influxDB!= null) || isConnected() && influxdb!= null;
Cosmetic: Braces on new line, please!
Cosmetic: Braces on new line, please. :)
Cosmetic: Curly braces on new line, please.
Should be _f_.bind(o)_
Should be renamed to something like schema.
Should be namespace instead of f
why log an exception if the user does not have enough information.
why log an error?
use {}
This is where you added the listener to setViewDataFromServer
This is where you added the listener to setViewDataFromServer it is not set to false.
This is where you added the listener to setViewDataFromServer it is not set to true.
i don't think this needs to be public?
i don't think this needs to be public
i don't think this needs to be public.
Why change this?
Use BranchManager.getSafeConstructorName() instead.
Use BranchDef.getSafeConstructor or change this to an interface.
This method could be static
This method could be static as 'extract(second, timestamp)'
Why two separate lines?
shouldn't this be if (threadFactories.isEmpty()) { checkFactoryForLeaks(factory); }
I wonder if it would be better to print the stack trace before the test?
I wonder if it would be better to print the stack trace as well, like the other ones.
We don't need the mFeaturedImageWidth variable either.
Should we just use dpToPx instead of getResources().getDimensionPixelSize()?
We don't need the mFeaturedImageWidth variable at all.
Use map() with filter()
use map() with filter()
Use map() with filter() and filter()
Oh, update, and this one is a version view, do you have a Mac to do it? If not, then you need to call it BoxLayout.
Oh, update, and this one is a version view, do you have a Mac to do it? If not, then call create a new one, while it has a version version.
Oh, update, please
+ desc
description = \"%s\" Active
nit: @Nullable
remove
remove this
remove public
Please add a second sentence here, e.g.: "Dosage Adjustment Percentage: " + nDosingInstructions.class"
Please add a second sentence here, e.g.: "Dosage Adjustment Percentage: "" + disnameingInstructions.class"
Please add missing assertEquals here
> Sorry, I missed this for the earlier patch set. The return type should be Map<String, Object>, and the cast to Map<String, Object>.
> Sorry, I missed this for the earlier patch set. The return type should be Map<String, Object>, and why is it a Map<String, Object>.
> Sorry, I missed this for the earlier patch set. The return type should be Map<String, Object>, and the cast to Map<Object, Object>.
Why not just'return true;'?
Why not just'return true;' like in the other apply?
Why do we need an explicit timeout?
suggestion System.arraycopy(configuredArgs, 0, allArgs, 1, inputCount);
suggestion System.arraycopy(configuredArgs, 0, allArgs, 1, argCount);
suggestion System.arraycopy(configuredArgs, 0, allArgs, 1, argsCount);
This test has failed before you check that namespace does not exists. We should check if it exists before creating the namespace.
This test has failed before you check that namespace does not exists. We should check if it exists before using the namespace.
This test has failed before you check namespaceBuilder.toString() was called.
I thought this was to be debug to prevent unwanted data from appearing in the log.
I thought this was to be debug to prevent unwanted data from appearing in the logs.
I thought this was to be debug to prevent unwanted data from appearing in the logging.
missing "protected AddCinderStorageDomainCommand(Guid commandId)"
missing "protected AddCinderStorageDomainCommand"
please add a "protected AddCinderStorageDomainCommand" method.
Copied log message: java @Override public List<Pool> createPoolsForSubscription(Subscription sub) { return createPoolsForSubscription(sub, new ArrayList<Pool>()); }
Copied from the Java 8 class: java @Override public List<Pool> createPoolsForSubscription(Subscription sub) { return createPoolsForSubscription(sub, new ArrayList<Pool>()); }
Copied for un-sub list...
suggestion if (authorizer.getHiveAuthorizationTranslator() == null) {
suggestion if (authorizer.getHiveAuthorizationTranslator()!= null) {
Objects.requireNonNull(tableName)?
I think it would be better to do this in a more explicit way. We could keep the way the user of the read() method and do the check within the get() method. It would be much more clean if it was done in the read() method and used in the read() method.
I think it would be better to do this in a more explicit way. We could keep the way the user of the read() method and do the check after the read() method.
I think it would be better to do this in a more explicit way. We could keep the way the user of the read() method and do the check within the get() method. It would be much more clean if the check were moved within the get() method and then it would be a good thing to do.
The getter could return a Flux, which is public and doesn't need to be public.
The endpoint type is transient, but the client can't modify it.
The getter could return a Flux, which is public and doesn't need to return a Flux.
The BackendClusterFeatureHelper.map() method should be extracted to a separate class.
The new BackendClusterFeatureHelper.map(feature, null) can be extracted to a constant
The new BackendClusterFeatureHelper.map(feature, null) can be extracted to a constant.
As there was no valid reason to use a boxed type boolean here.
As there was no need to use a primitive boolean here; you can use Boolean instead of Boolean
As there was no valid reason to use a primitive boolean here instead of Boolean, can you use that here?
You could get a ClassCastException here if fAspect is not a Class.
You could get rid of the isAssignableFrom and just use resolve.getClass().isAssignableFrom(fClazz.getClass()) here.
You could get a ClassCastException here if fAspect is not a Class. It's a way of doing this without casting.
While you're here, you might as well merge the two isValid() calls and make it have the same effect.
While you're here, you might as well merge the two isValid() calls into one.
While you're here, you might as well merge the two isValid() calls with a single equals instead of a single boolean.
This should be able to remove a membership that matches the patient, if there is multiple for the same patient then you can add it
This should also be able to remove a membership that matches the patient, if there is multiple for the same patient then you can add it
This should also be able to lookup the membership with the patient, if there is multiple for the same patient then you can add it
Should be public
Shouldn't we create a super method here?
Shouldn't you create a super method here?
How is this expression different from "this"?
How is this expression different from "this."?
How is this expression different from "this"?
Do we need to check if getMarkerSets() exists?
Do we need to check if getMarkerSets() is not null here?
Do we need to check if getMarkerSets() is not null?
getVm() is marked as @Nullable so no need to specify it here.
getVm() is marked as @Nullable so no need for the getter.
getVm() will be null if getParameters().getInterface() is not known as an optional.
This is a super class, not a public.
This is a super class, so I'm not sure, but is this supposed to be public?
It is a super class, not a public.
Isn't this public?
Isn't this a bug fix?
Nice change.
s/Checkpoints/CheckpointId
s/Checkpoints/Checkpoints
Duplicated code.
Please create a new line before the return statement
Please create a new line for the functional style.
Please create a new line before the if statement
Such exception is not a good practice. Can you log it?
Such exception is not a good practice. Can you log the exception?
Can you log the exception to cloud.
This will break the loop, or does it affect the iteration?
This method does not seem to be used. The typical use case is to add an element to the tail.
This will break the loop, or is it not possible to use the tail() method in the first place?
Why is the call to flush()?
Why is the flush method public?
Why do we need to call flush here?
I think I'm thinking if we should add another method that checks if first character is an anchor, and that's the case.
I think I'm thinking if we should add another method that checks if first character is an index, then calls to.filter(index)
I think I'm thinking if we should add another method that checks if first character is an index, then calls to.filter() and then using that.
Did you mean.isEmpty()?
Did you mean 'not'?
Did you mean 'not'
Not related to this PR, but consider using the new UISource.setWidget(String) method instead of repeating the same code.
Not related to this PR, but consider using a new method here instead of repeating the same code.
Not needed.
End of exit code is already hard to understand. Should we use a little more generic naming?
As above, I don't think you should be using a warn log level, as it's pretty important for debugging.
As above, I don't think you should be using a warn log level, as it's pretty important.
nit: This could probably be a static method.
nit: This code is duplicated in 3 places. Maybe have a static method?
nit: This code is duplicated in 3 places.
Now it's <code>@CheckForNull</code>
DRY use <code>this(parameterDefinitions!= null? parameterDefinitions : new ArrayList());</code>
DRY use <code>this(parameterDefinitions!= null? parameterDefinitions : new ArrayList();</code>
Similarly
ImmutableSet.of() would be better here.
ImmutableSet.copyOf() would be better here.
"handler" -> "handler"
Add a check for null
"handler" is a String and should be renamed to addRegistration
Do we need this else?
"Invalid hardwareId" -> "No hardware id
Add the current error message.
Seems like this is only required if the window is set to deflated or deflated
Seems like this is only required if the window is set to deflated or deflated?
For readability, can we store this into a field and reference it in the constructor?
Shall we rename this to isSecured (and its not a separate method)
Shall we move this code to the new master?
Shall we rename this to isSecured (and its not a role)
I don't think you need the public modifier here.
I don't think you need this extra variable.
I don't think you need the extra MapEntries here.
since this happens before canDoAction, getVdsGroup() can be null
since this method has no async flag, getVdsGroup() can be null
since this method is called from inside a single thread, it could be better to move the logic to an internal method.
Should this be "VM 1 should not have a boot disk attached"?
Should be "VM 1 should not have a boot disk attached"
Should this be "bootDiskVm1 should not have a boot disk attached"?
throw exception
throw exception?
throw error
You can make this constructor private.
You can make this constructor protected.
You can make this protected.
Is this because of the name of the test?
Is this because of the installation?
Is this really needed?
Please make this protected.
Please inline this protected.
Please inline this method.
Can you also verify that the result is an instance of MemoryHistory?
Can you also verify that the result is not an exception?
Can you also verify that the result is an instance of ProcessHistory?
I think we should depend on the fact that this is an instance of the class.
I think we should depend on the fact that this is an instance of the class rather than using a singleton...
Can we pass the assertion in?
If insertType is a string, we need to use the method.
If insertType is a string, we need to use the encoder to handle it.
If insertType is a string, we need to use the constructor.
Redundant braces
Redundant braces.
s/bcast/StringUtils/
what's the point of time limit? Can you show a time in LOST state?
what's the point of time limit? Can you show a time in LOST state, e.g. 30 seconds or so?
what's the point of time limit? Can you show a time in LOST state, e.g. 30 seconds or something?
Are we OK to leave this here?
Do we want to log the amount of files? How about logging in this case?
Do we want to log the amount of files?
As I see that in other method, the parameter is also in the log. Consider adding a method with List<String> typeInSearchField(String content, int length).
As I see that in other method, the parameter is also in the log. Consider adding a method to typeInSearchField(String content, int length).
As I see that in other method, the parameter is also in the log. Consider adding a method with parameter.
You should do that in the constructor, or store it in a field, so that the user knows what they want to do
You should do that in the constructor, or store it in a field, so that the user knows what they want to do with the problem.
You should use a button, not a "void".
Not sure if it's worth changing this, but why tc.typeClasses() instead of just TypeClass?
Not sure if it's worth changing this, but why tc.typeClasses() instead of just getRandomTypeClass()?
Not sure if it's safe to use cast(ConstT) instead of TypeClass?
Curious what happen if protocol v2 is not valid?
Curious what happen if invalid format result is reached?
Curious what happen if protocol v2 is not set?
are you sure this is not the right exception?
are you sure this is right?
are you sure this is not the right abstraction?
Could you please use jobContext.getPhysicalSchemas() here?
Could you please use jobContext.getAllPartitions() here?
consider using Streams here
Should be externalized.
Should we add network partition too?
Should this be externalized?
Minor: I would use ((AvroMapper<D, M>) getMapper(input.getClass())).toAvro(schema, input); instead.
Minor: I would use ((AvroMapper<D, M>) getMapper(input.getClass()).toAvro(schema, input); instead.
Minor: I would use ((AvroMapper<D, M>) getMapper(input.getClass()).toAvro(schema, input));
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file directory twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file file every time you call getWidth
Can be mutated by the caller.
Can be final.
Can be Collections.unmodifiableList here.
I think these should be deterministic by default.
I think these should be private
File
Why do we need to check one?
Is it OK to re-use qryMgr.enable() here?
Why do we need to check for a not-null qryMgr?
You can return the null object directly, no need to check other.getName().equals(name)
You can do return other.getName().equals(name);
you can return the null object directly, no need to check other.getName()
Same here, join() needs to be done afterwards too
Format the code, please.
Same here, join() needs to be done twice
I think it might be better to have a method like createTemporaryTable(boolean shortenName) and call it from these two places where the table name is created.
I think it might be better to have a method like createTemporaryTable(boolean shortenName) and call it from these two places.
I think it might be better to have a method like createTemporaryTable(boolean shortenName) that takes in TableMetastore, and to make LocationHandle clearer that way.
There is no need to check for null here. You can simply return an Optional.
There is no need to declare type on RHS, you can simply return null here.
There is no need to check for null here. You can simply return null at this point.
Don't you need to keep this synchronized?
Don't you need to keep this synchronized
Why synchronized?
Can you have an @After method that sConnection is more reliable?
Can you have an @Before method that sConnection is more reliable?
Can you have an @Before method that sConnection is private?
Are you sure that "== null" is correct?
this block of code is almost the same as the one in condition. Maybe extract to a method?
this block of code is almost the same as the one in the if condition.
would it be more robust to set the value of appraisal instead of UTC?
would it be more robust to set the value of Appraisal instead of DateTime?
Also add an assertion for the parameter value of the config?
why not move it outside the if statement?
why not move it to DestroyVmCommand?
why not just move it to the else block?
I am not quite sure about usage of findInferred here. If we are searching for an object, this should be taken into account. Or does it justify to use the api here?
I am not quite sure about usage of findInferred here. If we are searching for an object, this should be taken into account. Or does it justify why?
I am not quite sure about usage of findInferred here. If we are searching for an object, this should be taken into account.
can't this be more readable?
can we use more descriptive name for cellCount?
can't this be false?
nit: there's a weird code change here and in the other tests, but I'm not sure.
nit: there's a weird code change here.
nit: there's a weird code change here and in the other tests.
Can we get rid of the "n" variable here?
Can we get rid of the second variable?
Can we get rid of the "n" variable altogether?
I would use better return typeAlternatives.stream().filter(v -> list.toArray()).toArray(new Type[0])
I would use better return typeAlternatives.stream().filter(v -> list.toArray(v)).toArray(typeAlternatives.stream())
I would use better name(typeAlternatives) as the first one
Can we use method reference here? I think it's only used in the ctor.
Can we use method reference here? I think we need orElse.
Can we use method reference here?
For a failure, I think it's better to do something like: String lang = getScriptLanguage(); if (scriptEngine == null) { throw new ScriptException("Script language has not been chosen on the UI, ensure you set language field in JSR223 Test Element: " + getName()); } if (scriptEngine == null) { throw new ScriptException("Cannot find engine named: '"+lang+"', ensure you set language field in SYSIBM.java, ensure you set language field in SYSIBM.java, the script will be interpreted as a groovy script"); }
For a failure, I think it's better to do something like: String lang = getScriptLanguage(); if (scriptEngine == null) { throw new ScriptException("Script language has not been chosen on the UI, ensure you set language field in JSR223Test Element: {}", getName()); } if (scriptEngine == null) { throw new ScriptException("Cannot find engine named: '"+lang+"', ensure you set language field in DataSchema.format( "%s %s", lang)); } return scriptEngine;
For a failure, I think it's better to do something like: String lang = getScriptLanguage(); if (scriptEngine == null) { throw new ScriptException("Script language has not been chosen on the UI, ensure you set language field in JSR223 Test Element: " + scriptEngine); } Otherwise log warning message in case of failure.
The only difference between the two calls to permitCmAndStackUpgrade(currentVersion, newVersion) and componentBuildNumberComparator.compare(currentImage, image, buildNumberKey)); should be moved here.
The only difference between the original and the componentBuildNumberComparator is that the code doesn't have to be public. I think we should remove it now.
The only difference between the two calls to permitCmAndStackUpgrade(currentVersion, newVersion) and componentBuildNumberComparator.compare below. What do you think?
Braces for one-liners.
Braces for new code.
Braces for one-line statements.
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf(...) instead of new Long() - always for performance reasons
use Long instead of new Long() - always for performance reasons
the return type shouldn't be restricted in this case.
the return type shouldn't be needed.
please change this to get the report total size down
Can be replaced with functional style Java, as per example given in EpdqStatusGenerator: <LINK_0>
Can be replaced with functional style Java, as per example given in EpdqStatus.
This whole block can be replaced with functional style Java, as per example given in EpdqStatusGenerator and a call.
Why do we need this?
I'm not sure about this, it's a good idea to use findElements in the AreaRender, for example, to do this.
I'm not sure about this, it's a good idea to use the Handler classes that use these fields.
Use CollectionUtils.isEmpty() here and in the CommandsPlugin
Use CollectionUtils.isEmpty() here and in the CommandsFactory class
Use CollectionUtils.isEmpty() which checks the value
This can be simplified to "return true;"
This can be simplified to this: boolean value = true;
This can be simplified to this: boolean result = true;
should "streamName" be declared final?
please rename it to streamName
please rename to streamName
A flip!= 1
A flip!= 0 would be better here?
A flip!= 0 would be clearer
Wouldn't this need to change to List<PropertiesParameter> unmodifiableList = m_parameters.values().toArray(new PropertyParameter[m_parameters.size()])?
Wouldn't this need to change to List<PropertiesParameter> or is this API fixed?
Wouldn't it be better to change the order of the values to...size()?
Why are you assigning 0 to elementOnPage, as you assign some value again in the if?
Why shouldprotected be used only for testing?
Why shouldprotected be used here?
why should this be true?
why should we be testing the behavior of this method?
Please prefer to use static imports.
This should be implemented using org.apache.commons.lang3.StringUtils.hasBlockCompressedExtension(path)
This should be static
This should be implemented using the new Utils method.
Is there any risk of removing this? Since flush() is a "public" method, I think most likely the call to super.close() should be outside of the try/finally block
Is there any risk of removing this? Since flush() is a "public" method, it might be better to move the code over.
Is there any reason to remove this?
what do we need this assert?
what do we need this variable?
no need to call getSyncPoller() here
It seems like you compute file path here. Take a look at intellij inspection job.
It seems like you compute file path here. Take a look at intellij auto-formatting. Also you may want to rename file path to selectorPaths (without the function name), so you might getErlangModulePathsDefault).
It seems like you compute file path here. Take a look at intellij auto-formatting. You should be able to reuse one file, but not one time.
Should we throw an exception to let the caller handle the exception? At least we should log an error with a message.
Should we throw an exception if the repo doesn't exist?
Should we throw an exception if the repo doesn't exist? In this case, should we log and throw?
Let's rename the field to: java this.batchableGridDialect = (QueryableGridDialect<T>) asQueryableGridDialectOrNull( gridDialect );
Let's rename the field to: java this.messageableGridDialect = (QueryableGridDialect<T>) asQueryableGridDialectOrNull( gridDialect );
Let's rename the field to a more meaningful name.
This doesn't work. These changes aren't included in the buffer.
This doesn't work. These changes aren't needed. There's a lot of string concats in this class.
This doesn't work. These changes aren't included in the "UTF-8" buffer size.
Parameter annotation is not needed here
Parameter should be marked @Nullable
NotNull
since this is a constructor it should be private.
since this is a constructor it should probably be private.
Can we encapsulate this logic in a method? I know it's not part of this PR, but it makes it more readable.
Don't use string concatenation with +.
Don't use string concatenation with +
I do not think you need to use parameterized logging.
Have you considered making isHandleRenamedFiles final?
why public?
Have you considered making it package private?
I don't see a reason to return an Iterable here instead of the more specific return type Set. The result is very small and a lazy evaluation is not necessary (which could justify returning an Iterable). Returning a new set seems more complicated than that.
I don't see a reason to return an Iterable here instead of the more specific return type Set. The result is very small and a lazy evaluation is not necessary (which could justify returning an Iterable). Returning a modifiable set is not a good idea.
I don't see a reason to return an Iterable here instead of the more specific return type Set
elements.stream().map(Tree::cast).collect(Collectors.toList())
elements.stream().map(Element::cast).collect(Collectors.toList())
use collect instead of collect
.negation =!negation;
.negation =!negation
Isn't logic the same as condition?
I think you mean "Liquid Glass"
I don't think you mean "Liquid Glass"
I don't think "Liquid Glass"
This is missing <LINK_0>
This is removing the public modifier from hashCode(). I'm not sure we should be using it here.
This is removing the public modifier. I'd go ahead and change the implementation to call it, but I'm not sure.
not needed (the value is already added in the DB)
not needed (the value is already added in the vmBase). removeVmDevices
not needed, already done in line 89
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.removeCallbacksAndMessages(null) instead. Done in PR.
> Use this.removeCallbacksAndMessages( null) instead. Done in Patch set 2
I think we should check for null before accessing the map.
I think we should check for null before accessing the map, since it is possible that the value is not null.
I think we should check for null before accessing it
:bulb: we should get a null check before accessing the activity.
:+1: for using a static method.
:+1: for using a nested if in these two methods.
You need to check that the service was actually created
You need to check that the uuid are the same
Why do you need this change?
Filter(PsiErrorElement.class) could be private.
Filter(PsiErrorElement.class) could be implemented in a loop
Filter(PsiErrorElement.class) could be implemented in this method.
Mapper should be created in constructor
.map(moduleMetadata::deserialiseModule).
.map(moduleMetadata::get...)
Should be longValue(), not longValue()
nit: longValue() is not needed here
Should be longValue()
Should be noopTracerFactory.
Should this be public?
We can call bind(..) directly.
Please keep the indentation consistent.
Please be consistent to use the indentation of parameters (for instance variables).
Please be consistent to use the indentation of parameters (for instance parameters).
Access is not needed. You need AbstractUndertowSecurityProvider.
Access is not supposed to be atomic. You need AbstractUndertowSecurityProvider.
Access is not protected. You need to see it from the super class.
bad id.
bad field name.
bad field name
Could be replaced by Pager.single().
Could this be replaced by Pager.single().
public
Wouldn't this be better JSONObjects.of(job) so we don't have to check job.getName() for null?
Wouldn't this be better JSONObjects.of(job) so we don't have to check for null?
Wouldn't this be better JSONObjects.of(job.getName())?
This method is a public DRCatalogDiffEngine, so you need to override it.
This method is a public DRCatalogDiffEngine(Catalog localCatalog, DRClusterDTO remoteCatalog) method, so you need to override it.
This method is a public DRCatalogDiffEngine.
suggestion throw new OrmException("Cannot upgrade from " + curr.versionNbr + "; manually run scripts from" + " <LINK_0>");
suggestion throw new OrmException("Cannot upgrade from " + curr.versionNbr + "; manually run scripts from" + " <LINK_0>" +
Please don't reformat this file. It's hard to read the source code.
Duplicated code, please move to static method.
Duplicated code, please move to constant.
Duplicated code, please introduce a method.
This could be protected.
This could be a static method.
This could be a package protected method.
@krivera-pentaho Kris, is there any reason to do it? <LINK_0>
@krivera-pentaho Kris, is there any need to define this as a string?
@krivera-pentaho Kris, is there any reason to do it? It's the same error that you expect on the line above.
would be easier to read if you rename this variable to bundles[]
would be easier to read if you rename this variable to bundles[i].getSymbolicName() and use it instead of loop
should be bundles.length == 0?
this does not call doOnEach
This does not call factory.apply()?
This does not call factory.apply(...)
Consider @Restricted(NoExternalUse.class), I see no reason to make this public.
Consider @Restricted(NoExternalUse.class), I see no reason to make this public API.
Consider @Restricted(NoExternalUse.class)
Why is the change here?
Why are you using the deprecated Version?
Why is the change to the deprecated method?
Maybe we can move it to @Before or @BeforeClass?
Maybe we can move it to @Before or @AfterClass?
Maybe we can move it to @Before methods only.
If we use config.getCoordinatorSegmentBytes() every time, we will get it again. Need to double check if it is a byte array.
If we use config.getCoordinatorSegmentBytes() every time, we will get it again. Let's try to avoid these problems.
If we use config.getCoordinatorSegmentBytes() every time, we will get it again. Need to double check if it is a byte[].
I think we should use ArgChecker.isQuantity() here.
I think we should use java.util.Math.toIntExact(getValue(), delta)
I think we should use java.util.Math.toIntExact(getValue(), delta, 0, getMinimum());
Can you make JsonReader a class-private rather than creating a new instance?
Can you make JsonReader a class-private (no need to instantiate a new object each time)?
Can you make JsonReader a class-private (no need to instantiate a new instance each time)?
is it needed for this PR?
is it needed for this purpose? Looks like workspace is already being used in the code
is it needed for this purpose?
trace?
trace(element.getName())
trace
I suggest you create a private method to initialize the metrics. It will help to avoid copy/paste issues like this.
I suggest to call this method as the other names as well.
I suggest you create a private method to initialize the metrics
+
Same here (and in other classes)
spaces around +
Can we just check that the customParams is not null?
Can we just use Collections.unmodifiableMap( customParams) here?
Can we just store a copy of the map?
If the name appears to be unused, then this can be removed.
If the name appears to be unused, then this can be dropped.
If the name doesn't exist, JavaClass name should be Disk.
This should be the setIndicatorsEnabled(debugging) method.
This should be the setIndicatorsEnabled(debugging) method, the exception could be more explicit.
We can set the variable as final.
why do we need to pass Function<String, Integer> here? getValue(name, int defaultValue) simply returns Integer.parseInt(stringVal)?
why do we need to pass Function<String, Integer> here?
why do we need this?
@vilchik-elena Why not get the default charset from Readables?
@vilchik-elena Why not get rid of Readables.wrap?
@vilchik-elena Why not return a ReadableSet directly?
use assertThat instead of assertEquals
there is no need to declare the InternalSerializationServiceBuilder
there is no need to mock
Why do we need this line?
Why do we need this line? Does this work?
Can we keep this line of code?
This while loop doesn't need to be the loop inside the while condition.
This while loop doesn't need to be outside the loop.
This while loop doesn't need to be the loop inside the loop.
Same as above, you could probably remove the getter and return directly
Same as above, you could probably remove the getter altogether and just make the return type of getSources() for you.
Same as above, you could probably remove the getter altogether and use getter for getElement.
I think we shouldn't change the existing behavior here. In current line we may get the same property from the system property (to separate the current one).
I think we shouldn't change the existing behavior here. In current line we may get the same property from the current one when opening the current one.
I think we shouldn't change the existing behavior (from the original).
suggestion logger.info("[GET] {}", docsUri);
@xupyprmv I don't think this is necessary
@xupyprmv I don't think this should be debug
These two constructors should probably delegate to the other constructor.
These two constructors should delegate to the other constructor.
These two constructors should probably delegate to the other constructor too.
Is this being used? Doesn't determineTerminalState return a statusFlow.get() instead?
Is this needed? Doesn't determineTerminalState return a statusFlow.isCompletedState()?
Is this being used?
Avoid the use of swtDefaults(). fillDefaults() and explicit alignment makes the layout logic easier for others to read. applyTo() is preferred over create(...) when attaching to a control since it's easy to generate a ClassCastException if you mistype this and omit the BEGINNING state.
Avoid the use of swtDefaults(). fillDefaults() and explicit alignment makes the layout logic easier for others to read. applyTo() is preferred over create(...) when attaching to a control since it's easy to generate a ClassCastException if you mistype this and omit the BEGINNING flag.
Avoid the use of swtDefaults(). fillDefaults() and explicit alignment makes the layout logic easier for others to read. applyTo() is preferred over create(...) when attaching to a control since it's easy to generate a ClassCastException if you mistype this and omit the BEGINNING flag. What do you think?
Shoudn't we use try-catch here? Is there any reason for null?
Shoudn't we use try to avoid NPE here?
Shoudn't we use try to avoid NPEs here?
@tsr-thulio I think this should be: if (!this.supportsSerializationNatively) { MessageValues messageToSend = this.supportsSerializationNatively(message); }
@tsr-thulio I think this should be: if (!this.supportsSerializationNatively) { MessageValues messageToSend =... }
@dalifreire why this extra parentheses?
s/in/is
s/in/is/
s/Be/Been/
why not public BiMap<@Nullable String, Integer> getMap() {?
... if not a BiMap, requested to be an immutable BiMap<@Nullable String, Integer> getMap()
... if not a BiMap, requested to be an immutable BiMap.
This method should be private.
Why public?
This method can be private.
This and the next tests use assertThat(client.getConfiguration("system_palantir")).thenReturn(new KsDef("system_palantir", "", ImmutableList.of())); for brevity
This and the next tests use assertThat(client.getConfiguration("system_palantir"))
I think this and the next test will be a bit better as a separate test case for this case.
@lautarobock Why this change?
this.print(baos); should be moved outside the if/else
@lautarobock Why this?
I don't understand how this can work with null cache parameter.
I would prefer this to be readSafely instead of check in getFilter
I would prefer this to be readSafely instead of check if not null.
Not sure if this is necessary, but I think it's more readable to leave the default format of the string in context.
Not sure if this is necessary, but I think it's more readable to leave the default format of the string in context.getString() rather than using the string resource.
Not sure if this is necessary, but I think it's more readable to leave the default and avoid the string being saved.
Sorry for being picky, but I think this should be: if (!validBuffer && (this.address == null || this.address.equals(this.address)) { messageChanged(); }
Sorry for being picky, but I think this should be: if (!validBuffer && (this.address == null || this.address.equals(this.address)) { messageChanged(); } return this;
Sorry for being picky, but you can use this instead: if (!validBuffer &&!this.address.equals(this.address)) { messageChanged(); }
do do system.out println rather than System.out
do do System.out println rather than System.out
do do system.out println rather than println
NoSuchElementException is more accurate
NoSuchElementException is more appropriate
log.debug here and below
Does this create a new lambda at all? Doesn't it have an effect?
Does this create a new lambda at each event?
Does this create a new lambda at all?
nit: this method can be private if we keep it as is.
nit: this method can be private unless there is a immediate need for it
nit: this line can be removed
this can be removed, we can just try to get the format from the config
this can be removed, we can just try to get the format from the file.
this can be removed, we can just try to get the format from the config.
Perhaps there's a factory for this?
Perhaps we can log the exception here?
Should we log the error message here?
This should be using createSimpleManager, as it is a constant in the rest of the code.
This should be using try catch block and returning isInitialized
This should be using createSimpleManager, as it is a constant in the code base
Redundant, sessionInfo.getLiveUrl() can be removed
Redundant, sessionInfo.getLiveUrl() can be done here
we need to remove these?
could be a static constant for this
could be a static final variable
String.format
These local variables are final. If they start with a single value, then these variables are final.
These local variables are final. If they're only used once, you can use a private final variable.
These local variables are final. If they start with a single value, then these variables are too hard to read.
I think it would be better to show the wizard title.
I think it would be better to show the wizard title in the title.
I think it is better to show the wizard title.
Nit: We can just use _kafkaProducer.send(..) here to call this (and the one below) from Optional.empty().
Nit: We can just use _kafkaProducer.send(..) here to call this (and the one below) from these 2 methods.
Nit: We can just use _kafkaProducer.send(..) here to call this (and the other places in this class) to avoid the need for the getter.
Should this be marked @NonNull?
Should this be marked nullable?
Should this be initialized in the constructor?
this method should be called in onUnrecoverableError(exception, UserAction.REQUESTED_STREAM, NewPipe.getNameOfService(serviceId), url, errorId);
this method should be called in onUnrecoverableError().
this method should be called.onUnrecoverableError()
return data.length > 1024?
<LINK_0>
return data.length > 1024 * 1024
Minor: if you can name the metric name as String to be consistent with the rest of the codebase, this makes it more readable.
Minor: if you can name the metric name as String to be consistent with the rest of the code.
Minor: if you want to name the metric name as well, perhaps even better.
static import
use static import
to remove static
Is this method used anywhere?
Is this needed? Doesn't determineTerminalState return the chargeEntity?
Is this needed? Doesn't determineTerminalState return a status flow?
The method is already called in Line 109.
The method is already rather complex. No need to loop through the iterator.
The method is already rather complex.
Needs to be >= 0
java return (( dirty)!= 0;
java return (( dirty) == 0;
This should be false.
This should be true.
This should be inside of the method.
Do we really need this method public? It looks like it doesn't really matter.
Do we really need this method public? It looks like it doesn't actually do anything.
Do we really need this method public? It looks like it doesn't make sense to have this private.
Does this method need to be public?
Does this method need to be public?
accessor method?
Same here. It's more readable when part of deserializeValue
Same as above. It's more readable when part of deserializeValue
Same as above. It's more readable.
You don't need to send'verifyDefaultStructure' here
You don't need to send this validation. Can you pass the injected label too?
You don't need to send this validation.
check the equals method before using it.
check the equals method before doing the assertEquals
check the equals
Is this line redundant?
Is this really needed? Looking at the code it's pretty clear.
Is this really needed? Isn't the same as the next line?
Wrong JSR number in validation provider.
'validateProvider' is not needed
Duplicated code
!this.fields.isEmpty()
message should be "fields can not be empty"
message should be "fields cannot be empty"
Aren't we supposed to have only 1 element in the DescriptorType?
Aren't we supposed to have only 1 element in a DescriptorType?
Aren't you sure it is no longer used?
Remove the public modifier from the class.
Remove the public modifier
Remove the public modifier from this method.
return a == null? null : b;
return a == null? b : b; is more readable
return a == null? null : b; is more readable
I don't understand why isMainThread() is called here.
I don't understand why isMainThread() is called on this line.
I don't understand why isMainThread() is called on this line of code.
nit: Let's make this final.
nit: Let's make this a List.
nit: Let's make this a List
no need to break after default
No need to break after default?
no need to check for the right case?
I think if publisher doesn't set extras with placement ID, we should probably allow to use Firebase Ads.
I think if publisher doesn't set extras with a banner view, we should probably allow them to render their banner more easily. Adaptive view is used, so I think we should add a permission check here.
I think if publisher doesn't set extras with a banner view, we should probably allow them to render their banner more easily. Adaptive view is used, so I think we should export our publisher only by convention.
This should be public and non-private
Need to check for commits.size() > 0, otherwise you'll get IndexOutOfBoundsException if commits list is empty
Need to check for commits.size() here.
remove
remove?
and here?
Should we remove the clientAwake property from the PresenceStatus?
Should we remove the clientAwake field from the PresenceStatus?
Should we remove the clientAwake == null?
replace this with the following: return result.iterator().next();
replace this with scanner.nextRaw(values), as the current implementation creates a new scanner
replace this with scanner.nextRaw(values); as the current implementation of nextRaw will not return null.
Don't we need to put a continue statement here?
Don't we need to put a lock for unlock invocation?
Don't we need to put a lock for this call?
String f = String.format(f, "%s", args[0], args[1], args[2]); throw new RuntimeException(result);
String f = message.replace("{}", "%s")? args[0]
String f = message.replace("{}", "%s")? args[0] : "";
missing <LINK_0>
missing more-once
missing {} around the body
same logging here as in perform next operation
same logging here. child command status doesn't affect any action.
same logging here. child command status doesn't make sense if the debug is enabled
The ratio is not used
The ratio is not used anywhere else.
Do we really need this?
If the COPEPlugin.getLocalStorage() throws an exception, why not just log it and continue?
If the COPEPlugin.getLocalStorage() throws an exception, why not just catch it and let the IOException be thrown?
If the COPEPlugin.getLocalStorage() throws an exception, why not just catch it and let the IOException pass?
Can we move this to the first line of the method?
Can we move this to the first argument?
Can this be made private?
Could you use a variable for this?
Could you use a setter for this?
Could you use a setter for this this one instead?
Can this be enclosed in a single line?
I don't think we want to maintain the guarantees of the scanner to see if it's already closed.
I don't think we need the String.format here.
I don't think we should use GenericCallback here.
I don't think we should change this to public.
I don't think we want to pass 100L as the default.
call destroy instead
Why don't you just use directly the default value e.g. ERO_DOUBLE?
Why don't you just use directly the default value e.g. no need to set the brightness?
What is the motivation behind this change?
What about using ExitUtil.terminate(true) here?
What about using ExitUtil.terminate(1) here?
There is a genuine risk that the implementation is protected. So, this should be protected.
There is a genuine risk that the selected element can be null. In this case it will lead to NPE. Therefore this should not be public.
There is a genuine risk that the selected element can be null. In this case it will lead to NPE. Therefore it is better to check if the element is not null before trying to select it.
Why don't you just pass in the onClose?
Why don't you just pass in the listener?
Why don't we catch the exception?
Is this change?
Is this change safe?
Is this change safe?
we can just return DataStreamNotification.fetchingStart();. This will get called multiple times in the code.
we can just return DataStreamNotification.fetchingStart(); here
I do not know if this is the correct method name.
We have a null check in <LINK_0> for an empty call in the finally clause.
We have a null check in <LINK_0> for an empty call.
What is the purpose of this change?
This will work for all fields that aren't texts. You could do this: java this.text = new Text(text);
This will work for all fields that aren't texts. You could do this: java this.text = Text.getText(text);
This will work for all fields that aren't texts. You need to add getElement() method to the Text constructor.
Remove generic Exception
it's usually better to use generic method.
can we use generic method like List<String> headers
Could you please add a constant for "application/json"
Could you please revert this change to use a constant as well?
Could you please assert that this is not null?
you can use Objects.requireNonNull(map, "The map must not be null");?
can be final
I think this method should be private
Why is this public?
I think the indentation here is wrong.
This "if" statement is duplicated.
@lautarobock Here too, let's declare throws Exception
@fanifieiev the same above.
@lautarobock Here too, let's declare throws IOException
remove unnecessary blank line
remove unnecessary new lines
remove
Does this make sense? If not, you can put the url in the template.
Does this make sense? If not, you can put the url in the template and use it here.
Does this make sense? If not, you can put the url in the process of the relation.
IllegalArgumentException
Should settlementDate() be the same?
IllegalArgumentException?
suggestion DefaultClientMessageTracker(fromActive)
suggestion DefaultClientMessageTracker(fromActive) {
suggestion DefaultClientMessageTracker.fromActive.add(name);
Should this be on Update?
Should this be on Update? Or did you do this on the CDMA? I'm not sure why it should be here.
Should this be on Update? Or did you do this on the first line?
Why the list is mutable? The init() method will never be called, it's possible that the configs are created, from the perspective of the configuration.
Why the list is mutable? The init() method will never be called, it's possible that the config is created, from the perspective of this.
Why the list is mutable? The init() method will never be called, it's possible that the config is created, from the perspective of this.config.
No need to send equiv on the result
You should use Util.fixEmpty.
No need to check for null
Should this propogate logic? Call superclass.getSuperCategoryMap() as well.
Should this propogate logic? Call superclass.getSuperCategoryMap() as well?
Should this propogate logic? Call superclass.getSuperCategoryMap() following the same problem.
This is making a gap between the type and the else branch, which is then not needed. Can you revert this change?
This is making a gap between the type and the else branch, right?
This is making a gap between the type and the else branch, which is really a gap.
This should be a constant so we can change it in the future if needed
This should be a constant.
This should probably be a constant.
part of variableName is actually lower case and is lower case long.
part of variableName is actually lower case and is lower case.
@variableName
return array > 0?
Let's use Array.getLength() instead.
?
We should make a convenience method for such a field.
We should make a defensive copy of the list, and rename it to keepNullColumns.
We should make a convenience method for such a.
Map<String, Integer> componentsToScaleDown = new HashMap<>();
Worth parameterizing the HashMap<String, Integer>.
Map<String, Integer> componentsToScaleDown = new HashMap<>()
Why does this need to be done?
Why does this need to be public?
Why does this need it?
Don't print stack trace.
I think this should be in an Log.e with the exception.
I think this should be in an Log.e method
please verify that the amend function is actually executed
Maybe just verify that the amend function is actually executed?
Maybe just call QcowCompat.QcowCompat() and verify that the amend function is successful?
Please keep the space before the opening {
Please keep the space before the opening bracket
should be extracted to constants
Would be nice to verify that the string contains "BroadcastJoin" and "BroadcastJoin" below works
Would be nice to verify all the string concats.
Would be nice to verify that the string contains "BroadcastJoin" and "BroadcastJoin" below works.
Would it be better to print the generated pattern here?
I think it would be nice to print the generated pattern here.
I think it would be nice to print the generated pattern here. Something like: "Pattern {} finished: {}.", baseVariable);"
We should really throw a PrestoException here. Returning null or an empty string would be better.
The Exception should be thrown here.
We should really throw a PrestoException here. Returning null or an empty string would cause the test fail.
This can be simplified to just!finishing && lookupSourceProviderFuture.isDone() && spillInProgress.isDone() &&...
Instead of checking canLookupSourceEmpty, you can just check if lookupSourceProviderFuture.isDone() before calling this method.
Instead of checking replaceSourceProviderFuture, you can just ask whether it is empty or not.
Is this really needed?
I think we could rename the variable to firstToken and use that here as well.
I think we could rename the variable to firstToken
Can we make this method package private?
Would it be better to make this private?
Would it be better to make this method synchronized?
Need to check if the server is an instance of GChannel, not just the current one
Need to check if the server is an instance of GChannel, not just the current value.
Need to check if the server is an instance of JChannel, not just a proxy.
I think we might want to use stream instead of StreamSupport.stream(query.spliterator(), false) to create a stream from the iterable instead of returning a stream directly.
I think we might want to use stream instead of StreamSupport.stream(query.spliterator(), false) to create a stream from the iterable instead of adding all this into one
I think we might want to use stream instead of StreamSupport.stream
MePage.go().verifyUsername(...)
MePage().go().verifyUsername(...)
MePage().go().verifyUsername(...) can be used instead.
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null);
Squash into one commit? unregisterAndCloseRepository(i.next().getKey(), null)
Should we use.getInstance(properties) instead? I think that might also make the code more readable.
Should probably use getClass().getClassLoader() here.
Should we use.getInstance(properties) instead?
@vbradnitski why throws Exception?
@vbradnitski why throws Exception? shouldn't it be better to throw ProjectJson?
@vbradnitski why you throw Exception instead of Exception?
this.currentContext.getCurrentMacroBlock().getId() + "message";
Why not invoke super.getClassProperty() here?
should be final.
I don't think this is right, since handleException() is already synchronized.
I don't think this should be synchronized, as it is not properly synchronization.
I don't think this should be synchronized, as it is already done in the class.
please use Objects.hash() which simplifies the code
You can use Objects.hashCode() which simplifies the code of the code
You can use Objects.hashCode() which simplifies the code
The reason is the message not : "canDoAction failed for the wrong reason". By the way, text command.getReturnValue() canDoActionMessages() is populated, so it will return null if the message is 'null'.
The reason is the message not : "canDoAction failed for the wrong reason".
The reason is the message not the text of the plugin.
Remove this line, and log the exception as well.
Remove this line, and change the logging level to error
Remove this line, and change the logging level to error.
currentTimeMillis() instead of re-using Dates.
currentTimeMillis() is not necessary
stopAt is not needed
Make it call the method with the given alarm key.
Make it call the method with the given alarm id.
Is it really necessary to change the naming of the method here?
What's the purpose of this change?
could you remove the synchronization and just set the listeners to null?
could you split this into two methods and use sharedListeners instead of the referenced lookup?
remove explicit initialization
remove explicity
remove 'this'
This is kind of a nitpick but I would prefer to keep the private methods in this class.
This is kind of a nitpick but can we make the methods private? I prefer to have them private, and have them be private.
This is kind of a nitpick but can we make the method private? I prefer to have some methods for this kind of thing.
I think checking for null here should be done by calling getLocalItem(keyMaker.make(VNC_CLIENT_MODE));
I think checking for null here should be done by calling getLocalItem(keyMaker, VNC_CLIENT_MODE);
I think checking for null here should be done by calling getLocalItem(keyMaker, VNC_CLIENT_MODE)
It isn't really a good idea to make this public. Was it intentional to leave it as private? I'm a little confused.
It isn't really a good idea to make this public. Was it intentional to leave it as package private? I'm a little confused.
It isn't really a good idea to make this public. Was it intentional to leave it as private?
Why can't we get the average lengthAccumulator and then getSearchCounts() directly?
Why can't we to use lookup.getCount() instead of lookup.getCount()?
Why can't we to use lookup.getCount() directly?
Maybe we should test on an invalid account token code?
Maybe we should test on an API token like this: <LINK_0>
Maybe we should test on an API token type?
Small nitpick: I wasn't sure why there was a better implementation of this for loop. The result of the keySet() on the map is now populated no matter what, and now we're creating a new list every time we call getListeners.
Small nitpick: I wasn't sure why there was a better implementation of this for loop. The result of the keySet() on the map is now populated no matter what, and now we're creating a new object with the same list. Feels more resilient to my taste.
Small nitpick: I wasn't sure why there was a better implementation of this for loop. The result of the keySet() on the map is now populated no matter what, and now we're creating a new list every time we call getListeners. This is a nice bonus from being able to avoid the extra lookup and lookup.
Do you think we need sync control on all the map operations here?
Do you think we need sync control on all the map accesses?
Do you think we need sync control on all the map accesses here?
You can drop the else.
You can drop the check to use m_count < m_objects.length so the next check will not be needed.
You can drop the check to use m_count and m_count.length between the m_objects.length and the check.
Maybe you can use ServiceConfiguration config = serviceConfiguration.get(); instead of doing the line above.
In this case, the setting of unknown name will be stored in any key. Please use that value instead.
In this case, the setting of unknown name will be stored in any key. Please use that instead.
I would prefer to move this method to the ProjectState class rather than having it return an empty set.
I would prefer to move this method to the ProjectState class rather than having it here.
I would prefer to avoid the else clause in this case.
I don't think it's necessary to instantiate an instance of this class.
I don't think it's related to this change, however it could cause issues with berry-pickings, I have not checked and it should be fixed.
I don't think it's related to this change, however it could cause issues with berry-pickings, I have not checked and adding "instanceof" check in the PR description.
Unnecessary whitespace.
Unnecessary blank line.
Unnecessary change.
you don't need to equals here, you can simply check if lastCheckBox is null
you don't need to equals here, you can simply check for null.
you don't need to equals here too
Similarly here, exec. should not be necessary.
Similarly here, exec. should not necessary.
Similarly here, exec. is not necessary.
Ditto, is this deliberate?
Is there a reason why this change is not done?
Ditto, IOExceptions
Since this is public, let's make it private, since it's only used in tests.
Since this is public, let's make it public, since it's only used internally.
Since this is public, let's make it private, since it's only used by the builder
While we are at it, I think we should use Collections.emptyList() to prevent the null check.
Don't use a LinkedList here, use Collections.emptyList().
While we are at it, I think we should use Collections.emptyList() to prevent the null here.
I suggest to use more specific names like /var/tmp/sub1/x/sub1/x/y. The test would fail on Windows for example.
I suggest to use more specific names like /var/tmp/sub1/x/sub2/x/y to make sure we are sure it was not there.
I suggest to use more specific names like /var/tmp/sub1/x/sub2/x/y to make sure we are sure it was not null.
I don't think it makes sense to make this public.
I don't think it makes sense to make this protected.
I don't think it makes sense to make this private.
+1 for the lock, and in case it's an issue, it might be nice to add a bit more info here.
+1 for the lock, and in case it's an issue, it might be nice to break this into multiple lines.
+1 for is it right?
Since it's a flag, you can just do return mPaths.get(INTENT_TO_ADD)!= INTENT_TO_ADD;
no need to always use INTENT_TO_ADD.
Since it's a flag, you can just do return mPaths.get(INTENT_TO_ADD)!= INTENT_TO_ADD;?
@ivandalbosco No need to cast to (JavaScriptTree) condition.
@ivandalbosco Suggested name: isAncestorOf((JavaScriptTree) token).isAncestorOf((JavaScriptTree) token))
@ivandalbosco what about having a test for isAncestorOf((JavaScriptTree) token).isAncestorOf((JavaScriptTree) token))?
Do you want to use the getCellValues() method?
Do you want to use the new Row class?
Do you want to use the new getCellValues()?
I think it would be better to use StringUtils.defaultIfBlank(appHome).
I think it would be better to use StringUtils.defaultIfBlank(appHome)
I think it would be better to use StringUtils.defaultIfBlank(appHome) here
suggestion lastKilledQueryIsGone = generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery);
suggestion public boolean isLastKilledQueryIsGone() {
suggestion public boolean lastKilledQueryIsGone() {
Again, use IOUtils.
This variable is only used once - use this value in the method call
This variable is only used in one place (which is not used at all)
You should not have to check here that the KeyAlreadyExistsException has been thrown.
You should not catch KeyAlreadyExistsException here.
Should be static
Only log the sender's message.
:ant: This messages are a bit verbose.
Only log the sender's message
Collections.singletonList
Collections.singletonList(row.getValues())
Collections.addAll
Could you move this log message to the logger?
Could we change this to debug?
Maybe we should also log the exception here.
Constructors can call this() in the same order as the others.
Constructors can call this()
Constructors can call this() in the same order.
I think that the lock.get(objectName) method is not needed as long as key of the parameter.
I think that the lock.get(objectName) method is not needed as long as its entry is already keyed in L109.
I think that the lock.get(objectName) method would be better as we iterate over the values and instead of the get if there is no element in the list.
you don't need this function, you can use constructor directly
you don't need this, you can use constructor directly
you don't need this variable, you can use constructor directly
Why not package protected?
Why not just use literal?
Why not just use  literal?
This should be map to errorReport, as we do not expect the title to be null, and here we should have an errorReport like this: java if (errorReport.getBody() == null) { throw new IllegalArgumentException("Missing error report body and  title"); }
This should be map to errorReport, as we do not expect the title to be null, and here we should have an errorReport like this: java if (errorReport.getBody() == null) { throw new IllegalArgumentException("Missing error report body, or title"); }
This should be map to errorReport, as we do not expect the title to be null, and here we should have an errorReport.
no need to check for null again...
no need to check for empty length
no point?
I'm not sure we should log this. WDYT?
I guess we added this logger recently, we might need to add it to the HMS command line (as well as our recent PR, but I'll send it to your PR, wdyt?
I'm not sure we should log this.
The null check is not needed here.
This could be filtered out.
This could use StringUtils.isEmpty()
You can use the method ChecksumType.nameToType(String) method to do this
You should return checksumName to use conf.get(HConstants.CHECKSUM_TYPE_NAME)
You should return checksumName if it exists.
If you know the type of FileAlreadyExistsExceptionClassName is not possible, the code should be changed to throw an exception.
If you know the type of FileAlreadyExistsExceptionClassName is not possible, the code should be changed
If you know the type of exception I would prefer getClass().getName().
Should this be above "isColorTeamMatch"? For example, on line #755.
Should this be above "isColorTeamMatch"? For example, on line 115 you can get a String reference rather than an id.
Should this be else if (workPackArt == null)?
Maybe extract locating the VisualizationInternal as a class inStepEngineSettings?
Maybe extract locating the Visualization.class as a class inStepEngineSettings?
Maybe extract locating the VisualizationInternal as a class in order to getVisualizationInternal?
optional style nit: I think this is too long. Can we extract this to a separate method and use a method for checking the button.
optional style nit: omit this empty line
optional style nit: I think this could be private
The same is here with the property env name
The same is here with the property envName.
The same is here with the property envName
Please give this a better name.
Please return human_Variables here.
Please give this a better name. _Edit:**
I mean throwing an UnsupportedOperationException instead, to be consistent with the existing offer method.
I mean throwing NotImplementedException instead of returning NotImplementedException.
I mean throwing an UnsupportedOperationException instead, to be consistent with the existing offer methods.
this is bad magic. please do not relay on file names, nor on paths to files. you should have a proper entry in the icon. thanks.
this is bad magic. please do not relay on file names, nor on paths to files. you should have a proper entry in the key.properties to point into the icon. thanks.
this shouldn't be part of the file. you should have a proper name, or even better named file
This should be true by default.
This should return true.
This would be true by default.
Should this have a private static method?
Should this have a private method?
whitespace
Why change the name from 75 to 371?
Why call refresh if the command fails or not?
Why change the name from 75 to 372?
you can add here three times instead of operations
you can add here three times instead of res
you can add here three more elements
Did you think about using driver.getCurrentBaseUrl() instead? <LINK_0>
Did you think about using <LINK_0>?
Did you think about calling driver.getTextEquals here? <LINK_0>
this method is in a different scope than private. we could have both in SwiftParser.CodeBlockContext or something like that.
this class is in a different scope than in codeBlockContext. Extract the method body into a separate method.
this class is in a different scope than in codeBlockContext. Extract the method body to a separate method.
It appears that we can incorporate this logic into CommandBase.endWithFailure() The finally block of that method is: if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { compensate(); } else { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { compensate(); } } The code can be improved, but this is the direction to go to reduce leaving compensation trace in case of failure.
It appears that we can incorporate this logic into CommandBase.endWithFailure() The finally block of that method is: if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { endWithFailure(); } else { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { compensate(); } } catch (SystemException e) { log.error("...", e); } }
It appears that we can incorporate this logic into CommandBase.endWithFailure().
... and here we builder the entire class.
... and here builder is Builder.
... and here builder is Builder.Builder().
could be: return mIsValid? "0.0.0" : toString();
could be: return mOption? toString() : "0.0.0";
could be: return mIsValid? toString() : "0.0.0");
no need for public
let's rename the field?
let's rename the field
It would make more sense to do this initialization into the separate method.
It would make more sense to do this initialization.
suggest using batch.concat()
Possibly simpler to just return the method here.
Just a thought, but the method name is slightly misleading because you could use a method in some context. Maybe something like loadMethodFromSession?
Just a thought, but the method name is slightly misleading because you could use a method in some context. Maybe something like loadMethodFromSession would be better.
explain this?
explain that this is necessary?
please add braces
seems like you want to override the accept() method instead of adding there.
maybe just add "accept-spans" to the message?
maybe just add "accept-spans" to the end of the String?
You have the extra space. Please remove.
You have the extra space. Also, please remove the extra space before the curly bracket.
You have the extra space. Also, please remove the extra space before (.
Helix does not provide a factory for it. You assume it is null?
Helix does not provide a factory for it. You assume it is null. Can you check?
Helix does not provide a factory.
This could be changed to if (!flying!= null && canFly).
This could be changed to if (flying!= null && canFly).
This could be changed to if (flying!= null && canFly)
This should be done in subscribe(sc, "activate(sc.getName())", true);
This method should be called in.show()
This should be done in subscribe(sc, "activate(sc));
nit: you can use getFirst(K key) and getLast(name) instead of this whole method.
nit: you can replace this with: return list.stream().anyMatch(e -> dataName(data).equals(name));
Is there a reason to have this second condition?
This is not required if we get aSoReuseAddress back from the XML.
This is not backward compatible.
This is not required if you replaced it by a boolean...
DateTime.now().getDays()
DateTime.now().getDays() is enough
DateTime.now().getDays() is sufficient
What's the purpose of this assertion?
What happens if we have multiple capacity?
What's the purpose of making this an assert?
We can remove this method and create a default value for all Programs.
We can remove the getter and setter as well.
We can remove the getter and setter as well
Did you take a look at ObsServiceImpl's super class? <LINK_0>
Did you take a look at ObsServiceImpl's description? <LINK_0>
Did you take a look at ObsServiceImpl's super class? <LINK_0> Thanks
Seems for me this would be better: java Query query = Query.query(Criteria.where("_id").is(key)); Query query = Query.query(Criteria.where("value").is(key));
Seems for me this would be better: java Query query = Query.query(Criteria.where("_id").is(key)); query.fields().include("value"); return query.fields().contains(value);
Seems for me this would be better: java Query query = Query.query(Criteria.where("_id").is(key)); query.save(new Datastore(key, value), collectionName);
You could use [Joiner](<LINK_0> for this.
You could use [SimpleRestResponse.of](<LINK_0> here. This is also applicable to some other parts of the code.
You could use [SimpleRestResponse.of](<LINK_0> here, for better readability.
Shouldn't we throw a NoNodeException?
Shouldn't this happen? If a node exists, it will be a String, not a String.
Shouldn't this happen? If a node exists, isn't it?
You can replace it with Collections.singletonList()
You can replace it with Collections.emptyList()
You are not using it. Please remove it.
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
I'm wondering why do you use RtForks in MkForksTestTest. We should test MkForks instead
I'd use RtForks in MkForksTest tests. We should test MkForks instead
You could have implemented this method private boolean nullOrEmpty(List<?> list) { return list == null || list.isEmpty(); }
You could have implemented this method private boolean nullOrEmpty(List<Object> list) { return list == null || list.isEmpty(); }
You could have implemented this method private boolean nullOrEmpty(List<Object> list) { return (list == null || list.isEmpty()); }
I think we should only be writing to the local app if savedInstanceState is not enabled. For example: if (savedInstanceState == null) { return; } shouldCheckForLocalAppFilesChange = CommCareApplication._().isConsumerApp();
I think we should only be writing to the local apps here since it's not consumer app
I think we should only be writing to the local apps here since it's not consumer app.
Oh, I didn't mean to leave it. The [Type](<LINK_0> is usually used for assertions, though it makes the code harder to read.
Oh, I didn't mean to leave it. The [Type](<LINK_0> is usually used for assertions, so we should leave it as is.
Oh, I didn't mean to leave it. The [Type](<LINK_0> is usually used for assertions, so we should leave it as is
can be replaced with lambda expression?
can be replaced with lamda
can be replaced with lambda callable
Would it be better to replace this with containerEditpart.getFigure().getBounds().contains(absoluteBounds))
Would it be better to replace this with containerEditpart.getFigure().getBounds().contains(absoluteBounds)
shouldn't it be just "return containerEditpart" instead of "return true"?
this is internal, and we should have a closeConnection(final PoolEntry poolEntry, final String closureReason) method because these two methods are protected.
this is internal, and we should have a closeConnection(final PoolEntry poolEntry, final String closureReason) method because these two methods are private.
this.
Another case where the empty input is not an empty string.
Another case where the empty input is not an empty line
Maybe switch this to one line?
move null check back as first condition to not change behaviour
move null check back as first condition to not change behaviour.
again negate condition
Verify that this is being set?
0.4 or or maybe just _tear down?
0.4 or or she?
I suggest to break this line.
I'd suggest to create a separate method.
I suggest to create constant.
this.threadKeepAliveTime = threadKeepAliveTime;
@super132 to call this one this.threadKeepAliveTime = threadKeepAliveTime;
what's the reason for checking both of these variables?
@HighlightDrawables[0].setColor(mainColor);
mHighlightDrawables[0].setColor(mainColor);
@HighlightDrawables[0].setColor(mainColor); basically?
Do we need this catch?
Do we need to add more specific exception like  thrown here?
Do we need to add more specific exception like RuntimeException?
Maybe here you can use rs.getInt()
Maybe here you can use BooleanUtils.getBoolean.
Maybe here you can use rs.getInt() directly here.
If you know the Caffeine class, you will end up with a file extension for the Caffeine class.
If you know the Caffeine class, you will end up with a reference to the Caffeine object.
If you know the Caffeine class, you will end up with a reference to an entry java class.
pls avoid using /var/cloud_mount/
pls avoid using hard-coding the path in Environment.java
pls avoid using File.separator
Left over
Empty items not a valid feed, this message should be generated by the user
Empty items not a valid feed, this message should be generated by the feed.
Why is this required?
Why is the public?
Why is this needed?
Should this be a constant?
Should we have a utility for this?
Should this be  fullName.trim()?
UnsupportedOperationException seems reasonable here.
UnsupportedOperationException might be a better choice here.
UnsupportedOperationException might be better here.
I think it is redundant. tables.stream().map(t -> t.map(mapper)).collect(toList()) is enough.
I think it is confusing that properties.stream().map(t -> t.map(mapper)).collect(toList()) is not necessary.
I think it is confusing that properties.stream().map(t -> t.map(mapper)).collect(toList()) is not sound as-is. Maybe a better name?
Can you add another version of getStringContentBuilder and replace the deprecated one?
Can you add another version of getMessageContentBuilder and replace the deprecated one?
Can you add another else case?
Use Objects.requireNonNull(fTopNode, "TopNode cannot be null");
Use Objects.nonNull(fTopNode, "TopNode cannot be null")
Use Objects.nonNull(fTopNode, "TopNode cannot be null");
What is the issue with this context?
What is the exception parameter for?
What's the exception parameter for?
ITickable does not make much sense here.
ITickable does not make any sense here.
ITickable and this part can be removed from the loop
Remove?
Remove
Remove.
What about define BackupEventHandler as a class attribute, then check this method on line 110? Then you can get rid of the BackupEventHandler case completely.
What about define BackupEventHandler as static final, then you can reuse this method on line 110?
What about define BackupEventHandler as static final, then you can check this for example on line 110?
I18nLanguage is a public method which is invoked many times in this class.
I18nLanguage returns a blank string, so we should use that one.
ofNullable(result)
Don't call getChangeSets. use [this](<LINK_0>
Don't call getChangeSets. use added(<LINK_0>
Consider adding the version header in AtsClientService.get().createChangeSets(String...)
The name of the existing stream definition (required) is not used. Should we keep it?
@kritika-singh3 @viraj2712 -- How about to use the name of the existing stream definition (required) and an existing stream definition?
The name of the existing stream definition (required) is not used.
I'm not sure this is the right thing to check.
I'm not sure why this has the 'DEV' feature.
I'm not sure why this has the 'block', the generated code is the same, but the generated code is the same.
Use faster methods, should not use data processors when possible.
Use faster method, should not use data processors when possible.
Use data processors when possible.
[minor] Could this be a message like "Task can not be created done"?
[minor] Could this be a message like "Task can not be created done".
[minor] Could this be a message like "Task can not be created"?
Thinking starter on the full size should do it for the tests. And then is the extra length _3_ to be more precise than the size.
Thinking starter on the full size should do it for all the tests. And then is the extra length _3_ to be more precise than the size.
Thinking starter on the full list for all the rows, then we need to verify that the new count is at least 1.
This doesn't need to be public
This doesn't need to be volatile
This doesn't need to be volatile.
yes, what is the purpose of this ctor?
yes, what is the purpose of this.
yes, what is the purpose of this. done?
I would extract USE_KINDS constant as well, to make it more consistent with the rest of the code.
I would extract USE_KINDS constant as well, to make it more readable.
I would extract USE_KINDS constant as a constant for improved readability.
This is a good example of behavior. It should be : java assertThat(stats.getLast(), equalTo(tokens.getLast()));
This is a good example of behavior. It should be : java assertThat(stats.getLast(), equalTo(tokens));
This is a good example of behavior. It should be asserted that the update succeeded.
bikeshedding, but this method should be in the try {} block.
bikeshedding, but this method should be in the try/catch block.
bikeshedding, but this method is too much more readable in my opinion.
is this needed for the max time?
is this needed for the test?
It seems that this persist is missing the max time time.
Why does this need to be synchronized?
Why does this need to be public?
Is there a reason why you explicitly check the return value of this method?
You're doing something like: java if (!set) { ignoredPlayers.add(uuid); } else { setIgnoredPlayers(ignoredPlayers); }
You're doing something like: java if (!set) { ignoredPlayers.add(uuid); } else { setIgnoredPlayers(ignoredPlayers); } }
You're doing something like: java if (!set) { ignoredPlayers.add(uuid); } else { setIgnoredPlayers( ignoredPlayers); }
other tests are very similar - why not use something like this: java assertThatExceptionOfType(VariantException.class).isThrownBy(
other tests are very similar - it should be refactored to a common method.
other places use constants. Could you use something like this?
make this private?
public?
make it private?
Again, these are not public constants, they can be removed.
Again, these are hardcoded strings, not sure why they are hardcoded
Again, these are hardcoded strings, not deleted.
It would be better to have checkState( object, fieldOffset >= newValue ) here.
It would be better to have checkState(object == null || fieldOffset == newValue )
It would be better to have checkState(object == null || fieldOffset == newValue ) here.
Remove the public modifier.
Remove the public modifier from the review.
Remove the public modifier from the method.
Can you re-use @Test(expected = InterruptionException.class) instead?
Can you re-use @Test(expected = RuntimeException.class) instead of the try-catch?
Can you re-use @Test(expected = RuntimeException.class) instead of the try block?
Can we change the method name to useUserTimeone?
Can we change the method name to getUserTimeone?
Can we change this to return getUserTimeone()?
Similar
Same here for this test
Same here for the uuid.
why not set the environment directly in the constructor?
why not put this in the setter?
I think this should be <code>this</code>, not public
Move this method into the public UserDTO addUser(UserDTO userResource) method, and call it from here.
Move this method into the public UserDTO addUser(UserDTO userResource) method.
Move this method into the public UserDTO addUser(UserResource) method.
Use "this" when referring to field names in text.
Check whether we have moved the compatibility to Java8, since we have moved the compatibility to Java 7 without any other style.
Check whether we have moved the compatibility to Java8, since we have moved the compatibility to Java 7 without any other text.
If we're not using sourceProcessingDetails to determine whether it's null, you could simply return the'sourceProcessingDetails' object.
If we're not using sourceProcessingDetails, you could just do the assignment here and save one line of code.
If we're not using sourceProcessingDetails to determine whether it's null, you could simply return the'sourceProcessingDetails' object directly and save the check.
As we know the data type is not a data, this could be a void. As an example: java void writeElement(ObjectDataInput in, Object[] data) throws IOException { out.writeData(entry.getKey()); if (value instanceof Data) { out.writeData((Data)value); } else { out.writeData(value); } }
As we know the data type is not a data, this could be a void. As a test method, this is not a void.
As we know the data type is not a data, this could be a separate implementation
this is a constant string, why are you using it here?
this is a constant string, why are you using it?
this is a constant string, why is it set here?
I think isVariableHeight should be called first here to avoid unnecessary 'isVariableHeight'.
I think isVariableHeight should be called first here to avoid confusing conditions.
I think isVariableHeight should be called first so that it does not have to be true for all variable height.
Instead of checking if it is empty, you could have a add(event) method that checks if it is empty.
Instead of checking if it is empty, you could have a add(event) method that checks if the list is empty.
Instead of checking if it is empty, you could have a add(event) method that checks if the event is not created.
Does this need to be logged at info level?
Does this need to be logged at all?
Does this need to be logged at all? I think that's something the user should be logged at info level.
Should this be ClientConfigurationException?
Should this be using [StringUtils.isBlank](<LINK_0> instead?
Should this be using [StringUtils.isNotBlank](<LINK_0> instead?
Remove final.
Remove final
remove final.
explicit real ref?
The above cast should be done after the if (entry == null) check to avoid an NPE. My mistake.
explicit real ref? My mistake.
Maybe we can add an overload of isEmpty() to avoid the ugly check, e.g.: @Override public void request(int rowsCnt > 0) { if (waiting == -1) { source().request(waiting = IN_BUFFER_SIE); } else { onError(e); } }
Maybe we can add an overload of isEmpty() to avoid the ugly check, e.g.: @Override public void request(int rowsCnt) { if (waiting == -1) { context().execute(this::doPush); } else { waiting = IN_BUFFER_SIE; } }
Please remove this empty line
Same again.
Same: generic parameters, and context parameters.
Same: generic parameters.
nit: I'd prefer to not write the bloom filter if it is a add. If you think it is the problem, please add the following to the writeBloomFilter method: public void writeBloomFilter(BloomFilter bloomFilter) { if (port == null) { currentBloomFilters.add(bloomFilter); } }
nit: I'd prefer to not write the bloom filter if it is a add. If you think it is the problem, please add an explanation to the bloom filter in the writeBloomFilter method.
nit: I'd prefer to not write the bloom filter if it is a really generic type.
Should also be Objects.equals(_apiVersion, that._apiVersion)
This should also be Objects.equals(_apiVersion, that._apiVersion)
Should the comparison be done with Objects.equals(_apiVersion, that._apiVersion)?
Think I'm missing something, but the earlier call to getUrlForPatchSet() is doing the same thing so it would be better to do it in one place.
Think I'm missing something, but the earlier call to getUrlForPatchSet() is doing the same thing so I don't think it needs to be public.
Think I'm missing something, but the earlier call to getUrlForPatchSet(key, id) would be better.
The super() method does not have to be called explicitly.
The super() method is superfluous.
The super() method could be private.
SourceImpl?
SourceImpl should not be returned from SourceImpl
SourceImpl should not be returned from SourceImpl.
Cast and then you can be removed.
Cast and const please
Cast and then you can be removed
Do we need this?
remove!= null
remove this
Can we log the exception?
Can we log the error?
Can we log the exception here?
why do you need to override the above add() method?
why do you need to override the above add() method and not add()?
why do you need to override the above add()?
We can move this call to the constructor of IgniteJoin.
We should move this logic to the top of the class.
We can move this call to the constructor
I think the cache must be created in the constructor.
I think we can just use the cachedById.get(cacheKey) method to ensure the cache is always cached.
I think the cache manager should be used by the DefaultSchemaRegistry.
you can use String.format method here
you can use String.format method
I think you can use String.format here
The above line does not need to be changed.
The above line does not need to be changed in the preference store
Needs to be externalized to a constant.
use this form like newTemplate.setAuthorReference(null)
This null check should be in the ctor as well.
use this constructor
Is this a good idea? Should we throw an exception instead?
Is this a good idea? Should we throw an UnsupportedOperationException?
Is this expected to be a completed future?
Can this be static?
This should be protected.
Can this be simplified with a map?
Curious why this should be final?
Curious why this is not final?
Curious why we need the getIndexManager() method?
I'd rather use!isAnalyticsActive()
I'd rather use!isAnalyticsActive() instead of isAnalyticsActive.
I'd suggest!isAnalyticsActive()
negative logic
negative condition
negative value
This method should be synchronized, right?
This can be made more compact: Block.moveIntoContainer(this.wrapper.getPane().getTopLevel())
This method should be synchronized.
How about simply this(existingDirs, Collections.emptyList(), false);?
How about simply this(existingDirs, Collections.emptyList(), false) here?
How about using the constructor taking in a parameter?
I think we should standardize the waits to see if the Stream is closed.
I would prefer to standardise on InterruptedException.
I think we should standardize on single quotes in tests.
Do we really need to set the context that is already passed in?
Do we really need to set the context that's already passed in?
Shouldn't this be done in the ExtensionController constructor?
Is this method necessary? As in line 1872, you can remove this line.
Is this line necessary?
Is this necessary?
This won't work since completedFuture(null) returns an empty map. We should check the status of the response before creating a request.
This won't work since completedFuture(null) returns an empty map. We should check the status of the response and avoid creating a new map.
This won't work since completedFuture(null) returns an empty map. We should check the status of the response it was null.
nit:.flatMap(Schedulers.elastic()).map(zkInstance -> toookeeperServiceInstance(serviceIdToQuery, zkInstance)));
nit:.map(Schedulers.elastic()).map(zkInstance -> toookeeperServiceInstance(serviceIdToQuery, zkInstance)));
nit:.map(Schedulers.elastic()).map(() -> toookeeperServiceInstance(serviceIdToQuery, zkInstance)));
Why don't you initialize this where you are allocated?
Why don't you initialize this where you do this?
Why do you need this null check?
This userData map should be initialized to OPENSTACK_METADATA
Better to use isOpen(vmInit) :)
This userData variable and initialization is done in the constructor, instead of here.
Could this be null if the appReport is null?
check for the null and throw YarnClientNotFound
check for null too
I would put the String.valueOf() only.
I would put the String.valueOf() part here since it is a constant object.
I would put the String.valueOf() part here since it's a constant object.
I might be wrong, but this could be a lot more readable if cardTypes.stream().anyMatch(CardTypeEntity::isRequires3ds)
I prefer to use a spelled card type here instead of a single word.
I might be missing something, but why the list is > 0, when this is a shortcut of a anyMatch?
I think this could be private.
I think this could be private, or at least package protected.
please put this method on the previous line
can't this be a boolean?
If the type is a boolean, why not just have it be boolean?
If the type is not a boolean, why not just use a boolean?
Likewise..
Same.. Should be done in presenter
Same here..
try to simplify this to return toString(" ", " | " | ", ".Map");
try to auto-generated toString and put them in the lambda
| ->.Map?
I don't think we need to make this method public, especially as it is not used anywhere
I don't think we need this check, if the thread is already alive and we can perform a cleanup.
I don't think we need to make this method public, especially as it is not used anywhere.
If you're setting a profile without any error then it's better to remove this parameter.
If you're setting a property I would remove this line (to prevent any unexpected cast).
If you're setting a profile without any error then it's better to remove this command entirely.
This should probably just be getActiveClusterUrl
This should probably be getActiveClusterUrl
This should probably be getActiveClusterUrl().
Nitpicking: does this need to be made for testing?
Nitpicking: does this need to be before the @Before?
Nitpicking: does this need to be wrapped in a try/finally for testing?
missing space after =
It is unnecessary to log and throw.
It is unnecessary to log and throw
The HTTP standard way to do this is to use the "getConnection" method, or do we need to do it here?
The HTTP standard way to do this is to use the "getConnection" method, or do we need to do that here?
The HTTP standard way to do this is to use the "getConnection" method, or do we need to do it in a method?
This doesn't seem to be different.
This logic is different.
This doesn't look thread-safe.
If we have to do this, we should throw an UnsupportedOperationException or some other way to handle it.
If we have methods that throw exceptions, we should probably do the same.
If we have to do this, we should throw an UnsupportedOperationException or something like that.
I think we should do this without the need to expose a new method/class in the Config class. It should provide the class name as a parameter.
I think we should do this without the need to pass the Members to init(). Any reason for doing this here?
I think we should do this without the need to expose a new method/class in the Config class. It should provide the class name as parameter.
I still think this does not belong here. We don't want the permit to be non-deterministic.
Sorry wrong patch, will fix these problem.
Sorry wrong patch, will fix these.
Instead of using the context class loader, use the class loader of the first one.
Instead of using the context class loader, use the class loader of the first param.
Instead of using the context class loader, use the class loader of the first aggregate factory.
nit: can we create a constructor with ledgerDirsManager and ledgerDirsManager, and have only one constructor that takes DiskChecker?
nit: can we create a constructor with ledgerDirsManager and ledgerDirsManager, and have only one constructor that takes DiskChecker as a parameter?
nit: change quota name after create?
Why do we need it here?
Why do we need this check?
Why doing it here?
I'd prefer to remove this assertion and instead call the method org.assertj.core.model.Assertions.assertThat(actual).assertionError(String.class) instead. It's more readable and easier to understand.
I'd prefer to remove this assertion and instead call the method org.assertj.core.model.Assertions.assertThat(actual, actual).hasField(ClassName.class);
I'd prefer to remove this assertion and instead call the method org.assertj.core.model.Assertions.assertThat(actual).assertionError(String.class) instead. It's a bit more readable and concise.
We definitely need more details about what is invalid about the list of keys, e.g. which keys are not valid (e.g. which keys are not valid)?
We definitely need more details about what is invalid about the list of keys, e.g. which keys are not valid.
We definitely need more details about what is invalid about the list of keys, e.g. which keys are not valid (e.g. which keys are missing)?
nit: this is not a test. ;)
nit: this is not a test.
nit: this is not a timeout. We can really have a default timeout of 50 between cases.
The Exception is never thrown.
I think the Exception is never thrown.
I think the Exception is never thrown here
This could be a bit cleaner if we could do all this check first, since we are trying to do a non-default case.
This could be a bit cleaner if we could do all this check first, since we are trying to do a non-default case consistently.
This could be a bit cleaner if we could do all this check first, since we are trying to do a "renaBlockSize" section.
log.debugf
log.tracef
LOG.debugf
log this instead?
Should use the logger.
Should use the logger
action.accept(entry.getKey(), entry.getValue()); seems more readable.
action.accept(entry.getKey(), entry.getValue()); should be replaced by the following code: java public V process(Map.Entry<K, V> entry) { action.accept(entry.getKey(), entry.getValue()); return entry.getValue(); }
action.accept(entry.getKey(), entry.getValue()); should be replaced by the following code: java public V process(Map.Entry<K, V> entry) { action.accept(entry.getKey(), entry.getValue()); return entry.getValue(); } WDYT?
Perhaps it should check that the header is not null?
Perhaps it should check that the header is not set?
Perhaps it should check that the header is not headers?
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
Instead, start with bot.checkBox("SWT::READ_ONLY").select();
Instead, start with bot.checkBox("SWT.READ_ONLY").select());
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this issue.
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this problem.
UUIDs will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this issue.
Why not just iterate over all extended discovery services and use the extended services in the list of extended discovery services? That way you should not have to modify the list of services in a way.
Why not just iterate over all extended discovery services and use the extended services in the list of extended discovery services? That way you should not allow to add all the extended services to a service.
Why not just iterate over all extended discovery services and use the extended services in the list of extended discovery services?
This wasn't related to this PR, but wouldn't it be more correct to use an AssertJ assertThat instead?
This wasn't related to this PR, but wouldn't the test be more useful if the retiredOrderTypes are in the same order type?
This could be changed to assertEquals(number, orderTypeList.size())
I think this can just be futureToken.assertLockedAndUnlock(futureToken);
nit: can you add a failure message here?
I think this can just be futureToken.assertLockedAndUnlock(futureToken)
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
you MUST catch (Throwable t) and not t2nd arg? Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the tests fail
I think this could be changed to List<String> patterns = new ArrayList<>();
I think this could be replaced by Collections.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(pattern)).
I think this could be replaced by Collections.singletonList(StringUtils.commaDelimitedListToStringArray(pattern)).
you can invert the "if" condition
log it as well
log it as well?
Mappers should be creating the object using try-catch.
Mappers should be creating the object using try-catch. Handle them in a method.
Mappers should be creating the object using try-catch. Handle them in the exception.
No need to return boolean directly.
No need to return true since it will never be called right?
No need to return boolean.
Same here. Add ex as an argument to the IllegalArgumentException constructor.
You should have the ex as an inner throwable to that illegal argument exception.
You should have the ex as an inner throwable to that illegal argument exception and rethrow it as an illegal argument exception.
Maybe we should log a error here too.
Maybe we should log the error here too.
Maybe we should log a error here too, and report the error
Why 5?
Why 5 seconds?
Please avoid using reflection.
Unneeded space before )
Does this need to be public?
Unneeded space before ).
This is a nitpicky but I don't think "obvious".
This is a constant and can be used instead of hard codedly.
This is a constant and can be used
There's no need to declare the app to be instantiated.
This will break existing tests, which is not what we want. Please use the annotations: <LINK_0>
This will break existing tests, which is not what we want.
replace the if with checkIndex(toIndex)
if (fromIndex >= toIndex && capacity() == 0)
if (fromIndex >= toIndex &&!size() == 0)
Why change this?
Why is this change necessary? It should be BitBuffer.EMPTY_BITBUFFER, but that should if you change the bits, then its length should be > 0.
Why is this change necessary? It should be BitBuffer.EMPTY_BITBUFFER, but that should if you change the default to 0.
that can be null? This means we need to handle all the locks above. Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIATION. Please either make sure they are never null or use different objects for synchronization.
that can be null? This means we need to handle all the locks here? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIATION. Please either make sure they are never null or use different objects for synchronization.
that can be null? This means we need to handle all the locks above. Also accessing this object here without synchronized lock? I can't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIATION. Please either make sure they are never null or use different objects for synchronization.
is this method used anywhere? if so, do you need to add synchronized?
is this method used anywhere? if so, do you need to move it?
is this method used anywhere?
@wezell, it's a bad idea to use the OS.name() check instead of doing it.
@wezell, it's a bad idea to use the OS.name() check instead of doing it on windows.
@korthout Avoid using static imports for this kind of thing.
Can we remove the isInodeIndexed method by using the Util.pushDeleteEvent(contentlet, contentlet); instead?
Can we remove the 'isInodeIndexed' call? Since the isInodeIndexed already takes care of the connectionlet's param if it is not null
Can we remove the surrounding method call?
setIcon(android.R.drawable.ic_input_delete)
setIcon(android.R.drawable.ic_input_delete) is just a no-op
callback
Is there a reason we're not adding this to biostoreListenerNotifier?
Did you consider moving this inside of the constructor?
Is there a reason we're not adding this to the bucketwriter lock?
I wonder if it is better to pass the admin label here in getSystemAdmins(String adminLabel) to getSystemAdmins(String adminLabel)
I wonder if it is better to pass the admin label here in getSystemAdmins(String adminLabel)
I wonder if it is better to pass the admin label here in getSystemAdmins()?
this method can be private, and at the other two methods in this class
this method can be private now, no?
this method is redundant
Should allow null here to be taken to ensure non-null
Android Studio warns on merge. Please fix the formatting
Should be public
how about java if(service.getName().startsWith("eap")) { return service.getName().startsWith("eap"); } else { return false; }
how about java if( service.getName().startsWith("eap")) { return service.getName().startsWith("eap"); } else { return false; }
how about java if(service instanceof OpenShiftServerUtils){ return OpenShiftServerUtils.getService(getServer()); }
Do you want to keep this? it's a bug and should be fixed.
Do we not need to implement this?
Do you want to keep this?
Please use isEmpty()
Use isEmpty()
'protected' is redundant
Do we need to actually update the QPsDb model?
Does this need to be changed to check for the criteria being null?
Does this need to be changed to check for the criteria being sorted by the product?
Hm, I noticed that we should only deal with StreamsException here. So, we can't get a checked exception here. Are we sure we should only wrap it in an TimeoutException anyway?
Hm, I noticed that we should only deal with StreamsException here. So, we can't get a checked exception here. Are we sure we should only wrap it in an TimeoutException?
Hm, I noticed that we should only deal with StreamsException here. So, we can't get a checked exception here. Are we sure we should only enrich StreamsException here?
Superfluous empty line.
Superfluous "this".
Superfluous "this" qualifier.
Is this null? If yes, it should be default
Is this null? Is it to be non-null?
Is this null? Is it to be non-null? If yes, it should be remove.
no need to declare this once the test is done
no need to declare this once?
no need to declare this once the test are done
this.
this. return ImmutableList.copyOf(new ArrayList<>()
this.toList()
Not Customer.class.getResource(...) is fine.
Not Customer.class.getResource
Not Customer::class.
Suggest using getClass().getSimpleName() instead.
Suggest using Dao.findAllBy().
Suggest using Dao.findAllBy( adapter.getId()).
This operator should be changed from a else statement to a return.
This operator should be changed from a ternary to a logical operator.
Why empty line?
Is it really necessary to move it into the method? Is it because the other methods are part of the public API?
Is it really necessary to move it into the method? Is it because the other methods are part of the public interface?
Is it really necessary to abstract it? it seems like the other methods are already public.
Why is this method synchronized?
nit: it is probably more efficient to use a ternary expression.
Why is this method public?
Do we need this? All it does is assert that the message is equal
Do we need this? All it does is assert that the message has the correct value.
Do we need this? All it does is assert that the message has the correct values.
@tarun0 why don't you use <LINK_0>
@tarun0 why don't you declare <LINK_0>
@tarun0 why don't you declare the <LINK_0>
If the operation was removed, should this check be on the caller side?
If the operation was removed, should this be allowed as well?
Can you add curly braces?
Would it be a good idea to wrap the Folder.id in a field so that we can get rid of the duplicated code?
Would it be a good idea to wrap the Folder.rescanIntervalS in a field so that we can get rid of the duplicated code?
Would it be a good idea to wrap the Folder.id in a field so that we can get rid of the double brackets around the expression?
Minor: Would be nice to have a configurable wait time instead of configurable.
Minor: Perhaps it would be best to not use schedule as its own thread. This would allow the user to override its behavior or not.
Minor: Could you explain how this works?
Unnecessary check, since eventListenerSet is empty anyway.
Unnecessary check, since eventListenerSet is empty anyway
A nitpicking: the if can be omitted here.
Looks like this just declares a variable that's not used?
Looks like this just declares a constant that's not used?
Looks like this just declares a constant that's not used twice.
Why not assertNull and assertNotNull?
Why not use assertNull and assertNotNull?
Why assertNull and not call?
This should be a field.
This should be named as INVALID_CLASS.
This should be done in static field.
It seems like it would be better to explicitly set the default to to false, and then set it to true in the addPathParam(). I think the scope of this PR will be an sole change, so it's easier to debug if you want to fix it.
It seems like it would be better to explicitly set the default to to false, and then set it to true in the addPathParam(). I guess the only reason this method is called is because you went with an empty string and it didn't work, so it's not necessary to add it explicitly.
It seems like it would be better to explicitly set the default to to false, and then set it to true in the addPathParam(). I guess the only reason this method is called is because you went with an empty string and it didn't work, so it's not obvious why it was needed.
No assertions here unless you're going to play things.
No assertions
No assertions about this.
The test should validate the error message
The test should validate the absence of a network connection.
The test should validate the error message as well
Consider making this private as it's only used in tests.
This seems unsafe, consider making a private method.
Consider making this private as it's only used in tests
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked") for instanceof ReflectiveStaticInjection, too
@Override
Please remove empty line
Please remove empty lines
Please add a @Before annotation
Can we use a more descriptive name for the method? Maybe even isMilestonesSizeBelowLimit()?
This if statement should be removed. No need to check these.
Can we use a more descriptive name for the method? Maybe even just " populateBestMatchingMilestones"?
you should use "if (value == null || value.compareTo(column.value.toString()))" here
you should use "if (value == null || value.compareTo(column.value.toString()))"
Are you sure that value is "> 0"?
subs is used only once. I think it is better to have a method like: java private static void deleteSubscription(final BlockingSphereClient client, final Subscription subscription) { this.subscription = subscription; }
subs is used only once. I think it is better to have a util method that returns a subscription.
subs is not used
why add this for loop inside of it.
why add this for loop?
why add to this list, then call addAll?
loadTemplateMaps() is not necessary here.
loadTemplateMaps() is not necessary here
loadTemplateFromMaps() is not necessary here
The cacheNotifier and cacheNotifier are a bit weird, it's called a lot more than once in the callback. Maybe for us to have a separate method for deleteFromStoresAndNotify()?
The cacheNotifier and cacheNotifier are a bit confusing given that they're calling notifyCacheEntryExpired in any way. Maybe inline it out? (And know it's not a good idea to have a separate method notifyCacheEntryExpired that takes a CacheNotifier, but it's not a blocker for this purpose).
The cacheNotifier and cacheNotifier are a bit confusing given that they're calling notifyCacheEntryExpired in any way. Maybe inline it out? (And know it's not a good idea to have a separate method notifyCacheEntryExpired that takes a CacheNotifier, but it's like a filter operation).
nit: maybe use String.format("%s must set namenode URL", fs.length())
nit: Might want to log the file name and the file name here as well.
nit: Might want to log the file name also (like FS_DEFAULT_NAME_KEY).
since this is a test and these are not reporting errors, please change to logger.info()
since this is a test and these are not reporting errors, please remove // TODO and rename to logger.info()
since this is a test and these are not reporting errors, please remove // TODO and let the logger to be sure
Don't think this is correct. You can call a refreshHistory method that takes a String[] and an array. The name of the function is rather confusing.
Don't think this is correct. You can call a refreshHistory method that takes a String[] filter and returns a new History[]. The name of the filter method is rather confusing.
Don't think this is correct. You can assign a new value to the if clause and return if not empty.
Should this be warn instead?
Should this be warn?
Should this return rather than set?
This table should not be read by itself. The current purpose of this test is to check that the expected number is hidden, and that should be the same.
This table should not be read by itself. The current purpose of this test is to check that the expected number is hidden. So, this table should not be read by itself.
This table should not be read by itself. The current purpose of this test is to check that the expected number is hidden. So, it should be in a way that it is hidden, then?
Please remove System.out
Please use a logger.
Please use logger.
Since Date instances are mutable, the this.endDate should be a copy of endDate to avoid side-effects.
Since Date instances are mutable, the this.endDate should be copied into a copy of endDate to avoid side-effects.
Since Date instances are mutable, a copy of endDate should be passed into this.endDate = new Date(endDate.getTime())
public? Also, please remove the public modifier from the public class
public? Also, please remove the public modifier from the public methods.
public? Also, please remove the public modifier from the public class.
unneeded cast?
unneeded cast
space
You need to reformat this file.
You need to re-use the isAssignableFrom method since that method already checks for null and instanceof.
You need to recheck the message in here.
Just use systemProperties.getPublishedSequenceNumber()
Just use systemProperties.getPublishedSequenceNumber() and make this return the id.
> 0
this can be simplified as return checkAtNewTableRow(line, lineOffset)
this can be simplified as return checkAtNewTableRow(line, lineOffset);
this can be simplified a bit
can be just: java if (!incompatibilities.isEmpty()) {
What happens in case of RECURSION_SCHEMA?
What happens in case of RECURSION_AM_RESOURCE?
This could be null if the tag is not.equals()
This could be null if the tag is not in the filter.
This could be null, but I would also check this before filtering
Exchange#containsIgnoreCase(java.lang.Expression expression) could be replaced by method reference.
equalsIgnoreCase vs. equals?
Exchange#containsIgnoreCase(String, Object) can be replaced by null check on the upper line as well
Let's put this check in a static method so we can call it from here and in the other utility class.
Let's put this check in a static method so we can call it from here and in the other utility methods.
Let's put this check in a static method so we can call it from within the Core utility class.
Maybe use isBlank instead of equals?
Maybe use isBlank instead of equals.
Maybe use isBlank here.
Is it worth noting that this is AVAILABLE?
Is this call necessary? Note that there's no subscribe if the network is AVAILABLE.
Is this call necessary? Note that there's no subscribe if the network status is AVAILABLE
Since this is a public API we may also want to add @ServiceMethod annotation to the Map interface.
I'm not sure about this one. We may also want to change the return type of Map<String, Map<String, String>>.
I'm not sure about this one. We may also want to change the logic if the call to "get" method returns null.
assertFalse(...);
remove assertFalse(...);
assertFalse(...);?
Nit: Maybe we should probably have a ctor for it :)
Nit: Maybe we should probably have a ctor for it
Nit: Maybe we should decouple from the constructor call and from the builder as it's more descriptive?
This should be info.
This can be moved into the finally block.
This can be info log.
I think that the key should be 'null', not 'value'.
How about replacing UserIdStorageFactory.key with UserIdStorageFactory.key or UserIdStorageFactory.key?
I think that the key should be 'null', not "key".
Why is this just a wait? Why isn't it just an int?
Why is this just an alert?
Why is this just a wait? Why isn't it just an error?
This should probably be target.
This should probably be kept in the scope of the variable.
This should probably be kept in the scope of this method.
Again, be package-private.
Again, be package-private (or private) class.
Again, be package-private (or constructor)
Why not use TextUtils.isEmpty(mEmailInput.getEditText().getText()) here?
Why not using StringUtils.isEmpty(mEmailInput.getEditText().getText()) here?
Why not use TextUtils.isEmpty(mEmailInput.getEditText().getText()) instead?
I don't think it's possible to use the AuthorizationGroupBean to create an AuthorizationGroupBean.
I don't think it's needed, right?
I don't think it's safe to use the AuthorizationGroupBean that you can declare.
This should be an exception.
This should be done before the if(level == null) check, to ensure the config is always not null.
This needs to be done before the if(level == null) check, otherwise this will print the log level.
This will produce an Optional<Color> via map.get(PROPERTY_UNITS_COLOR_PREFIX) If the PROPERTY_UNITS_COLOR_PREFIX is not used it has to be a String. <LINK_0>
This will produce an Optional<Color> via map.get(PROPERTY_UNITS_COLOR_PREFIX) If the PROPERTY_UNITS_COLOR_PREFIX is not used it needs to be a String. <LINK_0>
This will need to be bound with the getCurrency and not the getCurrency.
"creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating the aliases here
"creator" and "lastModifier" should not be added to STANDARD_ALIASES instead of creating the aliases here
"creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating the aliases here.
You can use DiskImage::getImageStatus
should be DiskImage::getImageStatus
You should check if disks is not null
If you have a repo with an id of the repo then you need to re-use it here.
This can be @Override
This can be final.
List<Person> people = cast.getChildElements("actor"); people.add(makeActor(actor));
List<Person> people = List.of( cast.getChildElements("actor"), 0);
List<Person> people = new ArrayList<>();
Better do this as a constant.
Better do this in a constructor so that we don't need new ones
Better do this as an static variable
System.exit can return anything.
Log.debug
System.exit can be used instead.
We still need to call to super. partActivated()
We still need to call to super here.
We still need to call to super. partActivated() here
Here is another test case for parcel, not the parcel?
Here is another test case for parcel, not the parcel.
Why is this simply returning null?
The method should probably be private.
The method body should probably be: return new ImmutableMultimap<TypeName, TypeName>(Properties properties).put(properties);
The method body should probably be: java return new ImmutableMultimap<TypeName, TypeName>(entries);
[minor] static import 0.0.0.0:0 and doesn't need to be in a lambda as well.
[minor] static import 0.0.0.0:0 and doesn't need to be in a lambda as well?
[minor] static import 0.0.0.0:0 and is cut down on readability
Can we make these constants?
Can we make it constants?
Can we change this to 65536?
You are sure that both languages have the same settings, not just "computer-x.png" and "computer-x.png" are different. The reason being that would be the same, because we would have to use both annotations: ("java.util.Eclipse") and ("computer", "x.png")
You are sure that both languages have the same settings, not just "computer-x.png" and "computer-x.png" are different. The reason being that would be the same, because we would have to use both annotations: <?php echo WDYT?
You are sure that both languages have the same settings, not just "computer", and "computer", etc..
suggestion LOGGER.error("User id, returned a NULL media feed from instagram.", userId);
suggestion LOGGER.error("User id, {}", userId);
suggestion LOGGER.error("User id, {} returned a NULL media feed from in lives.", userId);
static import HIVE_STORAGE_FORMAT
This is wrong: the HIVE_STORAGE_FORMAT is not null. You should pass the HIVE_STORAGE_FORMAT directly and use it.
This is wrong: the HIVE_STORAGE_FORMAT is not null. You should either pass the HIVE_STORAGE_FORMAT or a codec's constructor.
For a lot of changes in this class it seems like there is a lot of duplication of the code. Can we please revert back to this line?
For a lot of changes in this class it seems like there is a lot of duplication of the code. Can we please revert back to the old code?
For a lot of changes in this class it seems like there is a lot of duplication of the code. Can we please revert back to your changes?
This synchronized block is not needed here as this.timedout.setIsSatisfied(true);
This synchronized block is not needed here as this.timedout.setIsSatisfied(true)
This is not thread safe.
I think this should use the ITimeEvent and not the ModuleEntryModel.
I think this does not work for the ModuleEntryModel. It is a set of bugs that you're taking into account the INVISIBLE if you go inside the outer if block and then you're back incurring the performance of the misspelling.
I think this does not work for the ModuleEntryModel. It is a set of bugs that you're taking into account the INVISIBLE if you go inside the else where you also need to override the ITimeEvent and cast to ModuleEntryModel.
The switch should be onlogLevel, not on JVM.
The switch is unnecessary, we already have default case
The switch is unnecessary, we already have a default case
looks like a good candidate for having a static import.
looks like a good candidate for @Before, setup, etc.
Why do you need this change?
maybe this should be readBytes < readLength, no?
maybe this should be readBytes < readLength, and then check to see if the text is changed?
maybe this should be readBytes < readLength, but maybe also rename to value or set.
This offset=0; is redundant here
This offset=0; is redundant.
This offset=0; is redundant here.
You could remove "this" here.
You could remove "this." here.
You could remove "this" from log statement.
This method may be unnecessary as the set is not synchronized.
This is not thread safe.
This method may be unnecessary as the synchronized methods are not thread safe.
no need for this empty line
no need for a Boolean here
no need for a Boolean here.
Shall we throw a runtime exception.
Exception should be logged.
I would throw an exception.
It seems to me that this is unnecessary, I think.
It seems to me that this is unnecessary, I think we should remove it.
It seems that this is unnecessary, I think.
Why are you using an empty list instead of null?
Why are you removing the space at the beginning of the sentence?
Why are you removing the space at the beginning of the string?
you could use a boolean also and get rid of StringUtils stuff
you could use a boolean also and get rid of the left side (you're using 'byte') here and above with 'boolean'.
you could use a boolean also and get rid of the left side
could you add an assertion to the log message?
could you add a log message?
could you add a second parameter to log message?
return bo? objWithBooleanField.b : aBoolean;
return bo? objWithBooleanField.b : aBoolean field;
return bo? objWithBooleanField.b : aBoolean
You can use ops.add(address, Values.of("transaction-support", transactions).and("module", module));
You can use ops.add(address, Values.of("transaction-support", transactions).and("module", module)) instead.
You can use ops.add(address, Values.of("transaction-support", transactions).and("module", module)); here.
Move this to initialize() method.
why do you need to define it here?
why do you need to define it as final?
Could you make these more specific?
Could you please remove these debugging output?
Remove
needs 2 _arguments_, plural
needs 2 _arguments_. plural
needs 2 _arguments_
Should be if (fInputHandler.saveTargetDefinition())
Should return if the saveTargetDefinition() was not null
Should be done in the finally block
This assertion is not sufficient, you are using the asserts already enabled by JUnit.
This assertion is not sufficient, you don't need to do this.
This assertion is not necessary anymore.
I think it is worth to add a log.info in this method?
I think it is worth to add a log.info message here to make sure that drain is shutdown.
What if drainExecutor is null?
Shouldn't we be using HarmonizationTableStudyId: "Harmonization Study ID cannot be null or empty"?
Shouldn't we be using HarmonizationTableStudyId: "Harmonization Study ID cannot be null or empty"
Shouldn't we be using HarmonizationTableStudyId?
You can use TimeUnit.MILLISECONDS.toLong() here.
You can use TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis())
You can use TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis()) here
Please move it to a constant.
Do you really need the.register() method?
Please move it to a constant
Guava Strings#toString(java.lang.String) could simplify this code a little bit.
Guava Strings#toString(java.lang.String)
Guava Strings#toString(java.lang.String) already does this.
nit: I'd make the output a bit more clear, something like "Reviewed Reviewed"
nit: I'd probably include the & in the text.
nit: I'd probably include the & in the output.
As discussed before, you can remove the public modifier from tablePropertiesInputs.get(2).asString()
As discussed before, you can remove the public modifier from the class and create two methods.
As discussed before, you can remove the public modifier from tablePropertiesInputs.get(2).sendKeys()
Do we really need to test this as well?
Do we really need to test that the URL was expected?
Do we really need to test this?
suggestion onLastOp = newOnLastOp;
nit: suggest using Preconditions.checkState() instead.
nit: suggest using Preconditions.checkArgument over asserts.
This whole method is too long. Please change it to java List<String> res = doc.getAdapter(BundleGroup.class); if (bgroup!= null) { res.add(bgroup.getId()); } return res;
This whole method seems to be doing more than one iteration over the parents. Can you change the implementation to use the iterator instead?
This whole method is too long. Please simplify it.
Why not private?
Why not public?
Why not remove the if statement?
Would you mind making this private? Additionally, I think it should only be called from the AnnotationMetadata constructor.
Would you mind making this constructor private? It's only used by tests, so there's no reason to make it public.
Would you mind making this package protected? I think it should only be used by the AnnotationMetadata constructor.
sendEmailForWorkspace only checks for workspace metacard with a email but we don't actually need to do it?
Create a separate method to update the timestamp field?
whitespace
lzSearchExecutor -> lzSearchExecutor
lzSearchExecutor -> WatchDogService
WatchDogService is a very bad name ;-)
What if it's absent? In my account it may be absent, for example
What if it's absent? In my opinion it should be : remove
What if it's absent? In my opinion it should be : remove.
suggestion if (mBannerSpot == null) {
suggestion if (mBannerSpot!= null) {
Remove the if statement.
This should be ether, not Force
This should be final.
This should be an import...
should this be more strict? i.e. require at least one character inside the parens?
should this be at least one character? i.e. require at least one character inside the parens?
should this say something like "The pattern must contain at least one group."? i.e. require at least one group.
Same as above, but I think this should be default.
Same as above, but I think it would be better to have a "check" method for this value.
Same as above, but I think it would be better to put the default value for the cache if you need to.
Can you also capture stats on the hit ratio, load time and total weight.
Can you also capture stats on the hit ratio, load size and total weight.
Can you also capture stats on size of file, load size and total weight.
This should be only if (getRoot().getAttribute("class").contains("cellTableSelectedRow"))
This should be only if (getRoot().getAttribute("class").contains("cellTableSelectedRow")) You can modify the method too.
This should be only if (getRoot().getAttribute("class").contains("cellTableSelectedRow")) You can set the attribute only once, for example.
Nit: I would be more explicit.
Nit: I would find static methods for these methods.
final.
Why not pass null here instead of empty string?
Why not pass null here instead of "m_resolvedIntf"?
Why not pass empty string here instead of null?
Use ImmutableSpongeValue.
Use ImmutableSpongeValueBuilder
Use this.key.
No need for null check.
No need for null check. Just check for null without the required method.
No need for null check. Just check for notNull.
Attempt to create an instance of the WorldProvider who has no registered type!
Attempt to create an instance of a WorldProvider who has no registered type!
Why are you casting getClass() to a Class?
Can we update the code if the current user has the ability to cancel the excludee?
Can we update the code inside the clientContext constructor? (IClientContext context)
Can we update the code inside the clientContext constructor?
Can this be private?
Can we make this a BeanDefinitionRegistry?
Can we make this a constant?
Remove this and use the 'this.' name.
Remove this and use the 'file' parameter instead
Remove this and use the 'this.' here
suggestion if (lastLen == 0) {
This check may cause the ArrayIndexOutOfBoundsException.
This check may cause the NullPointerException as well.
Consider writing this as return onStoreProxy(serverStoreProxy:: serverStoreProxy).iterator();
Consider writing this as return onStoreProxy(serverStoreProxy::iterator);
Consider replacing with Iterators.transform here?
do.getValue() on the next line
do.getValue() on the next line?
do we need to go through the Focus instance?
This test is failing for me, but we can make it more informative to test that the cause is a problem.
This test is failing for me, but we can make it more informative.
This test is failing for me, but we can make it more informative to test that the cause is a failure.
Could you please add a Builder to public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) throws Exception { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables())); }
Could you please add a Builder to public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) throws Exception { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode,  TpchTable.getTables(), embeddedElasticsearchNode); }
Could you please add a Builder to public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) and use it here instead of public constructor?
why are you no longer using this method?
please add a null check for pageViewCallback
why are you no longer using this method?
debug logging?
debug log?
you can keep the logging here as well
You don't need to call this method with the paymentSchedule
You don't need to call this method with the paymentSchedule. We can just drop the start date since it is already a clampedRate.
You don't need to call this method with the paymentSchedule. We can just have a single startRate method and call that with the paymentSchedule.
Use parameterized logging instead of string concatenation.
use parameterized logging instead of string concatenation
use parameterized logging instead of string concatenation.
@ivanarrizabalaga Maybe we should show a better opinion here?
@ivanarrizabalaga why do we need this?
@ivanarrizabalaga why do we need this? WDYT?
why else?
why is this else necessary?
why is this else necessary?
It doesn't look like this can be simplified.
It doesn't look like this can be written as a lambda.
It would be better to have this abstract class to get the stream.
same here, do we have to calculate the lint warnings
same question as above
Similar
Return value of the method is never used.
Could you use a variable index instead of calling length?
Return value of the variable index.
Perhaps we could use a more explicit equals here (and in the other tests)? java public static String equals(String name) { return name.equals(name); }
Perhaps we could use a more explicit equals here (and in the other tests)? java public static String equals(String name) { this.funcs = name; return func; }
Perhaps we could use a more explicit equals here (and in the other tests)? java Assert.assertEquals(parent, func)
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_1>
Why does this need to be canceled?
doStop() should probably be called in the constructor.
doStop() should probably be called here to prevent the current task from being canceled
Should this be a 'protected' method?
Should this be a 'protected' method? It's a private method so it can be called by other classes.
Should this be a 'protected' method? It's a private method so it can be called by other places.
assertThat(first).containsExactly(1, 0, 0).isEqualTo(3); looks better
assertThat(first).containsExactly(1, 0, 0).isEqualTo(3); looks clearer
assertThat(first).containsExactly(1, 0, 0);
This seems to be missing the @Override annotation.
This seems to be a public method in the base class?
This seems to be a public method in the base class.
Use try-with-resources so you don't need to manually close the session.
Use try-with-resources so you don't have to manually close the session.
use try-with-resources so you don't need to manually close the session.
I think this can be simplified to if (!isInterruptable() && mInterruptMessage.get(thread))!= null)
I think the logic is correct, mInterruptMessage.get(thread) returns null if mInterruptMessage.get(thread) is null. This will basically call a non-null value for mInterruptMessage.get(thread) and then the check for null value is not needed.
I think the logic is correct, mInterruptMessage.get(thread) returns null if mInterruptMessage.get(thread) is null. This will basically call a non-null value for mInterruptMessage.get(thread) and then there is no value in having the check for null. If it is the case, perhaps we should get rid of this condition?
Indentation doesn't seem correct here.
Indentation doesn't seem right here.
Indentation doesn't match should be 2 spaces only
There is a constant defined in VALID_NAME that you can use instead of a hard coded string.
There is a constant called MAX_NAMESPACE_LEN that can be used instead of a hard-coded number
There is a constant defined in VALID_NAME.
Missing <>, this is a raw type.
Missing <>, this is a raw type. We use a generic interface for this.
Missing <>, this is a raw type. It is specific to a generic type.
The query is not in the query. Also it looks like GetAllVmsFilteredAndSortedParameters should be renamed to BackendCollection.
[optional] write this as one line
Was this change made to the query?
pt should not be a parameter parameter
pt should not be a parameter
pt should not be null
Could just return fboManagerManagerSubscribers.add(subscriber)
Could just return fboManagerManagerSubscribers.add(subscriber);
Please, format this line.
Looks like questionsWithResponses should be included in the list of questionsResponses, right?
Looks like questionsWithResponses can be added in the for loop
Looks like questionsWithResponses can be added here as well
I'd rather use this.parseXMLToRelations instead.
Tiny thing, but I'd like to see a more consistent naming problem. "context" is a toString() method.
I'd rather use this.parseXMLToRelations(context, fileLocation); method to get the file location.
There's a lot going on in this method on the getDeclaredAnnotations() API. Could you change it to something like this: public List<ASTAnnotation> getDeclaredAnnotations() { List<ASTAnnotation> result = new ArrayList<>((ASTClassOrInterfaceBodyDeclaration) ); for (int i = 0; i < decl.jjtGetNumChildren(); i++) { result.add((ASTAnnotation) decl.jjtGetNumChildren(i)); } }
There's a lot going on in this method on the getDeclaredAnnotations() API. Could you change it to something like this: public List<ASTAnnotation> getDeclaredAnnotations() { List<ASTAnnotation> result = new ArrayList<>((ASTClassOrInterfaceBodyDeclaration) ); for (int i = 0; i < decl.jjtGetNumChildren(); i++) { result.add((ASTAnnotation) decl.jjtGetNumChildren()); } }
There's a lot going on in this method on the getDeclaredAnnotations() method
s.a.
s/alignedCodeListEntry/MongoCodeListEntry
s.a. <LINK_0>
Integer.toString(pairLine)
If <=="="
If <=="
Matchers.hasSize(0)
Matchers.hasSize
isEmpty()
Remove this.
Done
Done.
Verifying the variable name is probably redundant now
Verifying the deleted error message might be good?
Verifying the deleted error message might be better?
What if the storage pool was inactive and you moved it to maintenance and failed.
What if the storage domain was inactive and you moved it to maintenance and failed.
What if the storage pool was failed to be started and you moved it to maintenance and failed.
s.isEmpty()?
If this is empty, I would prefer if (first) { if (subs.isEmpty()) { //... } else { } } with no indents...
If we are going to add some magic numbers, I would prefer a variable name for the method names.
Does that need to be asserting that snapshots.isEmpty()?
Does this need to be asserting that snapshots.isEmpty()?
Does this need to be assert that snapshots.isEmpty()?
suggestion return Collections.singleton(a -> new SimpleGrantedAuthority(a.getUserRole()))
suggestion return new SimpleGrantedAuthority(a.getUserRole());
suggestion return Collections.singleton(a -> new SimpleGrantedAuthority(a.getUserRole())));
possible NPE
possible NPE?
possible null
This is somewhat sensitive. Let's still add this as a public static method.
This is somewhat sensitive. Let's still add this as a constant.
This is somewhat sensitive, such as a toString()
why has this changed?
why is this needed?
why has this been added?
Should be using NumberUtil.ChromedriverVersion
Should this return the version?
Should be using NumberUtil.ChromedriverPorts()
List<Spec> list = fileAssociationViewer.getStructuredSelection().toArray(new Spec[list.size()]); to avoid the cast.
"Collection" is more efficient, as you can see below
"Collection" is more efficient, as you're manipulating the list.toArray()
This is a case. If we have a container, but the container is connected to the same container, we shouldn't be able to deal with the free resources.
This is only needed if we have a Container in the free resources.
This is a case. If we have a container, but the container is connected to the same container, we shouldn't be able to deal with the free resources. Consider the case where we handle container in the same container.
This would be a bit more clear if it wasn't empty yet.
This looks like a copy/paste error.
This looks strange. Why not instantiate the driverPool field?
Looks like this should be private.
should we have an assertion that the message holder is not null?
should we have an assertion that the MessageHolder can be null?
Long.MAX_VALUE nanoseconds
Long.MIN_VALUE and Long.MAX_VALUE may work better.
Long.MAX_VALUE nanoseconds would be more readable than zero for performance reasons.
We should use!TextUtils.isEmpty(swipeDismissListener)
We should use!Utils.isNonEmpty
We should use!TextUtils.isEmpty(swipeDismissListener) instead.
Dont we need to call this method in the test?
Shall we also call verifyResponse(apiCreationResponse).get()?
Dont we need to call verifyResponse.
I'd suggest doing the same, but not a big deal, as is it possible that we're not retrieving the CountInputStream from a writer or reading it from the factory.
I'd suggest doing the same, but not a big deal, as is it possible that we're not retrieving the CountInputStream and then getting it again on the next line.
I'd suggest doing the same with the CountInputStream as in the other convertObject.
Add Pagelogging
AddPinComponentObject entity = new AddPinComponentObject(driver); driver.switchTo().frame(mapFrame).click(); driver.click(); return new AddPinComponentObject(driver);
AddPinComponentObject entity = new AddPinComponentObject(driver); driver.switchTo().frame(mapFrame).click(); driver.click().perform();
container can be null, please add "throws NotImplementedException"
container can be null, please add "throws RuntimeException"
container can be null, please add.add()
Would be good to move this contstant to this file and name it something like WIDGET_ANSWER_STANDARD_MARGIN_MODIFIER.
Why rename this contigtion to FIELD_HORIONTAL_MARGIN_MODIFIER?
Why rename this contigtion to FIELD_HORIONTAL_MARGIN_MODIFIER? This method should probably be private.
userRepository and modelMapper invocations are not verified
userRepository and modelMappers are not verified
userRepository and modelMappers don't be changed by each test.
I'm not sure if this should be throwIfTabLayoutIsMissing when the context is broadcast. We should do it in a separate throwIfTabLayoutIsMissing method.
I'm not sure if this should be throwIfTabLayoutIsMissing - it should just throw the exception if it is not the case.
I'm not sure if this should be throwIfTabLayoutIsMissing when it is true. We should do it else if (tabLayoutId!= null &&tabLayoutId!=...
If the config parameter is set to null then we don't need to make it final.
If the config parameter is set to null then we don't need to make it null.
If this method gets called both build and bootstrap methods, then I think we should make it static.
why not let defaultHistory = new SegmentMetadataQueryQueryToolChest(config.defaultHistory());
why not have defaultHistory = new SegmentMetadataQueryQueryToolChest(config.defaultHistory());
not public
I think the stream() is redundant here.
I think the stream() is unnecessary.
I think the stream() is unnecessary..
gerrit-server.bind(ChangeDetailFactory.class);
I'd rather use 204.
gerrit-server.bind(ChangeDetailFactory.class, "class");
nit: static import isEmpty() for readability
nit: static import isEmpty()
nit: static import isEmpty, assertFalse()
Shouldn't this method be public?
Shouldn't this be wrapped in try... finally block?
Shouldn't this be wrapped in a try... finally?
ReloadRequiredRemoveStepHandler does nothing
ReloadRequiredRemoveStepHandler does nothing here.
ReloadRequiredRemoveStepHandler does nothing by default.
this.do not work; you need to set this to false.
run = true so this will not work.
run = true;?
I am a little worried that this could cause a problem with the scenario where the user pulls the same routes as the docker-service's cache. One might be ok to add this block here - please elaborate.
I am a little worried that this could cause a problem with the scenario where the user pulls the same routes as the docker-service's cache. One might be ok with this, but it seems like it wouldn't make much sense.
I am a little worried that this could cause a problem with the scenario where the user pulls the same routes as the docker-service's cache. One might be ok with this, but it seems like it wouldn't be worth it.
Maybe log the _sigh_ metrics and/or log the exception for context?
Maybe log the _debug_ message here?
Maybe log the _sigh_ metrics here?
I would prefer to move this check to the removeFromListAndUnlock
I would prefer to move this check to the removeFromListAndUnlock so that we only have to lock the list of deleted resources, or do we need to lock it for another reason?
I would prefer to move this check to the removeFromListAndUnlock so that we only have to lock the list of deleted resources, or do we need to lock it?
Throw a SessionUnavailableException instead.
I think this should be returning null if there is an error in the currentUserId.
I think this should be returning null if currentUserId is null.
can we use Arrays.copyOf?
cannot this be the right exception?
cannot this be the right exception? I would prefer to have a different exception type.
Add final keyword.
Why set it to null here?
Should this be removed?
How about ExitStatus.COMPLETED.equals(exitCode)?
So...wrong 'exitCode'?
How about ExitStatus.COMPLETED.equals(exitCode)?
These "refs/*" don't exist in the repository group, but instead you can "refs/*" just in case someone performs refs/refs/tags in the directory.
These "refs/*" don't exist in the repository group, they are declared by the parent group.
These "refs/*" don't exist in the repository group, but instead you can "refs/*" just in case something exist in the config.
As [minor] you could make this one assertion: assertThat(timestampMatcher.find()).isLessThanOrEqualTo(expectedMinimum) and assertThat(timestampMatcher.group(1)).isGreaterThanOrEqualTo(expectedMinimum);
As [minor] you could make this one assertion: assertThat(timestampMatcher.find()).isBetween(expectedMinimum) and match the one on: assertThat(timestampMatcher.group(1)).isTrue();
As [minor] you could make this one assertion: assertThat(timestampMatcher.find()).isLessThanOrEqualTo(expectedMinimum) and assertThat(timestampMatcher.group(1)).isGreaterThanOrEqualTo(expectedMinimum)
why not use the compareAndSet method in all cases, instead of compareAndSet?
Is it necessary to have this check in the constructor and instead of compareAndSet?
why not use compareAndSet?
Can we test whether user is running on a nonDev environment? If not, we should try to restore the current page's perspective.
Can we test whether user is running on a nonDev environment? If not, we should try to restore the current behavior.
Can we abstract this out into a method?
suggestion throw new IllegalStateException("Unsupported type: " + path.getClass().getName());
suggestion throw new IllegalStateException("Unsupported type: " + path.getClass().getName()));
suggestion throw new IllegalStateException( path.getClass().getName(), path));
Just put.filter(field -> field.getType() instanceof GraphQLNonNull).map(Field::getName)
Just put.filter(field -> field.getType() instanceof GraphQLNonNull)
Just put.filter(field -> field.getType() instanceof GraphQLNonNull) here.
It would be better to have a new copy of the list to modify the original one.
It would be better to have a new copy of the list to modify the new one.
It would make more sense to have a new copy of the list in the middle of the editorTextWidget and put it in the new set.
convert to Optional.empty() instead of this if else.
convert to Optional.empty() instead of this else.
convert to return this..
I'm not sure if tokenDAO.findById() can return null, it will throw NPE
I'm not sure if tokenDAO.findById() can return null, you are getting a NPE here.
I'm not sure if tokenDAO.findById() can return null
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own collection?
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
@apc999 This would simplify
@apc999 This would avoid requireNonNull
@apc999 This would avoid NPE
@lautarobock Here too, let's declare throws Exception.
@lautarobock Same here, let's declare throws Exception
@lautarobock Here too, let's declare throws Exception
concatMap(this::listSegmentsForYear) can be replaced by mapMany(s -> listYears()).filter(s -> s.map(this::listSegmentsForYear)).forEach(this::getEventsForSegment);
concatMap(this::listSegmentsForYear)::getEventsForSegment
concatMap(this::listSegmentsForYear) can be replaced by mapMany(s -> listYears()).filter(s -> s.map(this::listSegmentsForYear)).
LOGGER.trace?
LOGGER.tracef
trace
I think it would be better to wrap this in a long rather than a default timeout. We may want to shorten the test to something like 30 seconds.
I think it would be better to wrap this in a long rather than a timeout. We may want to default the default timeout from the Geode timeout.
I think it would be better to wrap this in a long rather than a default timeout.
@ngwax, you are not supposed to handle null for an instance of InetSocketAddress
@ngwax, you know if that is an issue in the check. and if null is returned the array of inetSocketAddress in the first place, you could detect an NPE in the first place.?
@ngwax, you know if that is an issue in the check. and if null is returned the array of inetSocketAddress in the first place, it won't be getting the exception message.
Consider renaming this function to avoid the confusion.
Consider renaming this function to avoid the duplications.
Consider renaming this function to avoid the duplications/unnecessary.
Can't this be moved into the public AuthenticationInfo authenticate method? If so, then we need to move this to a static method
Can't we put the connection into a variable like the other methods?
Can't we pull the connection into a variable?
I would prefer that the rest of the test passes on the rest of the test.
I don't think we should close on its own.
I would prefer to close on its own.
better to add the error message like "The generated code from Butter Knife. Do not modify!")
better to add a known error message like "Session Builder not modify!")
this makes it impossible to do the builder also... I'd rather keep it as is and create the java file only the generated code.
I think this and the one below should be: java public static Credential refreshToken(Credential credential) throws IOException { try { credential.refreshToken(); return credential; } catch (NullPointerException e) { throw new IllegalStateException( "Couldn't refresh the OAuth token. " + "want to use a different file, first clear your stored credentials: " + "enomics.readthe credentials: " + "enomics.remove(e); } }
I think this and the one below should be: "Couldn't refresh the OAuth token. " + "want to use a different file? If the " + "want to use a different file, first clear your stored credentials.");
I think this and the one below should be: "Couldn't refresh the OAuth token. " + "want to use a different file? If the " + "want to use a different file, first clear your stored credentials." + "enomics.readthe credentials.xxx"
This is pretty dangerous and I don't see a way to write a list, which is pretty simple and very confusing. I'd just make it something like getStorageDomainDao().get(getParameters().getStorageDomainId()).
This is pretty dangerous and I don't see a way to write a list, which is pretty simple and very confusing. I'd just make it something like DestroyImageVDSCommand and add it or something.
This is pretty dangerous and I don't see a way to write a list, which is pretty simple and very confusing. I'd just make it something like getStorageDomainDao().get(getParameters().getStorageDomainId()) and then use it
Keep this counter as a constant, so we don't need to create a new gauge.
Keep this counter as a constant, so we can reference it in the constructor.
Keep this counter as a constant.
Should be externalized
Please make it localizable?
Might be nice to make it configurable
Shall we catch specific exception?
Better to catch specific exception like IOException catch.
Can we catch specific exception?
Why was this removed?
shouldn't this be a AssertionErrorDialog?
shouldn't this be a GraphLoadService instead?
probably better to return totalSize!= 0 && availableDiskSize / totalSize;
why do you need to return 0 if it's always 0?
why do you need this?
since the ArgUtil.notNull already takes care of this, we're making the defensive copy of the input, so why not just ArgUtil.notNull here?
since the ArgUtil.notNull already takes care of this, we're making the defensive copy of the input, so shouldn't we just pass the refs into the this method?
since the ArgUtil.notNull already takes care of this, we're making the code null safe
return String.join(",", subscription);
string.join(",", subscription);
string.join(",", subscription);?
This is a good place to make sure it's consistent with other files in the location.
This is a good place to make sure the segment does not exist in it.
This is a good place to make things more stream-like
Should be assert?
This check is not needed.
Should it be require childId == 0
Modifying the thread is risky. We should have an async flag on DataThread to do this.
Modifying the thread is risky. We should have a synchronization on the object itself that may fail if we're counting the position.
Modifying the thread is risky. We should have a synchronization on the object itself.
@fanifieiev the same above.
@fanifieiev the same above. please use final
@paulodamaso the braces and return are not needed here
I think it should be failOnMissingField && failOnMissingField.
.orElse(false) is enough
I think it will be better to use.orElseThrow( ) here. It is not enough
This is the default case that we do not want to set it to the default value.
This is the default case that is specified in the constructor.
This is the default case that we don't want to set it to empty strings.
RuntimeException?
RuntimeException? :)
Exception?
Let's make this a precondition, and make the constructor to be called from other properties.
Let's make this a precondition, and make the constructor to return precondition.
Let's make this a final int
as you're changing this, replace 'try' with'catch (Exception e)'
as you're using a different method, replace 'getNextPage' with'return true'.
as you're changing this, replace 'try' with'catch (Exception e)'.
You can just add player name like "Only player specified in one player, " + super.getRule();
You can just add player name as a variable to consistent with the rest of the codebase.
You can just add player name as a variable to use player name instead of player.
"isRevisionSupported" -> "isVersionSupported"
How about getActionType().isRevisionSupported()?
How about getActionType().isRevisionSupported(repo)?
extract the exception to a constant and reuse it for the log message
extract the exception to a constant and reuse it for the log
extract the exception to a constant and reuse it for the log messages
why not private static?
why not public static?
why public?
Can we have a method like this? public void execInitClipboardForm(ClipboardForm form) {... } Or, better yet, rename the method.
Do we have to call this from here? It looks like there could be too many null checks.
Can it be public?
I would suggest public static void assertDataSketchAvailable() { try { StringSketch(); } catch (Throwable t) { throw new ISE(t, "DataSketches is unvailable. Try adding the druid-datasketches extension to the classpath."); } }
I would suggest public static void assertDataSketchAvailable() throws IOException { try { StringSketch(); } catch (Throwable t) { throw new ISE(t, "DataSketches is unvailable. Try adding the druid-datasketches extension to the classpath."); } }
I would suggest public static void assertDataSketchAvailable() { try { StringSketch(); } catch (Throwable t) { throw new ISE(t, "DataSketches is unvailable. Try adding the druid-datasketches extension to the classpath."); } catch (Throwable t) { } }
Better revert.
Better to return this permission directly.
hasPermission()
You don't have to wrap here, if it's null, you can't put hist into a variable.
If getOrAddBucket() returns null, then you'll get a NPE.
You don't have to wrap here, and below.
The condition should be replaced with!TextUtils.isEmpty(assignmentId).
The condition should be replaced with!TextUtils.isEmpty(assignmentId)
The condition should be replaced with!TextUtils.isEmpty()
I think we could simplify this to if (rowNumbersOut == null) { return; } else if (inputNumbers == null) { int outerIdx = offsets[offsetIndex]; rowNumbersOut[numResults] = adjustValue(offsetIndex, value); } else { int outerIdx = numResults;...
I think we could simplify this to if (rowNumbersOut == null) { return; } else if (inputNumbers == null) { int outerIdx = offsets[offsetIndex]; rowNumbersOut[numResults] = adjustValue(offsetIndex, value); } else { int outerIdx = inputNumbers[numResults] = outerIdx; }
I think this should be private.
I'd prefer not to use contains() here. Same goes for fn and field.
I'd prefer not to use contains() here.
I'd prefer not to use contains() here since this would be unlikely to be seen.
this one is not needed
You could get the value from GlowPlayer here
You could get the value from GlowPlayer.
please move it to an 'else' part - we already know the vm is null
please move it to an 'else' part - for readability
please move it to an 'else' part - we already check the vm!= null
please use Assume.assumeTrue(mCameraId!= null);
I think this is a wrong place for this test. If mCameraId is null, you will set the lens facing behavior in the test below. This is why the test fails in the previous test.
please use Assume.assumeTrue(mCameraId!= null); in all the tests.
suggestion return convert(Arrays.asList(args));
suggestion return setDouble(Arrays.asList(args));
Why does this have to be static?
remove double a valid from test & implementation
remove double a valid from managed Realm object.
removed double a valid from test & implementation
Can we move this check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
Can we move this check back to the top of the method? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
Can we move this check back to the top of the method?
for (SourceControl sourceControl : SourceControl.SourceControlBean) { sourceControlList.add(new SourceControl.SourceControlBean(sourceControl)); }
for (SourceControl sourceControl : SourceControl.values()) { sourceControl.add(new SourceControl.SourceControlBean(sourceControl)); }
for (SourceControl sourceControl : SourceControl.values()) { sourceControl.add(new SourceControl.SourceControlBean(sourceControl)); } }
Instead of checking the result of arg.getData().equals(Boolean.TRUE) you could just check to instanceof OoyalaNotification as well
Instead of checking the result of arg.getData().equals(Boolean.TRUE) above, you could just use!= null.
Instead of comparing to Boolean, you can use == here
use.getUuid instead of getArtId, which will go away
Use.getUuid instead of getArtId, which will go away
need to handle case where the insertion fails with a 'e'
CodenodeID could be used here, what do you think?
nodeID could be null
CodenodeID could be null
Same as above, why do we need the cast?
Same as above. Use the same approach for all 3 methods.
Same as above. Use the same approach for all 3?
why not break here?
I think you should break out of the loop here too.
why not break?
same here, just use context.setAttribute(traceContext, context)
same here, just use context.setAttribute(traceContext)
same here, just use the span name
If fArg1.isNoexcept(overload) && (arg1 is noexcept) && (arg2 is noexcept) && (arg1 is noexcept) && (arg2 is noexcept).
If fArg1.isNoexcept(overload) && (arg1 is noexcept) && (arg2 is noexcept) then we need to return false
If fArg1.isNoexcept(overload) && (arg1 is noexcept) && (arg2 is noexcept) && (arg1 is noexcept).
Please, make it private.
Please separate the methods with descriptive names.
Please, make it private
nullity check here too :)
null check here too :)
null checks
config key is out of sync. change it to use speedUnits.length
config key is ok
config key is out of sync. change it back to 5k
@ivandalbosco Is it possible to test tree.parentTree() == null?
@ivandalbosco Is it possible to test tree.parentTree() instanceof JavaScriptTree?
@ivandalbosco Is it possible to test tree.parentTree() instanceof JavaScriptTree and compare it?
Before we always had non-null returns
Before we always had non-default mode, let's set it to -1
Before we always had non-default constructor, I would prefer we let the default constructor be used.
HashMap should be good here, I think.
HashMap should be good here.
HashMap should be CopyOnWriteArrayList
I would add an IllegalArgException with a message that says "Already closed."
not a big deal, but it would be nice if currentPageId was extracted into a variable for currentPageOffset.
not a big deal, but it would be nice if currentPageId was extracted into a variable
Wouldn't we want to unify these names and pick either onReady or onDataChanged? Other than that, LGTM!
Wouldn't we want to unify these names and pick either on the names or pick either on their names or on their names?
Missing fault that is some legacy stuff for JBI/WS.
I think this should be synchronized
I think this should be RemoteExceptions.
I think this should be guarded by a condition here
I'm not sure if the value for this list is necessary...
I'm not sure if the listed property is necessary...
I'm not sure if the value for this list is necessary.
There is no upper bound on the value of this char, so this may cause problems.
There is also StringUtils.defaultString() for this.
There is also StringUtils.defaultString(nameOrNumber) in another utility class
the QQ should return an error dialog, not a user
the QQ should return an error dialog, if the caller wants to do something
the QQ should return an error dialog, not a user.
missing @Override
Arrays.asList?
public instead of public
Can you use the new GnirsGratingOptics(getDirectory(), _grating.get(), _centralName, 1) here?
Can you use the new GnirsGratingOptics(getDirectory(), _grating.get(), _centralName, 1) here? And below.
Can you use the new GnirsGratingOpticsBuilder here?
As above, please do assert on the message message, which will be an aid in tests
As above, please do assert on the message message, it will be an aid in tests
As above, please do assert on the message message, which will be an aid in tests.
Removing this as a debug message is a bit too verbose. This is hard to debug. How about adding a debug log message?
Removing this.
registered
This is a test, not a test.
This is a test.
This is missing a test for this.
suggestion if (castTargetType.toLowerCase().startsWith(clobCompatibleCastTargetTypes[i]) || (castTargetType.toLowerCase().startsWith(clobCompatibleCastTargetTypes[i]) {
suggestion if (castTargetType.toLowerCase().startsWith(clobCompatibleCastTargetTypes[i]) || (castTargetType.toLowerCase().startsWith(clobCompatibleCastTargetTypes[i])) {
suggestion if (castTargetType.toLowerCase().startsWith(clobCompatibleCastTargetTypes[i]) || (castTargetType.toLowerCase().startsWith(clobCompatibleCastTargetTypes[i])
This seems a bit unrelated to this commit. Can we move it?
This seems a bit unrelated to this commit. Can we remove it?
This seems a bit unrelated to this commit.
Travis fails with this line. Should probably be in an xml file
Travis fails with this line
Line length
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
Would suggest using another MapID for 006 and 007 to break dependency from 001 and 002 to be successful
Would suggest using another MapID for 001 and 002 to be successful
Remove the extra empty line.
Remove the extra empty line
Remove ;
This is the default value. It's not necessary to accept an invalid volume.
This is the default value. It's not necessary to specify an IP for NAS load into the database.
Why not to use DomainOrder.FATAL?
rollback this?
rollback this newline
rollback this
Would you be able to create the SecureRandom once and use the TrustManagerFactory.DEFAULT_SSL instead?
Would you be able to create the SecureRandom once and use the TrustManagerFactory.DEFAULT_WIDTH constant?
Would you mind at least having a description of the exception?
Why is this constructor public?
Why do you need this constructor?
Why is this constructor public? It should be private.
Need to pass the timeBucketId as a parameter to store.getTimeBucketFor
Should we be returning the timeBucketId here?
Should we return false here?
nit: I think it would be better to throw new RuntimeException(e) instead of e.getCause().
nit: I think it would be better to call this method in PageWithPositionComparatorCacheKey
nit: I think it would be better to call this method in PageWithPositionComparator, as it is a general method.
I think you mean (d<=0)
I think you mean (d<=0L)
I think you mean (d<=0L);
nitpick: can we just move the @Override annotation to a separate line?
suggestion if (mQuickStartAdapter!= null) {
nitpick: can we just move the @Override annotation to the top, and remove the annotation?
Too long?
Typo?
Too long?
Can't you get the timezone from the context?
Can't we get the timezone from the context?
Can't you get the timezone from the running instance?
save a string constant
reuse a constant string
reuse a constant
s/MonitorDomainNames.Rebalancer.name()/redisMetrics
s/MonitorDomainNames.Rebalancer.name()/clusterName/
MonitorDomainNames.Rebalancer.name().
Not sure what this is for. Why not pass RETRY_THREAD_COUNT to RETRY_THREAD_COUNT?
Not sure what this is for. Why not pass RETRY_THREAD_COUNT to this constructor?
Not sure what this is for. Why not pass RETRY_THREAD_COUNT to this constructor and reuse the same name?
List internally defines the size of the event.
List internally defines the size of the event?
public?
This would be better. marshaller = componentRegistry.getComponent(Marshaller.class);
This would be better. marshaller = componentRegistry.getComponent(Marshaller.class); That way there is no need to check if cache is null. Even if cache is not initialized, there is a Marshaller.
This would be better. marshaller = componentRegistry.getComponent(Marshaller.class); That way there is no need to check if cache is null. Even putIfAbsent() would work just fine.
call super.getReturnValue() so the cast is not needed.
call super.getReturnValue()
Unnecessary cast.
@vilchik-elena I think that we could raise issue on the condition of the condition (ConditionCondition.is(Kind.BOOLEAN_LITERAL)).
@vilchik-elena I think that we could raise issue on the condition of the condition (ConditionCondition.is(Kind.BOOLEAN_LITERAL)) and save a couple lines of code.
@vilchik-elena I think that we could raise issue on the condition of the if statement in this case by using condition.
use getCurrentIndex() method to create index.
Use getCurrentIndex() method to create index.
use getCurrentIndex() method to create the index.
suggestion return name.equals(that.name);
TableDataSource.equals(Object) is redundant.
suggestion return name.equals(that.name); )
So have you considered just client = NioClient(serverAddress, peer, connectionTimeout);?
Change NioClient constructor to NioClient
Change NioClient constructor to NioClient?
nit: fix spacing
nit: fix code style
nit: fix code style.
Do we need to break after this line?
Do we want to break here?
Do we want to break after this statement?
Should use the constructor for this.context = builder.sb.length() > 0? builder.sb.toString() : null;
Should use the builder.sb.length() > 0 check.
Should use the builder.sb.length() > 0 check, or the similar.
Another spot where to convert the string to a string. You should probably move that to a new String( ) constructor.
Another spot where to convert the string to a string. You should probably move that to a new String( ) method.
Another spot where to convert the string to a string.
Why do you need this?
Why do you need a new m_ prefix for test methods?
Why do you need a new m_ prefix for test case?
Same as above, why not use try with resources?
Same as above, try with resources.
Same as above, try to avoid using try with resources.
We should add a null check for options before invoking this method.
We should add a null check for options before invoking this call.
We should add a null check for options before using it.
Add parentheses around containsKey and get.
Add parentheses around that.
Add parentheses around that one liner?
No.
no.
Replace with 0
Is this always safer than using Locale.getDefault()?
Pls use Locale.getDefault() as it is the same for all other places.
Pls use Locale.getDefault() as it is the same as in other classes.
Missing final
Missing the Context.
Missing final.
Can you delete the extra brackets around windowCount++ and the log statement? I don't want to overly clutter this example after merging. I'm going to write more than it already is.
Can you delete the extra brackets around windowCount++ and the log statement? I don't want to write more than it already is. I don't want to overly clutter this example (more than it already is).
Can you delete the extra brackets around windowCount++ and the log statement? I don't want to write more than it already is. I don't want to overly clutter this example after merging this PR. I'm going to write a sample of all the changes in this file.
Just to be safe, we need to consider the following code. if (obj instanceof ReferenceBindingSetWrapper) { ReferenceBindingSetWrapper other = (ReferenceBindingSetWrapper) obj; return this.referenceBinding.equals(other.referenceBinding); } return false;
Just to be safe, we need to consider the ReferenceBindingSetWrapper as well. ReferenceBindingSetWrapper is a inner class so you can just write return this.referenceBinding.equals(other.referenceBinding);
Just to be safe, we need to consider the referenceBindingSetWrapper as well. ReferenceBindingSetWrapper is a inner class so you can just write return this.referenceBinding.equals(other.referenceBinding);
what is the point of returning null here?
what is the point of having this null check?
NotNull
I think this was an overhead. Won't it make sense to wait until stop() is called before the jar files are loaded?
I think this was an overhead. Won't it make sense to wait until stop() is called?
I think this was an overhead. Won't it make sense to wait until stop() is called before the jar file is loaded?
s/logLevel//
logLevel == null?
s/logLevel//?
It seems like all this logic related to monitoring should be moved to somewhere else?
It seems like all this logic related to monitoring should be moved to somewhere else? Maybe use a constant!
It seems like all this should be moved to somewhere else if else to make it clearer
Why not: @Transactional(propagation = Propagation.REQUIRES_NEW)? Thanks
Why not: @Transactional(propagation = Propagation.REQUIRES_SESSION)? Thanks
Why this 'if'?
nit: This could be shortened to: suggestion.max(Comparator.comparingInt(v -> v.version))
nit: this could be APIVersion.VALID_VERSIONS.values()
nit: This could be APIVersion.VALID_VERSIONS.values()
I would prefer to throw a RuntimeException here.
I would prefer to have a Preconditions.checkArgument check here to verify that s is not null
I would prefer to have a Preconditions.checkArgument check here.
Nit: Consider extracting this to a method for readability (i.e. getSuiteName(iTestResult.getTestContext()), and use that in both places.
Nit: Consider extracting this to a method for readability (i.e. getSuiteName(iTestResult.getTestContext()), and use that in all test methods below
Nit: Consider extracting this to a method for readability (i.e. getSuiteName(iTestResult.getTestContext()), and use that in all the method below
I think that if Entity#setLock is no longer necessary. #Closed
I think that if Entity#setLock is no longer necessary. #setVmIfExists(Engine::set) is called before the user starts the lock. Correct me if I'm wrong.
I think that if Entity#setLock is no longer necessary. #setVmIfExists(Engine::set) is called before the user starts the lock. Is it actually the case?
Typo, should be XXX
Typo
Typo?
method should be static and non-static, if we have it more than once.
method should be static, and non-static, as it is called automatically in class.
method should be static, and non-static, as it is called from test class.
Can we squash your commits into one? I mean, if it is not a PR, then I would squash it into master.
Can we squash your commits into one? I mean, if it is not a PR, then I would squash it into commit.
Can we sue it to be public?
a bit of extra paranoia, but why don't you use "," as a separator instead of a comma?
a bit of extra paranoia, but why don't you use 'this.value = "," + value;'?
a bit of extra paranoia, but why don't you use 'this.value += "," + value;'?
You can use Java 8 String.join instead of String.join
You can use Guava's MoreObjects.ToStringHelper(value) instead.
You can use Guava's MoreObjects.ToStringHelper(value) method, right?
@Nonnull?
@Nonnull please.
@Nonnull?
This is not related to this PR, but maybe we can make it a class member variable.
This is not related to this PR, but maybe we can make it package private?
This is not related to this PR, but maybe we can make it a method on the phase result?
With the context.getPackageManager(), we could use registry.prepend(String.class, Drawable.class) to keep it consistent with other fields.
With the context.getPackageManager(), we could use registry.prepend(String.class, Drawable.class) to keep it consistent with other types.
With the context.getPackageManager(), we could use registry.prepend(String.class, Drawable.class) to keep it consistent with other classes.
Why a array?
Why a nested array?
static import
Breaks into previous line?
Breaks into previous line.
Breaks the loop into new lines?
Add a newline after the :.
Logging and throwing this?
Logging
shut this down first. General rule of thumb to follow - whatever starts last shuts down first. Otherwise, stores may shutdown and throw exceptions.
shut this down first. General rule of thumb to follow - whatever starts last shuts down first. Otherwise, stores may shutdown and throw exceptions. The line above can be removed from here if else.
In case clusterManagerAdapter is null, then line 92 will throw NPE. Is this intentional?
Should we rename this variable to something like deleteResultsCollection?
Should we rename this to deleteResultsCollection?
Should we rename this variable?
This needs to be public or package private.
This needs to be package private.
This needs to be public or package protected.
suggestion getView().setupEmptyContainer();
Just a question.
Just a convention, but the indentation is off.
Should this be records.size()?
should this be records.size()?
Should this be <LINK_0>
Instead of returning a new server aggregator, what do you think about adding a method to PDataType and return the appropriate PDataType?
Instead of returning a new server aggregator, what do you think about adding a method to PDataType and getMaxLength?
Instead of returning a new server aggregator, what do you think about adding a method to PDataType and return the appropriate PDataType.
The implementation of equals(Object) below can be simplified to return true.
The implementation of equals(Object) below can be broken. For example, it is a remote duplicate.
The implementation of equals(Object) below can be broken. For example, it can be null (when we request a a2 object).
This should simply invoke the synchronized block.
This should simply invoke the new method.
This should simply invoke the method.
you need to keep the logging message as warn()
you need to have the URLClassLoader constructor call return a new  URLClassLoader one
you need to toLowerCase()
Please add a check that value is valid only if it is not null.
Please add a check that value is not null.
Please add a message from the Validation interface.
we need to log here. Please call getReactorClient()
we need to log here. Please call this from the finally block.
we need to log here. Please call getReactorClient() instead
What's the purpose of this change?
Can we add a afterPropertiesSet() here?
Can we add a afterPropertiesSet()?
You can use CacheEntry::new
You can use CacheEntry::new.
This cache is not needed.
This can be simplified as follows if (filteredOptions.isEmpty()) { return true; } return filteredOptions.size() > 0
This can be simplified as java if (filteredOptions.isEmpty()) { return true; } return filteredOptions.size() > 0
This can be static
Should this be synchronized?
Should this be private?
Should this not be synchronized?
nit: can we use new TreeSet<>(new DateTime())?
nit: can we use new TreeSet(Comparator.comparing(new DateTime())?
nit: can we use new DateTime() for these values?
Did you call isEmpty() instead of checking 'isClosed'?
Did you call isEmpty() instead of checking 'isClosed'?
Did you call 'closeSocketAsync' twice?
Missing null check
Unnecessary cast
Missing null checks
Add a new method with different params so it will be more clear what the parameter is
should this be private?
should this be public?
Is this really necessary?
Better to use this.
Shouldn't this be 50ms?
Should this be super.dispose() to avoid possible ConcurrentModificationExceptions.
If we add super.dispose() here, this will be called by the super.dispose().
If we add super.dispose() to this, it could be a good test.
Only throw an exception, since the schema can't be null.
Only throw an exception, since the database can't be loaded.
Only throw an exception, since the database can't be closed.
Let's use AssertJ here.
Let's use AssertJ
Please use AssertJ
This is not the place for this test, it passes if the file is not found.
This is not the place for this test, it passes if the.gff file is empty
This is not the proper name.
please remove the method modifier
move it to execute method
please remove the method modifier.
can you please remove it and call it VmDeviceType.VNC
can you please rename result to vmDeviceType so it's clearer
can you please remove it and call super to setReturnValue
Use Objects.hash()
objects.hash()
objects.hash
Why are we adding this null check?
Why are we adding optional here?
Why are we adding this additional parameter?
Is this intentional to test this?
Is this correct?
Is this intentional to verify that no objects exist in the right order?
curly braces
curly braces.
curly braces { and }
We have a synchronization here on all threads.
we have a race condition here and should use the iterator and remove methods to make it thread safe
we have a race condition here and in the other methods that check for the close and return true - should use the shutdownNow instead
I think this call might need to be in the super at the end.
Should we log this at the tear down first?
Should we log this at the end of the visit method?
The above line should be where you're re-using the same variable.
The above line should be where the clearOdkDirOnScopedStorage() was removed.
The above line should not be required.
parallelStream()?
parallelStream() is unnecessary here, both peek and peek are async.
parallelStream() is unnecessary.
Is this the same as CCAnalyticsEvent.IN_APP_UPDATE_EVENT?
Is this the same as CCAnalyticsEvent.IN_APP_UPDATE_EVENT? I don't think we should have a method for this.
Would you mind adding a bit of parens to improve readability?
Collections.unmodifiableSet(new HashSet<>(plugins))
Collections.unmodifiableSet(new HashSet<>()
Collections.unmodifiableSet()
nit: This is not needed.
nit: add braces here and on the next line.
nit: add braces around isView() and its not needed
Is this method needed?
Is this method used?
Is this method used anywhere?
suggestion return requestThrottler.getInflight();
suggestion return requestThrottler == null? 0 : requestThrottler.getInflight();
suggestion public int requestThrottleInflight() {
Why did you catch any RuntimeException based class here?
Why did you catch any RuntimeException based class?
Why did you catch all these exceptions?
Is there a reason why you are doing the alias as a constant?
Is there a reason why you are doing this and adding it to the store?
Is there a reason why you are doing this and adding it to the handle to the EntityType?
These line is proof you don't need QuotaConsumptionParametersWrapper
These line is proof you don't have QuotaConsumptionParametersWrapper
These line is proof you don't want QuotaConsumptionParametersWrapper
it's not public, so remove it.
it's not public, please remove.
it's not public, so remove it
Should we name this in MaxwellUtils instead?
Should we name these in MaxwellUtils?
Should we name this thread instead?
why not just skip the SEAT feature?
why not just skip the SEAT
why not use the SEAT mechanism?
should we use pushInlineDeployments here?
Could we use pushInlineDeployments here?
- should we use pushInlineDeployments here?
We should also call super.cleanup() to cleanup even if we don't need to do it.
We should also call super.cleanup() to cleanup the _agsPub and then call super.cleanup() to cleanup the data.
We should also call super.cleanup() to cleanup the _agsPub.
I'm not sure about the naming. "a13c3c2d3c354040b8e4" to ArcGISScene.
I'm not sure about the naming. "a13c3c2d3c354040b8e4" to ArcGISScene?
I'm not sure about the naming. "a13c3c2d3c354040b8e4" to ArcGISScene
Any reason to not return null? It is semantically better to return some string than to have it as a FeedId.
Any reason to not return null? It is semantically better to return some string than to have it in the FeedId.
Any reason to not return null? It is semantically better than returning null.
Use this instead:plotted over range...
Use StringUtils.isBlank rather than string concatenation
Use StringUtils.isBlank
return Objects.hash(id, id);
use Objects.hash() instead of "+"
use Objects.hash() instead of "+"?
parentheses please :D
parentheses?
parentheses
Let's extract a constant for the timeout value.
Let's extract a constant for the timeout value?
please add a message saying what failed to fail
Maybe make this throw IllegalArgumentException?
Maybe make it a long ((long)0)?
Maybe make it a long ((long) 0)?
use try-with-resources.
I think this decode method also should throw IOException, e.g., IOException.
use try-with-resources to close the stream, which also closes the stream
Do you still need to skillLevel here?
Do you still get the skillLevel here?
Do you still need to skillLevel += player?
Maybe check if batch update exception has nested SQLNonTransientException?
I am thinking if we can move BatchUpdateException to caller method and use separate metrics for all possible cases.
I am thinking if we can move BatchUpdateException to caller method and use separate metrics for all possible cases that can handle batch update exception.
what about combine the if statements into one?
what about combine the if statements?
<LINK_0>
Why do you use BigInteger and not int?
Why do you use BigInteger.valueOf() here?
Why do you use BigInteger and not BigInteger?
I'm not sure whether it would be a good idea to throw an exception here. If you decide the strategy to decide whether the parameter is being set to false, then you could even set it to true.
I'm not sure whether it would be a good idea to throw an exception here. If someone reviews this PR, it might be nice to make the change.
I'm not sure whether it would be a good idea to throw an exception here. If you decide the strategy to decide whether the parameter is being set to false, then you could set it to true again.
The if condition is not needed because we have the same check in line 66.
URIish should be used in this method.
The if condition is not needed because we only have a single line in the constructor.
timeoutMsg -> timeoutMsg
timeoutMsg -> timeoutMsg?
timeoutMsg == null?
Same as above: I don't think it's necessary to build a url.
Same as above: I don't think it's necessary to build a url for this method.
Same as above: I don't think it's necessary to build a url when the user doesn't have it.
Are you sure that this method is required?
Is it required to check for null value here?
Are you sure that this method is used?
adding a default value to the region?
adding a default value to the region
spaces!
s/verify
s/verify/validate/
s/verify/handle
Why does this need to be added now-why is it in the cache? Was JENKINS-20398 somehow related?
Why does this need to be added now-why is it in this PR? Was JENKINS-20398 somehow related?
Why does this need to be added now-why is it in this PR? :P
I think it would be easier to read if we use the stream here.
Please use Option.apply instead of to have the possibility of nulls.
Please use Option.apply instead of Non-null.
style nit: missing braces
style nit: missing curly brackets
style nit: missing curly braces
How about LOG.warn("Retry #" + numFailures, " milliseconds.");
How about: LOG.warn("Retry #" + numFailures, " milliseconds.");
How about: LOG.warn("Retry #" + numFailures, " milliseconds.");?
If m_segmentHeaderBuf!= null then m_segmentHeaderBuf.discard() will also reset the m_segmentHeaderBuf to null. I suggest to make sure that m_segmentHeaderBuf and m_segmentHeaderBuf are not null.
If m_segmentHeaderBuf!= null then m_segmentHeaderBuf.discard() will throw an NPE.
If m_segmentHeaderBuf is null then m_segmentHeaderBuf.discard() will throw an NPE. I suggest to use Tracker.validate() here as well.
We could use a constructor with a set of false parameters. That way it is easier to change the default constructor.
This constructor could be deprecated and removed.
This constructor could use the new constructor.
Do we want to keep this method public?
Do we want to make sure that this is not thread safe?
Do we want to make sure that this method is called only once?
you should check featureSupported.isVmLeasesSupported instead
you should check feature support support without bump compatibility version.
you should check featureSupported.isVmLeasesSupported instead.
I think we should change the message to "must be specified."
As above, we should be consistent with the signature of the builder.
As above, we should be consistent with the signature of this method.
Please change to externalSearch =
Please change to externalSearch = to externalSearch.getInstance();
Please change to externalSearch.newAuthentication()
redundant else
unnecessary else: }
redundant else.
How about logging a message if we log the validation fails?
How about throw InternalException here?
How about logging a message from the exception?
This should also check the activeTextEditor here.
This should only be checking the editor is enabled if it is not null.
This should only be checked in the editor when the editor is opened.
Kind of weird to have the same condition multiple times.
Kind of confusing to have the same condition multiple times.
Kind of confusing to have the same condition multiple times. Also, would it make sense to raise issue on the first operand?
This looks like a synchronized block. If the lambda above throws an exception, while it's shutdown, the callable can be changed to while (isCancelled) {... }
This looks like a synchronized block.
This looks like a nit but this method can be private
isSupported() is deprecated, is this intended?
static is worth renaming.
isSupported() is deprecated, is it necessary?
Please consider adding an overridden version of CuratedContentPageObject for this.
The DateTime.now() is the same as this one.
DateTime.now()
IMHO, this should be a precondition.
IMHO, these methods should rather throw a RuntimeException, so the user can get a reasonable error message in the IOException. That should catch and handle both exceptions.
IMHO, these methods should rather throw a RuntimeException, so the user can get a reasonable error message in the IOException. That should catch and log the exception as a cause.
Wow, that's a lot of code. I guess it's better to do Integer.parseInt(maxSimulQueryParam, int totalTasks) at the top of the method.
Wow, that's a lot of code. I guess it's better to do Integer.parseInt(maxSimulQueryParam, int totalTasks) return totalTasks;
Wow, that's a lot of code. I guess it's better to do Integer.parseInt(maxSimulQueryParam, int totalTasks) here, just return totalTasks;
This class should be private, no?
This class should be private to avoid API break.
This class should be private to avoid API leak.
I ask myself if we're familiar with this. I think this is the place to flag the spliterator in a single place, so we need to map it to the Iterator's spliterator. I ask myself if you'd like to use that because in a single-thread spliterator. I will ask jshell: java jshell> Optional.of(1).stream().spliterator().characteristicOf(exceptions) 3 ==>../../a%20dev)
I ask myself if we're familiar with this. I think this is the place to flag the spliterator in a single place, so we need to map it to the Iterator's spliterator. I ask myself if you think it will be clearer. But wait... Java 9 added Optional.filter(Iterators.filter(i -> SecurityUtils.isNull(i)). I will ask myself if you're familiar with that.
I ask myself if we're familiar with this. I think this is the place to flag the spliterator in a single place, so we need to map it to the Iterator's spliterator. I ask myself if you think it will be clearer. But wait...
I'd suggest inverting the order of the conditions to make it more clear: return getGlusterVolume().getVolumeType().isReplicatedType() && getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount();
I'd suggest inverting the order of the conditions to make it more clear.
I'd suggest inverting the order of the conditions to make it more readable.
why do you need @SuppressWarnings("unchecked")?
why do you need @SuppressWarnings("unchecked") here?
why do you need @SuppressWarnings("unchecked")?
suggestion boolean isDeleted = dataStream.readByte() == 1? true : false;
Better to use ternary operator: dataStream.readByte() == 1? true : false
Better to use ternary operator.
I think you can wrap this test with a try-with-resources statement
I think you can ignore this exception. It should be test as well.
I think you can ignore this exception.
There's no need to have protected here.
Can we make this method private?
Maybe we could have this method private?
This test is wrong, it should be verifying the reason it failed.
This test is wrong, it should be verifying that the reason the ping failed.
This test is wrong, it should be verifying the reason the exception is thrown for us.
This could be simplified to if (object!= null && object!= null) {
This could be simplified to if (object!= null && object!= null)
This could be simplified to if (object!= null) {
remove this
remove this, or alternative?
Remove this
Should be a check for it.
Should be OK in this case, don't construct a ipDataChecker for a problem.
Should be OK in this case, don't construct a ipDataChecker for a problemInfo
Why did you not use a loop here to check for null length?
Why did you not use a loop here to check for null length? The loop body seems to be more efficient than the do-while loop.
Why did you not use a loop here to check for null length? The loop body seems to be more efficient than the check for null length.
why not use this.name directly?
why not use this.name?
why not use this?
this is not an error, it should be logged
this is a breaking change - please remove
if (tokenBucket == null) { return false; }
should be public IDebugCommandRequest
here we can return static 'protected'
should be public
Please add curly braces for this if statement.
Please add curly braces for the if statement.
Please add curly braces
Possible to log only one debug line here?
Possible to use parameterized logging instead of string concatenation.
Possible to log only one debug statement here?
blank line
**Failed** for indexRedirectsToOverview.
**Failed**
I don't think this is needed
I don't think this is needed as this is only called by UI thread.
I don't think this is needed as this is only called once per project.
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output,plainOldUserSchemaResource, PlainOldUser.class); avroItemWriter.open(new ExecutionContext()); avroItemWriter.close(); avroItemWriter.write(this.plainOldUsers());
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output,plainOldUserSchemaResource, PlainOldUser.class); avroItemWriter.open(new ExecutionContext()); avroItemWriter.write(this.plainOldUsers());
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output,plainOldUserSchemaResource, PlainOldUser.class); avroItemWriter.open(new ExecutionContext());
Why is that at the top of the method?
Why is that 1 here?
Why is that at least a type cast?
.orElseThrow(() -> new IllegalArgumentException("The password is null");
Couldn't this be private?
.orElseThrow(() -> new IllegalArgumentException("The password is null"))
*[x] This is not supposed to be anywhere in the project. It should be declared as private.
*[x] return "null" instead of "null". *[x] return null;]
*[x] return "null" instead of "null". *[x] return null; It also should be written as a constant.
:bug: this is a bad test.
if (OS.getCurrent() == OS.WINDOWS)
step >
If this is a string it can be null rather than an empty string?
If this is a string it can be null rather than an invalid string.
If this is a string it can be null rather than an empty string.
You can have you also call getActivityManager.getApiKeyActivity(startDate, end, new Date(end));
You can have you also call getActivityManager.getApiKeyActivity(startDate, end, new Date(end)); in the last two lines.
You can have you also call getActivityManager.getApiKeyActivity(startDate, start, end);
Does this method need to be public?
Does this method need to be registered for the non-default columns?
Does this method need to be registered for the non-labels?
Could be an ImmutableList.of()
Could return dir.listFiles(null)
Could return an empty list instead of null.
If you are going to use this to be injected, please consider creating a separate constructor.
If you are going to use this to be injected, please consider making the constructor private and have a static factory method.
If you are going to use this to be injected, please consider making the constructor private and have a static method.
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, so no action needed.. just for you to know
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, but no action needed.. just for you to know
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our API, so no action needed.. just for you to know
Adding this to a field is good manner.
Adding this to a field is bad manner.
Adding this to a field is good manner
Instead of using an enum here, you can use Collections.emptyMap()
Instead of empty map, queryStateMap should be set to null and avoid empty map.
Instead of 3 lines above, queryStateMap should be declared as private.
Please check if it is a Class instance variable.
Please check if type is not null, not instanceof.
Please check if it is a Class instance of Class.
rather than introducing a method, i.e.: private void testAndNameEquals(final ReadableBranch branch, final ReadableBranch branch) {... }
rather than introducing a method, i.e. List<ArtifactReadable> artifacts = builder.getResults(); assertEquals("Folder", artifacts.getExactlyOne().getName());
[minor] Space after "Folder"
@jglick In this case, it is better to use assertThat( parser.parseToHtml("[abc|Title\\]</p>", Pattern.MULTILINE()) may be better
@jglick In this case, it is better to use assertThat( parser.parseToHtml("[abc|Title\\]</p>", Pattern.MULTILINE())
@jglick In this case, use expectedException with description instead of String.format("HTML:", html);
Are we sure WFieldIndicatorWebElement is always a valid attribute from the outside? It might be safer to do a check on the class attribute and return it here.
Are we sure WFieldIndicatorWebElement is always a valid attribute from the outside? It might be safer to limit the usage of the class hierarchy.
Are we sure WFieldIndicatorWebElement is always a valid attribute from the outside? It might be safer to do a check on the class attribute and return it in a void method.
OperandTypes.SAME_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a field. It'ssss an enum.
OperandTypes.SAME_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a field. It'ssss an enum.
OperandTypes.SAME_VARIADIC indicates a parameter list with lowercase i.e. the OperandTypes.PER_VARIADIC indicates a parameter list with lowercase i.e. the same as the other tests.
It's better to use == for comparison.
It's better to use == here.
Compare directly
I don't think this does what you want. return cache.get(url.toString(), () -> resourceRetriever.retrieveResource(url));
I don't think this is right. If the user has access to the resourceRetriever, then one would have to account for it. What do you think?
I don't think this is right. If the user has access to the resourceRetriever, then one would have to account for it.
Why do we need this?
Why do we need to use the hash codes directly?
Why do we need to use the version of hash?
This will throw an exception if the path is not set.
This will throw an exception if the path is not in the map.
This will throw an exception if the path is not set to file system path
This function is only used in this class, I don't think we need to do this.
This is throwing a non-checked locking exception. I don't know if this is what we want
This is throwing a non-checked locking exception. I don't know if this is a good idea.
This prevents the register class from being called multiple times. I'd prefer to introduce a new registerClass() method to the ObjCObject that returns a Class<? extends ObjCObject> instead of the concrete class.
This prevents the registerClass() method from being called more than once. I prefer the registerClass() method to be renamed to this class.
This should be registerClass()
Maybe we should include a helpful error message here, including the bad version information
Maybe we should include the bad version info in the log.
Maybe we should include a helpful error message here, including the bad version information.
Note that the strange usage of reflection is to use the class loader of the class, which is not the class loader.
Note that the strange usage of reflection is to use the class loader of the class, which is not the default impl.
Note that you are missing a backwards compatibility check here.
Why do we need to call initAndFinishButton() if it's not already called first?
Why do we need to call initAndFinishButton() if it's not already called?
Why do we need to call initAndFinishButton() if it's not already called already?
Can you make the first part of the if statement? What is the point of having the _customInteractorListener exposed on the first line?
Can you make the first part of the if statement? What is the point of having the _customInteractorListener.createInteractor(actionName) in public methods? Or are you doing it multiple times?
Can you make the first part of the if statement? What is the point of having the _customInteractorListener.createInteractor(actionName) in public methods? Or did you change it to private?
these are public and not public in the interface.
these are public and not public?
these are public and not public.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(int, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate the type conversion.
Please add a space after (
Please remove empty line.
Please remove empty line
LOG.error("Failed to get note {} of note {}", revId, noteId, subject);
LOG.error("Failed to get note {} of note {}", revId, noteId, e);
LOG.error("Failed to get note {}", revId, noteId, subject);
It's pointless to use _any_ method in here (and in few other places), since it's a expression that is unused, and it's not a big deal.
It's pointless to use _any_ method in here (and in few other places).
It's pointless to use _any_ method in here (and in few other places), since it's a just one line.
Why is this "protected" method and only "protected" is totally necessary to have it here. The only difference is that I would remove the "protected" annotation, and it should be moved into the "protected" method
Why is this "protected" method and only "protected" is totally necessary to have it here. The only difference is that I would remove the "protected" annotation, and it should be moved into the "protected" method.
Why is this "protected" method and only "protected" is totally necessary to have it here. The only difference is that I would remove the "protected" annotation, and it should be moved into the first place.
It might be more readable to invert this condition, e.g. if (isWindows) { if (isWindows) { return true; } if (isWindows) { return false; }...
It might be more readable to invert this condition, e.g. if (isWindows) { if (isWindows) { return true; } }
It might be more readable to invert this condition: if (isWindows) { if (isWindows) { return true; }...
Use NewOperatorEntity.class
Use { }
Use assertTrue
Does this need to be public?
getKeyPrefixesForContainer(containerId)
Does this really need to be public?
nit: I think it would be nice to have a default constructor for this. ValueValue and someBoolean can default to false.
nit: I think it would be nice to have a default constructor for this. ValueValue and someBoolean can default to false. wdyt?
nit: I'd prefer using WrappedBigDecimal.fromDouble(someDouble) for this.
You could do a contains here like you do with the ACCEPTED_ENTRY_FACTORY_PIDS.contains(entry.getFactoryPid()) check.
You could do a contains here like you do with the ACCEPTED_ENTRY_FACTORY_PIDS.contains(entry.getFactoryPid()) check since it's repeated a lot.
You could do a contains here like above.
it would be better to use lambda parameter
it would be better to use lambda parameter instead of stream
it would be better to use lambda parameter for the lambda
can you please explain the reason of this exception?
can you please explain the reason of this change?
can you please explain the reason for this exception?
I think we could avoid isEqualTo(500); as the test is testing the same thing.
:+1: (minor) We could use isEqualTo() for numbers here.
I think we could avoid isEqualTo(500); as the code below doesn't define the value.
Add a space after the if.
Add a space after this line.
Add a space after the if?
nit: omit this.modifiers?
nit: This is unnecessarily complex. It looks like there are two different variables.
nit: This is unnecessarily complex. It looks like there are two "magic" below.
I suggest to use CompletableFuture.runAsync(super.run, executorService) to ensure the thread is interrupted
I suggest to use CompletableFuture.runAsync(super.run, executorService) (the CompletableFuture) to ensure the thread is interrupted
I suggest to use CompletableFuture.runAsync(super.run, executorService) (the CompletableFuture) to ensure the executorService is always completed.
PS. For what its worth, we should be using: java final Builder builder = DetectorOptions.newBuilder().with(new Builder(options)).with(help).xml();
PS. For what its worth, the plugin.xml is going to be progress barable.
PS. For what its worth, we should be using: java final Builder builder = DetectorOptions.newBuilder();
I would move this into the executor, we can get rid of the shutdown method.
I would move this into the executor, then we can shut down the executor after the start of the worker.
I would move this into the executor, then we can shut down the executor after the start of the new leadership.
This method is only called from within the loop, so no need to check if it is being replaced.
This method is very complicated. How about making it more descriptive and call it hasPendingMigrationsWork?
This method is very complicated. How about making it more descriptive and specific?
As far as I can tell, maybe it would be clearer to skip the loop if the jobBeingChecked.getCategories() contains category.
As far as I can tell, maybe it would be clearer to skip the loop if the jobBeingChecked.getCategories().contains(category) check.
As far as I can tell, maybe it would be clearer to skip the loop if the jobBeingChecked.getCategories().contains(category) statement.
Just td/td.conf should be better.
Just td/td.conf is better.
Possible Exception?
You can also use.collect(Collectors.toList())
You can also use.collect(Collectors.toList()) here.
You can also use.collect(Collectors.joining(","));
Can you make this a static constant and give it a name?
Can you make this a constant and give it a name?
Can we make this a static constant and have it calculated by the class?
I don't think we should log at trace level
I don't think we need this log. Should be at debug level
I don't think we should log at trace level and not at debug.
SA == SERVICE_ACCOUNT? avoid abbreviations
SA == SERVICE_ACCOUNT
Call this assertThrows?
I'd expect this to be the one you wanted by.contains.
I'd be more comfortable with this. :+1:
I'd expect this to be the one you wanted to check. :+1:
Is this right? When would this happen?
Is dismiss() necessary here?
Is dismiss() necessary here? Thanks
nit: I think we don't need to include the content. Warning: this can't be undone, since Users can know about it.
nit: I think we don't need to include the content. Warning: this can't be undone, since Users can inherit from Users.
nit: I think we don't need to include the content. Warning: this can't be undone, since Users can inherit from ;-)
Do we have a very descriptive name for this? Any reason not to make it true?
Do we have a very descriptive name for this? Any places where we can't have a very descriptive name?
Do we have a very descriptive name for this function? How about make it appear like we're losing the context of the app and we can reuse?
Minor: you can use diamond operator on the right hand side
Minor: you can use diamond operator here.
Minor: you can use diamond operator on the right hand side.
Can we make this private?
There should be a null check on the builder.
Can we make the constructors private?
If you do this in the constructor, this should be reverted.
If we do this in the initCommonImages() method, this should be in the enum.
If we do this in the initCommonImages() method, this should be in the ctor.
Style-nit: Please move the "throws" inside the method body
Style-nit: Unnecessary final modifier.
Style-nit: Add space after "!".
Should the check if the client is null to avoid a NPE?
Should we warn the server to crash here?
Should we warn the server to crash if the given server is null?
return isInit && initException!= null
return isInit && initException!= null;
return isInit && initException!= null;?
Need to implement this in a test.
Need to remove these 3 lines. bb.writeLong(lid)
Need to remove these 3 lines.
use simple Reply.with(Json.class)
use simple Reply.Builder
use short message
Can we fix the throws Exception in this method signature as well?
Can we delete this method, as it doesn't return an object?
Can you make this public?
Was it worth checking that this isn't really true in the test?
Was it worth checking that this isn't really true?
Was it intentional to remove this change?
Could combine the two calls to setXXX: params.setUseCipherSuitesOrder(useCipherSuitesOrder);
Could combine the two calls to setXXX: params.setUseCipherSuitesOrder(useCipherSuitesOrder).
Could combine the two calls to.setNeedClientAuth(true);.
This should probably be public.
This should probably be public since the "private" method is only used in tests.
This should probably be private.
static?
Can we make this a static method?
public static?
"Pool is busy (no available connection and the queue has reached its max size %d"
"Pool is reached its max size %d"
"Pool is reached its max size %d"?
You should use the class loader of the first parameterResolver instead of the direct class loader.
You should use the class loader of the first parameterResolver instead of using the class loader.
You should use the class loader of the executor service.
nit: you can also put TestConfigurationFactory.TEST_CONFIGURATION_URI_KEY on LOCAL.TEST_CONFIGURATION_URI_KEY
nit: you can also put TestConfigurationFactory.TEST_CONFIGURATION_URI_KEY on the previous line.
nit: you can also put TestConfigurationFactory.TEST_CONFIGURATION_URI_KEY on LOCAL.TEST_CONFIGURATION_URI_KEY to a suffix variable.
this should be static
this line should be removed
this line should be deleted
It may be better to use java.util.HashMap instead of the concrete class.
There is no need to have the return value of this method
It may be better to use java.util.HashMap instead of using a concurrent map
Duplicated code
Duplicated code.
Duplicated logic
You may also want to shutdown the executor, which you can use for the flush method
You may also want to shutdown the executor, which you can use for the flush executor
You may want to shutdown the executor, which you can use for the flush method
@nielsbasjes I think you need to try-catch here to improve readability.
@njhill after some more digging this actually depends on the exception handling to the test. I think you need synchronized or some other catch blocks.
Why synchronized?
suggestion public HdfsSinkConfig() {
suggestion public Permission initialize() {
suggestion public Up to you - this class is package private
Is this really needed? It's only used in the first place.
Is this really needed? It's only used in one place.
Is this really needed? It's only used in the JMX module.
HTTP_HEADER_CSP
HTTP_HEADER_CEARER
HTTP_HEADER_CLOA
This query (and the above query) should be named ship_timestamps, not TIMESTAMP.
This query (and the above query) should be named ship_timestamps.
You could ensure that stop at zero here.
ins't KEY2STRING_MAPPER missing?
isn't it missing KEY2STRING_MAPPER attribute?
isn't it missing KEY2STRING_MAPPER interface?
maybe Gonamed.class.getName() should be 'null'
maybe Gonamed.class.isAssignableFrom(key)
maybe GoEsiTreeUtil.findAllLiteral()
If you're not using @VisibleForTesting, wouldn't it be better to call context.backoffMs(backOffMs) directly?
If you're not using @VisibleForTesting, wouldn't it be better to call context.backoffMs(backOffMs) just once?
If we're not already calling context.backoffMs(), then we can drop the method which is the backoff only.
There is no authorizationRequest anymore. I'd remove this
There is no authorizationRequest anymore. I'd remove this.
There is no authorizationRequest anywhere in the request. Should be sufficient to use these.
I'm not sure if we want to use this feature: "beta".equalsIgnoreCase(newVersion).startsWith("beta");
I'm not sure if we want to use this feature: "beta".equals(newVersion).startsWith("beta");
I don't think we want to use this method to check if the newVersion is an empty String or not.
Seems like you don't need to get a list to find an ACL.
Seems like this should be final.
Seems like you don't need to get a list to find it, and return it.
Instead of adding the same string as a global variable, the String is only used here.
Instead of adding the same string as a global variable, the Strings might be better.
Instead of adding the same string as a global variable, the Strings might be more appropriate.
Why so complicated? Why not add a citation that doesn't process citation?
Why so complicated? Why not just let the exception propagate and let it throw?
Why so complicated? Why not just let the exception bubble up and let the stack trace get logged?
There is some object that won't overwrite things. Unless you change the object to this.
Think this should be a deferent method.
Think this should be registered in the setter.
@Rikkola is this change required?
can you add @Override annotation here?
@Rikkola is this change necessary?
the size of the resultset is no longer used. Not sure if it's worth it.
the size of the resultset is no longer used? Not sure if it's worth it.
the size is missing. Remove it.
There is a Composite needed here. The "protected" modifier could be removed.
There is a Composite.class.
There is a Composite needed here to avoid the unnecessary allocation.
It'd be a bit clearer to declare each switch in a single place.
It'd be good to move the registerReceiver() call out of the switch and just use a reference.
It'd be a bit clearer to declare each switch in a single line
maybe while you're at it, please put it in a variable
maybe while you're at it, can we remove this statement
maybe iterate with values()
Only catch IOException, is it really necessary?
Only catch IOException, is it really correct?
Only "throws IOException" is redundant.
Probably it makes sense to return workerEvalParams if workerEvalParams is null.
Probably it makes sense to return workerEvalParams if workerEvalParams is empty.
Probably it'd be better to return an unmodifiable Map here?
if (project instanceof IResourceConstant) {
if (project instanceof IProject) {
what if project is null?
make nonCountableQutoaVmStatusesMap a Map?
make nonCountableQutoaVmStatusesMap a synchronized Map
let's change this to.forEach
Same here, no need for the throws clause
Same here, no need for the throws
Same here, no need for the throws clause.
Add a new method to VmValidator that will be used here and in the second patch set.
Add a new method to VmValidator that will be used here and in extractVmValidator from VmValidator
Please make the method private.
Maybe we can download the image directly here
Maybe we can download our image here
Maybe we can abstract this test to the base class?
Why use isEmpty()?
Why use isEmpty() here instead of isEmpty()?
Why use isEmpty() here instead of isEmpty()?
shouldn't this be Optional.ofNullable()?
shouldn't we use Optional.ofNullable() instead?
How about using STATE.map(TraceState::of) instead?
No formatting change?
No formatting check required
No formatting change
I think this should be warn
I think this should be Stray.
nit: Just wanted to point out that both are different.
I think we should say "not able to recover" the user, like we do but at the end of AbstractApplicationObject. But as the underlying implementation we want the user to go go, we should go back to AbstractApplicationObject.
I think we should say "not able to recover" the user, like we do but at the end of AbstractObject. But as the underlying implementation we want the user to go go, we should go back to AbstractObject.
I think we should say "not able to recover" the user, like we do but at the end of AbstractObject. But as the underlying implementation we want the user to go go, we should go back to its own implementation.
This is unnecessary change.
traids can be null here
traids can be omitted
We could add a message in the assertNotBuilt() method like: java @Override public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { // this.principalDecoder = principalDecoder; return this; }
We could add a message in the assertNotBuilt() method like this: java @Override public Builder setPrincipalDecoder(PrincipalDecoder principalDecoder) { // the assertNotBuilt(); return principalDecoder; }
We could add a message in the assertNotBuilt() method like we do for other set* functions.
What is the purpose of this change? We need to be able to call getCachedBytes only once.
should be public instead of protected.
What is the purpose of this change?
nit: This is weird to have a single constructor, but it's not public.
nit: This is weird to have a single constructor.
Seems like this is weird.
Please use Map.Entry method.
Please use Java 8 streams here.
Please use Map.Entry function.
I think we might need to check that the fields are not null before the purgeOrderType
I think we might need to check that the fields were not null before the purgeOrderType
I think this is not needed
Is this change intentional?
Is this case possible?
Is this change related to PR?
This should not be sanitized because HTML is not properlysanitized. You should use sanitizeForHtml() instead.
This should not be sanitized because HTML is not valid HTML. The unsanitized name only present in the HTML attribute.
This should not be sanitized because HTML is not properlysanitized. You should use sanitizeForHtml() instead and have the caller only do this.
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
what's the point? The method is always true for DefaultDebugExecutor.EXECUTOR_ID without your changes.
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes
LOG.error("Failed to open {}, e)
LOG.error?
log it
I think the message should be "Cannot add a entity to a passable entity"
I think the message should be "Cannot add null entity on a impassable entity"
I think the message should be "Cannot add a entity to a passable entity".
Another reason to deal with Iterables.getFirst is that you're using an instanceOf and not a Iterables. That's why I'd prefer having one (as you do in my mind).
Another reason to deal with Iterables.getFirst is that you're using an instanceOf and not just the first element.
Another reason to deal with Iterables.getFirst is that you're using an instanceOf and not the first element.
why public? Are you using other methods in the class?
why public? Are you using other places in this class?
why public?
return this.count < values.count();
return this.count <= values.count();
return this.count < values.count();?
You don't need to do this.
This variable is unnecessary.
You don't need to do this. write(buffer);
Could we still use the getBinding() method here?
Could we get an exception if fBinding is null?
Could we still use the getBinding() method from previous PR?
Why do we need this?
Why do we need this toString implementation?
Please keep using toString() and format the string
Can you move the "_isCurrentUser" string to a constant? Ditto for "_isCurrentUser".
Can you move the "_isCurrentUser" string to a constant somewhere? eg. private static final String VERSION_ENTITY_USER = "You must have been syncronized"
Can you move the "_isCurrentUser" string to a constant? Ditto for "_isCurrentUser"
.join() is missing
Too many unnecessary blank spaces in this file.
stringify is an implementation of this. Please rename to name.
What about java updateProjecterStateVariable(newState);
What about boolean age = age >= projectorStateUpdateInterval; if ( age < age) {... } else {... }
What about boolean age = age >= projectorStateUpdateInterval; if ( age >= age) {... } else {... }
Add spaces around =
need to be protected
need to be package protected
This should be renamed to FL_STORAGE_APPLICATION_ID.
This should be renamed to FL_LEVEL_UNAVAILABLE.
This should be renamed to throw.
we can merge these 2 conditions since the operation is the same in both cases ( result is the same)
we can merge these 2 lines since the operation is the same in both cases ( result is the same)
we can merge these 2 conditions since the operation is the same in both cases ( result is the same).
We should check if the input is an LiteralPathElement to avoid creating the cast.
We should check if the input is an LiteralPathElement to avoid the cast.
We should check if the input is an LiteralPathElement, not just the selection.
Thoughts on changing this from using withContext and a String constant instead of a String?
Thoughts on changing this from using withContext and a String constant over a map?
Thoughts on changing this from using withContext and a String constant in Storage Common to making things a little cleaner.
suggestion throw Graph.Exceptions.edgeWithIdAlreadyExists(edge.id());
Suggestion: if you want to add an empty set of validations, you can keep them all together and call isEmpty() on the base class, and then you wouldn't need the 'if' here.
Suggestion: if you want to add an empty set of validations, you can keep them all together and call isEmpty() on the base class, as the impl does it by first step.
I think it's better to create a constant and refer to the parameter here
I think it's better to create a separate parameter and then call setString() here
I think it's better to create a separate parameter and then call setString() here.
Why do we need to explicitly assert that a format number is empty?
Why do we need to explicitly assert that a format number is 4? that is not enough, because the test can succeed
Why doaa is needed?
ofNullable?
Minor: could this be package private?
ofNullable should be enough
The null check will throw a NPE if certificate is null.
The null check can be dropped.
The null check can be removed.
Looks like this constructor can be private.
Looks like this constructor can be protected and/or protected.
Looks like this constructor can be protected and call via super.
This throw new IllegalArgumentException("No enum found for string: " + target, target));
This throw new IllegalArgumentException("No enum found for string: " + target, target);
This throw new IllegalArgumentException("No enum found for string: " + target);
I would log a more useful error message here.
I know this is just a test, but it needs to be more correct to throw an IllegalArgumentException instead of using a less informative message.
I know this is just a test, but it needs to be more correct to throw an IllegalArgumentException in order to have the developer aware/log supported exceptions.
Can we break the line up into the following? java public static long getValue(String name) { return getRegistry().get(name); }
Can we break the line up into the following? java public static long toString(String name) { return getRegistry().get(name); }
Can we break the line up into the following? java public static long lookupMetric(String name) { return getRegistry().get(name); }
I don't think we should always return [] to avoid NPE.
Needs a check for buffer.length
Missing {}
super() is unnecessary
DRSyncJob should remove this line.
super is unnecessary
this seems wrong. now you keep track of the last one and not the first one.
this seems wrong. now you keep track of the first one and not the last one.
this seems wrong. now you keep track of the first one and not the first one.
I assume this is a change in the future, and we don't want to update the image even if it's not changed.
I assume this is a change in UI, and the logic isn't changed here.
Could this be changed to just Log.d?
You can use IOUtils.copy(inputStream, outputStream); instead of these two lines.
You can use IOUtils.copy(inputStream, outputStream); instead of this.
You can use IOUtils.copy(inputStream, outputStream) to ensure the file is closed.
Coud you rather use long instead of [Duration](<LINK_0>
Coud you rather use long?
Coud you rather use long instead of 'final'?
Since all the process methods have changedBits, perhaps it's better to have it in a single method?
Since all the process methods have changedBits, perhaps it's better to have the same logic in terms of maintainability?
Since all the process methods have changedBits, perhaps it's better to have it in a single method? Also, the first process method shouldn't have to be public, the second process method would need to be private.
Don't set statusCode in this class, just delegate to the appropriate constructor.
Don't set statusCode in this class, just delegate to the appropriate constructor?
Don't set statusCode in this class, just delegate to the appropriate constructors.
I'd say this is an Identity library and the contract we use for other classes.
I'm not sure about the purpose of this change. When the class is a S3 object, the hashcode will be a messed up.
I'm not sure about the purpose of this change. If we compare two objects we may be equal for the same id, it's a regression.
Let's add a failBecauseExceptionWasNotThrown(IllegalStateException.class)
Use expectNoQuery and get rid of try... catch...
Let's add a failBecauseExceptionWasNotThrown(IllegalStateException.class) call?
This should be a warn too.
This should be a warn (or warn) not a warning.
This should be a static annotation.
directly use assertThat(actual).satisfy(consumers))
directly use assertThat(actual).satisfy(consumers)) withMessage(message)
suggestion assertThatNullPointerException().isThrownBy(() -> assertThat(actual).satisfy(consumers))
Is this needed? Removing it should work as well
I don't think this is needed. Removing it should work as well
Is this needed? Removing it should work as well.
Why are you not using the random accessor?
Why not just use the random accessor instead of nextFloat?
Why are you not using the random, it's an implementation detail?
This should be followsTemplateSpec(ref, caseDbSpecTemplate, 0);
Is there a particular reason why this is called in the super class?
This should be followsTemplateSpec(ref, caseDbSpecTemplate, 1)
why not to go to the logo here?
why not to go to the line 86?
why not to go to a line -1?
is this really needed? Just return null or empty list?
is this really needed?
is this really needed? Just return null or empty list.
You could use the method getField(Class) here instead of just doing this: @Override public FactModelTree getSimpleClassFactModelTree(Class clazz) { String packageName =  fullName.substring(0, fullName.lastIndexOf(".")); return new FactModelTree(key, packageName, simpleProperties); }
You could use the method getField(Class) here instead of just doing this: @Override public FactModelTree getSimpleClassFactModelTree(Class clazz) { String className = clazz.getSimpleName(); String className = Utils.getSimpleClassFactModelTree(class, fullName); return FactModelTree(name, packageName); }
You could use the method getField(Class) here instead of just a public FactModelTree getSimpleClassFactModelTree.
@Rikkola why do you define a private method?
@Rikkola why do you define a private method? use java.util.List to make it more readable
@Rikkola why do you define a private method? use: (String s)?
Objects.requireNonNull(buf)
Objects.requireNonNull(buf)?
Objects.requireNonNull( buf)
TypeCategoryRole.class.isAssignableFrom(categoryName)
TypeCategoryRole.class.isAssignableFrom(categoryName) would be better
Import?
Missing @Override
Missing @Override annotation.
Missing @Test annotation.
no need for super
no need for call to super
no need for the super
suggestion bufferNotFullCondition.await();
suggestion if (bufferedResults.size() >= maxResultsBuffered) {
Have you considered using try/finally here?
use hamcrest matchers for this: assertThat(e.getMessage(), containsString("Connection"));
use hamcrest matchers for this: assertThat(e.getMessage(), containsString("ConnectionType"));
use hamcrest matchers
rename to fragment
rename to pack
rename toFragment
nit: if we verify that the list is equal to the current number, then we should verify that the value is the same.
nit: if we verify that the list is equal to the current number, then we should verify that the value is at least equal to the number of items, but then another results is just ignored.
nit: why use assertEquals and then a single call?
Let's keep the boilerplate as it is done in ClusteringServiceConfiguration and ServerSideConfiguration.
Let's keep the boilerplate as it is done in ClusteringServiceConfiguration and ServerSideConfiguration, and provide a constructor that does this.
Let's keep the boilerplate as it is done in ClusteringServiceConfiguration.
I like this pattern, but this seems a little verbose. Does it make sense to have a isAdded() method in Log interface?
I like this pattern, but this seems a little weird. Does it make sense to both of these swipe to onConnectionStateChanged?
Nice touch!
The null check is not necessary.
The null check is not necessary
The null check is not necessary. It is checked in Util.java
suggestion throw new NativeException("Failed to stop watch. Reason: " + result.getMessage(), e);
suggestion if (results == null) {
suggestion
I am asking myself why do you convert this to wizard? Wouldn't this wizard be able to work with MakeProjectConversions too?
I am asking myself why do you convert this to wizard? Wouldn't this wizard be able to work with MakeProjectConversion and wizard?
I am asking myself why do you convert this to wizard? Wouldn't this wizard be able to work with MakeProjectConversion.monitor to split split?
What if name is null?
What if name is empty?
What if name.length() - 1?
Perhaps this.cipherInformation = null; could be removed.
Perhaps this.cipherInformation = null; could be replaced with 'final'.
Consider other null checks.
Are all server-sides of the client not aware?
Are all server-sides of the client not set it?
Are all three fields null by default?
I'm in favor of just using the iterator and remove during the iteration..that's unneeded.
I'm in favor of just using vdssToMaintenance here..that's unneeded..
I'm in favor of just using vdssToMaintenance here.. It's unneeded.
We do not need to modify the list of methods, it is possible to change the signature of this method to not have any parameter and make it package private. Please make it package-private.
We do not need to modify the list of methods, it is possible to change the signature of this method to not have any parameter and make it package private. Please make it package-private instead.
We do not need to modify the list of methods, it is possible to change the signature of the method to not have any parameter and make it package private. Please make it package-private.
check for null for organization.getUuid()
this method should be private.
check for organization.getUuid()
Should make these values configurable?
Should we maybe make these values configurable?
Should make these a constant.
s/vds/host
please make this method private
s/vds/host/
I think the constant should be WORKFLOW
I think the constant should be stored as a constant somewhere.
I think the new name should be stored as a constant somewhere? or have an enum for the various caches?
I think it's unnecessary for this method to be final.
I think it's unnecessary.
I think it's unnecessary for this method to be declared final.
The if is not needed, GuideGroup is the default value
The if is not needed, GuideGroup is the default options.
The if is not needed, GuideGroup is the default value.
Does this mean that the cache manager will be created even if the entry is not already committed?
You should make this a class member.
You should make this a class (ThreadRegistry)
this(new Config.Builder().build())
it should be private.
it is better to have this constructor private instead of public.
s/isServerRouteLoaded()/isServerRouteLoaded()
Why have you added this check here? Shouldn't it be removed?
s/isServerRouteLoaded()/isServerRouteLoaded()/
You don't need to call.onClickListener() here, as there is no need for runnable
You don't need to call.onClickListener() here, as there is no need for runnable.
remove ;
I think we should skip this, because the data includes the CommonImages.OVERLAY_SYNC_INCOMMING and even if the value is null we'll get a NullPointerException.
I think we should skip this, because the data includes the CommonImages.OVERLAY_SYNC_INCOMMING and even if the value is not provided.
I think we should skip this if you're just returning null.
I think it would be better to use Stream<String> on the declaration, so the Stream<String> is parsed as a stream.
I think it would be better to use Stream<String> here.
I think it would be better to use Stream<String> on the declaration, so the Stream<String> can be closed suggestion Stream<String> lines = Stream.of(in).lines();
It seems like you've lost the validation exception, please check.
It seems like you've lost the validation exception, please check
It seems like you've lost the validation exception, please check that it's not there.
Can this be a else if?
Can this be a switch instead?
this if is a no-op, k is never null.
You should probably spit out at least the class name otherwise ot won't be really helpful. As far as I remember, other classes to the same.
You could probably spit out at least the class name otherwise ot won't be really helpful. As far as I remember, other classes to the same.
You should probably spit out at least the class name otherwise ot won't be really helpful. As far as I remember, other classes that use a different AbstractID generation will be confusing.
I think this method should be public.
Needs to be public.
I think this should be 'final'
suggestion return Collections.emptyList();
return Collections.emptyList();
Collections.emptyList?
The purpose of this method is to provide a validSCT with noSCT and then all callers of this method can use the list of SCT, instead.
The purpose of this method is to provide a validSCT with noSCT and then all callers of this method should use the list of validSCTs. I suggest using a Preconditions.checkArgument here.
The purpose of this method is to provide a validSCT with noSCT and then all callers of this method should use the list of validSCTs. I know that you do not care much about the purpose of the list, but that might be weird.
Why not using the static method from getProviderSearchFilter().getEntity()?
Why did you remove this call? It is only about import storage model.
Why did you remove this call?
how about making it a bit more declarative: if (getStorageDomain().getStorageType().isBlockDomain()) { getVm().getImages().forEach(image -> image.setActualSizeInBytes(image.getSize())); }
OK, so maybe at least just write it to the log in backend. If we are changing the allocation type in engine and not libvirt so at least logging it should be easy and I guess helpful for users
OK, so maybe at least just write it to the log in backend. If we are changing the allocation type in engine and not libvirt so at least logging it should be easy and users can debug issues
you're going to store the enum name, but not the enum itself
you're going to get toUpperCase(Locale.US) here, but then you're not calling toUpperCase.
you're going to get toUpperCase(Locale.US) here, but the enum value is already normalized.
use java tmpFile = Files.createTempFile(srcFile, "testData"));
use java tmpFile = Files.createTempFile("srcFile, "testData"));
use java.io.File.createTempFile
could you please describe why this is needed?
How should the caller handle this with a tryHandshake?
How should the caller handle this with a single argument?
This should not be public.
This should not be public. The default value should be NONE.
This should be _endTime = 0L;
public void upgradeComplete() {... }
The public void upgradeComplete() is missing
public?
Just check this before you decide about what to do with this.
Just check this in the constructor
Just check if this is null before you start from?
I was wondering if the scope of the test is to make the scope of the issue, or not, but the scope of the test is quite dusty. Does it do so?
I was wondering if the scope of the test is to make the scope of the test clearer. Does it mean that we check that the scope of the profile is "biologicalMetric" for the whole filter?
I was wondering if the scope of the test is to make the scope of the test clearer. Does it mean that we check that the scope of the profile is "biologicalMetric" for the keyword set?
Please extract the for each loop to a separate old school for each loop, it's better to read
Maybe extract the for each loop to a separate old school for each loop, it's better to read
Please extract the for each loop to a separate old school for each loop:
You're testing that the string is not null, but the AssertionError is for clarity.
You're testing that the string is not null, but the AssertionError being thrown is not a valid AssertionError.
Please check the value of this String, NullHandling.notNullString()
suggestion return ID_MAP.get(identifier).get();
![MINOR](<LINK_0> 'Severity: MINOR') Specify a "id" parameter instead. [![rule](<LINK_1>](<LINK_2>
![MINOR](<LINK_0> 'Severity: MINOR') Specify a "name" parameter instead. [![rule](<LINK_1>](<LINK_2>
this.
@manstis I think this should be non-public class
this. (and the one below)
Is this upper case required?
Is this upper case necessary?
Is this upper case?
"A VariantErrorStatus has been added."
"Exception" instead of "Exception"
"return" isn't needed
This method is invoked by popAndRedirectMessage(). The current implementation of popAndRedirectMessage() is the method that you want.
This method is invoked by popAndRedirectMessage(). The current implementation of popAndRedirectMessage() needs to be simplified.
Can the processor name be extracted from the stub?
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "request". [![rule](<LINK_2>](<LINK_0>
10 seconds seems a bit excessive.
Make sure to set isEmpty
This can be null.
This checks against null. Please add a null check on the return value
This can be null. Please add a check on the first line of the method
@fanifieiev the same above.
@fanifieiev the previous two lines should be final
@fanifieiev the previous version was fine
What happens if there is no more than one message?
What happens if there is no more then one message?
What happens if there is no more then one line in the log handler?
This is a good place to make static methods on the server. It might be useful to have a util method which takes in a EurekaClient and wraps it with an Interests.
This is a good place to make static methods on the server. It might be useful to have a util method somewhere that returns a ServerResolver.
This is a good place to make static methods. It might be useful to have a util method.
Shouldn't we check here
Shouldn't we check here if properties are not null?
Shouldn't we check here also?
is this method supposed to be called a few lines above?
is this method supposed to be called from any of the internal tokens?
is this method supposed to be called a few times?
public void checkName(String origName) throws Failure { if (StringUtils.isNotBlank(origName)) { throw new Failure(Messages.Hudson_JobSinglesQuotesAreProhibited(origName)) } }
There is no need to check for DEFAULT_PATTERN.
public static
This is a bit hard to follow. Shall we pull this out into a separate method, and call it in other places?
This is a bit hard to follow. Could the expected exception be thrown?
This is a bit hard to follow. Shall we pull this out into a separate method.
Please, change findAny().get() to findFirst().
Please, add spaces between if and (.
Please, remove redundant spaces between if and (.
typo? :)
typo
use String constant? :)
Will be slightly better to have a test method for this.
Check error code/description
Will be null if you send an empty password by mistake
since this is a default method, I think we should throw an exception in the default case.
since this is a default method, I think we should throw an exception if the argument is null.
since this is a default method, I think we should throw an exception in the constructor.
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_1> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "finishTaskInErrorTask". [![rule](<LINK_0>](<LINK_2>
I think this would be cleaner if you could use the service.call() method here.
I think this would be cleaner if you could use the service.call() method like in the RemoteServiceException
I think this would be cleaner if you could use the service.call() method like in the catch block.
It's confusing to have a test stopAllGrids(); in the AfterTest() method. Why do you need it here?
It's great if you can add some spaces here :)
It's confusing to have a test stopAllGrids(); in stopAllGrids();
For consistency: consider using "final".
For consistency, consider using "final".
For consistency: consider using requireNonNull for data
Why not using [int](<LINK_0>?
Why not just do queueModeHelper.createServer()?
Why are you casting to int?
Null check here.
Null checks here.
Null check on ryaType.data
Can we get rid of the double containsKey check?
Can we get the value from the targetTable? Looks like we do not need it to be null.
Can we get rid of the containsKey() check?
this.clientEntity = checkNotNull(clusterEntity, "clusterCacheIdentifier")
this.clientEntity = checkNotNull(clusterEntity, "clusterEntity")
this.clientEntity =... is enough
input is not @Nullable, remove annotation or add null check.
input is not @Nullable so remove annotation or add null check.
input is not @Nullable, remove annotation or add null checks.
The latch should be released in a finally block, to avoid calling into the main method.
The latch should be released in a finally block, to avoid that from happening again (trying to the main thread).
The latch should be released in a finally block, to avoid that from happening again (trying to complete the thread in the background).
This should be just return client.verify(algorithm, digest, signature, context).toUtf8().
Use withContext(context -> client.verify(algorithm, digest, signature, context)).toUtf8().
Use withContext(context -> client.verify(algorithm, digest, signature, context)).toUtf8().first();
don't need to copy the list if you can avoid copy it
don't need to copy the list
don't need to copy the list if you can avoid it
Should this method implement the  interface?
Should this method implement  interface?
Should this be implemented?
This is getting long, wrap wrap the arguments
This feels like it should be all on the same line, not in the data source code.
This feels like it should be all on the same line.
you can avoid the call to super()
you can avoid the call to super
you could skip this check
Is there a ready method for returning null?
Is there a ready method for returning empty string?
Why not returning empty string?
java return LinuxStateItem linuxStyle!= null? linuxStyle.getHeightFactor() : super.getHeightFactor(event);
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Remove this unused method parameter(s) "getHeightFactor". [![rule](<LINK_2>](<LINK_0>
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Remove this unused method parameter(s) "stateTableIndex". [![rule](<LINK_2>](<LINK_0>
Can we add a rateLimiter.add(progress.create( targetRate / numberOfTasks)? rateLimiter is probably more appropriate as well
Can we add a rateLimiter.add(progress.create( targetRate / numberOfTasks) for consistency?
Can we add a rateLimiter.add(progress.create( targetRate / numberOfTasks)? rateLimiter is a very general purpose.
ValueAndBound<T> getValueForTimestamp()
ValueAndBound<T> getValueForTimestamp()?
Do we want this to be Optional<ValueAndBound<T>>, and move the logic inside the if block?
Can we have an assertion here please?
Can we have an additional method for groupId and artifactId? Is that possible to use this?
Can we fix this?
I'd add some basic check here: *.stream().map(this::getEngineSessionInfo).collect(Collectors.toList());
I'd add some basic check here: *.stream().map(this::getEngineSessionInfo).map(UserSession::new)
Why did you move this here?
We could the variable declaration and just use return decoratorClass.newInstance();
We could the variable check, and just use return decoratorClass.newInstance();
We could the variable check be done before the try.
this LOG line is unnecessary
this LOG line is unnecessary.
this log is redundant.
Use this.metadataKeys to be consistent with the other variables?
Use this.metadataKeys to be consistent with the other fields?
Use this.metadataKeys to be consistent with the other properties?
Use readAsString(...) instead
Use readAsString(InputStream).
Use readAsString(InputStream)?
This is not correct. APP_ENGINE_RUNTIME_VERSION = APP_ENGINE_RUNTIME_VERSION; return APP_ENGINE_RUNTIME_VERSION;
This is not correct. APP_ENGINE_RUNTIME_VERSION is a public static final String VERSION = "test" + APP_ENGINE_RUNTIME_VERSION;
I think this is not correct. APP_ENGINE_RUNTIME_VERSION is a public static final String VERSION = "test" + APP_ENGINE_RUNTIME_VERSION;
This method can be declared private
This method can be private.
This method can be declared private.
Is it necessary to check if the label is empty?
Is it intended to be a breaking change?
Is it intended to be public?
Is it passing of the exception message but not equal to the new one?
Is it passing of the exception message but not equal to the log of it?
Is it passing of the exception message but not equal to the new one? Is it passing of the message?
please always add where it is in the log
please always log isEqualTo to stdLimit
please always log isEqualTo to stdLimit.
View.isAppLauncherEmpty();
view.isAppLauncherEmpty();
View.isAppLauncherEmpty()
you can make this also static
you can make the same optimizations here as you did with it
you can make this second parameter public
Shouldn't this be transactional?
Shouldn't we use a UserUtils.createClient() here?
Shouldn't that be transactional?
I'm not sure if this is the right thing to do - it's because of the i18n value field. Can we use it here?
I'm not sure if this is the right thing to do - it's because of the rounding errors?
I'm not sure if this is the right thing to do - it's because of the rounding errors.
We don't need to start the execution plan for parameter validations.
We don't need to start the execution plan for parameter validations
bad variable name
Add a checkNotNull() check
remove this as it was already public
remove this
Please add braces, even if it's a single line statement
Please add braces, even if it's a single line statement.
Please add braces, even if it's a Oneliner
This boolean should be moved to an else clause and throw an exception instead of logging.
This boolean should be moved to an else clause and do the renaming inside it.
The boolean should be moved to an else clause and do the throw after the return.
use try-with-resources statement
use try-with-resources instead of the third statement
use try-with-resources instead of the two
What's the purpose of this line? It doesn't seem to be clicking on another'verify' button. What's the purpose of this method?
What's the purpose of this line? It doesn't seem to be clicking on another'verify' button. What's the purpose of this test?
What's the purpose of this line? It doesn't seem to be clicking on another'verify' button. What's the purpose of this line?
add "this" qualifier
the return type should be List<LogicalNode>.
the return type should be List<LogicalNode> (this avoids object creation)
I think it would be better to use the [String#format](<LINK_0> method that accepts a String.
I think it would be better to just put the value directly in the constructor.
Same here. LGTM.
Why are we returning an immutable map?
Why are we returning an empty map?
Why are we returning an immutable map, and returning an immutable map?
I think you should also have if (isUser == null || isLoading)
I think you should also have if (fUser == null || fUser == null) {
I think you should also have if (isUser == null || isName(c))
Assert.notNull() is redundant here.
initialization of the expression is redundant.
Assert.notNull()
When you update this trace message you no longer need to add it to the list.
When you update this trace message, this method should return void.
When you update this trace message you no longer need to add it.
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
Not needed, the next statement handles it in the DB, do you really care if we have the status changed in the instance?
Not needed, the next statement handles it in the DB, do we really care if the status changed in the instance?
why do you need double-check?
why does this need to be public?
why do you need double loops here?
no need for this line
no need for the VM parameter
no need for the VM..
When this is called, it should be return false.
When this is called, it must be the same.
Is this a bug?
This method shouldn't be public.
This method isn't needed.
Remove this method.
You could use microServiceContext.getService(getClass()) to get the service directory
You could use microServiceContext.getService(getClass()) to get the service name.
You could use microServiceContext.getService(getClass()) to get the service directory.
I don't understand where this method is used and where the existing role is?
I don't understand where the preprocessedRole, but the method in removeFromAllGroups() is only called from anywhere. We need to update that in the UI
I don't understand where the preprocessedRole, but the method in removeFromAllGroups() is only called from anywhere else.
type should be List<Integer>
type should be List<Integer> (no need to specify type)
type should be List<Integer>.
CM name isn't a very descriptive name. We should say something like "testSerializeAndDeserialize" or something like that.
CM name isn't a very descriptive name
CM name isn't a very descriptive name right?
Use NLS.bind()
Use NLS.bind() here and below
Use NLS.bind() here and below.
Any reason we are using this class?
Any reason for this?
Any reason for this class?
With a previous fix, there should probably be a check if event.getTargetId()!= null && originalId.equals(originalId.toString()) to avoid potential NPE
With a previous fix, there should probably be a check for null before creating the string.
With a previous fix, there should probably be a check for null before creating the object.
Why public?
Why not public?
Why public? And not private?
make this a constructor method
make this a part of code base
make a defensive copy of the list.
this should be in a helper method
this should be in the execute method
this should be in a helper class, not in the model,
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName());
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName())
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1 indent + 1, "typeName", type.getInternalName());
Nice. We should think of removing this function.
Potentially there is a race condition.
Nice. We should think of removing this method.
I think we want to make this constructor a Optimizer method, i.e.: public Optimizer() { this(5,SearchMethodName.BLINDSEARCH,0.5); }
I think we want to make this constructor a Optimizer method, i.e.: public Optimizer() { this(5, SearchMethodName.BLINDSEARCH,0.5); }
I think we want to make a defensive copy of the existing value, i.e. make it a singleton
AFAIR this will throw an exception when a SqlStack doesn't have a cause.
AFAIR this won't work in Android, so this could be removed
why this call?
Does it make sense to add a param in the constructor?
Does it make sense to move the member?
Does it make sense to add a param in the ctor?
Can we encapsulate this logic in the upper class, e.g., Objects.requireNonNull(currentAlias)?
Can we please move this line of code before the if (currentAlias == null) { return currentAlias; } and avoid nesting?
Can we encapsulate this logic in the upper class?
You can use @Rule ExpectedException to make the test more robust.
You can use @Rule ExpectedException to make the test more concise.
You can use @Rule ExpectedException to make sure the classpath is in the classpath.
Collections.emptyList()
Lists.newArrayList()
Lists.newArrayList()?
onCompleted() can be called after child.onCompleted() or after child.isUnsubscribed().
onCompleted() is called after child.isUnsubscribed() so no need to call it.
onCompleted() is called after child.isUnsubscribed()
This should be called when the user is open the activity like onReadyCreate().
This code doesn't match the account info (onReadyCreate() is called)
This should be public
Should return false if!part.isLocal().
Should return false if!part.isLocal()
Should return false if!part.isLocal();
Is this function called by the base class? Then the setTargetEnum method could be private.
Is this function called by the base class? Then it will be called whenever the link is made.
Is this a new method? Then the setText can be removed.
you can use Collections.EMPTY_SET instead, which would avoid the warning in the callers.
you can use the ImfXmlLocation.EMPTY_SET instead, to avoid warning on the warning.
you can use the ImfXmlLocation.EMPTY_SET instead, to avoid warning: return emptySet()
You should say <T extends LwM2mResponse>.
You should say <LINK_0>
You should say <T extends LwM2mResponse>
we can remove the status variable by calling addEndpoint(endpointData)
we can remove the status variable by calling return addEndpoint(endpointData);
we can remove the status variable by calling addEndpoint(endpointData) on that
verify(fragmentMap.containsKey(id)?
add a message in case it ever fails
add a message.
"Lizziemom"
Same here. I didn't see what you intended.
Same here suggestion for PR.
Why not just make it public?
Why not just make it static?
Why not INSTANCE_MAP.size() > 0?
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually public, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts).
nit: use parameterized logging instead of string concatenation.
nit: use warn instead of warn and add default:
Should this be warn instead?
hash = object.hashCode();
You need to clone it as it is a common object.
You need to clone it as well.
Are you sure you can use the hamcrest Matchers here?
Are you sure you can use the hamcrest sand +() here?
Are you sure you can use the hamcrest sand +() here instead of the concatenation?
How about adding one more logging before it with a description what's wrong? I'm afraid the test will fail if it works, so I'd like to see it. How about something like: org.cabref.sm.ned.util.Person1 CurrentFixtures.getOwner()![image](<LINK_0>
How about adding one more logging before it with a description what's wrong? I'm afraid the test will fail if it works, so I'd like to see it. How about something like: org.cabref.sm.ned.util.Console.separator#equals(java.lang.String)
How about adding one more logging before it with a description what's wrong? I'm afraid the test will fail if it works, so I'd like to see it. How about something like: org.cabref.sm.ned.util.Console.separatorsToSystem(String)
Maybe we could extract the common logic to a method? What do you think?
Maybe we could extract the common code to a method? What do you think?
Maybe we could extract the common logic to a method?
Should this be FusekiEmbeddedServer.create()?
Should this be more fuseable?
Should this be more franular to use FusekiEmbeddedServer.
should be called resources
should be public methods
should be public
I'm not sure if this should be a good idea to use a different puncher store with a simple _plus_ loop. A correct implementation would be: public void updateProgressForClockUpdates() { puncherStore.put(0, 1, 2, 3, 4, 5, 6, 7, 8, 9).stream().map(s -> s.get(s)); }
I'm not sure if this should be a good idea to use a different puncher store with a simple _plus_ loop. A correct implementation would be: public void updateProgressForClockUpdates() { puncherStore.put(0, 1, 6, TimeUnit.MILLISECONDS); }
I'm not sure if this should be a good idea to use a different puncher store with a simple _plus_ loop. A correct implementation would be: public void updateProgressForClockUpdates() { puncherStore.put(0, 1, 6, TimeUnit.SECONDS); }
We don't align on columns.
We don't align on columns, use HardSoftLongScore.ONE_HARD,
We don't align on columns, and should be OK.
To be consistent with the rest of the code, it should be _public_
To be consistent with the rest of the code, it should be public final
should be @Nullable
As this list is specific to the ArrayList, you should be able to use Collections.unmodifiableList().
As this list is only accessed in the constructor, I would suggest to cache it.
As this list is specific to the ArrayList, you should be able to use Collections.unmodifiableCollection()
Please make this private.
Please make a space before the return
Please make this protected, @NonNull
the method name is slightly misleading, it's not a test
you are catching Exception without catching an Exception
Exception is more specific.
The new randomGenerator(RANDOM_SEED) should be the last argument.
The new randomGenerator(RANDOM_SEED) should be enough, it is redundant.
The new randomGenerator(RANDOM_SEED) should be enough, should be existing constructor.
filters method argument should be passed to isMessageInLogFile as an argument
filters() should be passed to isMessageInLogFile as an argument
filters method argument should return true for logFileName as well.
Maybe DEFAULT_BARRIER_TIMEOUT_MS is a better name for this field?
I think DEFAULT_BARRIER_TIMEOUT_MS is a confusing name.
Maybe DEFAULT_BARRIER_TIMEOUT_MS?
It's fine to leave it at this point. It's not good to introduce unit tests for this method.
It's fine to leave it at this point. Remove the change to :P
It's fine to leave it at this point. It's not good to introduce unit tests for it, but at least unobvious what the PR is for this conversion.
Can we revert this constructor argument change for classes that don't implement ResultBearing?
Can we revert this constructor argument change for classes that don't implement ResultBearing.
Can we revert this constructor argument change for class definitions?
Do we really need a test for this?
This is an error. We should do a test.
Do we really need a test in this class?
@slubwama Why log the element and not the selected element? However, I think this method is not supposed to be used (i.e., click on the button and then switchOutOfIFrame()) {... }
@slubwama Why log the element and not the selected element? However, I think this method should be used in place of the method.
@slubwama Why log the element and not the selected element? However, I think this method is not supposed to be used (i.e., click on the button and return an element)
@bdragan this.origin = tr.get();
@bdragan let's not do this.
@bdragan let's do this.origin = tr.get(); and do it in the same line.
I would use CollectionUtils.removeIfFatal(vmId, "vmId"); instead, since it is not critical there is no reason to use it.
I would use CollectionUtils.isNotEmpty() instead of the contains() call.
I would use CollectionUtils.removeIfFatal(vmId, "vmId"); instead, since it is not needed?)
This is a lot of copy/paste... could we create a SimpleDateFormat here?
This is a lot of SimpleDateFormat per test, and we have SDKs to parse it easily. It's best to have a SimpleDateFormat on the user side.
This is a lot of copy/paste... could we extract it?
Nit: this.mChoices = this.mChoices;
Nit: this.mChoices = BoxMap.uniqueResult();
Nit: this.mChoices = this.mChoices.clone()
Remove entire wrapper finally block
Utils method to remove entire wrapper finally
remove entire wrapper finally block
No need for this test
This should be changed to assertSame
No need for that empty line
wtf?
wdyt about adding some message to this exception, including the stack trace is fine?
wdyt about adding some message to this exception, including the stack trace being generated?
Should we use the external ID here instead?
Should we use the external ID if it is needed?
Should we use the external ID here?
Can you please make the constructor private?
why put?
why not public?
Please add "final" modifier to the method.
Could you add "final" here in case the doc is null.
Could you add "null" here to both cases?
From a previous attempt to fix this: <LINK_0>
Same as above, please use Objects.hash(position, sequence)
From a previous attempt to fix sequence sequence is not obvious.
Nit: You can remove the if here - the expected value is what you have done in the code.
Nit: You can remove the if here - "skipping verify validation"
Nit: You can remove the unnecessary else clause.
Keep the suggested changes too.
Keep the suggested changes.
Keep the suggested changes before the suggested changes.
The lists are just a fixed capacity so, but if you want to 'no-op' I'd suggest to use Sets.newHashSet({value}) instead.
The lists are just a fixed capacity so, but if you want to 'no-op' I'd suggest to use Sets.newHashSet({value}) here, as it's more efficient.
The lists are just a fixed capacity so, but if you want to 'no-op' I'd suggest to use getOrDefault() here.
Do you think this can cause NPE if fongo is null?
Do you think a null check is necessary if fongo is null?
Do you think this if the super() is redundant?
Could be void
Could be one-liner using next()
Could be one-liner?
I don't think that this comparison is necessary
I think you need to add a connected property like this to the enum itself. It's not really obvious what it means here.
I don't think that this comparison is necessary because it is not implemented with isConnected().
Then you could use Given.ACommand.createProject()
Please explain when this change is needed.
Then, you could use Given.ACommand.createProject()
Can we add null checks for identity?
AccessControlInfo has an IdentityListener which is used for access control and therefore are not required.
AccessControlInfo has an IdentityListener which is used for access control and therefore are not required
We should add requireNonNull and check that parentMemoryContext is not null.
We should add requireNonNull and check that parentMemoryContext is not null
requireNonNull(parentMemoryContext)
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive. rulesAnnotation" are not clear enough.
rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
Missing discard command.
Missing randomDiscard param.
Missing discard command
Can we get rid of this, which couples the issues with the constant.
Can we get rid of this, which couples the issues with the tests? Can we log an error message when the content is not a number?
Can we get rid of this, which couples the issues with the constant?
1. I think this is a leftover from the previous code. 2. If configBuilder is null, then we can't do Config.builder().fromConfig(configBuilder.image(NO_IMAGE).build()).image(NO_IMAGE).build()
1. I think this is a leftover from the previous code. 2. If configBuilder is null, then we can't do Config.builder().fromConfig(configBuilder.image(NO_IMAGE).build()).image(NO_IMAGE).build()? What is the difference between image and image?
1. I think this is a leftover from the previous code. 2. If configBuilder is null, then we can't do Config.builder().fromConfig(configBuilder.image(NO_IMAGE).build()).image(NO_IMAGE).setTemplates(false);
Why private? Is it private?
Why private? Is it private later?
Why private?
Avoid using double check: java if (firstBound.getSymbol().isInterface()) return firstBound;
Avoid using null check: java if (firstBound.getSymbol().isInterface()) return firstBound;
We should return a JavaType, not null.
Can you add external resources to the ExternalResourceConstants.EXTERNAL_RESOURCE_KUBERNETES_CONFIG_KEY_SUFFIX?
It would be good to use ExternalResourceConstants.EXTERNAL_RESOURCE_KUBERNETES_CONFIG_KEY_SUFFIX.
Can you add external resources to the ExternalResourceConstants.EXTERNAL_RESOURCE_KUBERNETES_CONFIG_KEY_SUFFIX.
same suggestion about static comparator
same suggestion about static comparator there
same suggestion about static class Comparator
@vilchik-elena Why this? Is this method used in a few places?
@vilchik-elena Why this?
@Override?
Might be better to have dao.exist() and call it, but OK to do that later.
nit: exists(key)!= null
Might be better to have dao.exist() and call it, but OK to do that later on.
sorry for saying this.endCopyCollapseOperations should be part of the "setSucceeded(true)" section, as it is currently done in the "setSucceeded(true" section.
sorry for saying this.endCopyCollapseOperations should be part of the "setSucceeded(true)", it should be "setSucceeded(true".
sorry for saying this.endCopyCollapseOperations should be part of the "setSucceeded(true)" section.
The innerIterator is not thread-safe, meaning if two threads access next() in parallel, they may get junk. By synchronizing the wrapper, only one thread at a time gets through to the inner interator, other threads are blocked in the wrapper until the thread inside is done. That way, this method returns a thread-safe iterator.
The innerIterator is not thread-safe, meaning if two threads access next() in parallel, they may get junk.
The innerIterator is the base class, where the inner one is the children of the inner one.
this is a noop, as you always send the fpMessage
this is a noop, as you always send send to the Playlist messages themselves
this is a duplicate of what is causing
change to wikiURL
what is the point of having this line?
move this to separate method
An exception without any messages or stack traces.
Should we log or re-throw an exception here or just ignore?
Should we log or re-throw an exception here?
Wonder if this would work/read better.
Wonder if this would work. If you set the maxStrokeDashArray to a constant string, then you can safely use Double.valueOf(tempStrokeDashArray[i].trim());.
Wonder if this would work.
Extra space after (
toString() is not needed
Extra space after =
This is private and could be made private.
This is always true in unscaled.fromNullable().
This is always true.
this can be "Host.getStats"
Host.getStats() can be extracted to a constant.
Host.getStats() can be extracted as a constant.
This does not work with java.util.Range.
this does not work with java delta >= 0
This does not look right. I think you should use -1 to indicate delta
replace with Preconditions.checkArgument
nit: please use Preconditions.checkArgument() here.
replace with Preconditions.checkArgument?
Actually, it would be better to verify that the tested content and the contents were read correctly.
Actually, it would be better to verify that the course action was successful according to the CourseAction.
Actually, it would be better to verify that the tested content and the contents were written properly.
Remove this.
line break
Extra spaces
This check should be removed.
This actually has to be claimSlot(int slot, long[] key )?
This check should be removed. Since the old claimSlot() method returns a negative size.
If we add the default header in the request for an existing header, then we can avoid adding it twice.
If we add the default header in the request for an existing header, then we can avoid adding it if the default is an existing header.
If we use an overridable setHeader() method, then we can avoid ifs like this.
pls use ST_jdk_class.equals(version)
pls use ST_service_ version instead of VERSION
pls use ST_jdk_class.equals(Version)
The PaymentWorksVendor class has a getPaymentWorksVendorByPaymentWorksVendor method that could be called here.
The PaymentWorksVendor class has a [added method](<LINK_0>, therefore you could factor that out by calling that method here
The PaymentWorksVendor class has a getPaymentWorksVendor() method
blocking calls inside the SDK are not good. they can cause deadlocks.
blocking calls inside the api are not good. they can cause deadlocks.
blocking calls inside the SDK are not good. they can cause deadlocks because the variable is not volatile.
is it needed to emoji in replacement?
Please add a space after FROM
As discussed if I run this in my IDE
I understand that this is a duplicate of the deactivate method, but should this be removed? I mean, the deactivate method should be removed.
I understand that this is a duplicate of the deactivate method, but should this be removed? I mean, the deactivate method should be removed if it's needed.
I understand that this is a duplicate of the deactivate method, but should this be protected? I mean, it should be like protected.
This already calls remove, why do we need it in this cache and then remove them?
This already calls remove, why do we need it in this cache?
This already calls remove, why do we need it?
There is no reason to do (parserMap!= null) here, isn't it?
There is no reason to do (parserMap!= null) here, since the toString() method is never called.
There is no reason to convert timestampSpec to string and then toString()
Maybe extract this 2 lines into a method?
Maybe extract this 2 lines into a constant?
Maybe extract some constant here?
I would prefer to remove this boolean and move the constructor above it to a default value. That way if the feature is not enabled, it will still be easier to port the feature without having to set it twice.
I would prefer to remove this boolean and move it to the top of the class
I would prefer to remove this boolean and move the constructor above it to a default value. That way if the feature is not enabled, it will still be easier to port the feature without having to set it explicitly.
You already log an error if JNDI log is enabled, as part of getAuditLogger() -- do we need this else statement?
You already log an error if JNDI log is enabled, as part of getAuditLogger() -- do we need this check?
You already log an error if JNDI log is not enabled, as part of getAuditLogger() -- do we need this else statement?
3 return persist(roleSchoolDataIdentifier.setIdentifier(name));
3 return persist(roleSchoolDataIdentifier.name(name));
3 return persist(roleSchoolDataIdentifier.UUID, name)
This is redundant in Mockito 2
This is redundant in the next line.
This method is redundant in Mockito 2
shouldn't there be a brick status for UP as well?
shouldn't have the brick status be down?
shouldn't there be a brick status for UP
Same here, it's a good idea to abstract it out in a separate method, and use it in both places.
Same here, it's a good idea to abstract it out in a separate class. Maybe even have it be configurable?
Same here, it should be static.
One more debug logging.
One more debug message
One more debug log message
This is not really related to this PR, but should this method be synchronized?
This should be synchronized instead of lock.
This is not going to lock the holder.
Same here - unresolved merge conflict.
Same here - can you merge the line above into one?
Same here - can you merge the line above into line 80?
Magic string...
Assertion failed
Magic string a bit...
I know this is not a legacy test, but I've come to fix all the tests. I would vote for moving them to separate PR.
I know this is not a legacy test, but I've come to fix all the tests. Did you look at the original code?
I know this is not a legacy test, but I've come to fix all the tests. I would vote for moving them to separate PRs, to separate discussion.
Same as above. Also you need to pass the mapper.writer() around the writer.
Same as above. Also you need to pass the mapper.writer() around the ObjectMapper.
Same as above. Also you can use the default ObjectMapper.
instead of logging the error message, it would be better to log the exception message.
instead of logging the error message, it would be better to log the store name.
instead of info logging just one error message, we could log the store name.
Should be meanf.
Should be mean args.
Should be +\u.
what if this method is called multiple times?
what if this method fails? is it supposed to be called again?
what if this method fails?
is this method used anywhere?
Should there be a unit test for isValid()?
Should there be a break here?
Please add space around operators
Please add space between operators
Please add space around operators to make it more readable
This should be a static constant, no?
This should be a static constant, no need to re-use it.
This should be Locale.ROOT
suggestion assertEquals(1, RuntimeExceptionOnOnlineListener.onOnlineCount); I suggest following the existing pattern in this file and calling the assert() methods directly. Then the new import also wouldn't be needed.
suggestion assertEquals(1, RuntimeExceptionOnOnlineListener.onOnlineCount()); I suggest following the existing pattern in this file and calling the assert() methods directly. Then the new import also wouldn't be needed.
suggestion assertEquals(1, RuntimeExceptionOnOnlineListener.onOnlineCount); I suggest following the existing pattern in this file and calling the assert() method directly. Then the new import also wouldn't be needed.
should be a constant
should be a URI, or a constant.
should be a // TODO
If we're using dockerHostEnv as the default it should be dockerHostEnv instead
if unix, then not we don't need to initialize dockerHostEnv
If we're defining unix path, then it would be better to avoid NullPointerException.
Please catch specific exception(InterruptedException) not generic.
Please log this instead of printing it.
Please log this exception.
@stianst Is there any reason to replace it with ws-full-name-?
@stianst Is it better to replace ws-full-name-" by /ws-3.0?
@stianst Is it better to replace ws-full-name- in this PR?
Please remember the getter for this.
Please remember the visibility of the field instead of public.
Please use the constants for the visibility
@xurxodev can you please use the constant from LRA_HTTP_ENDED_CONTEXT_HEADER here?
@NielsCharlier consider extracting magic number 2 to a constant.
should the constant be 2?
This variable seems like an unused variable.
This _is_ unnecessary?
This variable seems unused?
we should use this(cache.getComponentRegistry().getComponent(EntryRetriever.class)) to keep the line 195
we should use this(cache.getComponentRegistry().getComponent(EntryRetriever.class)) to keep the code consistent.
we should use this.cache.getComponentRegistry().getComponent(EntryRetriever.class) to have the instance variable.
I think this will throw an exception if username is not found.
I think this should return a long, rather than a Long.
I think this will throw an exception if username is null, i.e. make it return void.
You're exposing these methods outside of the base class. It seems odd to me to have them under the public fields.
You're exposing these methods to the base class. It seems odd to me to have them converted to byte[].
You're exposing these methods to the base class. It seems odd to me to have them converted to public fields.
Can we also validate that elements is equal?
Can you also validate that elements is equal?
Can you also validate that the element is equal?
Remove public please.
remove private
remove public
What happens when the event is not found?
This is not necessary, the debug log should be sufficient.
What happens when queueEvent() is called in the race condition?
not sure if it makes sense to remove this.
not sure if it makes sense to make this package private.
remove this.
We should also call setActionBarTitle(fieldName) here.
We should also call getArguments() in here.
We should probably call getArguments() in onCreate and setActionBarTitle to null.
Would it make sense to make this private and remove the public modifier?
nit: would it make sense to make this private and remove the public modifier?
Would it make sense to make this private and remove the public modifier? It would allow them to make it package-private (no access modifier).
it's better to mock the vm object instead of using the getter.
it's better to mock the DAO rather than using the getter.
it's better to mock the DAO not to use it, as only getter
result -> results
result -> expected
checkState
What is the default value of new byte[]{}? Is it a constant field with meaningful name?
What is the default value of new byte[]{}?
This line could use the default constructor of the builder.
Oh! No! You have just introduced the annotation here. :cry:
Oh! No! You have just introduced the @Override annotation :cry:
Oh! No! You have just introduced the annotation above. :cry:
this can be condensed to if (!chkAuthorization(...)) { return false; }... return true and get rid of haveAccess
this can be condensed to if (!chkAuthorization(...)) { return false; }... return true and get rid of hasAccess
this can be declared final
Can you add a AccessControlList.isEmpty() method to the base class to avoid the problem?
Can you add a AccessControlList.isEmpty() method to the base class?
Can you add a AccessControlList.isEmpty() method to the base class to avoid possible NPE?
Why would this need to be Integer.MAX_VALUE? Then you get the length of the map.
Why would this need to be Integer.MAX_VALUE? Then you can just get rid of the Integer.MAX_VALUE.
Why not just make this java minLen = key.length();
return Boolean.parseBoolean(value);
return Boolean.valueOf(value);
java return Boolean.parseBoolean(value);
Why fakeThread-unlockSimple?
Can you change this to fakeLockToken?
Why fakeThread
Please don't use method names in variables and method names.
Please don't use method names, please use class names instead of underscores
Please don't use hardcoded numbers
EqualsBuilder.reflectionEquals(this, o);
This EqualsBuilder.reflectionEquals() is not necessary.
This EqualsBuilder.reflectionEquals() is not needed.
I wonder if this should be part of tableName rather than query parameters.
I wonder if this should be part of tableName rather than query parameters?
I wonder if this should be part of tableName rather than put it at the end of string.
ch is instance of Http2StreamChannel, why do you need to return it?
ch is instance variable, not used.
ch is instance of Http2StreamChannel.
remove this line
also this one seems unnecessary
also this one seems redundant
Maybe you can replace this if with: return Optional.ofNullable(activeEditor instanceof SessionEditor? Optional.of(activeEditor) : Optional.empty();
Maybe you can replace all your if conditions with return Optional.ofNullable(activeEditor instanceof SessionEditor)? Optional.of(activeEditor) : Optional.empty();
Maybe you can replace this if with: return Optional.ofNullable(activeEditor instanceof SessionEditor? Optional.of(activeEditor) : Optional.of();
Won't this throw a NoSuchElementException if the stream is empty?
Won't this always throw an IOException if the stream is empty?
Won't this throw an exception if the stream is empty?
Maybe extract this also to a method: getBuildingRooms(p)?
Maybe extract this also to a method: getBuildingRooms(query)?
Maybe extract this also to a method: getBuildingRooms(query)
either handle cocoa like [CC](<LINK_0> or remove COLUMN_TRIM= 4 below
either handle cocoa like [CC](<LINK_0> or remove COLUMN_TRIM=24
either handle cocoa like [CC](<LINK_0> or remove COLUMN_TRIM= 4 below.
prefer the following to be more explicit: java throw new CloudStorageException( actionName, partitionPath, attempts);
prefer the following to be more explicit: java throw new CloudStorageException( actionName, (attempts >= maxAttempts)? throwOrDelay(e, actionName, attempts, attempts));
prefer the following to be more explicit: java throw new CloudStorageException( actionName, (attempts >= maxAttempts));
Reduce the return type to boolean
Reduce the return type by returning a boolean primitive: false in this case
Reduce the return type by returning a boolean field.
typo. reportErrorToProducer - don't declare local variables that are used in the try-catch block.
don't need this. You have null-check for the message when you create a new UX.
don't need this. You have null-check for the message when you access the pmode.getErrorHandling()
Please use the constants fromRepositoryHelper instead of hard coding them.
Please use the constants fromRepositoryHelper
Please, use the constants fromRepositoryHelper
Please implement equals() to provide debugging state information for debugging purposes.
Please implement toString() to provide debugging state information for debugging purposes.
Please implement equals() method either. This will remove the potential problem when working with collections.
declare throws please
it's better to use @NonNull for this method
it's better to use @NonNull like @Nullable
What about the 10th argument to convertProjectFromCtoCC method?
What about the 10th argument to convertProjectFromCtoCC thread?
What about the 10th argument?
Nit: I think we can do return m.entrySet().stream().collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue().toString()))
Nit: I think we can do return m.entrySet().stream().collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue().toString()));
Nit: I think this can be made private.
Combine this with the method signature?
This method should be static.
Combine this with the method signature.
Can you move the By selector to a separate class?
Can you move the By selector to a class constant?
Can you move the By selector to a field to be consistent with other similar constraints?
Externalize all strings
Either check and store the result of the Action in the fNextEventAction.
Why not CompositeImageManager.IMG_MULTIPLIER = SWT.NONE?
nit: If we use this instead of calling it from the fragment and not from the library, we can just call this onLoadFinished method from onLoadFinished().
nit: If we use this instead of calling it from the fragment and not from the library, we can just call this onLoadFinished method directly.
nit: If we use this instead of calling it from the fragment and not from the library, we can just call this onLoadFinished method from onLoadFinished.
Can we inline this variable?
Could we inline this variable?
Could we inline this method?
does modified need to be called again? I didn't see the purpose of this method. I would say remove it and set it to null.
does modified need to be called again? I didn't see the purpose of this method. Why would it need to be done in two places?
changed?
Did you forget to check that the check for requireDrug is not null and requireDrug is not null
Did you forget to check that the check for requireDrug is not null too?
Did you forget to check that the check for requireDrug is not null and requireDrug is not null?
Why do you need this synchronized block? You could just invoke getOverponedEventsLock() and then you can use fsManager.clearPostponedWatchEvents().
Why do you need this synchronized? I would just invoke getOverponedEventsLock and check in getOverponedEventsLock
Why do you need this synchronized? I would just invoke getOverponedEventsLock and check in getOverponedEventsLock.
If getVolatilityFunction() is called on line 64. Do you really mean _interpolator.getVolatilityFunction()?
If getVolatilityFunction() is called on line 343, the variable should be consolidated to getVolatilityFunction()
If this is not null on line <LINK_0>
currentDate -> now
Is this correct?
currentDate -> now, no?
Not clear why AIDL_LAYERS_PREFIX here
Not clear why AIDL_LAYERS_PREFIX here? Why do you consider it?
Not clear why AIDL_LAYERS_PREFIX here?
use an overridable getOperationTimeout() method instead
Use an overridable getOperationTimeout() method instead
createUnresolved and getUpcomingNodeContext()
could be replaced with Objects.hashCode(projectUuid, argument, analysisUuid)
should be fine
missed you one
Might be simpler to use RecordType.UNTYPED here.
Please revert this change.
In other places we use synchronized for this method.
JdbiOptionals.firstNonNull(type, config)
JdbiOptionals.firstNonNull(type, config, config)
JdbiOptionals.ofNullable
You should add the ApiDefinition to the signature of executePostGLJournalEntries.
You should add the ApiDefinition.POST here too
I think we should add the ApiDefinition.POST here too
why do we need a function here?
why do we need a temporary variable here?
why do we need a phase tearDown here?
Is there a way to make this a fluent API? It seems like it would be more consistent to use the fluent API.
Is there a way to make this a fluent API?
Is there a way to make this a fluent API? It seems like it would be more readable to use the fluent API.
This is repeated more times, could we extract it to a common method?
This is repeated more times, could we extract it?
This is repeated more times, could we extract it to a local method?
Remove
Remove this.
remove
If request is null, we should throw UnsupportedOperationException rather than return null.
No need to return null?
If request is null, we should return it.
remove System.out
please remove this System.out
remove this
Add a new line after the :
Add a new line after the colon
Add a bug here
Please change SetResponse.class to SetResponse.class
Please pass zero as an argument to SetResponse.
Please change this to SetResponse.class
please use with.name().
please use.name().
please use "../".
Why not return Collections.emptyList()?
Why not return Collections.emptyList()?
Why not use Collections.emptyList()?
:bug: this should be return Collections.emptyList();
:bug: this should return List.
:bug: this should be return List.of();
I would use JenkinsController.getCurrentUrl()
I think you can use JenkinsController.getCurrentUrl()
I would use JenkinsController.getCurrentUrl() instead.
Please handle that with an appropriate error message
Please handle the candidate for a null check.
Please handle that with an appropriate message
I think we should iterate over all elements and collect them to be consistent.
I think we should iterate over all elements of the tree.
I think we should iterate over all elements of the tree, not just the elements.
Maybe we should rename it to Info?
Maybe we should rename this log message to tidKey.
Maybe we should rename this log message to tear down?
Replace blocks with Block.isLiquid()
Replace blocks with Material.STATE_ACTIVE?
Replace blocks with Block.of()
This test is redundant, it should just be returned
This test is redundant, it should just be returned returned
This test is redundant, it should just be ignored.
could you add a message saying that this is not possible to bump SASL_HANDSHAKE schema without a dependency?
could you add a message saying that this is expected as well?
could you add a message saying what failed because it would be easier to debug debug when debugging.
The options are not needed at this point. I feel we should leave it out as is.
The options are not at all needed, I feel we should leave it out as is.
The options are not at all, I feel we should leave it out as is.
names
duple
confusing
The volatile reads here and releases the thread. I guess this doesn't hurt either.
The volatile reads here and releases the thread. Is there any reason for this change?
The synchronization is still needed.
please use \n since this is platform specific
please use \n since this is platform specific.
please use \n for local\n
Is there a reason for making this public?
This method is only called by default, please remove it.
Please add @Override
I would remove the corresponding line
I would remove the corresponding @Nullable annotation here.
I would remove the corresponding @Nullable annotation
This should be!Constants.INVENTORY_SIE;
This should be!Constants.INVENTORY_SIE.isEmpty()
This should be!Collections.isEmpty()
Just a nit: it doesn't need to be public
Just a nit: you can replace this with activity.getApplicationContext()
Just a nit: you can replace this with activity.getApplicationContext();
No tabs please.
You don't need a try-catch here. You can simply use @Test(expected=NullPointerException.class)
you don't need a try-catch here. You can simply use @Test(expected=NullPointerException.class)
this is not needed
this right?
this is not required
I think that every one should be wrapped with "#669966"
I think that every one should be configurable. maybe we should use the same preference as the one in the file.
I think that every one should be wrapped with a constant.
When you create a Converter, is this done? If not, it should be done in the presenter.
When you create a Converter, is this done?
When you create a Converter, is this done? If not, it should be done in the ViewModel where you created it.
return block.isNull(position)?
return block.isNull(position)?
just a thought.
dimValue.length() > 0 is equivalent
dimValue.length() > 0 is not needed
dimValue.length() > 0 is not needed here (and below)
There's a method in JUnit 5 that can be used instead of bringing in the dependency on the JPA rules.
There's a method in JUnit 5 that can be used instead of a String.
There's a method in JUnit 5 that can be used instead of a string check.
This code should not be here. The node queue won't be added to the queue until the node has been removed.
This code should not be here. The node queue won't be added to the queue until the node has been removed from the queue. So this is probably better.
This code should not be here. The node queue won't be added to the queue until line 63
The visibility of this method is more than private.
The visibility of the method is more important than private.
The visibility could be removed
Can't we use a constant for this?
This currently seems wrong, we need to clone the entire array or the list-level array.
This currently seems wrong, we need to clone the entire array or the whole list.
what makes this copy of the list of Copy and pastes?
what makes this copy a bit confusing?
what makes this copy of list of iterator implementations?
Nit: suggestion } else {
Nitpick: suggestion } else {
Nit: probably use a logger?
s/cachedTables/cachedTableNames
s/cachedTableNames/cachedTableNames
s/cachedTables/cachedTableNames/
maybe return dateFormat.parse(dateAsString)?
maybe return dateFormat.parse(dateAsString);
Why not return dateAsString?
It is more correct to check if the group is null or not.
It is more necessary to check if the group is null or not.
It is more correct to check if the group is null or not. The condition is the same as checkOrElse.
no need for the outer parentheses
no need the outer parentheses
no need the outer parentheses here.
There is something wrong with this check. You will do nothing with the other cancel*** ringing.
There is something wrong with this check. You will do nothing with the other cancelLongPress() call.
There is something wrong with this check. You will do nothing with the other cancelLongPress() call. I think it's redundant.
Can be simplified to return bases[0] == '.' || bases[bases.length - 1] == '.'
Can this be done in the other way around? return false;
This should be bases.length <= 1
This should be a constant.
This should be declared final
return Integer.parseInt(...
This is a good candidate for a builder, rather than having a public constructor.
This is a good candidate for a builder. [ containerMap](<LINK_0>
This is a good candidate for a builder.
Don't you want to store the output of this path as a String, this way an extra call to setOpenFLPath(moduleSettings.getOpenFLPath())?
Don't you want to store the output of this path as a String, this way an extra call to setOpenFLPath(moduleSettings.getOpenFLPath())
Don't use this. :/
don't you need to convert the exception in the response?
don't you need to convert the original exception as well?
don't you need to convert these again in the else block?
Doesn't it work with touch?
Doesn't it make sense to make this change? (If not, then leave it.)
Math.<Node> buttons, long actual, and also not API change.
Single-line nesting is a bit too hard to read here, I would change it to if (elements.isEmpty()) { return element.get(0); } else if (elements.isEmpty()) { dialog = elements.get(0); } } return null;
Single-line nesting is a bit too hard to read here, I would change it to if (elements.isEmpty()) { dialog = elements.get(0); } else if (elements.isEmpty()) { dialog = elements.get(0); } } return null;
nit: remove unnecessary else clause
WrappingDimensionSelector is doing the right thing for all theDimensionSelector. Have you considered using this. for example: public LongWrappingDimensionSelector(LongColumnSelector selector, ExtractionFn extractionFn) { this.delegate = selector; this.exFn = extractionFn; } public LongWrappingDimensionSelector(LongColumnSelector selector, ExtractionFn extractionFn) { this.delegate = selector; this.exFn = extractionFn; }
WrappingDimensionSelector is doing the right thing for all theDimensionSelector. Have you considered using this. for example: public LongWrappingDimensionSelector(LongColumnSelector selector, ExtractionFn extractionFn) { this.delegate = selector; this.exFn = extractionFn; } public LongWrappingDimensionSelector(LongColumnSelector selector, ExtractionFn extractionFn) { this.exFn = extractionFn; }
WrappingDimensionSelector is already used for wrapping function. Have you considered using this.
How can you make this method activate() so that it is called twice?
How can you make this method activate() so that it only calls it with the last statement?
I think you should make this something more transparent.
I think this is a fragile way to set the properties, maybe for example when you want to set it to 200?
I think this is a fragile way to set the properties, maybe for example when you want to set it to 200 or so
200?
If the VM's custom compatibility version is set, the cluster's compatibility version is different than the cluster's compatibility version. I think we should also skip the compatibility version if it is set.
If the VM's custom compatibility version is set, the cluster's compatibility version is different than the cluster's compatibility version. I think we should also skip the compatibility version if it is set. (If it is already initialized, the cluster's compatibility version is invalid)
If the VM's custom compatibility version is set, the cluster's compatibility version is different than the cluster's compatibility version. I think it is better to just check the cluster compatibility version and only if there is explicitly cluster compatibility version set.
I would use: super(null, source, currentModel, currentDataObject);
I would use: super(null, source, currentModel, currentDataObject);. Not sure what is better.
I would use : super(null, source, currentModel, currentDataObject);
I'd prefer to throw an exception
I'm not sure if it is a good idea to throw an exception
I'm not sure if it's a good idea to throw an exception
We are not able to do this.
We want to log this even if it is not an error.
We want to log this even if we go ahead and merge.
if we wipeSandboxForCurrentDemoUser(instance) should be in the if rather than here, then we should move the isUpgrade check to the throw new ResourceInitializationException("The user restore file location is null!");
wipeSandboxForCurrentDemoUser doesn't make sense here, since it's a default user backup, which is also a desired user.
if we wipeSandboxForCurrentDemoUser(instance) should be in the if rather than here, then we should move the isUpgrade check
return serialize(createFromEsriGeometry(new Point(x, y), SpatialReference.create(4326));
return serialize(geometry, new Point(x, y), SpatialReference.create(4326));
return serialize(geometry, geometry)
this == OPERATOR_BARRED || (this == OPERATOR_BARPER) || this == MISSING_UNKNOWN_PDP_REJECT_GGSN)
isPermanentFail not deterministic?
@ralphdoe is the condition supposed to be true?
For this should close the log, in case of failure.
For this should be AutoCloseable.
For this should be AutoCloseable, too.
Does the config.isExpressionCacheEnabled() method need to be here?
when do we need the isExpressionCacheEnabled() method?
when do we need the isExpressionCacheEnabled() check here?
The![MAJOR](<LINK_0> 'Severity: MAJOR') Call "Optional#isPresent()" before accessing the value. [![rule](<LINK_1>](<LINK_2>
The![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
The METADATA_KEY_DURATION header is not EVENT_KEY_DURATION
This is the same as AddonDependency now. Try asum.
This is the same as AddonDependency now.. no need to add another dependency. Try using AddonDependency now.
This is the same as AddonDependency now.. no need to add another dependency. Try a gurnace.
Why public?
typo: deconfig?
typo: deconfig
first impression here is, that we can do: java if (indexShift < 0) || (index >= length()) throw new IndexOutOfBoundsException("get(" + index + ")");
first impression here is, that we can use size() as trie.get(indexShift).size()
I think we should throw exception here.
suggestion return taskReviewsMap.get(taskUrl);
suggestion return taskReviewsMap.getOrDefault(taskUrl, Collections.emptyList());
suggestion return taskReviewsMap.computeIfAbsent(taskUrl, Collections::emptyList);
When cancel is called, it really makes sense to call cancel(null) here to cancel the notification?
When cancel is called, it really makes sense to call cancel() here instead of cancel() because the view is not actually canceled
When cancel is called, it really makes sense to call cancel() here instead of cancel() because the notification is not actually canceled
We don't need to do this explicitly. Separate class is fine for this case.
We don't need to provide vdsId here. Can we just pass the VmId from the audit log?
We don't need to provide vdsId here. Can we just pass the VmId from the db?
Call I18N.getString(String).
Call getString(String) (there are no parameters in the resource messages).
Call getString(String).
Why not using ProjectedTimeDimension.getName()?
Why not using ProjectedTimeDimensionBuilder instead?
Parameter shouldn't be mutable.
What would happen if the node is not found?
What is the use case for this?
What would happen if the node is not there?
public void assertArrayEquals(String... expecteds)
this test will pass even if we want to use the same name
public void assertArrayEquals(String... expecteds) throws IOException
You could just use java return Optional.ofNullable(start.minusMillis(excessMillis))
_could_ be final?
You could just return Optional.empty() here.
How is this method used?
Why not return metricFactory?
Why not return metricFactory.get();?
I found this code is useless, you can just do: return fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId());
I found this code is useless, you can just do fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId()); in the following lines
I found this code is useless, you can just do fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId()); in this case.
I think this should be going to be a _really_ inlined_.
I think this should be going to be a _String_.
I think this should be going to be a _blank_ list. If so, I'm missing something else.
there is no need to check for null, since the enum already returns an empty string.
to make it public, I would prefer to have an public modifier.
method should be marked private.
Please remove extra brackets.
Please replace with ternary operator
Please remove extra brackets
Make public static
Make this static
Log some meaningful message.
I think in this case only the stats are relevant to the update. UserProfile may be run in the execute phase but not the job of the command.
I think in this case only the stats are relevant to the update. UserProfile may be run in the execute phase but not the job of the command. I'd think that it would be better to check only the stats of the profile update even if the update succeeded, to make sure that the new profile is actually valid.
I think in this case only the stats are relevant to the update. UserProfile may be run in the execute phase but not the job of the command. I'd think that it would be better to check only the stats of the profile update even if the update succeeded, to make sure that the new profile is actually moved.
Here, you are re-using AdapterFactoryDescriptorRegistry instead of Relaxing access to the registry. Maybe even break it up to 2 points: 1. Make it a private static final Multimap<String, RankedAdapterFactoryDescriptor> INSTANCE = new RankedAdapterFactoryDescriptorRegistryImpl( RankedAdapterFactoryDescriptor.Registry.INSTANCE, Multimaps.unmodifiableMultimap(adapterFactoryRegistry)); You can ensure that you use a single instance for the registry instead of re-using it. 2. add() to the constructor of RankedAdapterFactoryDescriptor.Registry 3. change the constructor to throw an IllegalStateException if it is not initialized, so you don't need to wrap it.
Here, you are re-using AdapterFactoryDescriptorRegistry instead of Relaxing access to the registry. Maybe even break it up to 2 points: 1. Make it a private static final Multimap<String, RankedAdapterFactoryDescriptor> INSTANCE = new RankedAdapterFactoryDescriptorRegistryImpl( RankedAdapterFactoryDescriptor.Registry.INSTANCE, Multimaps.unmodifiableMultimap(adapterFactoryRegistry)); You can ensure that you use a single instance for the registry instead of re-using it. 2. add() to the constructor of RankedAdapterFactoryDescriptor.Registry 3. change the constructor to throw an IllegalStateException if you still want to use a different instance for the factory.
Here, you are re-using AdapterFactoryDescriptorRegistry instead of Relaxing access to the registry. Maybe even break it up to 2 points: 1. Make it a private static final Multimap<String, RankedAdapterFactoryDescriptor> INSTANCE = new RankedAdapterFactoryDescriptorRegistryImpl( RankedAdapterFactoryDescriptor.Registry.INSTANCE, Multimaps.unmodifiableMultimap(adapterFactoryRegistry)); You can ensure that you use a single instance for the registry instead of re-using it. 2. add() to the constructor of RankedAdapterFactoryDescriptor.Registry 3. change the constructor to throw an IllegalStateException if it is not initialized, so you don't need to handle this.
There's no reason to log this; let's just remove
There are no usages of this log statement.
Same here LOG statement.
tracef
trace
infof
Not sure what the locks.Condition is doing. The name(NameCriteria.startsWith("await")).withNoParameterConstraint()
Not sure what the locks.Condition is doing.
I'm not sure what the locks.Condition is here. _await_ withNoParameterConstraint()_?
You should throw the exception using a logger here.
This debug statement should be parameterized, no?
You should throw the exception using a parameterized message, not an IOException
This will throw NullPointerException if m_recoveredPartitions is null. Better to use.map(Integer::parseInt).
This will throw NullPointerException if m_recoveredPartitions is null. Better use.map(Integer::parseInt).
This will throw NullPointerException if m_recoveredPartitions is null. Better to use.map(this::parseInt).
Not sure it's better to do this before do we need to have the check done in DBO? When do we expect the state to be removed?
Not sure it's better to do this before do we need to throw exception in case of any exception.
Not sure it's better to do this before do we need to throw exception in case state is OFF.
FYI, I think this might be cleaner with a single command line java try {... } catch (Exception ex) { return false; }
s doesn't need to be fully qualified
FYI, I think this might be cleaner with a single command line "cwltool", no?
This check should also be done in the operator.
This check should also be done in the operator
This check should be done in the operator
Should return 1 and dims if expectedYear is 0.
Should return 1 and dims if expectedYear is 1.
A year and years are not required.
You could extract this to a private method.
You're missing a method!
You could extract this to a private method
Please add a getStorageId() method, for example: getSnapshotDao().updateStatus(getParameters().getSnapshot().getId(), Snapshot.SnapshotStatus.OK);
Please add a space between the 'and'
Please add a getStorageId() here, if possible we should use it.
I feel free to ignore: I don't think we need this, but the "'";
I feel free to ignore: I don't think we should add a "'";
I think we might want to add a "'";
Nit: I'd suggest "in VisibilityGuard".
Missed this one.
Nit: I'd suggest optimizeing this to an Optional.
getter
this.
public
This should be debug or trace?
This should be debug or trace
log the correct format
return battleState.getUnits(EnumSet.of(side)), getActiveUnits().and(Matches.unitIsNotInfrastructure()));
return battleState.getUnits(EnumSet.of(side)), getActiveUnits().and(Matches.unitIsNotInfrastructure));
nit, Extra space after return
np: s/LocalApplicationRunner/RemoteApplicationRunner
np: s/LocalApplicationRunner/LocalApplicationRunner
np: s/LocalApplicationRunner/ProjectRunner
You don't need to use emptyList() method because we are not using it
Could you please use assertThat(checksum, is(empty()))?
You don't need to use emptyList() method. We can use xml.
You should follow the indentation of the test style.
You don't need the <String> here.
You should follow the indentation of the test method style.
Please use the toString method.
Please use the toString() method.
Please use the String.format() method.
This will fail on ClassCastException too, since you're handling the ClassCastException here.
This will fail on ClassCastException too, since you're handling the same event twice.
This will fail if there is an exception instead of returning. Instead, use InitBiomeGens.tryFind(event);
Does this always run on the same thread? If not, it should just be a standalone Thread.
Does this always run on the same thread? If not, it should be a standalone Thread.
Does this always run on the same thread? If not, it should just be a standalone if (this happens).
Let's make all the accessors final.
Let's make all of the accessors final.
Let's make all the accessors final
Catch all exceptions, eg Exception?
Catch all exceptions, eg Exception or Throwable
I think we shouldn't use UndertowOptions.DECODE_URL here. This will cause authentication issues, eg io.getUndertowOptions()
I think it's also missing a case TRUNCATE.
I think it's also missing a case TRUNCATE
I think it's a good idea to also use a switch case here.
if (Context.TelephonyManager.INDICATION_FILTER_FULL_MODE_IGNORE_SCREEN_OFF) {
if (Context.TelephonyManager.INDICATION_FILTER_FULL_NETWORK_STATE!= /* */) {
if (subId > 0) {
This unwrapValue() should be called only if the model is a WFCORE-23: <LINK_0>
This unwrapValue() should be called only if the model is a WFLY-10.
This should be using DomainHandlerUtil.createEmptyList()
Why not have it as an isPositionedReadable?
Why not have it as an instanceof check?
Why not have it check for instanceof PositionedReadable?
Maybe you could split this assertion into two?
Maybe you could split this assertion.
Maybe you could split this assertion into two tests.
If we log an error message, illegalArgumentException is not appropriate.
Do we know that we're not using this outside of the scope of the method? It seems illegal argumentException is sufficient.
Do we know that we're not using this outside of the scope of this PR? If not, we should keep this method package-private.
You should make this method final and remove the setter.
You should make this method final.
You should make this final or add to the field.
Maybe it's useful to have a util method to check if stackType is an instance of WORKLOAD?
Maybe it's better to call this if (!StackType.WORKLOAD.equals(stackType)) since it's a paramaterized block
Maybe it's useful to have a util method to check ifStackType is dynamic.
This is a nice method of this class. Just call it something like checkUnknownEntryTypes().
This is not a good name for this method, but I wouldn't do something like this.
This is a nice method of this class. Just call it something like checkUnknownEntryTypes().isEmpty()
You can return the Iterator directly.
You can return the Iterator directly, no need to make it public.
You can return the Iterator directly, no need to make it public
Is it needed to check the value of ttlLatch.await(..) inactivityDurationInitialDelay? We should just check the value of it.
Is it needed to check the value of ttlLatch.await(..) inactivityDurationInitialDelay? We should just check the value of it, and not create the thread in startTtl() method.
Is it needed to check the value of ttlLatch.await(..) inactivityDurationInitialDelay? We should just check the value of it, and not have it here and fail fast.
We should also add the following try { load(); } finally { VIEW_INJECTED_VARS.setEnabled(getConfiguration().isEnablePermissions()); }
We should also add the following try { load(); } finally { load(); }
We should also add the default permission to the report.
Since leap-day/year-day aren't part of the actual month, you need to return the zero length
Since leap-day/year-day aren't part of this calculation, you need to return the actual length
You don't need the true-ness of the actual length calculation
I would store this in a field
I'd store this in a field
I would store this in a private field
Better to use: Map<String, Object> map = new HashMap<>(); map.put(alias, aggregateValue.getResult());
Better to use: Map<String, Object> map = new HashMap<>();
Better to use: Map<String, Object> map = new HashMap<>()
suggestion for (int i = start; i < length; i++) { characterBuffer.append(i); }
suggestion for (int i = start; i < length; i++) { characterBuffer.append(i]); }
suggestion for (int i = start; i < length; i++) { characterBuffer.append(i]);
I'd say this should be in the next line, so that if something is disabled it doesn't get monitored.
I'd say that this should be in the next line, so that if something is disabled it doesn't get monitored.
I'd say this should be in the next line, so that if someone uses it it doesn't get the right s.
this should be implementable
builder should be immutable
builder should be immutable here
Formatting
[minor] Remove redundant tab.
[optional] Remove this line, the "enable" method already checks if disabled
Since this block is used twice, perhaps pull it into a private method?
Same thought as in the other files: this condition is more like an API error and not a batch user.
Same thought as in the other files: this condition is more like an API error, so it should use a _valid_ executor_.
1. I would prefer to use Objects.equals over object equality, since we don't consider equals() method. The reason is that we can't handle nulls for two different strings, e.g., java @Override public boolean equals(Object obj) { return Objects.equals(obj, TypeAndTime.class) && Objects.equals(event, obj.time.equals(time)); }
1. I would prefer to use Objects.equals over object equality, since we don't consider equals() method. The reason is that we can't handle nulls for two different strings, e.g., java @Override public boolean equals(Object obj) { return this == obj; }
1. I would prefer to use Objects.equals over object equality, since we don't consider equals() method. The reason is that we can't handle nulls for two different strings, e.g., java.util.Objects.equals(Object, Object)
if this is false, we need to store it as false.
if this is false, we need to check for it.
if this is false, we need to store it as false
Why have you added these now?
Why have you removed the handleFailure from here?
Why don't you remove the handleFailure from the call?
How about logging the exception instead of just swallowing it?
How about logging the exception instead of just the message?
How about logging the exception instead of throwing it?
I feel like this should be private.
I feel like this should be private
I think this should return card.size();
nit: usually the name of this method is not "system_server"
this method is private, and only used in test methods
nit: usually the name of the method is not "system_server"
A great way to get this is to hide dependency from other outside of this class. Could be made private.
A great way to get this is to hide dependency from other outside. Make it public.
A great way to get this is to hide dependency from other outside. Make it public, and have your own method
Nice cleanup!
Nice cleanup, thanks!
THREAD-SAFETY You are missing the lock.
Missing final
Inverse order.
Missing null check on group.
here you must check value == BoundType.UpperBound && value < threshold
here you must check value == BoundType.UpperBound - value < threshold
here you must check value == BoundType.UpperBound && value < threshold.
instead of orc, 'transactional_properties', you can use if (acidTableKindToUse!= null) {
use orc instead of orc for consistency
use orc instead of orc for consistency.
This should be removed
This should be removed.
These 3 test cases could be removed
I would be more explicit about the builder pattern.
I would be more explicit about the builder pattern. Of course this is RowCommitted specific?
This class is optional and may be mis-assignably it should be optional.
you should not compare two Strings with "!=" or "!= ", but not both. Only one prefer == for the other.
you should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use equals method
you should not compare two strings
Sorry, I suppose I wasn't clear. I meant that using == below would mean this check for null 'eref' and returning an unexecutable command would then not be necessary and could be removed. The only case where this check is necessary is to return an unexecutable command.
Sorry, I suppose I wasn't clear. I meant that using == below would mean this check for null 'eref' and returning an unexecutable command would then not be necessary and could be removed. The only case where this null check should be removed is the check for null 'eref'.
Sorry, I suppose I wasn't clear. I meant that using == below would mean this check for null 'eref' and returning an unexecutable command would then not be necessary and could be removed. The only case where this would be null is when the child 'eref' is not found.
you don't need use replaceAll, because above you used normalizeJson
you don't need use replaceAll(), because above you used normalizeJson
you can use replaceAll, because above you used normalizeJson
method reference here as well -> anywhere we are calling a static method can be replaced by a method reference
method reference here as well -> anywhere we are calling a static method can be replaced by a method can be removed
method can be made private
I think this could be removed
I think this will be safe.
you can use the generic interface here
The toString() isn't a good idea. Needs to be a toString().
What is the reason for toString method?
The toString() isn't a good idea. Needs to be a null check.
List<String> temp = Arrays.asList(topics);
List<String> temp = new ArrayList<>();
LinkedList would be more efficient
This can be simplified to package private static PageViewAvroRecord buildPageViewRecord(PageView pageView) {
This can be simplified to: record.put(1, pageView.userId); if (pageView.pageId!= null) { record.put(2, pageView.pageId); } return record;
This can be simplified to: record.put(pageView.userId, pageView.userId);
@garydgregory Please use getAndSet(key) instead of this.directChannelProvider. lookupSharedChannel(name)
@garydgregory Please use getAndSet(key) instead of this.directChannelProvider.
@garydgregory Please use getAndSet(key) instead.
What's the point of this loop?
What does this log mean?
What does this loop do?
Please use interfaces where possible.
Please use interfaces when possible.
Please use interfaces.
@vmaletta issue.comments().post("Closed manually because of rebase mode");
@vmaletta there is a better way to do it like this: issue.setIssue(Issue.Smart issue, new Issue.Smart issue(this.github, xml).close(); issue.to();
@vmaletta issue.comments().post("Closed manually because of rebase mode", true), Closed manually
suggestion Vector<URL> urlList = new Vector<>();
Another non-checked exception. I don't think it's good practice to catch all exceptions from inside the method. At least please catch specific exceptions.
Another non-checked exception. I don't think it's necessary to catch Exception here.
This is never called with the NULL_ITEM_ERROR_MESSAGE branch, as equals() has been replaced by equals().
This is never called with the NULL_ITEM_ERROR_MESSAGE branch, as equals() has been replaced by equals(), so it cannot be null.
This is never called with the NULL_ITEM_ERROR_MESSAGE branch, as equals() has been replaced by equals(), so it must be removed.
@vilchik-elena Why not @Nullable?
@vilchik-elena Why not @NotNull?
this assert may not be needed
Static import
Static import?
Static import.
I guess this could be shortened to final byte[] array = new byte[256]; int getUnusedByte(final byte b) {
style nit: we don't use final for local variables.
style nit: we don't use curly braces around single line blocks
return streamConsumer.get(stream)
return streamConsumer.get(stream) is null? null : streamConsumer.get(stream)
return streamConsumerConsumer.get(stream)
this method should be private as it is only used by trace.getAnalysisModules()
you can use TmfTrace.getAnalysisModules() instead of the cast below
you can use trace.getAnalysisModules() here too
as with the others, need to "remember" the first via, not the last.
as with the others, need to "remember" the first via, not the last, right?
as with the others, need to "remember", the first via, not the last.
it's a good idea to remove this catch block and rethrow it as a Throwable
it's a good idea to remove this catch block and rethrow it as a specific exception
it's makes sense to remove this catch block
all these methods can be private
all these methods can be private?
all these methods can be private.
@bxf12315 missing a check to see if the value is null, but I never understand this test case.
@bxf12315 missing a null check on ref.get() here.
@bxf12315 missing. description and test the value as well
I don't think that DSL.using(conn).createTableIfNotExists(FILE_COUNT_BY_SIE_TABLE_NAME) is needed here.
I don't think that DSL.using(conn).createTableIfNotExists(FILE_COUNT_BY_SIE_TABLE_NAME) is needed here. Can you please explain why don't make it so minimal as to what is done here?
I don't think that DSL.using(conn).createTableIfNotExists(FILE_COUNT_BY_SIE_TABLE_NAME) is necessary.
duplicate regex as above, can we reuse it?
duplicate regex as above, can we reuse it
duplicate regex as above?
Not sure if this is good. It looks like mLocked is set to me
Not sure if this is good. It looks like mLocked is set to boolean anyway.
I think this should be synchronized.
You're not doing this. Sample here.
You're not using this anymore, as you're now doing the same thing by one above.
You're not using this anymore, as you're now doing the same thing twice.
Are we sure that we don't put all the constructions in the layout?
Are we sure that we don't put all the constructions in the layout file?
Are we sure that we don't use all custom letters in the View before setting the type?
Since it's hard to read, consider this method returning an Optional<SchoolClass>, and set that to the return value.
Since it's hard to read, consider this method returning an Optional<SchoolClass>, and save a couple of lines.
Since it's hard to read, consider this method returning an Optional<SchoolClass>, and pass it to SchoolClass methods.
This should be replaced by a method to invoke the CookieStore, even if the cookieSpec is set to false.
This should be replaced by a method to invoke the CookieStore, instead of creating a noop implementation. And then we never have to call CookieStore.
This should be replaced by a method that accepts a boolean, not a parameter.
Maybe add count as an argument to StateSerializer?
Maybe an add to the map as well?
Maybe an add to the map?
is this really needed? If it's absent, it's always invalid.
I think it's better to fix the negation of isValidV6Address here.
ofNullable should be enough here.
This can be replaced with <LINK_0>
Not sure if this can be replaced with <LINK_0>
Not sure if this can be replaced with <LINK_0>?
This could just be new ArrayList<Locale>(request.getLocales()))
This could just be new ArrayList<>()
This line and the next could be removed.
Should we just return the references in this method? There is no need to introduce an integration test.
Should we just return the references in this method? There is no need to introduce a variable for it
Should we just return the references in this method? There is no need to introduce a variable for it.
This should be Block.class
This should be a Type.
I'm not sure this should be public. It's a generic interface.
You'll want to move this up here and remove the actionHelper call in that method.
You'll want to move this up here...
You'll want to move this to the actionHelper
Don't use Optional, instead.
Don't use an Optional here, since there is no other callers of ExportConfiguration or ExportConfiguration.
Don't use an Optional here, since it's present in the form and this could be null.
add null check
can this be checkState?
add null checks
Should be public, same for the other constructor.
Should be public, I guess.
Should be public, or at least package protected.
user will definitely not need it, it is quite internal exception, which we could track in the logs
user will definitely not need it, it is quite internal exception which we could track in the logs
user will definitely not need it, it is quite internal exception, which we could track in the log
suggestion if (enabledFeatures == null || parent!= null) { return enabledFeatures; }
suggestion if (enabledFeatures == null) { enabledFeatures = true; return parent.getEnabledFeatures(); }
suggestion if (enabledFeatures == null) { enabledFeatures = true; return parent!= null; }
Please put the { (bracket) in the same line.
please put the { (bracket) in the same line.
Please put the { (bracket) in the else clause.
please add call to populate: Users(user)
please add links as well
please add links to the outside scope of the patch
If this method will be called in client.getAllSources() then the variable will not be null.
If this method will be called in client.getAllSources() for every sourceExtractIteration it will not be true.
If this method will be called in client.getAllSources() for every sourceExtractIteration it will not be called upon construction.
if (req == null)
java IllegalArgumentException
if (req!= null)
enforce immutability
enforce immutability.
Unneeded and redundant
we can replace that with findAny/findFirst as we don't really need to know those vms
we can replace that with: return runningVm.map(vm ->!vm.isExternalVm()).findFirst().orElse(false);
we can replace that with findAny()
We don't include the underscores in the field names.
We don't include underscores in the field names.
We don't include non-null keys in toString().
This will throw NullPointerException if type is not an ParameterizedType
This will throw NullPointerException if type is not a ParameterizedType
Does it look like this is _unused_?
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_2>](<LINK_1>
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of return of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
use ShellMenuItem.makeUp() instead of new RegexMatcher("OK")
use ShellMenuItem.makeUp() instead of.click()
use ShellMenuItem.DEFAULT_TIMEOUT
Should we create a descriptive constant for the above check?
Should we create a constant for this?
Should we create a descriptive constant for this?
This should use the bitwise inclusive OR.
This should use the bitwise inclusive OR operator.
This should use the bitwise inclusive OR operator
Shall we change this to "Unable to resolve the hostname of the....". there are few other places as well with same error message.
Shall we change this to "Unable to resolve the hostname of the....". there are many other places as well with same error message.
Shall we change this to "Unable to resolve the hostname of the...."?
Make ejectLocation a '-i'
both EjectLocation and ejectLocation are both optional
both ejectLabel and ejectLocation are available
How about using a Deque instead?
Maybe add a dash before this line to make it more readable?
Don't use sv as a member variable, it will be more descriptive.
Please use uppercase 'final'.
Please use uppercase 'final' instead of inline.
Please use uppercase for the first letter.
I would make this protected and mark as @Deprecated from the public API
I would make this protected and mark as @Deprecated from the constructor
I would make this property a constant.
We should do this the same way as we did with the other evaluate method
We should do this the same way as the other evaluate method
We need to do this as well.
The indentation looks like it should be a space.
The indentation appears to be a bit confusing.
The indentation appears to be a bit wrong here.
It's probably more convenient to use rometheus stable.
It's probably more convenient to use rometheusMetricsTracker.
It is convenient to use a lambda for this.
This method is throwing an exception. It means that the encoder has to be decoding a certain file. It may cause the buffer to be _really_ unacceptable by the user.
This method is throwing an exception. It means that the encoder can't convert the bytes to a byte array or it is in the byte array.
This method is throwing an exception. It means that the encoder has to be decoding a certain file. It may cause the buffer to be _really_ unacceptable, but it could only return a byte array.
We don't need to have this, h.execute already returns a map and if we add elements to it, we can just add it to the map.
Don't hesitate to create custom assertXXX methods to reduce readability.
We don't need to have this, h.execute already returns a map with given name.
Doesn't this have a NPE?
Doesn't this have to be public?
Doesn't this have a side effect?
Typo here. should be service_type
Typo here. should be service_id
Typo.. should be service_type
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to take the value and expose a setter so that it can be overloaded, can we do that too?
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so that it can be overloaded, can we do that too?
Isn't it good to put this into its own method somehow?
nit: Since it's not a test, I think below test belongs to: java Assertion.assertTrue(MCFooter.isMcfooterPresent());
nit: Since it's not a test, I think below test should be more interesting: java Assertion.assertTrue(MCFooter.isMcfooterPresent());
nit: Since it's not a test, I think below test belongs to: Assertion.assertTrue(MCFooter.isMcfooterPresent());
null?
null check
null check?
i think this is wrong. You're returning a null object, not an empty string. We don't want to handle this case.
i think this is wrong. You're returning a null object, not an empty string.
i think this is wrong. You're returning the value each time you call.toLowerCase, not the case.
Style-nit: We prefer using equals for enums.
Style-nit: We prefer using equals instead of ==
Style-nit: We prefer equals instead of ==
always have a -Dx=\"foo bar\" -version" Or, even better, using -Dx=\"foo bar" and -version isn't a valid version
always have a -Dx=\"foo bar\" -version" Or, even better, using -Dx=\"foo bar\version instead of -version
always have a -Dx=\"foo bar\" -version" Or, even better, using -Dx=\"foo bar\" -version instead of -version
Fail the test, if this is not what you want.
Fail the test to prevent this from happening.
Fail the test, since this is what's going to happen.
We need to propagate exception here and return error so we can propagate the exception
We need to propagate exception handling here
We need to propagate exception here and throw it up.
nit: since we're using this to be a fluent API, could we please change the signature to use the other overload? e.g. java this(httpProtocolHandler, null);
nit: since we're using this to be a fluent API, could we please change the signature to use the other overload?
nit: since we're using this to be a fluent API, could we please change this to use the other overload?
[ ] [<LINK_0>
[Iterables](<LINK_0>
[Iterables](<LINK_0> can be used here
Do we need to change this to a string constant? Seems like it should be a constant.
Seems like this should be externalized, I think.
Do we need to change this to a string constant? Seems like it should be a constant that could be mutated.
Could this method be static?
Could this be a try-with-resources statement?
Could this try-with-resources be used here?
why?
pass in CacheEntryCreated directly
you can inline filterAnnotations
Suggest to move this code to a separate method
Suggest to remove this code.
Suggest to move this code to a separate class
Since this is a class field, we can use this.breakToolbarFactory.setShowIgnoreFilesButtons(showButtons);
Since this is a "this" method, and the other method has a side effect too, we should use this instead: this.breakToolbarFactory.setShowIgnoreFilesButtons(showButtons);
Since this is a class field, we can use this.breakToolbarFactory.setShowIgnoreFilesButtons(showButtons); instead in order to avoid the need for the visibility of showButtons.
Is it possible to use lambda here?
Is this change necessary?
Is it possible to use Collections.unmodifiableList() here?
Just do getView(event).refresh(); to prevent nulls.
Just do setCancelable(false) here. Otherwise the group will be really ignored.
Just do getActiveShell(event).refresh()
this can be null
this can be null at some point
this is already disposed
Can we use the getter instead of the fields?
Can we use the getter instead of the fields directly?
can use the getter instead
This sounds like a public API, not a blocker.
This sounds like a public API, no?
This sounds like a public API, not a "class".
I think that the call to addProperty("uuid") is redundant.
I think that the call to addProperty("uuid") is not needed.
remove the check of propertiesToCreate if it is not null
Should be ssh://user:password@localhost
Should be ssh://user:password@localhost.
Should be ssh://user:password@localhost,
This isn't the correct method to call, it needs to be synchronized and only the setter methods.
This isn't the correct method to call, it needs to be synchronized
This isn't the same as the old one, only public constructor
Possible NullPointerException.
Possible NPE.
Possible NullPointerExceptions.
return workflowManager.listUserWorkflows().stream().map(WorkflowStateDto::new).collect(Collectors.toList());
return workflowManager.listUserWorkflows().stream().map(WorkflowStateDto::new).collect(Collectors.toList()));
return workflowManager.listUserWorkflows().stream().map(WorkflowStateDto::new).collect(toList());
Why not use a static import here?
Why not use here a static import?
Why not use a newExpressionProperties(schema)?
This appendHtmlConstant("<td>").appendHtmlConstant(this.node).appendHtmlConstant("<td>").appendHtmlConstant(this.node).appendHtmlConstant(td>").append(this.start.toString()).appendHtmlConstant("</td>").appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant("</td>").appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this
This appendHtmlConstant("<td>").appendHtmlConstant(this.node).appendHtmlConstant("<td>").appendHtmlConstant(this.node).appendHtmlConstant(td>").append(this.start.toString()).appendHtmlConstant("</td>").appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant("</td>").appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start
This appendHtmlConstant("<td>").appendHtmlConstant(this.node).appendHtmlConstant("<td>").appendHtmlConstant(this.node).appendHtmlConstant(td>").append(this.start.toString()).appendHtmlConstant("</td>").appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant("</td>").appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start.toString()).appendHtmlConstant(td>).append(this.start
public Date getStartDate() { startDate = startDate; }
Why public Date getStartDate()?
Why public instead of protected?
Please use Paths.get(directory) instead of doing.startsWith
Can you add a check that there is exactly one file?
Can you add a second check that checks hasNext?
if credentials is not available, then execute push fails
if credentials is not available, then execute push fails, not execute push
if credentials is not available, then execute push fails?
@Override should not be public.
@Override should not be public
@Override is not required
Would it be more readable to do a select query here?
Would it be more readable to generate a "select CONCAT(select text, x(y))" and then select all the key and then select one?
Would it be more readable to generate a "select CONCAT(select text, x(y))" and then select all the key and then select one that comes back?
Should this be WARN or INFO?
Should this be WARN or error?
Should this be WARN or debug?
Change the name of the parameter to something like "}"
name() returns a list of strings.
Change the name of the parameter to java?
c is probably not equal to c. If it is equal to c you might want to check this in the update method.
c is already UNKNOWN. might be better to have a racing condition here.
c is probably not equal to c. If it is equal to c you might want to check this in the update method. (and a different method about the update logic).
what about!selection.isEmpty()?
what about!selection.isEmpty() && selection.getHeadElement() instanceof HasFile
this can return null at this point
those two methods should be private
These two methods should be private
those two methods should be static
1. You can use FirebaseExceptionUtils.createAndThrow() instead of getProcessor().process(exchange) 2. do we need all this check in single place?
1. You can use FirebaseExceptionUtils.createAndThrow() instead of getProcessor().process(exchange) 2. do we need all this checks in single place?
:thinking:
please check the point.
please check the point is actually set
please check the size of the stream
Couldn't we get rid of this?
Couldn't we make this method private?
Formatting.
I'm missing the call to provision below. :(
I'm missing the call to provision below
I'm missing the call to provision below. :D
Could you please elaborate on why this is necessary?
consider to use an enhanced for loop here
Could you please elaborate on why this is needed?
There is no need for this check in this case - second condition is enough
There is no need for null checking in this case - second condition is enough
There is no need for this check in this case - second condition is redundant
seems like it can be more useful to return false instead of getMessage?
maybe it can be improved in order to have more info?
seems like it can be more useful to catch the Error instead
We probably should have the Guava's Objects.equals() method.
We probably should have the Guava's Objects.getName() method, so we can get rid of the equals() method.
We probably should have the Guava's Objects.getName() method.
I guess this :wink:
:thinking:
I guess this :P
nit: s/null/null/
nit: s/have/really/
nit: > checkArgument(max < limit, "Number must be positive");
Why would the 'buckets' be supported by the server? If yes, it's better to define it as 'testName' or 'testType'
Why would the 'buckets' be supported by the server? If yes, it's better to define it as 'testName' or 'testType'.
Why would the 'buckets' be supported by the server? If yes, it's better to define it as 'testType' or 'testType'.
Couldn't we just check that quality is not null?
Missing {... }
Missing braces
this log message is too low-level. Maybe DEBUG?
this log message is too low-level. Maybe DEBUG? What do you think?
this log message is overweight. Maybe publisher-level?
@Happy-Neko Same here, use u == Use.X30.
@Happy-Neko I'd suggest inverting this and returning the condition at the top.
@Happy-Neko I'd suggest inverting this into an if statement.
Remove the assertTrue?
Remove the InterruptedException.
Remove the waitFor
Style-nit: No need to explicit close the builder.
Style-nit: No need to inserter.flush()
prevEdit.close()
If value is not number, just return (value.count.intValue() > 0)? value : null
If value is not number, just return (value.count.intValue() > 0).
If value.count.intValue() > 0?
please change log level to debug
Please change log level to debug
This seems to be WARN in the code, since the index is used in the allObisCodes. So, please change it to debug.
suggestion if (value == ombieTypes.VILLAGER) return false;
suggestion return Objects.equals(value, ombieTypes.VILLAGER)
Should be ombieUtils.toNative
not sure why this one needs to be public?
set a flag here so you don't get the rule?
not sure why this one needs to be public
what does getFieldReference do?
what if element is null?
what does getFieldReference do here?
if not null, make this a default and make it final
wait, for possible race?
if not null, make this a constant
Seems to change from ConfigRenderOptions to ConfigRenderOptions.concise()
Seems to leave systemProperties() in that case.
Seems to leave systemProperties() in this case. One line below is not needed.
quayanders => quayandgitlab
quayanders => quayandandgitlab
quayanders => quayanders
I would extract "globals" to a constant, I am not sure what this condition is trying to achieve.
I would extract "globals" to a constant, in order to avoid unnecessary string comparison.
I would extract "globals" to a constant, I am not sure what this condition is.
same here, move this to the top.
this..trace.
this.
This should be static.
This should be static. There's no reason for that.
This should probably be static.
minor: can be final
minor: you can rename this to shouldNotHaveFailed(future).
minor: I think this can be simplified
Recently, @yingsu00 removed all of the uses of the related form of getUnsetBits to not have an Bits instance. Her change, and in some cases increased performance. I suggest we use the pattern she introduced in this new code.
How about the following? java public void getSetBits(int batchSize, boolean[] vector) throws IOException {
Bits should be set on the same line.
Is this really useful to have a name for the job? I'm not very familiar with the language.
Is this really useful to have a name for the job? I'm imagining the use of the language.
Is this really useful to have a name for the job? I'm imagining the use of a Job.
There's no reason to keep the defaultDelay in the constructor. We should avoid defaultDelay in the constructor.
There's no reason to override this method, which is the default method which can be overridden by subclasses.
There's no reason to keep the defaultDelay in the constructor. We should avoid defaultDelay in the code because the setter implies that.
shouldn't this be synchronized as well?
It should be possible to add a lock-lock for this.cached.
It should be possible to use this.cached.lock().
There's no need to qualify the field here, since it's used only once.
There's no need to make this public, since it's only used in the master branch.
There's no need to qualify the field here, either use it or set directly.
Too many spaces here, please.
Too much whitespace here, please.
Use computeIfAbsent to replace x.
Use with Preconditions.checkArgument
Use symbolicValueFactory.getOrEmpty()
Use Preconditions.checkArgument
should be OseeCoreException
i think this should be OseeCoreException
consider adding a logger.error message to the exception
This change is not really necessary. computeIfAbsent will remove it at all.
This change is not necessary. computeIfAbsent will already map the attribute if value changes.
This change is not necessary. computeIfAbsent will already map the attribute if the extension changes.
I'm not a big fan of this one. The only reason we need to do it is to have a protected method. Can't we just call it withNoCache?
I'm not a big fan of this one. The only reason we need to do it is to have a protected method, and can be overridden in sub-classes.
I'm not a big fan of this one. The only reason I see is that you can't use the primitive type.
I would remove the extra parentheses here.
I would use the logger format of this class.
I would use the logger format of this method.
You don't need a transaction here
You don't need to lock the DB here
You don't need to lock the entity here
nit: use string concat instead of format string
nit: use of "exist" and "cannot"
nit: use of "exist" and "partition"
put(key, value) should be executed from within the future so it doesn't through right away.
put(key, value) should be executed from within the synchronized block.
put(key, value) should be executed within the synchronized block.
How about to use forEach in this class for conciseness?
How about using forEach?
How about to use forEach in a for-each loop?
you dont need to catch OseeCoreException here.
you dont need to add exception as the exception is thrown here.
you dont need to add exception as the exception exception
I think we should log the exception. ("Unable to load class " + className, ex)
I think we should log the exception here.
I think we should log the exception. Exception.
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of the url.
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of string.
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of how to use it.
This method is a little long, but I think it could be less efficient to use Objects.hash(listDelimiter, columns, findColumnsFromHeader, skipHeaderRows);
This method is a little long, but I think it could be less efficient to do Longs.hashCode(listDelimiter);
This method is a little long, but I think it could be less efficient to do away with the hashCode() and use the primitive #hashCode() method.
why not replace it with the constant?
why not replace it with the constant /index.zip?
Wow, this was probably my fault - but why not replace it with the code that pre-runs?
return is not null?
return is not null??
return a boolean?
The check for null can be removed, as it's not used anywhere else.
The check for null can be removed, as it's not used by the Viewpoint view.
The check for null here could be removed, as it's not used anywhere else.
Looks like we do not need method 'isSignatureBridge'.
Looks like we do not need method 'isSignature'.
Looks like we do not need to check entire method signature.
I think DIST or DIST?
I think DIST or DIST, should be ||
I think DIST or DIST, should be "false"
This method is only used in tests, please remove it
This method is only used in tests, please keep it as private.
This method is only used in tests, please remove it.
Same as above, why not use try with resources?
Can you use try with resources here?
Can you use try with resources?
I think this can be removed if we don't use the Java 8 String formats
I think this can be removed if you test this.
I think this can be removed
<code>return new Api(this);</code> and <code>return null</code>.
:bug: Should use hudson.security.ACL.ADMINISTER
Does this check need to be nonNull?
nit: you can remove the if...
nit: you can remove the if here as you do not know.
nit: you can remove the if before return.
@fanifieiev the same above.
@fanifieiev You can declare it static
can it be final?
Error message should be updated as well
Error message should be changed as well.
Error message should be updated as well.
The code of the CompositeReconcilerStrategy constructor should be used here, and in case there's only a single reconciler strategy, it should be returned directly.
The logic of the CompositeReconcilerStrategy constructor should be used here, and in case there's only a single reconciler strategy, it should be returned directly.
The code of the CompositeReconcilerStrategy constructor should be used here, and in case there's only a single reconciler strategy, it would be better to create the CompositeReconcilerStrategy constructor to be used here.
If you change this test to be using @Test annotation, then please also remove this one.
If you change this test to be using @Test annotation, then please also remove the @Test annotation from this one.
If you change this test to be using @Test annotation, then please also remove the @Test annotation from this test.
I'm not sure silent catch is good as after that url is null and it will create exceptions
I'm not sure silent catch is good as after that url is null but url doesn't have url
I'm not sure silent catch is good as after that url is null and it will create exception
order of operands
call adapterDecl.getAdapterFB()
call AdapterDeclaration#addAdapterDeclaration
This check is not necessary as the navigatePreviousComponent() method does nothing for you.
This check is not necessary as the navigatePreviousComponent() method does not work as expected
This check is not necessary as the navigatePreviousComponent() method does not work as expected.
You can get the status of the snapshot for the snapshot.
You can get the status of the snapshot for the snapshot which will be 'empty', and throw an exception if it is not OK.
You can get the status of the snapshot for a snapshot which will be versed by calling snap.getStatus() on it.
Do we need to check for null? equals may throw NPE?
Do we need to check that other.getClass() is not null here?
throw exception?
throws
nit: throws
nit: throws...
I don't think this is correct. If weakReferencesTolocks.keySet().contains(lockKey) returns null this will return null.
I don't think this is correct. If weakReferencesTolocks.keySet().contains(lockKey) returns null this will return a null reference to the lockKey.
I don't think that's safe. If weakReferencesTolocks.keySet().contains(lockKey) returns null, then you'll have to remove the synchronized.
if (buttonEvent.getButton() == null)?
if (buttonEvent.getRemote() == null)
if (buttonEvent.getButton() == null)
else statement is redundant
add braces
add { } around if body
consider moving both checks to the top of the class, so that we keep the tests shorter and avoid the duplication
consider moving both checks to the top of the class, so that the file set has the same behavior.
consider moving both checks to the top of the class, so that the file set in the left side is the same
This is check in the overriden enqueue method. I think this check is extra here.
This is checked in the overriden enqueue method. I think this check is extra here.
This check is extra
Why do you want to check for null here? I think it should be java if (location == null) { synchronized(this) { allLocations.add(location); } }
Why do you want to check for null here? I think it should be java if (location == null) { allLocations.add(location); }
Why do you want to check for null here? Also, I think you should annotate the fields as @NonNull
findinpage_enabled => findinpage_enabled
These strings should be in constants.
findinpage_enabled should be on page
this temp variable is redundant
this temp variable seems unnecessary
check
I think you also need to override toString() method of the base class
I think you also need to override toString() method
I think you also need to override toString() method that takes a String
Please use lowercase as it refers to the argument: disposables is null.
Please use lowercase as it refers to the argument: disposables is null
Please use lowercase as it refers to the argument: disposables is null"
Do we really need the full path for vcr.cluster.name? vcr.ssl.port=vcr.ssl.port?
Do we really need the full path for vcr.ssl.port? Can we just use getProperty("vcr.ssl.port", "")?
Do we really need the full path for vcr.ssl.port? Can we just use getProperty("vcr.ssl.port", null)?
Please close the stream.
Please use try-with-resources syntax.
Please use try with resources.
should this have a, to match the rest of the string?
should this have a, to match the rest of the pattern?
should this have a, to match the rest of the string? Otherwise, you're going to output the toString() on the first line.
Maybe you should synchronize on the entityStore here.
You need to do the clear() after the entity was removed.
You need to do the clear() after the entity removal.
entryId is not used, please remove
you can use parameterized logging, no?
you can use parameterized logging here
Fix the typo here?
Fix typo
Fix the typo here
Method name is sad since you are calling setContext here. I would prefer to use setContext() instead of accessing accessing accessing SecurityContextHolder.
Method name is sad
Method name is'static'.
"secrets" --> "secrets"
"secrets" instead of "secrets"
"secrets" instead of "secrets"?
here too, not sure if those are contained in your URL, but I'd suggest to keep them as static to reduce the problem.
here too, not sure if those are contained in your URL, but I'd suggest to keep lines 220 and 220.
You can add the attribute to applications service and port too.
Wouldn't it be better to use Devfile.AvoidName() instead? Devfile.JAVA_MAVEN, ws, Collections.emptyList() is simpler
@ivandalbosco I'd use the constant defined in a class name instead of ws
@ivandalbosco I'd use the constant defined in a class name instead of an EOL
subscribe and print the response status
subscribe maybe?
subscribe and print the response value
I think we should still be able to hide the DocksWhenHidden state before the enableDataModelerDocksWhenIsHidden.
I think we should still be able to hide the DocksWhenHidden state when the user clicks on the reaper. But there's no other prevents from editing.
I think we should still be able to hide the DocksWhenHidden state before the enableDataModelerDocksWhenIsHidden
You should probably check whether the i18n access is allowed in this case.
You should probably check whether the i18n access is allowed in this method.
You should check that the i18n delete has a field.
Not sure if it's a good idea to pass null for the contentSearcher to the builder. Why not just pass it in the first place?
Not sure if it's a good idea to pass null for the contentSearcher to the builder, but so it seems like it's returning a single value.
Why this change?
please use "SeleniumWebDriverHelper#waitSuccessCondition" method: seleniumWebDriverHelper.waitSuccessCondition(driver -> { return new WebDriverWait(seleniumWebDriver, LOAD_PAGE_TIMEOUT_SEC); }, LOAD_PAGE_TIMEOUT_SEC); }
please use "SeleniumWebDriverHelper#waitInFilesNames"
please use "SeleniumWebDriverHelper#waitSuccessCondition"
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void getTokenShouldReturnToken() { BitreserveClient bitreserveClient = new BitreserveClient("foobar"); Assert.assertEquals(bitreserveClient.getToken(), "foobar"); }
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void getTokenShouldReturnToken() { final BitreserveClient bitreserveClient = new BitreserveClient("foobar"); Assert.assertEquals(bitreserveClient.getToken(), "foobar"); }
Since the client doesn't matter anymore, I'd use a captor for this
Why do we need to pass this here? I think the setTitle should call the other with the setText method.
Why do we need to pass this here? This class is only used in a few places.
Why do we need these lines?
for ease of reading can you extract refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName()) as a final variable?
for ease of reading can you extract refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName()) as a local variable?
for ease of reading can you extract refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName()) as a final variable? (and same for calculateUq)
you do not need to specify param here
you're not testing anything here, but please, use Tv.TEN instead
you're not testing anything here, but please, use Tv.THREE
can you please rename this method to isImagesAlreadyOnTarget()
can you please rename this method to isImagesAlreadyOnTarget(), so that you can get the instance once with isImagesAlreadyOnTarget()?
can you please rename this method to isImagesAlreadyOnTarget(), so that you can get the instance once with isImagesAlreadyOnTarget()
Change it to a constant?
We can remove getClientCache() here and add it to clientCache() method.
We can remove getClientCache() here.
Unnecessary string concats
Helper methods should not be public
Helper methods in Inlaat api
This simply isn't a property of START_SCHEMA; i.e. the alternative is to have an array of RelationWriteMetadata in this case: java Map<RelationKey, RelationWriteMetadata> map = new HashMap<>(); map.put(sampleRelationKey, new RelationWriteMetadata(sampleRelationKey, COUNT_SCHEMA, true, true)); map.put(countRelationKey, new RelationWriteMetadata(countRelationKey, COUNT_SCHEMA, true, true)); return map; You can remove the above code completely, and it would be just as simple as: Map<RelationKey, RelationWriteMetadata> map = new HashMap<>(); map.put(sampleRelationKey, new RelationWriteMetadata(countRelationKey, COUNT_SCHEMA, true, true));
This simply isn't a property of START_SCHEMA; i.e. the alternative is to have an array of RelationWriteMetadata in this case: java Map<RelationKey, RelationWriteMetadata> map = new HashMap<>(); map.put(sampleRelationKey, new RelationWriteMetadata(sampleRelationKey, COUNT_SCHEMA, true, true)); map.put(countRelationKey, new RelationWriteMetadata(countRelationKey, COUNT_SCHEMA, true, true)); return map; If you go for the other map, you can remove the array initialization.
This simply isn't a property of START_SCHEMA; i.e. the alternative is to have an array of RelationWriteMetadata in this case: java Map<RelationKey, RelationWriteMetadata> map = new HashMap<>(); map.put(sampleRelationKey, new RelationWriteMetadata(sampleRelationKey, COUNT_SCHEMA, true, true)); return map; Which means you can remove the declaration and initialization.
Why is the check required here? Shouldn't the databindingServiceReference be removed?
Why is the check required here? Shouldn't the service be removed?
Why is the check required here? Shouldn't the databindingServiceReference be removed too?
This does not seem to be debugging code.
This does not seem to be Line too
Please add to Shretion!
This is a good idea. The logic that checks the status of the upload isn't entirely visible. The best way to do it is to add the new state.
This is a good idea. The logic that checks the status of the upload isn't entirely visible so we are setting it to completed.
This is a good idea. The logic that checks the status of the upload isn't valid.
Here you should be creating a new instance of experimentTaskResultRowMapper where you have several of the same parameters.
Not necessary to have this method in a private class.
Not necessary to have this method in a class.
You shouldn't expose AbstractTest in the interface similar to how it's done in timbuctoo-instancev4/src/main/java/nl/knaw/huygens/timbuctoo/security/dto/Login.java
You shouldn't expose AbstractTest in the interface similar to how it's done in timbuctoo-instancev4/src/main/java/nl/knaw/huygens/timbuctoo/security/src/main/java/nl/knaw/huygens/timbuctoo/security/dto/Login.java
You shouldn't expose AbstractTest. Instead it's better to add a static method in AbstractTest similar to how it's done in timbuctoo-instancev4/src/main/java/nl/knaw/huygens/timbuctoo/security/dto/Login.java
Are we really need to do this if we have the default value?
Are we sure we need to do the same value here? This solution is probably not good.
Are we sure we need to do this in the presenter? I think we should use it to ask the connect handler, no?
I know this is an existing code, but this will cause an unnecessary call to the method to do this. For example: if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) { if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) { if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) { return; } Uri uri = intent.getData(); if (intent.getAction()!= null) { handleDeeplink(uri); } if (uri!= null) { handleDeeplink(uri); } }
I know this is an existing code, but this will cause an unnecessary call to the method to do this. For example: if (intent.getAction() == Intent.ACTION_VIEW) {... }
I know this is an existing code, but this will cause an NPE. Instead, can we check for null?
s/DbFacade.getInstance().getClusterDao()/clusterId
s/DbFacade.getInstance().getClusterDao()/getClusterDao
s/clusterId/clusterId
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one every time
Shouldn't this be a field so we don'T have to create one each time
GENERAL_ERROR_CHANNEL_ID, not the R.string.notification_site_creation_id
GENERAL_ERROR_CHANNEL_ID, not the R.string.notification_site_creation_id.
GENERAL_ERROR_CHANNEL_ID, not the R.string.notification_site_creation_state.
I think we should have package visibility now.
I think we should have an interface for the two setTitle methods, just like setAttribute(String fileName, Metacard.TITLE, fileName);.
I think we should have an interface for the two setTitle methods, one with title and file name.
Should we return BigInteger.ERO here?
Should use BigInteger.ONE.shiftLeft() here.
Should use BigInteger.ONE.shiftLeft() instead.
This one too
This one too, it's the same behavior.
This one should be private.
I think we should not make this more readable by creating a variable for the lockInterruptibly() and re-throw the exception directly. That way we don't lose the lockInterruptibly() call.
I think we should not make this more readable by creating a variable for the lockInterruptibly() and re-throw the exception directly. That way we can remove the finally block.
I think we should not make this more readable by creating a variable for the lockInterruptibly() and re-throw the exception directly. That way we don't lose the lockInterruptibly() call and only needs to be synchronized on the method.
SkinnableCharonPortal.CONTACT_US_URL_SUFFIX is not the best choice here.
Typo, SkinnableCharonPortal.CONTACT_US_URL_SUFFIX is also used in the method below
Typo, SkinnableCharonPortal.CONTACT_US_URL_SUFFIX is also used in the method above.
I think that this will be wrong. It will be operators with standard memory format - hence no memory format - this is intended
I think that this will be wrong. It just makes addInput(Page page) method, no?
I think that this will be wrong. It just makes addInput(Page page)
what about moving this "else" block after line 156?
What about moving this "else" block after line 156?
what about moving this "else" around line 156?
It seems to me that it would be good to not allow to set the boolean to false here. Would be good to have something like: java public void stop() { if (this.reader!= null) { this.stoppedDueToParent.set(false); } else { throw new IllegalStateException("Waber stop"); } }
It seems to me that it would be good to utilize the [this.](<LINK_0> in the class.
It seems to me that it would be good to utilize the [this.](<LINK_0> in the ticket.
Can't we make it more general?
Can't we merge both of these?
Can't we make it final?
java return notSanitized(sanitizer.sanitize(value));
this. notSanitized(sanitizer.sanitize(value)); should be enough.
this. notSanitized(sanitizer.sanitize(value));
I think this should be final.
I think this should be final
I think this should be a break.
This whole method should be refactored to a new method that returns the correct event notification (ie. call updateConcurEventNotificationsForProcessing()).
This whole method should be refactored to a new method that returns the correct event notification (ie. call updateConcurEventNotificationsForProcessing() in the service's body).
This whole method should be refactored to a new method that returns the correct event notification rather than the contents of the event.
Could be improved to make this method a bit clearer : java if (nodeComponent.length < 1) { return; } else if (nodeComponent.length < 2) { resetDelay(root, vineComponent); }
Could be improved to make this an if-else.
Could be improved to not use the component's memory
why the change here?
why the default type?
why?
Can you move the transactionService.required() into the try block?
Can you move the transactionService.required() to the try block?
Can you revert the transactionService since it is not needed?
Please add at least of project in order to check that the result is empty because it return an empty list
Please add at least of project in order to check that the result is empty when it return an empty list
Please add at least of projects
Note that this method probably isn't the Class Class.getClassLoader().getResource(classFolder) is annotated with @ClassRule, therefore the method name should be removed and not needed.
Note that this method probably isn't the Class Class.getClassLoader().getResource(classFolder) is annotated with @ClassRule, therefore the method name should be loaded directly instead of Class.getClassLoader().getResource(classFolder).
Note that this method probably isn't the Class Class.getClassLoader().getResource(classFolder) is returning a File.
This is why you don't need the else here. The do you need the if block.
This is why you don't need the if block. The loop goes from the if block.
This is why you don't need the else here. The do you just compute the latest distance twice?
@bgeVam you do not need to set those to display in the database instead you should use the view to retrieve it
@bgeVam you do not need to change those to display name, you should be able to display else after the start method.
@bgeVam you do not need to change those to display name, you should be able to display else after the start method
The stack trace would be more helpful than just returning null?
The stack trace would be more helpful than just returning null here.
The implementation of this method is more readable than what's supposed to do.
intents.get( plugin ).getAndIncrement() == 0 is sufficient?
intents.get( plugin ).getAndIncrement() == 0 ) can be removed, or it's always 0
intents.get( plugin ).getAndIncrement() == 0 ) is sufficient, as it is always known to be positive.
trackers.computeIfAbsent(destination, k -> new MessageIdTracker(config));
trackers.computeIfAbsent(destination, k -> new MessageIdTracker(config))
what is the point of having this synchronized?
I think this would be better as: if (defaultMtu > IPV6_MIN_MTU) { defaultMtu = (defaultMtu > IPV6_MIN_MTU); }
I think this would be better as: if (defaultMtu > IPV6_MIN_MTU) { defaultMtu =  IPV6_MIN_MTU; }
I think this would be better as: if (defaultMtu > IPV6_MIN_MTU) { defaultMtu = IPV6_MIN_MTU; }
Would be nice to have a test for WITH without any parameters.
Would be nice to have a test for WITH without 'p1', and find a single schema (I also used for)
Would be nice to have a test for WITH without 'p1', and find a single schema (I also used for schema)
I would suggest returning this.jobName as well.
I am not sure whether this is required.
I am not sure whether we should be returning this.jobName as the value of this.getViewName() at all. Perhaps we should add a isDebugEnabled() check?
Why not get rid of this?
Why package private?
Why package protected?
This should be injected with the @Before keyword. Otherwise we could end up with a lot of overhead.
This should be injected with @Before and within the @After, not here.
This should be injected with @Before and within the @After, no need for a separate bean-level initialization.
Try to avoid the need for the null check here if we have null.
Try to avoid the need for the null check here.
Try to avoid nested checks.
Should we not be public?
Or we should not be public?
Or we should not be public
Should it be fine to move this.singleMetricFilters = singleMetricFilters; after this.
Should it be fine to move this.singleMetricFilters = singleMetricFilters. The Logic is not related to this PR.
Should it be fine to move this.singleMetricFilters = singleMetricFilters. The Builder pattern is not consistent with the pattern used in this class.
Redundant cast.
Redundant parentheses
Redundant parentheses.
We have org.apache.commons.lang3.StringUtils.isNotEmpty;
We have org.apache.commons.lang3.StringUtils.isNotEmpty; there's no need to check for null.
We have org.apache.commons.lang3.StringUtils.isNotEmpty; there's no need to check for null
Why public?
This method should be private
This method can be private
Exception again
Exception again?
Magic constant?
ObaStopRequest returns null when you're using the above line, so this could be: java log.debug("ObaStopRequest returned " + response);
ObaStopRequest returns null when you're using the above line, so this may not be an error.
ObaStopRequest?
What about adding a method for getting the default URLDecoder?
Is there a reason to check getRequestParameters()!= null, than to always return defaultValue?
What about adding a method like getRequestParameters().getStringParameter that does not require encoding?
What is the use of Preconditions.checkNotNull?
What is the use of Preconditions?
validate
uploadItem1 -> uploadItem1
uploadItem1 -> uploadItem1?
uploadItem1 is already defined in the line above.
@bdragan performance-wise I think it would be better to use a-z0-9] instead of "/"
@bdragan performance-wise I think it's better to use a-z0-9] instead of "/"
static import
remove tabs
remove useless parentheses
remove useless condition
looks like this doesn't dump the entire DatanodeDetails file. Should it be a.param for the second parameter?
looks like this doesn't dump the entire DatanodeDetails file. Should it be a.properties file?
nitpick: it's more idiomatic to have a name for this.
It might be better to add a "stop()" method in handleNewUpstreamIface, so that we don't have to call it twice (e.g. in handleNewUpstreamIface).
It might be better to add a "stop()" method in handleNewUpstreamIface, so that we don't have to call it twice (e.g. in handleNewUpstreamIface)
It might be better to add a "stop()" method in handleNewUpstreamIface, so that we don't have to call it multiple times.
This is wrong. When loadClass() returns null, this should throw NullPointerException. Exception should be thrown from loadPdx(String className) or throw new JdbcConnectorException( String.format("The name of the class \"" + className + "\" could not be loaded because " + ex) is null.");
This is wrong. When loadClass() returns null, this should throw NullPointerException. Exception should be thrown from loadPdx(String className) or throw new JdbcConnectorException.
This is wrong. When loadClass() returns null, this should throw NullPointerException. Exception should be thrown from loadPdx(String) or due to bad values.
The consumer key should be the consumer name, or Hypervisor
The consumer key should be the consumer name, or is this the consumer name?
The consumer key should be the consumer name, or Hypervisor.
If an exception is caught, should this be caught?
If an exception is thrown, should this be caught and handled?
If an exception is caught, should this be caught and handled?
Use TestPlatform.isBooleanPropertyTrue(System.getenv()) instead?
Use TestPlatform.isBooleanPropertyTrue(System.getenv()) instead.
A little better to use TestPlatform.isBooleanPropertyTrue(System.getenv()).
Can you pull this change into a private method?
Can you be consistent with the original coding style?
Can you be consistent with the naming?
Should be "./" at the end of this line, or put it in a constant.
Should be "./" at the end of this line, or put it in a constant?
Why 2 :?
don't need this.
don't need this. Just use the IF block
don't need this
Let's only use DsfDebugOptions... as mentioned above
Let's only use DsfDebugOptions.DEBUG_SESSION_MODEL_ADAPTERS to include the parameters.
Let's only use DsfDebugOptions... as mentioned above.
return APITypeManager.getAPITypeParameters();
return APITypeManager.getAPITypeParameters(); is useless
I don't think you need the try catch here
nit: remove(true)
remove(true)
nit: remove() call unnecessary
This should not call fragment.children(). It should return a String instead of a String
This should not call fragment.children(). It should return the name of the node.
This should not call fragment.children(). It should return a String instead of a String.
I think it should be return executeCommand.execute(action, resultCallback); else you lose the "good" DispatchRequest in the process.
I think you should add @Nullable to this method.
I think you should add @Override
Why does this need to be public?
Either remove synchronized or remove it.
Why do you need to check for null?
We could just return ignoreEventSet here
shall we just return ignoreEventSetKey here?
We could just return ignoreEventSet here, right?
ArgChecker is null, so no need to check it here.
Won't the tests throw a null, too?
ArgChecker is null, so no need to check
Can you remove the + in the log message?
Can you remove the + in the log statement?
Can you remove the +1 from the log statement?
+ ", can contain more than 1 replicas of same partition"
+ ", can contain more than 1 replicas of same partition"?
you can include more details in the message
you import ByteBuffer, no need to use the full package path
you import ByteBuffer, no need to use the full package name
you import ByteBuffer, no need for the full package path
java this(dependencyResolvers, dependencyResolvers);
java.util.Collections.unmodifiableList(dependencyResolvers)
java.util.Objects.requireNonNull(dependencyResolvers)
You could use MimeTypeUtils.getMimeTypeFromExtension(...).
You could use Collections.emptyList() here
You could use org.junit.Assert#assertNull instead
please just define on the next row.
please just define on the right side of the test
please just define on the value
You can replace this by: returnValue.getVdsError()!= null && returnValue.getVdsError()!= null
You can use instanceOf here
You're a simplification of the logic here, which is useless.
style nit: we don't use braces around single line blocks
style nit: we don't use curly braces around single line blocks
style nit: space after if
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during the git clone or other editor that changed the encoding. On my clone : <LINK_0>
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during Eclipse?
That statement should work, there's no need to modify the source here. If something is wrong maybe it'll fail.
Update the method signature to set the connection to null.
Update the method name to set the Bus connection
Update the method name to set the variable messageBusConnection.
please add IP address to the end of the string
pls use configuration to get the hostname and the value.
please add IP address to the end of the String
Maybe extract doesAccountGlobalHaveAccountRestrictionCodeAndNoSubFUndGroupCode() to isTheRestrictionCodeValidForEachAccount?
Maybe extract doesAccountGlobalHaveAccountRestrictionCodeAndNoSubFUndGroupCode() to a variable and use that variable in all the places?
Maybe cleaner to move this after the if condition to a private method
Why not String configFile param as it is not used in init()?
Why not have this method be private?
Why not have this method in the init method?
use an overridable getOperationTimeout() method instead
Use an overridable getOperationTimeout() method instead
Use an overridable getOperationTimeout() method instead.
create an overloaded setClientAuthenticationMethodAsString(String auth) and then use that.clientAuthenticationMethod.parse(auth)
create an overloaded setClientAuthenticationMethodAsString(String auth)
create an overloaded setClientAuthenticationMethodAsString(String auth) and then use this.clientAuthenticationMethod.parse(auth)
if(StringUtils.isNotEmpty(domainName)) {
if(StringUtils.isNotEmpty(domainName))
if(domainName.isEmpty()) {
Please add { and } in this method.
Please add { and }.
Please use brackets with if.
getClients(this, 0, cacheSession.getClientsCount(this))
getClients(this, 0, cacheSession.getClientsCount(this));
getClients(this, null, null)
This is not public
This should be package private
This should be package-private
This is hard to read. How about adding a static import for Optional<ColumnHandle> columnHandles = node.getOutputSymbols().stream().map(node -> nodeColumnHandles.containsAll(columns.get()));
This is hard to read. How about adding a static import for Optional<ColumnHandle>
This is hard to read. How about making it a static final constant?
Do you really want to throw an exception here?
Nextflow eventually, this should be non-null.
Revert this change?
Maybe we should add an Builder to the StringBuilder, this is cleaner and more robust.
Maybe we should add an Builder to the StringBuilder, this is cleaner and more efficient.
Maybe we should add an Builder to the StringBuilder?
Please use the FTimeFormatter. It's built into a dateTimeFormatter is useful for usage.
Please use the locale object here.
Please use Locale.ROOT
What is the purpose of this? It should be zero if we pass more than one element to the iterator. More over a value, we could use an anonymous class for this
What is the purpose of this? It should be zero if we pass more than one element to the list. In other words, if we use a zero-size iterator, we can skip the last element in the list.
What is the purpose of this? It should be zero if we pass more than one element to the iterator.
new QueryResult<>(uniqueStudies);
new QueryResult<>() is redundant here
new QueryResult<>(uniqueStudies) is redundant here
Does this change now?
Please use spaces here too.
Please use spaces here
So this is actually not needed anymore?
Why do we need to throw an exception here?
So this is actually not needed?
exception does not need to be caught.
exception does not need a log.
throws IOException
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within addToResponseBody()?
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() while you do other checks within addToResponseBody()?
Is addToResponseBody() being used from within any synchronization? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within addToResponseBody()?
use getEndTime instead of getExactlyOne().getValue
use getEndTime instead of getExactlyOne().getValue()
use getEndTime()
You already have a click on the list view, so you don't need to use it again.
You already have a listener for this, so you don't need to use it again.
You already have a click on the list view, so you don't need to use it here.
NIT: HostNetworkInterfaceBondedListViewItem. Same for HostNetworkInterfaceBondedListViewItem.
NIT: HostNetworkInterfaceBondedListViewItem.class. That way, the typecast could be inlined here.
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here
Two things here: - It's not a disposed map - you should not call in this method. The proper call to dispose() does nothing.
Two things here: - It's safe to call dispose twice - the synchronization on this map is not necessary, but there's no way to do it.
Two things here: - It's not a disposed map - you should not call in this method. The proper method is to get a lock on this map.
Style-nit: We don't use curly braces in new lines.
I don't see why you need to have a loop in this case.
I don't see why you need to use equals in that case.
Does the checks are not needed?
Does the checks are still needed?
Does the checks are always stopped if all fields are initialized?
nit: suggestion logger.info("Added table {}: {}", tableId);
I believe we should add a null check for config.getTableIds().size()
I believe we should add a null check for config.getTableIds().size() == 0
Lets use kernal.logRegistry()
Lets use kernal.exceptionRegistry()
Lets use kernal.context
This should probably be: return pemFile.isPresent() || Files.isReadable(path) && Files.isReadable(path));
This could be: return pemFile.isPresent() || Files.isReadable(path) || Files.isReadable(path));
This should probably be: return pemFile.isPresent() && Files.isReadable(path) && Files.isReadable(path));
Any reason why this can't be void?
Any reason why this return a void?
Can be void
Rather than using a static method here, we should probably do something like this: setAsString(.., connectionId).
Rather than using this method, we should probably just call this.setAsString(...).
Rather than using a static method here, we should probably do something like this: setAsString(.., connectionId);
nit: don't use Objects.requireNonNull(asyncClient, "'asyncClient' cannot be null.");
nit: don't use Objects.requireNonNull(asyncClient, "'operationTimeout' cannot be null.");
nit: don't use Objects.requireNonNull for such checks.
I understand this is just for testing but you're failing if host_key is not null. So maybe you want to set it to "server_host_key" instead?
I understand this is just for testing but you're failing if host_key is not null. So maybe you want to set this to "server_host_key" instead?
I understand this is just for testing but you're failing if host_key is not null. So maybe you want to set this to "server_host_key", and then if hostKeyChecking is not empty, it's false
why do we need a new ErrorCodeChecker here?
this test is kinda redundant, we could remove it.
this test is kinda redundant, we could remove it by people.
This should be a logger call.
I think this should be a logger.error() instead of printStackTrace()
I think this should be a logger call.
missing space after =
missing space after ","giving up casting
We should log the exception as well.
Just a test trick, it's better to use fail("Tree does not support SWT.MULTI, cannot make multiple selections.", e.getMessage())
Just a test trick, it's better to use fail("Tree does not support SWT.MULTI, cannot make multiple selections.", e);
Just a test trick, it's better to use fail("Tree does not support SWT.MULTI, cannot make multiple selections.", e.getMessage());
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return the status of #cachedVds?
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return the status of #cachedVds?
I see what you meant but that's a very confusing name since the collection holds VDSM events. I'd suggest something like: "Failed to process device for host '{}' - skipping VMs monitoring."
The identifier could have a symbol in it and be stored in a field.
The identifier could have a symbol in it and be returned to the toString() method.
The identifier could have a symbol in it and be returned to the toString().
please revert back this change and implement the required method.
please revert back this change and implement the required method, no need to do this here.
please revert back this change and implement the required method, no need to do this change anymore.
Can we add some kind of druid servers in the JdbcTable? And we don't want to introduce new tables for each table.
Can we add some kind of druid servers in the JdbcTable? And we don't want to introduce new tables.
Can we add some kind of druid table to the JdbcWraper constructor and use a RowType.toExternal() to avoid a big lambda
The parameter is not used.
'public' is not needed
'this' is not needed
Isn't it the normal way to do this, where you do this (as it is right now) with default value?
Isn't it the normal way to do this, where you do this (as it is right now) that this will work?
Isn't it the normal way to do this, where you do this (as it is right now) that this will create a new zoneId if it doesn't exist?
I am not sure if it should be a message whose type is to convert the message to a T. Can we keep the message so it is known?
I am not sure if it should be a WARN instead of a ERROR.
I am not sure if it should be a message whose type is to convert the message to a T. Can we keep the message so it is more meaningful?
unused this.operator?
unused this.operator
unused this.
nit: looks like this could be private?
nit: looks like this could be static
Potential NPE, check for null?
orientation == Configuration.ORIENTATION_LANDSCAPE? I am not sure this is the pattern that we are using Configuration.ORIENTATION_LANDSCAPE.
orientation == Configuration.ORIENTATION_LANDSCAPE? I am not sure this is the right place to use this.
orientation == Configuration.ORIENTATION_LANDSCAPE? I am not sure this is the right place to make this field public.
This is a little confusing to me - why don't you send a request that is an HTTP request?
This is a little confusing to me - why don't you send a request that is an HTTP server?
This is unnecessary, please remove.
This should be a if (disco.includesFeature(NAMESPACE)) no?
This should be a if (disco.includesFeature(NAMESPACE)), no?
If you want, this will not be a bug, right?
Why not initialize all of those fields at the declaration site? This @BeforeClass in my opinion doesn't add much value. (It would make sense if any of these constructors threw exceptions.)
Why not initialize all of those fields at the declaration site? This @BeforeClass in my opinion doesn't add much value. (It would make sense if any of these methods threw exceptions.)
Why not initialize all of those fields at the declaration site? This @BeforeClass in my opinion doesn't add much value.
Please fix that
Please fix the indentation.
Please fix the typo here.
replace with: Mono.when()
replace with: Mono.when().then()
replace with: Mono.when() Also, why not peek()?
Wouldn't be better to do: java return IntegrationTestInitService.getInstance();
Wouldn't it be better to do: java return new IntegrationTestInitService();
Wouldn't a IntegrationTestInitService be better?
This line should be changed to the following: java if (log.logError() == null) { log.error(log, msg, e); }
This line should be changed to the following if : if (log.isDebugEnabled()) U.error(log, msg, e);
This line should be changed to the following: java if (log.isDebugEnabled()) U.error(log, msg, e);
Should this variable be declared final?
Should this variable be declared private?
error
This looks the same as the old method, isn't it?
This looks the same as student.getStudentForGoogleId
This looks the same as the old method, safe side effect
The only thing I see here is "entry" is the getKey() of the getKey() of the getKey(). I don't think it's necessary to create the entry if the getKey() of the map is already null.
The only thing I see here is "entry" is the getKey() of the getKey() of the getKey(). I don't think it's necessary to create the entry two times.
The only thing I see here is "entry" is the getKey() of the getKey(). I think in this case the key should be the same getKey() method.
I'd rather make this private.
I presume this is an API change, but I'd rather not make it public.
I presume this is an API change, but I'd rather not synchronize the FBOs.
Context.getPermissionsManager().getServer().getDistanceUnit() can be used here instead (or better Context.getPermissionsManager().getServer().getForceSettings()):D
User can be null. getDistanceUnit() could be used instead.
Context.getPermissionsManager().getServer().getDistanceUnit() can be null at the end.
This is a behaviour change (we now check that this is in a behaviour change). I think we should separate test cases for assertReplicationFactorMismatchException and test that the correct behaviour is the same.
This is a behaviour change (we now check that this is in a behaviour change). I think we should separate test cases for assertReplicationFactorMismatchException and test that it is the correct one.
This is a behaviour change (we now check that this is in a behaviour change). I think we should separate test cases for assertReplicationFactorMismatchError and assertNotNotAfter, because it is a behaviour change.
This is a change of behavior. Some tests createForTesting get called for all cases. Wouldn't it make sense to have a method createForTesting() which returns a RuntimeException if a specific exception is thrown?
This is a change of behavior. Some tests createForTesting can lead to a regression.
This is a change of behavior. Some tests createForTesting get called for all cases. Wouldn't it make sense to have a method createForTesting() which returns a RuntimeException with all the error cases?
@magicDGS Sorry, I didn't notice this before, but this would be cleaner as a double-checked locking idiom. It looks like it's a trivial change, but you could also change it.
@magicDGS Sorry, I didn't notice this before, but this would be cleaner as a double-checked locking idiom. It looks like it's a trivial change, but you could also move it.
@magicDGS Sorry, I didn't notice this before, but this is probably a good idea. It's a good idea to have a single point of it. It is not a good idea to have it.
Seems like the context must be closed in a finally block.
Seems like the context must be closed in the constructor.
Wouldn't it be better to pass in context and avoid null checks?
So, this method doesLastNRecentBlogActivitiesWithOptional could be called by both doesLastNRecentBlogActivities and doesLastNRecentBlogActivitiesWithOptional. Wouldn't this be better as an if statement?
So, this method doesLastNRecentBlogActivitiesWithOptional could be called by both doesLastNRecentBlogActivities and doesLastNRecentBlogActivitiesByByCode. This is the same code. For this method, the whole if statement could be simplified by calling the method directly.
So, this method doesLastNRecentBlogActivitiesWithOptional could be called by both doesLastNRecentBlogActivities and doesLastNRecentBlogActivitiesWithOptional. Wouldn't this be equivalent?
i'd suggest just making this code more readable and have something like: Attribute<T> attribute = defaultValue; try { attribute = getSoleAttributeValue(attributeType, flag, defaultValue); } catch (AttributeDoesNotExist ex) { value = attribute.getValue(); } return value;
i'd try to simplify this code a little bit: Attribute<T> attribute = defaultValue; try { attribute = getSoleAttributeValue(attributeType, flag, defaultValue); } catch (AttributeDoesNotExist ex) { value = attribute.getValue(); } return value;
i'd try to simplify this code a little bit and only do this if the attribute is non null.
Please add a new array.
Please add @Nullable to the array.
Please use java.util.Collection instead.
since it's not used, it'd be better to keep it this way for consistency.
since it's not used, it's better to print the zone here.
since 'commit' is not supported, it'd be better to mention the standard connection here
suggestion String str = input.substring(0, input.length() - 1);
suggestion String str = input.substring(0, input.length())?
suggestion String str = input.length();
Should this be a "occurred" section?
Should this be a "warn" level?
Should this be a "while" loop?
These setters should be public
These methods should be public
These setters should be done from the constructor.
There needs to be a translation for this.
There's no guarantee that the value will be indeed a Number, but the bindings can't be null. Probably best to test for that case.
There's no guarantee that the value can be indeed a Number, but the bindings can't be null. Probably best to test for that case.
This should really not be public.
This method should return an Optional<Object>.
This method needs to be private.
You don't need this log.
You don't need this.
Why remove this?
You don't need to use DelegatingClassLoaderBuilder here.
You don't need to use DelegatingClassLoaderBuilder
+1 for consistency.
I prefer to leave this as package-private to avoid a synthetic accessor.
I prefer to leave this as package-private: it from the class.
can remove unnecessary checks
Magic number
Minor: this can be static
Magic numbers
checkNotNull for bounds?
checkNotNull for this
requireNonNull
I would recommend using [Guava's DataTables](<LINK_0> instead.
I would recommend using [Guava's preconditions](<LINK_0> here. Note that this code will prevent us from modifying the state of the object.
I would recommend using [Guava's preconditions](<LINK_0> here. Note that this code will prevent us from modifying the state of the preference just to the preference?
To be consistent with the other methods, this should be private.
To be consistent with the other methods, this should probably be private.
To be consistent with the rest of the method, this should be private
Could you please make this method private? It seems to only be called from the first place, and to be consistent with the rest of the class (in this class).
Could you please make this method private? It seems to only be called from within the loop.
Could you please rename nextRec to nextRecord? It's definitely not a good idea to use local variable names.
Line 296 has to be changed.
remove the "for" loop.
Unnecessary, the parent class is already called below.
Why does this have to be protected?
Why does this have to be public?
There should be a getter for this that implements
We should use getNextScanSize()
We should use getNextScanSize() method here.
We should use getNextScanSize() method here
Needs to be rebased on the unsaved commit handler.
Needs to be rebased on this.
Needs to use asyncExec
call super() not needed
call super(); not needed
remove?
Is there any way toSlice this could be a separate method that seems to be static?
Is there any way toSlice may be closed when close() is called?
Is there any way toSlice this could be a separate method?
Again, you should use String.format(...)
Again, you should use StringBuilder here.
Again, you can use String.format(...)
Not sure if this is the right place to put a.replace("", + UrlSerializer.serialize(self.attributes)); I think it is better to move the string concatenation into localization resource and do putString. What do you think?
Not sure if this is the right place to put a.replace("", + UrlSerializer.serialize(self.attributes)); I think it is better to move the string concatenation inside the self.attributes field, and in the getter as well.
Not sure if this is the right place to put a.replace("", + UrlSerializer.serialize(self.attributes)); I think it is better to move the string concatenation inside the self.attributes field, and in the getter.
can be static
can be static.
can we return null?
Same here, use isEmpty().
Same here, use.equals()
Same here, use getNameCount()
This can be a static constant, i.e. private static final Set<String> COMPLETED = new HashSet<>(Arrays.asList("Could not parse date 'abcdef'"));
This can be a static constant, i.e. private static final Set<String> DECISION_OK = new HashSet<String>();
This can be a static constant, i.e. private static final Set<String> DECISION_OK = new HashSet<>(configs);
This change should be a separate test, it's not re-used in the EX test.
This change should be a Long instead of long, if it's broken in the future.
This change should be a Long instead of long, if it's the same thing in the commit.
I'm puzzled by this line, is this here to check the instance when I expect it to be PROJECT_OWNERS?
I'm puzzled by this change. I think it would be better to check this before testing the instanceUnderTest.handles(PROJECT_OWNERS);
I'm puzzled by this change. I think it would be better to check this before testing the instanceUnderTest.handles(PROJECT_OWNERS)
can you merge all the above lines into one?
can you move that fragment into onStart?
can you merge all the above lines into one line
return waitFactor;
return waitFactor?
return waitFactor
Unnecessary parentheses.
Unnecessary parentheses
Unnecessary
the JPAMessageId doesn't implement equals() method, but the toObject() method returns a primitive int which will never be equal. The same goes for the other fields.
the JPAMessageId doesn't implement equals() method, but the toObject() method returns a primitive int which could potentially be null. if you want to check to see if the value is null then it will return false.
the JPAMessageId doesn't implement equals() method, but the toObject() method returns a primitive int which could potentially be null. if you want to check to see if the value is equal to null, then it will throw an exception.
use org.apache.commons.lang.StringUtils
use java.util.Set instead of using valueOf
use org.apache.commons.lang.StringUtils.isNotEmpty
Why do we need this line?
new File(tempTestCase, GraphHopperOSM) throws NullPointerException {
new File(tempTestCase, GraphHopperOSM) is a bit cleaner.
not sure about this lambda - maybe just the one arg?
not sure about this lambda - the list of instances may be empty
not sure about this lambda - the list of instances may be null.
I expect this will always be null. If there is a chance that for this button, with a null button, this will always fail.
I expect this will always be null. If there is a chance that for this button, with a null button, this will throw a NPE.
I expect this will always be null.
This is standard procedure in our registries. :+1:
This is standard procedure in our existing registries. :+1:
This is standard procedure in our existing Qualifier class.
A null check is required before accessing
A null check can be added here.
A null hole.
Can use validatePrimaryLanguage here and below.
Can we provide more specific description here?
Can use assertj for this.
what is this method for? It should be private
can you say this method is private?
what is this method for?
content.orNull() should be better.
content.orNull() should be better :return content.orNull();
content.orNull() should be a constant.
this(null, configurationsCount) should be removed
this(null, ServiceDescriptor. ServiceDescriptor.getIconUrl());
this(null, ServiceDescriptor::getIconUrl) should do this.
Can we use the EventHubProducerOptions for this? It's a bit hard to find.
Can we not use EventHubProducers in the EventHubProducers? It might be better to have a retry method.
Can we not use EventHubProducers in the EventHubProducers? It might be better to have a retry-off operation.
I think we can just use new ArrayList<>() here.
I think we can just use Collections.emptyList() here.
I think we need to rename the key to dataPair here.
Can you make MINIMUM_SDK_VERSION_OF_TESTING_DEVICE a constant?
Can you make MINIMUM_SDK_VERSION_OF_TESTING_DEVICE a little clearer and more informative.
Can you make MINIMUM_SDK_VERSION_OF_TESTING_DEVICE a constant? And below.
Same question as above
Same question as above, calling super class is safer than calling it directly.
Same question as before, call super(keyId, pipeline, version);
I'd make it protected instead of public since it's not used in the new class.
I'd make it protected instead of public since it's not used in the same class.
I'm not really sure it makes sense to introduce this new constructor at all and call it from the constructor on line 34.
Wondering if we should use the singleton pattern here: <LINK_0>
Wondering if we should use the builder pattern here: <LINK_0>
Wondering if we should use the builder pattern here: create a State(startTime, numTrail, int numSuccess, boolean isActive) { return State.builder().set....setNumOfTrail(numSuccess).setNumOfSuccess(numFailure).setNumOfSuccess(numIgnored).setNumOfSuccess(numIgnored).setNumOfSuccess(numIgnored).setNumOfSuccess(numIgnored); }
Once we start using placeholders, the getString() API can actually support it via additional parameters; it's pretty cool. suggestion String dialogContent = dialog.getContext().getString(R.string.confirm_deletion_message, " \"" + listName + "\"");
Once we start using placeholders, the getString() API can actually support it via additional parameters; it's pretty cool.
Once we start using placeholders, the getString() API can actually support it via additional parameters; it's pretty cool. <LINK_0>
I think we should allow null for the parameter to be non-null. Otherwise we might get an NPE here if configurationMetadata is null.
I think we should allow null here if configurationMetadata is null.
I think we should allow null for the parameter to be non-null.
Use InetAddress.getByAddress(byte[]) instead?
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, addressBytes = {addressBytes.toString(addressBytes); return InetAddress.getByAddress(addressBytes); } catch(UnknownHostException e) { return null; }
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, addressBytes = {addressBytes.toString(addressBytes); return InetAddress.getByAddress(addressBytes); } catch(UnknownHostException e) { return null; } }
Is there a benefit of this constructor being public?
Is there a benefit of this constructor being public? That is a little bit neater to me.
Is there a benefit of this constructor being public? That is a little risk of breaking some cases.
Please change the provider name so that it is consistent with the ParameterNameProvider instance.
Please change the provider name so that it is consistent with the ParameterNameProviderFactory.
Please change the provider name so that it is consistent with the Factories implementation.
Curious: don't we need to check for null here?
Curious: don't need this null check. Can zkClient be null?
Was it accidentally null?
suggestion return String.format("toLower(%s.%s),
Thanks for the PR. However, I'm not sure if it's more readable to use static imports here.
Thanks for the PR.
This should be: assertThat(violations.stream().anyMatch( v -> v.getMessage().equals(message))
This should be: assertThat(violations.size(), violationSize >= 0)
This should be: assertThat(violations.stream().anyMatch( v -> v.getMessage().equals(message)).
This doesn't seem to be necessary.
This should be outside the if statement.
This should be outside the if statement
@manuelplazaspalacio I'm not sure that we should have a check for hidden card type when possible.
@manuelplazaspalacio I'm not sure that we should check the visibility of the card type prior to the Cancel CommonUtils.getCardType(String) instead.
@manuelplazaspalacio I'm not sure that we should check the visibility of the card type prior to the Cancel CommonUtils.getCardType(String) instead of the for loop.
Formatting. Also, fix indention.
Formatting. Also, check for null.
Formatting. Also, fix the method names.
Once we start editing a space here (and maybe we should rename it _id_ to _id_ or something similar)?
Once we start editing a space here (and maybe we should rename it _id_ to _id_ or _id_.
Once we start editing a space here (and maybe we should rename it _id_ to _id_ or _id_ and _name_.
Conditional actions in the table. Please check whether it's a debug debug.
Conditional actions in the bcbc class.
Conditional actions in the table. Please consider calling CloneNotSupportedException.
Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it.
Recommend adding a link in the report to the ValidationResult constructor.
Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it. You could just return a list of valid steps and update them.
Just return mask.covers(entry.getKey()).contains(name);
Just return mask.cover(entry.getKey()).contains(name);
No need to check if mask.covers(entry.getKey()) is always false
This check should just be in the caller and remove the call to reserveAny. This is only true for user that owns a concurrent hash map.
This check should just be in the caller and remove the thread from the concurrent hash map.
This check should just be in the caller and remove the call to reserveAny. This code is only called by caller except for the call to reserveAny.
If you put this in the constructor, use the new static method in the Builder.
Since these are injected, should use the setters, and should not be public.
Since these are injected, should use the setters, and should use the constructor in them.
Are we 100% sure this should not replaced tag with the empty string? String tag = element.getEnclosingElement().getSimpleName(); tag = element.getName().toString();
Are we 100% sure this should not replaced tag with the empty string? String tag = element.getEnclosingElement().getSimpleName(); tag = element.getName();
Are we 100% sure this should not replaced tag with the empty string?
This looks like a copy&paste error.
You forgot to check [this](<LINK_0>, which I think is a bug.
You forgot to check ROLE_TAG, isn't it?
allowRetriesWithoutTimestamp just like the other constructor.
allowRetriesWithoutTimestamp * options.toArray()
allowRetriesWithoutTimestamp * options.toArray()?
Why not use null instead of an empty list?
Why not use null instead of an empty string?
Why not use null instead of a descending list of emptySet?
This is not the same as testDataSource. It should be a different requirement.
This is not the same as testDataSource. It seems getDelegate().getLock() is missing here
static import
Not sure why we need this anymore. Let's just do ImmutableMap.copyOf(builder.getPrivateKey(), builder.PrivateKeyId)
Not sure why we need this anymore.
Not sure why we need this anymore. Let's just do ImmutableMap.copyOf(builder.getPrivateKey(), builder.PrivateKeyId) at all.
You could just call channelOpen.get() and save a second check.
I would rather use read(InputStream) method
You could just call channelOpen.get().
I think this is even worse than the cast because it assumes that start and other are equal, but it is not, correct?
I think this is even worse than the cast because it assumes that start and other are equal, but this is not, correct?
I think this is even worse than the cast because it assumes that start and other are equal, but it is not, correct? I would add a cast to H2State
don't return null, module can have a checked exception here
trace.getAnalysisModuleOfClass?
add a check return value
This will throw IndexOutOfBoundsException if the size of the array is empty.
This will throw IndexOutOfBoundsException if an empty array is passed as the value of the method.
This will throw IndexOutOfBoundsException if an empty array is passed as the value of the methods.
if (urlIndex+1) < urls.size() || urlIndex+1) > 0) { urlIndex = 0; } else { urlIndex = 0; }
if (urlIndex+1) < urls.size() || urlIndex+1) > 0) { urlIndex++; } else { urlIndex = 0; }
if (urlIndex+1) < urls.size() { urlIndex = 0; } else { urlIndex = 0; }
CollectionUtils.isNotEmpty already checks if eventsList is empty.
isNotEmpty is not needed here
CollectionUtils.isNotEmpty already checks for empty list.
This function **and** returns true if there is no match. That's why I guess we should use getMimeTypeFromName() instead of mMimeType.startsWith("audio/")
This function **and** returns true if there is no match. That's why I would change the function name to something else.
This function **and** returns true if there is no match. That's why I would change this.
does this not work?
does this mean that the name is always the same?
does this mean that the idea is that this context is managed twice?
This should be replaced with a guard method.
This should be replaced with a check that it is not a String.
This should be replaced with a guard method
Any reason this can't use getMessagingExceptionCause?
Any reason this can't be part of the retryPolicy log?
Any reason this can't have a check instead of an instanceof?
What's the purpose of this change?
What's the purpose of returning null?
Maybe just return an empty string?
This change can be reverted.
This change can be reverted. We don't want to change this class anywhere, so it can be removed.
This change is not needed.
why not call the new method with null?
Why not call the new method in this case?
Why not call the new method in order to retrieve the report?
could you remove the'catch' here?
Add the exception as the second argument to logger.warn.
Add the exception as the second argument to LOG.warn.
Why is this necessary?
Why not have this constructor private?
Why not have this constructor injected?
Is there a reason for logging this message?
Is there a reason for logging these message?
Is there a reason for logging message instead of WARNING?
You can try with resources at the end of the test.
You can probably add an assert around the directoryver array.
The assert is here.
better to have fail(); in the onSuccess()?
better to have fail(); in the onSuccess method?
better to have fail(); after onSuccess()?
:x: I'd prefer AssertionsUtil.expectException(e) style.
assertFalse()?
Too much specific exception.
Just return Collections.emptyList()
Just return Arrays.asList(tumorType.getMainType())
Just return Arrays.asList(tumorTypes);
Should this be getNonNullRequestParamValue?
gateKeeper.verifyAccessible is a no-op for this method, it is only used here. This is a function to perform verification.
This should be getNonNullRequestParamValue
text should be externalized
text should be defined as constant.
text
Why did you remove this if statement?
Why did you remove this?
Why did you remove this if clause?
Null case maybe log an error or throw
Null case maybe log an error or throw.
Null case maybe log an error or throw RuntimeException?
Why the increment may be zero?
Why are you decrementing on this one side?
Why the change?
Missing super() call?
Missing the super() call?
Missing the call to super()
Change to: if (validatorLocator == null) { validatorLocator = new... } return validatorLocator;
Can validateLocator be volatile or empty?
Can validateLocator be volatile?
Here too, can we just use scheduleDirect(true)?
Here too, can we use scheduleDirect(true)?
Here too, can we just use scheduleDirect(true)?
WebApplicationException is a RuntimeException, so no need to catch it
You should not write to the ParticipantStatus enum here as well
You should not write to the ParticipantStatus enum here as well.
Can we call this method removeSessionOnLogout?
Can we call this method removeSessionOnLogout? That way other callers don't seem to have their own method.
Can we call this method removeSessionOnLogout? That way we don't need to have a method for it.
I think we might want to add a constructor like this: public Iec61850MockServerMarkerWadden(final String serverName, final String hostname, final int port);
I think we might want to add a constructor without the super() call, as default constructor is called from this one.
I think we might want to add a constructor with the default values.
This crashes. You are not supposed to access the result of TransactionId.MAX_VALUE.
Why do you need this?
This crashes. You are not supposed to access any kind of data.
Can you put this into a constant?
Would be nice to use a constant for this instead of URL
The color should be hardcoded as a constant.
I would suggest to make it consistent with the null check.
I would suggest to make it consistent with the null check in this method.
I think daysToPurge should be the second name
Will this be hardcoded?
Will this work for all browsers?
Will this work for all the other clients?
Use the existing constructor here.
Use this to avoid null checks.
Use the existing constructor
Let's use more specific exceptions. Throw the exception with the message.
Let's use more specific exceptions. Throw the exception, if the exception is not found.
Let's use more specific exception. Throw the exception with the message.
equals!
"equals" is not needed.
"equals" instead.
don't we need to guard this? if (numberOfRunningTransactions.get() == 0)
don't we need this null check?
don't we need to notify these ids if we have more than 1 change?
@dilini-muthumala Dilini, please also use setNoGroup() in the code
@dilini-muthumala Dilini, please also use setNoGroup() here.
use setNoGroup() in all cases
Nit: We can use producer.send(producerRecord) here
Nit: We can use producer.send(producerRecord).get() for consistency.
Nit: We can use producer.send(producerRecord) to avoid blocking the creation of the producer.
How is this expression different from "this"?
How is this expression different from "this"? I may be wrong.
How is this used?
Not sure if this is the best approach. Perhaps this should return an immutable list.
Consider to return Collections.unmodifiableList(channels).
Not sure if this is the best approach. Perhaps throw an exception if sorting required.
Add final keyword.
Add a public static method from the KeyExtent to avoid duplicating code
Add a public static method from the KeyExtent to avoid duplicating code.
again.
again unnecessary.
again unnecessary new list
Maybe consider moving these strings using a method in the tests.
Maybe consider moving these strings using a method in the test class?
Maybe consider moving these strings using a method in the outer class?
also check for null here
also check null on Collection
protected?
I'm pretty sure this message shouldn't be part of the checkInitialized(). At the very least, this should be terminated.
I'm pretty sure this message shouldn't be part of the checkInitialized(). At the very least, shouldn't it?
I'm pretty sure this message shouldn't be part of the checkInitialized(). At the very least, shouldn't the word "is properly instantiated" be a word?
This should be enough: java @TestUtils.createSwarmClient(j, processDestroyer, temporaryFolder, "-fsroot", fsRootPath);
This should be enough to check the path for the current path operation?
This should be final
warn?
Should this be done in the executorService thread?
warn
You should use ContinuousTimeRangeCondition
You can use getName()
You should use getName()
I don't think this is necessary, because bp can be the default value.
I don't think this is necessary, because bp.parseLocal already returns the bp value.
I don't think this is necessary, because bp.parseLocal returns the bp value. Also, is it necessary to do this? I would prefer to avoid a double check.
Trivial nit: space after if
Trivial nitpick: space after if
:(
I'm a bit confused about this method. This has two types of arguments: java public static <T> Class<? extends T> Class<? extends T> Class<? extends T> defineClass(ClassDefinition, Class<? extends T> classDefinition, Class<? extends T> class) { return defineClass(classDefinition, superType, new DynamicClassLoader(parentClassLoader, callSiteBindings)); }
I'm a bit confused about this method. This has two types of arguments: java public static <T> Class<? extends T> Class<? extends T> Class<? extends T> defineClass(ClassDefinition, Class<? extends T> classOwner, Class<? extends T> classClassLoader) {
I'm a bit confused about this method. This has two types of arguments: java public static <T> Class<? extends T> Class<? extends T> Class<? extends T> defineClass(ClassDefinition, Class<? extends T> classDefinition, Class<? extends T> class) {
long now = System.currentTimeMillis();
I would suggest using now instead.
It sounds a bit weird to me why this works, but I would not do it in this commit, since this can be used..
These two assertions should probably be their own tests, testNullPath and testNullPathWithRoot respectively.
These two assertions should probably be their own tests, testNullPathWithRoot and testNullPathWithRoot respectively.
These two assertions should probably be their own tests, e.g. "assertNullPathWithRoot".
never catch NPE.
getAdapter().getCount() == 0
getAdapter().getCount()!= 0
finally?
order should be consistent with previous line
order should be 1
Asserting it to true might save someone some time?
Asserting it to true might save someone some time someday.
Asserting it to true might save someone some time someday?
Should be gw::destroy
Should be gw.destroy() also do the reverse, since the native code will do the reverse.
Should be gw.destroy()
set this to this.config.getImplementation().dynamic
call this method withName
set
No need for builder as a field here.
These two methods can be private.
These two methods can be private
thrown.expect(PackProtocolException.class);
This doesn't seem to match the error message.
This doesn't seem to match the expected behavior, what is it?
nit: suggestion String addressOne = "your-job-id";
suggestion String addressOne = "your-job-id";
nit: suggestion String addressOne = "your-job-id");
catch IOException and throw to avoid wrapping an IOException
Wondering if this is a good place to catch IOException.
Wondering if this is overly complicated... How about "No file path from".
nit: space between if and (
n: space between if and (
nit: space after if
TestFilter is non-null, so you can use Objects.equals() here.
TestFilter is null, so you can use Objects.equals() here.
TestFilter is non-null, so you should use equals() to ensure it's not null too.
You can call this.fTimestamp = timestamp;.
You can call this.
remove this.
Is this necessary?
Is this necessary? If I remove the update line seems still to work.
Is this necessary? If I change the default value of this field to void, i.e. after the update call.
why? I'm asking myself if the analysis works too early.
why?
externalize
These should probably be private.
These two lines should be private.
These should be private.
return Arrays.hashCode(delegate.hashCode());
return Arrays.hashCode(delegate.hashCode()); should suffice
return Arrays.hashCode(delegate.hashCode()); should suffice.
Shouldn't a cast to int be enough?
Shouldn't a cast to Integer be enough?
Shouldn't a cast to int be enough??
This is a final class. Please remove this.
This should be removed.
This is a debugging statement that should be removed.
Again, we should be able to use "study.export.crosses.no.germplasm.list.available"
@vmaletta use RandomStringUtils.randomAlphanumeric
Again, we should be able to use the "study.export.crosses.no.germplasm.list" constant
Please move the "protected" modifier to a separate method.
Please move the "boolean" part to a separate method.
please move to static method.
Seems you should verify the response code here as well?
No assertions needed here?
No assertions required here?
Suggest logging the boolean value of partitionName instead of just the toString
Suggest logging the boolean value of partitionName as well.
Suggest changing the log message as well since it is not a pb...
There is no need to call super.checkIfUsernameCanBeChanged() here.
There is no need to call super.checkIfUsernameCanBeChanged() here as it is called above.
There is no need to call super.checkIfUsernameCanBeChanged here.
This is the wrong place for this. Use ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE) and throw the exception if it isn't null.
This is the wrong place for this. Use Timber.e and throw the exception. This should be the fourth argument to the method so it can be passed in as a parameter.
This is the wrong place for this. Use ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE) and remove the unused variable.
It seems to me that it should be replaced to cloud.removeDynamicTemplate(podTemplate) where removed_Template is called.
There is a pod template that should be removed when the pod is removed.
There is a pod template that should be removed when executed from a single thread
I think we could use a field like: /** The 'logging.file' or 'logging.path' properties. * * @param path The sseEmitter can be returned if the path is missing */ public void logFileStream() {
I think we could use a field and name the log method, which then can be confusing.
I think we could use a field like: logFileResource
use getDiskInfoDestinationMap().get(diskImage.getId()) instead of getDiskInfoDestinationMap().get(diskImage.getId())
use getDiskInfoDestinationMap().get(diskImage.getId()) instead of get diskInfoDestinationMap().get(diskImage.getId())
why not use the getDiskInfoDestinationMap() method?
Is this check really needed? If not, please use materialTextView.isValid() instead.
Is this check really needed? If not, please use an 'if' statement.
Is this check really needed? If not, please use materialTextView.isPreviewWithText().
I'm a little confused, but straight forward. Does it really need to be public?
I'd like to see this's Preconditions.isEmpty(pubsubPrefixes, "pubsubPrefixes cannot be null") before the if statement.
I'd like to see this's Preconditions.isEmpty(pubsubPrefixes, "pubsubPrefixes cannot be null") and the underlog.isEmpty() check is redundant.
Again ;)
Again ;) and move this down to the first line.
Change all of this to private?
if you want to throw UncheckedIOException, it should be closed in finally block
please use RuntimeException(e) here and in other places
please use RuntimeException(e) to avoid wrapping
please make this method private
please make this method final
please make this method final.
Is there a reason to use the throws Exception here?
Is it possible to use a builder pattern here?
Is there a reason to use the throw Exception here?
this is deprecated but I think we should have a different way of handling the exceptions in the RuntimeException
this is deprecated but I think we should have a different way to avoid the exception
Shouldn't this check be the RuntimeException?
Better to have this constructor take in a DataSink as an argument, so that we don't have to pass in a file.
Better to have this constructor take in a DataSink as an argument, so that we can avoid the need to pass in a file.
Better to have this constructor take in a DataSink as an argument.
Please use assertEquals.
Please use assertEquals instead of ==.
Consider using assertEquals instead of ==?
How about move it to the top of the constructor?
How about rename it to be consistent with the other constructor?
How about replacing this with it.
@Virtkememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememememem.getParserModule(komScriptedDefinition.mainSyntaxModule())
@vilchik-elena Suggested name of the method getParserModule:.
@vilchik-elena > This class is not necessarily a singleton.
Yes, you're right.
Yes, it's the timezone. The user's newInstance method is that it returns a non-Timezone set, no?
Yes, it's the timezone. The user's newInstance method is that it returns a non-Timezone set, not a data provider.
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
I think you will find that there are a race condition here: while (end - now) > 0L) { wait((end - now) / 1000L); return isTerminated(); }
I think you will find that there are a race condition here: while (end - now) > 0L) { wait((end - now) / 1000L); }
why do we have closed = true? I'd rather put exceptionally in a finally block.
why do we have closed = true? I'd rather put exceptionally in the finally block.
why do we have closed = true?
super nit: > 1
super nit: > 1?
super nit: > 1 -> :
reduce to debug
"Refreshing channel" should be a debug message
"Refreshing channel" sounds a little strange.
Let's use hamcrest matchers here: java Map<String, String> originalProperties = registries.build(); assertThat(originalProperties, null, true).isInstanceOf(Map.class);
Let's use hamcrest matchers here: java Map<String, String> originalProperties = ImmutableMap.of("foo", "bar"); assertThat(originalProperties, hasSize(foo,bar))
Let's use hamcrest matchers here. They use much more descriptive assertions.
Might want to pass a boolean in the signature here.
Might want to pass a boolean here.
Might want to pass a boolean in the signature here instead of false?
This doesn't look very readable.
This doesn't look right.
Please add @Nullable to static variable
Does it make sense to wrap the exception in a checked exception and call super.isDynamic?
Does it make sense to wrap the exception in a checked exception and wrap it as a checked exception?
Does it make sense to wrap the exception in a checked exception and provide a stack trace (adding a warning).
On the web, there is three formats: 1- More than one year: Month day, year ex: Jan 10, 2015 2- Not 1.1.2, 2.6.
On the web, there is three formats: 1- More than one year: Month day, year ex: Jan 10, 2015 2- Not today: Month day ex: May 13 3- Today: hour:min AMget year
On the web, there is three formats: 1- More than one year: Month day, year ex: Jan 10, 2015 2- Not today: Month day ex: May 13 3- Today: hour:min AM/day
It's better to use synchronized here just in case inProgressRebalanceOperations is null
I would suggest using synchronized here just in case inProgressRebalanceOperations is null
I would suggest using synchronized here just in case inProgressRebalanceOperations is null.
Throwing exception is not a good practice. We should log it in the caller and display it to the user.
Throwing exception is not a good practice. We should log it in the error log.
Throwing exception is not a good practice.
Should we check that addr is non-null here? java if (obj instanceof XBee64BitAddress) { return false; }
Should we check that addr is non-null here?
Check if the instance of the array is null.
This implementation is going to create a new HashSet with references to every date in the calendar every time this method is called. This seems pretty expensive given that it has to be expensive. Could we structure the internal state of this class so that this is a simple contains operation?
This implementation is going to create a new HashSet with references to every date in the calendar every time this method is called. This seems pretty expensive given that it has to be expensive.
This implementation is going to create a new HashSet with references to every date in the calendar every time this method is called. This seems pretty expensive given that it has to be expensive. Could we structure the internal state of this class so that this is a simple contains check?
Please use log4j.
Please, use the logger instead.
Please use log4j printStackTrace instead.
You need to close conn as well here.
You need to close connection as well since you are not closing the connection.
You need to make sure all these are closed if there are not exception thrown.
This can be simplified to return action.composeAction()? AUDIT : NOT_AUDIT;
This can simply be return action.composeAction()? AUDIT : NOT_AUDIT;
This can be simplified to return action.composeAction()? AUDIT : NOT_AUDIT);
This is not necessary, take a look at the TransactionR code.
This is not necessary, take a look at the super class in ActivityInstrumentation.
This is not necessary, take a look at the truth code.
nit: try to be consistent with the rest of the indentation here
nit: try to be consistent with the rest of this method.
nit: try to be consistent with the rest of the indentation here.
Please revise this statement
Please install java maven in this file
Please revise this variable
nit: Not sure if this is used anywhere.
nit: Not sure if this is used anywhere
nit: Not sure if this is used anywhere?
Because of the changes to supported item types, this item just has nothing to do with the ItemType. Please change the message to say "Items of type {} are not supported for now".
Because of the changes to supported item types, this item just has nothing to do with the ItemType. Please change the message to something like "Items of type {} are not supported for now"
Because of the changes to supported item types, this item just has nothing to do with the ItemType. Please change it.
no need to cast to Table here
no need to cast to TableLiteral here
no need to cast to stringLiteral here
why do we need this check? Since stream() already returns a Map, what if we have a turn operation or iterable?
why do we need this check? Since stream is already returning a String and if it was empty, this method could be deleted.
why do we need this check? Since stream() already returns a Map<String, Attribute>, Attribute> should be enough.
suggestion long now = System.nanoTime();
Minor: can you change this to a unit test?
Minor: could you change this to a unit test?
Gerritpicking: This is not a bug, as the cache is a Gerrit managed by the service. Use the getter.
Gerritpicking: This is not a bug, as the cache is a Gerrit managed by the JVM. Use the getter.
Gerritpicking: This should be past the renamed config parameter name Ehcache instead of Ehcache.
useless
useless newline
useless embar
it would be better to use append here
it would be better to use append here.
rename one variable
That is not a good practice in Java. You can do.flatMap(Map.Entry::getKey).collect(Collectors.toList());
That is not a good practice in Java. You can do.flatMap(Map.Entry::getValue).collect(Collectors.toList());
It looks like you are using.collect(..) here.
Is this method threadsafe?
we should add as the cause here as well
add 'throws IOException'
Great, just noticed this is a problem!
Great, just noticed this is a typo.
Could this be a a static final?
You're changing this to a synchronized method.
You're changing the semantics of a computeIfAbsent. Why not just call delete()?
You're changing the semantics of a computeIfAbsent call. Why not just call this method directly?
Can you call this(scope, value, value, sampleRate, tag) that matched? You can save the same rule for the same reason.
Can you call this(scope, value, value, sampleRate, tag) that matched? You can save the same rule for the same rule.
Can you add this so that it is consistent with the rest of the class?
I think this should be a Mutation instead of a Mutation since its not a Mutation.
I think this should be a Mutation instead of a Mutation.
I think this should be a Mutation instead of a Mutation since it's not a Mutation.
you can't do this as File.exists() test?
you can't do this in a method but really it can be static
you can't do this in a method but really it can be protected
We can rename this variable to diagnoses.
We need to rename this variable to diagnoses.
We need to rename this variable
Would be nice to have this method private?
You can be simplified to returnhostsConnectionResult.getSecond() == true
Would be nice to have this private method private?
same here with above for loop
same here with above loop
same here with above for loop.
This commit appears to duplicate changes from the one above. Please remove the duplication.
This commit appears to duplicate changes from the one above. Please make sure that nothing is happening in the right indent.
This commit appears to duplicate changes from the one above. Please make sure that nothing is happening in the right indent. Thanks!
I would just add line return (long)(0.1 * totalCount);
I would not return null here. It just adds cognitive complexity.
I would not return null here. It just adds cognitive complexity for this.
the log message should be "request spent {} ms in the transport buffer."
are we not going to do this on every request?
this will not work if REQUEST_RECEIVED_MILLIS_KEY is null
This should be synchronized
This should be synchronized too, right?
This should be atomic.
Why not something like this? checkForAdminPermissions(groupId, groupId, 4)); return new ModelAndView(groupUserList").addObject("group", groupDto);
Why not something like this: checkForAdminPermissions( throws NotFoundException.class);
Why not something like this? checkForAdminPermissions(groupId, groupId, 4));
Would be nice to verify the methods of this class
Would be nice to check here that the methods you replaced above are working as expected.
Would be nice to check the methods of this class and the ones that testPutIfAbsent methods.
Does this need to be done before creating the message?
Does this need to be done once? The checkOpen method is not good enough.
Does this need to be done in pipeline().release()?
Why is there a test for the update?
why is there a test for the update?
Why is Charlie a part of the name?
I think you shouldn't need this as we check it also for permissions.
I am thinking you shouldn't change this to WRITE_EXTERNAL_STORAGE because it is Glucosio and not Storage permissions.
I am thinking you shouldn't change this to WRITE_EXTERNAL_STORAGE because it is Glucosio and not Glucosio
Why not use Preference.APPLICATION_SCOPED.getString(userUuid)
Why not use Preference.APPLICATION_SCOPED.getString(userUuid) directly?
Why not return real value?
UncheckedIOException can be wrapped in UncheckedIOException.
UncheckedIOException can be wrapped in UncheckedIOException
UncheckedIOException?
Wouldn't it be easier to use the [StringUtils.isNotBlank(topic)](<LINK_0> here?
Wouldn't it be more consistent to have the isNotBlank check in the first place?
Wouldn't the other isValid methods be more consistent?
try { fail("Unexpected " + wrongDoc); } catch (RemoteException e) { fail("Unexpected " + wrongDoc); }
try { fail("Unexpected " + wrongDoc); } catch (RemoteException e) { fail("Unexpected {}", e.getRemoteCause()); }
try { fail("Unexpected {}", wrongDoc); } catch (RemoteException e) { fail("Unexpected {}", wrongDoc); }
I'm not sure there is a good reason for this to be a list.
I guess we can make this a private method with a template invocation...
I'm not sure there is a good reason for this to be a list instead of a concrete class.
Don't we need to add an StandardCharsets.UTF_8 here?
Don't we need to expose StandardCharsets.UTF_8?
We can remove the StandardCharsets.UTF_8, right?
I think we should pass here and return a StringBuilder instead of StringBuilder
I think we should pass here and return a StringBuilder instead of a StringBuilder.
I think we should pass here and return a StringBuilder instead of a StringBuilder
This is weird, I would use AdsContent.MOBILE_TOP_LB.
This is weird, I would suggest using AdsContent.MOBILE_TOP_LB.
do we have to add a method its own page object?
What does this test do? Should we test the number of groups?
Can you use an actual list to test the number of items?
What does this test do? Should we test the other one?
Please implement equals() method either.
Objects.hash(Interval, condition)
Objects.hash(Interval, condition)?
@dmzaytsev let's inline this
Is it possible to inline this string with the gson instance?
Is it possible to inline this variable?
Should check whether autocommit is false here
We probably need a finally block here if rollback() is called.
We probably need a finally block here to ensure that the transaction is always committed.
It seems we are assigning analysisJobXmlInputStream to a JaxbJobReader, there is no need for the _dataCleaner configuration. Then it would be better to do something like this: return analysisJobXmlHdfsResource.read( analysisJobXmlHdfsResource);
It seems we could have a util method for getting the dataCleaner configuration. Then it would make the code more readable and user-friendly.
It seems we are assigning analysisJobXmlInputStream to a JaxbJobReader, there is no need for the _dataCleanerConfiguration.
increase to selector
check that the return value of this method was not null
increase to move
you can just change this to endpointRegistry.deleteEndpointRegistry("abc1");
you can just change this to endpointRegistry.deleteEndpointRegistry("abc")
you can probably remove this line.
Can we change the default to commitOffsetsQueue > 0?
can we change the default to commitOffsetsQueue > 0?
can we change the default to commitOffsetsQueue > 0?
Any particular reason that you published an event instead of publishing an event?
Any particular reason that you published an event instead of publishing an event? Remember that Pressure Switch is added as a system property for the golden standard.
Any particular reason that you published an event instead of publishing an event? Remember that Pressure Switch has been added as a system property for the golden standard.
IllegalArgumentException is possible here. I see it is not handled
IllegalArgumentException is possible here. I see it not handled
Check for default file length.
Check for equality of the json mapper.
Check for equality of the object.
Check for equality of the object ConcurrentMap.
Yeah, we should have a explicit transport type.
Yeah, we should have a explicit transport exception.
Yeah, definitely unfortunate.
please use try-with-resources
FileOutputStream and FileOutputStream need to be closed
I don't think FileOutputStream really need to be closed
Optional
Optional<Long>
Optional.ofNullable
IIUC, this will trigger redeploy even if the project is not in the ActivateMRS module, but the snapshot was actually not updated. This is why I think we need to store the version of the project that was persisted before and restore the original value.
IIUC, this will trigger redeploy even if the project is not in the ActivateMRS module, but the snapshot was actually not updated. This is why I think we need to store the version of the project that was actually being installed.
IIUC, this will trigger redeploy even if the project is not in the active context. What you want is to store the latest item as a dependency, and rebuild it.
nicer to have a method IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
nicer in IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
nicer in this case IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion
![MAJOR](<LINK_0> 'Severity: MAJOR') String.valueOf(int) [![rule](<LINK_1>](<LINK_2>
Should this be "getContainerId"?
Should this be "getContainerId"?
As setInstalledLineNumber, I think it should also set RESET_INSTALLED_LOCATION
As setInstalledLineNumber, I think we should also set RESET_INSTALLED_LOCATION
As setInstalledLineNumber, I think we should also set RESET_INSTALLED_LOCATION here.
suggestion int fileStateSizeThreshold = 1024;
suggestion int fileStateSizeThreshold = Boolean.MAX_VALUE;
While we are at it, could you change this to fileStateSizeThreshold = 1024 instead?
Not sure if we should have this outside the if block?
Not needed?
Not sure if there is a reason in the default methods?
Hardcoded xD
Hardcoded string
Hardcoded x3
nit: not sure if'subFields' is empty or empty
nit: empty line
empty line
I suggest using Iterables.all(tail, tail).
I suggest using Iterables.partition(tail, tail).
I suggest to start with the for loop.
nit: not sure if'subFields' can be mutated by the caller.
nit: not sure if'subFields' can be empty
nit: not sure if'subFields' can be empty?
use java.util.Objects.hash
use guava
use java.util.Objects
lowercase for package names.
lowercase for character names.
lowercase?
to be consistent, maybe use Objects.requireNonNull?
to be consistent, maybe use Objects.requireNonNull?
nit: java checkNotNull(capableScanNodes)
verify that fixedLifespanScheduleGroupedExecution is not null
verify that fixedLifespanScheduleGroupedExecution is not called
verify that fixedLifespanScheduleGroupedExecution is not empty
Should this be synchronized?
Is this necessary?
Is this necessary? Doesn't the next method already do this?
I think a generic type returned would be sufficient.
I think a generic type should be removed (and a tab character :-)
I think a generic type should be removed (and a tab character!)
This doesn't seem to be used.
This isn't thread-safe, so you should be synchronization on the parameters.
This isn't thread-safe, so you're not required to synchronize on these operations.
Maybe we could use the same description as in method getDescriptionUsage()?
Let's use different naming variables for each method? Maybe we could use [this](<LINK_0>
Let's use different naming variables for each method? Maybe we could use [this](<LINK_0>?
please add metrics to this log
please add metrics to this message
please add synchronized block for the methods
why doesn't tags have a CDATA section?
why doesn't one of these be add labels?
why doesn't tags be added in the loop?
java String courseName1 = SanitizationHelper.desanitizeFromHtml(courseName2); courseName2 = SanitizationHelper.desanitizeFromHtml(courseName2);
java String courseName1 = SanitizationHelper.desanitizeFromHtml(courseName2); String courseName2 = SanitizationHelper.desanitizeFromHtml(courseName2);
java String courseName1 = SanitizationHelper.desanitizeFromHtml(courseName2); return courseName1.compareTo(courseName2);
why don't you return STACKTRACE_SHORT directly?
one small nit, for local variables please
one small nit, for code style and method names, please change to be consistent.
This could be simplified to java this.metadatas.stream().filter(metadataName -> meta.getKey().equals(metadataName)).findFirst().orElse(null);
This could be simplified to java this.metadatas.stream().filter(meta -> meta.getKey().equals(metadataName)).findFirst().isPresent();
This method should probably be synchronized.
consider using an overload of this method
Consider using an overload of this method
"0"?
it should be renamed to applyStereotype
it doesn't work for multi-valued feature
it doesn't work for multi-valued feature?
typo " shoud"
typo
typo  shoud
this is strange, why 'this'?
this is a breaking change - why?
this is strange, why 'this'?
now that we have some permissions in common in ImportVmCommand and ImportVmFromExternalProviderCommand, we should probably move the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to ImportVmCommandBase as it is common to all import commands, what do you think?
this method should return all permission checks, no?
this method should return all permission checks: host and cluster
can be replaced by: return Objects.equals(other.sender_id, other.recipient_id);
can be replaced by Objects.equals(other.sender_id, other.recipient_id)
Can be replaced by Objects.equals(other.sender_id, other.recipient_id)
This is mostly wrong. From the transform method, it basically returns null, which will cause an NPE. You probably want to use the output schema here
This is mostly wrong. From the transform method, it basically returns null, which will cause a NPE. You probably want to use the output schema here
This is mostly wrong. From the transform method, it basically returns null, which will cause a NPE.
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
you can set the label test in the ui binder file for both versionLabel and userNameLabel now.
You can set the label test in the ui binder file for both version and userNameLabel now.
When pressing the button, this button gets disabled even when the user is not able to select the hint (just like the first option, and then the second option is selected). Then again, the button is disabled, but it should not be enabled. I would remove this line and add a break.
When pressing the button, this button gets disabled even when the user is not able to select the hint (just like the first option, and then the second option is selected). Then again, you could just break out of the switch statement, and save you the break. I think that would be more clear.
When pressing the button, this button gets disabled even when the user is not able to select the hint (just like the first option, and then the second option is selected). Then again, you could just break out of the switch statement, and save you the break. I think that would be more readable.
suggestion long dueTime = getNextAlarmDueElapsedTime(); long newDueTime = endTime - getBoundIntervalInSeconds() * MILLISECONDS_IN_SECOND;
suggestion long dueTime = getNextAlarmDueElapsedTime() * MILLISECONDS_IN_SECOND;
suggestion long dueTime = getNextAlarmDueElapsedTime(); long newDueTime = getBoundIntervalInSeconds() * MILLISECONDS_IN_SECOND;
I think this should be warn.
I think we should log a WARN and include cost function name in the logging.
I think we should throw an exception if there is no cost function, and log a warning. This is the reason for logging an error.
I don't think this is right. The cache is supplied in the file itself. It's possible that only the readFailure() method is called.
I don't think this is right. The cache is supplied in the file itself. It's possible that only the readFailure() method is called. So, the readFailure() method could be removed.
I don't think this is right. The cache is supplied in the file itself. It's possible that the user might have an empty zk-plugin.
assertThat(conf).hasSize(2
assertThat(conf).hasSize(14); seems better
Dangerous assertions here
Minor: Might be better to make it final.
Minor: Might be cleaner to make it final.
Minor: Might be better to make it private.
This is not right, it's only stopped because it is currently stopped.
It's not really related to this PR, but I think we should make this a log.info.
This is not right, it can't be stopped.
this does seem to cover some people who might have a legit reason. but some do "gc/runFinalization/gc".
this does seem to cover some people who might have a performance impact. but some do you think it is worth to check the performance.
this does seem to cover some people who might have a performance impact. but some do you think it is safe to call this on the lock.
Can we use Objects.hashCode() instead?
Can we use Objects.hash() instead?
Can we use Objects.hashCode()?
do not forget to set it to true
do not forget to set it
do not forget to use setDeleted as that is most likely aappointment operation
Can this be public?
Can this be made static?
Can we make this private?
Wouldn't it make sense to deprecate this method and have a Flux<Message> that would return a Flux<Message>?
Shouldn't this method return Flux<Message>?
Wouldn't it make sense to deprecate this method and make this method protected?
Why is this method required?
Why is this method outside of the package?
Why is this method outside of the first place?
what if data is null?
what if data is empty?
how about values = new double[rows];?
This method is the same as <LINK_0>
This method is the same as <LINK_0>?
This nobody is using the default.
This test is not testing NormalizeUserName, it should assert that input is not null
This test is not testing equals
Assert is not needed
This can be simplified to return Objects.equals(value, other.value) && Objects.equals(value, other.value);
This can be simplified to: return Objects.equals(value, other.value);
This can be simplified to return Objects.equals(value, other.value);
extract this to static field.requirement
this would make this private static final
this will make this private.
I think this should be more clear: java String actual = null; if (lastError!= null) { description.appendText("AssertionError with message: "); description.appendText(text); } description.appendText(reason);
I think this should be more clear: java String actual = null; if (lastError!= null) { description.appendText("AssertionError with message: "); description.appendText(reason); } description.appendText(reason);
I think this should be more clear: java String actual = null; if (lastError!= null) { description.appendText("AssertionError with message: "); description.appendText(text); } description.appendText(reason); }
spaces in (str : attributeList)
Comparable?
spaces in (boolean) and tab
I think you can replace this.iterator.hasNext() with this.iterator()
I think you can use this.iterator().hasNext()
I think you can replace this.iterator.hasNext() with false
neither of these need to be a concurrent data structure. if you really need them, you can use a plain ArrayList with the linked list.
neither of these need to be a concurrent data structure. if you just make the addTriggerChangeListener method use an atomic write, you can avoid a double read.
neither of these need to be a concurrent data structure. if you really need them, you can use an AtomicBoolean and compareAndSet() in the declaration.
shouldn't this be assertSame?
you can use assertFalse() instead?
you can use assertFalse() instead which is more readable.
negative logic
negative value
logic
return segmentsNeeded?
return segmentsNeeded.
doc
nit: I think we can write this as return StringUtils.defaultString(value.toString());
nit: How about using a string constant?
nit: I think we can write this as return "value == null? "" : value;
Needs a null check.
Couldn't this be done on paramType?
Arguably running on this line?
suggestion throw new InvalidSettingsException("No Files selected.");
Personally I'd rather throw the more specific exception here.
typo
Why are you catching the exception and then catch it?
Why are you catching all exceptions and then catch them? Are you just trying to catch them?
Why are you catching all exceptions and then catch them? Are you just trying to close them?
There is no need to catch Throwable here, just let it throw.
:pencil2: The loop here should be replaced by: if (mynode.numNodes!= 2) { fixture.delete(); }
:pencil2: The loop here should be replaced with fixture.numNodes().
Does this have unit tests? e.g. for non-windows systems?
Does this have unit tests?
Does this have unit tests? e.g. for non-Windows?
setTimeBoundsAndIntExact(data, minorFraction)
Double -> double
setTimeBoundsAndIntExact
Shouldn't this be checkEntityTypePermission as well? I mean, action == Action.CREATE || action == Action.UPDATE?
I think it's better to keep the enum as dumb as possible. I would suggest to check if the action is CREATE and update if needed.
I think it's better to keep the enum as dumb as possible. I would suggest to check if the action is CREATE and update if it is already an UPDATE.
note that the locationListing field is removed later. I'm not sure the newScope is really intended here.
note that the locationListing field is removed later. I'm not sure the newScope is really used for finding (this is what would mean).
should this be public?
Here we want to consider using "jgit ls-files" instead of "jgit ls-files".
Here we want to consider using "jgit ls-files" instead of "jgit ls-files"
Here we want to consider using "jgit ls-files" to be consistent (I didn't notice this earlier).
This could be the way it was before, but this is only used in the field declaration.
This could be the way it was before, but this is only used in the getter.
This could be the way it was before, but this is only called once.
my guess is that the deserializer should be set up correctly in the constructor?
Could we move the ObjectMapper inside the package?
Could this be an Class field?
It would probably be helpful to cover a test case with an assertion here that you expect selectAll to be null when creating a new activity with it.
It would probably be helpful to cover a test case with an assertion here.
It would probably be helpful to cover a test case with an assertion here that you expect selectAll to be null when creating a new view.
remove the second param
remove the one again
remove the one in @Test
Can you use isEmpty()?
Can you use isEmpty()? isEmpty() is more concise.
Why not check result.isEmpty?
@erimerturk let's rename this to Folder
@erimerturk let's rename variables too
@Won't that method be used?
@pefernan here the message should be: KieServerMode.DEVELOPMENT.toString()
@pefernan here the message should be: KieServerMode.DEVELOPMENT.name()
@elguardian this constructor should be deprecated, right?
Can this be public?
Can this be made private?
Can you make this public?
How come we call this scheduleMessageForRetry?
How come we call a method like this?
How come we call this scheduleMessageForRetry()?
can we use DetailAST ast2 instead of ast2?
can we use DetailAST.class.getSimpleName() here?
can we test this method?
There's no need to check for null.
There's no need to check for null here
Why do we need to check for null here?
redundant newline
please remove )
please remove ()
nit: add braces around this statement
nit: this doesn't seem like the same check as the setView.
nit: move this line below the assignment
This test should also test that the name matches the name, not the first.
This test should also test that the name matches the name of the first character.
This test should also test that the name matches the name of the read name.
Is it possible for allNormalizationIds to be null? If not, please raise an exception.
Is it possible for allNormalizationIds to be null? If not, please raise an error.
are we OK with null?
firstNonNull doesn't sound better.
firstNonNull doesn't sound better
firstNonNull doesn't work
Nit: java public static void clearVisitDate(String[] selected) { if ( selected.length > selected.length) { geocodes.add(selected[i]); } } setVisitDate(geocodes, 0); }
Nit: java public static void clearVisitDate(String[] selected) { if ( selected.length > selected.length) { geocodes.add(selected[i]); } setVisitDate(geocodes, 0); } }
Nit: java public static void clearVisitDate(String[] selected) {
nit: Maybe add the default value to the DistributedQueryRunner constructor and call it from createQueryRunner().
nit: add default value for DistributedQueryRunner.
nit: Maybe change this to: java return DistributedQueryRunner.builder(testSessionBuilder().build())
new byte[(int) Math.ceil(source.length / (double) chunkSize)?
using java.util.byte[(int) Math.ceil(source.length / (double) chunkSize)?
new byte[(int) Math.ceil(source.length / (double) chunkSize) can be faster.
I'm not sure if this is the right log level. If there is anything we should do.
I'm not sure this is necessary, if you switch the order of running '/' from the main UI, it should be something like this: LOGGER.info("{} is currently not supported", osType);
I'm not sure this is necessary, if you switch the order of running '/' from the main UI, it should be something like this: LOGGER.info("{} is currently not supported", osType)
I believe it would be more understandable to do the following: // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
See above about title, which would be more understandable than {sha", sha}
See above about title, region, and region.
Missing this.
Missing "this."
Missing this.value
Add "this" qualifier
Add "public" qualifier
add "this" qualifier
can be shortened to: ILogData loadedVal = fetch(address); data = readCache.asMap().computeIfAbsent(address, k -> loadedVal);
can be shortened to ILogData loadedVal = fetch(address); data = readCache.asMap().computeIfAbsent(address, k -> loadedVal);
can be shortened to: ILogData loadedVal = fetch(address); data = readCache.asMap().computeIfAbsent(address, k -> loadedVal) );
We might want to use setChange(hints) in the final object.
We might want to use setChange(hints) in the final method above.
We might want to add a set method in the RenderingHints constructor that calls setChange.
I don't think we should use lazySet here.
I don't think you should use lazySet here.
I don't think you need lazySet here since the next method is going to use this on every update.
If these objects can be added to the map, that would avoid the need for the offer cycle.
If these objects can be added to the map, the remove will get called more times.
If these objects can be added to the map, that would avoid the need for the count variable.
Not sure if this is the right place for this method. Why don't you just call model.getProcessFormModel().getProperties()?
Not sure if this is the right place for it, but we could use new HashMap<>() here.
Not sure if this is the right place for this method. Why don't you instantiate it at the class level?
suggestion return "None";
Why is this not @NonNull?
Why?
There's no need to enforce an ArrayList constructor. We can simply do this.signedHeaders = new ArrayList<>(signedHeaders);
There's no need to enforce an ArrayList constructor. We can simply do this.signedHeaders = Collections.unmodifiableList(signedHeaders);
There's no need to enforce an ArrayList constructor. Set it to be generic.
Here should be addProperty("uuid") and addProperty("display").
Here should be the above method
Here should be addProperty("uuid") and addProperty("display");
Can we move this to a private static method and call it from here?
Can we move this to a private static method and call it from the "org" instead?
Can we move this to a private static method and invoke it from the "org" instead?
Should be a space after,.
Should be a assertFalse(succeed)
Should be assertTrue(resulted.
I'm not sure if it's a good idea to accept a Map here. It also initializes a static field from an instance method and that feels strange. I think it's not necessary to have the lock in one place (such as a synchronized method or block).
I'm not sure if it's a good idea to accept a Map here. It also initializes a static field from an instance method and that feels strange. I think it's not necessary to have the lock in one place (such as the defaulting method everywhere) on the class.
I'm not sure if it's a good idea to accept a Map here. It also initializes a static field from an instance method and that feels strange.
Any reason to have this condition here? Do you need to test it?
Any reason you are checking this twice? Is it necessary to have the same call?
Any reason why this condition is not?
Enforce immutability.
Enforce immutable and non-nullable lists. If you do that, use Collections.unmodifiableList to enforce immutability.
Enforce immutable and non-nullable lists. If this method is called directly, it likely makes sense to enforce immutability.
Maybe just return regName.indexOf(SEPARATOR)? regName.substring(0, firstDot + 1)) : regName.substring(firstDot + 1);
Maybe just return regName.substring(0, firstDot + 1);?
Maybe we should extract this as a constant.
remove the explicit initialization?
This can be made more compact.
This can be made more compact: List<String> lines = new ArrayList<>();
There are no race conditions here. Do you want to store this in the SingleTokenStats?
There are no race conditions here. Do you want to store this in the cache?
There are no race conditions here. Do you want to store and save when the size is 2?
This should be a bundle util class
This should be a bundle util.
We should use a different exception handling than catching exceptions.
Just an observation that in the case the null is passed as "null" to the map, we will get a NPE on the first read placepoint for "null".
Just an observation that in the case the null is passed as "null" to the map, we will get a NullPointerException if the map is null. java return readStartpointMap(Collections.singletonMap(null, Collections.singleton(ssp));
Just an observation that in the case the null is passed as "null" to the map, we will get a NPE on the first read placepoint for "null"
Let's remove package modifier.
Can you please remove redundant package modifier?
Let's just remove the public modifier.
I think we shouldn't need the second commit if we follow up activity
Remove unnecessary public method
Remove unnecessary public static method
Is it possible that this is a remote connector?
Is this class thread safe?
Is it possible that this is null?
Why do we need this?
Why this change?
Why does this need to be synchronized?
this.
this. is package private
this.isNotempty
return PROVIDER_MAP.computeIfAbsent(provider, p -> new SegmentStoreTableDataProvider(trace, p));
return PROVIDER_MAP.computeIfAbsent(provider, p -> ((IAnalysisModule) p).schedule(this::schedule);
return PROVIDER_MAP.computeIfAbsent(provider, p -> ((IAnalysisModule) p).schedule(this);
change to var name
change to private
change to var value
Collections.emptyList()
Collections.emptyList() is imported statically.
Collections.emptyList() is used here.
This should also be synchronized
This may not be a problem with self-contained.
This may not be a problem with the PR description.
This should be public
This should fix the extra parentheses.
This should probably be public
Work is just a raw type. No need to cast.
Work is generic, so addPage method can be used directly.
Work is generic, no need to cast.
Use base64.trim().length() == 0
The replaceAll() can be done through a static final String
The replaceAll() can be done through a static String
Sorry for being picky, but does this need to be public?
Sorry for being picky, but do you want to check other decoders for null?
Sorry, I made another PR, but the Base64 decode method is not necessary of decode.
Might want to be consistent with displayName?
Might want to keep it localizable?
Might want to go with using this.name
Why do you need to reset the gc()?
Why do you need to wait for null?
Why do you call System.gc()?
what is this needed for? I think this can be just after the test.
what is this needed for? I think this is in line with higher level.
what is this needed for? I think this is in line with the method above.
I think this method is cleaner than the old code because it is shorter and easier to understand. @Override public void setTriggerConfigURL(String triggerConfigURL) { if (triggerConfigURL == null) { if (triggerConfigURL.equals(triggerConfigURL)) { this.dynamicConfigurationChangedFromLastStart = true; } else { this.dynamicConfigurationChangedFromLastStart = triggerConfigURL; } }
I think this method is cleaner than the old code because it is shorter and easier to understand. @Override public void setTriggerConfigURL(String triggerConfigURL) { if (triggerConfigURL == null) { this.dynamicConfigurationChangedFromLastStart = true; } else if (triggerConfigURL.equals(this.triggerConfigURL)) { this.dynamicConfigurationChangedFromLastStart = triggerConfigURL; } }
I think this method is cleaner than the old code because it is shorter and easier to understand. @Override public void setTriggerConfigURL(String triggerConfigURL) { if (triggerConfigURL == null) { this.dynamicConfigurationChangedFromLastStart = true; } else if (triggerConfigURL.equals(this.triggerConfigURL)) { this.dynamicConfigurationChangedFromLastStart = triggerConfigURL; } } return true; }
return!Boolean.parseBoolean(get(feature).trim());
return!properties.containsKey(feature).trim();
return!properties.containsKey(feature).trim();?
static
static?
static import
externalize "Actions"
externalize strings
externalize strings?
The Task class uses a Task.Builder to configure the side effect, and adding labels to the task. That way, this method doesn't need to be public, it should be package private.
The Task class uses a Task.Builder as well. Please add this to the Task class.
The Task class uses a Task.Builder as well. Please add this to the Task class instead.
I would check for null. And you can use State.isNone() in State class.
I would check for null.
I would add @since 2.8 here to indicate what is going on.
Is this call blocking? my fear is yes.
Is this call blocking?
Is this call blocking? Is it?
This should be declared as private static final.
Why are you changing this line?
This should be declared as private.
If we add a metric, we don't register it. What do you think?
If we add a metric, we don't register it.
Seems there exists a race condition here. When we add a metric, unregister() doesn't return the old value. What's the rationale for shutdown?
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <- remains unchanged logger.info("Not skipping file: {} ", source); <- just before the return;
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <LINK_0>
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source)
...and add size to message.
...and add size to exception message
...and again...
I'm not sure i'm following on this method. Why do you want to split PR out into two? It seems more complicated than one way.
I'm not sure i'm following on this method. Why do you want to split PR out into two? It seems more clear to me.
I'm not sure i'm following on this method. Why do you want to split PR out into two separate methods? i.e. Score Error and Score Error?
Can you please put spaces between if and ( please?
Can you please put spaces before and after if?
Can you please put spaces before and after if? I have the project auto-formatting in IntelliJ
Should also be catalog?
Should the URL be in the URL?
Should also be set in the Db for the URL
Does this have to be public? I think you can't think of a public method.
Does this have to be public? I think you can use a builder method which has this.
Does this have to be public?
This should not be public
This should be private because it is only used in the this class
This should be private because it is only used in the test
We should also compare with the same size as we have in equals().
We should also compare with the same size as well.
We should also compare with the same size as we have in toString().
same here. Please add a new constructor
same here. I think it's reasonable to pass a configuration object
same here
Should we use!dataFile.getMissingRunTypes().isEmpty()?
Should we use isEmpty instead of size > 0?
Should we use!isEmpty instead of size > 0?
I think we should return an empty list instead of null.
I think this should return an immutable list. We should throw UnsupportedOperationException when a method is not implemented.
I think we should return an immutable list here instead of null.
this field name is confusing since the parameter passed to the constructor is a File but this is a File.
this field name is confusing since the parameter passed to the constructor is a File but this is a PackExt
this field name is confusing since the parameter passed to the constructor is a File but this is a File
WKT has some other potential to be a pain.
public empty line
public
The concern here is that recipeFileContentProvider equals to RecipeFormatException
The concern here is that recipeFileContentProvider >validateDevfile() with the original implementation. Is there any reason to add it here?
The concern here is that recipeFileContentProvider >validateDevfile() with the original implementation. Is there any reason to add it to the implementation class?
Formatting
Missing a parameter.
Formatting?
This test checks topic creation. Why do you call replyTopicStubs?
This test checks topic creation, but then no call replyTopicStubs?
This test checks topic creation, but the TopicStubs are good enough for asserting parameters that are not null?
@m-g-sonar you can get rid of this.
@m-g-sonar you can do this.equals and hashcode should be at same time..
@m-g-sonar you can get rid of the variable also, it's one more time.
Last thing I think this is actually easier to follow: java if (healthCheck.shootTimeLock()) { // throw an exception }
Last thing I think this is actually easier to follow
Last thing I think this is actually easier to follow if you switch to an enum
Could we better use basePath.isEmpty() instead of list().length > 0?
Can we better use basePath.isEmpty() instead of list().length > 0?
Could we better use java.util.Optional#isEmpty() instead of list().length > 0?
LinkedList?
LinkedList is not needed here.
LinkedList is not needed here
Can we add a getSymMapReader method, getSymMapReader can be private?
Can we add a check for reader == null here?
Can we add a space after the {
Did you take a look at this? <LINK_0>
Did you take a look at this? <LINK_1>
Did you take a look at this <LINK_0>
Ternary operator is easier to read.
java return pageName.toLowerCase(Locale.ENGLISH);
Ternary operator?
This method is probably invoked only when sent the @Nullable but not in the current implementation. When we do this, we'll get NullPointerException if we do: @Override public List<String> getPushOptions() { return pushOptions == null? Collections.unmodifiableList(pushOptions); }
This method should be synchronized, otherwise the caller's local state cannot be changed.
This method is probably invoked only when sent the @Nullable but not in a general case, so why not return an empty list instead of null?
@ekondrashev let's use Tv.TEN instead of String literal
@ekondrashev let's use Tv.TEN instead
@ekondrashev put the same string in the previous line
Should be '!= null'.
Should be 'if (progressState == SWT.INDETERMINATE)'
Should be '== null'.
this is not necessary, the test for the existence of the db generation fails.
this is not necessary, right?
this is not necessary, the test is not finished.
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
shouldn't the test throw the exception, it will be marked as a failure too?
shouldn't the test throw the exception, it will be marked as succeed?
This is not a good idea to return an enum here to have it look at the shape of the security level
This is not a good idea to return an enum for the security level info
This can be static
This can be null if peerLeaderReplicasByPartition contains the partitionName.
This can be null if peerLeaderReplicasByPartition contains the partition name
This can be null if peerLeaderReplicasByPartition contains the partitionName
use guava for equal and hashcode... reduces code a lot
style nit: we don't use braces around single line blocks
use guava for equal and hashcode... reduces code a lot.
This method doesn't need to be public.
This doesn't seem to be public.
This method doesn't seem to be used.
please use Path.ROOT_PATH instead of "/"
Are we sure that this path separator is always correct?
Are we sure that this path separator is good for packaging logic?
Duplicated logic, shall we move it to a single method?
Duplicated logic, shall we move this to a single method?
suggestion logger.debug("Purged queue: {}", queueName + ", " + queuePurged);
we probably want to say something like this: "Traced a call to {} that {} ms. It will appear in system_traces with UUID={}",
we probably want to say something like this: "Traced a call to {} that {}took {} ms. It will appear in system_traces with UUID={}",
we probably want to say something like this: "Traced a call to {} that {} to{}. It will appear in system_traces with UUID={}",
Move this validation to PluginProperties.
Move this validation logic into the ConfigService.
Move this validation up in the create() method.
Why do we need to flush the index here?
Why do we need to cleanup this?
This method can be private.
Why is this hard coded? Can't we use the static variable from CONTAINER_STORAGE_QUOTA_IN_JSON here?
Why is this hard coded? Can't we use the static variables defined in Constants.java?
why is this hard coded?
Instead of having a rootObject here, we could just override the getAuthentication() method.
Instead of having a rootObject here, we could maybe make it final.
Instead of having a rootObject here, we could just make it final.
so we are changing the name a bit?
so we are changing the signature here to be consistent with the other listeners?
this.leadershipEventProcessor = Map.Entry
The client can call getFromValue() here, right?
The client can call getFromValue() here.
The client can call getFromValue() here. It seems that getFromValue() is working.
Don't we need to return true here?
Don't we need innerList.remove(o) here?
Don't we need to return true here as well?
I'm pretty sure it's worth to use some constants, like CUSTOM_OTHER_STATUS and use them in the read-only code.
I'm pretty sure this is a good idea. Should we throw an exception if it is not found?
I'm pretty sure it's worth to use some constants, like CUSTOM_OTHER_STATUS and use them in JSON and look them up by intent.
Maybe we should just set requestInProgress = false here. Since the message is an instance of Exception in the logDurations method, I think the third parameter should be set to true in the constructor.
Maybe we should just set requestInProgress = false here. Since the message is an instance of Exception in the logDurations method, I think the third parameter should be set to true in ChannelPromise?
Maybe we should also set requestInProgress to false here.
Use the constant for the insertType.
Use the constant for the insert type.
nit: Druid code convention is to have braces.
Are we sure we need keyStorePassVersion?
Are we sure that we need keyStorePassVersion?
Are you sure we need keyStorePassVersion?
Missing braces.
Too much whitespace between if and (
Missing braces, the code style is off here
please move checkName = ast.getParent().getType() == TokenTypes.LITERAL_CATCH; to the if.
please move checkName = ast.getParent().getType() == TokenTypes.LITERAL_CATCH; to the if
please move checkName = expression into method please.
This is also notTooManyNonLiterals, isOneLiteralTree should be atLeastHalfLongLiterals
If atLeastHalfLongLiterals is not needed, I think it will be also safer to test for nulls.
This is also notTooManyNonLiterals, isOneLiteralTree(operandsNum - literalsNum / atLeastHalfLongLiterals)
nit: don't use times(1)
nit: don't need times(1)
Is this exception verifying that the cause of the exception is not thrown?
add an error message
add an exception or log a failure
add an error message.
suggestion
java.util.Arrays.copyOfRange()
java.util.Optional.ofNullable(methods)
I am concerned that this change doesn't solve the problem. From what I can tell, it's only a single thread calling canceled.compareAndSet(false, true );. Maybe it makes sense to change the cancel method to return canceled.compareAndSet( false, true );?
I am concerned that this change doesn't solve the problem. From what I can tell, it's only a single thread calling canceled.compareAndSet(false, true );
I am concerned that this change doesn't solve the problem. From what I can tell, it's only a single thread calling canceled.compareAndSet(false, true )
Wouldn't it be better to make the constructor private instead of public?
Wouldn't it be better to make the constructor private?
Wouldn't it be better to initialize this with Collections.emptyMap() instead of copying the map?
please remove System.out
please remove this
please remove system.out
By composition, do we need this?
By composition, do we want to set it?
By composition, do we want to set this?
You can replace this with j.createOnlineSlave(new LabelAtom("test"), env);
You can replace this with j.createOnlineSlave(new LabelAtom("test"), env);.
Similarly, this should be initialized in the setup method.
Would it be better to return a null?
Maybe return an empty list instead of null?
Would it be better to return null?
again I don't think you need to guard against null, to avoid NPEs.
again I don't think you need to guard against null here. to use channels.isEmpty()
again I don't think you need to wrap here
Let's take this into account. Separately, this method is hard to read.
Let's take this into account. Done.
Let's take this into account. Preferably use of uuid to generate the key.
:+1: But I really prefer <code>value.toLowerCase()</code> here. Since this is a constant, it's better to use [this](<LINK_0>
:+1: But I really prefer <code>value.toLowerCase()</code> here. Since this is a constant, it's better to use [Assert.](<LINK_0>
:+1: But I guess we want to use Jenkins.isAvailable() in this case.
This seems redundant, because the break could be removed.
This expression could be declared outside the while loop, which is probably more clean.
This expression could be declared outside the while loop.
you could add the exception message to the exception.
you could remove the first sentence.
you could remove the first {}.
can we do it in one line? return parsePeriod(s);
can return Calendar.class.isAssignableFrom(dataType);
can we do it in the constructor?
This should not be public, we should make it package private.
This should not be public, we should make it package private. Note that we might want to use putIfAbsent here.
This would be another place to check that we're not already existent block.
Should use Level.FINE not Level.FINE.
Should use Level.FINE not Level.SEVERE.
Should use Level.FINE.
Here we can just return mObjectIdMapper.getObjectForId(id).get();, and then we can remove the verifyThreadAccess().
Here we can use getClassForNodeId.getObjectForNodeId(id) method for getting the instance.
Here we can just return mObjectIdMapper.getObjectForId(id).get();, and then we can remove the verifyThreadAccess() call.
Use newHashSet()?
Use Collections.emptySet()
Use newHashSet() instead.
wrong formatting - every parameter should be in new line
wrong formatting here - every parameter should be in new line
wrong formatting - every parameter should go to new line
This block can be moved into the synchronized block.
This block can be simplified to just invoke vdsbroker.buildSslContext(this.settings); in the synchronized block.
This block can be simplified to just invoke vdsm.buildSslContext(this.settings);.
An unescaped.newAccount works for clarity
An unescaped. matches anything, so [\\ implements it as a constant value.
An unescaped. matches anything, so [\\ doesn't compile.
Why this change? It seems to be unrelated to this change.
Why do you need this step? It seems to me that if you're going to add the new item to the model, WFLY-1069 it should be done.
Why do you need this step? It seems like it's more complex than it should be.
Don't we need to add this fontRegistry?
@pynicolas This fontRegistry is useless, it should be removed
public?
nit: this is Optional.ofNullable(metricName.safeTags().get(ADMN.TAG_CURRENT_SUSPECTED_LEADER)).filter(x -> x.equals(String.valueOf(currentLeader))).isPresent(); though I'll leave this as personal preference
nit: this is Optional.ofNullable(metricName.safeTags().get(AtlasDbMetricNames.TAG_CURRENT_SUSPECTED_LEADER)).filter(x -> x.equals(String.valueOf(currentLeader))).isPresent(); though I'll leave this as personal preference
nit: this is Optional.ofNullable(metricName.safeTags().get(ADMN.TAG_CURRENT_SUSPECTED_LEADER))
Shouldn't this be private? Or should it be private?
Shouldn't this be private? Is it used outside of this class?
Shouldn't this be private?
Can call the method directly, like f.getPopulatedErrorMessage(...);
Can call the method directly, without having to cast.
Can call the method directly, without having to repeat this code.
you added synchronized to the method here, wanted?
you added synchronized to the methods here, wanted?
you added synchronized to handle stime in parallel as well
@vrushaliwaykole @dhanasp -- There is a null check inside test method and we're not interested as part of this test. Let's remove the null check verification from test methods as there is no null check verification from test methods.
@vrushaliwaykole @dhanasp -- There is a null check inside test method and we're already making sure that the test is as part of this test. Let's remove the null check verification from the test method and instead let the test return a null value.
@vrushaliwaykole @dhanasp -- There is a null check inside test method and we're already making sure that the test is as part of this code. Let's remove the null check verification from test methods as there is no null check verification from test methods.
I think it would be better to have this method return an Optional<GlobalId> instead of a Long object.
I think it would be better to have this return an Optional<Long> instead of a Long object.
I think it would be better to have this method return a Nullable Long instead of a Long.
Another suggestion here to make sure it's a no-op.
Another suggestion here, to make sure it's a no-op.
Another suggestion here to make sure it's a valid output, but can you add tests for it?
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
nit: jut call super...setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
nit: jut call super( forceCloseTimeoutMillis) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
This assertion is redundant, since the get(0) checks the first element of the list.
This assertion is redundant, since the get(0) checks the first element.
This assertion is redundant.
I would prefer to let the logic of collecting exceptions hidden in the visitor. You can use if (visitedUnknown || thrownExceptions.isEmpty()) {
I think this can be simplified to: if (visitedUnknown || thrownExceptions.isEmpty()) {
I think this can be simplified to: if (visitedUnknown || thrownExceptions.isEmpty()) { return null; }
What are you testing here?
What are you trying to do here? Code looks like you're using two different methods, and more than one.
What are you trying to do here? Code looks like you're using two different classes, and more than one.
Please move the try catch to a separate method.
Please move the try catch to a separate method and remove the catch clause for RuntimeException
Please move the catch block to a separate method and use try-catch with a generic message.
unused
unused try-catch
should be close()
please replace the second part of if with: if (!Guid.isNullOrEmpty(clusterId))) { performActionForServicesOfCluster(); }
please replace the second part of if with: if (!Guid.isNullOrEmpty(clusterId)) { performActionForServicesOfCluster(); }
please replace the second part with java if (!Guid.isNullOrEmpty(clusterId))) { performActionForServicesOfCluster(); }
private
Missing @Override
private?
Is there a particular reason that you are using Select.parse(qnNumber) here?
Is there a particular reason that you are using Select.parse here?
Is there a particular reason that you only want to select the first question number after an offset?
This is valid.
This should be defensive.
This shouldn't be public.
Should be more meaningful, you can use the method directly
Should be a more meaningful exception
Should be more specific, you can use the method directly
I don't think this can be private. Why remove?
I don't think we need to clean this up and use FileRepository.createTempDir
I don't think we need to clean this up and use File.separator instead. This exists where you can use / instead of "/".
please export this method to a function to improve readability
please export this method into a private method to improve readability
please export this method into a private method to improve readability.
Why Collections.emptyMap()?
If we have this constructor, it can be public.
If we call this constructor in all cases, it can be private.
deleteFilePath(jobExecution)
deleteFiles()
nit: deleteResources()
I think it is confusing when startCount = Finalizers.INSTANCE.finalizingObject!= null when the Finalizers are created by other threads.
I think it is confusing when startCount = Finalizers.INSTANCE.finalizingObject!= null
I think it is confusing when startCount = getNeedToWork().get()
minor: this could use a constant like EMPTY_CACHE_ID
minor: this could use a constant like EMPTY_BYTES
Should this be a static constant?
This should also be res == 0?
This should also be res = "Sucess";
This should also be res = "Sucess"
Use Guava Streams.stream(entityTypes.spliterator(), false) instead of StreamSupport.stream(entityTypes.spliterator(), false)
Use Guava Streams.stream(entityTypes).map(entityType -> EntityTypeMapper.map(entityType)).collect(Collectors.toList())
Try to use Guava Streams.stream(entityTypes).map(entityType -> EntityTypeMapper.map(entityType)).collect(Collectors.toList())
No need for final here
<LINK_0>
No need for final
We can't use searchView.setVisibility here.
We should also hide the search view here.
We can't use searchView.
minor: you can use Paths.get(Path) instead of "/"
minor: you can use Paths.get(name).delete() instead of "/"
minor: you can use Paths.get(Path).delete() instead of "/"
You can remove this if block instead and set the default locale in the constructor.
You can remove this if statement and set the default locale in the constructor.
You can remove this if block instead and set the default locale on the client.
Please remove "my://" and "port parts" as we discussed.
I'm not sure the best way to check this. The URI does not have a host and port parts (which is already there as an URI) and fails to throw the URISyntaxException. Why not just check that?
Please remove "my://" and "port parts".
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully backoff when an application wants to manually configure a value. What that means here is that if the application has configured any algorithms, then the auto-fetch doesn't get run.
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully backoff when an application wants to manually configure a value. What that means here is that if the application has configured any algorithms, then the auto-detect the available ones.
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully backoff when an application wants to manually configure a value. What that means here is that if the application has configured any algorithms, then the auto-fetch doesn't get run, but the value is a constant too. In that case, what I think is better.
please remove this statement or enhance it to something more context/meaningful
please decrease log level to debug or trace
please remove this log statement or enhance it to something more context.
You only have to dump the truncation handle, right?
If you have the guard clause, you don't need this here.
You only have to check this after the replica count.
This method does not throw any exceptions so calling flush() can be outside the try block. Is there any style to do that?
This method does not throw any exceptions so calling flush() for the flush will fail. Can you please revert this?
This method does not throw any exceptions so calling flush() can be outside the try block.
From <LINK_0> I still think that a declarative programming approach with streams is a much more elegant implementation than Stream.
From <LINK_0> I still think that a declarative programming approach with streams is a much more elegant implementation than streams.
From <LINK_0> I still think that a declarative programming approach with streams is a much more elegant implementation than stream.
[Checkstyle] INFO: '200' is a magic number.
[Checkstyle] INFO: '200' is a magic number. Please use a constant instead.
[Checkstyle] ERROR: '200' is a magic number.
This should be == null || _upsertMode == UpsertConfig.Mode.FULL
( Usually upsertMode == null, I think we don't need to check upsertMode here.
( Usually upsertMode == null, I think we should have less than 1 field in the enum.)
I would use an 'else' clause: java if (CollectionUtils.isNotEmpty(sourceFormat.getDataInfo()) && fieldApprover.approve(sourceFormat.getDataInfo())) {... }
I would use an 'else' clause: java if (CollectionUtils.isNotEmpty(sourceFormat)) {... }
I would use an 'else' clause: java if (CollectionUtils.isNotEmpty(sourceFormats)) {... }
Can you move this stream to a private method to make it more readable?
returning List<WebElement> here would be slightly better
returning List<WebElement> from here is redundant.
Why call executeQuery.run() here?
Why do you need this check?
Why call executeQuery.run() here and not directly executeQuery?
This should be KeyPairApi.delete(keyPair.getName())
This should be 'Delete'.
This should be 'Delete'
As we have two arguments, one for copy, another for restore. I would rename the method to "copyId" to make it clear the purpose of "result"
As we have two arguments, one for copy, another for restore. I would rename the method to something like copyAttributesIds
please rename to builder
Why 5?
Why do you need the 5?
Shouldn't this be 5?
you could return false here and move the if into the first line
you could return false here and move the if into the if.
Why is this needed?
kieModule should be unused
kieModule should be a variable
Unused
This should be super(new MockVaadinServlet(deploymentConfiguration), deploymentConfiguration);
This class is never used in this class as it is in the same package. Please remove it.
This class is never used. Please remove it.
"While trying to perform POST: Unsupported operation for Admin service - OK"
"While trying to perform POST: Unsupported operation for Admin service -"
"While trying to perform POST: Unsupported operation for Admin service - POST"
>byte
Use fail()
Use fail() :)
We should not use this but use the message getString("ModelMergeToolCommandID")
We should not use the model-command ID in the message. We use the ID of the default value in the properties file.
We should not use the model-command ID in the message. We use the ID of the default value in the message.
return boolean.class.isInstance(VdsStaticData.class)?
return boolean.
return boolean?
We should reset servicemode in GrillServices also
Can we move this to tearDown?
Can we move this to tearDown method?
I'm not sure this doesn't account for the case where we have a Alert in the same package.
I'm not sure this is the right thing to do. Why is this called a public method, and not a public one?
I'm not sure this doesn't account for the case where we have a "set" details in the Q749. This can be fixed, but it's also used by the Cwe Location Location widgets.
Annotations on the wrong line
Annotations on the same line
Annotations should be on the same line
requireNonNull
what about this(count, skip)?
what about this(count, skip)
[GET_CATEGORIES_URL_SUFFIX](<LINK_0> is unintuitive. This should be: java return DiscussionsOperations.service(String.format(GET_CATEGORIES_URL_SUFFIX, context.getSiteId()));
[GET_CATEGORIES_URL_SUFFIX](<LINK_0> is unintuitive. This should be: suggestion return DiscussionsOperations.service(String.format(GET_CATEGORIES_URL_SUFFIX, context.getSiteId()));
[minor] Space before :
Arrays.toString?
Arrays.asList?
reverse?
Is this needed? I do not know how normally the name is printed in this case but how about throw an exception?
Is this needed? I think getAlias() can return " null" here.
Is this needed? I think getAlias() can return "null" when running in the wild. If so we need to use null here.
Missing.getMinecartHooks().
Missing.getMinecartHooks().targetView()
Redundant NL
nit: PRT support -> PRT support
why is a v1 PRT support?
nit: spell out PRT support for the V1.
Should be alfioGroupsNameParameter
List<String>
lfioGroupsNameParameter isn't used anymore.
You can refactor this into a method and use it in all places.
You can refactor this into a method and use it in the main class.
You can refactor this into a method and use it in the main class instead.
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "boolean" 3 times. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "true" 3 times. [![rule](<LINK_1>](<LINK_2>
(!rootDir.relativize(filePath).toString().replace("\\", "/");)?
You could use Double.valueOf(0) instead of Double.valueOf(0) for these two lines.
You could use Double.valueOf(0) instead of Double.valueOf(0) to make it clear that you are using "sum", not an empty object.
You could use Double.valueOf(0) instead of Double.valueOf(0) to make it clear that you are using "sum", not an object.
Nit: we should assert the name, it makes it clear that it's not empty when it is empty.
Nit: It is better to use assertThat(splits.size(), 1)
Nit: we should assert the name, it makes it clear that it's not empty.
instead of calling into this method, i suggest to remove the call to notifyOnSubscriptionsChangedListener, because the mOnSubscriptionsChangeListener is final
instead of calling into this method, i suggest to remove the call to notifyOnSubscriptionsChangedListener, then call it like: notifyOnSubscriptionsChangedListener();
instead of calling into this method, i suggest to revert this.
nit, deeply nested functional chain. Consider using a CollectionUtils.getMatches method.
nit, deeply nested functional chain. Consider using a CollectionUtils.getMatches method that accepts a List.
nit, would you mind renaming this variable to "descriptor"?
please insert the exception here, since you get it
please insert the error here.
please insert the exception here, since you get a context
Is it possible to just call Frontend.setFilterQueries(filterFrontendQueries()); here? And that might be a better place in the GerritGlobalModule instead of a void method.
Is it possible to just call Frontend.setFilterQueries(filterFrontendQueries()); here? And that might be a better place in the GerritGlobalModule instead of a void method with an empty listener.
"user.logout()" instead of user.hide()
this test should be executed when the merge is invoked, you should not call the method on a new Observable.
this test should be executed when the merge is invoked, you should not call the new method with 1 parameter.
this test should be executed when the merge is invoked, you should not call the method on a new thread
no need to declare the type of the setOptionStep to be an instance of GlusterVolumeEntity. This will allow reusing the same code in the test.
why not keep the reset methods in the test?
no need to declare the type of the setOptionStep to be an instance of GlusterVolumeEntity. This will allow reusing a single type of pattern set by user.
suggestion this.endpoint = endpoint;
suggestion public SearchServiceClientBuilder endpoint(String endpoint) {
Nice to add requireNonNull for endpoint.
If there's no exception, we may be updating or throwing an exception.
If there's no exception, we may be updating just one constructor?
make this constructor private?
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
You've added a bunch of methods in between the two overloaded versions of initializeAppResources(). Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to understand.
We should avoid using a StringBuilder if possible.
I think we should go away with the old method signature and return an ArticleContent.
I think we should go away with the old method signature and return an ArticleContent().
The exception message could be simplified to "The parameter named 'type' is null or empty or empty".
The exception message could be simplified to "The parameter named 'type' is null or empty or empty".",
The parameter named 'type' is null or empty or empty is a job-service.
This could be made package private.
I think we could use the empty constructor here.
I think we could use this constructor to make it public
@marchof I'd prefer to name local variable invisibleAnnotations or even better runtimeInvisibleAnnotations instead of just list
@marchof I'd prefer to name local variable invisibleAnnotations or even better runtimeInvisibleAnnotations instead of just flag
@marchof I'd prefer to name local variable invisibleAnnotations or even better runtimeInvisibleAnnotations instead of just flag.
This looks like a duplication of code to me. Instead of calling this method with a second forceSaveButtonDisabled() method, you could simply call the same method inside.
We do not need to return false here. Instead, instead of throwing a NoSuchElementException, we should simply return true.
This looks like a duplication of code to me. Instead of calling this method with a second forceSaveButtonEnabled() method simply by doing the same thing.
The locale should be logged here.
The locale should be logged using the builder.
The locale should be specified to the builder.
"execute is null"
Static import
Static import?
why do we even need this? IPath expectedPath = Path.fromPortableString(prefs); isJdtCoreSettingsResource = expectedPath.equals(expectedPath);
why do we even need this? IPath expectedPath = Path.fromPortableString(prefs); isJdtCoreSettingsResource = expectedPath.equals(expectedPath)
why do we even need this? IPath expectedPath = Path.fromPortableString(prefs); isJcCoreSettingsResource = expectedPath.equals(expectedPath);
What about moving this test to a helper method?
I think we should use assertj.
I think we should use assertj.core.util.ClassUtils#getQualifiedName
This should be implemented such that this method is called on the GTK level.
This should be implemented such that this method is called on the GTK lifecycle.
This should be implemented such that if(tick == 0) { do nothing; }
delete empty line
why empty string?
delete empty line.
Name it as TEST_A_topology
Can we change this to be logger.debug?
Can we change this to be logger.fine?
Why make this a _last_ partition? Isn't this the same test as the previous one?
Why do we need this line?
Why make this a _last_ partition?
By using a call to isIncrementOrDecrement, this check won't cover this case?
By using a call to isIncrementOrDecrement, this check will fail if we don't have a expression which is primitive or zero.
By using a call to isIncrementOrDecrement, this check will fail if we don't have a expression which is unused.
Make "Kafka" a constant
"Kafka"
Fix "Kafka"
The simpler way to create a feature is: AdditionalFeature feature = new AdditionalFeature(Guid.newGuid(), "libgfapi_supported", Version.v4_1, null, null);
The simpler way to create a feature is: AdditionalFeature feature = new AdditionalFeature(Guid.newGuid(), "libgfapi_supported_v4_1, null, null);
The combination of the "feature" parameter seems to be missing:: SupportedAdditionalClusterFeature feature = new AdditionalFeature(Guid.newGuid(), "libgfapi_supported", Version.v4_1, null, null);
No, that was the purpose of this change.
No, this method should be called setter.
No, that was the purpose of this change!
We don't want to use a string concatenation, as it's more readable to use a StringBuilder: StringBuilder sb = new StringBuilder("Encountered problems when parsing the annotation on class " + clazz.getCanonicalName(), a);
We don't want to use a string concatenation, as it's more readable.
We don't want to use a string concatenation, as it's more readable to use a StringBuilder.
I don't think this should be protected.
I don't think this should be protected as it's only used by the subclasses.
I don't think this should be protected as it's only used by the tests.
the name of the method is misleading. getItems() is not null.
the name of the method is misleading. :p
the else is not necessary.
I think "search operator requires a String" is wrong.
I think "search operator requires a String" is a good advice.
I think we should catch the specific exception type here.
In general, I think.map(a -> BigInteger.valueOf(a).pow(b)) is better.
Here is another example of using Streams.concat() which is a bit more readable.
Here is another example of using Streams.concat(a, b) which is not readable.
Why public?
Why public? Also, I don't see tests being used.
Why is this needed? Also, why protected?
suggestion throw new IllegalArgumentException("Serialization strategy can't be null");
throw new IllegalArgumentException("Serialization strategy can't be null");
suggestion throw new IllegalArgumentException("Serialization strategy can't be null!");
assertThat(cache, is(not(null))
assertThat(cache, is(not(null))?
What if we have this configuration option? Is it possible to refactor this?
This is a breaking change I guess.
This is changing the behaviour of getSamtoolsBin in this class. It should be protected instead of public.
This is changing the feature for this feature.
If the user is deleted, does this mean, the API contract for createInstance can be deleted?
If the user is deleted, does this mean, the API contract for createInstance can be regular?
If the user is deleted, does this mean, the API contract for createInstance can be replaced?
remove public
why not use an empty array?
why not pass an empty array?
just call.put(pid, arg) here
just call.put(pid,new Pair<String, String>()
just call getEntity() here
API breakage errors. You should declare another method and mark for deprecation this one.
API breakage errors. You could declare another method and mark for deprecation this one.
API breakage errors. Please declare another method and mark for deprecation this one.
this looks like it should be a separate thread
this looks like a different behavior as I think it should be a separate thread.
this looks like a different behavior as I think it should be sufficient
Maybe add a constructor to BaseRealm with frozen RealmLists?
Maybe add a message here as well?
Maybe add a constructor to BaseRealm with a current name?
else clause can be removed
else could be a little more clear.
else could have been a little more clear.
This line should be executed in handleFinishedContext()
This line should be executed on failedContext.getParentContext()
This line should be executed only if contextID is found.
Prefer using assertThat instead of assertTrue
Prefer using assertTrue instead of assertTrue
Avoid assertTrue
new line can be removed
you can create alias t2 for t1
you can create alias t2 for this test.
We should add a new constructor here for errorHandlers and options.
We should add a new constructor here for errorHandlers and options
We should add a new constructor here for errorHandlers and errorHandlers
Should this be called onSelectedItemChanged and onActionAvailability()?
Why is this call needed? You could just call updateActionAvailability()
Why is this call needed? You could just call updateActionAvailability() and save the code
Better to use String.format("Can't create reference for segment without ID", this.getId())
Please replace String.format with %s
Please replace String.format with String.format.
Nullable
Dislike using this.
Redundant, remove.
Shall we move this logic to SOURCE_OF_REPLICATION to keep it as a constant?
Shall we move this logic to SOURCE_OF_REPLICATION to keep it as a String?
Formatting
style nit: we don't use braces around single line blocks
Are the options!= null and options.getGetOperationType()!= null?
style nit: no braces around single line blocks
please rename done to something more meaningful like verify(Calculator).process();
please rename done to something more meaningful like verify(e);
please rename done to something more meaningful like verify(Calculator). process();
Extra line
Extra line of code.
Extra line.
No need to check if the node already exists.
This should return false.
This should throw.
don't use params as parameters. I'm not sure if it's easier or not but it's slightly more consistent.
don't use params as parameters. I guess it's easier to read the code in the same way.
don't use params as parameters. I'm not sure if it's easier to handle parameters in the future.
I think this can be replaced with: doReturn(vms).when(vmDao).getVmsWithPlugInfo(diskId);
I think this can be replaced with: doReturn(vms).when(vmDao).getVmsWithPlugInfo(diskId));
I think this can be removed as well
wdyt about adding init() and simply call [this](<LINK_0>
wdyt about adding init() and simply call getWindow() and getWindowContents() if they are not enabled?
wdyt about adding init() and simply call getWindow() and getWindowContents() if they are configured?
Good use of ftrace....
hardcore ftrace.trace....
hard coded string
same question
null check
same logic
From dataGeneratorListMap.get(topic): Maybe to make sure that dataGeneratorList can't be null.
From dataGeneratorListMap.get(topic): Maybe the code may be simplified by using a method reference: dataGeneratorList.forEach(CommonType::emitData).
From dataGeneratorListMap.get(topic): Maybe the code may be simplified by using a method reference: dataGeneratorList.forEach(ByteBuffer::emitData);
Those two should be equals (and even ==) rather than going through FQN
Those two should be equals
Those two should be equals (and even ==) rather than going through the FQN
this appears to be unused
Lets move this to after line 501
this seems to be unused
Wouldn't this be a pretty low-level constant?
Wouldn't this be a pretty low-level constant? Can the getMsgBytes() be replaced by 1?
Wouldn't this be a pretty good idea?
Where is the default?
Where do we handle exceptions?
Where do we handle failure?
- this code is a duplicate of previous ephemeralPath. - It could be broken if we use data.length() - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length == 0
- this code is a duplicate of previous ephemeralPath. - It could be broken if we use data.length() - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length == 0
- this code is a duplicate of previous ephemeralPath. - It could be broken if we use data.length() - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - ephemeralPath.length - path.length
can you make sure that the groupedJob is called more than once?
can you make sure that the groupedJob is called as well?
Looks like it's not critical.
Since we're modifying this line, could you just do this.belongsToRecentIndexSegment.compareAndSet(false, belongsToRecentIndexSegment.get());?
Since we're modifying this line, could you just do: this.belongsToRecentIndexSegment.compareAndSet(false, belongsToRecentIndexSegment.get());?
Since we're modifying this line, could you just do this.belongsToRecentIndexSegment.compareAndSet(false, belongsToRecentIndexSegment.isRecentIndexSegment());
What is the difference between addNotificationEventModifier and addNotificationEventModifier?
What is the reason for the brackets around boolean success?
What is the reason for the String instead of boolean?
Is this sleep necessary?
Is this thread safe?
Is there a way to make this sleep thread safe?
same opinion here :) (though break logic here seems correct)
same opinion here :) (though break logic here seems good)
same opinion here :) (though break logic here seems correct) :)
i'd prefer to return List<Order>, and remove public
i'd prefer to return List<Order>>, and remove public
i'd prefer to return List<Order>>, and remove public modifier
why do you have to remove this?
why this?
new File(tmpDir, "MANAGE");
java return!tickets.isEmpty()? false : false;
java return!base16.equals(world.provider.getDimension());
java return!isNullOrEmpty(world.provider.getDimension());
can't you use constants.empty() here as well?
Is that intentional to remove check for dhg.getDomainName() is null. We would have null string appended to dhost name.
Is that intentional to remove?
Here you can wrap the findAny call, it will be much more performant.
Here you can wrap the findAny call, it will be much more efficient.
Here you can wrap the findAny call, it will return null.
It's only called from the single thread to execute()? Are you sure it's safe to do it twice?
It's only called from the single thread to execute()? Are you sure it's necessary to do it?
It's only called from the single thread, doesn't matter!
@komaz We should also check here that release is not null before remove.
@komaz We should also check here that release is not null before remove
@weisebrazil There should be a test case for this one in the test above
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Remove this unused method parameter "input". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Remove this unused method parameter "ctx". [![rule](<LINK_2>](<LINK_0>
No need to add spaces around arguments.
No need to add spaces around arguments
No need to add spaces around operators.
return?
Why is this needed?
Why is this necessary?
Please check also left content, in order to be sure that left model has not been modified.Please verify all other tests that present the same problem.
Please check left content, in order to be sure that left model has not been modified.Please verify all other tests that present the same problem.
Please test left models (those who have been modified).Please verify all other tests that present the same problem.
why is getParent() called directly?
why is getParent() called twice?
why is this needed?
Could we avoid using a generic getClass() method here?
Could we avoid using a generic equals() method here?
Could you please remove this line?
I think it would be useful to move this check into the beginSpan() method? If the user didn't change the behavior of this method, then they'd need to change it as well.
I think it would be useful to move this check into the beginSpan() method? If the user didn't change the behavior of this method, then they want to push/recreate the span strategy, but I'm not sure that it would be useful.
I think it would be useful to move this check into the beginSpan() method? If the user didn't change the behavior of this method, then they want to push/recreate the span strategy, but I'm not sure that it would matter.
Since this method uses a Transciever to respond, should it be named'readCategories'?
Since this method uses a Transciever to respond, should it be called'readCategories'?
Since this method uses a Transciever to respond, should it be named'readCategories'? :)
You could do if (dataProvider == null) { fEntries.row(dataProvider).clear(); }
You could do if (dataProvider!= null) here.
You could do a dataProvider itself to avoid the null check? Or have you verified?
Same remark as for the other concrete class.
can we use LEFT_RIGHT_TOGGLE_BTN instead?
Same remark as for the value of variable.
Missing space after.
Missing { } after if
Missing final.
Should we do an Assert.assertTrue on the return value of verify()?
Should we still delete the user if the user didn't create the K client?
Should we still delete the user if the user is already deleting the data?
would it make sense to leave the list of devices as it was before?
the null check is not needed
the null check is not needed here
ENABLED.equals(getStatus())
ENABLED.equals(getStatus()) is redundant here
Minor: I think getStatus() can return null
I think this can be ACL.impersonate(ACL.SYSTEM) like in AbstractACL.run().
I think this can be ACL.impersonate(ACL.SYSTEM) like in AbstractACL.run()
I think this can be ACL.impersonate(ACL.SYSTEM) like in other places.
Same issue as with getChildren and getChildren.
Same issue as with trace
Same issue as with getChildren(),
Please add braces to if and clause.
Please add braces to if and statement.
Please add braces to conditional.
nit: Does this need to be?
nit: Does this need to be a constant?
nit: Does this need to be a separate?
Static import
the if is useless
the if is redundant
We need to set a flag internally on this listener. Then, when cacheEventModified() is called, we can just set a boolean value to true.
We need to set a flag internally on this listener. Then, when cacheEventModified() is called, we can just set it to true.
We need to set a flag internally on this listener. Then, when cacheEventModified() is called you can just set it to true.
The code about NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getOldNetwork().getLabel()) is identical to getOldNetwork().getLabel().
The code about NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getOldNetwork().getLabel()) is identical to getOldNetwork().getLabel()
The code about NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getOldNetwork().getLabel()) is duplicated, so I'd suggest extracting it to a method.
Minor: can use Objects.hashCode(key) here
Minor: can use Objects.hashCode(size) here
Minor: why public?
Take the look at the getContentResolver() method, this should be useful for usage.
Take the look at the api [here](<LINK_0>
Take the look at the getContentResolver() method, this should be called from the context, too.
These two lines probably can be combined into one.
These two lines probably can be combined into 1 line.
These two lines probably can be combined in one.
Can we rename this variable to memberValue?
why does the second parameter need to be Stream<T>?
why does the second parameter need to be Stream<Object>?
find a better name for this method.
I think it would be better to move this logic into the HyperLinkLabel class. lemme a method in HyperLinkLabel.java.
find a better name for this method?
Do we have tests for invalid input?
Do you want to enable what the error is?
Do you want to test that the file contains the input?
Check if credential and registryUrl are null before creating the serializer.
Check if credential and registryUrl are null before creating the serializer?
Check if credential and registryUrl are null before creating the serializer
We should be able to use instanceof comparison where possible. Please find all you use it in a single place.
We should be able to use instanceof comparison where possible. Please find all of these methods more complicated and understandable.
We should be able to use instanceof comparison where possible. Please find all of these methods more complicated and avoid the double compare.
I think it's safe to use float and double as the original code. Otherwise we will get into a double negative result.
I think it's safe to use float and double as the original code. Otherwise we will get a boxing warning.
I think it's safe to use %d here.
Please remove the extra empty line.
I understand if(bean.getAnnotatedType().getJavaClass() should be moved inside the if block.
I understand if(logger.isDebugEnabled()) on too line, but won't the following check getAnnotatedType().getJavaClass() a bit better?
This one should be private.
I'm not sure if there's a reason to use accessibilityAccumulator rather than just a singleton.
I'm not sure if there's a reason to use accessibilityAccumulator rather than simply a singleton.
Wouldn't it be more obvious to have this method public?
Is this method used anywhere?
Do we need this?
do we need to.set(true) here?
do we need to.set(true) around CloseWebSocketFrame?
do we need to.set(true) here? ;)
testK and v2 are not expected.
testK and v2 are not guaranteed by default.
testK and v2 are not guaranteed by itself.
Parameter validation should be done in ruleConfigs map.
Parameter validation fails instead of returning value
complaint, that method should return something.
Not sure if it is ok for this test, but as long as the test is in WaitUntil(new ShellWithTextIsAvailable(shell), TimePeriod.VERY_TEXT_")).click(); (Same with L67)
Not sure if it is ok for this test, but as long as the test is in WaitUntil(new ShellWithTextIsAvailable(shell), TimePeriod.VERY_TEXT_FLAG));
Not sure if it is ok for this test, but as long as the test is in WaitUntil(new ShellWithTextIsAvailable(shell), TimePeriod.VERY_TEXT_")).click(); (Same with L120)
A lot of this logic seems to be reused for each name. Is there a way we can generify it to save some code duplication?
A lot of this logic seems to be reused for each class. Is there a way we can generify it to save some code duplication?
A lot of this logic seems to be reused for each name. Is there a way we can generify this logic to save some code duplication?
I'm not sure why we're calling this here, but wouldn't it be better to call it "unloadingPool.execute(...);" inside the try-finally block?
I'm not sure why we're calling this here, but wouldn't it be better to call it "unloadingPool.execute" instead?
I'm not sure why we're calling this here - it's probably not good to call things in things like this.
onAttach is called before onCreateView so the first notification we sent might be for a characteristic with no value. Given that the app is first initialized in onStart I think we should use onAttach instead of app.
onAttach is called before onCreateView so the first notification we sent might be for a characteristic with no value. Given that the app is first initialized to a Settings, I think we should use a different option than post-aggregators.
onAttach is called before onCreateView so the first notification we sent might be for a characteristic with no value. Given that the app is first initialized to a Settings, I think we should use a different option than post-aggregators for this.
(the event was cancelled)- pool {0} with exception {1}
CancellationException can be thrown here since the event is not cancelled) - pool {0} with exception {1}
CancellationException can be removed
You have a static method for this except the very long places. This is why I forgot to change to return Direction.CAUSE if it has a non-zero value.
You have a static method for this except the very long places. This is why I forgot to change to return Direction.CAUSE if null is not possible
You have a static method for this except the very long places. This is why I forgot to change to return Direction.CAUSE
suggestion protected static void addFieldsFromRelation(SelectAnalysis context, AnalyzedRelation relation) {
suggestion public static void addFieldsFromRelation(SelectAnalysis context, AnalyzedRelation relation) {
suggestion private static void addFieldsFromRelation(SelectAnalysis context, AnalyzedRelation relation) {
I wonder if we should at least log an error instead of warn?
I wonder if we should at least log an error somewhere.
I wonder if we should at least get rid of this.
can you please replace this with: return StringUtils.join(mTopic, mPrefix);
can you please use StringBuilder here instead of all this code?
can you please replace this with: if(mTopic.isEmpty()) {
why not partitionTostore.remove(id)!= null?
why not partitionTostore.remove(id) == null?
why is it a public method?
This escape call should be in the try-finally block, i.e.: try { xml.openElement(this); } finally { xml.closeElement(this); }
This escape call should be in the try-finally block, i.e.: try { xml.release(); } finally { xml.closeElement(this); }
Just to be sure that there are no padding, consider switching to the html string?
Would it make sense to call checkLatitude( latitude, MIN_LATITUDE) first? If so, it would be better to call checkLatitude( latitude, MAX_LATITUDE) and throw an exception in the else case.
Would it make sense to call checkLatitude( latitude, MIN_LATITUDE) first? If so, it would make sense to call checkLatitude( latitude, MAX_LATITUDE) later.
Would it make sense to call checkLatitude( latitude, MIN_LATITUDE) first? If so, it would make sense to call checkLatitude( latitude, MAX_LATITUDE) and throw an exception in the else case.
nit: I think it's easier to just have a nanoTime()
nit: I think it's easier to just have a nanoTime() function
nit: I think it's easier to just have a nanoTime() function in this class.
could we make a constant and use it here?
could we use a constant for the comma?
could we make a constant for the max name?
This visits several methods. How are you clarifying what's driving the analysis? We could make it more convenient as well.
This visits several methods. It would be more convenient to reuse.
This visits several methods. How are you clarifying what's driving the analysis?
I'm not sure this check is necessary. If we decide to go from the _last_ value to the iterator of the list, then it is better to do something like: if ( alreadyAdded && alreadyAdded && mapperConfigPrism.uses() ) {... } else {... }
I'm not sure this check is necessary. If we decide to go from the _last_ value to the iterator of the list, then it is better to do something like: if ( alreadyAdded && alreadyAdded && mapperConfigPrism.uses() ) {... } else {... } And no one in the other methods...
I'm not sure this check is necessary. If we decide to go from the _last_ value to the iterator of the list, then it is better to do something like: if ( alreadyAdded && alreadyAdded && mapperConfigPrism.uses() ) {... } else {... } And the _if_ condition should be the same.
suggestion EMPTY_VALUE);
suggestion EMPTY_VALUE); Is a better test for EMPTY_VALUE?
suggestion EMPTY_VALUE;
try with StringBuilder
try to avoid the ""
try/catch
Shouldn't the TradeDate/tradeDate be null here?
Shouldn't the TradeDate/tradeDate be null here instead?
Shouldn't the ResolvedOvernightFutureTrade(...) call be moved outside the resolve?
dto is either null
dto is either null or empty
dto
Why does this method need to be public?
Why does this need to be public?
Why do we need to check for session existence?
You can push this directly to the frame so you don't have to worry about it.
You can push this directly to the frame so you don't have to worry about extra copying.
Should be SpongeImpl.
jiraConnection.getRestJiraClient().loadByKey(issueKey)
Also keep in mind that jiraConnection.getRestJiraClient() throws IssueTrackerUpdateException { } catch (JSONException e) { throw new IssueTrackerUpdateException(e.getMessage(), e); }
Also keep in mind that jiraConnection.getRestJiraClient() throws IssueTrackerUpdateException { } catch (JSONException e) { throw new IssueTrackerUpdateException( e.getMessage(), e); }
The helper method here can be private.
Extract this line into a method
Extract method
why is this noncompliant?
why not null?
why?
This should probably be 'unsortedMods'.
This should probably be removed since the player's mods list is already a member variable.
This should probably be removed since the mainMenu is the mods reference.
maybe move this into the synchronized block?
not sure why this synchronized block is needed here
not sure why this synchronized block is needed.
.getFileContent() is deprecated. Please use [this](<LINK_0> instead.
.getFileContent() is deprecated. Is it possible to use.getFileContent() instead?
s/fileContent/with-\u00F6/
To avoid code duplication, I suggest to follow pattern from the "getHostId" method: java @Override public void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) { return this; }
To avoid code duplication, I suggest to call super. getDataCenterById(dataCenterId) once and store the result
To avoid code duplication, I suggest to call super. getDataCenterById(dataCenterId) once and store the result in a local variable.
calling this command will not move the host to up. need to think about that.
calling this command will not move the host to up. need to think about that i guess
why public?
This doesn't need to be public. It's private for this class, because we're not using it outside of the class.
This doesn't need to be addressed now, but this class is not part of the public API. It's better to make it private for now, because it doesn't need to be public.
This doesn't need to be addressed now, but this class is not part of the public API. It's better to make it private for now. We might want to put tests for these too.
tableScanPlanNodeId
nit: should be done in a synchronized block
nit: should be synchronized
This is also used in the other resolveProjectedDimensions. I'd suggest to inline this: java private Set<ColumnProjection> resolveProjectedDimensions( Table table) { return resolveProjectedDimensions(groupByDimensions, table).stream().map(column -> resolveProjectedDimensions(table, column.getName())).collect(Collectors.toCollection(LinkedHashSet::new)); }
This is also used in resolveProjectedDimensions. Should we rename this method so that the method does not have to return a Set?
This should probably be private
Please add "autoteleportenabled" to the config key.
Please add "autoteleportenabled" to the config parameter, since default value is false.
Please add "autoteleportenabled" to the config parameter, since "config" is already available.
you could use the super constructor here
you could pass e as the second argument to super constructor.
you could use the super constructor here as well
Should this be in the constructor?
Should we throw a UnsupportedOperationException instead?
Should this be in the constructor, instead of this?
vanilla generator has no world type, right? This will throw an exception. Populator pregenerate it to default world generators.
vanilla generator has no world type, right? This will throw an exception. LightProcessor should use WorldWorldType.ipulfiller.
vanilla generator has no world type, right? This doesn't work. LightboxGenerator should have a custom world type.
This variable is useless. Please just use return in your if/ branches.
This variable is useless. Please just use return in your if and branches.
This variable should be final.
Should be done in the map.
Is it possible to use Map.putIfAbsent instead?
Is this still needed?
suggestion void performCheck() throws Exception {
suggestion doCheck(videobridge);
suggestion void doCheck() throws Exception {
Maybe skip the null check?
Maybe skip the null check (this will be handled by the caller)
Maybe skip the null check since it will be handled by the caller.
Should we introduce a method for this?
Should we introduce a method which is used to create the Text object?
Should we introduce a method which is used to create the Text object?
Take a look at ResponseData.Builder.
Take it from the ResponseData constructor.
Take a look at ResponseDataBuilder.
Can we check if the path exists here? suggestion public boolean createDirectory(Path path) throws IOException {
Can we check if the path exists and throw an exception if it is not?
Can we check if the path exists?
Can you move the Assert.assertNull into a method so we can log the class name?
Can you move this Assert.assertNull into the assert method?
Can you move the Assert.assertNull into a new method?
Should be public
Should cast to String
Should be public.
This should have a static logger method with a code
This should have a static method with a code style
This should have a static logger method for this
You can use the ECApi.postLog overload as well.
You can use the ECApi.postLog overload to add a new method.
You can compute the size of the List by calling the constructor directly.
Type is not used.
Type is not used. Just remove it.
Type is not used. Just remove.
should be similar to validation, we should also check that the schema is not specified in the input schema
isn't this check redundant? Doesn't the same check be done in configurePipeline
isn't this check redundant? Doesn't the same check be done in configurePipeline?
Is this still needed?
Is this still returning null?
Is this supposed to be if (subject.getPrincipals().isEmpty())?
Why public?
Why not return the message?
Why protected?
why do you need this cast?
why the List<ViewInfoWritable>?
this should be in a try-with-resource block.
I don't think it's necessary to instantiate the Message object here. If it's the case, no need to do it for each message
I don't think it's necessary to instantiate the Message object here. If it's the length of the Message object then it's better to just pass null to the encoder and leave it as null.
I don't think it's necessary to instantiate the Message object here. If it's the length of the Message object then it's better to just pass null to the encoder and leave it as is.
Why Pausable check?
Why is it public?
Why is this method final?
Wouldn't it be possible to suppress the warning for this case?
Wouldn't it be much easier to suppress the warning for replacement with Exception?
Wouldn't it be much easier to suppress the warning for replacement with CrossJoinE9?
Missing @Override
Missing Override
Missing ()
Same as above, assert that message.getMeta().getPublishedAt() is non-null?
Same as above, assert that message.getMeta().getPublishedAt() is not null
Same as above, assert that message is non-null?
nit: missing space after =
Nit: missing space.
nit: missing space after the {
I don't understand this. you're returning the translation in the context of the project, but you just return it. Can you explain this?
I don't understand this. you're returning the translation in the context of the project, but you just return it
I don't understand this. you're returning the translation in the context of the project, but you just return the language to find out the language.
can be simplified as java public static String startAppiumServer() { final String port; try { InetAddress inetAddress = inetAddress.build(); } catch (InterruptedException e) { throw new IllegalStateException("The server can not be a host: " + port); } }
can be simplified as java public static String startAppiumServer() { final String port; try { InetAddress inetAddress = inetAddress.build(); } catch (InterruptedException ex) { throw new IllegalStateException("The server can not be a host: " + port); } }
can be simplified as java public static String startAppiumServer() { final String port = StringUtils.getLocalHost()? address.start() : inetAddress; }
You can use a Set here
You can use a stream here
You can use a stream here to make this loop more efficient
Use for-statement instead of 11
Use SQLServerQueryModule.VERSION instead of 11.
Use SQLServerQueryModule.VERSION instead of 11
The validation is on the TraceCollection Port and not the one that provided one is returned by the method above. That's the reason it failed :P
The validation is on the TraceCollection Port and not the one that checks it. However, I think we should put the log message back into the FormValidation.ok method so that it can be reused in other places.
The validation is on the TraceCollection Port and not the one that checks it. However, I think we should put the log message back into the FormValidation.ok method so that it can be reused in other methods.
I think we should add a INFO log here.
I think we should be checking:!inputMetadata.isEmpty()?
Please add a INFO log here.
final?
final? and/or static import?
final
As I understand, planNodeCosts.getPlanNodes(root) is called twice in this constructor.
As I understand, planNodeCosts.getPlanNodes(root) is called twice in this method.
As I understand, planNodeCosts.getPlanNodes(root) is cheap and elegant.
It's the default value of the property to set in the constructor?
It's the default value of the property that the user has in place to access it.
It's the default value of the property that the user has in place to access it as part of the serialization format.
Doesn't this duplicate duplicate the logic in the if (deckName.charAt(index-1) == ':') { if (original dir.charAt(index-1) == ':') { return null; } }
Doesn't this duplicate duplicate the logic in the if (deckName.charAt(index-1) == ':') { return null; }
Doesn't this duplicate duplicate the logic in the if (deckName.charAt(index-1) == ':') { if (original dir == -1) { return null; } else { if (original dir == -1) { return null; } }
you need call addColorSettingsListener on the new instance.
You need call addColorSettingsListener on the new instance.
you need call addColorSettingsChanged on the new instance.
Can we maybe call this(createDateTime(WELCOME_URL)) instead?
Can we maybe call this(id, null, false) instead?
Can we maybe call this(createDateTime(WELCOME_URL)) and remove all the above call?
what if taskFuture.isDone() is true?
what if processFuture.isDone() is true?
what if processFuture.isDone() == true?
This is not correct. You need to close the lastWriteFuture regardless of whether the data is a HttpContent or not.
This is not correct. You need to close the lastWriteFuture regardless of whether the content is a HttpContent or not.
This is not correct. You need to close the lastWriteFuture regardless of whether the data is a remoteAddress or not.
call deleteOldDeployments
why not deleteOldDeployments?
why not deletePodDeployments?
Instead of 17, can we use Arrays.hashCode(entries)?
This will include the proxy-generated value for the hash code.
Instead of 17, can we change the hash code?
There is a typo in the error message.
There is a typo in (m_latitude < x) and m_latitude is different.
(m_latitude < 0 is a bit strange)
I'm not sure if there is a need to keep this if, because it is already done in the save method.
I'm not sure if there is a need to keep this if statement. It is marked as @Deprecated.
I'm not sure if there is a need to keep this if, because it is already done in the save(Note, AuthenticationInfo subject) method.
We do not unpack it for all the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to int is needed here.
We do not unpack it for the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to int is needed here.
We do not unpack it for all the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to an int is needed here.
declare failFilter inline
declare failFilter in the top of line
declare throws please
s/this Jobby does not implement getJobStats()/
s/this Jobby does not implement getJobStats()/g
I don't think this is the right exception to throw. It can be any more specific than Exception.
Argument name
"Argument name
String name
"([0-9]*\\.[0-9]+[0-9]+[K]+[B] |[0-9]+[0-9]+[K]+[B])" should be sufficient.
"([0-9]*\\.[0-9]+[0-9]+[K]+[B] & 100)"
"([0-9]*\\.[0-9]+[0-9]+[K]+[B] |[0-9]+[0-9]+[K]+[B])" should be sufficient...
so you don't have to use reflection?
so we don't have to support this yet?
so you don't have to use instanceof.
I think you meant to use SalesforceHybridSDKManager.getInstance().getLoginServerManager().getSelectedLoginServer().url()
I think you can just use SalesforceHybridSDKManager.getInstance().getLoginServerManager().getSelectedLoginServer().url()
I think you meant to use SalesforceHybridSDKManager.getInstance().getLoginServerManager().getSelectedLoginServer().url() instead.
We should also add a method public static oneId getone() { return ONE_ID; }
We should also add @since one_ID to the for loop.
We should also add @since one_ID to the private static final variable.
you can check the empty list
you can check the empty list here
you can check the size of the list
Guessing that something is happening a lot with this (which I don't think is), but is there a reason it's not running into start/stop?
Guessing that something is happening a lot with this (which I don't think is), but is there a reason it's not running into the sync button?
Guessing that something is happening a lot with this (which I don't think is), but is there a reason it's not running into start/stop? Maybe this should just be a volatile boolean.
It's not good to use final
It's not a good idea to use @GuardedBy syntax.
It's not a good idea to use @Override
I'd say this should be.setCatalogSessionProperty("hive", "aria_scan_enabled", false).
I'd say.setCatalogSessionProperty("hive", "aria_scan_enabled", "false")
I'd say this should be 'aria_scan_enabled', not 'aria_scan_enabled'
By removing the return value of this method, it is not clear that this method is returning a null value. This is returning null if this line is reached, but the function is empty.
Why is this private?
Why does this return null?
Is it better to use Opcodes.ISTORE instead of Opcodes.ASTORE?
Is this change useful? Please mention it in the commit message.
Is this better than using Opcodes.ISTORE?
return ((Number) val).longValue();
return ((Number) val).longValue()? -1 : -1;
return ((Number) val).longValue()?
Why not using the image object instead of creating a new one?
Why not using the image_storage_domain_map here?
Why do we need this method?
Let's not change the name of this query to "SELECT partkey FROM " + partkeyTestHivePushdownDistributedQuer"
Let's not change the name to partkeyTestHivePushdownDistributedQuer.
Let's not change the name to partkeyTestHivePushdownDistributedQuer, it's not a test.
Use templateFileName
Use the templateFileName variable
Use the template file
Consider the CollectionUtils.isEmpty() check instead
Consider the CollectionUtils.isEmpty method instead
Consider CollectionUtils.isEmpty
suggestion return new ExtendedBlockState(this, PROPERTIES, UNLISTED_PROPERTIES);
Do you want this to be nullable?
Do you want this to be nullable? Maybe use just a suggestion?
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (long) tileCount.
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (int) tileCount.
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (long) tileCount
please don't use thread-safe notation for logging.
please don't use thread-safe Closer here, it should be cleanup()
please rename -> container
Can be replaced with ComparisonChain.start().
Can we be more specific in the exception? Would catching an exception be more specific?
Can we be more specific in the exception? Would catching an exception have the same result?
I don't think we need this test.
I don't think we need this test to fail if the build failed, right?
I don't think we need this test, since it seems to be testing [DeploymentTest](<LINK_0>
What's the purpose of this init method?
What's the purpose of having this init method?
What's the purpose of having this init method?
missing check that vm exists.. (getVm()!= null)
missing check that vm exists.. (getVm() == null)
please remove extra brackets.
if (storageMethod!= null) { return new RemoteTouch(this.getExecuteMethod()); }
if (configuration == null) { return new RemoteTouch(this.getExecuteMethod()); } return this;
if (configuration == null) { return new RemoteTouch(this.getExecuteMethod()); }
Don't log the exception as it causes the connector to crash.
Don't log the exception as it causes it to be logged twice.
RuntimeException?
If disabledAdministrativeMonitors is empty you don't need the if statement to be removed.
If disabledAdministrativeMonitors is empty, this.disabledAdministrativeMonitors = disabledAdministrativeMonitors;
If disabledAdministrativeMonitors is empty you don't need to check the null here.
Could you explain why this is no longer necessary and rename the logOrProcess() method? The message should be something like: "Attention".
Could you explain why this is no longer necessary and rename the logOrProcess() method? The message should be something like: "Cannot rename folder"
Could you explain why this is no longer necessary and rename the logOrProcess() method? The message should be something like: "Cannot rename folder".
should use equals
variable name
should the assertion be reversed?
I'd propose to change the string "j-" to "Pool management process started (id: %s)"
I'd propose to change the string "j-" to "Pool management process started (id: %s)"?
There's no guarantee that the image is actually created. image may be not created because it would be an image.
Is it necessary to remove this method? When baseName is null I think it is.
Is it necessary to remove this, but baseName can be null when used in the constructor.
Is it necessary to remove this, but baseName can be null when used in the constructor?
consider adding this(storagePoolId, vmId, vmName) to the ctor
why not have this ctor be private?
why not public
spacing here looks off
spacing (s/b/c)
style nit: missing braces
This shouldn't be necessary.
This should be done in the ProviderHelper
This should be done in the ProviderDrawer
Is this method used anywhere?
Wondering if we could use targetSelector.refresh() instead?
Wondering if we could use targetSelector.refresh()?
please check if dockerConnector.getEvents is null before
please check if dockerConnector.getEvents is indeed called on every while loop
please check if dockerConnector.getEvents is null
It should be & 0xFFFF + 1
It should be & 0xFFFF + 1 here.
Did you think of moving this check to a static method?
Consider making a check for null check.
Consider making a check for null check first.
Consider making this a constant for both key/value checks.
Can you correct the order of the strings here? "Final '" + this.beanName + "' channel";
Can you correct the name of the enum here? "Final '" + this.beanName + "' channel";
Can you correct the order of the strings here? "Final '" + this.beanName + "' channel'"
You need also to call configureConsumer(answer); also as well.
You need also to call configureConsumer(answer); here.
You need to use configureConsumer(answer); also as well.
Should be ceilingKey().
Should be ceilingKey()
final
outClosed == null is redundant.
outClosed == null should be part of the while loop.
outClosed == null condition is always true because of the while loop.
Looks like everything in the toString() can fit one line.
Looks like everything in the toString() can handle this.
Looks like everything in the toString() can go one line.
Do you need a mock here?
Do we need a mock here? Can't we mock it in the test?
Do we need a mock here?
In VSMElementNameValidConstraint as you can return timegraph.getSelectedIndex() directly (in case of ModelElement.java)
The int result should be primitive int
In VSMElementNameWidget
I'm not sure we want to show the expiration in the logs. If the expiration is 'd' it's the default expiration it's System.err?
I think it's better to remove the logging from this method, or to combine the two calls to setExpirationTimer.
I'm not sure we want to show the expiration in the logs. If the expiration is 'd' it's the default expiration it's System.err?
Do you want RulesProcessor to have a RulesProcessor?
Do you want to swallow this exception?
Do you want this to throw the exception?
[65][index](<LINK_0>
[65, index](<LINK_0>
[65](<LINK_0>
.filter(mbeanPredicate, configPrefix)
.filter(mbeanPredicate, configs)
Is it safe to call this multiple times?
Static import
Static import.
Static import?
this is not really a service at all, please use method reference
this code is not fully thread safe, workflowDefinitions.values() can be null
this method should be private
I wonder what this is doing. What it does it mean?
I wonder how this is related to InvalidChangeField.MERGEABLE &.NET. Would it be better to use the same order as in the other classes?
I wonder how this is related to InvalidChangeField.MERGEABLE & NO_INDEX_GRANTED?
to remove, just use new ArrayList<>() in the constructor, two lines below
newArrayList(), just use new ArrayList<>() in the constructor, two lines below
to remove, just use new ArrayList<>(2) in the constructor, two lines below
new Double is redundant here
new Double is useless here
new Double is redundant
return Uri.EMPTY
return query;
No null
You can use Lists.newArrayList(dataService.findAll(DYNAMIC_DECORATOR).map(Entity::getIdValue).collect(toSet())
You can use Lists.newArrayList(dataService.findAll(DYNAMIC_DECORATOR).map(Entity::getIdValue).collect(toSet()) to remove the need for the static variable
You can use Lists.newArrayList(dataService.findAll(DYNAMIC_DECORATOR).map(Entity::getIdValue).collect(toSet()) to remove the need for the local variable
use same type for instanceof and force casting
use instanceof instead of PrivateKey?
use instanceof instead of PrivateKey
isAssignableFrom should be used here, otherwise you're now doing the cast.
isAssignableFrom should be used here, otherwise you're now doing the right thing.
Can't we get the class name from the store config?
add StringUtils.hasText(exTypes)
add @Override annotation.
add @Override
Even if it's already visible, I'd leave this up to the base class as it is.
Even if it's already visible, I'd leave this up to the base class as it was before.
Even if it's already visible, I'd leave this up to the base class as it is now.
Why is AnonymousAuthenticationToken not a ADAuthenticationToken?
Why is AnonymousAuthenticationToken not a AnonymousAuthenticationToken?
you are always returning true here?
would it be easy to interleave a bad operation with serverErrorCodes?
would it be easy to interleave a bad operation with future.
would it be easy to interleave a bad operation with a bad future?
@m-g-sonar I don't like the indentation here.
@m-g-sonar I don't like the name of this method.
@m-g-sonar I don't like the name of variable.
An IllegalArgumentException can be thrown here to avoid a NPE.
An abstract method that checks whether the returned object is null?
An IllegalArgumentException should be better than returning null.
How about using a compareAndSet?
How about using a ThreadPool here? I think we need to wait for the latch to complete?
How about using a ThreadPool here? I think we need to wait for the latch to complete.
Wouldn't it be better to have a contributor named something else, just like that?
Wouldn't it be better to have a contributor named apart than the one you'd want to downcast them to apart?
Wouldn't it be better to have a contributor named apart than the one you'd want to downcast them?
Nit: This could be handled in the other if statement
Nit: no need to add braces here
Nit: This could be called in a multiple line
in case closing one grouper throws ex, we would still want to close the remaining?
in case closing one grouper throws ex, we would still want to close the remaining? if yes, we could replace closing with forEach
in case closing one grouper throws ex, we would still want to close the remaining? if yes, we could replace closing with shutdownNow
If we are not using the assert, we should have a NO_OP implementation for the DownloadBatchStatusCallback
If we are using the assert, we should have a NO_OP implementation for the DownloadBatchStatusCallback
If we are using the assert, we should have a NO_OP implementation for the DownloadBatchStatusCallback.
What we are waiting here on?
Are we really need to wait here on all element element?
Are we really need to wait for 2 seconds here?
Can this test be a little bit less "testcases", maybe it should be named "grid1.json" instead.
Can this test be a little bit less "testcases", maybe it should be a named test?
Can this test be a little more descriptive name? (the ones that are used in other files)
qry -> query
qry ->Query
qry -> Query
The exception is never thrown.
Same as above. Should this be done with a try-catch?
The exception is never thrown, it can be removed.
Too long and nesting. Please consider refactoring into more lines.
Too long and nesting. Please consider refactoring into more compact code.
Too long
Suggestion: You can change this to this.keySet = Arrays.asList(key).
Suggestion: You can change this to this.keySet = Arrays.asList(key);
This keySet is an immutable object. You can use Collections.addAll
why not use paramsMap.values()?
why not use paramsMap.compute?
why not use paramsMap.compute()?
I think this should be "Clear alarm register result is OK for device: " + device.getDeviceIdentification());
I think this should be "Clear alarm register result is OK for device: " + device.getDeviceIdentification();
I think this method should be called clearAlarmRegisterRequestDto, in case of an error.
Is there any reason why the beans have different beans? Why are we not using ConfigurableListableBeanFactory.getClass().values()?
Is there any reason why the beans are added to ConfigurableListableBeanFactory? I don't see a reason to move to ApplicationSecurityInterceptor the way you are using ableBeanFactory.
Is there any reason why the beans are added to the listableBeanFactory. Notice?
Should the getIdentity() method be moved to the SyncSessionSession class?
Should the getIdentity() method be moved to the utils class?
Should the getIdentity does this check for null?
When you will use I18N.tr with _I18N.tr, you will have to use I18N.tr with _I18N.tr. <LINK_0> I recommend using I18N.tr with _I18N_ and _H18N_tr to use I18N.tr. <LINK_1>
When you will use I18N.tr with _I18N.tr, you will have to use I18N.tr with _I18N.tr. <LINK_0> I recommend using I18N.tr with _I18N_ and _H18N_tr to use I18N.tr.
When you will use I18N.tr with _I18N.tr, you will have to use I18N.tr with _18N_.tr. <LINK_0> I recommend using I18N.tr with _I18N.tr.
Why don't you just pass the InterruptedException to the constructor?
Why don't you just pass the InterruptedException to avoid one?
Why InterruptedException?
Same here, this check on the scale and should be done.
Same here, this check on the scale and should be done with other objects.
Same here, this check on the scale and should be done with other object.
no need to explicitly create an empty map for var args
no need to explicitly create an empty map for var
no need to explicitly create an empty map for var and just add an item
getProxyForRootService(client, TimelockRpcClient.class) or TimelockRpcClient.class?
getProxyForRootService(client, client); seems unnecessary?
getProxyForRootService(client, client); seems unnecessary
requireNonNull
remove public
remove the public modifier
Why did you move this to separate patch?
What about?
Why did you consider it?
isAvailable is technically true, so can be removed
isAvailable is technically true?
isAvailable is redundant
After commit squash the commits, there's no need to change this if/else block, as it is a no-op.
After commit squash the commits, there's no need to change this if/else block, right?
After commit squash the commits, there's no need to change this if/else block.
Is it really necessary to call assignedState(tp).preferredReadReplica = null here?
prop: For consistency, consider calling assignedState(tp).preferredReadReplica = null instead of setting it to null.
Is it really necessary to call assignedState(tp).preferredReadReplica = null after this?
I don't think this method needs to be protected, it should be private.
I don't think this method needs to be public, it should be protected.
I don't think this method needs to be protected, it should only be called by subclass.
return steps.filter(s ->!uploadingPost.getId().equals( postModel.getId())).findFirst().orElse(null);
How about if (!uploadingPost.hasPendingMedia()) { return null; } to reduce nesting level?
How about if (!uploadingPost.getId().equals( postModel.getId())) { return null; } return steps.getPendingMediaForPost(pageModel, 0);
Adding this to a field is good manner.
Adding this to a field is better than a getter.
Adding this to a field is bad manner.
should be "skip_after_chars"
does this need to be public?
can be "forbidden"
can simplify the code like this: java return Arrays.stream(partitionRangeList).map(x -> toFeedRange(xRange));
can simplify the code like this: java return ImmutableList.copyOf(partitionKeyRangeList.stream(), partitionKeyRangeList.stream());
can simplify the code like this: java return Arrays.stream(partitionRangeList).map(x -> toFeedRange(xRange));
I prefer to inline this variable. The method returns the XMLGregorianCalendar, which will always be used as the same as the other.
I prefer to inline this variable. The method returns the XMLGregorianCalendar, which will always be used on the same line.
I prefer to inline this variable. The method returns the XMLGregorianCalendar, which will always be used as the same as other.
I would suggest name this findElement(By.id("feedback-copy-modal-status") in findElement(By.id("feedback-copy-modal-status") in findElement(By.id("feedback-copy-modal-status") in findElement(By.id("feedback-copy-modal-status") in Utils.java
I would suggest name this findElement(By.id("feedback-copy-modal-status") in findElement(By.id("feedback-copy-modal-status") in findElement(By.id("feedback-copy-modal-status") in findElement(By.id("feedback-copy-modal-status") in Utils.java [Alterion](<LINK_0>
I would suggest name this findElement(By.id("feedback-copy-modal-status") in findElement(By.id("feedback-copy-modal-status") in findElement(By.id("feedback-copy-modal-status") in Utils.java
@szczepiq Would you mind checking index.drop() here? Or, again, perhaps it's better to just call index.drop()?
@szczepiq Would you mind checking index.drop() here? Or, again, perhaps it's better to call index.drop() again?
@szczepiq Would you mind checking index.drop() for the sake of readability?
style-nit: we don't use braces around single line blocks
style nit: we don't use braces around single line blocks
style nit: we don't use braces around single line blocks.
Static import
Try to use StringUtils.format()
Static import?
Why the change?
Why are we throwing an exception here?
Why are you changing this?
new Boolean() instead of.toString()
new Boolean() and public canCloneVolume() should be declared private
new Boolean() and public canCloneVolume() should be declared private.
I think these should be package private.
I think this should be private.
I think this should be package private.
I think it would be better for this method to be more generic, something like ParsingUtils.appendToPath(filename, extension)
I think it would be better for this method to be more generic, something like ParsingUtils.appendToPath(filename, extension).
I think it would be better to look for ParsingUtils.appendToPath(filename, extension).
minor but I'm not sure if creating a new class or method is much better than creating it.
it would be nice if we could do a List<Object> here or for an empty list.
it would be nice if we could do a List<Object> here or with a toArray method.
If the storedAccount is already non-null, then we can skip that check.
If the storedAccount is already non-null, then we need to check that it is not null. We can simply rely on the get method.
If the storedAccount is already non-null, then we need to check that it's non-null.
Same here, return ImmutableSet.of(this.resultStream);
Please return ImmutableSet.of(this.resultStream, this.resultStream);
Please return ImmutableSet.of(this.resultStream);
this is exactly the same as the next line
Do you need this line?
Do you need this?
rlly nit-picky: would have made this method private unless you are using it.
rlly nit-picky: would have made this method private
:point_up:
I think this method should return null
I think this method should be private.
I think this method should return null (ie no proxyHost was set).
assertFalse(...);
remove empty lines
assertFalse(...);?
This is a little strange, it should be using String.format().
This is the same as the old line of code. We should use String.format() instead.
This is the same as the old line of code. We should use String.format() for that.
This method is called from the super class, so why do we need to pass the context?
This is a bit hard to follow, but why do we need to return an ListenableFuture here?
This method is called from the super class, so it should be renamed to something like hasRequestMetadata
"data" is in a plural noun.
"data" should be a constant.
"data" is a weird term in Patching.
As I understand the code, this is not needed.
As the selection is done in the HttpService.java, I think this is not needed.
As the selection is done in the HttpTools side, I think this line can be removed.
I think you can use Lists.newArrayList( getOffsetString(name)) to avoid the creation of a list
I think you can use Lists.newArrayList( getOffsetString(name)) to avoid the need for a new ArrayList
I think you can use Lists.newArrayList( getOffsetString(name)) to avoid the creation of a list.
In spelMessage.UNKNOWN_OR_FIELD_NOT_READABLE you can use here.
I would have used warn instead of WARN.
I would have used warn instead of warn.
nit: it's easier to read if you inline.anyMatch(c -> coverageId.equals(c.getCoverageId())));
nit: it's easier to read if you inline.anyMatch(c -> coverageId.equals(c.getCoverageId()));
nit: it's easier to read if you inline.anyMatch(c -> coverageId.equals(c.getCoverageId()))
if requests are null, don't we want to return null?
string can be null, and always return empty string
string?
I think GENERATING_CONTENT is better to have a flag that checks whether the event is in the model and not whether it is in the model. The current logic can apply to the block as well as in ReportProgressEvent.
I think GENERATING_CONTENT is better to have a flag that checks whether the event is in the model and not whether it is in the model. The current logic can apply to the block as well as in ReportProgressEvent.java.
I think GENERATING_CONTENT is better to have a flag that checks whether the event is in the model and not whether it is in the model.
Why are we returning null when input is trimmed?
Why are we returning null when input is invalid?
Why not use trim() for trim, as above?
Don't forget to remove this println.
Don't forget to remove this println!
Don't use System.out.println... remove it.
You could use [Guava's AreaEvent](<LINK_0>
You could use [Guava's AreaDialog](<LINK_0>
You could use [cert](<LINK_0>
Although AsyncClient is deprecated retrieving event loop has some additional checks. Could you please check AsyncClient.get() for an example.
Although AsyncClient is deprecated retrieving event loop has some additional checks. Could you please check AsyncClient.get with a method call.
This and below lines of if statements can be merged.
bankState?
debug?
Make the log message a private static final String.
I would prefer: if ((insideTryStatement &&!isResourceResolver(tree)) && resourceResolversInTryWithResources.contains(getResourceResolver(tree))
I would prefer: if ((insideTryStatement &&!isResourceResolver(tree)) && resourceResolversInTryWithResources.contains(getResourceResolver(tree)))
I would prefer: if ((insideTryStatement && isResourceResolver(tree)) && resourceResolversInTryWithResources.contains(getResourceResolver(tree))
Again, let's pass the CountDeviceTypeRequest to the Response constructor.
Again, let's pass the CountDeviceTypeRequest as a parameter.
Again, let's pass the CountDeviceTypeRequest to connectToRequest().
This method should not be public
This method should not be public.
Should this method be private?
if the debug level is enabled, log ok
if the log message is going to be printed, log ok
if the log message is going to be printed, log ok?
isn't this breaking backward compatibility? If this method is called anywhere in the future, why is it public?
isn't this breaking backward compatibility? If this method is called anywhere in the future, why is it needed again?
This breaks backward compatibility, why is this needed?
Should this be through the other constructor?
should this be synchronized?
should be great.
I don't think we need to schedule a tick for every BlockState. The way it is implemented now is to avoid explosion of requests because the currentPos could be avoided by failing on BlockStateProperties.WATERLOGGED.
I don't think we need to schedule a tick for every BlockState. The way it is implemented now is to avoid explosion of requests for every BlockState.
I don't think we need to schedule a tick for every BlockState. The way it is implemented now is to avoid explosion of requests for every BlockState, and provide a pre-existing BlockStateProperties.
We do not use this. on Alpha() but it is a common common method. I would skip this and use Color.RGBA()
We do not use this. on Alpha() I think you can get rid of the cast here.
We do not use this. on Alpha() but it is a common common method. I would skip this.
(nit) suggestion if (_partitionMetadataManagerMap.containsKey(partitionId) { _partitionMetadataManagerMap.put(partitionId, new PartitionUpsertMetadataManager(partitionId)); return _partitionMetadataManagerMap.get(partitionId); }
(nit) suggestion if (_partitionMetadataManagerMap.containsKey(partitionId)) { _partitionMetadataManagerMap.put(partitionId, new PartitionUpsertMetadataManager(partitionId)); return _partitionMetadataManagerMap.get(partitionId); }
(nit) You can change this to a ConcurrentHashMap.computeIfAbsent().
Do we need a null check of user? I think a cast would be sufficient.
Do we need a else here? I think a cast would be sufficient.
Do we need to check this every time? I think a cast is needed.
suggestion: super.getAllContacts(1, new, User.Error>() {
suggestion: super.getAllContacts(1, newContactsFromServer){
suggestion: super.getAllContacts(1, new, User.Error());
is the default timeout really needed?
is the default timeout (several instances)?
is this really needed?
Let's remove this check and just call the extractor to saveAuthorizedClient?
Let's remove this check.
Remove this check.
This is returning the student that was created in the database before the getAccountId() operation was triggered. We should get the calling account from the database before calling getAccountId() on it.
This is returning the student that was created in the database before the getAccountId() operation was triggered. We should get the calling account from the database before calling getAccountId() on that client.
This is returning the student that was created in the database before the getAccountId() operation was triggered. We should probably return the student ID right?
This should be a warning instead of an warn.
This should be a warning instead of an error.
Why not using LogicalWindow#isHelpAvailable()?
init is called in the init() method of this class.. no need to call it here.
init() is called in the init() method, but it is a no-op.
init is called in the init() method of this class.
Can be rewritten with Arrays.asList().
Can't we use Collections.singletonList() here?
Can't we add Constants.REMOTE_TYPE?
> list.size()==0 [](start = 30, length = 7) can you put.isEmpty() on a variable instead of adding a function call? Also what do you think? :)
> list.size()==0 [](start = 30, length = 7) can you put.isEmpty() on a variable instead of adding a function call? Also what do you think?
isEmpty()
@antonini please name it user
@Suseika hmm, I see, that this block is exactly the same as the following: java if (retValue.isEmpty()) { retValue = new Opt.Empty<Identity>(); }
@Suseika hmm, I see, that this block is basically same as the following: java final Opt<Identity> retValue = new Opt.Empty<Identity>();
it should be trace as well, to avoid unnecessary call to releaseView
it should be trace as well, but in the current log message is the only way to create a view for a given task.
should we add in the log message as well?
I'd use 1 here.
I'd use 1 here. What do you think?
I'd use 1 as the name, and default valueCalculator
super() is unnecessary
super(); is unnecessary
super() is unnecessary.
jobtracker = Cluster.getIdentifier( jobtracker);
jobtracker = jobConf.get(JOBTRACKER_KEY, V3)
jobtracker = jobConf.get(JOBTRACKER_KEY, cluster);
Maybe add "this" to other metric names instead of "header-only".
Maybe add "this" to be consistent with other metric keys?
Maybe add "this" to other metric names instead of "tokens"?
This method is too hidden. It should be private
This method is too hidden. It should be private.
This method is too complicated. I'd prefer to keep it simple if-else.
Why not return new HashMap<>(result)?
Why not return immutable Map<ComponentType, String>?
Why not return an empty map instead of null?
return;
return?
else
Could you use mpinput with mpinput?
Remove "throws IOException"
Remove the throws?
I think this condition should be: if (arg.is(Kind.REGULAR_STRING_LITERAL) && ((LiteralTree)arg).value().length() - 1 >= MIN_LENGTH_OF_HARDCODED_PASSWORD)
I think this condition should be: if (arg.is(Kind.REGULAR_STRING_LITERAL) && ((LiteralTree)arg).value().length() - 1) >= MIN_LENGTH_OF_HARDCODED_PASSWORD)
@vilchik-elena Why not java if (arg.is(Kind.REGULAR_STRING_LITERAL) && ((LiteralTree)arg).value().length() - 1) >= MIN_LENGTH_OF_HARDCODED_PASSWORD)
This should be minimum
This should be minimum to avoid magic numbers.
This should be the first constant
- please remove TODO - please use [this](<LINK_0>
- please remove TODO - please use file handles, instead of close the stream. - please add.close() to the RuntimeException block.
- please remove TODO - please use file handles, instead of close the stream. - please add.clear() to the _this_ method for this
nit: this could be just numBytes == NUM_BYTES
nit: this could be just Ints.BYTES - numBytes
nit: this could be just numBytes == 3)
LOCK_NAME is 0 when LOCK_NAME is set.
LOCK_NAME is what I meant here.
LOCK_NAME = 1 should work, though.
Not atomic. Two threads can reach line 100.
I think this should be separate declaration. It appears to only read initialization time in PrometheusMetricsTrackerFactory.
Does this still need to be synchronized?
Instead of getEncountersModifiedOnOrAfter, wouldn't it be better to return a List<Encounter> instead of List<Encounter>?
Instead of getEncountersModifiedOnOrAfter, wouldn't it be better to have a getter?
Instead of getEncountersModifiedOnOrAfter, wouldn't it be better to return a List<Encounter> instead?
Nit: Is there a reason we use 200 instead of 200?
Nit: Is there a reason we use this feature instead of using schedule()?
Nit: Is there a reason we use this feature instead of using schedule?
static import SECONDS
static import SortOrder.
static import SECONDS. I think it would be nice to be consistent.
don't you want to check if the status is not null?
can be replaced with: return getVmList().stream().noneMatch(vm -> status.getStatus()!= status)
can be replaced with: return getVmList().stream().noneMatch(vm -> vm.getStatus()!= status)
Use logger please
Your code is waisfyi, but for me it would be better to read a bit better and map the entire file to the directory instead of just the entire array. You can also use the iterator to read the directory and call Files.walk(directoryPath) instead of stream.
Your code is waisfyi, but for me it would be better to read a bit better and map the entire file to the directory instead of just the entire file... You can also use the directory because of line 136, 148 and 160 can be removed.
Looks like the spacing got messed up here
Looks like the spacing got messed up
Add project name (C) to the subject.
NetUtil is imported statically, so could be removed
NetUtil is imported, so could be removed
NetUtil is imported.
please check the nulls at the right places.
please check the nulls at the right places
please check if null.
Need to handle 'win32'. It's better to return the statemask for all OS.
Need to handle 'win32' here.
Use "win32".equals(stateMask) instead.
You shouldn't call onError with onComplete.
You shouldn't call onError inside the composite thread.
You shouldn't call onError inside the second function. This has the same problem that you have added.
I think we should use a constant for this, WDYT?
I am not sure if this is the correct place for a safety check. Cleaner would be to use -1 to indicate whether this is an error or not.
I am not sure if this is the correct place for a safety check. Possibly this should be a null check?
again, why do we need this?
why is the monitor needed here?
why is the monitor needed here?
nit: this doesn't need to be public, as it's only used by tests.
nit: this doesn't need to be public, as it's static.
Wouldn't it make sense to replace the putIfAbsent call with a a synchronized function?
There is already a forEach() on this collection, you can put that inside a single filter.
There is already a forEach statement which can be used here.
There is already a forEach() on this collection, you can put that inside a simple for-loop.
Can we test if the captured PAID is null? Is this value already guaranteed to be present when your entity is closed?
Can we test if the captured PAID is null? Is this value already guaranteed to be present when you're expecting to set the PAID?
Can you please confirm if the PAID is active? Is this value already guaranteed to be DEBIT_CARD.
negative logic
negative condition
negative value
How about return result.mStatus.mCode == 0);?
How about checking result.mStatus.mCode == 0?
How about checking result.mStatus.mCode == 0 (to be consistent with the previous version)?
return streamConsumer;
return streamConsumer;?
Can we make this return a List?
assertThat(map).hasSize(0);
assertThat(map).containsExactly(0)?
Since we're testing that the same contents is correct, could we do a assertEquals here?
I think we need to also check the email is not null
I think we need to also check the email is not null.
I think this dialog should not be visible.
404 => NotFoundException
404 not found
POST
Do we want to return null?
Would it be better to return an Optional<Integer> instead?
Would it be better to return an Optional<Integer> and check for null?
You don't need this method at all.
You don't need to check that this is not null.
You don't need to check that this is mutable, and you can't do an ImmutableMap.Builder.
Can we use multi-catch here to avoid explicit close() usage?
Can we use multi-catch here to avoid explicit close() calls?
nit: all these elses should be on the same line as the {}
nit: I'd prefer to call this method createTimeoutWithNoTimeouts with no timeout.
nit: I'd prefer to call this method createTimeoutWithNoTimeouts
nit: could be final?
Our coding style is to have a single line: if (getConstantLength() == -1) { return; }
Our coding style is to have a single line: if (getConstantLength() == -1) { return 0; }
Our coding style is to have a line break between if and else blocks.
Suggest setting the default to null.
Use the ObjectMapper.load() method.
Write to use the ObjectMapper.load() method
you're not asserting on null here: ByteBufferAccessor byteBufferAccessor = message.write(byteBufferAccessor, cache, version);
prefer "Expected to see a NullPointerException when writing " + message + " at version " + version, so we're less error-prone.
prefer "Expected to see a NullPointerException when writing " + message, version > " + version.
why not using!undefinedScenarios.isEmpty()?
Shouldn't we throw an exception in this case?
Shouldn't you clear the type here?
Do we need to cast this.enderman to GriefProvider?
Do we need to check for null here before casting?
Fix method name with the prefix..
nit: for readability, rename variable to scanScreenAdapter or something better name.
nit: for readability, let's name it get rid of the name.
Too long.
I'm concerned about this change. Any reason to make it synchronized?
I'm concerned about this change. Any reason we can't make a MutableObjectId variant here? It would allow us to make a MutableObjectId variant and have it return a MutableObjectId.
I'm concerned about this change. Any reason we can't make a MutableObjectId variant here? It would allow us to make a MutableObjectId variant and have it return a MutableObjectId. This is consistent with the current RevWalk and the caller can change its value.
Should be EXPERIMENT, EXPERIMENT, ETERNITY, false);
Should be EXPERIMENT, EXPERIMENT, ETERNITY, true) instead.
Should be EXPERIMENT, EXPERIMENT, ETERNITY, true) instead
Should this be initialized in the first place? Or is there a reason to null check?
Should this be RevWalk? Or is there a reason to make this protected?
Should this be RevWalk instead? Or is there a reason to make this constructor protected?
Why first the file?
static imports
suggestion
move the labelControl!= null check here
move this call to the top.
move this call to the top; the labelControl is not null
queue.offer(p)
'p' is already added to queue.offer(p)
'p' is already added to queue.offer(p)'
Is this a little more readable? Maybe use NumberUtil.getMaxStackSize here instead?
Is this a little more readable? Maybe use NumberUtil.getMaxStackSize()
Is this a little more readable? Maybe use NumberUtil.getMaxStackSize here?
&&
&& copy!= source
&& copy == source
Could you make the string a constant and use it here?
Could you make the text a constant and use it here?
Could you make the text a constant in the class?
Probably best to just use String.format() or do this with StringBuilder also.
Replace with String.format() or use Objects.toStringHelper()
Probably best to just use String.format() here. Also this would be cleaner if you just do sb.append(propertyName).append("sortOrder=");
This should be moved to the generateInputs() method
This should be moved to the start method
This should be moved to the beginning of the loop
You can remove the call to super() with no arguments
You can remove the call to super();
You can remove the call to super() with no arguments.
Should there be a null ProfileDataException?
Are you sure that there is no default implementation?
Should there be some default value here?
We should log the error using LOG.error(String, Throwable)
We should log the error using LOG.error(String msg, Throwable t)
We should log the error using LOG.error(String msg, Throwable exception)
nitpick: I would change this message to "Response contains containers"
Can we please also check that response contains all of the containers?
nitpick: I would change this message to "Response contains containers with all containers"
This should probably be 'if (!Boolean.TRUE.equals(option.observable.getValue())) return option.value;'
This should probably be 'if (!Boolean.TRUE.equals(option.observable.getValue()))'
This should probably be 'if (!Boolean.TRUE.equals(option.observable.getValue())) return option.value;
Minor: you can use Objects.equals for comparing the objects.
Minor: you can use Objects.equals for comparing.
Minor: you can use Objects.equals for comparing object IDs.
We should be able to test if theMixClass is provided by multiple different tests using different MixClass. It should be assertSame here.
We should be able to test if theMixClass is provided by multiple different tests MixClass. If the MixClass is provided, it should be assertSame here.
We should be able to test if theMixClass is provided by multiple different tests using different MixClass. It should be assertSame(i1, i2);.
This method should be private
This method should be static
This method should be private.
Change this to return heartbeatInterval + heartbeatInterval / 5;
Why change this? Possibly protected for heartbeatInterval?
Why change this?
Would it be more efficient to do: if ( services.isEmpty()) { services = internalClassLoaderService.loadJavaServices( serviceContract ); } return services;
Would it be more efficient to save the size of the list as a variable instead?
!isEmpty()?
<LINK_0>
The form should not be public.
The form should be package protected.
should this be public?
should be public.
should be public
if we know that the workspace has an enabled role, then we should throw an exception and get the correct error message from the method.
if we know that the workspace has an enabled role, then we should throw an exception and get the correct error message.
if we know that the workspace has the right permission, then we can get a warning and break right away.
nit: You can probably extract this into a named constant.
nit: You can probably extract this into a constant.
nit: You can probably extract this into a named constant with a meaningful name.
@carlosmiranda we need to inline ex. File(site.mail_dir, orig + ".example").example();
@carlosmiranda we need to inline ex
@carlosmiranda I think you need to return directly
1. Why do we need to check this? I think it should be done in onSkipWriteItem. 2. Do we need to do this check for instanceof Exception?
1. Why do we need to check this? I think it should be done in onSkipWriteItem. 2. Do we need to do this?
I think this is broken. It should be the same.
Same here? It is always number or null?
Same here? It's always number or null?
Same here. It is always number or null?
Use InvalidArgumentException instead
Not sure how this would work.
Use InvalidArgumentException instead?
I think that if we're not totally sure that params is not null, then we should remove this check.
This is not unit tested. If we wanted to use params.getExtras() it will not be null.
This is not unit tested.
Why is this method needed? It is only used in the first place, so I would remove it and have the method be private.
Why is this method needed? It is only used in the first place, so I would remove it and make it private.
Why is this method needed? Should it be protected?
Make it public
this.targetFolder = targetFolder;
this.targetFolder = getModel()
can't you have the VM's name as vm?
can't you have the VM's name as "setImagesIllegalIfNotInDb"?
can't you have the VM's marked as failed (see line 184)?
I think 06_ID should be 64 for consistency.
I don't like the strategy to set the properties. All the other getters use this one at the very least
I don't like the strategy to set the file length. All the other versions of this method should be going to be broken.
I would use com.google.common.base.Strings.isNullOrEmpty here.
I would use com.google.common.base.Preconditions.isEmpty(str) here.
I would use com.google.common.base.Preconditions.isEmpty(str)
Make this a graph, not a graph.
Make this as a graph, not a graph.
Can you please change this to graph?
minor: please use toString() not just for the sake of readability.
it would be safer to write AliasedDiscoveryConfig{enabled=" and usePublicIp=" with properties="
minor: please use toString() instead of +
IMPORTANT isEmpty() && events.isEmpty() * 2
IMPORTANT isEmpty() &&!events.isEmpty() -- we need to be able to return immediately after the first occurence of the eventBundle() call. When we arrive here, the eventBundle doesn't have been sent yet..
IMPORTANT isEmpty() &&!events.isEmpty() -- we need to be able to return immediately after the first occurence of the eventBundle() call.
I am thinking if not better to get init parameter of form: schemes.* instead of split into 2 lines.
I am thinking if not better to get init parameter of form: schemes.* instead of split into two lines.
I am thinking if not better to get init parameter of form: schemes.* instead of split into 2 lines. public void init(final Deployment filterConfig) { additionalSchemes = filterConfig.getInitParameter("schemes"); } public void init(final Deployment filterConfig) { writer.add(new BufferedLineReader(filterConfig)) }
We still need to check the type when creating a policy. Why don't you just return the result?
We still need to check the type when creating a policy. Why don't you just return the result?
We still need to check the type when creating a policy. Why don't you simply return the result?
Remove this selector and use the constant instead.
Use String.format() instead of concatenation.
Remove this selector and use the constant from the element element.
GENERATION_SUFFIX -> GENERATION_SUFFIX.
Formatting... suggestion OptionsHelper optionsHelper = new OptionsHelper(operatorHelper);
GENERATION_SUFFIX -> GENERATION_SUFFIX
Should this be moved into the try-catch?
Should this be moved into the try block?
throws IOException instead of catching and wrapping
In order to avoid the need to return a variable and then you can safely use: return SymbolReference.unsolved(ResolvedValueDeclaration.class);
In this case it's going to throw an exception if the iteration is empty. In that case you can either fix the test for empty/null values or return null.
In this case it's going to throw an exception if the iteration is empty. In that case you can either fix the test for empty/null values or crash with a NPE.
This should be logged at info level.
This should be logged at WARN level
This should be logged at WARN level.
validateCommitCursor throws InvalidCursorException
validateCursor throws InvalidCursorException
validateCursorAsNulls().
No reason to return null, throw an exception instead.
No need to return null, you can just return from delete().
No reason to return null, throw a NullPointerException or UnsupportedOperationException.
This is unnecessary, just return the result of getAlternatePrincipal(certificate)
This is unnecessary, you should return the result of getAlternatePrincipal(certificate)
This is unnecessary, just return the result of getAlternatePrincipal()
this line is missing the default case. I think you need to add it in the case where the property is not set
this line is missing the default case. I think you need to add it to the parent class.
this line is missing the default case
How about use Guava's Objects.equals()?
What about Arrays.equals() as well?
What about comparing className and class name to compare?
You should return a copy of the internal collection
You should return a copy of the internal list
You should return a copy of the internal list.
You can use this.
rm public
package visible only
Not sure how this info is useful for this one, this could be a WARN instead of an ERROR.
Not sure how this info is useful for this one, this could be at the debug level
Not sure how this info logs are. Any reason it could be at info level?
Should be logged as SEVERE.
Should be an IllegalStateException.
Should be an info.
I think the CosemDateTime constructor should be private, and as such there is no need to create a new one to protect the field in this class from changes from outside.
I think the CosemDateTime constructor should be immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
I think the CosemDateTime constructor should be private, as the method is not necessary to change the field in this class from outside.
nit: at the end of message, please set the '" + RuntimeOptions.RUNTIME_MODE.key() + "' to 'BATCH'. " +...
nit: s/set to 'BATCH'.
nit: s/set to 'BATCH'. "
nit: Should be nonTransactionalRemoveGroup(true, explicitFlags, context)
We should add a method nonTransactionalRemoveGroup(String key, long explicitFlags) to InvocationContext, and do everything in this method.
We should add a method nonTransactionalRemoveGroup(String key, long explicitFlags) to the InvocationContextBuilder, and do everything in the private method.
nit: the indentation is not necessary.
Is the revisionActions initialize to an empty array?
Is the revisionActions initialize to null?
We can remove this empty line.
LoginUserInfo.getLoginName() should be moved to class level
We can remove this line. It it's not necessary :)
this will only set the size on the array list, which should be set by setting the min/max size.
this will only set the size on the array list, which should be set by the caller's default.
this will only set the size on the array list, which should be set in 2.
I think you want to use the name of the method here, e.g.: private final GHIntArrayList reverse() { return this.buffer; }
I think you want to pass the size of the buffer as the first param to the method.
I think you need to pass the size of the buffer as an argument.
why is this check needed?
if (failNext > 0)
why is this needed?
Collections.singletonList(new TmfEventTableColumn(fAspect));
Collections.singletonList(new TmfEventTableColumn())?
Unnecessary, can be @NonNull.
If we're changing this in the future, it would probably be worth adding a fail() after this line?
If we're changing this in the future, it would probably be worth adding a fail() after this line
If we're changing this in the future, it would probably be worth adding a fail() after this line and just making sure that the return value is what we expect.
_force_ to use Integer.toString( fqdn)_ instead of Integer.toString( fqdn )
_force_ to use Integer.toString( fqdn)_ instead of Integer.toString( fqdn)
_force_ to use Integer.toString( fqdn)_ instead of Integer.toString( fqdn );
This can also use covariant return types
I would not use covariant return types here since you can write suggestion this(other.getHaplotype(), other.contamination);
I would not use covariant return types here since you can write suggestion //.qualify. (here and in the next line)
Can we use a standard org.junit.Assert.fail instead?
Can we use a standard URL scheme here?
Can we use a standard org.junit.Assert.assertThrows(FailureException) here instead?
Please add braces to the if.
Please add braces.
Please add braces (or the if else block)
Why is this method public?
Why is this necessary?
Why not this?
I think we should check null to avoid NPE.
I think we need to check if _participants[0] is null here
I think we need to check if it is null here, right?
This makes no sense. If 'getLazyDataView()' or 'inspectDataView()', it makes sense to override the subinterface method, and only use the classes that expose the right type. I'd suggest to add a private method to getSupportedDataProviderType, and use it here.
This makes no sense. If 'getLazyDataView()' or 'inspectDataView()', it makes sense to override the subinterface method, and only use the classes that expose the right type. I'd suggest to add a private method to the data view and use that in the actual implementation.
This makes no sense. If 'getLazyDataView()' or 'inspectDataView()', it makes sense to override the subinterface method, and only use the classes that expose the right type. I'd suggest to add a private method to getSupportedDataProviderType, and use it here. The only invoker that knows what is wrong is the actual implementation.
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
@garydgregory Please use Args#notNull for consistency with the rest of the code base.
@garydgregory Please use Args.notNull for consistency with the rest of the codebase
can we remove the new-arg constructor from the method-call?
can we remove: declare-response, useless- assignment
can we remove the null-check?
Minor readability suggestion suggestion alarmCounter.addPropertyChangeListener("alarmCount",!active)?
Minor nit, please remove this empty line
Minor nit, please remove this empty line.
rename to methods
rename to method
rename to method or action
Separate file. Please change it to something more descriptive.
Do we need to make input file names cryptic? Please rename it to something more meaningful.
Do we need to make input file name EOL, DEF, EOL, DEF?
shouldn't this be'setExploreFormat'?
shouldn't this be 'isExploreFormat'?
Should the signature be protected?
whitespace
verify the operation is executed since the operation is executed [here](<LINK_0>
verify the operation is executed [here](<LINK_0>
The.equals() method should check whether it's a64bit.
Maybe we should have a constant for this?
The.equals() method should check whether it is a64bit.
Should be new VersionID(String.class)
Should be one of the other.
Should be new VersionID( className)
shouldn't we also be able to attach the disk after the rotation?
shouldn't we also be able to attach the disk?
shouldn't we also save the disk alias after the call to vdsm?
I don't think it's a good idea to print out the System.out here. We should either print out the CacheDistributionTask object or pass it as a parameter.
I don't think it's a good idea to print out the System.out here. We should either print out the stack trace or use a logger.
I don't think it's a good idea to print out the System.out here. We should either just print to the logger or wrap it with a logger.
It seems like this could be private. Does this need to be public?
It seems like this could be public. Does it make sense to have this public?
It seems like this could be private.
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the file).
Better to get the bytes with toString with StandardCharsets.UTF_8 (that's what will be used to read the file).
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the file)
currentImport.getImportGroup() method can be used here.
currentImport.getImportGroup() may be null if this is called more than once.
currentImport.getImportGroup() method returns a list which is more readable.
Why are we not using the public access modifier for this method?
Why do you need to keep this?
Why are we not using the public access modifier?
Why public?
Why the double sync is necessary?
Why the change to syncExec?
new LinkedList<>()
illegalstateexception?
we don't need a builder here
Why are we passing in the fatalErrorHandler or dispatcherBootstrap which is a bit confusing.
Why we are passing in the fatalErrorHandler or dispatcherBootstrap which is a bit confusing.
Why are we passing the fatalErrorHandler in onFatalError?
Please make this method protected since the test is in the parent class.
Please make this a method is called after the restart.
Please make this a method "refreshAllFeeds" without the restart.
I think that's unnecessary. BIOS_TYPE_INVALID_FOR_CLUSTER is always true for bios type, so the check in line biosType can be removed.
I think that's unnecessary. BIOS_TYPE_INVALID_FOR_CLUSTER is always true for bios type, so the check for null is not necessary.
I think that's unnecessary. BIOS_TYPE_INVALID_FOR_CLUSTER is always true for bios type, so the check for null is not needed.
The AzureObjectId belongs in the UmsGroup super class, not the Group itself. We use equality to make it easier to maintain.
The AzureObjectId belongs in the UmsGroup super class, not the Group itself. We use equality to make it more efficient to reference the SmsGroup instance.
The AzureObjectId belongs in the UmsGroup super class, not the Group itself. We use it only here. I think that the equality of the group is accurate to make it the same.
remove redundant nulls and nulls.
remove redundant nulls
Add a nulls check as well.
Throws AIOOB exception when called with index = -1.
Throws AIOOB exception when called with index = 0. Maybe add a check in the method below.
Throws AIOOB exception when called with index = -1. Maybe add a check in the method below.
Why send this to serverError().build()?
Why send this to serverError?
Why?
Spelling:
state!= from
Spelling: splitted
you could combine this into an else if
why sometimes super.emitContent() == false?
unnecessary
To follow code style, could you please make it consistent?
To follow code style, could you please make it consistent with the rest of the code?
To follow code style, could you please make it consistent with the rest of the code base?
Are you sure that appUrl is not null?
Are you sure that appUrl.getRootUrl() is only called if not authenticated?
Are you sure that appUrl is only used?
should be synchronized
should be synchronized.
final?
Why do you need this change?
Why do you need this check?
Why not just do return computeHash()?
Can we make it final?
Can we make it public?
Make it public?
this else block is still neccessary
do we also want to catch the more specific exception?
do we also have a window where we're still viewing?
Can we check if they are passed in to the constructor? The only way to do that is if they need to pass in the assigner.
Can we check if they are passed in to the util method? The only way to do that is if they are passed in.
Can we check if they are passed in to the util method?
If this is not covered by above, it is better to throw UnsupportedOperationException rather than throw an IllegalArgumentException.
If this is not covered by above, it is better to put it before the loop.
If this is not true, should it be missing?
Is shutdownNow more appropriate (which would interrupt running tasks)?
Is there a reason for using interrupts?
Is there a reason for not using Thread.currentThread().interrupt() instead?
Please annotate @Nullable
Please annotate @Nullable.
Please change to DruidMetrics.ID.
You should also verify the exception message as well.
You should also check the exception message here.
You should also check the thrown.expectMessage(...) here
rename suggestion } else { published = true;
rename final?
rename suggestion } else {
Redundant brackets suggestion return tryActivateAndGet(e, item)!= null;
Redundant brackets suggestion return tryActivateAndGet(e, item);
Redundant brackets suggestion return tryActivateAndGet(e, item).!= null;
I'm not sure we should also change the digestId based on the hash type of the pipeline. So this is a  chars.
I'm not sure we should change the digestId based on the hash type of the pipeline. So this is a  chars.
I'm not sure we should also change the digestId based on the hash type of digests.
We build the StringBuilder and then use it on line URN_OASIS_NAMES instead of adding an intermediate variable.
We build the StringBuilder and then use it on line URN_OASIS_NAMES.
We use the toString method in the custom error message.
These two calls to super() are redundant.
These two calls to super(context, 0.5f, 0.5f) are both same.
These two might look better with.set() calls.
please remove checks here.
please remove checks here too
please remove checks
rename count to targetPath, as we have no guarantee that count is actually added.
rename count to targetPath, as we have no guarantee that count is actually duplicates.
rename count to targetPath, as we have no guarantee that count is > 0
java authCardDetails.getAddress().flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry).map(NorthAmericaRegion::getAbbreviation).ifPresent(stateOrProvince -> worldpayTemplateData.setState(stateOrProvince));
java authCardDetails.getAddress().flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry).map(NorthAmericaRegion::getAbbreviation).ifPresent(smartpayTemplateData::setState)
java authCardDetails.getAddress().flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry).map(NorthAmericaRegion::getAbbreviation).ifPresent(stateOrProvince::setState);
Why did you remove the final modifier?
Why did you remove the static modifier?
Why did you remove the final keyword?
why is this necessary?
one argument per line. No need to create Layout here and below.
again, what is the purpose of this future?
The position parameter is in NatTable coordinates and could be out of range in the scrollableLayer. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportPosition.row);
The position parameter is in NatTable coordinates and could be out of range in the scrollableLayer. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportLayer);
The position parameter is in NatTable coordinates and could be out of range in the scrollableLayer. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(position.row, NatTable.OFF_ON_HEADERS);
These two properties should be consistent. The default value should be greater than the current default.
These two properties should be consistent. The default value should be greater than 0.
These two properties should be consistent. The default value should be " *or.credentials."
Why not use the getMap() method, rather than doing this check here?
Don't we need to check if the valuesMap is null?
Why not use getMap()?
Enforce immutable and non-nullable lists.
[minor] You could pass fileInfo as an argument to the create method.
[minor] You could pass fileInfo as an argument to the immutable method.
this will throw a NullPointerException if the value is null. Can you check the return type before toObject()?
this will need to be nullable.
Minor: Please use static imports for null-checks.
nitpick... this should be renamed to simply gammaId, it's not necessarily gammaId
nitpick... this should be renamed to simply gammaId, it's not necessarily new.
nitpick... this should be renamed to simply gammaId, it's not necessarily vmId
Let's set the default value to constants in the test.
Let's set the default value to constants in the tests.
Let's set the default value to constant and use it here.
assertFalse(...);
printStackTrace will reset the interrupted state for the RuntimeException
printStackTrace will remove the need for printStackTrace
It feels like there is a lot of code duplication here that should be pulled into a method
It feels like there is a lot of code duplication here that would be nice to have a method for checking the cache state, that's already passed in
It feels like there is a lot of code duplication here that should be pulled into a method. Not sure if that's the case, but just feels like it could be.
nit: this should be new Object[]{NA12891.over.fingerprints.r1.sam", false}, {
nit: this should be new Object[]{NA12891.over.fingerprints.r1.sam", false}, {new Object[][]{new Object[] { } });
Thanks for the cleanup!
Is it really needed to create a new instance of this class?
Is it really needed to create a new instance of this PR?
Is it really needed to new RandomClient()?
What about using testHelper.getCurrentDialectType() == GridDialectType.NEO4J_REMOTE?
What about using testHelper.getCurrentDialectType() == GridDialectType.NEO4J_REMOTE?
What are you trying to do here? It seems to me that we return 1 or 2 directly.
> Use this.personService.getActivePersons() instead
> Use this.personService.getActivePersons()
> Use this.personService.getActivePersons instead
We don't need to log this?
We don't need to log this.
We can remove this log line?
You can simplify this by: java return schema.numColumns() == 1;
You can simplify this by using Integer.MAX_VALUE
This should be return schema.numColumns();
Why is the toString on the left side?
Why is the toString on the generated toString?
Why is the toString on the generated by the toString method?
Can we please keep this call to dbManager.destroy()?
Can we please keep driverClass as final?
Can we please keep tab removal of driverClass parameter as a parameter?
I prefer: return handle*Handler(targetObject, targetMethodName).stream().filter(e ->!StringUtils.hasText(targetMethodName)).collect(Collectors.toList());
I prefer: return handle*Handler(targetObject, targetMethodName, targetMethodName).stream().filter(e ->!StringUtils.hasText(targetMethodName)).collect(Collectors.toList());
I prefer: return handle*Handler(targetObject, targetMethodName, targetMethodName);
We need to be able to remove RTSideAffixedPortDisplay, and the resulting domain name must be removed.
We need to be able to remove RTSideAffixedPortDisplay, and the resulting domain name must be raptors
We need to be able to remove RTSideAffixedPortDisplay, and the resulting domain name must be raptor ;-)
Please use CollectionUtils.isEmpty()
Please use Utils.isBoolean()
Please use nonNull
The same as above using this.strategy.
The same as above using this.strategy
The same questions as above.
I think you could use StringUtils.join(criteriaNumbers, " or ";
I don't think this code needs to be public. If you want to make it public, you can put it there.
I don't think this code needs to be public. If you want to make it public, you can put them there.
requireNonNull(columnName, "column name");
requireNonNull?
requireNonNull
This does not seem necessary.
This seems like it should be done regardless of whether the task is async or not.
This does not seem necessary. If we have the task editor before the reconnect is finished, then the'reflow' will be actually executed.
Any reason for this?
Any reason for this test?
Can you test the method for below?
Format: new Date(Pair.create(EventStrings.CRYPTOGRAPHY_STATUS, status));
Format: new Date(Pair.create(EventStrings.CRYPTOGRAPHY_STATUS, status)));
UserProfiles is created to use some fake data. so this is not reliable enough.
This should be inflight. It is not a thread-safe object.
This should be inflight. It is not a thread-safe iterator.
This should be synchronized
Hmmmm. I just noticed this change and it isn't good: from a human perspective having the fbo id alone in the logger output is of limited use. Having the name printed out is quite important. I can imagine a couple of solution: 1. we pass the fbo's URN on construction, solely for the purpose of printing it out in the log alongside the fboId 2. we store the URN in the FBO, but I'm not sure if this is going to come and bite us in the future.
Hmmmm. I just noticed this change and it isn't good: from a human perspective having the fbo id alone in the log output is of limited use. Having the name printed out is quite important. I can imagine a couple of solution: 1. we pass the fbo's URN on construction, solely for the purpose of printing it out in the log alongside the fboId 2. we store the URN in the FBO, but I'm not sure if this is going to come and bite us in the future.
Hmmmm. I just noticed this change and it isn't good: from a human perspective having the fbo id alone in the logger output is of limited use. Having the name printed out is quite important. I can imagine a couple of solution: 1. we pass the fbo's URN on construction, solely for the purpose of printing it out in the log alongside the fboId 2. we store the URN in the FBO, but I'm not sure if this is going to come and bite us in the future).
Why use apache-commons, when you have java.util.Collections.unmodifiableList(Collections.emptyList())
Why use apache-commons, when you have java.util.Collections.unmodifiableSet(Collections.emptyList())
Why use all of them instead of UnmodifiableList.decorate?
return create(version.getNumber() + 1, currentTime);
That's not exactly for testing, but I'd prefer to have a static method onVersion that gives you a fully defined version rather than a fully qualified version.
That's not exactly for testing, but I'm not sure if this method should be public. If you need to access version.get()?
you can use Collections.singletonList
you can use Collections.singletonList()
you don't need to use new ArrayList
Why it's here? Please try to understand what onUpdateToFirstVersion and onUpdateToFirstVersion are doing. If user remove them and add them.
Why it's here? Please try to understand what onUpdateToFirstVersion and onUpdateToFirstVersion are doing. If user remove them and set them to OSchemaHelper.
Why it's here? Please try to understand what onUpdateToFirstVersion and onUpdateToFirstVersion are doing. If user remove them and add them, it will not work.
This test is missing an assert-statement.
This test is not enough under preHandle-call_should_fail.
This test is exactly the same as the old one.
assertThat(e).hasMessageContaining(...), is(..))
assertThat(e).hasMessageContaining(...)
assertThat(e).hasMessageContaining(...)?
Hi @stevenschlansker, I think the recommended approach is to do the following: java this.bytes = Arrays.hashCode(bytes);
Hi @stevenschlansker, I think the recommended way to do this is to call Arrays.hashCode() on a byte[]. For example, if bytes is null then the constructor should throw an IllegalArgumentException.
Hi @stevenschlansker, I think the recommended approach is to do the following: java this.bytes = Arrays.hashCode(bytes); As for me it makes the code more readable and I have a question on the top of my head whether the hash code is correct.
We should also return the screen height as before: return templateData.getAuthCardDetails().getJsScreenHeight().orElse(DEFAULT_BROWSER_SCREEN_HEIGHT);
We should also return the screen height as before: return templateData.getAuthCardDetails().getJsScreenHeight().orElse(DEFAULT_BROWSER_SCREEN_HEIGHT_RANGE);
Shouldn't the value be the default? (This may be another PR, but I think this line should be another if statement though).
We should be checking if ownerProductUuidMap!= null here as well.
How about adding an init() method to this class and calling it from the init() method from here?
How about adding an init() method to this class and calling it from here and in the following method?
log lvl rather to trace here?
similar to the other examples here, just to be avoided here.
similar to the other examples here.
I think un-needed cast.
Use getListView().getLocationTracker() instead.
do we need this?
Why does this need to be static?
Why does this need to be public?
Why is this method public?
I think this could be private.
I think this could be removed.
I think we could have a check here.
suggestion public boolean logTransactionMergeFailure() {
it should be private or protected.
it doesn't seem to be used anywhere?
I might be missing something here but it would use the isPasswordHashed() method of the User object.
I might be missing something here but it would use the isPasswordHashed() method which is called from the places where the tests are failing.
I might be missing something here, but it would use the isPasswordHashed() method which is called from the account.
is this line necessary?
remove the toString for consistency.
you can inline this line for better readability.
is empty()?
is this empty?
is defined as a getter method
No need to return a copy of the size here.
No need to return a copy of the size here, this is just a MutableInteger
No need to return a size here.
We should add deviceList=%s to the toString, also deviceList=%s
We should add deviceList=%s to the toString, otherwise it will be hard to debug.
We should add deviceList=%s to the toString, also deviceList=%s.
do we need this line?
do we need to check CRC here?
formatting
Missing curly braces for this if.
Missing curly braces for this if-statement.
Missing curly braces for this if-block.
nit: maybe replace the null check with "!".equals(resultStr)
nit: "orders".equals(resultStr)
nit: you could use "resultStr".equals(resultStr)
Pls use Boolean.parseBoolean.
this can be moved to the constant
Hardcoded.
I think the attribute "create=true" should not be put in the test case, it is used the very first time to create the schema.
I think the attribute "create=true" should not be put at all the test cases, it is used the very first time to create the schema.
I think the attribute "create=true" should not be put in the test case, it is used the very first time to create the schema and the test case
Let's move this to the update() method above, so that the state of the FBO is only attached to the display: private final FBO readOnlyGBufferFbo;
Let's move this to the update() method above, so that the state of the FBO is attached to the FBO.
Let's move this to the update() method above, so that the state of the FBO is only attached to the display: private final FBO readOnlyGBufferFbo = displayResolutionDependentFbo();
Should this function handle the case where a parent is a child?
this method should not be public.
Should this method createPartControl(aParent) be moved to above?
Does this need to be public?
Does this need to be protected?
Why not make this return true?
So _ret is a queue of 1 task and it is never used?
So _ret is a queue of 1 task and it is called only once. Is it a correct approach to use a queue for 1 task?
So _ret was a queue of nulls?
No need to check this for instanceof MockScatterChartDataModel. I feel that the tester can be done by getting the point shape separately.
No need to check this for instanceof MockScatterChartDataModel. I feel that we can't change the behavior for this method.
No need to check this but simply mock an ImmutableMap.Builder()
Should we use a logger?
Should we use a logger here?
Lets remove this
Please add try/catch: public void test() { }
Can we define the class for this instead of having it public?
Can we define the class for the test so that it is easier to maintain?
couldn't / shouldn't getTenant() return the uniqueName instead? As we use it everywhere in the TenantUserManager
couldn't / shouldn't getTenant() return the tenantAware and not throw exception?
cache?
use parquet.Ints.checkedCast or you could get a negative value out of this cast
use parquet.Ints.checkedCast or you could get a negative value out of this box
use parquet.Ints.checkedCast or you could get a negative value out of this column.
'envVblesAsString' does not need to be in an if, so you can just do this: envVblesAsString = envVbles.entrySet().stream().map(Map.Entry::getKey, envVblegetValue()).collect(Collectors.joining("|"));
'envVblesAsString' does not need to be in variable names, so you can just do this: envVblesAsString = envVbles.entrySet().stream().map(Map.Entry::getKey, envVblegetValue()).collect(Collectors.joining(","));
'envVblesAsString' does not need to be in variable names, so you can just do this: envVblesAsString = envVbles.entrySet().stream().map(Map.Entry::getKey, envVblegetValue()).collect(Collectors.joining("|"));
Could you turn this into a synchronized block?
Could you turn this into a synchronized method?
How does load() behave if there are COL() methods?
Why use apache-commons, when you have java.util.Collections.unmodifiableMap
Once you switch back to the Apache commons collection 4.0, it would be unmodifiableMap
Why use apache-commons, when you have java.util.Collections#unmodifiableMap
Add a null check for ignoreInterfaceOverrides
Add a null check here
Add a null check here.
I don't know that this is the ID for the message; it's always the ID..
I don't know that this is the ID for the message; it's the ID for the message.
I don't know that this is the ID for the message; it's the ID for the message;
no need to check if chromPos.getOrientation() == '+'
no need to check if chromPos.getOrientation() returns null.
no need to check if chromPos == null.
Is there a reason to remove the winner?
Is there any reason to remove the winner?
Is it right to remove the winner?
How about printing the stack trace to the log?
How about printing the exception in logger.err?
How about printing the stack trace to stdout and stderr in error logs?
remote installations
remote installations should be disabled
remote installations should never be disabled
This is returning a number of getNumberOfCommas(binaryExpression.leftOperand()) could be made more readable with a variable getNumberOfCommas(binaryExpression.leftOperand())
This is returning a number of getNumberOfCommas(binaryExpression.leftOperand()) could be made more concise and easier to read.
This is returning a number of getNumberOfCommas(binaryExpression.leftOperand()) could be made more readable with a variable getNumberOfCommas method.
mvcccced members can be replaced with isMvccReadAll()
mvccced members can be replaced with isMvccReadAll()
mvcccced members can be replaced with isMvccRecoveryMessage()
exiting, so STDERR
exiting. so STDERR
exit(), so STDERR
Can you change this to return ThreadLocalRandom.current().nextBoolean();
Can we return ThreadLocalRandom.current().nextBoolean() instead of cast?
Can you change this to return ThreadLocalRandom.current().nextBoolean()?
Lower case
Lower camel case
Lowering
I think we should do this in the constructor.
I would wrap the if with {}
I think we should not expose the exception.
You can filter on the value returned by Framework.getService
You can filter on the value returned by Framework.getService(PageProviderService.class)
findFirst() is a bit better than findFirst().
I'm not sure if this is correct. If you force push a fresh manifest, then the job directory is already open, so we don't need to wait until it succeeds.
I'm not sure if this is correct. If you force push a fresh manifest, then the job directory is already open, so we don't need to invalidate it.
I'm not sure if this is correct. If you force push a fresh manifest, then the job directory is created, but the exception is not logged.
I would have used 'prevBuffer' to keep the zero-byte array
I would have used 'prevBuffer' to keep the previous value.
I would move the requireNonNull above the assignments to new byte[] {... }.
Can we use the formatter.emit() method here?
Can we use the formatter.emit()? <LINK_0>
Can we use the formatter.emit() method here? <LINK_0>
Typo: cannot contain -> cannot
Same here and above.
Typo: cannot contain -> cannot contain
minor typo: SEPARATOR
this function can be private
why a function for this?
I think this should be public
I think this can be made static
I think this should be protected
This cast is no longer necessary. You are cast to ViewPager.getAdapter() and ViewPager().getAdapter() directly.
This cast is no longer necessary. You are cast to ViewPager().getAdapter() and ViewPager().getAdapter() directly.
This cast is no longer necessary, you can remove it.
You should check that the request is not being saved to your memory. If it is being removed, the log is going to take care of this.
You should check the i18n result of the call to your method, it is being called for'manager'
You should check that the request is not being saved to your memory. If it is being removed, the log is going to take care of that.
You can just valueOf(uniqueName.replace('-', '_').toUpperCase(Locale.ENGLISH) here
You can just valueOf(uniqueName.replace('-', '_').toUpperCase(Locale.ENGLISH)) here
- [x] There is no need to call valueOf() here
/s/returned/changes/
/s/returned/changes
/s/DefaultHostResource.java/impl
nit: simplify to if (expression instanceof CallExpression) { return functionManager.getFunctionMetadata(((CallExpression) expression).getFunctionHandle()).getName(); } return false;
nit: simplify to if (expression instanceof CallExpression) { return functionManager.getFunctionMetadata((CallExpression) expression).getFunctionHandle()).getName(); } return false;
nit: simplify to if (expression instanceof CallExpression) { return functionManager.getFunctionMetadata(Expression.getName()); } return false;
let's move this line to the top of the method
let's move this method to the top of the file
let's move this method to the top of the method
You may want to set the status to null and call notify() on it.
You may want to test whether the status is null or not.
You may want to set the status to null and update it to null to avoid NPE
Possibly unnecessary to check it's not null?
Possibly unnecessary to check it here?
could be private
want to use toStringHelper(this)
hostname can be null?
indentation is a bit off here
I think this is too: public Set<OperatorSpec> getAllOperatorSpecs() { Collection<OperatorSpec> inputStreams = inStreams.values(); for (InputStreamInputStream stream : inputStreams) { doGetOperatorSpecs((MessageStreamImpl) stream, operatorSpecs); } }
I think this method is too long: public Set<OperatorSpec> getAllOperatorSpecs() { Collection<OperatorSpec> inputStreams = inStreams.values(); for (InputStreamInputStream stream : inputStreams) { doGetOperatorSpecs((MessageStreamImpl) stream, operatorSpecs); } }
I think this method is inStreams.values()
throws
nit: throws
throws?
If this is the case, shouldn't it be "state=DONE" like in the other tests?
If this is the case, you should have a test around it.
If this is the case, shouldn't it be "state=OK" or "state=OK"?
Typo: "id"
Typo: really needed
Typo: Should be jg.id
Why use the value of this.?
Why use this?
Why use this instead of calcAreaAspectRatioScale?
Do you really need this set to 100? Magic numbers are very similar too.
Do you really need this set to 100? Magic numbers are pretty much?
Do you think it's worth setting a limit to 100 instead of 100? Magic number
java return getNetworkInterface()!= null && getHostAddress()!= null;
java return getNetworkInterface()!= null && getNetworkInterface()!= null;
So if the controller is null, it's not enough to compare the database with the value from the properties.
Should the signature here be void?
Should this return a List<String> instead?
Should the signature here be void? At least package protected access?
Is there some particular reason for using peekFirst()?
Is there some particular reason for using peekFirst()?
Is there some particular reason for checking this multiple times?
@erimerturk let's add info on who subscribed to the blast
@erimerturk let's add info on who subscribed to the bern.
@erimerturk let's add info on who subscribed to the blast list, don't forget
do we need this here?
How about Assert.notNull(distanceField, "distanceField must not be null.");
do we need this here? if not, we should error error.
I thought the first test would fail, because it wasn't otherwise obvious why we had this test failed.
I thought the first test would fail, it would be more useful to have a test for that: - [x-370](<LINK_0> - [x-370]
I thought the first test would fail, it would be more useful to have a test for that: - [x-370]
This call will lead to an NPE if no thing is found for the thing.
With placing it here, you decided that an UNINITIALIED/DISABLED thing should actually _have_ a handler instance - any reasons why that is?
This call will lead to an NPE if no thing status is found for the thing.
Why not use the Arrays.asList() method to create a list?
Why not use the Arrays.asList()?
Why not use the Arrays.asList() method you did in List.
See above, it would be better to initialize s with title and s in the constructor.
See above, it would be better to initialize s to title and then assign to s in the else block.
See above, it would be better to initialize s to title and then assign to s in the if else block.
Please put final on the new line.
Please follow the style guide in other tests: <LINK_0>
Please follow the style guide in other tests.
This constructor should have no logic to enforce username and password.
This constructor should call the other constructor using this(KEY)
This constructor should call the other constructor using this(KEY).
This is a minor constructor but it seems a bit odd to have a public constructor that takes ServerSideConfiguration and a ServerSideConfiguration. If that's the case, could it make sense to have a ServerSideConfiguration constructor that takes ServerSideConfiguration and a ServerSideConfiguration like this?
This is a minor constructor but it seems a bit odd to have a public constructor that takes ServerSideConfiguration and a ServerSideConfiguration. If that's the case, could it make sense to have a ServerSideConfiguration constructor that takes ServerSideConfiguration and a ServerSideConfiguration inside it?
This is a minor constructor but it could be private or protected.
This method doesn't seem to be used.
This method should be synchronized.
This method should be called only once in the loop.
looks like we should add an MetricsInterceptor so we can test it.
looks like we should add an MetricsInterceptor so we can test it
Be more specific about the MetricsInterceptor being passed
This method is private, should not be static.
This method is private, should not be public
This method is private. Please change to public
You should use getVdsGroup() && getParameters().isGlusterPeerProbeNeeded() (I prefer the first option).
you can just use getVdsGroup().supportsGlusterPeerProbeNeeded()
you can just use getVdsGroup().supportsGlusterPeerProbeNeeded().
This test is a little weird, the previous test just failed.
This test doesn't seem to cover anything. I think the previous test is an interesting case.
This test doesn't seem to cover anything. The test should throw an exception
Why is the java.sql.Timestamp needed?
Why is the java.sql.Timestamp here?
s/java.sql.Timestamp/
Shouldn't this be: taskExecution.getTaskExecution(id).get()?
Shouldn't this be: getLatestManifest()?
Shouldn't this be: taskExecution.getTaskExecution(id) as the current processing of the task?
It is never null, you should change to @Nullable
It is still public. Why?
It is still public, you should change to private.
If resolveNodeToBinding() can return null, why do you need to check for null?
If resolveNodeToBinding() can return null, why do we need to check for null?
why?
The constructor should take care of the initialization.
The constructor should take care of the initialization of the networkToEndpointMap, not the implementation of the constructor.
The constructor should take this one and use the additional singleton.
Not sure why we want to do this here. We seem to be using this on a different thread for the subscription that was provided by the user. Can we try to do this in the ProcessThread class?
Not sure why we want to do this here. We seem to be using this on a different thread for the subscription that was provided by the user. Can the service take care of it?
Not sure why we want to do this here. We seem to be using this on a different thread for the subscription that was provided by the user. Can we try to do this in the ProcessThread class instead?
Shouldn't the id be the parameter of the MusicFragment object, rather than the id?
Shouldn't the id be the new MusicFragment object?
Shouldn't the id be the parameter of the MusicFragment, rather than the id?
What is the purpose of this method? It returns a boolean but is it just a String?
What is the purpose of this change?
What is the purpose of this method? It returns a boolean but is it not assigned to anything?
Can be simplified to: java return entityTypeIds.stream().findFirst().orElseThrow(() -> new IllegalStateException("There are no entities available!");
Can be simplified to java return entityTypeIds.stream().findFirst().orElseThrow(() -> new IllegalStateException("There are no entities available!");
Can be simplified to: java return entityTypeIds.stream().findFirst().map(Entity::getName).orElse(findFirst.orElseThrow(() -> new IllegalStateException("Entities are available!");
is public enough? Please don't change visibility.
is this meant to be public? If not, the class methods should be private.
can you explain why is this public?
equals?
Too many spaces, please
equals
This needs to be {X}{B}{X}{B}{A} {X}{B}{A} {B}
This needs to be {X}{B}{X}{B}{A} {X}{B}{X}{B}
This needs to be {X}{B}{X}{B}{A} {X}{B}{A} {A} {B}
I don't think you need the orElse(null) here.
Shouldn't the query bar be closed in a finally block?
Shouldn't the query bar be null?
Is there a reason why this method isn't implemented?
Is this missing a method declared? Or you can just call the other method with a null password
Is there a reason why this method isn't implemented? Or you do it at all?
typo:rael Standard Timeone
typo: rael Standard Timeone
typo: 'rael Standard Time'
please verify(eventAdmin, times(1)).postEvent(any());
@ verify(eventAdmin, times(1)).postEvent(any());
please make this call out of the @Before method.
I think if (DefaultDisplayVsync) is enough this will do: if (useDefaultDisplayVsync) { unregisterDisplayListener(); }
I think if (defaultDisplayVsync) is enough this will do: if (defaultDisplayVsync) { addDisplayListener(this); }
I think if (DefaultDisplayVsync) is enough this will do: if (defaultDisplayVsync) { addDisplayListener(this); }
I don't think this is right. You are printing the stack trace, but you are not logging it.
Log the exception
Log the exception here.
Please use one assertion to check whether the workspace has a tag with a name "workspace".
Please use one assertion to check the tag of the metacardImpl.
Please use one assertion to check whether the workspace has a tag with a name that we know about it.
The level of this is not very clear, it really belongs in the 'addTrackers' method
The level of this is not very clear, it really belongs in the 'addTrackers' method.
The level of this is not very clear, it really belongs in the 'addTrackers' frame.
would be more clear to check the last testTextSize.endsWith("org.apache.hadoop.test.bat.AbstractSwarmTestSwarmTest")
would be more clear to check the last testTextSize.endsWith("org.apache.hadoop.test.bat.AbstractSwarmTestSwarmTestS")
would be more clear to check the last testTextSize.endsWith("org.apache.hadoop.test.bat.AbstractSwarmTestSwarmTestSwarm matching");
suggestion return this.typeWrapper.elements().getBinaryName(element).toString();
Think we should return Optional<String> instead of toString() here.
Suggestion: If getBinaryName() returns null, then return the String value of toString() and avoid toString() in the next line.
Should we rename it to View or Client to View?
ApplicationProvider.requestPoint()
Should we rename it to View.View to global
What do you think about using a CountDownLatch instead of a simple Thread? It will be easier to control the state of the thread. I'm not sure what it is for free.
What do you think about using a CountDownLatch instead of a simple Thread? It will be easier to control the state of the thread. I'm not sure what UI thread does by default.
What do you think about using a CountDownLatch instead of a simple Thread? It will be easier to control the state of the thread.
Blank line before and after + sign probably.
Blank line before and after + sign should be good enough.
Blank line before and after =
maybe just call this.addUpdateTask(operation, key, value) and remove the overload in BoxMetadataUpdateTask
maybe just call this.addUpdateTask(operation, value, value) and remove the overload in BoxMetadataUpdateTask
maybe just call this.addUpdateTask(operation, value, "") and remove the overload in BoxMetadataUpdateTask
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
The ParameterService has a version of the parameterService.getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter is null. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
The ParameterService has a version of the ParameterService.getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter is null. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
I think you meant to pass true for the second parameter to be false.
I think you meant to pass true for the second parameter to the new method.
boolean
I remember this method should return true in case of a port. It would be better to throw an exception (in case of a non-existing port).
I remember this method should return true in case of a port. It is not isNumeric.
I remember this method should return true in case of a port. It would be better to throw an exception (in case of a non-existing port.
As we discussed, this should be package private.
As we have the [FileListFilter](<LINK_0>, could we change this to package-private?
As we discussed, this should be protected.
return CurveInfoType.DAY_COUNT
return DAY_COUNT
return CurveInfoType.DAY_COUNT?
These should use the constants, no?
You can use the static method getAllowableOffset(String) method, I think
You can use the static method getAllowableOffset(String)
Can you use DateUtils.getCurrentTime() and avoid creating a new Date(0)?
Can you use DateUtils.getCurrentDiagnoses() instead?
Can you use final Date(0)?
Why do we need to catch all exceptions? Can't we just throw something?
Why do we need to catch all exceptions? Can't we just let the exception through?
Why do we need to catch all exceptions? Can't we just let the exception propagate?
Throw an exception, as we are not returning 0
Throw an exception if the list is empty, will return 0
Missing generics
I think this should be changed to String.class
I think this should be changed to Class<Void>
this should be changed to private
[ -> ]
[ --> ] Maybe more verbose?
[ -> ] Maybe more verbose?
is there a Map.of? Why not just do java Map<String, Object> request = new HashMap<>()?
is there a Map.of()? Why not just do java Map<String, Object> request = new HashMap<>()?
is there a Map.of?
I suggest to use File f = new File(repo.getDirectory(), url).getAbsolutePath();
I suggest to use File f = new File(repo.getDirectory(), url).getAbsolutePath(); instead of the above two lines
I think we should check for a null url here
I do not think this is appropriate.
Why are you passing null?
I do not think this is supported.
Pull Item first into a static final variable
Pull sSize into a static final variable
Pull Item first, and use the static final
This could be shortened to: java return delegate.getBaseUriBuilder().scheme(scheme).host(scheme).port(port).replacePath(contextPath).build();
This could be shortened to: java return delegate.getBaseUriBuilder().scheme(scheme).host(scheme).port(port).replacePath(contextPath).build());
This could be: java return delegate.getBaseUriBuilder().scheme(scheme).host(scheme).port(port).replacePath(contextPath).build();
Looks like this warn message is a little over-complicated. Not sure why we are doing this.
Looks like this warn message is a little over-complicated. Not sure why we are doing this. Do you think we should be more specific here?
Looks like this warn message is a little over-complicated. Not sure why we are doing this. Do we know why?
You could use && Objects.equal(maxChangesOptionByVersion, maxOption.getValue()) to check whether the version is positive or not.
You could use && Objects.equal(maxChangesOptionByVersion, maxOption.getValue())
You could use <= here to be consistent with the logic above.
this method should be in the api as well
this should be in the update method in the template mapper
this should be in the update method in the api
method name could be improved, as it could be waitUrlStartButton(wsName).
method name could be improved, as it could be waitUrlStartButton(ws)
method name could be improved, since it's not quite clear what it is.
public? Or at least package protected?
public?
Why public?
Should be debug level
Should this be debug level?
Should be debug level.
Let's remove the public modifier and just let the annotation fail on this method.
Let's remove the extra line, and just return the assertPostParamNotNull check here.
Let's remove the extra line, and just return the assertPostParamNotNull check.
Maybe just using string concatenation would be cleaner?
Maybe just using string concat here?
Maybe just using string concat here like in other classes?
I would remove this while, or use an assert with a more precise condition.
I would remove this while, or use an assert with a more precise check.
I would remove this while, or use an if.
The view type should be JSON and not JSON. The view type should be JSON only
The view type should be JSON and not JSON
The view type should be JSON and not JSON. The view type should be JSON_XML
We should also consider the empty string (maybe VariantType.NO_ALTERNATE.
We should also check if the reference is empty.
We should also consider the empty string (maybe VariantType.Empty_ALTERNATE.
Timeout may be better than Thread.sleep. It's recommended to use a timeout.
Timeouts should be available at compile time. Also, it's better to use a semaphore here
Timeout may be better than timeout.
nit: OSDelegatingFileTailingMessageProducer adapter = new OSDelegatingFileTailingMessageProducer(); adapter.setOptions("-F -n 99999999");
nit: OSDelegatingFileTailingMessageProducer adapter = new OSDelegatingFileTailingMessageProducer();
nit: I would extract "-F -n 99999999" into a constant, like the other ones.
initStat() is only called once, so it can be removed.
Shall we add the call to setMsgId(id) here?
Shall we add the call to setStat() inside the initStat()?
Maybe we could just do if (action == null ||!action.equals("Already created") in the method?
Maybe we could just do if (action == null ||!action.equals("Already created"))?
Maybe we could just do if (action == null ||!action.equals("Already created") in the verb?
This is becoming a recurring pattern, maybe a good time to refactor this if statement into a method?
This is becoming a recurring pattern, maybe a good time to refactor this if statement into a method like isAnsiSupported()?...
This is becoming a recurring pattern, maybe a good time to refactor this if statement into a method like isAnsiSupported()?... :...
typo
typo?
typo: signature vs.
rename to delta
rename to deltaecations
typo
This binding is not needed. Only the following is enough: bind(AsyncBlobStore.class).toGlacierBlobStore(class).to(GlacierBlobStore.class);
This binding is not needed. Only the following is enough: bind(AsyncBlobStore.class).toGlacierBlobStore(class).to(GlacierBlobStore.class)
This binding is not needed. Only the following is enough: bind(ConsistencyModel.class).to(ConsistencyModel.STRICT);
You should re-throw the IOException instead of swallowing it.
You should re-throw the IOException here.
You should re-throw the IOException instead of catching it here.
Instead of a try/catch, can you use forEach: try (InputStream inputStream = resourceFile.newInputStream()) { }
should be a.register(input)
Instead of a try/catch, can you use try (InputStream e =...) { }
this line can be removed
this line can probably be removed
this line can be removed and directly return true;
Why do you need this? Is it just for testing?
Why do you need this? Is it just doing something like getIndexManager(cache)
Why do you need this? Is it possible to use the host name on the cluster?
I think we should turn these 0 checks into a isEmpty check.
I think we should turn these off into a checkState method since they are used in no-op.
I think we should turn these off into a checkState method since they are used in no-op
if the select() doesn't exist, doesn't that make sense here?
if the select() doesn't exist, doesn't that make sense?
if the select() doesn't exist, doesn't that make sense here.
nit: I would do return Strings.isNullOrEmpty(version)? new Cassandra22XVersion() : from(version);
nit: Just return the version?
nit: I would create a private method which takes the version as a CassandraVersion.
Nitpick: would you mind using assertQuery(1 + 2, 3 + 4", "SELECT 1 + 2, 3 + 4");() to make it clear that we are testing the case of the query and not the statement?
Nitpick: would you mind using assertQuery(1 + 2, 3 + 4", "SELECT 1 + 4", " + 3 + 4");() to make it clear that we are testing with being repeated times?
Nitpick: would you mind using assertQuery(1 + 2, 3 + 4",) here?
Exception should be logged.
Throwing an exception here will cause the test to fail.
Please remove.
use Boolean.parseBoolean(apolloFlag)
use Boolean.parseBoolean(apolloFlag) here
use Boolean.parseBoolean(apolloFlag)?
I think your pull request should be in the AddActionMessages file, if you are sure it will not be admin, just in case.
I think your pull request should be in the AddActionMessages file, if you are sure it will not be admin.
I think your pull request should be in the AddActionMessages file, if you are sure it is a list of things you are adding.
This should use a constant, please.
This should be 1.1f
This should use a constant, so that it can be updated in the future.
Can we put this at the start of the method as well?
Can we put this at the top of the method as well?
Can we put this at the top of the file as well?
Why is the need to make this constructor public?
Why is the need to make this constructor package private?
Why do you need to make this constructor public?
This could be private.
This could be private and protected.
Is this really needed?
Is there a particular reason to wait again for element element? We already have a timeout. So is there a particular reason to wait again for that?
Is there a particular reason to wait again for element element? We already have a timeout. So is there a particular reason to wait again for that?
Is there a particular reason to wait for element removal of the page? It looks like we can get a element from the page.
Could just make lambdas here since getAge isn't used elsewhere
Could just make this shorter since getAge isn't used elsewhere
Could just make this classes accept boat, here.
This is backwards.
This toString is wrong.
This toStringHelper(Block) looks redundant.
maybe change this to debug?
maybe change this to debug level
maybe change this to debug level?
.equals()
.timeSince() is expected
.time is known
If this is the smallestReadPoint value, why the smallestReadPoint is always the smallestReadPoint?
If this is the smallestReadPoint value, why the smallestReadPoint is always the same?
If this is the smallestReadPoint of the Compactor, why the smallestReadPoint is always the same?
Typo: Unable
Is this one I missed?
Typo: Unable to find scope
I believe this check is unnecessary: java if (this.anyRequestConfigured) { Assert.state(!anyRequestConfigured, "Can't configure anyRequest after itself"); }
I believe the extra if check here is unnecessary: java if (this.anyRequestConfigured) { Assert.state(!anyRequestConfigured, "Can't configure anyRequest after itself"); }
I believe this check is unnecessary: java if (this.anyRequestConfigured) { Assert.state(!anyRequestConfigured, "Can't configure anyRequest after itself"); this.anyRequestConfigured = true; return requestMatchers(ANY_REQUEST);
Nit: DateTime now = DateTime.now();
Nit: DateTime now = DateTime.now().parse(issueId);
Nit: DateTime now = DateTime.now().parse(issueId)
I think it would be better to use Long.compare(actual, expected)
I think it would be better to use Long.valueOf(actual)
Long.valueOf()?
Must be {3}{U}");
This doesn't need to have the rule added to the card's name, just the fact that you're adding this.
This doesn't need to have the rule added to the card's name, just the text.
hell no
hell no, all the time we want to mock this class to avoid NPEs, please write a unit test for this.
hell no, all the time we want to mock this class it's not clear to me what this method is doing.
I think it should be public SyncLunsParameters(Guid storagePoolId) { this(storagePoolId, storagePoolId); }
I think it should be public SyncLunsParameters(Guid storagePoolId, UUID storagePoolId)
I think it should be public SyncLunsParameters(Guid storagePoolId) { super(storagePoolId); }
shouldn't you convert the value to millis?
shouldn't you convert the long value to millis?
shouldn't you convert the long value to millis and use it in the patch?
Check the env variable before returning true.
Check env variable before returning true.
Check Check env variable before returning true.
You could add the exception to the log statement.
You could add the exception to the log statement. Just a thought.
This method (and other places) could be extracted to a separate class.
Do you have a test that peeks the next sequence number?
Do you have a test that peeks the sequence number?
Do you have a test that peeks the sequence number above?
Maybe return FCollection.map(testsForMutant, x -> x);
Maybe TIME_WEIGHTING_FOR_DIRECT_UNIT_TESTS should be renamed?
Maybe @VisibleForTesting?
Can be replaced with java return css.stream().anyMatch(this::isEmpty);
Can be simplified to java return css.stream().anyMatch(this::isEmpty);
Can be replaced with java return css.stream().anyMatch(e -> isEmpty(e)).findFirst();
the name of this method is not clear (pun not intended...) because the word 'clear' is usually used when some collection is being emptied. actually looking at the code in the 'bondsToRemove.addAll(bondToScan)', is it correct?
the name of this method is not clear (pun not intended...) because the word 'clear' is usually used when some data is being read.
the name of this method is not clear (pun not intended...) so this makes sense in my opinion.
this is a bug, it should be HIVE_METASTORE_ERROR
this is a config problem and should be logged at trace level.
this is a bug, it should be RHS.
it is more readable if you use String.format(Date.from(instant)), then call serialize(df.format(Date.from(instant)))
it may be easier to use the serialized format if it is null rather than the default.
it may be easier to use the serialized format if it is not null rather than the default.
Oh, I see the reason for the change to true here (and in the next version) is to update the XML version. If you use the XML version, it will be false anyway. Could you please make it consistent?
Oh, I see the reason for the change to true here (and in the next version) is to update the XML version. If you use the XML version, it will be false anyway.
Oh, I see the reason for the change to true here (and in the next version)
This is called on the first line of the constructor.
The return value of the method is not used.
The return value of the constructor is not used.
Should we really report this event in the log?
Should we just report this event in the log?
Should we just report when the session was actually open?
lambda
(Optional) I don't think you need this.
Should be in the superclass
This method is called multiple times, please extract the code in a method.
This method is called multiple times, please extract the code in its own method.
This is unnecessary, the method is already public.
java @Override public int hashCode() { return delegate.hashCode(); }
return Objects.hash(delegate, delegate);
return delegate.hashCode();
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 89-90. Do the same for the others.
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 247-248. Do the same for the others.
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 118-119. Do the same for the others.
What about Arrays.equals? Also possibly an intrinsic in JDK9.
What about Arrays.equals? Also possibly a bit of extra checks?
What about Arrays.equals? Also possibly an intrinsic in JDK
@akarettchabot doesn't this method return 0?
@Nullable
throw IOException?
Prefer LazyValueBuilder.of(String.class, LazyValue.class)?
Prefer LazyValueBuilder.of(String.class, String.class)?
Prefer LazyValueBuilder.of(String.class, String.class)
setSteam()?
minor: this method should be private
setSteam()
This is not thread safe. Ideally the order of user code is off, and it does not prevent the suspend method from being called.
This is not thread safe. Ideally the order of fields should be changed to read from the field declaration, rather than in the getter.
This is not threadsafe.
What if values is not empty?
What about Comparator.comparing(Number::compareTo)?
What about Comparator.comparing(Number::getValue)?
Please use urls.length()
Please use urls.length(invocation)
Please use urls.length(length)
These should use key.get()[key.getOffset()] instead of key.get()[key.getOffset()]
These should use key.get() instead of key.get()[key.getOffset()]
These should use key.get() instead of key.get()
How about using [StringBuilder](<LINK_0> instead?
How about using.group(1) here?
How about using [StringBuilder](<LINK_0>
I think this could be replaced with:.computeIfAbsent(DMNContext.class, clazz -> DMNFactory.newContext()); dmnContext.set(name, value);
I think this can be replaced with:.computeIfAbsent(DMNContext.class, clazz -> DMNFactory.newContext()); dmnContext.set(name, value);
I think this method should be private.
I don't think we should catch throwable instead, since that would let the test throw the exception instead.
I don't think we should catch throwable instead, since that is what the exception you expect (for better readability).
I don't think we should catch Throwable and test Error().
Same change here. And make it private.
Same change here..
Same change here. You can drop the public modifier
This is a lot of code. Could we maybe have a unit test for *just* this section? I would be wondering if there's a way to test for any of these tests here. The main concern is that *any* of the.security file is the main concern.
This is a lot of code. Could we maybe have a unit test for *just* this section? I would be wondering if there's a way to test for any of these tests here. The main concern is that *any* of the.security file is a very resource for any of the tests here.
This is a lot of code. Could we maybe have a unit test for *just* this section? I would be wondering if there's a way to test for *just* this section. The main concern is that *any* of the.security file is the main thing for our tests here.
minor: add StatsManager to StatsManager
minor: add StatsManager to ReplicaId.
minor: consider adding StatsManager to StatsManager
As the operator is only used in this method, I suggest to rename it to operatorImplGraph.close().
As the operator is only used in this method, I suggest to rename it to the following: operatorImplGraph.close();
As the operator is only used in this method, I would prefer to keep the same style as the other methods.
Also called twice here.
Also called twice here and in setAttribute().
Also called twice here and in setAttribute.
The injector!= null check is still needed.
The injector!= null check is no longer needed.
The injector!= null check is not needed.
As per offline conversation, to be consistent, if we're logically deleting, it's fine if it's logically deleted.
As per offline conversation, to be consistent, if we're logically deleting, it's fine if we don't check logically deleted authorization statistics (the response can be undeleted).
As per offline conversation, to be consistent, if we're logically deleting, it's fine if we don't have logically deleted authorization statistics (the response can be undeleted).
The 'when' can be dropped from the log statement.
The logging message is a little confusing, it doesn't include the token.
The logging message is a little confusing, it doesn't include the name of the token.
why not simply String msg = String.format("Provision of snapshottable in " + argv[1] + ".");
why not just String msg = String.format("Provision of snapshottable in " + argv[1] + ".");
why not just out the try-catch?
(nit) Typo in log message
in this case we need to protect against using a file stream
log.trace if using multiple files
The changes in Elide are not specific to this class, as it is not specific to this class. Can we make it private?
The changes in Elide are not specific to this class, as it is not specific to this class. Can we mark it as final?
The changes in Elide are not specific to this class, as it is not specific to this class, so it should probably be private.
The commit message for this line is longer than it is currently a change.
The commit message for this line is longer than it is intended to be.
The commit message is incomplete.
I am unsure about the logic of this method. Will DLNAThumbnailInputStream.toThumbnailInputStream still get the correct image stream?
I am unsure about the logic of this method. Will DLNAThumbnailInputStream.toThumbnailInputStream still get the url if it is not a URL?
I am unsure about the logic of this method. Will DLNAThumbnailInputStream.toThumbnailInputStream still get the url when it is not a URL?
nit: would it be a good idea to override this instead?
nit: would it be a good idea to override this?
nit: would it be safer to check the prefixedTimestampTableName every time?
Shouldn't this be: if (!misoProperties.get("miso.autoGenerateIdentificationBarcodes")) { } too?
Shouldn't this be: misoProperties.get("miso.autoGenerateIdentificationBarcodes") &&!misoProperties.get("miso.autoGenerateIdentificationBarcodes")?
Shouldn't this be: if (!misoProperties.get("miso.autoGenerateIdentificationBarcodes")) { }
why we delete this function if we don't use hiveServerContainer?
why we call this function if we don't want to expand variable?
why we are not throwing exception?
I think this should be domainsVisibility.clear();
I think we should also rename this to we are going to use a different mechanism.
I think we should also rename this to we are using this to avoid any confusion?
Why is this needed OPEN? I would suggest splitting it of to a separate method/service if needed at all.
Why is this needed OPEN? I would suggest splitting it of next if statement
Two questions/remarks for here
Null-ptr check, please.
Null-ptr check, you should be sure to add a null check here.
Null-ptr check, you should be asserting that activity is non null.
we can use ReflectionUtils.makeColumnValueSelector()
I would prefer to create a method for computing that selector and instead of using the ternary operator we can just return true for the boolean field
I would prefer to create a constructor accepting the boolean field we use for returning boolean for computing.
I'd rather use mPluginStore.getWPOrgPluginBySlug() here.
I'd rather use mPluginStore.getWPOrgPluginBySlug instead of mPluginStore.getWPOrgPluginBySlug
I'd rather use mPluginStore.getWPOrgPluginBySlug instead.
I think this logic should be replace with return totalFilesSkipped == 0 || totalFilesSkipped == 0
I think this logic should be replace with return getFilesSkipped() == 0
nit: I think this logic should be replace with return getFilesSkipped() == 0
why not use assertFalse?
why not use assertFalse()?
above?
isEmpty()?
Formatting.
Can get rid of the substring() call?
mMap is used by the method name in the activity. Can it be final?
mMap is used by the static methods in the class, and with a reference to it. If it is used more than once, " mMap" is not used by the method name.
mMap is used by the static methods in the class, and with a reference to it, should be final
please use #isEmpty()
please use #if ( commandsCache.containsKey(key))
I'd add a warning to this method
Two things here: - It would be better to use RandomUtils for this. - get current millisecond timestamp and apply it to the Convertible one. - Also, use System.currentTimeMillis() as an argument to format the string
Two things here: - It would be better to use RandomUtils for this. - get current millisecond timestamp and apply it to the Convertible one. - While today we have a risk of clock skew, it might be better to use the 10000000 as the hale configuration and have a default sues for it.
double ;?
All three lines can be replaced with if (dataSource == null) {
All three lines should be done in a single place.
All three lines can be replaced with if (dataSource == null) {... }
This is not correct. Try to use parallelStream() since it is used to build the content of a List. If you use a normal iteration, you can use a LazyCollection.
This is not correct. Try to use parallelStream() since it is used a lot of other places.
This is not correct. Try to use a normal for loop.
Do you want to set the message text as well?
Do you want to end up with a message?
Do you want to set the message text as a cancel?
This is fine. A DeployVirtualMachineOptions needs to be created with a message. It should not be that big.
This check isn't needed anymore.
This check is not needed.
This should be more obvious
This should be more readable
This should be public
Oops is not related to the fix.
Unable to change this particular thing
Oops
if it is supported, please add a debug log here
Can't we re-format this?
if it is supported, please add a debug message
I'm not sure if this is the correct way to handle this. In this case, a RunnerException is thrown.
I'm not sure if this is the correct place. In general, would be to return false and throw an exception if the file doesn't exist.
I'm not sure if this is the correct place. In general, would be to return false and throw an exception if the file doesn't contain the file name.
Nit: add call to node.set(value, value)
Nit: add(new ObjectNode(node).set(field,value));
Nit: add(new ObjectNode(node).set(field, value));
You're return Optional.empty() here.
Shouldn't we throw a OptionalException here?
You're returning null here.
I guess the empty list is just a reference, so you don't need to do this.
I think empty list is fine, but just add to the message.
I guess the empty list is just a reference to the field.
Wrong method name in the error message.
Wrong method name in the error message
Wrong error message here.
huh this is creative, I've never thought to use the diamond operator when you're just casting to telephonyRegistryManager
huh this is creative, I've never thought to use the diamond operator when you're using it, which is not important
huh this is creative, I've never thought to use the diamond operator when you're just casting to encyrpts
Initialize this to new ArrayList<>()
Initialize the size of the store, and passed as the size.
Initialize this to new ArrayList<>(size).
Leftover debug message?
s/No production/fatal
getLabel
Please remove this line
Please remove this.
Use Logger instead of sysout.
Style inconsistency: space after if
Any reason for the spaces between if and (?
Any reason for the formatting of the line?
Maybe you should refactor this log message to something like "Something went wrong in Natura plugin MineFactoryReloaded."
Maybe you should refactor this log message to something like "Something went wrong in Natura plugin Mine factoryReloaded."
It looks like a lot of these log messages should be moved to the logger.
Nit: You could get rid of the first if statement by something like: if (!getMainAst.getParent().getText().equals(ASSIGNMENT)) { return new IndentLevel(result, getIndentCheck().getLineWrappingIndentation()); } else { result = new IndentLevel(getLineStart(getMainAst())); }
Nit: You could get rid of the second check: if (!getMainAst.getParent().getText().equals(ASSIGNMENT)) { return new IndentLevel(result, getIndentCheck().getLineWrappingIndentation()); } else { result = new IndentLevel(getLineStart(getMainAst)); }
Nit: You could get rid of the first if statement by something like: if (!getMainAst.getParent().getText().equals(ASSIGNMENT)) { return new IndentLevel(result, getIndentCheck().getLineWrappingIndentation()); } else { result = new IndentLevel(getLineStart(getMainAst)); }
Let's inline this into the previous line.
Let's inline this into the previous line?
Let's get rid of the cast and make it private.
Maybe change this to: LOGGER.debug("Configured Jasypt algorithm [{}] does not work for Jasypt algorithm [{}]", alg);
rather than checking for the property once, please change the log message to something like: LOGGER.debug("Configured Jasypt algorithm [{}] does not work for Jasypt algorithm [{}]", alg);
rather than checking for the property once, please change the log message to something like: LOGGER.debug("Configured Jasypt algorithm [{}] does not work for Jasypt algorithm: {}", alg);
You don't need this line, the default is IP file.
You don't need to play a file here. You can just play it in the play file.
You don't need to play a file here. What happens if the sink is null?
The check is not needed, if it is a directory.
The check is not necessary, the directory exists but is not a directory.
What happens if the directory doesn't exist? Throwing an exception might be a bit misleading...
You can just iterate on proposalProviders.stream().filter( proposalProvider -> provider.getNewEmtpyExpression()).collect(Collectors.toList());
You can just iterate on proposalProviders.stream().filter( proposalProvider -> provider.getNewEmtpyExpression()).collect(toList());
You can just iterate on the  proposals list.
To keep relying on public <M extends Externalizable>, we can skip the need for this method and just return a copy of the topic.
To keep relying on public <M extends Externalizable>, we can also use a factory method from the AbstractLogAppender.
To keep relying on public <M extends Externalizable>, we can skip the need for this method and just return a copy of the trimmed object.
Will this test fail if the name of the view is not defined?
Will this test fail if the name of the view is not supported?
Will this test fail if the name is not valid?
Same here, use this pattern: java return iterateUrlTemplates(target, urlTemplate -> { try { getRouteModel().getRouteTarget(urlTemplate, parameters); } catch (IllegalArgumentException e) { return null; } };
Same here, use this pattern: java return iterateUrlTemplates(target, urlTemplate -> { try { getRouteModel().getRouteTarget(urlTemplate, parameters); } catch (IllegalArgumentException e) { return null; } });
Same remark as above, use this pattern: suggestion return iterateUrlTemplates(target, urlTemplate -> {
I think this is fine as it's unrelated to the change in the PR description. I think it would be better to do this in a separate commit.
I think this is fine as it's unrelated to the PR.
I think this is fine as it's unrelated to the change you made in the PRs.
Maybe inline this variable?
Check if delimiter is still a delimiter.
Check whether this parsing works.
Same here. sourceVariableDescriptor should not be null.
Same here. sourceVariableDescriptor should be the same.
And sourceVariableDescriptor.
Here I would prefer to implement the hashCode() method to be consistent with equals().
Here I would prefer to implement it as return this == other;
return other;
1. Please change "getRepository" to "getInterfaceMethod". 2. Please change "getRepository" to "getInterfaceMethod".
/si/.
/si/..
Should this be a  defensive copy of the map?
Should this be a Map<AnyObjectId, List<T>> - - otherwise it will be a ruft, which the data could be loaded or loaded?
I think this should be a concurrent hash map.
This may be done in the UI thread.
This may not be the right place for this. You can just return null.
This may not be the right place to handle this.
Can this method be private?
can this method be private?
private seems to be more appropriate
Is there a way to test that there is no exceptions?
test should also check that there is a null return value
Is this a test?
log time only once.
move this to the method and return true at the end of the method.
move this to the method and return true at the end of this method.
I don't think the second part of the "if" is redundant - we already know that the disks are not image.
I don't think the second part of the "if" is redundant - we already know that the disk storage type was "IMAGE", no?
I don't think "else" is needed here
this seems like a significant change in behavior if we keep this class and log the event as debug instead of using the toString below.
this seems like a significant change in behavior if we are not using the toString method below. let's keep this to debug like below.
this seems to be debug right?
Why is this catch block? Are you sure this is fine?
Why is this catch block? Are you sure this is by doing anything?
Why is this catch block necessary?
StandardCharsets.UTF_8
Can we use the [StandardCharsets.UTF-8](<LINK_0> here?
Should we add some more information here, like kPathBuilder?
Is this needed?
Is this constructor used?
Is this used for the new field?
minor: this will need to be KeycloakUserRemover.
This is not needed. KeycloakUserRemover is a ServiceRemover so no need to bind it.
minor: this will need to be consistent with KeycloakUserRemover and KeycloakUserRemover
Don't need to call.get() here?
Don't need to call initMocks(this) since it is not needed
Don't need to call initMocks(this) since it is not used.
Why to add the todo?
Change to as the next assertion.
Change to as the next assertion
Maybe we could pass a LeaderRetrievalDriverFactory and then set it to false here instead of setting it in the constructor?
Maybe we could pass a LeaderRetrievalDriverFactory and then set it to false by default?
Maybe we could pass a LeaderRetrievalDriverFactory to this constructor and then pass in the builder instead of this null setting
The same as in the method before.
Again, I would prefer this error message as the second parameter to method.
The same as in the method name.
Can we do this?
Can we just throw the exception here?
Can we just throw the original exception?
I think you can switch the exception to: LOG.error("Worker netty server receive message this message", e);
I think you can safely re-raise the exception to the last catch block instead of having no log here.
I think you can switch the exception to: LOG.error("Worker netty server receive message this message", e)
You can use assertEquals here
You can use assertEquals() here instead of assertEquals()
You can use assertEquals here. This gives you a descriptive message.
Please wrap this if statement in {}
Please wrap this if statement in curly brackets.
Use { } even for one line statement.
get reportedConfigurations == null so this can be simplified
get reportedConfigurations == null ||!getAttached
get reportedConfigurations == null
It would be good to use Map<String, String> data = new HashMap<>();
Map<String, String> data = new HashMap<>();
It would be good to have the test with invalid notification id, just to make sure it is not visible.
The settings should be a static field
The settings should be a static field in this class.
The settings should accept this value, not return null.
super(String.class);
super(Noop);
public
Indentation is off here.
Indentation + 2 spaces too
Indentation here is off.
Did you mean to remove this line?
suggestion return Scoreboard.values().stream().map(s -> {
Did you mean to remove this TODO?
This should be /random.yml.
This should be a static final String in the class.
This should be /random.yml - right?
Do we really want to return true here? As written, could we maybe use a ternary here?
Do we really want to return true here? As written, could this method be called by the "protected" method? Or should it return void?
Do we really want to return true here? As written, could this method be called by the "protected" method?
You can use ContentTooLargeException directly, to avoid string concatenation
You can use the org.dspace.utils.ContentTooLargeException and place it in the message
You can use the org.dspace.utils.ContentTooLargeException and place it in the message as well
I would remove "Did not find any plugins"
I would keep this method private.
I would keep this method private
Actually, how does this line work? It doesn't line up with this change, but it seems that we don't need to call this method.
Actually, how does this line work? I don't see how it is that we're done with this change, which is not clean.
Actually, how does this line work?
why not return the set?
You could add a null check here
You could add a null check here if you want to return null.
Could use Guava's hashCode function
Could you use UUID.hash()?
Could use a hash function here.
What is this variable for? It is never used in the remainder of the code block.
@felipeaziziejski Should be thrown in the remainder of the code block for the remainder of the code block.
What is this variable for? It is never used in the remainder of this code block.
Is this correct then?
Is this correct then? Maybe we should do something like "setLabelFilter"?
Is this needed?
Add a failure from this semantics: public static EntropyWith(String type, String base) { try { return EmpiricalEntropy.get(0), base.length() + 1; } catch (Exception e) { return null; } } return null; }
Add a failure from this semantics: public static EntropyWith(String type, String base) { try { return EmpiricalEntropy.get(0), base.length() >= 0; } catch (Exception e) { return null; } } return null; }
Add a failure from this semantics: public static EntropyWith(String type, String base) { try { return EmpiricalEntropy..... } catch (Exception e) { return null; } } return null; }
nitpick: you can use == here
nitpick: should declare a variable for clarity.
you can simply return true here.
this should throw an InitialisationException
Put this check to a static method
this should throw an IllegalStateException, but here we use.isThrownBy
What's the purpose of this?
The parameter needs to be 1 since we have a marker with no children.
The parameter needs to be 1 since we have a proper distribution.
This loop is duplicated -- we could have a single method "rewriteGitSendBundleActivity(IActivity)" that would then work to remove the implementation.
This loop is duplicated -- we could have a single method "rewriteGitSendBundleActivity(IActivity)" that would then work to remove that duplication.
This loop is already done in any other method. Here it is a duplication.
still need to catch AttributeNotFoundException and print it from PartialSS
still need to catch AttributeNotFoundException and print it in the console.
still need to print the stack trace.
I'd suggest to change the message here to "Failed waiter timeout of " + _poolName + "ms: in Pool: "+_poolName+": "+ _poolName);
I'd suggest to change the message here to "Failed waiter timeout of " + _poolName + "ms: in Pool: "+_poolName+": "+ _poolName
I'd suggest to change the message here to "Failed waiter timeout of " + _poolName + "ms: in Pool: "+_poolName+"; and for _poolName : "+ _poolName
I think this can be turned into a method reference.
I think this can be turned into a method reference. Also, the JavaFileScannerContext.Location("This call can throw an expected exception", expr)
I think this can be turned into methodInvocationTrees.stream().map(Path::new).collect(Collectors.toList())
Are you sure this is correct?
Are you sure this.data is not null?
Are you sure this is required?
Can we please remove this empty line?
Can we test this with some sort of poll (i.e. just the name of this user)?
Can we test this with some sort of poll (i.e. just the name of these items)?
nit: No need to print out organizationDiscoveryIntervalMillis.
nit: No need to print out organizationDiscoveryIntervalMillis, everything is done
nit: No space after =
Should you also test the no-arg SSLFactory from the test?
Can you also use @Rule ExpectedException?
Should you only use @TestUtils. test?
Is this the correct usage of compareAnnotationValue or av2?
Is this the correct usage of compareAnnotationValue?
Is this a test?
@ivanarrizabalaga why not catching exception and wrap it in a RuntimeException?
@ivanarrizabalaga why not catch Throwable?
@ivanarrizabalaga why not catching exception and re-throwing it?
@NotNull is not required
@NotNull is not required in constructor
@Nullable
Add some space after the comma.
Add space after "()" so it gets indented.
Add some spaces.
Should this method check getT()?
Should this method check _before_ calling execute()?
Should this method check _before_ throwing an exception?
I would delegate to the new method directly
I would delegate to the delegate.
I would delegate. the method directly
You can do this instead. proxyPorts.stream().map(s -> "localhost:" + proxyPort);
You can do this instead. proxyPorts.stream().map(stripe -> "localhost:" + proxyPort);
You can do this instead. proxyPorts.stream().map(stripe -> "localhost:" + stripe).collect(Collectors.joining(",", stripes));
Please close this line, if possible
Please close this line, too.
Please close this line, if possible.
Can be simplified to new ArrayList<>(kryoCompatibilityMap.values())
Can be just new ArrayList<>(kryoCompatibilityMap.values())
Can be simplified to new ArrayList<>(kryo TransportMap.values())
why public?
Can be private
why not just inline this map?
This should use System.err.
This should use System.err
This should be System.err
See ByteByReference.java
See ByteByReference#java
See ByteByReference
I think we should make it private.
There is no need to declare this method public
I think we should make this method private.
suggestion List<byte[]> actualArgs = whereClauses.getArguments();
suggestion List<byte[]> actualArgs = whereClauses.getArguments().stream().map(f -> assertThat(f.get(i)).isEqualTo(expectedArgs.get(i));
suggestion List<byte[]> expectedArgs = whereClauses.getArguments();
i think we had talked about swapping the order of these so we can short-circuit?
i think we had talked about swapping the order of these so we can short-circuit? i.e. we can short-circuit?
i think we had talked about swapping the order of these so we don't have to acquire the report count outside of the initializer.
if storeKeepIndexInMemory is false, you won't need to store it as a null check.
if storeKeepIndexInMemory is false, you won't need to store it as a void.
log related metrics
add: import org.ovirt.engine.core.common.utils.Pair;
add: import org.apache.commons.lang3.Validate;...
please remove this as well
This should be merged into the SurfaceGenerator constructor
This should be outside the DesertPopulator, not a DungeonPopulator.
This should be merged into the SurfaceGenerator constructor since its not implemented
i think this is a common place for InjectionHelper.inject(screen). onOpened()?
i think this is a common place for InjectionHelper.inject(screen).onOpened()?
i like the idea of InjectionHelper.inject(screen).onOpened() is better than InjectionHelper.inject(screen).
Should we throw an exception if the authentication fails?
Should we add this log line as well
Should we throw an exception if the tenantDomain is not null?
nit: Root query in the exception message
I think it's a bit easier to understand if it's return or throw an exception
I think it's a bit easier to debug if it's logged in the exception
This should probably be annotationType.getDeclaredAnnotations()
anyMatch() should be noneMatch( )
This anyMatch() should be noneMatch( )
Wouldn't it be better to use.endsWith(".jar") here?
Wouldn't it be better to use.replaceAll()?
Wouldn't it be better to use.endsWith("..") here?
Doesn't this need to be conditional on the terminator, not the isEmpty check?
Doesn't this need to be conditional on the terminator list?
Doesn't this need to be conditional on the terminator, not the 'else' case?
I would log the remote peer address being set.
IMHO this should be DEBUG logging.
I would log the remote peer address being set..
this method can be private
Should be externalized.
Should be created in setup.
The exception should be caught and changed to throw the same exception.
The exception should be caught and changed to the method name.
The exception should be shifted into the method call.
I assume this function must only be called if the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
I assume this function must only be called when the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
I assume this function must only be called if the service is activated.
This should be "Failed to filter log with "+f, e".
This should be "Failed to filter log with "+f, e" so we have the full stacktrace in the log.
I thought you wanted to have this in the repo?
CHANGE it to TypeConstants.JAVA_LANG_RECORD
CHANGE it to TYPE_DECK_DECL?
CHANGE it to TypeConstants.JAVA_LANG_RECORD?
Why is this called 'displayDensity'?
Why is this called'displayDensity'?
Why public?
What do you think about setting the state parameter in the init method?
What does this init means?
why do you need this change?
ShadowActivity.getNextStartedActivity()?
ShadowActivity.getNextStartedActivity() already checks if you're testing on ShadowActivity.setInstance().
ShadowActivity.getNextStartedActivity() already checks if you're testing.
Mind fixing the copy and paste error, %n
Mind fixing the %n
Mind fixing an %n
I don't think we should assume that the Version.compareTo(new Version(2, 1) is safe here, right?
I don't think we should assume that the Version.compareTo(new Version(3, 0) is less than 2, not >=3. Just check for > 1 instead.
I don't think we should assume that the Version.compareTo(new Version(3, 0) is less than 2, not >=2.
Also, in the @After method, this should be called getEntityKeyOnlyQuery(entityClass)
Also, in the @After method, this should be called getEntityKeyOnlyQuery().
Also, in the public methods above, this should be public.
Should we include organization here too?
Should we include organization to the log statement?
Should we include organization to the log message?
Again, I think this should evaluate against the standard special path info, not the stuff for the maven package
Again, I think this should evaluate against the standard special pathInfo, not the stuff for the maven package
Again, I think this should evaluate against the maven package
can be replaced with for (E iterator = endpointProvider.take()) { iterator.next(); }
can be replaced with for (E iterator : endpointProvider.toList())
Indentation?
IMO, we don't need to have the completedWithFalse() in the case of the connectionIsOpen
IMO, we don't need to have the completedWithFalse() in the case of the error.
IMO, we don't need to have the completedWithFalse() in the cases where the connection is closed.
Since this is a constant, consider replacing it by a constant just like you did on the other classes.
OuiaConstants has a constant for "qe-dmn-grid-context-menu-item".
Missed this.
This doesn't belong here, we have to create the CompletionStages.join() method
This doesn't belong here, we have to create the CompletionStages.join() method in the client code base. I don't see any reason to make this a public method
This doesn't belong here, we have to create the CompletionStages.join() method in RpcManager...
Formatting.
Wow, nice catch.
Wow, nice catch there!
Incorrect message. Should be "This version must not be null."
Incorrect message. Should be "This is not null."
Incorrect error message. Should be "This is not a valid transition"
I know you said this PR but I think it would be handy to also verify that it is correct by the parser.
I know you said this PR but I think it would be handy to also verify that it is correct as well.
I know you said this PR but I think it would be handy to also verify that it is correct as well
This is breaking change-sensitive. You should use IndexModule.NAME here.
This install method should be called in the AddIndexModuleRule.
This should be public.
Since we're already using activity.startActivityForResult(typedActivityBase.getIntent(), typed.getRequestCode()); I don't think this is right. But I'll merge it.
Since we're already using activity.startActivityForResult(typedActivityBase.getIntent(), typed.getRequestCode()); I don't think this is right.
Since we're already using activity.startActivityForResult(typedActivityBase activity, typed.getRequestCode()); I don't think this is right.
We should use here the same message as for failValidation(EngineMessage.CANNOT_PLUG_PASSTHROUGH_VNIC_VF, String.format("vnicName %s", getInterfaceName()));
We should have a method for this. That is the same.
We should have a method for this.
@Override is not required.
This null check is not needed.
Redundant with this.
I think we should log this also in debug, no?
I think we should log this also in debug, since this would be useful for debugging.
I would do this in a RuntimeException
Is the super() necessary?
Just use the keyword "super()"
Just use the keyword "super()" here.
Inject the method in CompilationTestHelper as well
Whitespace after }
Inject the thread.
one more method can be used: - PageFactory.initElements(driver, this);
one more method can be used: - skip this constructor, and reuse: PageFactory.initElements(driver, this);
one more method can be used: - executeElements()
please use StringBuilder, and it's more efficient and safer.
Please use StringBuilder, and it's more efficient and less error prone.
Please use StringBuilder here.
Please use Vector2d.equals(x, v.getX())
Please use Vector2d.equals(x - v.getX())
Please use Vector2d.equals(x, y)
Does this method need to be public?
Does this method need to be registered for the non-default columns?
Does this method need to be registered for the non-labels?
can you please add a helper method for performing it? this code is repeating itself in all of the classes.
i'd create a getter for the parameters
extract to variable
here you can use org.ovirt.engine.core.common.utils.Props.CONFIG instead of hard coding the code here.
here you can use org.ovirt.engine.core.common.utils.Props.CONFIG instead of cast
same here.
For this method, I wonder if this is a better design to do readTree(body) instead of create a new ObjectMapper every time.
For this method, I wonder if this is a better design to do readTree(body) instead of create a new ObjectMapper each time.
For this method, I wonder if this is a better design to do readTree(body) instead of create a new ObjectMapper per method call.
can you call this(nameOrKeyQuery, null, null) here?
can we maybe call it this(nameOrKeyQuery, null, null) here?
can we have something like this? this(nameOrKeyQuery, null, null);
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
returning boolean type is useless here because it can only return **false**, or throw timeout exception.
returning boolean type is useless here since it can only return **true**, or throw timeout exception.
This is a breaking change and should not be reverted.
This is a duplicate of the code, only used in LargeInternal. I think we can remove it.
This is a duplicate of the code, please extract it to a separate method.
please remove this line.
EnvUtil.storeTimestamp
EnvUtil.storeTimestamp should be used everywhere else.
Should be protected.
Does this need to be public?
Should be private.
I believe this return should be PluginUploadResponse.create(false, null, errors);
I'd rather return PluginUploadResponse.create(fileName, filename); here.
You need to return PluginUploadResponse.create(false, null, errors); to prevent validations.
Is this supposed to be FOUND_CYCLE?
Is this important? Should we throw UnsupportedOperationException instead? Or just make it very specific.
Is this important? Should we throw UnsupportedOperationException instead? Or just make it very specific to the exception message?
Why this method can't be imported?
Why this method is changed?
<LINK_0>
you need to catch Exception here too.
you could also catch Exception here
you need to catch Exception here
we should use MANY_TO_ONE here
can we rename this to checkRecursiveOrEmpty?
can we rename this to checkRecursiveOrEmpty
This might as well become if (log.contains(id)) { log.debug(..) }
This might as well become if (log.contains(id)) { log.debug(..)} since the logger will be able to optimize it.
This might as well become if (log.contains(id)) { log.debug(..)} since the id is not valid.
This can be moved to the add() method.
This can be moved to the method.
This can be private.
Please add braces.
Please add {...} after if.
You should add {...} after if.
chProfiles.isEmpty()
chProfiles.isEmpty() should be used
If chProfiles.isEmpty()?
change to return String.format("Unrecognized value.", art.getGuid())
change to return String.valueOf(toReturn).toString();
change to return String.valueOf(fromReturn).getGuid(toReturn)
If m_segments.firstEntry() is null, we should still be checking m_segments.firstEntry().
If m_segments.firstEntry() is null, we should throw an exception because the entry is not found. It should be ignored if it is null.
If m_segments.firstEntry() is null, we should throw an exception because the index is out of bounds.
nit: I don't think you need fully qualified path name. it can just be CompletableFuture<LedgerEntries>.
nit: I don't think you need fully qualified path name. it will work in all cases.
nit: I don't think you need fully qualified path name. it will be enough to have it fully qualified name.
This can be package private.
This can be package private. No need to mark it as private.
This can be package private?
Can we make it static?
Can we make it final?
You can use ERO_DOUBLE
You may not need to check if appender is null.
You may not need to check if the appender is null.
You may not need to call Logger.removeAppender(loggerName) here
This should be getLookup()
This if branch can be merged
This if should be return value == null
I don't think this is correct. It's not a public API, it's only used in tests. The only usage is to make it package private. protected.
I don't think this is correct. It's not a public API, it's only used in tests, but it makes sense to move this requireNonNull to the end of the class
I don't think this is correct. It's not a public API, it's only used in tests. The only usage is to make it package private.
Strange naming, I think,'selectByNameAndLanguage' does not conform to current implementation of QualityProfileDto.
Strange naming, I think,'selectByNameAndLanguage' does not conform to current implementation of QualityProfileDto
Strange naming, I think,'selectByNameAndLanguage' does not conform to the QualityProfileServiceImpl.
Maybe remove the public modifier as it's not used anywhere.
Maybe I worked to much with the old constructor via Objects.requireNotNull() instead.
Maybe remove the public modifier as suggested.
I think we should throw an exception if the method is null.
I think we should throw an exception if the method is not defined.
I think we should throw an exception.
These are the wrong way to get the data, this is to call db.getData("/key", stat, null); If the data is a local variable, you won't have to create a new one.
These are the wrong way to get the data, this is to call db.getData("/key", stat, null) before the zk data is updated to return the same value.
These are the wrong way to get the data, this is to call db.getData("/key", stat, null); If the data is a local variable, you won't have to construct a new one every time. getKey returns a non-null array.
no need for else and else
no need for else and return null
no need else
StringUtils.isEmpty
assertNull
Can you please use assertEquals instead?
Is there any reason to select this action instead of selectLeftTopCell?
Is there any reason to select this action instead of tracking the whole page?
Is there any reason to select this after click?
Change this to StringUtils.endsWith("., FormsMigrationConstants.BPMN2_EXTENSION", fileName)
Change this to if (fileName.endsWith("." + FormsMigrationConstants.BPMN2_EXTENSION)) {... }
Change this to if (fileName.endsWith("." + FormsMigrationConstants.BPMN2_EXTENSION) {... }
Do we need to pass 0.6f as an argument to this function?
Do we need to pass 0.6f?
Do we need to pass 0.6f as an argument to the function signature?
Throw a RuntimeException like this: java Objects.requireNonNull(result, "'result' must not be null");
Throw a RuntimeException like in the method signature.
Throw a RuntimeException like this...
The name of the free vars in the hierarchy is a bit confusing. It is not a free variable-name and it is named free vars-name. Same in the rest of the codebase.
The name of the free vars in the hierarchy is a bit confusing. It is not a free variable-name and it is named free vars-name. Same in the rest of the PR
The name of the free vars in the hierarchy is a bit confusing. It is not a free variable-name and it is named free vars-name. Same in the rest of the PR.
Missing "this" qualifier.
Missing the "this" qualifier.
Missing null checks for the parameter.
why not Boolean.valueOf(type)?
why not just return type?
this is not correct. Schema.Type.STRING is a primitive boolean, so it should be boolean.
@tumijacob Rather invert this logic and throw if the user is null. The reason for this is because one has an Exception like you have pointed out. Thanks for picking this though
@tumijacob Rather invert this logic and throw the exception if the user is null. The reason for this is because one has an Exception like you have pointed out.
@tumijacob Rather invert this logic and throw if the user is null. The reason for this is because one has an Exception like you have pointed out.
Maybe add a check on the type of recoveryProblems?
Maybe add a check on the "isRecoveryProblems" before accessing the map.
Maybe add a check on the "isRecoveryProblems" string too?
Use a null guard here instead
Use || instead of null check.
Use || instead of null check everywhere
Could you put this in a @Before method?
A very minor thing. How about adding a this.mVerifyStr = null;?
Could you put this in the tear down?
nit: please use Collections.emptyMap() instead of creating a new one every time.
nit: please use Collections.emptyMap() instead of creating a new instance every time.
nit: please use Collections.singletonMap(map, singletonMap)
Please use the information from CircuitBreaker. It will be more correct to use conditionals for creating the name.
Please use the information from CircuitBreaker. It will be more correct to use conditionals for creating CircuitBreaker.
Please use the information from CircuitBreaker. It will be nice to use a map.
Add and offer are same thing for Nodes.
Add to container.
Add and offer are not null.
nit: This could be a collapsed into a single line. java thenApply(ignored -> Collections.emptyList());
nit: This could be a collapsed lambda.
nit: This could be moved to the first line.
return ImmutableList.of();
return List.of(FIELD_TAGS);
return all getTags(subscribed)
Should be Log.e(e, "Error while trying to create or log", t);
Should be Log.e(e, "Error while trying to create or log",t);
Should be Log.e(e, "Error while building Pending {config.error}");
SecurityException?
Is this better as getProperty?
SecurityException.
s/.LightboxHeader').css('s JLabel("(\)', 'initial')'));
s/.LightboxHeader').css('s JLabel("(\)', 'initial')')/
s.LightboxHeader
this should be a IllegalArgumentException
this should be a utility method
typo
s/ CustomSpeedControllers/
capitalize "To"
typo
Unnecessary
Name it right?
Simplify it?
Could be replaced with while( warnings.size() <= warnings.size())
Could be replaced with while( warnings.size()).
Could be replaced with while ( warnings.size() <= warnings.size())
You could use Objects.equals for equals
You could use Objects.equals for equals comparison. It does not need to be null.
You could also use Objects.equals for equals
This seems like a debug statement that should be removed.
This seems a bit redundant.
suggestion
this logging statement should not be needed since it has been used in 2 places
this logging statement should be removed since it is in the lamda
this logging statement should not be needed since it has been used in 2 different places
Given that you have a RowRanges visit(Not) and an RowRanges. visit(Not) - should you also run the predicate against a not-found field, or?
Given that you have a RowRanges visit(Not) and an RowRanges. visit(Not) - should you also explain why this message is not used?
Given that you have a RowRanges visit(Not) and an RowRanges. visit(Not) - should you also run the predicate against a not-found column name?
Could be replaced with registryURLObservable.setValue(ret);
I would rather have a slightly more precise name. It's not clear who's selected when it is not there, though.
I would rather have a slightly more precise name. It's not clear who's selected when it is.
Could you also rename this variable isInTransition and isGenotypeInTransition to isGenotypeInTransition?
Could you also rename this variable isInTransition and isGenotypeInTransition to isGenotypeInTransition? So that the logic is slightly clearer.
For a simple test case, I think the logic is slightly clearer with letting isGenotypeInTransition take in a Transition type.
You should need to clear the cache in the use case where the model is actually null. You should just call get and check if it is not null.
You should need to clear the cache in the use case where the model is coming from the cache.
You should need to clear the cache in the use case where the model is actually null.
I wonder if we should also delete the FusedLocationProvider and verify not only provider
I wonder if we should also delete the provider and then add it to the provider
I wonder if we should also delete the FusedLocationProvider and check it before creating a new provider?
This should not be public. 'public' is not required.
This should not be public. 'public' is for a public method.
This should not be public. 'public' is for a public API option.
Strange check. Why there is no empty string?
Strange check. Why is this case necessary?
Strange condition and there is no upper bound. Why not use isBlank?
I would rename the variable to imagesInDb
I would rename the variable to imagesInDb to better name
I would rename to vm.getImages() and use DiskImage to avoid confusion
Why use try-with-resources ( (T) rs.getObject()) instead of (T)?
Why use try-with-resources ( (T) rs.getObject()) instead?
Why use try-with-resources?
Make this private and remove the public modifier.
Make this private.
Make this private and introduce a factory method like JSONPointer(List<String> tokens)
I know this is the only place where we do this, but why not make this private like the others?
I know this is the only place where we do this, but this should probably be final.
I know this is the only place where we do this, but why not make this private or at least package protected?
Can we use Context.setRebaseTrucks instead of creating a new method here?
You can use onViewCreated() and then set a callback for all your tests. What do you think?
You can use onViewCreated() and then set a callback instead of creating a new method.
**USB**
**USB** If the method is only called once, it is probably deceptible to NPE. If the User wants to start background discovery tasks, the binding should fail.
**Saml**
ArrayList should be constructed with fixed capacity.
This should probably be Collections.singletonList(RAND)
Why not ArrayList<Integer> list = new LinkedList<>(Integer.MAX_VALUE);
This method is not executed from the context of the workspace.
This method is not executed for all workspaces.
allAnalyses
It looks like you're doing page.getChannelCount() here but then, why is it a method, and not just call page.getChannelCount()?
It looks like you're doing page.getChannelCount() here, but then, you're setting the same value in addRows(). Why not just call addRows(channelCount, fixedWidthRowSize, variableWidthChannels, outputBuffer)?
It looks like you're doing page.getChannelCount() here, but then, you're setting the same value in addRows(). Why not just call addRows(channelCount, fixedWidthRowSize, variableWidthChannels, outputBuffer) and remove the extra variable?
I'd recommend using setDiscussions here since it makes it more readable and removes a lot of unnecessary object creation.
Is setting the status to set available here intentional?
I'd recommend using setDiscussions here since it makes it more readable and removes a lot of unnecessary work.
Exception's should be logged at least
Exception's should be logged at debug.
Exception?
I know this is PR but maybe it would be better to use a constant for 2 and 3 to explain what this number means?
I think it's better to wait for element size to be 2 or 3?
I think it's better to use setText() here
@dmzaytsev similar thing here, could you please use link().set(something) here?
@dmzaytsev similar thing here, could you please use linkPath instead of link?
@dmzaytsev similar thing here, could you please use linkPath instead of link URI?
Windup/Discover/
externalize strings
externalize string
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
It seems Math.abs() is missed. What about negative rows? And also please, add {} arround the procedure.apply(...)
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...).
No, this property should be on dspace.index.commit. How about dspace.index.commit?
No, this property should be on dspace.index.commit.
No tspace.index.commit property anymore ;)
Fantastic coverage, thank you!
Can we add java doc, for example, and for java doc?
Can we add java doc, for example?
style nit: no braces around single line blocks
style nit: no braces around single line block
style nit: no braces after if
might want to consider throwing Exception or some other mechanism to handle it.
might want to consider seeing this one before?
might want to consider throwing Exception, since the caller doesn't have to handle it
we really need 1024 * 1024?
we really need 1024 * 1024 * 1024?
there is really such magic number 1.0 / 1024?
You could use Session.of(EObject)
You could use Session.of(EObject) here
You can use Session.of
Should't we call incrementInvalidationEvents() here? Same question for updateEntry and updateEntry.
Should't we call incrementInvalidationEvents() here? Same question for updateEntrySet().
Should't we call incrementInvalidationEvents() here? Same question for updateEntry and updateEntry too.
The disabled image is set inside the actionbar, so it is not really set here.
The disabled image is set inside the actionbar, so it is not set here.
The disabled image is set inside the action.
you can use string.format() here
you can use string literal here
you can use stringbuilder
Wrong method - the validation in the method above should be taken care of by the other invocations.
Wrong method - it's already protected by private.
Wrong method - it's already protected.
foreach
rid of this line
rid of this
This method doesn't make much sense for a public method. I think it's not needed.
This method doesn't make much sense to me. If we need to make it public, it would be better to not throw an exception.
This method doesn't make much sense to me. If we need to make it public, I would expect that we should be able to call private here.
@ekondrashev Here too, let's declare throws Exception
@ekondrashev Here too, let's declare this variable outside the class
@ekondrashev Here too, let's declare this variable
Are these methods public?
Are these functions used?
Are these functions public?
This should be in a finally block
Lets remove this check
Lets remove this
We should invoke the method's init() method.
Its better to invoke the method directly without casting.
Its better to invoke the method directly and invoke the init() method.
the put will remove the previous mapping
the put will remove the previous mapping. keep the previous mapping
the put will remove the previous mapping. is that ok?
This one too, returning "" is fine.
This one too.
This one too
Might be worth replacing the isActive() call with a catch (IllegalStateException e)
Might want to give a reference to the defaultEventLoop.isActive()
Might want to give a reference to the defaultEventLoop.isActive() method here
We need to make sure that the connectionlessProtocolList can contain asList.
We need to make sure that the connectionlessProtocolList can contain null.
We need to make sure that the connectionlessProtocolList can contain asList items.
why there is no value in the first place?
why there is no value in both cases?
why there is no value?
With this API, char[] matcher = pattern.matcher(input).appendReplacement( matcher.group().charAt(0));
Same thing here - StringBuilder instead of StringBuffer.
Same thing here - StringBuilder instead of StringBuilder.
no need to break long strings... check that it actually has an exception
no need to break long strings... check that it actually has an expected attribute...
no need to break long strings
you can set it to 1_000_000L inside the constructor
you don't need the "_000_000L"
you can make this a static final and make it a constant
Could you add a deferredRecords.clear() method in this class?
Could you add a deferredRecords.size() at the end of this method?
Could you add a deferredRecords.clear() method in this class. It is only used to iterate over.
Not 100% sure about this, but I think we can simplify it like this: java return findUnRevokedAccount(tokenHash).map(handle -> handle.createQuery( "SELECT account_id, coalesce(type, 'API') as type, coalesce(token_type, 'API').bind("token_hash", token_hash));
Not 100% sure about this, but I think we can simplify it like this: java return findUnRevokedAccount(tokenHash).map(handle -> handle.createQuery("SELECT account_id, coalesce(type, 'API') as type, coalesce(token_type, 'API').bind("token_hash", token_hash));
Not 100% sure about this, but I think we can simplify it like this: java return findUnRevokedAccount(tokenHash).map(handle -> handle.createQuery("SELECT account_id, coalesce(type, 'API') as type, coalesce(token_type, 'API').bind("token_hash", token_hash);
Add a space before the {
Add a space before the "Can not be found" message
Add a space before the "Can not be found" bracket
Put brackets around conditional bodies.
just return true;?
Put brackets around conditional bodies, please.
You should be able to use the non-Wiki API instead of two lines: return url + wikiName + wikiPath;
You should be able to use the non-Wiki API directly, for example: return URL + wikiName + wikiPath;
You should be able to use the one bellow for a null check.
s/test message/test message/
maybe the assertion should be on the new line?
s.o.
I don't think you need to check for null. The serviceConfigTypeAmbariToOriginalPattern already has the same information.
I don't think you need to return the'serviceConfigItemType'.
I think you should make the method private.
replace with fType.add(DescriptorType.NUMERICAL, DescriptorType.TIMESTAMP); the idea with EnumSet is that as you see values you just add() them to the set, without having to care for the current contents. Then when reading you can check things like contains(), or the utility methods like isNumer() proposed above.
replace with fType.add(DescriptorType.NUMERICAL, DescriptorType.TIMESTAMP); the implementation with EnumSet.of(DescriptorType.NUMERICAL, DescriptorType.TIMESTAMP) at the top of the file. Then the implementation can be simpler.
replace with fType.add(DescriptorType.NUMERICAL, DescriptorType.TIMESTAMP); the idea with EnumSet is that as you see values you just add() them to the set, without having to care for the current contents. Then when reading you can use new EnumSet, you can check values() at the beginning of the set and get rid of the utility.
Is this method used anywhere?
Is this method used?
Same issue as above.
nit: This method does not seem to be used.
nit: This method does not seem to be used. Just remove it.
nit: this could be static
Please use something like assertEquals("abc", list.toString());
Please use something like assertEquals("abc".getBytes(txt), list.toString());
Please use something like: assertEquals("abc", list.toString());
Is this a WARNING? Should we have a WARN as well?
Why do we need a try/catch block here? I mean, we can log the exception here.
Is this a WARNING?
package visible only
We should add the blurb, to the ss.size()
package private?
You could rather use org.apache.commons.lang3.StringUtils.write(in, String.valueOf(buf))
You could rather use org.apache.commons.lang3.StringUtils.write(in, String.valueOf(String))
You could rather use org.apache.commons.lang3.StringUtils.toImmutableList()
@since 3.13 missing
If you want to add this.mode = enabled? It's a bit more readable.
If you want to add this.mode = enabled? It's a cleaner approach.
I don't think you need this.
Why did you change this?
I don't think you need this call.
Would prefer to use a tighter check here. As-is, setting to "druid.coordinator" or " overlord.enabled".
Would prefer to use a tighter check here. As-is, setting to "druid.coordinator" or " overlord.enabled" would be a simpler.
Would prefer to use isNotBlank here.
Nitpick: I think you can use Map.getRoboGuiceList() to get rid of one-liners.
Nitpick: I think you can use Map.getRoboGuiceList() to get rid of one-liner.
Nitpick: I think you can use Map.getRoboGuiceList() to get rid of this to throw exception.
It won't throw an exception anymore
It would be nice to instantly see this exception type in the enum.
It won't throw an exception in that case.
This is probably unnecessary, you need to directly test this.
Does this test fail if you remove fps, which is over the absolute time?
Does this test fail if you remove fps, it does not need to be the same?
for these tests to pass if the exception is thrown, then the test will pass.
for the test to work properly, why do we need to change the test?
import fail; why?
May be we should throw UnsupportedOperationException instead?
does this need to be public?
Public?
Since the transport provider is closeable, and should be closed in a finally block.
Since the transport provider is closed and should not be closed, we should add a log line.
Since the transport provider is closeable, and should be closed in a finally clause.
Same here. I would prefer to not introduce softly.assertThat(query.getParameterBindings()).hasSize(1)
Same here. I would prefer to not introduce softly.assertThat( query.getParameterBindings()).hasSize(1)
Same here. I would prefer to not introduce softly.assertThat(query.getParameterBindings()).hasSize(1);
If this was at the Payment  validator level it would use Set<ConstraintViolation<ChargeCreateRequest>> constraintViolations = validator.validate(telephoneChargeCreateRequest); and then it could be passesValidationForNullCardExpiry. If that's not the case, then it could be passesValidationForNullCardExpiry.
If this was at the Payment  validator level it would use Set<ConstraintViolation<ChargeCreateRequest>> constraintViolations = validator.validate(telephoneChargeCreateRequest); and then it could be passesValidationForNullCardExpiry. If that's not the case, then it should be passesValidationForNullCardExpiry.
If this was at the Payment  validator level it would use Set<ConstraintViolation<ChargeCreateRequest>> constraintViolations = validator.validate(telephoneChargeCreateRequest); and then it could be passesValidationForNullCardExpiry.
You can do result = 31 * result + viewId;
You should update the hashCode() method since this class is using equals().
You should update the hashCode() method since this is public.
Let the user pass invalid versions! This will crash if the service doesn't allow a crash suggestion returnapiVer.equals(sJsApiVersion);
Let the user pass invalid versions! This will crash if the user didn't specify a crash suggestion returnapiVer.equals(sJsApiVersion);
Let the user pass invalid versions! This will crash if the user passes without a crash suggestion return false;
you could write this shorter: java return isBinary(buffer, 0, buffer.length);
you could write this shorter: return isBinary(buffer, 0, buffer.length);
you can write this shorter: return isBinary(buffer, 0, buffer.length);
it would probably be more appropriate for all these commands to take an empty map instead of an empty map.
it would probably be more appropriate for all these commands to take here, since this is not an abstract class in VdsBrokerCommand
it would probably be more appropriate for all these commands to take here, since this is not an abstract class in VdsBrokerObjectBuilder
Please assume usage of applicantService and jsonUtil.toJson
In success response I think, 200 is enough
In success response I think, 200 is enough. It will be enough
Consider using a method reference here
Consider using a method reference here <LINK_0>
Consider using a loop here
These should be info level too.
These should be level too.
These should be info level instead of info.
Why is this not a constant?
Why not use the constant in Consts.java?
Why not use the constant for the URL?
you could add "public TmfTimeRange getCurrentRange();" to the constructor
you could add "public TmfTimeRange getCurrentRange()" to the constructor, for consistency
you could return getCurrentTraceContext().getCurrentRange(getCurrentTraceContext())
The G.allGrids() method is not necessary.
The G.allGrids() method is not needed here
Override is not needed here
I believe it can be simplified to return (!value.equals("true") &&!value.equals("false");
I believe it can be simplified to return (!value.equals("true") &&!value.equalsIgnoreCase("false");
I believe we can use Boolean.parseBoolean(value, "true") here to check that value is not null.
DEFAULT_IS_OPS.PropertyIsEqualTo = DEFAULT_MATCH_CASE
this isn't needed
this isn't needed?
You can use String.valueOf(getTenant().getId())
You can use Value.of(getTenant().getId())
You can use Value.of(getTenant().getId()) here
return Objects.requireNonNull(context, "context is null");
return Objects.requireNonNull(context);
can be final.
Could probably be private instead of protected, which if so, would be preferred.
Could probably be private instead of public, which if so, would be preferred.
Could probably use Preconditions.checkNotNull() instead of this check.
if you use assertEquals(restTemplate.nonNull(name), () -> new AxonConfigurationException(..., name)));
if you use assertEquals(restTemplate.nonNull(name)
not a big deal, but we can use assertThat(restTemplate.nonNull(name)) for both lines
consider moving the compiled pattern into a static final field.
consider moving this into a static final constant.
consider moving the compiled pattern into a static final constant.
throws RestApiException not necessary.
throws RestApiException not needed.
throws RestApiException not needed here
Please change to externalSearch = ExternalSearch.getInstance().markerSearchEngine( referer );
Please change to externalSearch = externalSearch.getInstance().markerSearchEngine( referer );
Please change to externalSearch = ExternalSearch.getInstance();
You can use the new EditorPartPresenter.onResourceChanged(event) method
You can use the method directly
You can use the method directly.
(HunkHeader[, SarosHeader](<LINK_0> ). It might be better to add a new method in the toString and use this method in the OSC.
(HunkHeader[, SarosHeader](<LINK_0> ). It might be preferable to add a new method to the toString method and use this method in the OSC.
(nit) Text should be in toString method :)
return (TInterface) invoice;
A MultiMap might be more suited here.
return (TInterface) invoice;?
please replace with verify(adminDAO, never()).executeSQL(null, true);
please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean());
please rename verify to verify(adminDAO, never()).executeSQL(null, true);
Please, move the check at the beginning of the method.
Please, move the check at the beginning of the map.
Please, move the check after the map.
I think you can call isEmpty()
I think you can return vds here
I think you want to call the getAlternateUpServerInCluster method
Nice. I would rather have a test on the ugly field in this class that makes it easier to implement
Nice. I would rather have a test on the ugly constructor
The error message is incomplete
Vered - Good catch. s/proceed/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not get into corner cases :) )
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not discard the entity. End action should be completed.
s/the//
s/notAvailable - count/isAvailable
s/bytesAvailable - count/bytesAvailable
> 0?
Same question as above
Did you try to call FeedbackSessionAttributes.builder() here?
Did you try to call FeedbackSessionAttributes.builder(null, null, null) instead?
Please use CanDoActionAssertUtils
please use CanDoActionAssertUtils
Please use hamcrest matchers.
Shift to the platform's default charset, not the platform's default charset.
Shift to the platform's default charset, not the platform's default encoding.
Shift to the platform's default charset, not the test case for null.
I'm not sure about the method name though. Why not "buildAnalysisSegments" like in the state system analysis? Or "buildAnalysisSegments"?
I'm not sure about the method name though. Why not "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
I'm not sure about the method name though. Why not "buildAnalysisSegments" like in the state system analysis? Or "buildAnalysisSegments" for more clarity. After all, it is called only if needed.
Maybe this will already be immutable. And a list.
You don't need this. The Iterable is already implemented for a stream. And a list.
Maybe this will already be immutable. And a list. I'd suggest to change the underlying Iterable to immutable it.
Please use only one return statement
Please use only one variable result variable.
Please use only one variable result.
This should probably be a List, not a List.
This should probably be a List, not a List
This should probably be a List, not a list.
Unsupported exception
Return this
Return type here
I don't think this is needed, it should be this.
I don't think this is needed, it should be this test?
I don't think this is needed, it should be this method or this test?
Why this change?
Unnecessary, the get() method returns null.
Unnecessary, the get() method will replace.
caching an Exception?
Shall we move this logic to a service method?
Shall we move this logic to a service method? :)
@haozhun any thoughts on using k-distribution.k-distribution.k-distribution.k-distribution.k-distribution? If so, does it still return: getAbsoluteFile().toString().replaceAll("k-distribution.k-distribution", "k-distribution")); But given that we only have k-distribution.k-distribution trying to get the value of sout
@haozhun any thoughts on using k-distribution.k-distribution.k-distribution.k-distribution.k-distribution? If so, does it get overridden by test method which then can be directly tested?
@haozhun any thoughts on using k-distribution.k-distribution.k-distribution.k-distribution.k-distribution? If so, does it get overridden by test method which is expecting the value of k-distribution?
not sure how this is tested, but why don't you call these methods?
not sure how this works, e.g., if the Stage has been re-created but the pre-release checking is done here, then (!refreshViewView.isValid())
not sure how this works, e.g., if the Stage was already initialized in the stage, this is not called yet.
is there a reason why you use 11 here?
is there a reason why you use 11 as the default?
why is this necessary?
This syntax seems way more clunky
This syntax seems way less clunky
This syntax seems way more clunky?
Why add this?
Why not just return sb.isEmpty();
Why not just return true?
minor: would it be good to include a message for each of these exceptions?
minor: would it be good to include a SSL context for an outbound connection on the server side?
minor: would it be good to include a message for each of these methods?
Shouldn't we check if IgniteCheckedException is thrown here?
Shouldn't we check if #active(true) here?
Shouldn't we check if IgniteCheckedException is thrown here, too?
Can be simplified: return hasWindowOrJoins || (!spec.getOpCode()) ||...
Can be simplified: return hasWindowOrJoins && hasWindowOrJoins &&!hasWindowOrJoins;
Can be simplified: return hasWindowOrJoins && hasWindowOrJoins &&!hasWindowOrJoins();
What about adding the owner to the message?
What about adding the owner to the message and removing the owner parameter from the constructor?
What about adding the owner to the message and removing the null check?
contains() is redundant if the input is null.
contains() is redundant if you do an if statement.
contains()?
I don't like the naming of this "private" method because it goes from the bottom of the class, and the visibility of the class is package-private. This is useful for clients to be able to use it or not.
I don't like the naming of this "private" method because it goes from the bottom of the class, and the visibility of the class is package-private. This is useful for clients to be able to change the visibility of the class or method of the class. Please use braces for such a thing.
I don't like the naming of this "private" method, especially when it's not being used.
You can use assertNull here.
You can use assertNull
You could use an assertion here.
Is this cast needed? (CouchbaseLoadGeneratorDriver)getDriver() is package private
![CouchbaseLoadGeneratorDriver](<LINK_0>
Is this a cast? (CouchbaseLoadGeneratorDriver)
kStateChangeListener:: A new session established.
kStateChangeListener::A new session established?
Shall we throw an exception instead of just logging?
Same as above, please move this line under the SetViewport line and add an empty line after it.
Same as above, please move this line under the SetViewport line and add a line after it.
Same as above, please move this line under the SetViewport line and add a new line after it.
the session no longer exists... if not, please remove.
you can use session.setAttribute method.
the session no longer exists... please check if the session is null
This is not related to the changes in this PR, but I think that we need to track this issue.
This is not related to the changes in this PR, but I think that we need to track this thread as well.
This is not related to the changes in this PR, but I think that we should have a separate thread for each event received by the thread.
It should be client.listTables(new ListTablesOptions());
It's better to move this method to PagedIterable as it used in other places
It's better to move this method to PagedIterable as it is used in other places
nit: make this final
nit: make this final?
nit; make this final
Minor: "Remaining = " + remaining;" sounds like a better name.
Last name of variable is unused
Minor: "Remaining = " instead of "
log.debug("Parent task {} failed", fromChild);
log.debug("Parent task {} failed", fromChild, ex);
log.debug("Parent task {} failed", fromChild, throwable);
@paulodamaso the braces and return are not needed here
@paulodamaso the braces and return are not necessary here
@paulodamaso use braces and return are not needed here
Could you please move the "os.name" stuff to a constant?
Could you please remove the unused variable?
Could you add a check that System.getProperty("os.name", "Unix") and remove the system property.
This seems to be public? Why is it public?
This seems unused.
This seems to be unused.
Please squash this method into a single method, e.g. private String stripLeadingAndTrailingSlash(String string) { int startIndex = string.startsWith("/")? 1 : 0; int length = string.substring(0, startIndex, endIndex); return string.substring(startIndex, endIndex); }
I don't think this method is necessary. string.substring( startIndex, endIndex) will return null anyway if the variable is uppercase.
I don't think this method is necessary. string.substring( startIndex, endIndex) will return null anyway if it was set to zero.
Use the checkDataSizeLimit implementation you have in the other class.
Use the checkDataSizeLimit method instead
Maybe checkDataSizeLimit is already protected.
why not set it in the constructor?
why not set it in the constructor?
set the value in the constructor
I think this should be cleared after test. It can be removed.
I think this should be cleared after test. It doesn't have any effect because it can be changed later.
I think this should be cleared after test. It can be set by user.
static?
IllegalArgumentException is possible?
static? or static?
I'd make it clear that it's only test the logic for it
I'd make it clear that it's only test param without setting it
I'd make it clear that it's only test param without any argument
I'm not sure that we need to merge the whole updateActivationKey and the other methods.
I'm not sure we need to merge the whole updateActivationKey method.
I'm not sure that we need to merge the whole updateActivationKey method.
This isn't the right place to replace the "this" with this.
This isn't the right place to replace the "this" with "this.".
So, this isn't the right place to change this?
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a method can be declared private
same with this.
The test should cover both cases.
Do we really need to test both the null and the EventType type? I think the most common way to do this would be to use a different strategy.enrich(batch, eventType) here.
Do we really need to test both the null and the EventType type? I think the most common way to do this would be to use a custom implementation of EventType.
I'd rather call it evts.
Same here, and there is a Throttler  method to create a timer.
Same here, and there is a Throttler.
Why the change?
why the change?
Why the change? Is it necessary to make the assertEquals method more readable?
I think you need to provide protected otherwise this class is never called.
I think you need to provide protected otherwise this class is being used by other places.
I think you need to provide protected otherwise this class is being used by other static methods
This should be using curly braces.
This should probably be using curly braces.
This should probably be in a finally block.
Calling getOffscreenPageLimit() will do the trick nicely without the call to setOffscreenPageLimit.
Calling getOffscreenPageLimit() will do the trick nicely without the call to setOffscreenPageLimit. Here we are checking whether the list is zero or not.
tab
This INFO and INFO seem to be from the stack trace. If you don't want to keep it, let's keep them.
This log should be at the end of the method.
This log message is incorrect, please remove.
does this need to be public?
why not use Objects.equal()?
why not use Objects.equal?
It's better to convert attribute.getValue() to (String) attribute.equals(IPv4_PATTERN) &&!address.matches(IPv6_PATTERN) &&!address.matches(IPv6_PATTERN_SHORT)) to make it more readable.
It's better to convert attribute.getValue() to (String) attribute.matches(IPv4_PATTERN) &&!address.matches(IPv6_PATTERN) &&!address.matches(IPv6_PATTERN_SHORT)) to make it more readable.
It's better to convert attribute.getValue() to (String) attribute.equals(IPv4_PATTERN) &&!address.matches(IPv6_PATTERN) &&!address.matches(IPv6_PATTERN_SHORT))
Could you replace the sole use of HadoopDruidIndexerConfig.JSON_MAPPER.writeValue with try-with-resources for hadoopJobId file?
Could you replace the sole use of HadoopDruidIndexerConfig.JSON_MAPPER.writeValue(new File(hadoopJobIdFileName), StandardCharsets.UTF_8), hadoopJobIdFileName) {
Could you replace the sole use of HadoopDruidIndexerConfig.JSON_MAPPER.writeValue with try-with-resources for hadoopJobIdFile?
This will generate a call to inspect _every_ instance, when you're only asking for a subset. Remove this and directly call inspectIfView on the provided ids.
This will generate a call to inspect _every_ instance, when you're only asking for a subset. Remove this and directly call inspect inspect.
Use the more efficient contains method here?
I don't think we need this public.
I don't think we need this constructor.
I don't understand why we need this constructor.
We can cache the result of INITIALIATION_TIMEOUT_MS as well.
We can't use Thread.currentThread().interrupt() here.
We can cache the result of INITIALIATION_TIMEOUT_MS as before.
I missed this before, but I think you should at least log the error if the input was not present (ie the size is less than the number of bytes left).
I missed this before, but I think you should at least log the error if the input was not present (ie. if it was not present it should throw an exception indicating that the request was not supported on the page).
I missed this before, but I think you should at least log the error if the input was not present (ie. if it was not present it should throw an exception indicating that the issue was not present).
Have we decided to use super.onOptionsItemSelected(item) instead of this switch?
Have we decided to use super.onOptionsItemSelected(item) instead of this so that we always have to do nothing when we get to it?
Have we decided to use super.onOptionsItemSelected(item) instead of this so that we always have to do nothing when we get here?
You should find a better name for this depthFirstSearch, as that is what you want.
You should find a better name for this. Why the depthFirstSearch thing needs to be implemented?
You should find a better name for this. Why the depthFirstSearch thing needs to be depth?
Should this be package private?
Should this be synchronized?
Should this be package private or private?
Can you please remove this change? This looks like the one I have: ConfigSource configSource = Exec.newConfigSource(); configSource.set("guess_sample_buffer_bytes", GUESS_BUFFER_SIE);
Can you please remove this change? This looks like the one I have: ConfigSource configSource = Exec.newConfigSource(); configSource.set("guess_sample_buffer.bytes", GUESS_BUFFER_SIE);
Can you please remove this change? This looks like the one I have: private ConfigSource createGuessConfig() { return ConfigSource.newConfigSource(); }
can you please add it as an static method?
can you please add it as a separate method for debugging
can you please add it as a separate method for this
Wouldn't it be better to return List<Property>?
Wouldn't it be better to return an array of property names instead of converting to array?
Wouldn't it be better to return List<Property> instead of List<Property>?
I think it would be better to use Integer and not Integer here
I think it would be better to use Integer and Long here
I think int will be better
I am not sure that this would work in compatibility with older versions of getBdbStats. Perhaps we should keep the original order in mind to have only one place where we explicitly need to call this.
I am not sure that this would work in compatibility with older versions of getBdbStats. Perhaps we should keep the original order in mind to have only one place where we explicitly need to query data.
I am not sure that this would work in compatibility with older versions of getBdbStats. Perhaps we should keep the original order in mind to have only one place where we explicitly need it.
As an aside, you can pass a boolean here. Also in content values. They get converted correctly
As an aside, you can pass a boolean here. Also in content values. They get converted correctly and the original values are bad
As an aside, you can pass a boolean here. Also in an ContextClassLoaderFactory class
Does this need to be protected?
Does this need to be a new method?
Does this make sense?
delay is already completed.
check if delay is completed.
delay is being completed.
Would it be possible for an envelope to be null? It's just a null check.
Would it be possible for an envelope to be null?
Would it be possible to call put on the envelope? It appears that this method will be called after put
since we always use interid variables, please remove the "s".
since we always use interid variables, please remove "s".
since we always use interid variables, you could just inline them in the body
please use StandardCharsets.UTF_8 instead of Charsets.UTF_8
Please use StandardCharsets.UTF_8 instead of Charsets.UTF_8
Please use StandardCharsets.UTF_8 instead of Charsets.UTF_8.
I would rather throw an exception in the constructor, and silently fail to enforce the expected behavior. If we do throw an exception, then we should fail with an assertion error.
I would rather throw an exception in the constructor, and silently fail to enforce the expected behavior.
I would rather throw an exception in the constructor, and keep the caller as defensive and fail fast.
Does this ever need to be closed?
Why do you need to close the stream?
Why do you want to close the stream?
Would it be better to use simple constructor that takes a ReadTimeoutHandler and returns a handler of the given timeoutInSeconds also? That way you can reduce the number of times the method is called.
Would it be better to use an atomic boolean here?
Would it be better to use simple constructor that takes a ReadTimeoutHandler and returns a new ReadTimeoutHandler(this.timeoutInSeconds)
If the host doesn't exist, we should return something like "local" to distinguish between the two mount errors. The exception may be thrown by the checkPacks() method. If we do this, we should return FsckError.
If the host doesn't exist, we should return something like "local" to distinguish between the two mount errors. The exception may be thrown by the checkPacks() method, or the last one is FsckError.
If the host doesn't exist, we should return something like "local" to distinguish between the two mount errors. The exception may be thrown by the checkPacks() method.
Same suggestion about using Object StoreMap.equals(id)
Same suggestion about using Object StoreProperties.equals(id)
Realm Object Store can be null
also check that conditions is non-null
also check that checks are non-null
also check that conditions is not null
It looks like this exception is thrown by the test - the exception gets thrown in the previous stmt.
It looks like this exception is thrown by the test - the exception gets thrown in the previous stmt. Is this intentional?
try block.
this is still required
this is private and we don't want people to use it in any way.
this constructor is private and we don't want people to use it in any other way.
should be "eduPersonEntitlement"
Should be "eduPersonEntitlement"
should be "eduPersonEntitlements"
seems like this method should be extractedType to a toString() method.
seems like this method should be extractedType to a getProductType method, no?
seems like this method should be extractedType to a toString() method, the extractedType can be null
We could use the RegistrationApplicationListener constructor when this is calling scheduleAtFixedRate
We could use the RegistrationApplicationListener constructor when this is called
We could use the RegistrationApplicationListener constructor when this is calling scheduleAtFixedRate.
This should be returning an existing collection.
This is not returning null. It should be returning an empty collection.
This should be returning an existing collection. All clients can use it when invoking GarbageCollectionStatus.
Should the DataFileStream be logged here?
Should the signature of the method be void?
Should this be warn?
Since validate.size() > 0, you don't need a > 0 check.
Since validate.size() > 0, you don't need a 2 assertTrue() calls.
Since validate.size() > 0, you don't need a > 0 check here.
s/bookie-shell/
nit: can you remove the public modifier?
s/bookie-shell/name
You're missing the @Override annotation.
You're missing the @Override annotation here.
You're missing the context here.
I would call eraseEntityDescriptions() here, since the implementations of this method don't have to make things public.
I would call eraseEntityDescriptions() here, since the subclasses of the public API don't have to make things public.
I would call eraseEntityDescriptions() here
I think it is cleaner to do this in a private method like you did in SyncCreateCallback.
I think this method can be moved to create.
I think it is cleaner to do this in a private method SyncCreateCallback, and have the create method inside it.
make this package private, since it's only used in this class
make this package private, since it's only used in tests
make this package private
put the select statement inside the "+"
put the select statement in a new line
put the select statement in a separate line
instanceof is redundant?
instanceof?
instanceof is not safe
Is there a reason why we would need to be public? Do we really need to expose the public methods?
Is there a reason why we would need to be public?
Is there a reason why we wouldn't just return Duration.standardSeconds(seconds + minutes * SECONDS_PER_DAYS + 1); at the end?
Use [return null](<LINK_0> instead
Use 'null' instead of 'null'.
Use [return null](<LINK_0> instead.
filter(spatial join).filter(e -> isFunction(e))
s/filter(/)/
s/filter(s)/match
Is it still needed to add the token/token to the toString?
Is it still needed to add the token or token to the end?
Is it still needed to add the token or token to the log?
could you add the payloadType restriction (as before) and remove the first import?
could you do this check before adding the payloadType?
could you add the payloadType restriction, so it doesn't take it from the index
Why not java public static Builder builder() {... }
Why not java public static Builder builder() {?
Please don't expose common methods.
how about overriding equals and hashCode?
how about overriding toString()? <LINK_0>
how about overriding toString()?
log.trace
log.debug
trace
Why you not do the next() after loading all data?
Why you not do the next() after the previous line?
Why the cast?
this variable is unused - can be removed
this variable is unused, can be removed
this looks like a duplicate code from ModelFieldValidator
How about this.queryEngine = cache;
How about this.queryEngine = queryEngine;
How can this be private?
This is not necessary. Just setauthorizedClientManager.
Remove throws Exception.
Remove public.
Why not just check for request!= null?
Why not just check for request.isObserve()?
Why not just check isBuffered()?
Thread.currentThread().interrupt();
Thread.currentThread().interrupt()
Thread.currentThread().interrupt(); please.
nit: if you use Log.e(TAG, "message", "should be called before "); then it should be on one line.
nit: if you use Log.e(TAG, "message", "should be called before "); then you can use it like that.
nit: if you use Log.e(TAG, "message", "should be called before "); then you can use it like that.
Any reason to use a lambda rather than a simple for loop?
Any reason to use a lambda rather than a simple for loop? With Java 8's lambda? I can't find a reason to make this more readable
Just use logger?
probably better to return totalSize!= 0? (availableDiskSize / totalSize) : 0;
probably better to return totalSize!= 0? (availableDiskSize / totalSize) * 100 : 0;
probably better to return totalSize!= 0? (availableDiskSize / totalSize / totalSize) : 0;
this is probably not what we want. You could at least log why this is called for every event.
this is probably not what we want. You could at least log why this is called for every call.
I think we need to move this line to line 91, since this method is called in case of an error.
Should be: if ((View) getHost().getModel()) instanceof View) { return (View) ((View) getHost().getModel(); } else { return null; }
Should be: if (View.class instanceof View) { return (View) ((View) getHost().getModel(); } else { return null; }
Should be: if ((View) getHost().getModel() instanceof View) { return (View) ((View) getHost().getModel(); } else { return null; }
It doesn't have to be public
Why do we want to modify the current regex here?
Why do we want to modify the code that you extract?
log or remove this
log or remove
log or delete this
This method should probably be private
This should be private
This method should be private
This is making the change in behavior. Should this return 0 or -1?
This is making the change in behavior. Should this method return 0 or -1?
This is making the change in behavior. Should this return 0 or -1 to avoid the confusion?
I think we should rather return a RestView<TopLevelResource>.
I think we should rather return a RestView, rather than null.
I think we should rather return a Empty EmptyList.
Is this for 'key'? What if value is undefined?
Is this for 'key'? What's the purpose of this?
Is this for 'name'?
. updateCameraBearing(float bearing)
. updateCameraBearing(float bearing)?
. updateCameraBearing(true)?
There is a method called start() that you can use.
There's a method called getStartTime() that can be used instead.
There's a method called getStartTime() that can be used directly.
:disappointed:
getResultMessage(exchange) can be moved inside getResultMessage().
getResultMessage(exchange).... is not a required variable.
Don't make SpongeAPIMod public.
Put the mod id in a single local variable.
Don't make SpongeAPIMod a public.
Check if the string is null.
Please use Parsing html instead of string
Please use Parsing html instead of "<li>"
Is this really needed? If not, it should be a constant.
Is this really needed? If not, it should be better to make sure that getProperties() is not null.
Is this really needed? If not, it should be better to make a Properties instance instead of creating it everytime.
To be consistent with the rest of the code, please add a static import for Preconditions.checkNotNull(domain, "domain cannot be null");.
To be consistent with the rest of the code, please add a static import for Preconditions.checkNotNull(domain, "domain cannot be null");
To be consistent with the rest of the code, please remove the null check and just add a new line.
suggestion assertMessageEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion assertMessageEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE());
suggestion assertMessageEventExecutionSet(emptySub process.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
UnsupportedOperationException seems reasonable here.
throw new UnsupportedOperationException()
throw new UnsupportedOperationException()?
What if fn.apply(e) is null?
What do you think to have a name like fn? It will help in future refactorings.
What do you think to have a name like fn? It will help readability for future refactorings...
You probably want to use Collections.unmodifiableList here (and in other similar places).
You probably want to use Collections.unmodifiableList here (and in other similar places)
You probably want to use Collections.unmodifiableList here (I would probably make it compact for symmetry/flow).
I see it is not that hard to check if the serviceRef is null. I think it is in a different way to check if the object is null.
I see it is not that hard to check if the serviceRef is null. I think it is in a different way to check if it is null.
I see it is not that hard to check if the serviceRef is null. I think it is in this case, right?
nit: Assertion could be static final
static import
nit: Assertion could be final
Looks like it should be public, no?
Should be package protected and package protected.
Looks like it should be public, no longer public
Wrong method name. Also StringDimension is called automatically. Isn't it always empty instead of empty string? java if (distributionTarget == null) { builder.setDimension( "distributionTarget", distributionTarget); }
Wrong method name. Also if you want to use String, you should use String.valueOf(distributionTarget.getDataSource())
Wrong method name. Also StringDimension is called automatically. Isn't it always empty instead of empty string? java return String.valueOf(distributionTarget.getDataSource().toString())
As I said in the whole PR, I think this method should be private. The reason why it's needed is that we only call prepareSearchCodeSystem() in the prepareSearchCodeSystem method.
As I said in the whole PR, I think this method should be private. The reason why it's needed is that we only call prepareSearchCodeSystem() in prepareSearchCodeSystem()
As I said in the whole PR, I think this method should be private. The reason why it's needed is that we only call prepareSearchCodeSystem() in the prepareSearchCodeSystem() method.
Is this used anywhere?
Is this used anywhere else?
Is this needed?
Should we log here too?
Should we log here?
Why rethrow?
Please bring the braces back.
Please use braces for the if block.
Please use braces for all if statements.
Why does the assertion need to be changed here?
Why does the test not fail on equals?
Why does the assertion need to be changed?
Again, this condition is wrong:! counts.exceptions!= 0 && counts.exceptions == 0
Again, this condition is wrong:! counts.exceptions!= 0 && counts.exceptions == 0)
Again, this condition is wrong:! counts.exceptions == 0 && counts.exceptions == 0)
If you re-purpose the method, you should change that
If you re-purpose the method, you should change that to a our internal utility.
If you re-purpose the method, you should change that might as well
I would use isrt.getTypeNameForGetter() here
You should use assertEquals(expected, actual) here.
I would use assertEquals(Integer.MAX_VALUE, null, false) here.
The dispose methods should be done in the model provider.
The dispose methods should be done in a finally block.
The guard is not needed.
i think you need to introduce a new method in this class, i.e. getTransactionTimeone()
this method should be private
this method should be private, and remove this method.
String.compare(x, y)
String.contains(project) is a common use case as the synchronized block.
String.contains(project) is a Java 6 bit shorter
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "org.springframework.security.core.exceptions.ProtocolProtocol.close" [![rule](<LINK_0>](http://sonar-s4/coding_rules#rule_key=squid%3AS1192)
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "org.springframework.security.core.server.Url.exceptions.ProtocolAdapterFactory" [![rule](<LINK_0>](http://sonar-s4/coding_rules#rule_key=squid%3AS1192)
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "org.springframework.security.core.server.Url.exceptions.ProtocolProtocol.validate()" [![rule](<LINK_0>](http://sonar-s4/coding_rules#rule_key=squid%3AS1192)
using Integer.valueOf(fSelectedRevision.get_number())?
space after =
using Integer.valueOf()?
Nit: Context.current().getDeadline() is null.
Nit: Deadline is optional.
Nit: Deadline is used by requestTimeoutMs.
replace this with a field: @Inject private Instance<ConcurrentChildCommandsExecutionCallback> callbackProvider;... callBackProvider.get()
replace this with a field: @Inject private Instance<ConcurrentChildCommandsExecutionCallback> callbackProvider;
replace this with a provider: @Inject private RequestContextUtil;
remove
Format
Remove
@vilchik-elena why?
@vilchik-elena Why?
@vilchik-elena Maybe we could also change the name of the logPaths to WARNING?
You can use stripedExecSvc.executeDefault()
No need for final
You can use stripeIdx here
why is this else block?
why is this else required here?
why is this else required?
Not sure if it is a good idea to log the channel open as well. Dropping will only help debug issues.
Info is too verbose
no need to log it at all.
What is the value of this.notes for?
What is the note here, when the current version is more than one line?
What is the Gerrit? Perhaps it should be a Gerrit or something.
I think you can invoke doGcEntryLogs() here.
I think this is necessary. Since we are not scanning, we can do the data collect inside doGcEntryLogs().
I think this is necessary. We can't pass the ledger storage.
Should this throw a UnsupportedOperationException or something?
Should this return a non-null value?
Should this return null to avoid issues?
nit: if (mCachedDataReader.deRef() == 0) {
nit: if (mCachedDataReader.deRef() == 0) { BLOCK_READERS.remove(mBlockId); }
nit: this line is not atomic.
Assuming the if is redundant.
Assuming the if is redundant, you could just set it to true.
Assuming the invocationStarted is set to true, then you could also remove it.
nitpick: the if statement can be replaced with a for (MapGenStructure c : structures) { if (struct.getStructureName().equals(structureName)) { return c.getNearestStructurePos(worldIn, position, findUnexplored); } } return null;
nitpick: the if statement can be replaced with a for (MapGenStructure c : structures) { if (struct.getStructureName().equals(structureName)) { return c.getNearestStructurePos(worldIn, position, findUnexplored); } return null; }
nitpick: the if statement can be replaced with a stream
suggestion this.setRepositoryUrl(repositoryUrl);
Note: The configuredByUrl parameter can be used instead of the this..
Note: The configuredByUrl parameter can be used instead of the call to this.
How about checking that 0 == TimeoutException or just just checking for null?
How about checking prepare(final long ParameterWorkerTestUtil.close()?
How about checking that the queue is completed?
Why don't you want the entire string to be gc friendly?
Why don't you want the entire string to be included?
Why don't you want the content of the html to be text?
This is pretty odd, I think we try to have a start/stop on the job itself, yeah?
This looks more like a good filter code. At least should we try to have something more generic, generic about the startup process?
This is pretty odd
uriHost is already a Text. Is toString() on it?
uriHost is already a Text. Why not just call the String constructor for it?
uriHost is already a Text. Why not just call the String constructor?
or just create the single purpose geospatial threads in this class and makeOfferNewThread() to save a lot of time.
or just create the single purpose geospatial threads in this class and makeOfferNewThread() to save the lock.
or just create the single purpose geospatial threads in constructor?
Nit: I would move the ts into isUpgradeRequired() method and rename the method to isUpgradeRequired(). Same for all other places that do that.
Nit: I would move the ts into isUpgradeRequired so that we don't have to do that.
Nit: I would move the ts into isUpgradeRequired() method and rename the method to isUpgradeRequired(). Same for all other places that do it.
It's not clear to me what it means, but can we remove the entry in the list instead?
It's not clear to me what it means, but can we rename it to checkForResponse?
It's not clear to me what it means, but, can we rename it to checkForResponse?
The code here is the same as readMinShiftAndBinDepth where it's first used. I think you can just remove it.
The code here is the same as readMinShiftAndBinDepth where it is called. It's a different method that can be reused.
The code here is the same as readMinShiftAndBinDepth where it is called. It's a different method that it calls here.
why? how can you use a list to access the resource set if it is empty? it should work without this check.
why? how can you guarantee that the list is empty? if there is no resource set hook and we have the same name then why?
why? how can you use a list to access the resource set if it is empty?
suggestion return Objects.copyOf(RuleAttributeWidget.getAttributesList());
suggestion return Objects.requireNonNull(RuleAttributeWidget.getAttributesList());
suggestion return Collections.unmodifiableList(attributes);
#createAssociationRow(AssociationKey associationKey, object ) can be replaced with this.rows = new LinkedHashMap<>( wrapped.size() );
#createAssociationRow already does this this.rows = new LinkedHashMap<>( wrapped.size() );
#createAssociationRow already does this this.rows = new LinkedHashMap<>();
Please use braces {} for a single line
consider using? : here
Please use braces {} for a single line loop.
delegate to resolveParams()
move all parameters to a new method
move all methods to the base class
Consider using the test builder for this instead: java public static Collection<Object[]> data() { return Arrays.asList(new Object[]{ "production", Config.EncryptionLevel.NONE }, Config.EncryptionLevel.REQUIRED ); }
Consider using the test builder for this instead: java public static Collection<Object[]> data() { return Arrays.asList(new Object[][]("production")); }
Consider using the test builder for this instead: java public static Collection<Object[]> data() { return Arrays.asList(new Object[]{ "production", Config.EncryptionLevel.NONE ); }, Config.EncryptionLevel.REQUIRED ); }
There is no need to do synchronized here, because it is private.
There is no need to do synchronized here, given that it is an instance method.
There is no need to do synchronized here, because it is private. Or we should change it to private.
This is not really a public API. You should be careful not change the accessibility of the method.
This is not really a public API. You should be careful not change the methods in this class.
This is not really necessary. You're creating a new object and then throwing it away.
i don't think this is correct. If feature name is not a result of the loop, i.e. addtionalFeaturesSupported and addtionalFeaturesSupported
i don't think this is correct. If feature name is not a result of the loop, i.e. addtionalFeaturesByClusterId should return true.
i don't think this is correct. If feature name is not a result of the loop, i.e. addtionalFeaturesSupported and addtionalFeaturesSupported, then you can return it.
I would suggest doing the following: if (objectItr == null) { return null; } CsvSchema firstLineSchema = CsvSchema.emptySchema().withHeader();
I would suggest doing the following: CsvSchema firstLineSchema = new CountInputStream(csvSource); CsvSchema firstLineSchema = new CountInputStream(csvSource);
I would suggest doing the following: if (objectItr == null) { return null; } CsvSchema firstLineSchema = new CountInputStream(csvSource);
This toString() may be expensive. Please do it before if(satisfied == null) { if (log.isTraceEnabled()) { log.trace(toString() + " " + satisfied); } else { return false; } }
Does this need to be here? suggestion if (satisfied == null) {
Does this need to be public?
I know this is not part of this PR but shouldn't we set the first WaterMarks() call here?
I know this is not part of this PR but shouldn't we set the first WaterMarks() here?
I know this is not part of this PR but shouldn't we set the first WaterMarks() call here.
Please remove the @To annotations and put the annotation into. @Override public void configureServlets() { filter("login",OAuthWebFilter.class); }
Please remove the @To annotations and put them into the method.
Please remove the @To annotations.
Should make a method for this so that the caller doesn't have to re-parse the head if it's not the repo?
Should make a method for this so that the caller doesn't have to re-parse the head.
Should make a method for this so that the caller doesn't have to care about the caller?
Add the @Override annotation here.
Add the @Override annotations?
Add some message here.
In this case, we need to stop the thread pool to know it did happen. It took me a while to stop it.
In this case, we need to stop the thread pool to know it did happen. It took me a while to add it.
In this case, we need to perform shutdown of the thread pool to stop it.
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It should only be temporarily turned off to create (or delete) test content.
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It's not a good practice to leave authorization turned off across test methods.
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior.
As mentioned above: please use log.warnPartitionHandlingForReplicatedCaches()
As mentioned above: please use log.warnPartitionHandlingConfigurationWithoutReplicatedCaches()
As mentioned above: please use log.warnPartitionHandlingForReplicatedCaches() since this is a generic method.
The only issue I see is that the list of tickets contains a user. The purpose of this method is to test the return value of hasAnyTicket, only the one that is returned the list ofTickets. The only issue I see is that the return value of the method is ignored by the admin. Rewinding the method in my opinion is that you should return an Optional<Ticket> instead of a List.
The only issue I see is that the list of tickets contains a user. The purpose of this method is to test the return value of hasAnyTicket, only the one that is returned the list ofTickets. The only issue I see is that the return value of the method is ignored by the client. It is not a problem if the user only returns null value. Please let me know if my wrong question is.
The only issue I see is that the list of tickets contains a user. The purpose of this method is to test the return value of hasAnyTicket, only the one that is returned the list ofTickets. The only issue I see is that the return value of the method is ignored by the admin. Rewinding the method in my opinion is that you should return nothing, but not a collection.
Suggestion: Can we have a method here such as: runInternalAction( VdcActionType.ExtendImageSize, createExtendImageSizeParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()), createDefaultContexForTasks(getExecutionContext()), createDefaultContexForTasks(getExecutionContext()), createDefaultContexForTasks(getExecutionContext())
Suggestion: Can we have a method here such as: runInternalAction(VdcActionType.ExtendImageSize, createExtendImageSizeParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()), createDefaultContexForTasks(getExecutionContext()), createDefaultContexForTasks(getExecutionContext()), createDefaultContexForTasks(getExecutionContext())
Suggestion: Can move this to a separate method, and reuse it in both places?
Even though we're only going to make this clear and make it clear that we're not running for a second day. Oct -> 1000.
Even though we're only going to make this clear and make it clear that we're not running for a second day. Oct -> 10001 minute.
Even though we're only going to make this fail for now.
Maybe just call this "return newApps".
Maybe just call this "return newApps" and pass in null.
Maybe just call this "return newApps" or something like that?
Sync container, consumer of the hash code is not thread-safe.
Sync container, but the module object is still there.
Sync container, but the module object is still there
This should be made into a generic try-with-resources block.
This should be made into a generic try-with-resource block.
This should be made into the public method.
Are you sure that this is safe?
Are you sure that the caller is going to be using this lock?
Are you sure that the caller is going to be using the lock?
should be 'false'.
should be 'false'
can use compatibility versionUtils#getEffective instead
if you make this a private method, it should be appropriate to keep the return type as private
if you make this a private method, it should be appropriate to keep the Java 6 syntax well.
if you make this a private method, it should be appropriate to keep the return type as private.
please remove the synchronized
please remove these synchronized methods
please remove the synchronized modifier
Here you are comparing name to DEFAULT_NAME_TOKEN.
Why we need this check? We have that many handle methods, no?
Why we need this check? We are not using it right?
I am sorry, I don't understand why we need to use store to return a map instead of a String, but here we can return the same Map<String, String>.
I am sorry, I don't think we need to support this. If you can declare a Map here, it's pretty straightforward to do it.
I am sorry, I don't understand why we need to use store to return a map instead of a String, but here we can return the same Map<String, String>
Why not using warnFormat()?
why snpa?
Why not using warnFormat?
LOG.error("JAXB resolution");
log the stack trace to the error.
LOG.error("JAXB resolution", ex);
Can we use assertEquals(0, service.countTotalNumberOfVariants());
Can we use assertEquals(0, service.countTotalNumberOfVariants())
assertNull
if you want to be able to specify a messageFormat as null, you should probably switch the equals() method to avoid possible NPE
if you want to be able to specify a messageFormat as null, you should probably switch the equals() method to avoid possible NPE here.
if you want to be able to specify a messageFormat as null, you should probably switch the isEmpty method to equals()
what is the reason for this to be null?
what is the reason for this to be null? I think we should do a null check before doing this.
what is the reason for this to call this constructor? I think we should simply invoke the super() method to enforce this.
what about case clearK = true and clearK = false
what about case clear and clearK = true and case clearK = false
what about case clear and clearK = true and cases where the test fails?
That's not the contract of this method.
So there is no reason to call this, because this will return null.
So there is no reason to call this, because this has always return null.
move this to GeometryType.GEOMETRY.writeSlice
move this to GeometryType enum private static final BlockBuilder out;
move this to GeometryType enum
return childMethods.isEmpty() || (childMethods.size() == 1) && isSingleAbstractMethodOverride(childMethods.get(0), parentType));
return childMethods.isEmpty() || (childMethods.size() == 1 && isSingleAbstractMethodOverride(childMethods.get(0), parentType));
return childMethods.isEmpty() || (childMethods.size() == 1) || isSingleAbstractMethodOverride(childMethods.get(0), parentType));
I would expect the following code to be more readable: java return database.getFileDirectoriesAsPaths(fileDirPrefs);
I would expect the following code to be more readable: java return database.getFileDirectoriesAsPaths(fileDirPrefs());
I would add a check that the new method is empty
Probably instanceof?
Probably want to return null, not a message, since HTTPCommandResult is not a string
Probably want to return null, not isAssignableFrom?
Consider using DtoConverter.DtoFactoryDto.class.getSimpleName()
Please use DtoConverter from commons-lang
Consider using DtoConverter.convert
It would be nice to de-duplicate this logic.
You could de-duplicate this logic.
You should not explicitly raise this.
You can just use s.equals(s) here
You can just use s.equals(s)
You can use Boolean.parseBoolean(s) here
Use Objects.firstNonNull for this, as you have above.
Use Boolean.format instead.
Use Objects.firstNonNull for consistency.
I'd suggest to change the wording in this method, for example: // protocol is already associated with a single protocol, // somewhat consistent with the code final String protocol = ""; if (PushPublisher.PROTOCOL_AWS_S3.equalsIgnoreCase(protocol)) { return new PushPublishingEndPoint(); } else if (PushPublisher.PROTOCOL_AWS_S3.equalsIgnoreCase(protocol)) { return new StaticPublishingEndPoint(); } return null;
I'd suggest to change the wording in this method, for example: // protocol is already associated with a single protocol, // somewhat consistent with the code // protocol is already associated with PushPublisher.PROTOCOL_AWS_S3.equalsIgnoreCase(protocol) || PushPublisher.PROTOCOL_AWS_S3.equalsIgnoreCase(protocol)) { return new StaticPublishingEndPoint(); }
I'd suggest to change the wording in this method, for example: // protocol is already associated with a single protocol, // somewhat consistent with the code final String protocol = ""; if (PushPublisher.PROTOCOL_AWS_S3.equalsIgnoreCase(protocol)) { return new PushPublishingEndPoint(); } else if (PushPublisher.PROTOCOL_AWS_S3.equalsIgnoreCase(protocol)) { return new StaticPublishingEndPoint(); } return null; }
Looks like you are skipping getOwnerId() here.
I think this method should be public.
Looks like you are skipping getOwnerId().
Assertion seems to be missing?
extract this to a separate method downloadAllServerChanges
can we throw AssertionException?
This should also be ContainerConfiguration.get() and not createInitParameters()
This should also be a VaadinConfiguration class.
This should also be an instance of a VaadinConfiguration.
info?
This string should be info
info
please use StringUtil.isEmpty(value) instead.
please use String.format("Project name cannot be blank" )
please use StringUtil.isEmpty(value) instead of a regular expression.
Can we move this wait outside the waitFor-block?
Can we move this wait up to the waitFor method?
Can we move this 250 to the constant?
Nit: I'd suggest to make this private.
Nit: I'd suggest to make a private method on the class, and put this method on that class.
Nit: I'd suggest to make it private.
:question: Could you add some information to this log message? Maybe it's better to include the paramaterize it.
:question: Could you add some information to this log message? <LINK_0>
:ant: action=GET
if (really!= null && remoteRate.isValidEstimate() &&!remoteRate.isValidEstimate()) { return false; }
if (really!= null && remoteRate.isValidEstimate() &&!remoteRate.isValidEstimate()...) { return false; }
if (really!= null && remoteRate.isValidEstimate() &&!remoteRate.isValidEstimate()) { return false; } and remove the boolean parameter.
Can't we use a lambda here?
Can't we use a simple lambda here?
Can't we use a constant - it's more familiar to see where the operator is used
Please, inline these methods
Please call into this method.
Please, inline methods
You need to add synchronized here
You need to add synchronized here, otherwise this method will be calling this method.
You need to add this method after queryStopped and queryRefresh.
- this should be the entity of the EmulatedMachine - no need to check it here. - this should be the selected one, not the value of the EmulatedMachines :)
- this should be the entity of the EmulatedMachine - no need to check it here. - this should be the entity of the selected OS.
- this should be the entity of the EmulatedMachine - no need to check it here. - this should be the entity of the selected OS. - I want to test it actually.
@xupyprmv I think it's a good idea to use some constants here
@xupyprmv I think it's better to use some kind of UTs here
Should be public
I'm assuming this constructor is combining the two maps? If so, didn't we just get the jobCoordinatorkBasePath from config? Do we need to add it back again?
I'm assuming this is combining the two maps? If so, didn't we just get the jobCoordinatorkBasePath from config? Do we need to add it back again?
I'm assuming this constructor is combining the two maps? If so, didn't we just get the jobCoordinatorkBasePath from config? Do we need to add it again?
return false?
"Thread access" would be a better choice.
This should be return false right?
<LINK_0>
java return moduleexportsinstrumentcode.instrumentCodeInstance.instrumentCode(\"" + encodedParam + ", ");
TIL. I'm not sure if this was the pattern we're using.
It would be better to parse it in an Optional<String> rather than using null to represent "null".
It would be better to parse it in an Optional<String> rather than using null here
It would be better to parse it in an Optional<String> rather than using null to indicate invalid config value.
To improve readability, should be "if (exemptedPaths.contains(request)) {".
To improve readability, may you please change "exemptedPaths" to "request"?
To improve readability, should be: HttpServletRequest request = invocation.getServletRequest(); return request.invoke();
Should we have a version of createCheckURIEncoding that takes a String argument and use that in the rest of the code?
Should we also have a version of createCheckURIEncoding that takes a String argument and use that in the other places?
Should we also check that the value arrived?
This should not be static.
This should not be public.
This should not be public. Please remove.
Don't you think it's better to show the command line in the caller? At Status.canExecute(String commandLine)
Don't you think it's better to return the command line directly here?
Don't you think it should be final?
Do not use i in the middle of for loop. Also, is this thread safe?
Do not use i in the middle of the for loop.
Do not compare strings directly.
Cool that seems like a good solution
It's best practice to treat these as a map instead of passing the usernameAndPasswordToAuthWith object
Cool that seems like a good solution :+1:
I suggest to replace these 3 lines with:.thenReturn(mock(IMethods.simpleMethod("string")); iMethods.simpleMethod("string");
I suggest to replace these 3 lines with:.thenReturn(mock(IMethods.simpleMethod("string")); iMethods.simpleMethod("string");");
I suggest to replace all this mock call with IMethods.simpleMethod("string") since it is just the same thing.
Feel free to ignore: Do we really want these this there?
Feel free to ignore: Do we really want these this there? If not, I'd go with the old cluster version.
Feel free to ignore: Do we really want these this there? If we really want them to be non-final, maybe we should just set the old cluster version to the template?
Check if it is done.
Check if it is working.
Check null once at the begin/stop and return early.
Why is there a public constructor?
Why is this constructor public?
Why is it public?
The line above has no effect on the same line.
The line above this could be more readable.
The line above this could be moved to the else statement.
We could re-throw the exception instead of catching it here.
We can re-throw the exception instead of catching it here.
We could re-throw the exception instead of catching it here?
getMessage() and debug trace?
i'd add "perform live snapshot"
i'd add "perform live snapshot..."
Use an [Optional](<LINK_0>
Use an [Optional](<LINK_0> instead?
[minor] Why null?
Can you remove the second {} here?
Can remove the second {} here?
Can you remove the second {}?
Is... depends from on these?
Is... depends from on why...
... and here...
I'd push that condition to an assertion on the last line: LOGGER.warn( "artifact {} already attached, remove previous instance and add again" );
As discussed, we should log an error and continue.
I'd push that condition to an assertion on the last line: LOGGER.warn( "artifact {} already attached to..."
Not sure it's worth changing the style of this file.
Not sure it's worth changing this. If the path is not a Path, it's possible to change the implementation to Path.fromPath(String).
Not sure it's worth changing this. If the path is not a Path, then this method can return Path.fromPath().
This is a good idea.
This makes no sense.
This is a strange exception.
Same as above:.getAllOfType(VDSType.forValue(-1)
Same as above: / @Test public void testGetAllOfTypeWithUnrepresentedType() { List<VDS> result = getAllOfType(VDSType.forValue(-1)); assertIncorrectGetResult(result); }
Same as above:.getAllOfType(VDSType.forValue(-1))
No need for this
is this a bug?
No need for the new method
You can't use shift here, but instead use ((c & 0x7f) << shift).
You can't use shift here, but instead use ((c & 0x7f) << shift). (Same for the above instruction.)
You can't use shift here, but instead use ((c & 0x7f) << shift). (Same for the other method.)
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when it happens.
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when we do that.
getSelectedDocOperationOwner() is a Composite, you can add a check for it too.
the selected doc is not a good name.
getSelectedDocOperationOwner() is a Composite, you can add a check to selected item.
I think the return type is enough to be dealing with such operations. Please change PersistedDataSetID#getPersistedIntermediateDataSetIds.
What's the purpose of making it protected? Does it make sense to return a new object?
I think the return type is enough to be dealing with such operations. Please change PersistedDataSetID.
this seems like it should be a partition column?
this looks like it should be a partition rather than a column position.
this looks like it should be a partition rather than a write to disk.
Don't need this check as this method is only called from the StepRegistry
Don't need this check as this method is only called by the StepRegistry
Don't need to check for null here as well.
I would move this (so it is not re-assigned) to the public methods of the class.
I'd move this just after the public methods: public PasswordBasedEncryptionUtil(Cipher cipher, AlgorithmParameters algorithmParameters,Alphabet alphabet)
I would move this (so it is not re-assigned) to the public methods of the class
Utils.deleteIfExists(tempFile.toPath())
Utils.deleteIfExists(..)?
try-with-resource?
This should be made into a static variable.
This should be made final
This should be made into a static method.
This is the same as workerLogs.getAllWorkerDirs().stream().filter(DirectoryCleaner::deleteOldestOnlyLarge).forEach((k, v) -> {
This is the same as workerLogs.getAllWorkerDirs().stream().filter(DirectoryCleaner::deleteOldestOnlyLarge).forEach((k, size) -> {
This is the same as the one above, so why not just pass workerLogs instead?
was this used in the scope of the patch?
was this added in the previous review?
was this used in the scope of the ticket?
why is this check required? The port can never be negative (if set to < 0 it should always be >=).
why is this check required? The port can never be negative (if set to < 0 should always be >= 0)
why is this check required? The port can never be negative (if set to < 0 should always be >=).
Set to null.
Set to null. Same with render()
Set this to null.
valueOf(illegalChar) is enough to check for null.
valueOf(IllegalChar)
valueOf(BeeChar)
this needs to be called before startAndAttachTimingContext
this needs to be done before startAndAttachTimingContext
this needs to be done for this?
java checkNotNull(name, "name");
java this.encoding = encoding;
java constructor can be used instead of this()
Why not ImmutableList.of(values)?
Why no builder?
Maybe use an ImmutableList here?
@carl-mastrangelo I think this method should be as follows: java if (inputStream instanceof BlockCompressedInputStream) { return new AsciiLineReaderIterator(new AsciiLineReader(inputStream)); } else if (inputStream instanceof PositionalBufferedStream) { return new AsciiLineReaderIterator(...); } return new AsciiLineReaderIterator(new AsciiLineReader(inputStream));
@carl-mastrangelo I think this method should be as follows: java if (inputStream instanceof BlockCompressedInputStream) { return new AsciiLineReaderIterator(new AsciiLineReader(inputStream)); } else if (inputStream instanceof PositionalBufferedStream) { return new AsciiLineReaderIterator(new AsciiLineReader(inputStream)); } return new AsciiLineReaderIterator(...inputStream);
any reason for not just casting inputStream?
If there is an element in the pools queue, it should be stopped as well, to avoid the parallelStream(). filter(comp ->!comp.stop(timeout)).count()
If there is an element in the pools queue, it should be stopped. This is why you do not want to interrupt the thread. In other words, this method should be called only if needed.
If there is an element in the pools queue, it should be stopped. This is why you do not want to interrupt the thread. In other words, this method should be called only if there was no pool.
I wonder why this is necessary. What would happen if the state is not PING mode?
I wonder why this is necessary. What is the state of the first component that is checked for State.PING?
I wonder why this is necessary. What would happen if the state is 'not found'?
scheduleTime => scheduleTime?
scheduleTime -> scheduleTime?
scheduleTime --> scheduleTime
This can be static?
This should also be public?
This should also be public, shouldn't it?
Wouldn't Collections.emptyList() be more appropriate here?
Wouldn't it be simpler to return an empty list instead of null?
Wouldn't it be simpler to return an empty list instead?
isHidden()
IMHO we should track newServerEvent as well.
isHidden()?
Please name the variable 2.
Please name the variable, it 3:1: -> /
Please name the variable.
Double-checked locking, but this could cause problems when a new location is created. Add a check to make sure the "reset" is not called.
Double-checked locking, but this could cause problems when a new gamzing is added to the object under synchronization. Check not the other thread that does this.
Double-checked locking, but this could cause problems when a new location is created. Add a check to make sure the "reset" is correct.
nit: it is a matter of personal preference, but I think it would be more readable to use static imports for matchers.
nit: consider using ValidationUtils.notNull(value, "testValue");
nit: consider using ValidationUtils.assertNull instead.
Should we use the long here?
Should we use the long here? Can we change this in the individual methods?
Should we use the cached model here?
Why do we need to return 10?
Why do we need to return 10 here?
Why do we need to make this method static?
Should we move this lock to the end of the method?
Should we move this lock to the leaseId, and just in case it is successfully cleared?
Should this be synchronized?
port them as well
Why do we have this thing static?
Why do we have this?
Typo.
Spelling.
Exception is redundant.
I would not have a hard time understanding what is happening here. A simple 'get' would be better here.
I would not have a hard time understanding what is happening here. A simple 'get' would be better imho.
I would not have a hard time understanding why we would want to move this to a separate class.
I'm not sure this is right. It's only ever used for Haxe if you've got a VarInit variable. I can't remember.
I'm not sure this is right. It's only ever used for Haxe if you've got a VarInit. I'm not sure if it makes sense.
I'm not sure what this is for, but I think it's better to make it a variable.
Should this be set to true?
Should this be setCommand()?
Should this be set to true as well?
Since the CompositeDisposable is not really used anywhere else, I'd be tempted to just call the method directly.
Since the CompositeDisposable is not really used anywhere else it would be better to use the SingleDisposable from the super class.
Since the CompositeDisposable is not really used anywhere else, I'd be tempted to just call the method directly and have it be removed.
Can you cover me a bit?
Can you cover this method with the one above?
Can you cover me a bit more?
Looking at the code, it seems like we can simplify this method to: java catch (TDClientHttpException e) { // TODO: } catch (TDClientHttpException e) { // TODO: }
Looking at the code, it seems like we can simplify this method to: java public boolean existsTable(String databaseName, String tableName) throws TDClientHttpException { return listTables(databaseName)!= null; }
Looking at the code, it seems like we can simplify this method to: java public boolean existsTable(String databaseName, String tableName) throws TDClientHttpException { return listTables(databaseName) || listTables(schema.getName()) == 404; }
Is it possible to make the BinomialDistribution a new BinomialDistribution(nWithArtifact, f)?
Is it possible to make the BinomialDistribution a new BinomialDistribution(xWithArtifact, f)?
Is it possible to make the variables final?
Unnecessary; the constructor would be called directly on line 69
Even though it's unlikely, I think it would be better to have a secondary location.
Unnecessary; the constructor would be called only once.
This is not supported anymore.
This is not supported in the API.
This is not supported anymore, right?
extract to a method for better readability
extract to public method
extract to a separate method
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify (assert) it, then fetch it, verify the new status.
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such updates
The status of the pre-defined hook should be ENABLED.
If the drawable is turned off, the Id should be immutable. If this is the case, the this class should be immutable.
If the drawable is turned off, the Id should be immutable. If this is the case, we should cut this out.
If the drawable is turned off, the Id should be specified. If this is the case, the Id should be specified.
Do you really need to cast m to a RemoteFileArtifactValue?
Do you know if m.isRemote is true but the cast is unneeded?
Do you know if m.isRemote is true but the cast is unneeded.
I like the approach; but I'd recommend to have a utility method for most of the kinds of operations (or the similar ones) to use the / catch, and check the resulting future.
I like the approach; but I'd recommend to have a utility method for most of the kinds of operations (or the ones, and the assert to check the resulting data, or the java doc string).
I like the approach; but I'd recommend to have a utility method for most of the kinds of operations (or the ones, and the assert to check the resulting data, or the java doc states).
Cosmetic: Could you please, follow the project's coding convention and keep it?
Cosmetic: Could you please, follow the project's coding convention?
Can be just package private
Please add spaces before and after the < <>. < layout
Please add spaces before and after the < operator. < layout
Please add spaces before and after the < <>. <<>
Instead of declaring the field directly, could you create a private static final field for this?
Instead of declaring the field directly, could you create a static final field for this?
Instead of declaring a new field for this, could you create the ContentProviderClient that is created inside the constructor?
Why does this need to be changed?
Why doesn't this have an explicit size?
Why do we need this change?
shouldThrottle() is not overridable.
make this method private.
Throttle to be overridable.
Should log the thread context
Should log the exception instead of just the exception
Should log the threadContextFactory
Minor: we can use Objects.equals(alias, alias) instead of the containsKey check.
Minor: we can use Objects.equals()
Minor: we can use Objects.equals() for this.
Exception is never thrown
Duplicate code
Duplicate code also here
typo: "per node"
typo: DroolsJoinConstraintStream?
typo: "DIV"
return (splitTime < fTime + fDuration? new TimeEvent(fEntry, Math.max(0, splitTime - fTime)) : null);
return (splitTime < fTime + fDuration? new TimeEvent(fEntry, Math.max(fTime), fDuration - Math.max(0, splitTime - fTime)) : null);
return (splitTime < fTime + fDuration? new TimeEvent(fEntry, Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fTime));
nit: I'd call enabledForMultipleContexts() here just after enabledForMultipleContexts()
nit: I'd call enabledForMultipleContexts() here and below. This is just my preference, but it seems cleaner.
nit: I'd call enabledForMultipleContexts() here and below.
nit: I would prefer to have the consumerGroupName as a parameter, and instead add it to the constructor.
nit: I would prefer to have the consumerGroupName as a field, and use it here
nit: I would prefer to have the consumerGroupName as a parameter, but add it only to the constructor.
this is redundant, the method can be removed
this is redundant, the method will already return null
this is redundant.
Seems like you're setting the initial capacity to zero here.
out of curiosity, why is this set to zero?
Seems like you should use a Builder.
oldValue should never be null; otherwise the merge function wouldn't be called.
oldValue should never be null; otherwise the merge function wouldn't throw an NPE.
oldValue should never be null; otherwise the merge function wouldn't work.
This mapping needs to be done in a separate PR, so that it is not required in this PR.
This mapping needs to be done in a separate PR, so that it is not duplicated.
This mapping needs to be done in a separate PR, so that it is not required to be merged.
what if valueOf is null?
Should be V5 and V3?
Should be V5 and V3
nit: you can simply return this (1 << SNAPSHOT_ID_BIT_WIDTH);
nit: you can simply return this (1 << SNAPSHOT_ID_BIT_WIDTH)
nit: I think this should be a separate constant.
Can you make this method final?
Can you make this method private?
use curly braces
Contract also says that "Cannot close"
Contract also says that "return" is not null.
Needs docs given how this functions work
I don't think we want to log every single session because we have many entries in the database. Perhaps it would be worth to change it to debug as well?
I don't think we want to log every single session because we have many entries in the database, One would be toString()
I don't think we need the toString() method. Perhaps it is unnecessary?
Why not use new names?
Try string.format() instead?
Try string.format?
Is the method used in this class that could be removed?
Is the method being used in this class that could be removed?
Should be private.
redundant assertion
duplicated condition.
should be checkArgument
Why always true for the first time?
Why always true for the current implementation?
Why always true for the default behavior?
Personally I'd rather this method using getChildren and getChildren?
Personally I'd rather static import Stream
Personally I'd rather this method using getChildren and getChildren
It's better to have a test with a message, i.e. "expected true"
It's better to have a test with a message, i.e. "expected true".
It's better to have a test with a message, i.e. "expected true but was false"
"select a from staff a where a.admin = true"
"select a from staff a where a.admin = true".
"select a from staff a where a.admin = true". Might be clearer to use
Check if this returns a FileInputStream here.
Check if this returns a FileInputStream.
Is this possible?
suggestion graph.removeNode(node);
Should the graph be removed as well?
Should this be done by a refresh or clear?
s/vfToPfMap/responseMap
As per above, please remove the "final" keyword.
s/vfToPfMap/g
I think it would be better to use StringUtils.EMPTY or StringPool
I don't think this can be null, but the constructor should be private
I don't think this can be null, but the constructor should call this(...)
You might want to return defaultValue!= null? defaultValue.trim() : defaultValue;
You may want to return defaultValue!= null? defaultValue.trim() : defaultValue;
You might want to add a null check here too
I think we should have a better abstraction here for the getPropertyStrings(Resource) an operation.
I think we should have a better abstraction here for the getPropertyStrings implementation. We could consider this improvement for the next iteration.
I think we should have a better abstraction here for the getPropertyStrings(Resource resource) an operation.
nit: you don't need to pass the backend's validation. The validation should be enough.
nit: you don't need the arguments
nit: you don't need the arguments.
Could we simplify the code like this? DetailAST node = lambdaBody.getLineNo(); node = node.getLineNo(); do { node = node.getLineNo(); } while (node!= null) { node = node.getLastChild(); } return node;
Could we simplify the code like this? DetailAST node = lambdaBody.getLineNo(); node = node.getLineNo(); do { node = node.getLineNo(); } while (node == null) { node = node.getLastChild(); } return node;
Could we simplify the code like this? DetailAST node = lambdaBody.getLineNo(); node = node.getLineNo(); while (node!= null) { node = node.getLineNo(); }
I think that we should send request on a server with a Permission. In this case we are not passing the qualifiedTopicName to the server. And by Permission.
I think that we should send request on a server with a Permission. In this case we are not interested in the operation.
I think that we should send request on a server with a Permission.
Not sure that this is needed. redirecting to {1} is only the output of the method. Maybe call it e.g. java LOGGER.log(Level.FINE, "coming from {0} and path to {1}", () -> new Object[] { "" }));
Not sure that this is needed. redirecting to {1} is only the output of the method. Maybe call it e.g.: LOGGER.log(Level.FINE, "coming from {0} and and {1}", () -> new Object[] {from {1}, () });
Not sure that this is needed. redirecting to {1} is the end result of the test.
I think it would be better to obtain the number of attempts with the same size as previous timestamp, just to ensure that number of attempts have been > 0.
I think it would be better to obtain the number of messages in a command line.
I think it would be better to obtain the number of attempts with the same size as the previous line.
[minor] Static import
Compilation error: not true
Compilation error: not true.
This is not assertions correctly right?
This is not assertions correctly?
This is not assertions, you could use AssertJ assertions.
Shall we add a more descriptive error message here?
this should be a WARN or INFO.
Shall we add a more descriptive error message.
This adds the caps a second time.
This adds a caps a second time.
This adds the caps a few times.
public?
public? Might be nice to have them as static.
public? Might be better to have them as static.
Can you please add final here?
Can you please add final keyword.
Can you please add final
fQuark = quark;
fQuark is never used.
fQuark = quark
I'm not sure if we want to change this. The idea is that if a plugin is using the old api and this class is not installed, this will break. For example, if an application uses the old api (which is still using the new api), then this will create a new instance every time the getInstance is called. We could do the check once in a constructor and cache it in this class.
I'm not sure if we want to change this. The idea is that if a plugin is using the old api and this class is not installed, this will break. For example, if an application uses the old api (which is still using the new api), then this will create a new instance every time the getInstance is called. We could do the check once in a constructor and cache it in a new instance.
I'm not sure if we want to change this. The idea is that if a plugin is using the old api and this class is not installed, this will break. For example, if an application uses the old api (which is still using the new api), then this will create a new instance every time the getInstance is called. We could simply create a new instance every time the client is instantiated.
This is redundant, initialize results to an empty map.
This is incorrect. If an argument is null, do we want to initialize to null?
This is incorrect. If an argument is null, set to null.
This should be public.
This should be JavaClass.
This should be JavaClass.class.
log.info message is too general. When you have multiple bundles this statement may confuse you when trying to troubleshoot OSGi related issues. Instead, your message should ideally be "All required capabilities for web component component is available."
log.info message is too general. When you have multiple bundles this statement may confuse you when trying to troubleshoot OSGi related issues. Instead, your message should ideally be "All required capabilities for web component component is available"
Is it necessary to make this an info log?
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
Adding something like the following should make the arrow call to setOnPageChangeListener a few lines above as it will be re-set here as well.
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well. Should be removed here as well.
Check the length : String[] credentials = credentialsString.split(":", credentials); if (credentialsString.length > 2) throw new BadCredentialsException("Authorization required");
We should only trim the characters at the end of the string.
We should only be accessing the first element of the string.
Do you think it would make sense to create a new method like remove(int id) that returns the count?
There is no need to do this here.
There is no need to do this.
This could be null since the container doesn't support this.
This could be made into one line
This could be null since the container doesn't support this, but the container (event) could be null
This method could be called for a form of input data, i.e. String getContinue(CruiseConfig) { return...; }
This method could be called for a form of getContinue
This method canContinue is a void, so please remove it.
I think it should return Array here.
I think that it should return Array here.
I think should return Array here.
this method should be private
check that the string is valid
check that the string is empty
I think you can use private JCacheCacheManager(final CacheManager mock, final CacheManager cacheManager) { this.afterPropertiesSet(); }
I think you can use "assertTrue(mock.getCacheManager())" instead
I think you can use private JCacheCacheManager afterPropertiesSet() for this.
Make "kie-deployment-descriptor.xml" a constant.
a constant for "kie-deployment-descriptor.xml" could be used here.
a constant?
If these methods are final, this method should be package private
If these methods are final, this method should be package scoped
If these methods are final, this method should be package scoped.
This test should verify something like an error message.
This test doesn't fail if called more than once. Please move it to the beginning of the test method.
This test doesn't fail if called more than once. Please move it to the beginning of the test.
Why public? Can it be removed?
Why? Can't we use setCanDoActionMessageParameters()?
Why? Can't we use setTestBases?
Please, make "setVlanId" a constant, and use it in the vdsId variable.
Please, make "setVlanId" a constant, and use it in the vdsId
Please log the passed in parameters, and remove it from the modified classes.
This should be synchronized
This should be synchronized with the concurrent hash map.
This should be final.
Just curious: why we want to rerun container here?
Just curious: why we need to rerun container here?
Is this safe?
Thoughts on using a default String value, may be better to use TextUtils.EMPTY_Text instead.
Thoughts on using a default String value, may be better to use TextUtils.isEmpty() here.
Thoughts on using a default String?
Please add identifying about the exception to assist with operational debugging.
Please add the exception to the log message to assist with operational debugging.
Why do you catch and log the exception to error? No need to catch anything.
"stageTaskRecoveryCallback should only be registered once (<LINK_0>
"stageTaskRecoveryCallback should only be registered once (of not registered once)"
checkState checkState
Shall we move this to a doPrivileged method -> createUsersAndGroups(um)?
Shall we move this to a private method -> createUsersAndGroups(um)?
Shall we move this to a private method in the DataResource class?
Consider adding a "%" and the "%" parameter to the ruleText field, for example: public static String removeQualifierFromRuleText(String ruleText) { if ( ruleText.startsWith( "%" ) && ruleText.endsWith( "%" ) && ruleText.substring( 1, ruleText.length() - 1) ) { return ruleText.substring( 0 ); } }
Consider adding a "%" and the "%" parameter to the ruleText field, for example: public static String removeQualifierFromRuleText(String ruleText) { if ( ruleText.startsWith( "%" ) && ruleText.endsWith( "%" ) && ruleText.substring( 1 ) ) { return ruleText.substring( 0 ); } } return ruleText.substring( 0 ); }
Consider adding a "%" and spec spec to the ruleText object
Change this constructor to call this()
Change this constructor to ChainFilter
Change this constructor to append in ChainFilter
Instead of loading the entire FeatureFinderMetabo files, if the list of features is empty, return a new File(mzMLFile.getName() + "featureXMLXML")
Instead of loading the entire FeatureFinderMetabo files, if the list of features is empty, return a new File(mzMLFile.getName() + "featureXML")
Instead of loading the entire FeatureFinderMetabo files, if the list of features is empty, return a new File(mzMLFile.getName() + "featureXMLXML") That will be called by the createVariableColumn() method above.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Are you sure you need to convert this to the following? :) return maybeGameProfile.getName();
Are you sure you need this?
Should be "Security service is closed."
Should be "Security service is closed.", though not related to this patch.
minor: you can use 'while' instead of 'if'
You can use FiltersHelper.Constants.HEADER_AUTHORIATION here.
You cannot use FiltersHelper.Constants.HEADER_AUTHORIATION here.
Use FiltersHelper.Constants.HEADER_AUTHORIATION here.
Since you are adding Gender.valueOf(...) twice, there's no need for string literal here.
Since you are adding Gender.valueOf(...) twice, there's no need for that check anymore.
Since you are adding Gender.valueOf(...) twice, there's no need for string concatenation and enum here.
This doesn't have to throw an exception.
This doesn't have to throw an Exception.
missing @Override
In general, I'd suggest doing. Multimap::getQueryParams(). The unmodifiableMap method is not needed here.
In general, I'd suggest doing. Multimap::getQueryParams(). The unmodifiableMap of the map is not exposed to the API.
In general, I'd suggest doing. Multimap::getQueryParams(). The unmodifiableMap of this method is not exposed to the API.
This return value is not used.
This return value is absent in the method.
This return returns an empty list if the caller passes it.
Please remove the public modifier as well and use other methods in these classes.
Please remove the public modifier as we are using it everywhere.
Please remove whitespace
Is there a reason to use MetricsLogger.LOGGER here?
Is there a reason why we want to use MetricsLogger.LOGGER here?
Is there a reason why this is here?
if (isStopped(payload)) { topic.removeMessageListener(registrationId); }
if (isStopped(payload)) {... }
if (isStopped(payload)) {
Synchronization is needed
Synchronization is needed otherwise there can be a race condition and the code inside isSendAssignentFailures synchronized.
Synchronization is a simple synchronized block.
Please remove this line
Please remove this line and replace with logger
Please remove sysout.
Should we log the potential error?
Should we log the potential exception?
Should it be done in a separate thread?
I would inline this method: ICdtVariable var = fEnvironmentMacroSupplier.getVariable(variable.getName(), info);
I would inline this method: ICdtVariable fEnvironmentMacroSupplier.getVariable(variable.getName(), info);
This could be null
These changes should be reverted, right?
These changes shouldn't be necessary anymore.
These two lines should probably be final.
You're getting the same value twice, parse it and store it in a local variable
You're getting the same value twice, parse it and store it in a local variable.
You're getting the wrong offset everywhere, but you need to make the method private or remove it from the interface.
If this is returning to be correct, the error message should be something like "could not find location matching pattern '" + pattern + "' in provided list \"%s\" in provided list \"%s\"",
If this is returning to be correct, the error message should be something like "could not find location matching pattern \"%s\" in provided list"
If this is returning to be correct, the error message should be something like "could not find location matching pattern '" + pattern + "' in provided list \"%s\"",
suggestion ignoreFailure = true; return this;
suggestion if ( ignoreFailure = true) { this; }
suggestion ignoreFailure = true;
I think it's better to return an empty string instead of null.
Shouldn't we return an empty string instead?
can we use the toString() method of the "getNameFromXmlStateValue" too?
nit: static import of Matchers.of
nit: static import of Matchers#contains
nit: static import of isEqualTo
Style-nit: We don't put braces around single line blocks
Redundant extra empty line.
nit: extra line
You can make this method private.
Maybe you can make this method private?
You can make use of DateData using DateData.
why is this necessary for initialization? shouldn't it be done in getStudio?
why is this necessary for initialization? shouldn't it be done in getStudioDir()?
why is this necessary for initialization? shouldn't it be done in getStudioSnapshot?
The file name should be "tdat".
The file name should be createTempFile.
The file should be in a finally block.
Please check the previous value is "passthroughProfileContainsSupportedProperties".
Please check the previous value is "no".
This should be tested by passthroughProfileContainsSupportedProperties
let's do it using lambda approach
do we need do it using lambda approach
do we need do it?
You are not closing the file
You are not closing files here.
Can we use <LINK_0>
Better to do an "if / else if /else" style
Do not harcode english messages, use properties.
Better to do an "if / else" style
Seems like this line should also be moved to the init method.
Seems like this line should also be moved to the if method.
Seems like this line should also be part of the if method.
What does the above path mean?
What do you think about to move this to a private method?
What are you trying to remove here?
This is a duplicate of what is being called in line 297.
This is a duplicate of what is being called in line 216 above.
This line should be removed.
Change to: throw new Status(IStatus.ERROR, "timeWithTimezone is not a valid e time", timeWithTimezone);
Change to: throw new Status(IStatus.ERROR, "timeWithTimezone is not a valid e time") }
Change to: throw new Status(IStatus.ERROR, "timeWithTimezone is not a valid e time", timeWithTimezone); }
@since 9.3 setProperties(endpoint, parameters);
private methods should be package private.
@tmarzeion Shouldn't this be parameters.get("rootReference") then?
Please keep using EnvUtil.splitAtCommasAndTrim() here
- EnvUtil.splitAtCommasAndTrim() -- why not use _links_ directly?
- EnvUtil.splitAtCommasAndTrim() -- why not use _links_ directly?
similar issue here. remove validation in client
we should not validate the hashtoken on client since we don't know the system password.
you should not validate the hashtoken on client since we don't know the system password.
username + "/xxx/" + DockerClient.getClient()
username + "/xxx/" + DockerRule.getClient()
username + "/xxx/" + DockerRule.getClient().pushImage()
do we need to add a utility method to Listener which fetches the cache and updates the cache?
do we need to add a utility method to Listener which calls addListener(listener) to this class?
do we need to add a utility method to Listener which calls addListener(listener) to this class rather than return a new one each time?
Cleanup?
Reduce the count by 5?
Unnecessary class cast at all.
Please have a constant for this
Please have a null check for this
Please have a null check here.
onError and onError are more of a resource, does it make sense to add some flag in this class instead of logging a message?
onError and onError are more of a resource, does it make sense to add some flag in this class instead of logging a string?
onError and dismissing all these strings?
If you are going to use a list of addresses, then use [this](<LINK_0>
If you are going to use a list of addresses, then you need to check the type in the exception message.
If you are going to use a list of addresses, then you need to check the type after mullable
Doesn't this need to be public?
Objects.requireNonNull(fboName)
A more intuitive way would be to write this.fboName = fboName;
Name it "ForceText"?
Name it "ForceText"
Name it "ForceText MB"
Consider using Objects.requireNonNull()
CacheOperationsTest.cacheMode is never null
CacheMode.NONE is not used
this class is not allowed to be used in unit tests
this class is not allowed to be used in unit test.
this method is not needed
Replace the null check with.equals(typeName)
should be "ecore.EObject"
Should we check for null type here instead of just type instanceof?
no need to check if it's a Class?
no need to check if it's a Class.
no need to check this?
Consider overriding toString() instead of relying on the model.
Consider overriding toString() instead of generating the time.
Use getClass().getSimpleName() instead of hard-coding the name.
Instead of doing this, can we do a VideosModuleComponentObject object?
Instead of doing this, can we move it to VideosModuleComponentObject class method?
Instead of doing this, can we do a VideosModuleComponentObject object = new VideosModuleComponentObject(driver);
suggestion LOG.error("Exception from BufferedReader:", e);
you can add a WARN level of this exception
you are ignoring the exception here, right?
add null check
add null checking for newInput
add null checking
Is this a public constructor or the other? If it's private, then I would remove this public.
Is this a public constructor or the other? Could you make it protected?
Is this a public constructor or the other? Could you make it package protected?
if the message is not correct, we should also verify that the label is the expected value.
if the message is not correct, we should also verify that the label is the expected value of the queue.
if the message is not correct, we should also verify that the label is the expected value of the queue
The note should be closed in a finally block.
The variant returned by replaceNote is a deprecated method, so it shouldn't be public.
The variant returned by replaceNote is a deprecated method, so we should add a check on it.
Can you rename it to date_trunc?
Can you rename it to date_trunc?
Move to a local variable
Check for null and validate params.
Check for null and validate method
Check for null.
SystemMemoryContext#setBytes is the same as SystemMemoryContext#setBytes. Is this needed?
SystemMemoryContext#setBytes is the same as systemMemoryContext. So it doesn't need to be public.
SystemMemoryContext#setBytes is the same as SystemMemoryContext#setBytes. Is it needed?
Needs to be private, same for the other 2 methods
getActiveColor(String colorChar) is deprecated, use getText()
getActiveColor(String colorChar)
I don't think we need to set modes here.
I don't think you need to set hidden to true here.
This method can be private
use getGlusterVolume() instead of DbFacade.getInstance().getGlusterVolumeDao()
use getDbFacade().getGlusterVolumeDao() instead of DbFacade.getInstance().getGlusterVolumeDao()
use getGlusterVolume() instead of DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume);
Should be some kind of assert?
Should be some kind of test here.
Should be some kind of test here to verify that the request is valid.
I don't think we should set a value for timeoneOffset. Callers should always have an getTimeone with a non-zero value, though.
I don't think we should set a value for timeoneOffset. Callers should always have an getTimeone rather than a literal for the timeone.
Was this needed?
remove
remove with deactivate
remove with the statement
This is not time zone id file?
Is there a reason why this is necessary?
This should be a RuntimeException, not a runtime exception
Use Assert.assertTrue().
use Assert.assertEquals
Use Assert.assertTrue.
Missing whiteListedAgencies.
"Missing whiteListedAgencies"
Missing curly braces.
Is there a WebDriverWait necessary here? Can we please simply use new WebDriverWait(driver, 10000)?
Is there a WebDriverWait necessary here? Can we directly use it we wait, which excludes the alerts?
Is there a WebDriverWait necessary here? It can be Asserted that the alert text is created.
Can't we move the  location to a constant?
Can't we move the identifiers into the parent directory as well?
Can't we move the /Name classes into a single location?
Is this one worth have an optional estimation?
Is this one worth have an optional output with isEnabled instead of checking the DISABLED?
Is this one worth have an optional output with isEnabled instead of checking the isEmpty?
we should have a initalizer of File(progressFilePath, PrintStream error) and pass the error to the constructor.
we should either throw an exception or log something here to indicate the path was not created
we should have a initalizer of File(progressFilePath, PrintStream error) that calls new File(progressFilePath).
please dont remove explicit initialization
it looks like images have no diff
it looks like it's better to remove the file and add sandbox.
I would prefer to change this to throw NullPointerException instead of catching NPE.
I would prefer to change this to throw NullPointerException instead of catching NPEs.
NPE?
Make this an abstract method... try {... } finally { rs.close(); }
Make this an assertion?
Make this an static import?
container => Cluster
container = null
container
this looks like an error. If there are multiple devices with the same id, we'll get a different one in the case of failure. Should we be throwing a generic Exception? Or is that handled in a separate method?
this looks like an error. If there are multiple devices with the same id, we'll get a different one in the case of failure. Should we be throwing a generic Exception? Or is that handled in a different way?
out of curiosity, why is this true?
This constructor should call the more general one.
This constructor should call the more general one-argument variant.
This method should be deleted.
This method should not be public.
This method should not return a null.
This method should not return a null. It is an internal error.
Did you need to use getName() instead of "minecraft:"
Did you mean to use java.util.Objects.nonNull(String)
Did you mean to use java.util.Objects.nonNull(String) instead?
I almost want to say that the SkullOwner in the first place is necessary, since it's not an SkullOwner.
I almost want to say that the SkullOwner in the first place is necessary, since this is a key in the JSON object.
I almost want to say that the SkullOwner in the first place is required, since this is a key in the JSON object. Else it would be a new SkullOwner in the first place.
decorator.onError(....) is not required to call these methods.
decorator.onError(....) is not needed to call these methods.
curly braces
Is there a reason for this to be public?
Is there a reason for this to be package-private?
I think this'd need to be here. Its a re-startReporting()
remove this line
please remove this line.
please remove this line
Why do we need this?
Why do we need this? It seems like this method should be private.
Why do we need this? It seems like this method is already private.
In the original code, the docUpdateSentinel_.setFocus(sourceOnSave); is a no-op and probably the code will just use that
In general, I think we should handle the case where docUpdateSentinel is null, instead of null.
In the original code, the docUpdateSentinel_.setFocus(sourceOnSave); is a no-op and might be confusing.
It's better to id("session" + rowId
id("session")
ID("session")
I think this should be capabilityRegistry.clear().
I think this should be capabilityRegistry.remove()
I think this should be ok.
Missing final
Missing space after }.
Curious why this is needed.
Why? RequestBodyDeserializer exists = null; if (contentType == null) {... }
Why? RequestBodyDeserializer exists = null; if (contentType == null) { n = ACL.copyOf(contentType); }
Why? RequestBodyDeserializer exists only if the request is not null.
I would use "Add \"security-constraint\" elements to this descriptor."
Nitpick: I would use "Add \"security-constraint\" elements to this descriptor."
Nitpick: I would use "Add \"security-constraint\" elements to this descriptor." whenever it's not "Add" element.
possible NPE
possible NPE?
possible NPE here
maybe it'd be better to check dir.isDirectory() before trying to check if the directory exists and then check if it exists?
You could replace dir.isDirectory() with dir.isDirectory() and then test dir.isDirectory() for the directory.
You could replace dir.isDirectory() with dir.isDirectory() to avoid the null check.
Same argument as with the DeadlineJob.
Same argument as with the DeadlineJob. Is it worth a separate refactor?
Same argument as with DeadlineJob.
Can we please explain this a bit more?
Can we please explain this a bit?
Can we please explain this a bit more? 1 line please.
suggestion this(-1, null);
[minor] This should be considered a bad practice.
[minor] This should be initialized to null?
Please, rename the field to hasHammer, e.g. hasHammer = true for the switch.
Please, rename the boolean to hasHammer, e.g. hasHammer = true for the switch.
Please, rename the variable to hasHammer for clarity.
It may causes two consecutive calls of onTracksChanged due to MediaPlayer L3008 in the same patch set.
It may causes two consecutive calls of onTracksChanged due to MediaPlayer L3008 in the same patchset.
It may causes two consecutive call of onTracksChanged due to MediaPlayer L3008 in the same patch set.
Add the StandardCharsets.UTF_8 constant to the error message.
you can move this to the first line of the try block
you can move this to the start of the method
I wonder if this method should be Files.deleteDirectories(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, "staging directory cleanup");
I wonder if this method should be Files.deleteDirectories(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, "staging directory cleanup"));
I wonder if this method should be Files.deleteDirectories(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, "staging directory cleanup")
Should we verify that we can set the external ID on the study?
Should we verify that we can also set the external ID on the study?
Should we verify that we set the external ID on the study?
You can't use the field is final because there is no shared data to this method.
You can't use the field is final because there is no shared data to this object.
You can't use the field is final because you're not using it to determine whether you are setting or not.
Make this java fail("Expected exception with message: " + messagePattern);
Make this PrestoException.
Make this public please.
java mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference )
java ArrayList<AnnotationMapperReference> mapperReferencesForConstructor = new ArrayList<>();
java mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ) );
suggestion return issueShouldNotBeReported(issue, excludedLinesByRule());
suggestion return issueShouldNotBeReported(issue, excludedLinesByRule);
Not a big deal, but the method name could be more descriptive.
why not keep the method static?
How about keep the methods IMO?
why not keep the methods static?
again, can you switch to the existing 'if' condition?
Shouldn't this not copyProjects as it was before?
Shouldn't this not copyProjects?
you should use 'instanceof()' here
you need to use 'instanceof' here
you need to use'magic bytes' field.
I would go to the beginning of this folder
I would prefer to have this fixed the issue for several files
I would go to the previous folder
I'd prefer a NullPointerException with a message explaining what value is null.
I'd prefer a NullPointerException instead of the NullPointerException.
I'd prefer a more explicit exception handling.
Why not use <LINK_0>
Why not throw SnapshotImpl.create(update);
Why not use <LINK_0>?
I'd suggest moving this check to the top of the method to have a static method with a Set<String> getFatalException(String error) which would be consistent with the enum above.
I don't think we need a static import for the internal state.
I'd suggest moving this check to the top of the method to have a static method with a Set<String> getFatalException(String error) which would be consistent with the order of the checks.
Does this need to be public?
Does the constructor need to be public?
Does not need to be public.
what is the point of method name?
in test method currentFrame, expected String.format(String)
in test method currentFrame, expected String.format()
nit: we don't usually use final on method. (Also, as a side note: we don't use final for tmp variables)
nit: we don't usually use final on method. (Also, as a side note, we don't use final for tmp variables)
Can we compute this only once? (i -> i % 2 == 0? createValue() : null)
Extra space.
This method needs to be public.
This needs to be public.
@garydgregory Please use [StringUtils](<LINK_0>
@garydgregory Please use Args.notNull for this
@garydgregory Please use trim() to check response.contains()
Should we pass in MAX_LEN here?
Should we pass in the list of SIE and then compare the resulting array?
Can we use 'U' in here?
Use org.atlasapi.entity.Series instead of the fully qualified class name
Use org.atlasapi.entity.Series instead of the fully qualified name
Use org.atlasapi.entity.Series instead of importing the base class
iirc it's initialized in the ctor, check that it's not empty.
isn't it more readable to use diskInfoDestinationMap.values() instead of calling it twice?
isn't it more readable to use diskInfoDestinationMap.values() instead of the list to iterate over?
Typo: udm.deleted
Typo: udm.deleted = true
Typo: udm.deleted is not null
Should also add new commands here as well.
Should also add new Command() to the console too.
Should also add new commands here as well
why not tracking it in computeIfAbsent?
why not init it once in the constructor and directly return?
why not init it once in the constructor?
Why remove this?
Why do you need this?
Why do you need this line?
Can you simplify this if statement by using return parameterDunningCampaignCode;
Can you log this as an empty string instead?
Can you simplify this if statement by using return parameterDunningCampaignCode;?
bad rebase
bad error message
bad start
why the cast to an int here?
why the cast to int here?
why private?
Let's make this more consistent and remove the Map use of the reference type.
Let's make this more consistent with the method  getStockList.
Let's make this more readable and remove the map if needed
If you don't have access to TsvFile, you can use TsvFileParser.create().
If you don't have access to TsvFile, you can use TsvFileParser.create()
I think you should also write "src/test/resources/examples/dataWithHeader1.tsv"
feedback session's course ID -> feedback question?
Actually, it's a matter of style, but you don't need the braces around the if clause.
feedback session's course ID -> feedbackQuestionAttributes.getGiverType()
back to URL (URL)
space
back to general
==
does this mean you can't set the attribute to null?
== null?
Should download method be used in these methods?
Should this be in the Flux<ByteBuffer> instead?
Should we take in a look at this.download()?
Is it possible that the thread is interrupted and the previous thread is still alive?
Is it possible that the thread is interrupted and the previous thread is still alive? If this is in the background, the thread should stop the thread.
Is it possible that the thread is interrupted and the previous thread is still alive? If not, then the thread should stop.
suggestion data.getExtras().getStringArrayList(RecognizerIntent.EXTRA_RESULTS)
suggestion data.getExtras().getStringArrayList(RecognizerIntent.EXTRA_RESULTS) == null? "" : data.getStringArrayList(RecognizerIntent.EXTRA_RESULTS)
You're not checking the result here, it's going to be more performant. suggestion data.getExtras().getStringArrayList(RecognizerIntent.EXTRA_RESULTS)
This method should be static as well. Also, use the same in the other class.
This method should be static as well. Also, use of the rest of the file to test images.
This method should be static as well. Also, use the same in Presto code.
return!this.m_elements.isEmpty();
return!this.m_elements.isEmpty()?
return!this.m_elements.isEmpty()?
Please use contains instead of contains otherwise looks good.
Please use containsOnly instead of contains otherwise looks good.
Please use contains followed by contains otherwise looks good.
toString() is missing when the parameter is null
toString() is missing when baseName is null.
toString() is missing when the parameter is null.
if (signed) is enough. We try not to compare boolean variables to boolean constants.
if (signed) is enough. We try not to compare boolean variables to boolean variables.
If remove, The caller has to allow this method to be called.
Wonder if we would want to check toString() first instead of toString() here.
Wonder if we would want to check toString() first instead of toString() for more safety.
Wonder if we would want to check toString() first.
Why dx and r?
Why is this using dx?
Why are these dx and r?
could use Objects.equals(a, "a")
could use Objects.equals
could use Objects.equals(a, "a") instead
Is it possible to remove Exception?
Is it needed?
Remove Exception.
"Cannot perform the analysis on this trace because the trace is of the wrong type"
suggestion "Cannot perform the analysis on this trace because the trace is of the wrong type";
trace
Does this need to be synchronized?
Is synchronized needed here?
Is this method really needed?
Please make this private. It is only used by the item.
Please make this private.
Use method reference
"is not part of the VariableOrder."
"be not part of the variable order."
"be not part of the variableOrder."
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_0>
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_1> <LINK_0>
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_2>
Where really needed this and the next line?
add null check
Where really necessary?
This should be private, no?
This should be private or package private
This should be package private.
Please change to: VmBase vmBase = getVmBase(vmId);
Please change this to: VmBase vmBase = getVmBase(vmId);
I think this should be clusterUtils.getCompatibilityVersion(vmBase)
Please remove evict here, it's unneeded to fetch the log.
Please remove evict here, it doesn't do anything better.
Please remove evict here.
!= null
null check
Optional
why static?
why private static?
why private?
If I understand correctly, cleanupPassthroughVnics can be done inside cleanupPassthroughVnics, instead of inside'refreshPassthroughVnics' parameter. It's enough to take a snapshot and a'refreshCaps' method to do it. Also, the'refreshCaps' method should be called in 'RefreshCaps' method (which is the new behaviour).
If I understand correctly, cleanupPassthroughVnics can be done inside cleanupPassthroughVnics, instead of inside'refreshPassthroughVnics' parameter. It's enough to take a'snapshotFailed' variable (which is what it is).
If I understand correctly, cleanupPassthroughVnics can be done inside cleanupPassthroughVnics, instead of inside'refreshPassthroughVnics' parameter. It's enough to take a snapshot and a'refreshCaps' method to do it.
Let's move this to a constant to make it more readable.
I think the underscore should be a dash instead of underscore.
Let's move this to a constant to make it clear what the difference is.
I think you need to add a check for null here: if (ElasticAgentExtensionConverterV2!= null) {
Use ElasticAgentExtensionConverterV2 instead of duplicating the code.
I think you need to add a check for null here.
Would it be better to use the constant for this?
Can we change this to the following?
Would it be better to use the constant in MetadataConstants.properties?
It's not clear why you call clickOnaHiddenElement instead of clickOnaHiddenElement
It's not clear why you call clickOnaHiddenElement instead of clickOnaHiddenElement.
I'm not sure why you removed the debug handler and instead of using clickOnaHiddenElement method, it's not intended to do anything by default.
Why do you need a separate 'block' block?
Why do you need a separate 'if' here?
You could use peekType(index) that would make it more obvious what's going on.
No need for this. on methods.
No need for this. on next line.
No need for this. here.
you should catch the exception in the log instead of logging it
you should catch the exception here. At least log the exception
you should catch the exception here. At least log the exception.
suggestion assertThat(got).contains("Description");
suggestion assertThat(got).contains("Description);
suggestion assertThat(got). contains("Description");
I think this is okay, because this method does not return FutureUtils.composeAfterwards.
I think this is okay, because this will run if the handler is closed again. compareAndSet should be called before timeout, right?
I think this is okay, because this will run if the handler is closed again. compareAndSet should be called before timeout
You can use Truth assertions instead of the third party ones.
You can use the Truth assertions here.
You can use Truth assertions instead of the ones.
Why is it public?
Why is it protected?
Why is this protected?
not sure if this method name is really useful or not, how about using the ComparisonUtil.getClass().getSimpleName() instead of hard-coding the package name.
not sure if this method name is really useful or not, how about using the ComparisonUtil.getClass().getSimpleName() instead of hard-coding the package name?
You can use assertEquals here and in the other files to make sure that this assertion fails even if the fields value is not null.
Not sure it's worth it, but since the field is final, it's more likely that it's the same as the class name.
Not sure it's a good idea to return null here. The test should explicitly cover the null case.
Not sure it's worth it, but we could always return null here.
As you already need to touch this file, I think this empty line could be removed.
As you need to touch this file, I think this empty line could be removed.
As you already need to touch this file, I don't think this empty line could be removed.
Code style
Code style: Missing space after =
Code style.
@fabriciofx Here also, we can use the encoding version of the backing array to avoid junk.
@fabriciofx Here also, we can use the new method for writing values().
@Override
Can't we use containsKey() here?
Can be replaced with (avEntry::getKey)
Can't we use containsKey?
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
You should verify that the underlying data is as expected.
You should verify that the underlying parameters are sent.
You should verify that the instructor is actually used.
Why use a sanitizeMap here?
Why use a RelNode here?
Why call it again?
Maybe use Collections.singletonList() here instead of new ArrayList<>()
<Integer> emptyList is perhaps cleaner.
<Integer> emptyList is perhaps simpler.
Not needed.
Get rid of this.
Not needed. See below.
@Override should not be public.
@Override should not be public. Please remove.
@Override should be on the line above.
does this need to be public?
Do we need this method if it is private?
does this have to be public?
Please, use public HotPlug() { return osRepository.hasNicHotPlug(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion()); }
Please, use public HotPlug() { return osRepository.hasNicHotPlug(getVm().getOs(), getVdsGroupCompatibilityVersion()); }
Please, use: VmRepository.hasNicHotPlug(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion()).
Please, reuse your extracted method for checking if a file is an Erlang source file.
Please, reuse your extracted method for better readability: java private static void addAnnotatedPaths(List<ErlangFileDescriptor> file) {
Please, reuse your extracted method for better readability.
This is nice, but I wouldn't mind moving the null checks to the new line from the [line 44](<LINK_0> as well.
This is nice, but I wouldn't mind moving the null checks to the new line from the [line 44](<LINK_0> here.
This is nice, but I wouldn't mind moving the use of Optional here. It comes from the client code.
Throw an exception here if the entity store is null.
Throw an exception here if the entityStore is null.
Returning a copy of the map might be a bit off in some cases. It's not a good idea to return an immutable map.
This doesn't seem right. I think the errorHandler reference should be an error handler reference instead of a reference. Either have a separate close helper or a factory method on errorHandler that returns this.cncByteBuffer. I assume this should be closed before closing the object on close.
This doesn't seem right. You need to keep this consistent with the errorHandler reference above. You could remove the errorHandler reference here too.
This doesn't seem right. I think the errorHandler reference should be an error handler reference instead of a reference. Either have a separate close helper or a factory method on errorHandler that returns this.cncByteBuffer.
Use a OffHeapServerStore static constant.
Use a OffHeapServerStore instead
Use a OffHeapServerStore(byte[], int, int)
This isn't used.
This isn't used for the visibility of the view.
This isn't used for the whole view.
Do you think we want to debug the entire bean be logged? I'm not sure.
<LINK_0>
Do you think we want to debug the entire bean be logged? I think this is not the right level.
size == null || size.longValue() == -1
size == null || size.longValue() == -1?
size is never null or empty, so the condition should be size == null || size.longValue()
Please use CheckUtils.isUnreasonableName(generationConfig.isStatusStatus()) instead.
Please check ParameterFormatter.isUnreasonableName(name)
Could we use CheckUtils.isPositiveNumber()?
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To save changes you need 'Submit' rights on " + REF_CONFIG"."
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To push to this reference you need 'Submit' rights on " + REF_CONFIG"."
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To push into this reference you need 'Submit' rights on " + REF_CONFIG"."
Please do check on null for all such getters. I believe we previously returned null in such case, because now we return primitive long which isn't an object.
Please do check on null for all such getters. I believe we previously returned null in such case, because object was a Date, now we return primitive long which isn't an object.
Please do check on null for all such getters.
Maybe 'cluster.isSetRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
Maybe 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
Maybe 'cluster.isSetRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'true' as a parameter.
suggestion sink.success(new OkHttpResponse(response, request));
I think this method should be called createFromResponse(), and then close it in finally block.
I think this method should be called createFromResponse(), and then close it shouldn't be called explicitly.
you can check here if globalLayout == null and throw an exception if it's null.
you can use AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayout)
you can use AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayout) here
wouldn't it be better to throw IOException?
wouldn't it be better to return Path.resolve(new Path("testing.yaml")) that way we don't have to expose File directly into Path?
wouldn't it be better to return Path.resolve(new Path("testing.yaml")) so that static import can be reused?
do we need to check?
do we need to check the status?
check status!= null
Please remove this. Tests are by intent using a string and not a constant
Check error code/description
Please remove this. Tests are by intent using a string and not a constant.
This should be wildfly-base.config
This should be in the shared method.
This should be in the base class. It's not required to add this.
Typo
Typo in exception
Typo in exception message
I'd move the assertion to the method: public void renameTempPartitionFile(File workDir, int partId) throws IgniteCheckedException { File defragmentedPartTmpFile = defragmentedPartTmpFile; try { Files.move(defragmentedPartTmpFile.toPath(), defragmentedPartFile.toPath(), defragmentedPartFile.toPath(), ATOMIC_MOVE); } catch (IOException e) { handleIoException(e); } } catch (IOException e) { handleIoException(e); } }
I'd move the assertion to the method: public void renameTempPartitionFile(...) throws IgniteCheckedException { File defragmentedPartTmpFile =... }
I'd move the assertion to the try block, so that we don't do aIoException catch and collapse all the catch.
curly braces even though this is not a style guide
curly braces even though this is not a good idea.
curly braces even though this is not a style guide.
This will break the equality of mAlign.length() == 0.
This will break the equality of mAlign.length() == 0. I think it is more logic to avoid duplicating the array logic
This will break the equality of mAlign.length()
This method is not used.
Parameter is not null
Parameter is not a parameter, so it should be null
why do you want to whitelist it at the end?
why do you want to whitelist it at all?
don't whitelist name and event_types are.
this is probably the same as in the other tests, so it should be named setValidatorForActivation
this is not required, 'is it?
this is not required, 'throws' should be enough
"the cached Channel" should be sufficient
"the cached channel" should be sufficient
"the cached Channel"
Raw type.
Raw type here.
This shouldn't be the getBytes(). You should enforce that.
Nit: "Creating ephemeral nodes..."
Nit: "Creating ephemeral nodes..." would be equivalent.
Nit: "Creating ephemeral nodes..."?
catch WPE in a separate method requestRouteToHostAddress(int networkType, InetAddress InetAddress) or mService.requestRouteToHostAddress(networkType, address);
You're not getting the address from the hostAddress and using it to determine if it is a host address. Wouldn't requestRouteToHostAddress do the same?
catch timeout?
Do you want to push this constructor down into the default constructor?
Do you want to push this constructor to the base class?
Do you want to share this constructor?
Please use CommonUtils.loadResource(). It allows overriding config files by placing them into /etc/sw360
Please use CommonUtils.loadResource(). It allows overriding config files by placing them in /etc/sw360
Please use CommonUtils.loadResource() instead.
Remove the redundant null check, and the null check is not needed.
Remove the redundant null check, the annotation is not needed
Remove the redundant null check, the annotation is not needed and can be removed
wait.forElementClickable() should be used before
wait.forElementVisible returns WebElement
wait.forElementVisible()
Why are we not returning null?
Why are we returning null?
Why are we returning null when it should be completed?
I understand this is here because of the mIsMultiSelectEnabled in line 54, but now it's set to false and we need to set it to true. Is that intentional?
I understand this is here because of the mIsMultiSelectEnabled in line 54, but now it's set to false and we need to set it here.
I'm thinking about this. setting mIsMultiSelectEnabled to false does not seem like it has any effect.
suggestion checkDuplications(functions, FUNCTION_TO_NAME);
the method checkDuplications should be private
the method checkDuplications should be tested with the parent class.
Use StandardCharsets.UTF_8
Use StandardCharsets.UTF8
Use StandardCharsets.UTF8 instead
remove System.out
Debugging artifact?
Remove System.out
Is this parameters really mandatory? I thought its default was false.
Better to use something like "StepParametersValidator".
Is this parameters really mandatory?
Can we use Collections.singletonList() instead of creating new Date object?
Can we use Collections.singletonList() instead of creating new Date?
Can we use Collections.singletonList() instead?
please export the "protected Snapshot doPopulate()" to a method, for consistency.
please export the "protected Snapshot doPopulate()" to a method so it can be more readable (just for consistency)
please export the "protected Snapshot doPopulate()" to a method so it can be called only once and not on the whole class.
This test is wrong, check that the expected exception gets thrown using the expected attribute of the @Test annotation
This test is wrong, check that the expected value isn't null
This test is wrong, check that the expected value isn't null and then test that using the expected value
I would prefer to make the field private rather than protected. It makes it easier to reason about what the field is public.
I would prefer to make the field private rather than protected. It makes it easier to reason about what the field is.
I would prefer to make the field private rather than protected. It makes it easier to reason about what the field is (or even a subclass) approach.
Add a Preconditions.checkArgument checks to verify that the passed reparedStatement is not null
Add a Preconditions.checkArgument checks to verify that the returned ByteBuffer is not null
Add a Preconditions.checkArgument checks to verify that the passed SSLEngine is not in the cache
Can we roll this into the parseJobId method and maybe rename that to reflect its purpose of creating a manager from config along with the attribute that its keyed on? E.g. getManagerFor... or getManagerFrom...
Can we roll this into the parseJobId method and maybe rename that to reflect its purpose of creating a manager from config along with the attribute that its keyed on? E.g. getManagerFrom... or getManagerFrom...
Can we roll this into parseJobId?
PerunSession.delete() is missing from user_attr_values() as well.
PerunSession.delete() is missing from user_attr_values() (no need to query it for single element).
PerunSession.delete() is missing from user_attr_values() (no need to query whole user)
You should also lazily initialize the exclusionList file during initialization, as it will slightly improve performance when calling the code during init.
You should also lazily initialize the exclusionList file when exclusion is not provided, as it will slightly improve performance when calling the code during init.
You should also lazily initialize the exclusionList file during initialization?
maybe move that to a constant
why public?
maybe pass the ts?
This change is not related to this PR, but while you're at it, can you change this to be: return Objects.equals(c, object.change(dbProvider));
This change is not related to this PR, but while you're at it, can you change this to be: return Objects.equals(c, object.change(dbProvider));?
This change is not related to this change. Relying on ChangeCommand#change() is actually more robust than this implementation. But I must admit I can't find another solution.
@vilchik-elena measures.stream().anyMatch( measure -> measure.isPop() || measure.hasComputeRatio()).
@vilchik-elena measures.stream().anyMatch( measure -> measure.isPop() || measure.hasComputeRatio()). Up to you.
@manstis the original concern about extracting @BeforeMethod to a method to reduce code duplication.
If we can avoid this method, it would be good to return an empty string instead of an empty string.
If we get an exception in this method, I would suggest having a method that returns the appropriate value.
If we get an exception in this method, I would suggest having a method that returns an Optional<String> and throw an exception in the callers.
Is it possible, that the context is null?
Is it possible, that the context is null? What happens in this case?
Is it possible, that the context is == null?
Please add a public static String getMessageId(String rawMessageHref) { return (rawMessageHref.lastIndexOf('/'))? rawMessageHref.substring(rawMessageHref.lastIndexOf('/')+1); }
Please add a public static String getExtension(String rawMessageHref) { return substring(rawMessageHref.lastIndexOf('/')+1); } What do you think?
Please add a public static String getMessageId(String rawMessageHref) { return (rawMessageHref.lastIndexOf('/'))? rawMessageHref.substring(rawMessageHref.lastIndexOf('/')+1); } What do you think?
Please add braces around the if body.
Please add braces around the if statement bodies.
braces
You can remove the /src/test/resources/ since it is declared.
You can remove the \\src\\test
/src/test/resources/user.dir
These two should be set in the DTO's constructor. Could these be null?
These two should be set in the DTO's constructor. This should be in a separate class.
These two should be set in the DTO's constructor. Could these be null if theDto is null?
These two lines could be this.literalExpression = mock(literalExpression);
These two lines could be this.literalExpression = mock(literalExpression);. We don't need to really care about it, since we use it more than once.
These two lines could be this.literalExpression = mock(literalExpression);. We don't need to really care about it, since we use it more than just to append literalExpression to the variable.
Do we need to compare the clocks here?
Do we need all these objects?
Do we need all these objects here?
@vilchik-elena Why not return!result &&!isConstant(Kind.CHAR_LITERAL, Kind.CHAR_LITERAL, Kind.LITERAL_LITERAL);
@vilchik-elena Why not return!result &&!isConstant(Kind.CHAR_LITERAL, Kind.CHAR_LITERAL, Kind.LITERAL_LITERAL);?
Please remove the null checks.
We should clean up the original implementation here and remove the method that throws AbstractProject.
We should clean up the original implementation here and remove the method that is already very obvious.
We should clean up the original implementation here and remove the method that throws AbstractProjectException
public final?
public final please, with the annotation and method name.
public final
@fanifieiev the same above.
@fanifieiev the same above, it should be RsOf.
@fanifieiev the same above
Kind of a strange condition to test for >= ICS. Just maybe we should do the same here.
Kind of a strange condition to test for >= ICS. Just maybe we should just check for > 0 instead?
Kind of a strange condition to test for >= ICS. Just maybe we should just check for > 0 instead.
You can just use return getIndex() here, no need to copy.
You can just use return 'this' instead of copying.
You can just use return getIndex() here, no need to copy and then copy.
Before you were checking if all these values are empty, now we'll have to use null when creating the properties.
Before you were checking if all these values are empty, now we'll have to use null when creating the properties. That seems better.
Before you were checking if all these values are empty before calling getScheduler.
nit: could be package private..
nit: could be package private.
nit: this could be package private.
can you please remove this?
can you please remove the @Inject annotation?
please remove
Could you please rename this list to something like list?
Could you please rename this list to something like listList?
Could you please rename this variable to something like list?
Logging.
Handle it properly.
Be careful.
sorry. Please use the static imports, as it's a little clearer.
As an instance variable, you can use packet.getExtensionBit() here.
sorry. Please use the static imports, as it's a matter of style.
This if-else is duplicated in the previous method.
This if statement can be removed.
This if-else looks duplicated, can we extract a private method for this?
Isn't it possible to have more than one binding to the class?
Isn't it possible to have only the view defined in the class?
Isn't it possible to have an injection of the project in the class?
I would remove the public here and use of DialectManagerImpl.INSTANCE.getAllLoadedRepresentations(session).stream() instead.
I would remove the public from this method.
I would remove the public here and use the private method.
nullity check
nullity check here too :)
null check
scaledData, thread safety and all
scaledData, thread safety and size should be > 0
scaledData, thread safety and size should be Float.
Would it be possible to avoid using nulls by yourself?
Would it be possible to avoid using nulls by default?
Would it be possible to avoid using nulls here?
This is still a Geopoint, but in practice the Geopoint is not enabled. Just use the GeopointFormatter here.
This is still a Geopoint, not an Android point. Just use the GeopointFormatter here.
This is still a Geopoint, but in practice the Geopoint is not enabled. Just use the GeopointFormatter.
Wonder if we need to cast to Number here?
Wonder if we need to cast toNumber here?
:+1:
When will the results of scheduleIfNoTaskRunning() ever be true?
When will the results of scheduleIfNoTaskRunning() ever be called?
When will the results of scheduleIfNoTaskRunning() be true?
This should return a BAD_REQUEST when it is returned.
This should return a BAD_REQUEST when it isn't handled.
This should return a BAD_REQUEST when it isn't a valid json.
@mbarbieri you can also use StandardCharsets.randomAlphanumeric
why CAS fail?
@mbarbieri you can also use FakeNode
rename tempVar2 to something more meaningful
rename tempVar2 to resource
declare private static final
unnecessary public
We can add synchronized keyword here as well.
Objects.requireNonNull()
I'd add the comma after the comma.
I think we're missing the trailing slash below.
I'd add the trailing slash below as we did below.
I think this should be logging instead of println
I think this method should be removed
I think this should be logging instead of println.
AssignMentId ->  assignmentId
Name/ assignmentId
Name/ assignmentId?
Remove the duplicate domain.
Remove Domain.
Remove
This seems like it use a different name for the class. Do we need to rename it to _ or _?
This seems like it use a different name for the class.
This seems like it use a different name for the class. Do we need to rename it?
This assumes the proper code is to check if the range is within the range, and you might expect it to be within the range if the target range is >= getMaxOverlap().
This assumes the proper code is to check if the range is within the range, and you might expect to return false if not.
This assumes the proper code is to check if the range is within the range, and you might expect it to be within the range if the target range is within the range. This is not the case here.
Do you need to duplicate the 'byteBuffer.position() + size'?
Do you need to duplicate the logic in getString(int size)?
Do you need that?
this cast is pointless.
this cast is pointless, because it would return a NormalizeFunction that should result in there.
this.alpha as well
I think you can call group.region() if the line is the same
I think you can call group.region() if the line is the same.
I think the case of the group should be different than the current one.
I don't know if this is a good idea to return null by default, but given the description is not clear (so we can change the String to String). I would prefer to either return Optional.ofNullable(this.changeDescription).map(String::trim).orElse(null) or return String.trim().startsWith("{")
I don't know if this is a good idea to return null by default, but given the description is not clear (so we can change the String to String). I would prefer you use String.valueOf(this.changeDescription) (this.changeDescription)
I don't know if this is a good idea to return null by default, but given the description is not clear (so we can change the String to String). I would prefer you use String.valueOf(this.changeDescription)
Add a log message here.
When would this method be called? Why are we catching the exception here?
Add a log message here? Why are we catching exception and returning ""?
This is an improvement. We could also directly use the "", and use the template in the class.
This is an improvement. We could pre-compute the string representation of storing the last element in a variable.
This is an improvement. We could also directly use the "", and use the template in the code.
@mstzn36 what is the difference between AbstractAsyncKeyValueStore and AbstractAsyncKeyValueStore?
@mstzn36 what is the difference between AbstractAsyncKeyValueStore and the async thread?
@mstzn36 the number of threads is either 30 seconds or more.
A lot of code in this class is a good candidate for a private method: java private Semaphore getActiveThreadNum(int maxThreadNum) { if (activesLimit == null || activesLimit == 0) { return null; } synchronized (this) { if (activesLimit == null || activesLimit == 0) {... return new Semaphore(maxThreadNum); } } return activesLimit; }
How about having a synchronized block for this, without any synchronization block?
A lot of code in this method: why not have it return null?
Another way to do this like this: java final Object[] array = (Object[]) arrayObject; if (arrayObject == null) { array = arrayObject; } else { array = array.clone(); }
Another way to do this like this: java final Object[] array = (Object[]) arrayObject; return array.clone();
No need for final, the casting to Object[] is enough, and can be removed.
Minor: could return streamVal!= null? streamVal : defaultValue;
could return Optional.ofNullable(streamVal).orElse(null); or line 53 and 176
could return Optional.ofNullable(streamVal).orElse( defaultValue);
Why 2? default-max-chars.csv has a single line so it should have a greater length?
Why 2? default-max-chars.csv has a single line so it should have a greater value?
Why 2? default-max-chars.csv has a single set of arguments?
If the reasonLocation is isOneOf(MUTABLE_TYPE_TO_FIELD) is true, does it make sense to drop the isOneOf check? (If that's what we would prefer to avoid, we could also make the call to isOneOf or isOneOf or something else.)
If the reasonLocation is isOneOf(MUTABLE_TYPE_TO_FIELD) is true, does it make sense to drop the isOneOf check? (If that's what we would prefer to fix, we could also make isOneOf(MUTABLE_TYPE_TO_FIELD) a bit simpler to fix the issue.
If the reasonLocation is isOneOf(MUTABLE_TYPE_TO_FIELD) is true, does it make sense to drop the isOneOf check? (If that's what we would prefer to fix, we could also make isOneOf(MUTABLE_TYPE_TO_FIELD) a bit simpler to avoid duplicated code-ness.
@xupyprmv I'm not sure if it's worth to define this as a constant.
@xupyprmv I'm not sure if it's worth to use a StringBuilder here.
I think this should be fullyQualifiedName + (imported)
Why is this needed? Isn't it already done in the setup() method?
Why is this needed? Isn't it already done by the setup() method?
Why is this needed? Isn't it already done by super.tearDown?
accepted change
unindent this?
unindent line
You're changing the passed in Collection to a List. Is it possible to get a list from the values array instead of converting it to a List?
You're not checking if it's null here. If you find a NPE, you're returning null here.
You're changing the passed in Collection to a List. Is it possible to get a list from the values array instead of iterating it?
Might want to add a metric for timeToWait that can be set in the while loop.
Might want to add a metric for timeToWait that can be set in the while loop?
Might want to add a metric for timeToWait that says that the account is now taken for timeToWait above, while for remaining timeToWait is within the loop.
Sorry! I meant we don't need to pass the options in!
Sorry! I meant we don't need to pass the options in.
Sorry!
I see that we don't use the factory on the constructor but I think it would be better to have a createValidatorWithConfiguration(configuration, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, strategyFactory, factory, scriptEvaluatorFactory, traversableResolverResultCacheEnabled ) to the factory.
I see that we don't use the factory on the constructor but I think it would be better to have a createValidatorWithConfiguration(configuration, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, strategyFactory, factory, scriptEvaluatorFactory, traversableResolverResultCacheEnabled ) to the factory?
I see that we don't use the factory on the constructor but I think it would be better to have a createValidatorWithConfiguration(configuration, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, scriptEvaluatorFactory, strategyFactory, factory, scriptEvaluatorFactory, traversableResolverResultCacheEnabled ) in the constructor?
Better use cluster.getRead.
Better to use cluster.getRead.
Better use cluster.getRead
Consider using @SuppressWarnings("unchecked") for all the type safety.
Consider using CopyOnWriteArrayList for consistency, as we do for all the plugins.
Consider using CopyOnWriteArrayList for consistency, as we do for all the threads.
Please add a null check here.
Please add a space after the if
Please add a space after the if condition
I think this needs to be an error.
I think this could be declared private
I think this needs to be return false
These methods are public but you might want to put it in a @Before method
These methods are public but you might want to bring back the @StorageDomain annotation for that.
These lines should be in an else statement.
I don't think we need to do this. What is the value of this method?
I don't think we need to do this. What is the value of this method for?
I don't think we need this if we're setting the default value. What we really want is the default value for BinderPropertyKeys.SYNC_PRODUCER?
.isEmpty( virtualHost) sounds a bit strange in this case.
.isEmpty() is probably better
.isEmpty( virtualHost) would be more robust and more robust.
Looks like the try block is unnecessary here.
Catch Exception instead of the try block
Looks like the try block is unnecessary.
Is it worth providing a complete error message
Is it worth providing a complete error message?
Is it worth providing a complete error message?
The Persister() method is never called. Is it necessary to instantiate a new object here?
The Persister() method is never called.
The Persister() method is never called. Is that intentional?
I think the edit should happen before the affinityGroup is set.
I think the edit should happen before the affinityGroup is initialized.
I think the edit should be done before the "edit" dialog.
suggestion gitSystemConfig = null;
suggestion this.discoverGitSystemConfig());
suggestion gitSystemConfig = new Holder<>();
Multiple method(*) methods
Maybe removing the method("POST") as it is more obvious and detected at this point?
Maybe add an overload to the constructor that accepts a Parameter?
We don't need to do this. The class is not part of the public API, and it's only used in the same package.
We don't need to do this. Just set it in the constructor.
We don't need this method at all. Just set it inline.
.randomInt(1) is a misleading name.
.randomInt(1) is probably not needed.
StaticMethodAccess()?
You should test the null value as well.
You are using unvoidPatient(null) for the null check as well
You are using unvoidPatient(null) as a patient.
I don't think this is right. The release() method should return the remaining buffers, even if the counter is zero.
I don't think this is right. The release() method should return the remaining bytes that are remaining in the release(). (And release() in the background)
I don't think this is right. The release() method should return the remaining bytes that are remaining in the release(). (And release() implies the perf will be less than the default).
This should be return;
This should be return;. It's not a blocker to read.
This should be return;. It's not a blocker to update the object
getNodeStart() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails.
getNodeStart() will return 0 for non-null value. And the assert in the benchmark fails.
getNodeStart() will return 0 for non-null value. Then the assert in the benchmark fails.
You can use here'setHashName(templates.getString(ConstantsManager.getInstance().getConstants().templatesTitle()));
You can use here'setHashName(templates.getConstants().templatesTitle(), this.updateActionAvailability());'
I would suggest using the template id here instead of hardcoding it.
what is the purpose of passing null into the flushIfNeeded?
I think passing null and having the caller is better than null to fail the test.
What is the purpose of passing null into flushPredicate?
Should be externalized.
Wouldn't it be better to externalize the string?
Might be better to externalize the string.
extract into static method. an empty line between the two lines.
extract into static method?
extract into static method.
This looks like a typo, should be 'commit'
This looks like a typo. 'commit' should be 'p'.
This looks like a typo. 'commit' should be 'p'
2 empty lines?
maybe we can use 2 of entries here?
maybe we can use 2 columns here?
No need to have this at all; just return queryStateMap.computeIfAbsent(queryId, state)
No need to use ConcurrentMap.
No need to use ConcurrentMap on the map.
This should be changed to access the mainActivity instead of mainActivity.getSelectedSite().
This should be replaced with the new method call: suggestion if (getActivity() instanceof WPMainActivity) {
We should be able to remove the instanceof check, but the cast to the local variable is no longer necessary.
why do we need this? Can't we just use a lambda expression here?
why do we need this? Can't we just use a String instead?
why do we need this?
Should probably be a method called addMessageSent too.
Should probably be a method with a throws IOException too.
Can you extract a method called validateNoGoalConflictMessage too?
![MAJOR](<LINK_1> Rename this method name to match the regular expression '[a-z][a-zA-0-9]*'. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Rename this method name to match the regular expression '[a-z][a-zA-0-9]*'. [![rule](<LINK_2>](<LINK_1>
There is a Tuple6 constructor which can be used instead of a Tuple6.
Since this method can be used for multiple components, use "default" instead of "log:exeo".
use constant as well
use constant as well.
Can we add a null check here?
Can we add a null check here before returning?
Can we add a null check here before trying to avoid NPE?
Only work if repository.open() is false. In that case, you can use wizard.isConfiguredRepositories(true).
Only work if repository.open() is false. In that case, you can use wizard.isConfiguredRepositories(false) to get the repository.
Only work if repository.open() is false. In that case, you can use wizard.isConfiguredRepositories(false) to get a repo.
And you could just let the exception be thrown (and remove the try block)
And you could just let the exception be thrown (and remove the warning).
And you could just use throws Exception here
use String.format()
use the junit rule of error message on the test too
use String.format and pass a default
If we are changing this to ImmutableSet.of, it would be better to have the Set collector as a constant.
If we are changing this to ImmutableSet.of, it would be better to have a Set collector directly.
If we are changing this to ImmutableSet, it would be better to have the Set collector as a field.
If you use a concurrent map you can use: attestationValues.putIfAbsent(value.getHostName(), value);
If we use a concurrent map you can use: attestationValues.putIfAbsent(value.getHostName(), value);
If you use this method, you can use: attestationValues.putIfAbsent(value.getHostName(), value);
This should be configurable as well
This could be private.
This could be configurable.
Consider to replace with "an allowed command".
How about a method that returns an empty list?
How about a method that returns the allowed command (on the disk content type) that returns a list of DiskContentType?
super. afterConfigureProperties() is missing.
super. afterConfigureProperties() is missing. Also I don't think you need to execute it.
super. afterConfigureProperties() is missing. Also I don't think this is necessary.
The last argument for the constructor is the same as the other one.
You can use the new executor by calling the constructor directly.
The last argument for this constructor should be in the AbstractDataResponseResponseView.
you can probably inline this in the Monitor
this isn't used
you can probably inline this in the Monitor class
Why is this needed?
This is not sufficient. You should invoke GetAllGlusterGeoRepSessions and remove the new query parameters.
This is not sufficient. You should accept user_id and is_filtered as well.
You can just return value!= null right?
You can just return value == null || value == null;
You can just return value == null || value == null.
I don't think we should fix it. It is only done in the launch method, but not in the generator.
I don't think we should fix it. It is only done in the launch method, but not in the core code
I don't think we should fix this
Can't we modify the array style?
Can't we put this in the array so that it will be readable?
Can't we put this in the array so that we have better size?
It's better to update the width of deleteColumn to avoid any confusion. Just to be sure, if there's a reason to do it, and update it in the future we should use GridColumn.
It's better to update the width of deleteColumn to avoid any confusion with deleteColumn method.
It's better to update the width of deleteColumn to avoid any confusion with the table name.
I see you"ve moved'reportsWebappDeployed' but what about'retryCount > MAX_RETRY_COUNTS'?
IMO, it is better to name it'reportsWebappDeployed' rather than 'zip'.
IMO, it is clearer to name it'reportsWebappDeployed' rather than 'zip'.
question: "Authorization token is missed"
question: "Authorization token is not available"
question: "Authorization token is not missed"
public?
Guice best practices: make it public instead of protected.
need to have public
We can use Collections.singleton() to simplify this code.
We can use Collections.singleton() here.
Use ImmutableSet.of() for consistency.
This is cleaner than public.
This does not look right. submission skips skips editing if the thing is in the config, which can be confusing.
This does not look right.
These can be public?
These can be static
These can be public static
Why is this needed?
Since we need to add a new method here, maybe call it election instead of being a void.
Since we need to add a bit more metrics about the event type, can we add a new method like isCurrent?
Can you remove this?
Can you remove this?
Can you use File.format?
Please remove
Please remove cannot be null
Please remove?
could this be channel.getAdvertisedFrom() == null || c.Advertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised() == null || c.getAdvertised().isEqualNow() == null
creep, I think this could be channel.getAdvertisedFrom() == null || creep
creep, I think this could be channel.getAdvertisedFrom() == null || creep.Advertised() == false
I think this is the best place to implement this. if (lockState == null) { return false; } return list.of(lockState, submittedState).contains(chargeStatus);
I think this is the best place to implement this. if (lockState.isInProgress(chargeStatus)) { return true; } else { return false; }
I think this is the best place to implement this. if (lockState.isInProgress(chargeStatus)) { return true; } else return false;
make this constructor private and remove the public
make this constructor private and make it private
make this constructor private
I think your IDE should be able to do this: accountinLineBases.forEach(line -> sb.append(line.toString()));
I think this line should be call sb.append(line.toString()).append('\n');
I think your IDE should be able to do this instead: accountinLineBases.forEach(line -> sb.append(line.toString()));
I'd probably use assertj's assertThat(out).hasSize(2);
I'd probably use something like: assertThat(out).hasSize(2);
I'd probably use assertJ's assertThatThrownBy instead of the one below.
I tend to lean towards the side-effect of an optional. _only_ prefer to have a single value object (like this). If I'm not mistaken, you can remove it.
I tend to lean towards the side-effect of an optional. _only_ prefer to have a single value object (like this).
I tend to lean towards the side-effect of an optional. _only_ prefer to have a single value object (like this). If I'm not mistaken, you can create a default Relation by default.
I think we should use!StringUtils.isEmpty() here.
I think we should make this method private since it's not used outside of this class
I think we should make this method private.
replacing this with helper method would be great
replacing this by helper method would be great
replacing this with helper methods would be great
Again, use IOUtils.
You should use IOUtils.write(), too.
You should use IOUtils.
please use log statement
Please format the test log statements.
Please format the assertion messages.
suggestion processModel.getPubKeyRing(processModel.getTradeManager().requestPersistence()); This should be better.
suggestion processModel.getPubKeyRing(processModel.getTradeManager().requestPersistence());
suggestion processModel.getPubManager().requestPersistence();
Please wrap this in a try/finally, like the other tests.
Please wrap this in a try/catch like the other tests
Please wrap this in a try/catch like the other tests.
should be _1_SECOND_IN_NANOS + 1.
no need to call cancelability_monitor_abbrevUnitSeconds
no need to call.format() on each call to nanos.
Name these please.
Name these! :)
Name these please. :)
Is this the only log level?
Is this the only log message you're referencing?
Is this the only log message you're passing?
Anyway we can use java streams here
Anyway we can use Streams here
Anyway we can use java streams feature
This file does't have any passphrase, instead of null.
This should be Assert.fail() or see if there's no longer a file with none set.
This should be Assert.fail() or see if there's no passphrase with none set.
should this be the dropdownTable? Now that we keep the table.
should this be the dropdownTable? If so, shouldn't this be the dropdownTable?
should this be the dropdownTable? If so, shouldn't this be tested?
QemuVolumeFormat is private, so it can be protected.
QemuVolumeFormat is private, so it can be made private
QemuVolumeFormat is private, so it can be made private.
It would be nice if all partition tasks were included in the toString() method
It would be nice if all partition tasks were included in the toString() method - for example by printing the partition metadata in the metadata.
It would be nice if all partition tasks were included in the toString() method - for example.
I think this should be " '{0}' only, to speak to '{0}'.
I think this should be " '{0}' only, to speak to '{0}'
I think this should be public
isMatrix()? Also what about the row vector case? I've ran in to bugs in the past with subiRowVector being applied to row vector. May want to make this explicit.
isMatrix()? Also what about the row vector case? I've ran in to bugs in the past with subiRowVector being applied to row vector. May want to explain what happened here to verify.
isMatrix()? Also what about the row vector case? I've ran in to bugs in the past with subiRowVector being applied to row vector. May want to explain what exactly this does.
Should be public
Should be INFO
Should be INFO level
Don't think we should do this - [This](<LINK_0> is a good example of how to handle the case when the maxBytes is negative.
Don't think we should suppress the warning here, unify the setMaxModelMemory(long numBytes)
Don't think we should do this - [This](<LINK_0> is a good example of how to handle the case when the buffer is bigger than or equal to zero.
Should be java if (parts.size() == 0) {
Should be java } else if (parts.size() == 0) {
Should be java int first = (parts.size() == 0);
This method isn't public, it doesn't need to be public
This method isn't required, doesn't it?
This method isn't required, it's already public?
Shouldn't we keep the!updateTs?
Shouldn't we keep the!updateTs.isEmpty() check?
Shouldn't we keep the!updateTs??
could be removed?
final?
final
I'm not sure we want to accept a CompletionException here. Maybe we can use [AndGetValue](<LINK_0> here?
I'm not sure we want to accept a CompletionException here. Maybe we can use [AndGetExceptionally](<LINK_0> here?
I'm not sure we want to accept a CompletionException here. Maybe we can use [AndGetExceptionally](<LINK_0> here to be consistent with CompletionException
If we change the default value of getValueAsString we should change this one too.
If we change the default value of getValueAsString we should change it to: public static String getValueAsString(String fieldName, String name) { return StringUtils.format("Telemetry", name), name); }
If you change the default value of getValueAsString you should change this one too.
Why are you using TreeSet with initial capacity?
Why are you using TreeSet with a comparator?
Why are you using TreeSet?
Preconditions.checkArgument() would be better form.
this.randomSeed = randomSeed.;
this.s implicit
I think it is a good idea to have a log.error(message, Throwable).
I think it is a good idea to have log.error(message, e) instead of throwing RuntimeException.
maybe a static log message?
This property should be rePLICATE, not REPLICATE
This is a little weird. The property can't be system properties, if the user has explicitly provided the system property, then it can't parse it. But if the system property is not set, then the method should be called..
This property should be rePLICATE, not REPLICATE.
@NielsCharlier change content of the store to store?
@nvazquez you can put the store not being used with a @Before instead.
@nvazquez you can put the store not in the store
Why do you return an array?
Why do you return an array? Shouldn't it be better to return at least one element?
The "else" branch isn't needed here
Collections.singletonList(String.valueOf(userId))
Collections.singletonList(userId)
asList?
return 0L;
return 0
return 0?
pls substitute these three lines with String.format()
nit: I think you can use String.format(), since you do not need the string concatenation
pls substitute these three lines with {}
This could be replaced with entry.getValue().toString() as well
This could be replaced by Map.forEach() as well
This could be replaced with entry.getValue() as well
Silent failing
I think we should re-throw the IOException for debugging purposes.
StandardCharsets.UTF_8.name()
When using Possibly we should warn that the player has vanilla the max position we're looking for.
When using Possibly we should warn that the player has vanilla the max position we're using in the constructor, and the player has vanillaPosition.
When using Possibly we should warn that the player has vanilla the max position we're using in the constructor.
No need to catch the exception here, it was already done in the overload.
No need to catch the exception here, it was already handled in the overload.
Shouldn't this be in the try block?
why XpathResourceXmlLoader.XmlNode?
can we use xmlLoader.findResourceXml(XpathResourceXmlLoader.class) instead of this XpathResourceXmlLoader?
can we use xmlLoader.findResourceXml(XpathResourceXmlLoader.class) instead of new XmlContext?
if you're going to loop over the same instance multiple times, makes sense to move the linked list outside the loop.
if you're going to loop over the same instance multiple times, makes sense to move the linked list outside the synchronized block.
if you're going to loop over the single instance of handlers, there is no need to re-register them.
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
I'm still confused. Why are you parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an int?
Not sure if the extra space at the beginning is still needed though... Better leave it there and eventually tackle it in a refactor to uniform the isMatching
Not sure if the extra space at the beginning is still needed though... Better leave it there and eventually tackle it in a refactor to uniform the method
Not sure if the extra space at the beginning is still needed though... Better leave it there and eventually tackle it in a refactor to uniform the setUp
:bug: This can be a bit verbose. Can we change the message to: "The expiry queueSize attribute is deprecated and will be removed"
:bug: This can be a bit verbose. The expiry queueSize attribute was deprecated and will be removed.
:bug: This should be: long.
suggestion return "Data Cloud Sign In");
suggestion return "Data Cloud Sign In";
suggestion return "Data Cloud Sign in");
you have to be careful with this test. You shouldn't be testing the Duplicated correlationID :(
same here re: create the correlation id and compare it
removed
TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And TBH I have not thought of a better solution now, but TBH I am concerning (creating an instance of ChannelStateByteBuffer) in question. I think it would be better to have: abstract ChannelStateByteBuffer wrap(byte[] bytes) { return bytes.length - written; } and use that method here.
TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And TBH I have not thought of a better solution now, but TBH I am concerning (creating an instance of ChannelStateByteBuffer) in question. I think it would be better to have: abstract ChannelStateByteBuffer wrap(byte[] bytes) { return bytes.length - written; } And then use putIfAbsent.
TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And TBH I have not thought of a better solution now, but TBH I am concerning (creating an instance of ChannelStateByteBuffer) in question. I think it would be better to have a single instance of ChannelStateByteBuffer and use that method internally.
Minor: For consistency: String content = OBJECT_WRITER.writeValueAsString(offsets);
Minor nit: For consistency: String content = OBJECT_WRITER.writeValueAsString(offsets);
Minor nit: For consistency's sake, it looks like we use FileUtil.writeOffsetString(offsets) here.
Can we make this private?
Can this method be private?
public static?
Fix aliases = aliases =...
Fix aliases =...
Fix aliases = aliases
Should this be removed or the following?
Should this be removed?
This should be removed
let's stick to if (styles!= null) { return true; } for this patch.
let's stick to if (styles!= null) return true;
let's stick to if (styledText.wordWrap || styledText.visualWrap) {... }
suggestion tokenizer.forEachRemaining(e -> {
suggestion tokenizer.forEachRemaining(e -> { throw e; }
nit: it could be more than a check for see failure cause, no?
I'm missing the public API here. It throws NullPointerException if input is null. Can this return null?
I'm missing the public modifier here. It throws NullPointerException if input is null. Can this return null?
I'm missing the public modifier here. It throws NullPointerException if input is null. Can this return null instead?
This is just a whitespace change; do you have a different formatter?
This is just a whitespace change; do we have a different formatter?
This is just a whitespace change; do a different formatter.
We don't need to put this into lock.
We don't need to put this into lock if it's only a single lock.
We don't need to put this into lock if it's only a single operation.
From discussion above, would probably be good to imply VmSettings.MESSAGE_TIMESTAMPS. (same in VmSettings.MESSAGE_TIMESTAMPS below)
could we solve this by overriding send() in the TracingActor? I'd like if you made send() a member and then call super.send() in that case.
From discussion above, would probably be good to imply VmSettings.MESSAGE_TIMESTAMPS. (same in VmSettings.MESSAGE_TIMESTAMPS) since it's STS
Is it possible to make this a constant in a class?
Is it possible to make this a constant in a generic way?
Is it possible to make this a constant in a future version?
setChecked(mPlugin.isAutoUpdateEnabled());
setChecked(mPlugin.isAutoUpdateEnabled())
Needs to be in  shared state.
Have you considered using CacheQuery::getDefaultQueryTimeout instead?
Have you considered using CacheQuery::getDefaultQueryTimeout instead of this logic? Because in cases where we have a DefaultQueryImpl with an default timeout.
Have you considered using CacheQuery::getDefaultQueryTimeout instead of this logic? Because in cases where we have a DefaultQueryImpl with an max timeout.
The ID is used to restore old files (from an older release) so this must not be changed!
The ID is used to restore old files (from an older release) so this must no longer be changed!
The ID is used to restore old files(from an older release) so this must not be changed!
@amihaiemil the path to "rest/novnc.html" is a little more appropriate. Let's move this to a constant.
@amihaiemil the path should be in the properties file
@NielsCharlier great opportunity to include the URL in the properties file
Try string.format()
Try file.separator
Try file.separator.
len is unnecessary variable name
len is not used
len is not used anywhere
I don't think we need this lambda at all. WDYT?
I don't think we need this kind of refactoring anymore.
I don't think we need this lambda at all.
String.valueOf()
String filePath() is private, so it can be called filePath()
String filePath() {
This should be a separate method, shouldn't it?
This should be a private method, and only called in the AddNetworkCommand.
This should be a private method, and only called from canDoAction inside this class.
Can you move this into a private method?
Can you move this into the public method?
Can you move this into setCreateOutputDirectory()?
this message should be moved to the service implementation, and not from the service implementation
There is a new error message: 1. In this case, we should include frameIndex 2. Why not just return Promises.reject(JsPromiseInfo.class, frameIndex);
this message should be a constant, and not a reference to it
This isn't used anywhere?
Do we need to return a completed map here?
This isn't used anywhere.
Can you please remove this?
Can you please remove sysout.
Can you please remove it?
As I think I mentioned previously, we should use the String.format only on most users than toString() on most users than just calling it twice on most users than we wants to call it twice on most users. Probably drop toString and add a new line.
As I think I mentioned previously, we should go through the String.format only once here.
As I think I mentioned previously, we should use the String.format only on most users than toString() on most users than just calling it twice on most users than we wants to call it twice on most users. Probably drop toString and add a new line?
not sure if this will change in the future, but perhaps it is better to use the real size of the list directly instead of the real size
not sure if this will change in the real code base, but perhaps it is better to use the new ArrayList<>(justificationList); here?
not sure if this will change in the future, but perhaps it is better to use the real size of the list directly instead of just the ArrayList
@fanifieiev the same above.
@fanifieiev methodAndHeaders
@fanifieiev methodAndConstructor
I'm not sure if this is going to be a problem. We should probably throw an exception here.
I'm pretty sure we don't need to writeTo(bb) as it's going to write from a different channel.
I'm not sure if this is going to be a problem. We should probably throw an exception here instead.
Should this be merging with the one above?
Should this be2?
Should this be merging with the one below?
requireNonNull
assignment can be removed
assignment is wrong here
This will fail if sizes is empty
This will throw an exception if sizes is null
This will fail if sizes is empty.
we can do away with the "ms" @Test method. we can do this in a single test method
we can do away with the "ms" @Test method. we can do this same way
we can do away with the "ms" @Test method. we can do this in a follow up patch
Suggestion: why do you need this.state = defaultState?
Redundant, please remove
Suggestion: move this to private
Hey @dgutierr, I think this won't work as expected because this line doesn't look like an if statement. The call to getUsage() is non-null. This line could be simplified as return state.currentView.get(owner);
Hey @dgutierr, I think this won't work as expected because this line doesn't look like an if statement. The call to getUsage() is non-null, so the cache can be used.
Hey @dgutierr, I think this won't work as expected because this line doesn't look like an if statement. The call to getUsage() on the currentView is inefficient.
This doesn't need to be a separate PR, so would it be possible to use pgStartupWait?
This no longer needs to be a global variable, so the parameter can be removed.
This no longer needs to be a separate commit.
maybe you can use TimeUnit.SECONDS.toMillis(timeoutInMillis)
maybe you can use TimeUnit.MILLISECONDS.sleep?
maybe you can use TimeUnit.SECONDS.sleep(500); instead?
please replace the lines of order 237/238. also, please export this entire block to a function to ease the read here. thanks.
please replace the lines of order 237/238. also, please export this entire method to a function to ease the read here. thanks.
please replace the lines of order 237/238. also, please export this entire block to a function to ease the read here. thanks
I think you should check that UnifiedPushArchive contains the provided MessageHolderWithVariantsProducer (and theVariantsProducer) instead of the hard coded string.
I think you should check that UnifiedPushArchive contains the provided MessageHolderWithVariantsProducer (and the RST file should be moved to the end of the file).
I think you should check that UnifiedPushArchive contains the provided MessageHolderWithVariantsProducer (and the RST file should be moved to the base class as well).
I understand that PromiseComibner() constructor is deprecated, maybe we could extract this as a method and do isDone() method? Then we will not need to construct this class, and if someone will need to construct this class, he could call this method that encapsulates the logic?
I understand that PromiseComibner() constructor is deprecated, maybe we could extract this as a method and do isDone() method that encapsulates the logic?
maybe we could extract this as a method and do isDone() method?
please use getDbFacade()
please use getDbFacade() @Inject for this
please use getDbFacade() @Inject for this.
if we do not want to do it, why do you need to check for null?
if we do not want to do it, why do you need all the null checks?
if we do not want to do it, why do we need all the null checks?
@Serranya Maybe use StandardCharsets.UTF_8 instead?
@Serranya same here. Maybe this method can be public?
@Serranya same here. Maybe use utf8.getBytes()?
@prahladyeri We can declare the try-with-resources block at the end of the method.
@prahladyeri We can move the try-catch block in the next line.
@prahladyeri We can declare the try-with-resources block at the end of this method.
Don't catch Exception, it is safe to catch both Error and Exception
Don't catch Exception, it's better to catch Throwable and log it
Fix code. The exception will be logged.
I think this should be package-private if it is only used by the test.
I think this should be package-private if it is only used by the Guice injector.
Is there a reason to use computeIfAbsent instead of a synchronized set?
Doesn't this call getSchema()?
Doesn't it make sense to return null or empty schema?
Doesn't it make sense to call getSchema() here?
This is a clear programming error, right? If so, suggest throwing NPE instead.
This is a bad idea, since this would return null.
This is a bad idea, since this would NPE.
If you are using this on line 94, it will be safer to check if the string is empty rather than NPE.
If you are using this on line 94, it will be safer to check that indicativeSentencesGeneration.get().separator() == "".
If you are using this on line 94, it will be safer to check that indicativeSentencesGeneration.get().separator() == null.
![MAJOR](<LINK_0> 'Severity: MAJOR') Change this condition so that it does not always evaluate to "false" [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> 'Severity: MAJOR') Change this condition so that it does not always evaluate to "false" [![rule](<LINK_2>](<LINK_0>
![INFO](<LINK_0> 'Severity: INFO') Change this comparison to use the standard syntax '![rule](<LINK_1>](<LINK_2>
nit: formatting.
nit: formatting is off
final?
suggestion.withLastName(lastName)
Even though it's not a big deal, you may just inline the builder.
suggestion
Don't log and throw.
You should not log and throw.
You should not log and throw. I believe there is no need to log the exception.
Why does this method need to be public?
Why does this have to be public?
Why does this have to be super.onBase?
nit: Promoting..
nit: I would rename this to shadowPromoting.
nit: I would rename this to nonUserOnPrimaryItem.
Please throw exception if! nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN.
Please throw exception if! nameLookupPossibleInAdvance(), but getValueCardinality() returns something non-negative.
Please throw NullableAggregatorFactory.
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
There is a weird inconsistency. Sometimes you start the CR with a capital letter, sometimes not.
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not before the 'un'
The string "tooltip.bloodmagic.currentOwner" should be a constant, like "tooltip.bloodmagic.currentOwner".
I don't think it's necessary to check whether the binding is null. This will cause a NPE if it is.
I don't think it's necessary to check whether the binding is null. This will cause a NPE if it is not already present.
I think this could be removed. See above.
I think this could be removed. See fLINK_0>
I'd prefer to have an explicit check that it's valid for an empty string.
Rebase error - should be used Helper.getCurrentUser.
Rebase error - should be used Helper.getCurrentUser().
Rebase error - should be used Helper.getCurrentUser....
Please add curly braces
Please add curly braces.
good.
You can call the super constructor like this(null, value, Keys.ENTITY_HAS_GRAVITY, SpongeGravityData.class, value);
You can use the Keys.ENTITY_HAS_GRAVITY here as well
You can call the super constructor like this(null, value, Keys.ENTITY_HAS_GRAVITY, SpongeGdata.class, value);
This is a debug statement that should be logged.
This is a copy&paste error, this should be debug.
This is a copy&paste error, please remove
when is this call necessary?
when is it needed?
when is this call necessary?
Take a look at <LINK_0>
Take care of this removal from <LINK_0>
Take care of this removal of the namespace.
Needs to be protected.
Suggest using DoubleArray.copyOf(...
Suggest using DoubleArray.of(...
Why synchronize on an operatorMemoryContext?
Why synchronize on an operatorMemoryContext here?
Why synchronize on an operatorMemory?
don't need the type on RHS
This method should be private.
don't need the type parameter
Wrap this line
Make this an error log and throw it just in case.
Make this an error log.
I think this should be: return Objects.equal(name, role.name);
I think this is wrong. Role role = (Role) o;
I think this should be hashcode, right?
Also not thread safe, but why not just use an AtomicBoolean instead?
Also not on the setter. Why not just make singleton() an instance instead?
Is that change to only have the usage of the getter method?
This can be private.
this can be private
This should be private.
I'm not sure what is the purpose of this while loop.
I'm not sure it is good for now, but wouldn't it be good to give a list of bitmaps with this size?
I'm not sure it is good for now, but wouldn't it be good to give this variable name?
I would fall back to this off. I mean this would fall into the off-chance that I mean.
I guess this would fall into the if block below in.
I would fall back to this off the line above this. in.close();
is it better to use RandomUtils with RandomUtilsSeedingRule?
If it's possible to use RandomUtils with RandomUtilsSeedingRule
If it's empty, is it better to use RandomUtils with RandomUtils?
Why not just return boolean?
Scares me this does not seem to be necessary.
Scares me this does not seem to be necessary. Would be nice to return boolean here.
So why not throw an UnsupportedOperationException instead? As in why not wrap in RuntimeException, but not in RuntimeException.
So why not throw an UnsupportedOperationException instead? As in why not wrap in RuntimeException, but not in the constructor
So why not throw an UnsupportedOperationException instead?
would be good to have a test for this
would be good to have a message here
would be good to have a more meaningful exception here
Hmmm... is this a little strange to me? The return value is not null. Why not return!...?
Hmmm... is this a little strange to me? The return value is not null. Why not return!SwrveHelper.isNullOrEmpty(msgId)?
Hmmm... is this a little strange to me? The return value of get is null?
Looks better to use ExpectedException.
As for the sake of test readability, I suggest using assertj.
Looks better to use LOG.debug
This is a bug, but I think that the projection.keySet() can never be null.
This is a style thing, but I think that the projection.keySet() can never be null.
This is a bug, but I think that the projection.keySet() can't change after the comparison.
this.nameResolver = requireNonNull(nameResolver, "nameResolver is null");
s/nameResolver is null/empty()
s/nameResolver is null/empty()/
This should have a test case for the TestClassWithConfigFailureSample
This params are missing the values above.
This params are missing length
This is not correct. The storeFence() method should be able to acquire the lock. It should be like this: java final long s = (s & EXL_MASK)!= 0; boolean unwritablyLocked = (s & CNT_MASK) == CNT_MASK; return failWriteLock( s, writeCountOverflow );
this is not correct.
This is not correct.
you should use shutdownNow() here
you should use shutdownNow()
you should use BeforeMethodOrder.remove() here
Unnecessary @Override
contract should be public
Unnecessary public
What is the use of this one?
What is the use of stringValue() in the message?
What is the use of.getproviderType()?
Why do we need this wait?
Why do we need to wait for it?
Why sometimes and sometimes return true?
RocksUtils.createIterator already
Utils.getMutable?
Suggest using an immutable list here
Remove the "throws" annotation.
Remove the "throws" warning here.
Remove the public modifier?
If I understand correctly, this test is no more used. So why keeping it?
If I understand correctly, this test is no more used. So why keeping "null" here?
If I understand correctly, this test is no more used. So why keeping "null" as a result?
I know this method is only used in this class, but perhaps it can be moved to private?
I know this method is only used in this class, but perhaps it could be moved to private?
I know this isn't related to this PR, but looking at this method, perhaps it can be moved to private?
"#" + link is always evaluated when its a directory?
"#" + link is always evaluated when its a constant?
"#" + link is always final?
Read this into a try-with-resource block? We might want to close it in a finally block.
Read this into a try-with-resource block? It might be a bit less readable to just read the file stream once.
Read this into a try-with-resource block? It might be a bit less error prone to read the file stream once.
If the selection is empty, shouldn't we clear the selection before?
If the selection is empty, the setup won't be called.
change to debug
here we can test if the level is more than one level to test.
here we can test if the level is "CPE" instead of CPE.
here we can test if the level is more than one level to test?
Please use URIBuilderFrom(uriBase).appendPath(String.valueOf(token))
Please use URIBuilder instead of String.valueOf(token)
Please use URIBuilder instead of String.valueOf(token).
Same as above, why do we need this?
Same as above. Also, why do we need this?
Same as above. Also, why do we need separate constants?
I would prefer to have more explicit name than tester = new RuleTester(); I know other tests do that better.
I would call the other constructor with RuleTester.
I would prefer to have more explicit name than tester.
It's a good idea to add a default value as FieldType.OBJECT.
It's a good idea to add a default value as FieldType.OBJECT to use here.
Need to add name; default value
I think this is a good idea to wrap the original set in Collections.unmodifiableSet in a new HashSet every time we get a new one.
I think this is a good idea to wrap the original set in a Collections.unmodifiableSet might be a bit cheaper
I don't think this is a good idea to return a set from a set. We do not want to modify the set anywhere, and then immediately return it
Shouldn't we use map to the leaseDuration?
Shouldn't we use map to the ConfigChangeHandlerManager?
Shouldn't we use map to the lease duration too?
I think we should also check that the commit cursor is not created in this case.
I think we should also check that the commit cursor is not successful.
I think we should also check that the commit cursor is not created in case the current page is not created
Add Assert.notNull()
Add Assert.assertTrue()
Assert.notNull
Is this method public?
Is this class public?
Is this method called to make sure that it was not null?
Should be GuidOr404(id)
Should invoke GuidOr404(id)
Should be Guid or404(id)
Replace with.toLowerCase
Replace with  Locale.ENGLISH
Replace with Char.toLowerCase
nit: you don't need this, you can use == instead of bitwise
nit: you don't need this, and you can inline this.
nit: you don't need this, you can use == instead of ||
use rewrite than get
use rewrite than get()
use rewrite than get to avoid casting?
The s is consistentHashChangeListener, but as a constant, you could probably put s in the method name.
The s is consistentHashChangeListener, but should probably be t -> true to avoid such confusion.
The s is consistentHashChangeListener, but as a constant, you could probably put s in the constructor.
It's better to change this to: return startCommit.equals(other.numbers, other.numbers);
It's better to change this to return true.
It's better to change this.
please add timeout to this timeout
please add timeout to this line
It would be nice to add an assertion here that would be set.
Can you try to use a static import for Matchers?
Can you try to use Tv.THREE instead of Tv.
Can you try to use Tv.THREE here instead of hardcoding true?
This should actually check if the convergence actually has one, right?
Should check the number of characters, defined at the beginning of the exception.
Should check the number of characters, defined at the beginning of the exception too
This method should probably be static
this method should probably be static
this method should probably be public.
You can easily use value.replace(" ", "") for the esotuitization.
You can strip the leading and trailing whitespace by using the StringBuilder constructor.
Please change to spaces.
Please change this to public void enableButtons() { reviewImageFragments[0].enableButtons(); }
Please change this to public void enableButtons() {
Please change public to void enableButtons() {
optional: consider adding this(itemType, itemType) to the constructor
optional: consider adding this qualifier
optional: consider adding this(itemType, label);
Collections.emptyList()
Collections.emptyList();
Collections.emptyList?
Can you call this 'this' here? <LINK_0> Thanks!
Can you call this 'this' here?
Can you call this 'this' here? <LINK_0>
I think this should be private
I think this should be package private
I think this should be package-private
I would rather use a 'a', since the value can't be null.
I would rather use a 'a', since the value can't be null
I would rather use a 'a' variable
It should be new TajoRuntimeException(new InvalidCastException(...).
It should be new TajoRuntimeException(new UnsupportedException(...).
It should be new TajoRuntimeException(new InvalidCastException(...);.
Add method with these params as argument and remove the params
Add method with these params as parameter.
Argument validation
Also not comfortable with this.
Also properties are assigned to a field.
Also not sure about this.
Use Assert.assertEquals
Use Assert.assertEquals instead.
Do we need to check the content of the message.
This is using a StringBuilder, which is inefficient. Can you just use append("(type: ) and compare it with.append(verify())?
This is using a StringBuilder, which is inefficient. Can you just use append("(type: ") and compare it with.append(verify())?
This is using a StringBuilder, which is inefficient. Can you just use append("(type: ") and compare it with.append(verify())?
unused
unused or remove
unused or removed
@szczepiq Would you mind using double.hashCode() here instead of new Double(this.resolution).hashCode()? I don't think it's a good idea to keep annotations on their own.
@szczepiq Would you mind using double.hashCode() here instead of new Double(this.resolution).hashCode()?
this is the same I think
Please don't use System.out.println, a logger should be used instead.
Please don't use System.out.println, a logger should be removed.
Remove this.
Add PageObjectLogging.log(Messages.DEVICE_NOT_FOUND, "Page void waitAndDismissAlertModal")
Add PageObjectLogging.log(Messages.DEVICE_NOT_FOUND, "Session did not exist.");
Add PageObjectLogging.log(Messages.DEVICE_NOT_FOUND, "Page void waitAndDismissAlertModal");
Instead of calling updateTrack, wouldn't it be better to call the updateTrack() method of type ChangeListener?
Instead of calling updateTrack, wouldn't it be better to call the updateTrack() method of type AbstractTrack to override the toString method?
Instead of calling updateTrack, wouldn't it be better to call the updateTrack() method of type AbstractTrack to override the toString() method?
nitpick: no braces around single line statements
nit-pick: no braces
Is this bit necessary?
If the request is null, do we need to check for null?
If the request is null, do we need to check if (request!= null)
If the request is already null, do we need to check for null?
I guess you mean to pass Kryo.clone() here?
I guess you mean to pass Kryo.clone() here.
I guess you mean to pass Kryo.CloneUtils<SRC> in this constructor.
Seems to be the wrong value, we should also check the value of the project.
Seems to be the wrong value to use here, I would keep it the same value.
Seems to be the wrong value, we should check for the value of the project.
is there a way to avoid this duplication? (i.e., with 30 secs, ActiveMQWebLogger.LOGGER.jolokiaAvailable(consoleUrl) would be more appropriate.
is there a way to avoid this duplication? (i.e., with 30 secs, ActiveMQWebLogger.LOGGER.jolokiaAvailable(consoleUrl)) should take care of it
is there a way to avoid this duplication? (i.e., with 30 seconds or so)
Should this not be done in store(entity)?
Should this not be done in store()?
Should this not be done in store(entity)?
nit: return policy!= null? policyEntity.fromServicePolicy(policy) : ServicePolicyEntity.fromServicePolicy(policy);
nit: return policy!= null? policyEntity.fromServicePolicy(policy) : null;
nit: return policy!= null? policyEntity.fromServicePolicy(policy) : ServicePolicyEntity.fromServicePolicy(policy)
You can use getRight
Can you move this up to a separate line, please?
Can you move this up to getRight
As above, you should update this test to use that concept name constants.
As above, you should use conceptName instead of conceptName
As above, you can use conceptName instead of label
Oops, this is not needed
Oops.
Oops
Just a small nitpick. I think we could just use Void.class.getName() at the end of the test.
Just a small nitpick. I think we could just use a single "host" instead of "Location". What do you think? :)
Just a small nitpick. I think we could just use Void.class.getName() at the end of a test.
check for null
please use StringAssert as well
use static import
Global listener catch each click. You don't need to log it.
Global listener catch each click. You don't need to add it.
waitForElementNotPresent(saveButtonDisabled);
This method is private and is not necessary to make it public.
Minor nit: This method is private so you could call the static method.
This method is private and is not used outside.
Doesn't this generate an error? Here you're changing the implementation of SetViewportToSizeOf.
Doesn't this make an extra copy?
Doesn't this generate an error? Here we're changing the implementation of SetViewportToSizeOf.
@anuraaga this is the only reason we use the ChunkProvider and not the ChunkProvider.
@anuraaga this is the only reason we use the ChunkProvider and not the ChunkProvider?
@anuraaga this is the only place where we use the ChunkProvider is not available
The order of the arguments is reversed - it should be assertEquals("Test_123", result);
The order of the arguments is reversed - this should be assertEquals("Test_123", result);
The order of the arguments is reversed - it should be assertEquals("Test_123", result);.
As discussed, I think there should be a check on fOutputs.add()
As discussed, I think there should be a check on fOutputs and call super.add()
As discussed, I think there should be an @Override
This method is no longer meant to return null.
This method is still returning null.
This method is not really correct. If an internal method is supposed to return null, the internal method is protected.
Same question about unit conversion as earlier.
See above about unit conversion as unit.
See above, IMO this should have return units.
I don't think we want this default. This should just default to 1.
I don't think we want this default. This should just be doesPropertyMatch(MARKDOWN_ENABLED, BuildConfig.DEBUG) The default values are set in doesPropertyMatch().
I don't think we want this default. This should just be doesPropertyMatch(MARKDOWN_ENABLED, BuildConfig.DEBUG)
style nit: no braces around single line blocks
style nit: we don't use curly braces around single line blocks
style nit: we don't use braces around single line blocks
The parameter can bee removed
That's going to be weird anymore and can bee removed
That's going to be weird anymore and can be removed
Why are you not using just "tagContext"?
What's the purpose of this change?
Why are you not using just "tagContext" instead of "tagContext"?
I think this should return streams.stream().map(StreamService::findAllRepositories).collect(Collectors.toList())
I think this should return streams.stream().map(ss -> ss.findAllRepositories()).collect(Collectors.toList())
I think this should return an immutable list.
validate()
validate method
validate()?
Please make this private
Please make it private
Please make this private.
That's an unnecessary import
Name profile is optional
That's an unnecessary cast
I don't think this makes a lot of pandle sloppy. Maybe we should just show the capabilty?
I don't think this makes a lot of pandle sloppy. Maybe we could try and avoid this in the middle of the list.
I don't think this makes a lot of pandle sloppy. Maybe we could try and avoid this in the middle of a list.
Same here, context can be null.
Same here, one liner can be switched to one line.
Same here, one liner can be fine.
I'd change this to job == null || jobName.compareTo("dynamic")
I'd change this to job == null || jobName.equals("dynamic")
I'd want to change this to job.getClass().equals("dynamic")
Please add braces to the if, even if it's a single line
Please add curly braces to the if statement.
Please add braces to the if, even if it's a single line.
concat empty str?
concatempty str?
concat empty str
@jomarko we should also check that the result of invoking afterPropertiesSet() is not null.
We should be able to use org.junit.Assert#assertArrayEquals here or in other places.
@jomarko we can inline this variable.
This should be "bepson"
I would change this to be "bepson"
This should be getName
These 3 lines are same.
Sorry, just noticed this as a switch statement right? So the ChargeDialogFragment implementation is not right? Aside from that, awesome idea!
Sorry, just noticed this as a switch statement right? So the ChargeDialogFragment class is type-safe, right? So we'll need to use the same code as the other places?
static import?
static import
externalize error message
Can you please make this method private? It is only used by AddVmCommand.
Can this be private? It seems to me like a generic method, but I wouldn't care about this.
Can you please make this method private? It is only used by AddVmCommand.java
The exception also needs to be modified a bit.
Based on <LINK_0>, we should name groupName as " groupName" and jobName to be "group name".
The exception also needs to be caught and logged.
To avoid duplicate code, can you create a separate method to get the metric and compare with the filter?
To avoid duplicate code, can you create a separate method to get the metric and compare with the given metric?
To avoid duplicate code, can you create a separate method to get the metric and compare with the given formatter?
<code>else</code>
<code>else</code> should be changed to private
Volumed of error here
No need to catch the exception here, it was already public.
No need to catch the exception here, it was already public
No need for try/catch here.
unnecessary change
unnecessary changes
unnecessary change.
suggestion return float.MAX_VALUE;
suggestion return 0L;
-1 is better, because it is bad input.
Can we add another method for this logic? int mobileNavbarHeight = -1 * driver.findElement(F2_MOBILE_BAR).getSize().getHeight();
Can we use [this](<LINK_0> instead?
Can we add another method for this in the PR?
This isn't quite right. If key's can't be blank, then it should return false. I'd prefer to have a dedicated check for null and the call to isBlank
This isn't quite right. If key's can't be blank, then it should return false. I'd prefer to have a dedicated check for that.
Map.Entry::getKey
externalize
setXmlFile here
externalize?
getBytes(Charset.forName("UTF-8")?
getBytes(Charset.US_ASCII)
getBytes(Charset.forName("UTF-8"))
Need to refresh the view when the addFilter() call below fails
This should be NonNullByDefault, there is no need to check
Need to refresh the view before setting the pattern.
getCurrentUserLogin() should return null if the userLogin is not authenticated.
getCurrentUserLogin() should return null if the userLogin is null.
getCurrentUserLogin() should return null if the userLogin is not authenticated. Is that intentional?
This doesn't work. Parameters that are initialized using the value set in the RecordsRetrieved type. I'm not sure why we need to wrap this with optional.
This doesn't work. Parameters that are initialized using the value set in the RecordsRetrieved type. So I'm not sure why we need to wrap this with optional.
This doesn't work. Parameters that are initialized using the value set in the RecordsRetrieved type. I'd prefer not doing that.
I'm not sure if this should be public.
I'm guessing this should be pulled out of the public methods. Does it make sense?
This method is probably not public.
It would be more efficient to do sdf.format(new Date(timeStampMillis)). Also do a double check on the last saved time.
It would be more efficient to do sdf.format(new Date(timeStampMillis)). Also do a double check on the return value.
It would be more efficient to do sdf.format(new Date(timeStampMillis)). Also do a double check that the last timestamp is UTC.
use try with resources?
use try-with-resources
use try with resources
Maybe we should add a checkNotNull() here?
Maybe we should add a checkNotNull() here to make sure the parameter is not null
Maybe we should add a checkNotNull() here to prevent NPEs?
why is this line necessary?
why is this line needed?
perhaps we can use path separator here like at: /
There seem to be different message. Like this one: %s cannot be removed from %s totally"
There seem to be different message. Like this one: %s cannot be removed from the group.
There should be different message.
i'm not sure, but do you think it is better to use next() in the DeltaVisit too? This is because next() is not a part of the original DeltaVisit.
i'm not sure, but do you think it is better to use next() in the DeltaVisit too? This is because next() is not a part of the DeltaVisit.
i'm not sure, but do you think it is better to use next() in the DeltaVisit too? This is because next() is not a part of the public DeltaVisit.
Please add braces
why does this check for null?
why can't you replace.contains with booleanValue()
Instead of logging SonarQubeServerException here, why not log it at trace level? (If we don't log anything at debug, I don't know)
Instead of logging SonarQubeServerException here, why not log it at trace level? (If we don't log anything at all)
Instead of logging SonarQubeServerException here, why not log it at trace level? (If we don't log anything at debug, this would be less useful)
I think this is an error.
I don't think this is a good idea. You should be able to create a factory method for this.
I don't think we need this log.
So this is incorrect because we have size() in it? I think this is incorrect because we copy-and-paste the contents of the students.
So this is incorrect because we have size() in it?
So this is incorrect because we have size() in it? I think this is incorrect because we copy-and-paste the contents of the set.
Can we revert back to ArgumentPreparedStatementSetter since OAuth2 is an object.
Can we revert back to ArgumentPreparedStatementSetter since OAuth2 is the only way to do spring serialization?
Can we revert back to ArgumentPreparedStatementSetter since OAuth2 is the only way to do spring save operations.
Same note as above.
Same note as above about PaddingLeft() and extraHorizontalHorizontal().
Same note as above about PaddingLeft() and extraHorizontalHorizontal.
I might have been confused, but shouldn't we have a new handleNewSession method that takes a boolean as parameter?
I might have been confused, but shouldn't we have a new handleNewSession method that takes a boolean and calls createLiveInstance?
I might have been confused, but shouldn't we have a new handleNewSession method that takes a boolean and calls the callback?
no need for == false
no need to compare storage domain here.
no need to compare storage domain here also.
This should be email, not email.
This should be email, not email
This should be email, not email anymore
Still worth using Map<String, Object> commandParameters = Collections.singletonMap(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
Still worth using Map<String, Object> commandParameters = Collections.singletonMap(); commandParameters.put(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
Still worth using emptyMap as commandParameters is Collections.singletonMap()
please make sure you are rebased.
Can be static
please make sure static
process the reports availability as in LoginModel. Is the setup not necessary?
process the reports availability as in LoginModel. is the setup not supported by the system?
process the reports availability as in LoginModel. Is it not possible to disable the setup from here?
Missing "intent cannot be null"
Missing "intent may not be null"
Missing "intent must not be null"
avoid using magic numbers.
one param per line.
one param per line
nit: can be chained onto previous line's assertion
nit: can be chained to assertThat(hunter.actions).hasSize(1)
nit: can be chained to assertThat(hunter.actions).hasSize(1);
Passivate is never null, it's always created by EmptyConstructorNamedCacheFactory. True, it may not be created if the Passivate is null or empty.
Passivate is never null, it's always created by EmptyConstructorNamedCacheFactory. True, it may not be created if the Passivate is not null.
Passivate is never null, it's always created by EmptyConstructorNamedCacheFactory. True, it may not be created if no CompletionStage is found for a null entry.
You should do'return'here' or 'public'.
You should do'return'here.
You should do'return'here
this is confusing. We should only replace the table name, and not the NAMESPACE
this is confusing. We should only replace the commit message if it says "write failed"
this can be static
remove return statement and just return!tuples.isEmpty();
remove return... just return!tuples.isEmpty();
remove return... just return... is it?
This seems like an unnecessary change, if the property is null it will be overwritten in the another constructor.
This seems like an unnecessary change, if the property is null it will be overwritten in the other constructor.
This seems like an error.
Shouldn't we add the Mapping: itemName = 'itemName'?
Shouldn't we add the property to the log?
Shouldn't we add the Mapping: itemName = {}"?
Why do you need the call to resendLatestResourcePackRequest()?
Why do you need the connection when you sendLatestResourcePackRequest?
Is this necessary?
Should this be public? If createNotificationChannel is called by the other constructor, then we could override the createNotificationChannel() method and put the channel creation outside the factory.
Should this be public? If createNotificationChannel is called by the other constructor, then we could override the createNotificationChannel method and put the channel creation outside the factory.
Should this be public?
You need to add fileToTar to the caller of addFileToTar method as it is alway public void addFileToTar(tarArchiveOutputStream, File file, String path) throws IOException {
You need to add fileToTar to the caller of addFileToTar method as it is alway public void addFileToTar(byte[] export, String name) throws IOException {
You need to add fileToTar to the caller of addFileToTar method as an example: <LINK_0>
It should be entry.setAuthor(null)
It should be like entry.setAuthor(null)
It should be like entry.setAuthor(null).
Not sure if this is the right place to call replyText(null, res, msg). On the other hand, it looks like replyText(null, res, msg) is null, which will cause a memory leak.
Not sure if this is the right place to call replyText(null, res, msg). On the other hand, it looks like replyText(null, res, msg) is null, which will cause a NPE.
Not sure if this is the right place to call replyText(null, res, msg). On the other hand, it looks like replyText(null, res, msg).setNotCacheable(res); should be enough.
I think we might want to check the exception message here. This may be useful to quickly see an example of what you had: @Test(expected = IllegalArgumentException.class) public void testResetMessage(String principal) throws Exception { String principal = "invalid_type_true"; try { resolver.resolveArgument(principal, null, null, null); fail("should not reach here"); } catch (ClassCastException ex) { } } I think the name of the test is slightly more clear.
I think we might want to check the exception message here. This may be useful to quickly see an example of what you had: @Test(expected = IllegalArgumentException.class)
I think we might want to check the exception message here. This may be useful to quickly see an example of what you had: @Test(expected = ClassCastException.class)
style nit: no braces for method name
Unnecessary exception message.
Can be reverted
@aschworer why this is necessary?
@aschworer why this empty line is necessary?
@topicResaRi
How about move beginTransaction method inside the transaction? I think it'll simplify the code
How about move beginTransaction method inside the transaction and then return the current object? This way we can at least add a call to setBookmark method and then we can just call the method from here.
How about move beginTransaction method inside the transaction and then return the current object? This way we can at least add a call to setBookmark method and then we can get the current object from the transaction.
...Don't remove this. We catch and handle IOException later down the line, we don't handle NullPointerExceptions however.
...Don't handle this. We catch and handle IOException later down the line, we don't handle NullPointerExceptions however.
...Don't catch and handle NullPointerExceptions however.
I believe the right way to do this was: checkExp("json_type('foo\":\"bar\"}')", "VARCHAR(20) NOT NULL");
I believe the right way to do it is: checkExp("json_type('foo\":\"bar\"}')", "VARCHAR(20) NOT NULL");
I believe the right way to do this was: checkExp("json_type('foo\":\"bar\"}')", "VARCHAR(20) NOT NULL")
Why is this needed?
I would move this to a separate method.
I would move this to <LINK_0>
Arrange, act, assert. java public T  train() { return 1; }
Ternary operator
Arrange, act, hasRequest(ByteBuffer)
Can this be made more clear to have if (isWeekend(date)) return false;
Can this be made more clear to have if (StringUtils.isNotEmpty(date)) return false;
Can you make this more succinctly more readable?
Why does the one above need to be public?
Why does this need to be public?
Why does the one above need to be protected?
@dalifreire here you could just drop the instanceof check, but use our equals method instead
@dalifreire here you could drop the cast to byte[] -> String and send to ByteArraySerializer
How about making the method final?
I see that we synchronize on this method... If we really need to do this in #get(), could we synchronize on this only. But I think it is harmless to have a concurrency issue that logs out.
I think we can use synchronized instead of synchronized.
I think we can call namespace == null
I am not sure why this string concatenation is needed.
I am not sure why this string concatenation is needed. If you add it in the StringBuilder then append it to a query string, it will be more robust.
I am not sure why this string concatenation is used here.
I would prefer something like this: throw new JUnitException(String.format("Failed to convert configuration parameter with key '%s' for input: %s", key, input));
I would prefer something like this: throw new JUnitException(String.format("Failed to convert configuration parameter with input '%s' for input: %s", key, input));
I would prefer something similar to the JUnitExceptionMapper in org.apache.commons.lang.exception.ExecutionExceptionUtils to wrap the original exception.
Was this change intended?
Was this method intentionally left out of the old version?
Was this method intentionally left out of the new cast?
I would prefer to keep this method non-static and make it private.
I would prefer to keep this method non-static and remove the public modifier.
I would prefer to keep the Objects.toString(content, null) into java parameter.
can't we use CollectionUtils.isEmpty?
can't we use toStringHelper?
can't we use CollectionUtils.isEmpty()?
is this related to this PR? or am I missing something?
is this related to the sync client?
is this related to the synchrno?
Can we delete the view like this?
Can we remove this kind of thing and make it private?
Can we remove this kind of thing and make it more general?
Lines 1068-1088 are redundant.
Lines 1068-1088 are redundant. Please remove this
unrelated ; please fix.
Could you please check if this is null?
Could you please rename this variable?
Could you please add this.
Why is this List<String>?
Why are you creating a LinkedList here?
Why is this a LinkedList?
should be synchronized
should be if (onCloseAction!= null)
Should be an IllegalStateException.
@lmontrieux Wow... Strange. I think in this manner you need to add another method there.
@lmontrieux Wow... Strange. I think in this manner you need to add addional {} to this list.
@lmontrieux Wow... Strange. I think in this manner you need to add addional {} to this code.
what if other.position == null?
what is the point of copy if other.position == null?
what if.position == null?
This is not the right way to test asserts, they are all stopped in the method from the main method. You should have a look at this: <LINK_0>
This is not the right way to test asserts, they are nice.
This is not used, please remove.
all these methods can be private
all of these methods can be private
all the methods to be private
By default, this test is not necessary.
By default, this test is not needed.
Does this change bring any existing issue?
Can you add a note not that this change is necessary?
Can you add a note about this?
Can you add a note not that this change is necessary
If "GnomeLoginKeyring" is true, this will fail.
If "GnomeLoginKeyring" is null, this will fail.
If "GnomeLoginKeyring" is false, this will fail.
Seems weird to delegate to generateStructSupportWriter. Maybe we should introduce a method that checks if initialization and creating the structSupportWriter is done here.
Seems weird to delegate to generateStructSupportWriter. Maybe we should introduce a method that generateStructSupportWriter can call this?
Seems weird to delegate here, given that generateStructSupportWriter is abstract
I would prefer if workbench.getActiveWorkbenchWindow() would be replaced by workbench.getDisplay().asyncExec(() -> { workbench.getActiveWorkbenchWindow().installOnWindow(active); }
I would prefer if workbench.getActiveWorkbenchWindow() would be replaced by active.getWorkbench().getDisplay() instead of doing this on the UI thread.
I would prefer if workbench.getActiveWorkbenchWindow() would be replaced by active.getWorkbench().getDisplay()
It seems like this could be handled in a different commit as well.
It seems like this could be handled in a different commit than in StateTransferService.
It seems like this could be handled in a different commit than in StateTransferSessionStatus.
this should only be allowed if the client is logged in when it is being sent or if the client is not there yet. clientStatusList.get(reg.getEndpoint())
this should only be allowed if the client is logged in when it is being removed.
this should only be allowed if the client is logged in when it is being sent. If it is so, the getPresenceStatusObject(down.getEndpoint()) needs to be called in order to obtain the clientStatusList contains the getEndpoint().
can you remove the instance?
can you can remove the instance?
can you extract this into a private method?
Added a check, i.e. the bounds are different, and it is not 2.
Added a check, i.e. the bounds are not there.
Added a 'assert' statement?
I think this should be in a synchronized block as the updateNotification() method is a cleanup for "public void updateNotification() { synchronized (mUpdateLock) { if (mTetheringInactive) { setupRestrictedNotification(); } else { clearNotification(); } }
I think this should be in a synchronized block as the updateNotification() method is generally called after a user task this update() is called.
I think this should be in a synchronized block as the updateNotification() method is a cleanup for "public".
Does this need to be public?
Should you add an assertion that hasMining is false?
Should you add synchronized?
I'd like to see this more of a general exception class.
I'd like to see this more of a warning.
I'd like to see this more of the types of near-real-level format.
You can use try-with-resources.
You can use try-with-resources, I think.
try-with-resources?
elapsedNanos.
elapsedNanos is not necessary
elapsedNanos is not used
add curly braces around if body.
add braces around if and else clause.
add curly braces around if and else.
Wouldn't it be better to move to the constructor here? The "private" method is a part of the public API, so it's a matter of style.
Would there be a case for this fail?
Wouldn't it be better to move to the constructor here? The "private" method is a part of the public API.
It's better to check the param is not null first.
eccRecords is an also EVENT_REFRESH, no need to change the test.
eccRecords is an also EVENT_REFRESH, no need to verify
Not sure if jobs.poll()!= null is a good idea here. In this case, perhaps we should explicitly stop the jobs that are running on the first time?
Not sure if jobs.poll()!= null is a good idea here. In this case, perhaps we should explicitly stop the jobs that are running on the first time and avoid queueing with nulls.
The loop should be executed only when jobs.poll()!= null
I think we should not register RateLimitsEventHandler at all. Can we make RateLimitsEventHandler a class Listener instead? So that we can cast to ModelUpdatedEventHandler of RateLimitsEventHandler?
I think we should not register RateLimitsEventHandler at all. Can we make RateLimitsEventHandler a class Listener instead and have RateLimitsEvent add it in ListenerManager.addEvent?
I think we should not register RateLimitsEventHandler at all. Can we make RateLimitsEventHandler a class Listener instead? So that we can cast to ModelUpdatedEventHandler of RateLimitsEventHandler? I also wonder if we can get rid of this interface later.
This method is private for now, so it can be made private
This method is private for now, so it can be made protected
This method is private for now, so it could be made private
If response.getInputStream() throws an IOException, we should close the response.
If response.getOutputStream() throws an IOException, we'll commit the file on the same stream.
If response.getOutputStream() throws an IOException, we'll flush the file on the content.
Is this line necessary?
Is this a reason to return an immutable list?
Is this a reason to return a list of strings?
Nullness of this is already tested in hashCode
Nullness of this is already tested in the hashCode
Could be synchronized (this)
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
It should be false even if it's not set to true. For occurrences in the class, when the parameter is set to true, the method shouldScan check that it is set to true.
It should be false even if it's not set to true. For occurrences in the class, when the parameter is set to true, the method shouldScan will take care of it.
It should be false even if it's not set to true. For occurrences in the class, when the parameter is set to true, the method shouldScan will take care of it (I think).
Will there be anyOf(Element.class) when canvasHandler.doBatchUpdate returns false?
Will there be anyOf(Element.class) when canvasHandler.doBatchUpdate returns true?
Will there be anyOf(Element.class) where you're not comparing to any()?
Instead of using IOUtil, you could use IOUtil.copy( container.getId(), "/root/.ssh/id_rsa" ).exec(), writer );
Instead of using IOUtil, you could use IOUtil.copy( container.getId(), "/root/.ssh/id_rsa" ).exec()
Instead of using IOUtil, you could use the copyFileFromContainerCmd method below, which calls copyFileFromContainerCmd.
Maybe you could set the content type as a POST attribute in the ingest file and call it from /api/json?
Maybe you could set the content type as a POST attribute in the ingest method and invoke it on the HTTP method?
Maybe you could set the content type as a POST attribute in the ingest file and call it from /api/request/?
This is not consistent with equals. It should be!(value instanceof NameHolder) || name.value == null)
This is not consistent with equals. It should be!(value instanceof NameHolder)
This is not consistent with equals. It should be equal to just the value.
I think we need to always use the Object parameter for the method. Otherwise we always want to set setBaseEnabled to true.
I think we need to always use the Object parameter for the method. Otherwise we always want to set setBaseEnabled.
I think we need to always use the Object parameter for the method. Otherwise we always create a new Parameter implementation for this.
Extra space after keywords
Extra final
Extra curly brace.
This variable is not being used anywhere. Is it necessary to verify it?
This variable is not being used anywhere. Is it necessary to verify it?
This variable is not being used anywhere. Is it necessary?
Why is this needed?
For BundleContext it is important that you automatically call startModuleSources and from that method. But I think it is ok to call initializeModuleSources only once.
For BundleContext it is important that you automatically call startModuleSources and from that context. But I think it is ok to call initializeModuleSources only once.
I think you can add: if (++this.processed % this.n == 0) { log(chrom, pos); }
you're still doing this.processed % this.n == 0 is redundant.
you're still doing this.processed % this.n == 0 is useless.
You should create a new validateEmail(String email ) method in this class.
You should create a new validateEmail(String email) method which checks the email, and call it from there.
You should create a new validateEmail(String email) method which checks the email, and call it here.
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing)
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton.
Is takeLast(0) meaningful?
Make it a switch
Why do you need to use isPresent here?
Why do you need to call isPresent here?
This is a legacy case of backwards compatibility. deleteHorizonMs is never going to be set.
This is a legacy record, deleteHorizonMs is never going to be set. It seems this method could be removed.
This is a legacy case of backwards compatibility. deleteHorizonMs is never going to be set. It seems we can avoid returning an -1 from an old implementation.
How about a constant for the maximum length?
How about a constant for the numbers?
How about a constant for the default value?
requireNonNull
Not a good idea to make the constructor private (as we only have to pass in the relevant param). An instance of the constructor can call the constructor with a null argument.
Not a good idea to make the constructor private (as we only have to pass in the relevant param). An instance of the constructor can call the constructor with a null param.
What's the magic number please?
What's the magic number you used for?
What's the magic number you used in?
Using String.format with one argument is slightly more efficient. Also, how about removing the need for String.format?
Using String.format with one argument is slightly more efficient. Also, how about doing return String.format(long, nanoTime); so the result doesn't have to be computed twice?
Using String.format with one argument is slightly more efficient. Also, how about doing return String.format(long, nanoTime); so the result doesn't have to be modified?
Why change this line?
Why do we return Optional.empty()?
Why can't we use cache here?
Why do we need this change?
Why do we need to change it?
Why do we need to change the xml?
Please use assertEquals
You can use assertEquals.
You can use assertEquals
this loop is not necessary
this could be static
this loop is not needed
Hue -> Shutdown
Possibly error instead of info?
Possibly error instead of "Hue"
So the conversion for the name and the conversion here is not needed. Is there a reason to make ReadPreference#valueOf using the method of the ReadPreference class?
So the conversion for the name and the conversion here is not needed. Is there a reason to make ReadPreference#valueOf using the getReadPreferenceSet instead of the method?
So the conversion for the name and the conversion here is not needed.
guava
return (name == null)? 0 : name.hashCode();
I think I saw it earlier in the class, but can you please make it consistent with other classes?
How can getCachedVm().getClusterId() return null here?
How can getCachedVm().getClusterId() return null here? If this is to return a null, what is the caller of this method?
How can getCachedVm().getClusterId() return null here? If this is to return a null, what is the caller of this query?
Maybe log the scopes that are in the log?
Maybe log the scopes that are usually in the log?
Maybe log the scopes that are lower case?
This might be cleaner: java if (totalCount < pageSize) { return Optional.absent(); } return Optional.of(toPaginationOptions(pageNumber + 1)); } return Optional.absent();
This doesn't seem to be used.
Why is this special case necessary?
Why not return Optional<TableMetadata>?
Why not return Optional<TableMetadata> here?
Why not make this private?
Remove the call to closeSiblingParts.
Remove the call to closeSiblingParts()
Remove the if check
suggestion logger.warn("Could not remove {}: {}", element.getMessage(), ex);
suggestion logger.warn("Could not remove {}: {}", element, ex);
suggestion logger.warn("Could not remove {}: {}", element, ex.getMessage(), ex);
Should this be private?
Should be private, right?
Should this be private, or
maybe check for null in request?
maybe check for null in request.getEntity()?
maybe check for null in request.getEntity()
There should be a finally block after this line.
There should be a finally block after the catch block.
There should be a finally block after this statement.
This method isn't really being used.
This returns a boolean.
This method isn't really being called from any lifecycle.
Should be adding some validation checks that the value of the 'object' outputs.
Should be adding some validation checks that the value of the 'current' value is null.
Should be enough to retain the object creation.
Nit: Line wrapping is a bit odd.
Nit: Line wrapping is odd here.
Nit: Line wrapping is a bit odd here.
This should be a warning.
This should be a compile method.
This should be a warn instead.
The TM_RESOURCE_SPEC is a property of the enum, so we can just use getAnnotation(key) instead.
The TM_RESOURCE_SPEC is a property of the enum, so we can just use getSystemState().
The TM_RESOURCE_SPEC is a property of the enum, so we can just use getAnnotation(key) and read from the setter.
This should be done in a separate commit.
This should be before we call.show(getApplicationContext(), Context.getShell(), Context.TAG);
This should be before we call newInstance now.
If the hiveFileContext is not set, the exception will be thrown. let let the caller handle the exception.
If the hiveFileContext is not set, the exception will be thrown. let's add a check on hiveFileContext.isOperationContext()
If the hiveFileContext is not set, the exception will be thrown.
:ant: I think you meant "itemcategory-standalone-standalone"
:ant: I would suggest itemcategory-standalone, itemcategory-standalone can be null
:ant:
huh?
"should resolve model one dialog"
"should resolve model one dialog", is it the last one?
Redundant else blocks.
Unnecessary else blocks.
Redundant brackets.
Please remove these empty lines.
Please remove this empty line
Please remove this empty line.
I guess it is better to return a Map<String, String> here?
I guess it is better to return something like namespace.getMetadata().getName(), i.e. return null;
I guess it is better to return an empty map for the attributes here, just in case.
It is better to use ToStringHelper.
It is better to use toStringHelper as in other objects.
It is better to use ToStringHelper
return (hasCurrency(name));
return (hasCurrency(name))
return true;
I think we should only log the exception if the logic is reinitializer is not reinitializer. Also in ConfigHashSync#runr the code in the AbstractTransactionHashSync#runr is not clean.
I think we should only throw the exception if the async user is not running, not just print some info
I think we should only throw the exception if no user is running on the server
You need to declare the parameter as Duration.TEN_MINUTES
Let's move this logic to a new method named setupJavaRuleChain(eteClass, composeFile, env, environment)
Let's move this logic to a new method called RuleChain setupFromTimelock
I wonder if we should consider unconditional return value in the end instead of adding a new value to the end of the list. Wouldn't it be better to just cancel(true) in the end?
I wonder if we should consider unconditional return value in the end instead of adding a new value to the end of the list?
I wonder if we should consider unconditional return value from the setter?
The full package name here is confusing, it's not what it's supposed to do.
The full package name here is confusing, it's not what it's supposed to be.
Why not make this an abstract method that you already have the common code that you want?
Please extract this to a method in the StartActivity.java
Please extract this to a method in the StartActivity class, as it is repeated in more places.
Please extract this to a method in StartActivity.java
Maybe we should move this to a finally block too?
For some reason, there is no synchronization to append this to the transaction? If so, this will not be seen as any issues.
Maybe we should move this to finally block as it could cause some problem.
create unmodifiable view
return unmodifiable list.
return unmodifiable list.of();
I'd prefer to make the constructor private and make the default constructor private.
I'd delegate to the new constructor to make it public.
I'd delegate to the new constructor to make this public.
[minor] this change is messed up, this line should be removed.
[minor] this line is messed up, i think it should be removed
[minor] move this line to the next line
![MAJOR](<LINK_0> Remove this unused method parameter "reauthenticate". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> Remove this unused method parameter "request". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> Remove this unused method parameter "reauthenticate". [![rule](<LINK_1>](<LINK_3>
consider to change this to return driver.findElements(languageSelector, languageSelector); for consistency.
this method can return List<WebElement> instead of List<String>, as it's not that important.
this method can return List<WebElement> instead of List<String>, as it's not needed anymore
Here too: java new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name()).thenReturn(Collections.singletonList(EventHubNamespaceImpl.class));
Here too: java new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());
Here you could probably extract new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name()) to EventHubNamespaceImpl or EventHubNamespaceImpl as well.
If size is Long it will be a long. E.g. an int instead of a double.
If size is Long it can return an Optional<Integer> instead of a float.
If size is Long it will be a long. E.g. an int instead of a float.
@erimerturk let's rename toString to "factoryClassName"
@erimerturk let's rename pmml to getName()
@erimerturk let's rename'sourcePath'
maybe add a check that taskResource!= null before doing String.format()?
maybe add a check that taskResource!= null before doing String.format?
maybe add a check that taskResource!= null
Nice use case for a constant
Nice use of a timer variable
Nice use case for a constant.
pass in a conversion to object2IntMap instead.
pass in a conversion to string2IntMap instead.
Make sure to handle a case where totalLimit will be zero.
It might be better to add a Preconditions.checkArgument to check that the parameters are not null and empty.
It might be better to add a Preconditions.checkArgument to check that the address is not null
It might be better to check whether the readers contains the address, and then remove the consumers.
You have two DAO calls here, 1) To be on the DAO, you should use getEnclosingCommand() and getStorageDomainId().
You have two DAO calls here, 1) To be on the DAO, you should use getEnclosingCommand().getParameters().getStoragePoolId() and getStorageDomainId().
You have two DAO calls here, 1) To be on the DAO, you should use getEnclosingCommand().getParameters().getStoragePoolId() and getStorageDomainId()
This should be moved into the else if
This should be moved to the else if
This should be moved to the else if statement below
this(null, backoffStrategy) can be removed
this(null, backoffStrategy)
this.inverno
This is not needed.
This is where it should be.
This is causing boxing.
Why not using Application.getStepDescriptions() instead of creating a new array?
Why not using Application.getStepDescriptions() instead of creating a new one?
Why not just return empty array of StepDescriptions?
> / / @Override public void openFile(File file) { if (file!= null &&!file.isDirectory()) { TemporaryFolder file = fileService.readFromFile(file.getAbsolutePath()); TemporaryFolder file = FileService.readFromFile(file.getAbsolutePath()); } else { TemporaryFolder file = FileService.readFromFile(file.getAbsolutePath()); } etc.setEditorContent(content);
> / / @Override public void openFile(File file) { if (file!= null &&!file.isDirectory()) { TemporaryFolder file = fileService.readFromFile(file.getAbsolutePath()); TemporaryFolder file = FileService.readFromFile(file.getAbsolutePath()); } else { TemporaryFolder file = FileService.readFromFile(file.getAbsolutePath()); }.setEditorContent(content);
AFAIR file can't be null at this point.
Does this need to be public?
Does this need to be synchronized?
Does this need to be null?
Could be simplified to return new PublishExecutor();
Shouldn't this be synchronized?
Could be simplified to return new PublishExecutor()
String.valueOf() is not needed
String.valueOf is deprecated. Please fix.
String.valueOf is unneeded.
I'm not very sure what this test is doing. (I don't think it's very realistic if it happens to be in a scan that won't do anything).
I'm not very sure what this test is doing. (I don't think it's very realistic if it happens to be a scan that won't exist.)
I'm not very sure what this test is doing. (I don't think it's very realistic if it happens to be in a scan that won't do the filter.))
There is a sub() error in line 16338379 which is not the same.
There is a sub() error in line 16338379 which is not the same as the one of the sub classes.
There is a sub() error in line 16338379 which is not the same as the one of the sub() error.
java checkNotNull(rfc822Format, "rfc822Format");
java checkNotNull(rfc822Format, "rfc822Format"));
checkNotNull can be removed here.
<LINK_0>
<LINK_0> return (Boolean) pipeline.getOrDefault("disabled", false);
java return (Boolean) pipeline.getOrDefault("disabled", false);
I think we should use Preconditions.checkNotNull for consistency.
I would prefer to replace this with Preconditions.checkNotNull(family, "family");
I would prefer to replace this with Preconditions.checkNotNull(family, family)
consider adding a Preconditions.checkArgument to check that valueSymbolsWalked is never 0.
consider adding a Preconditions.checkArgument to check that valueSymbolsWalked is never null.
consider adding a Preconditions.checkArgument to check that valueSymbolsWalked is not null.
Is this needed?
Is it really necessary to check the response status?
I think this should be 403
Please use equals when comparing with ==.
Can we use equals instead of ==?
Please use equals when comparing with a string
Should this be one line down after site?
Should this be one line down before site?
Should this be one level deep?
I think this null check can be removed since it can be null in any case.
I think this null check can be removed since it can be null.
I think this null check can be removed since it can be null in any tests, and does this check in a few places down.
levels = {/level/3.txt}
levels = new Log();
levels = {/level/1.txt}
This is confusing. Should this be a Flux<Payload>?
why this is not a Flux?
This is confusing. Should this be a Flux?
please put each parameter in separate line :)
please put each argument in separate line :)
please put each parameter in separate line
Why not just synchronize on sample here?
Why not just inline this in the field declaration?
Why not just synchronize on sample here and return?
You should use a variable to store this 5, so that when you want to change it, you only have to change it in one position instead of 3.
You should use a variable to store this 5, so that when you change it, you only have to change it in one position instead of 3.
You should use a variable to store this 5, so that when you have to change it, you only have to change it in one position instead of 3.
You should lock the DB before the snapshot
You don't need to check if vm is null
You should lock the DB before the vm disk
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface?
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface? If you need to change this method, you can probably just return isReadOnlyPropertyCompatibleWithInterface
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface? (sounds odd, but still it's not clear to me)
can we use toStringHelper
Can we use toStringHelper
Can we use toStringHelper instead?
Can we return Optional<String> instead?
Can we return getClientInfo() or something along those lines?
Can we return getClientInfo() or something else more descriptive?
Should be: getByOriginAndCustomEventId(ORIGIN, CUSTOM_BAKUP_EVENT_ID);
Should be: getByOriginAndCustomEventId(ORIGIN, CUSTOM_BAKUP_EVENT_ID)
Should use getByOriginAndCustomEventId() here, as it's a little confusing to read.
nit: it's fine to use 'early return' for readability.
nit: it's fine to use 'early return' for readability of code.
suggestion
suggestion throw new IllegalArgumentException( "expires must be in range of 1 to " + expiry > DEFAULT_EXPIRY_TIME));
suggestion throw new IllegalArgumentException( "expires must be in range of 1 to " + expiry > DEFAULT_EXPIRY_TIME);
Here it's possible to use -1 as a default value.
YamlParser.INSTANCE.parseMap(...);
YamlParser.INSTANCE.parseMap(resources.sourceFile(configPath))
Can you define a static method for it?
the InputNoCloneClones.java is about providing a category and parameter. Please rename this file to InputNoClone.java or something similar.
the InputNoCloneClones.java is about providing a category and parameter. Please rename this file to InputNoClone.java or others.
the InputNoCloneClones.java is about providing a category and parameter. Please rename this file to InputNoClone.java.
return!value.trim().isEmpty();
return!value.trim().isEmpty() &&!value.trim().isEmpty();
return value!= null &&!value.trim().isEmpty();
LOG.error("Python Ready");
LOG.error("Python Ready {}: {}", line);
LOG.error("Python Ready" + line);
I am not sure if it is a good idea to throw an exception here. If we are not able to continue using old code, we should probably throw an exception.
I am not sure if it is a good idea to throw an exception here. If we are not able to continue using old code, we should just skipVariableAssign and continue with the class.
I am not sure if it is a good idea to throw an exception here. If we are not able to continue using old code, we should just skipVariableAssign and continue.
Can be simplified with java return isPresent( klass).map(Class.forName(klass)).findFirst();
shouldn't this be ClassNotFoundException?
Can be removed
Collections.emptyList()?
Collections.singletonList()?
Collections.emptyList() let's use guava from guava
Can we define a constant for this?
Why make a string literal here (and not in another class)?
Can we define a constant for this string?
same as above, exception message should be more meaningful.
same as above, exception message should be more meaningful
same as above, exception message should be more explicit
Same here. It's not clear about the code.
Same here. It's not clear whether you are modifying the code.
Same here. It's not clear whether you are modifying this method.
Is it possible to use RANGER_USER_SYNC_ROLE_TYPE instead of null?
Consider using Iterables.getOnlyElement instead of Iterables.getOnlyElement
Is it possible to use RANGER_USER_SYNC_ROLE_TYPE instead of null? If so, we could use getOnlyElement
Missing a return statement.
Missing a default: return
Missing a return statement
You can use the for-each syntax here too, and remove the break.
You can use the for-each syntax here and below.
You can use the for-loop syntax here too, and remove the break.
static import
nit: add TupleDomain.all()
nit: final
We should use synchronized over a synchronization on this object.
We should access this outside of the API.
We should use synchronized.
this one can be moved to the validateParameters() method
this one can be removed as well
this one should be stopmigrate by default
Oh, I see. Why "Single use connection needed with closeStreamAfterSend" has been removed? Why not just "Single use connection needed with closeStreamAfterSend"?
Oh, I see. Why "Single use connection needed with closeStreamAfterSend" has been removed? Why is it still needed here?
Oh, I see. Why "Single use connection needed with closeStreamAfterSend" has been removed? Why is it still needed?
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
suggestion if (!isRunningInJmc() &&!isRunningInJConsole() &&!isRunningInJVisualVm()) {
suggestion if (!isRunningInJmc() &&!isRunningInJConsole() &&!isRunningInJTester) {
typo
super. clearForce only called once.
typo.
Not sure you need to call this.zoneVisits.put(z, 0) would be better.
Not sure you need to call this.zoneVisits.put(z, 0);
This can be done in one line
- [x] I know the it's not your mistake, but the test for the case where the validation is redundant.
- [x] I know the it's not related to this patch, but the tests for the same reason should be improved (and more accurately this test case).
Maybe check the values of the validator too?
@erimerturk why not Joiner.on(RqMultipart.Fake, dispositions).forEach(this::fakeBody);
@erimerturk why not do this(req.head()) here instead?
@erimerturk why not to inline this?
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check!isPlace() has a main method. It will be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check!isElementEqual would be safer, since it would be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
I would use InterfaceUtils.equals("getPackageName().equalsIgnoreCase")
@gmalanga this condition should probably be else if (data.isEmpty()) { } else { }
@gmalanga there is a utility method available(List<T> data)
@gmalanga this condition is not needed
This is missing an unrelated change.
This is missing an exception.
This needs to use a null check.
[Java-8 try-with-resource](<LINK_0> try(PrintStream socket = attach(); output.print(eventBody + "\r\n"); output.flush();
[Java-8 try-with-resources](<LINK_0>
[Java-8 try-with-resource](<LINK_0>
you are comparing strings here. Don't we need to use equals()?
you are comparing strings here. Don't we need to use equals method?
you don't need to check for empty strings
The buttons are added as a UIComponents method.
The buttons are added as a  button.
The buttons are not descriptive.
I think it's safe to add the same domain to the data, but OvirtClient will also map the same domain to the entity.
I think it's safe to add the same domain to the data, but OvirtClient will also map ServerConnections that contain it. You should use it here.
I think it's safe to add the same domain to the data, but OvirtClient will also add the proxy.
Can't you rename to something like supportsStorageDomainWithinThresholds()?
Can't you rename to something like supportsStorageDomainWithinThresholds?
Can you rename to validSpaceWithSnapshots or something more descriptive?
Versions should follow [our standard](<LINK_1>, which is basically [semantic versioning](<LINK_0> The quick fix is change from 1.0 to 1.0.0. The reason to change this is eventually we'll enforce version standards in code.
Versions should follow [our standard](<LINK_1>, which is basically [semantic versioning](<LINK_0> The quick fix is change from 1.0 to 1.0.0. The reason to change this is eventually we'll enforce version 5.
Versions should follow [our standard](<LINK_1>, which is basically [semantic versioning](<LINK_0> The quick fix is change from 1.0 to 1.0.0. The reason to change this is eventually we'll enforce versioning to be more likely to cause issues.
We should make this more reliable, I think.
We should make this static.
We should make this more descriptive, I think.
Use getConfig().getName().
I wonder if this should be more of an optimization. The cluster node to be a snapshot of the parent, not of the machine.
I wonder if this should be more of an optimization for LocalDisks.
No need for public, package local is enough.
No need for public, package protected, and the test class is in the same package.
You need to make it work as COPY was before before you call copyAs.
I would suggest to use a couple of examples for getting the class and a DefaultTable instead of a  DefaultTable.
I would suggest to use a couple of examples instead of System.out.println and another one for different behaviour.
I would suggest to use a couple of examples instead of System.out.println.
It might be better to create a protected method in the EMFFormsSettingToControlMapper and have a method that takes the Iterator<EObjectsToValidation> instead of the repeated logic.
It might be better to create a protected method in the EMFFormsSettingToControlMapper and pass it in here as an instance variable.
It might be better to create a private method in the EMFFormsSettingToControlMapper and pass it in here as an instance variable.
As above: private, 100 chars, use error result instead of doOnError.
As below: private, 100 chars, use error result instead of doOnError.
As above: private, 100 chars, use error result instead of doOnError().
I think this logic should be in a shared method, so it's only applied if it's a SingularityEventSender.
I think this logic should be in a shared method, so it's only applied if it's an error.
I think this logic should be in a shared method, so it's only applied if you want to verify it
We need to check the size at the end of the list.
We need to check the size at the end of the expression (e.g. callExpression.getChildren().size())
We need to check the size at the end of the expression.
Instead of too many this should be JOptionPane.YES_OPTION, JOptionPane.YES_OPTION, JOptionPane.NO_OPTION);
How about the too much relibilty: return (userChoice == JOptionPane.YES_OPTION)? JOptionPane.YES_OPTION : JOptionPane.YES_OPTION;
How about the too much relibilty: return (userChoice == JOptionPane.YES_OPTION)? JOptionPane.YES_OPTION : CanOpenState.OPEN;
PsiTreeUtil.getNonStrictParentOfType
what if element is invalid?
what if element is empty?
remove?
remove
remove!
If you're done it will override the onPartitionsRevoked() immediately and call onPartitionsAssigned() only once. If the partitions are assigned to the same list, then you can add the partitions parameter to the callback in onPartitionsRevoked() immediately.
If you're done it will override the onPartitionsRevoked() immediately and call onPartitionsAssigned() only once. If the partitions are assigned to the same list, then you can remove the @Override annotation.
If you're done it will override the onPartitionsRevoked() immediately and call onPartitionsAssigned() only once. If the partitions are assigned to the same list, then you can add the partitions parameter to the callback in onPartitionsRevoked()
1. use.toUpperCase(Locale.US) 2. use default locale (if default locale is set, for example using locale)
1. use.toUpperCase(Locale.US) 2. use default locale (if default locale is set, for example using locale).
1. use.toUpperCase(Locale.US) 2. use default locale (if default locale is set)
We should still log the exception as ConcurrentModificationException.
We should still log the exception, even if it is not a ConcurrentModificationException.
We should still log the exception, even if it is the application failed?
change to List
change to ArrayList
Change to List
you could add a method in HostProviderProxy to already return the proxy. This will help to avoid calling this from the execute method.
you could add a method in HostProviderProxy to already return the proxy. This will help to avoid some casts.
you could add a method in HostProviderProxy to already return the proxy. This will help to avoid calling this from the command line output
Speaking of sanity checks, is this: (100 - minLastVerified) + 1 OR 100 - minLastVerified + 1)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
Speaking of sanity checks, is this: (100 - minLastVerified) + 1 OR 100 - minLastVerified + 1? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
Speaking of sanity checks, is this: (100 - minLastVerified) + 1)
Shouldn't this be called in the finally block?
Shouldn't this delete be in the finally block?
Should this be called in the finally block?
Why is o1 == null a valid instance?
Why is o1 == null a valid instance? Wouldn't it be better to throw an exception if o2 is null?
Why is o1 == null a valid instance? Wouldn't it be better to throw an exception if o1 == null?
What do you think about changing the order of the arguments to the assertThat? java assertThat("number of rows should encrease", schemaRows, equalTo(0));
What do you think about changing the order of the arguments so that we don't have to encrease and event_type_schema? I personally think that's a bit more readable...
What do you think about changing the order of the arguments so that we don't have to encrease and event_type_schema?
you sure it's correct? the error messsage is the EngineException
why do we want to restrict it? the error messes with the engine is down
why do we want to restrict it? the error messsage is relatively harmless as well..
listFiles can return null, so you would need to check that the File exists before trying to add it to it. And if it doesn't exist then the subsequent update will fail.
listFiles can return null, so you would need to check that the File exists before trying to add it to it.
listFiles can return null, so you would need to check that the File exists before trying to add it to the directory.
Suggest return type here as well.
Suggest return type here as well
Cache<K, V>?
Isn't pattern.matcher(username) ? (add extra  a the end)
Isn't pattern.matcher(username)? (add extra  a the end)
Isn't pattern.matcher(username) ? (add extra )
I'm not sure if this is the right place. Can you verify? If so, perhaps add a check.
I'm not sure if this is the right place. Can you verify? If so, this way we can create a list of listeners. I'm not sure if this is the right place.
I'm not sure if this is the right place. Can you verify? If so, perhaps add a check..?
Make it final static
Make this final static
Make use of @Nullable here
nit: we could extract this into a private method or even private.
nit: we could extract this into a private method or make it private.
nit: we could extract this into a private method or even private? It should be accessed in a subclass
why not just cause?
why not just skip this?
why you don't just assume this?
This method should be private or package-private (probably not needed). Also, please make it private.
This method should be private or package-private (probably not needed). Also, are you sure that it's only ever used through this class?
This method should be private or package-private (probably not needed). Also, are you sure that it's only ever used outside this class?
Use URI.trim() instead of URI.contains(ConcurConstants.TRAVEL_REQUEST_URI_INDICATOR)
There are many more places where URI is null. Makes it more readable to make it a bit more readable.
There are many more places where URI is null. Makes it better to make it a descriptive variable.
static import?
static import, it reads better
static import
This could be return ((Target) treeContext.getUserObject();
This could be return getSelectedContext();
This return is not needed and it exposes too much of the internals anyway
Doesn't the remove() function return you the UpdateHandler which you want to call onCompletedExceptionally on?
Doesn't the remove() function return you the UpdateHandler which you want to call onCompletedOnUpdate?
Doesn't the remove() function return you the UpdateHandler which you want to call onCompletedExceptionally(cause)
onClosed() but this entire callback's value can be null, so I'd remove this check.
onClose?
onClosed()
Shouldn't this line be _ensureUserIsWorkspaceOwner_
Shouldn't this line be _ensureUserIsWorkspaceOwner_?
It would be better to move this line to _ensureUserIsWorkspaceOwner_
introducing local scope.span()?
ints?
introducing
I would suggest to use an AtomicBoolean instead, since it would be easier to read.
I would use try-with-resources here, and make this code cleaner
I would use try-with-resources here
Needs to be a constant
Needs to be a dash
Needs to be a dash like "buss"
I don't think this is necessary here, because we're returning a list of modules with no length.
I don't think this is necessary here, because we're returning a list which can never return anything on an end of the method.
I don't think this is necessary here, because we're returning a list of modules with no length. The method should return void.
it's better to use EnvType.OSEE_APPLICATION_SERVER
it's better to use EnvType.equals(envType) here as well.
it's better to use EnvType.equals(envType) here if you use it.
Probably returned value can be cached. What do you think?
Probably we should check that this value can be greater than Long.MAX_VALUE.
Are you sure this can never happen?
c!= null.
c is always non-null.
Can c be null?
Could restructure this if to always be true. It looks like you are trying to use either class or style.
Could restructure this if to always have both null and empty lines.
Could restructure this if to always be true.
this needs to be synchronized as well.
this.responses = new HashMap<>();
this.responses() is not a server operation
This seems like it should be a warn
This seems like it should be a warning
This log is not appropriate.
I don't think you need to include the input here. It means that we will not have a valid input in the id if there is a problem.
I don't think you need to include the input here. It means that we will not have a valid input in the id if there is a problem with the old difficulty level
I don't think you need to include the input here. It means that we will not have a valid input in the map.
Maybe we could do it in one line.
Maybe we could do it in the service layer?
Maybe we could do it in the service and return a List<SearchSuggestion>?
Would this be safer if the lambdaInterface's name was extracted to a variable?
Would this be better as a lambdaInterface.get() method?
Would this be better as a lambda interface?
Border-case user is not null, so you don't need to check for null.
I think this method can be private.
Border-case user is not null, so you can get a NullPointerException with an NPE.
Use Arrays.copyOf: this.weights = Arrays.copyOf(weights, min, max);
Use Arrays.copyOf: this.weights = Arrays.copyOf(bucketCount, min, max);
This should be private.
This should be the EntityDictionary.
This should be the type.
Not necessary.
Can combine the 2 above lines and use the constructor which accepts disk-id
Use "guid" instead of "asGuid(guid)".
Can combine the 2 above lines and use the constructor which accepts disk-id.
It seems that this should return Object, not Object.
It seems that this should be returning an object, not a data source.
It seems that this should be returning an Optional<Response> instead.
s/public// This//
s/public// This/
s/public//
I would make this return objectMapper.writeValueAsString(this.clientSideRequestStatistics); and avoid the try/catch
I would make this a warning instead of a string concat.
I would make this return objectMapper.writeValueAsString(this.clientSideRequestStatistics);
Minor: Use this. consistently in the class.
Minor: AbstractApplicationRunner should implement AutoCloseable.
Minor: rename the field to "systemAdmins".
Is there a reason to make this public? It seems like it would be a breaking change.
Is there a reason for this constructor being public?
Is it a public constructor?
Wouldn't it be better to move the implementation of hasLeaderInformationChange inside the synchronized block?
Wouldn't it be better to move the implementation of hasLeadership to the LeaderInformationMap?
Would it be possible to move the implementation of hasLeaderInformationChange inside the synchronized block?
Did you mean to leave this method synchronized?
Did you mean to leave it here?
Did you think this method could be called with a lock?
Please don't make this final.
please guard against null here.
Please guard against null here.
why requestNextBatchIfNeeded?
why not use the iterator?
why not use the builder?
This and the method need to be static
This and the method are only used in API. Please remove the public modifier.
This and the method should be private.
(maybe performance-wise) the field that's being initialized here is probably not the case, but to prevent it from being initialized many times, maybe it's worth caching?
(maybe performance-wise) the only usage of a map here is probably an incorrect one, but I'd rather have it return a blank if there are more than one values in the map.
(maybe performance-wise) the only usage of a map here is probably an incorrect one, but I'd rather have it return a blank if there are more than one values in the map. If it's not the case, please use it with the ternary operator.
This can be in an else statement.
This can be in an else block?
This can be an else-if.
log()
you should not show the icon but click here. Sorry for the confusion.
You should be able to click on the diff before the new method is called.
public static
return!supportedSerdes.contains(serdeName);
if you are not going to include the stack trace, let's add the stack trace
log()
log() here and after
log() here
The toString() is probably not a good idea.
The toString() is not a good idea.
The toString() is not a good practice.
maybe add a isEmpty() check here?
Something is wrong here. You are incrementing the variable to a HashSet, which is not the proper solution. Perhaps you want to use a HashSet?
Something is wrong here. You are incrementing the criteria each time in the loop. Why not just set it in the constructor?
suggestion "Either Refreshable or Supplier of runtime config must be provided or none, but not both");
suggestion "%s must be provided or Supplier of runtime config must be provided or none, but not both");
suggestion "%s must be provided or Supplier of runtime config must be provided or none, but not both"); Same for the other check.
@inverno Why?
@vilchik-elena I think that this condition is not necessary
@inverno why?
can you add @since sam annotation here?
can you add @since sam here?
can you add @since sam annotation here?
This can be private, I think
This should be private, I think
This is the same, I think there are private methods, like this.
This will cause ClassCastException. I think, it's not supported.
This will cause ClassCastException. I think, it's not supported. Same deal in all other places.
This is the same as in the other method.
Another place where we could do this but I wish we could have a protected method so that we can avoid the isActive check.
Another place where we could do this but I wish we could move the TcpSlaveAgentListener to JobHelper.start() so that there's a single listener.
Another place where we could do isActive = false.
Does it make sense to import the org.apache.commons.lang package?
Does it make sense to use the same name for both get and get?
Potentially break for the else.
Do we need innerList.toString() here?
Do we want to return the innerList of the node's toString()?
Do we need innerList.toString()?
rename to view
rename to viewStack
rename to viewD
Better to throw Exception than have a throws clause.
Better to throw Exception than have a test that returns null.
Better to throw Exception than have a test that returns nothing.
Shoundn't this already happen inside the if statement? If not would it be possible to use logFileName instead of logMessage?
Shoundn't this already happen inside the if statement? If not would it be possible to push that into the method?
This should be moved to a try-with-resources block
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void should_fail_if_one_field_or_property_is_set_even_if_another_is_ignored() { // GIVEN Jedi jedi = new Jedi("Kenobi", "blue"); // WHEN expectAssertionError(() -> objects.assertHasAllNullFieldsOrPropertiesExcept(someInfo(), jedi, content)); // THEN verify(failures).failure(INFO, shouldContain(actual.getMessage(), content), actual.getMessage(), content); }
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void should_fail_if_one_field_or_property_is_set_even_if_another_is_ignored() { // GIVEN Jedi jedi = new Jedi("Kenobi", "blue"); // WHEN expectAssertionError(() -> objects.assertHasAllNullFieldsOrPropertiesExcept(someInfo(), jedi, "name")); // THEN verify(failures).failure(INFO, shouldContain(actual.getMessage(), content), actual.getMessage(), content); }
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void should_fail_if_one_field_or_property_is_set_even_if_another_is_ignored() { // GIVEN Jedi jedi = new Jedi("Kenobi", "blue"); // WHEN expectAssertionError(() -> objects.assertHasAllNullFieldsOrPropertiesExcept(someInfo(), jedi, content)); } catch (AssertionError err) { verify(failures).failure(INFO, shouldContain(actual.getMessage(), content), actual.getMessage()); }
println should be changed to a logging message
println should be changed.
println()
Raw password cannot be null. The check for rawPassword == null is necessary.
Raw password cannot be null. Please replace it with Optional.empty()
Raw password cannot be null.
return ImmutableList.of(pylintRcfileName + rcfileName);
return ImmutableList.of(pylintRcfileName + rcfileName); should work
return Collections.emptyList()?
Should be VOOB.REQUEST_ON_CREATE, no?
Should be ON_DEMAND.
Should be VOOB.REQUEST_ON_DEMAND.
The synchronized can be removed.
The synchronized can be avoided by using a concurrent collection.
The synchronized can be avoided by using a concurrent map.
Should use a more descriptive message here
Should use the existing Exception message
Should use a more descriptive message here as well
Map<TableScanNode, Void> ret = new IdentityHashMap<>();
Map<TableScanNode, Void> result = new IdentityHashMap<>();
It's not necessary to make a HashMap, it should be enough to check the context.
![MAJOR](<LINK_1> 'Severity: MAJOR') Format specifiers should be used instead of string concatenation. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') String#valueOf(java.lang.String) [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Format string should use %n rather than string concatenation. [![rule](<LINK_2>](<LINK_0>
> /cc @grkvlt i'd suggest using context.getXWikiContext() instead of context.getXWikiContext().
> I would prefer context.getXWikiContext() instead of context.getXWikiContext().
> I would prefer context.getXWikiContext() since it's not used anywhere else.
update header to "AWSMobileClient initialized. User state is : "
Can you pull back into Log.i?
update logs
Please, make sure it's not null
Please, remove extra brackets.
why?
This should be final
Do we need to show latin names?
Do we need to show _this_ is the last one?
Please remove unnecessary parentheses
I'm not sure that it is necessary to init the Input() method. The HandlerThread is not part of the input tab.
Please remove unnecessary parentheses.
To be consistent with the rest of the code, I would leave this as @Override and remove the annotation.
To be consistent with the rest of the code, I would leave this as void
To be consistent with the rest of the code, I would leave this as @Override
I think you can add one more method to pass the event.
I think you can add one more constructor to pass the selectedExpression instead of calling it.
I think you can add one more method to pass the event as an argument.
where is this used?
where does this handle to?
where does this handle to respond?
Why is the cluster ID not clusterId?
Why is the clusterId being set to clusterId?
Why is this exposed?
Change this variable declaration to something with meaning in the context. map is unclear here
Change this declaration to something with meaning in the context. map is unclear here
Change var declaration to something with meaning in the context. map is unclear here
Suggest throw new Exception() if the upload times out. In case the blob is not valid, throw an exception. Throwing an exception here will cause a lot of memory leak.
Suggest throw new Exception() so that the user knows what happened. In this case, don't do anything.
Suggest throw new Exception() if the upload times out
Can we add the CA certificate to the error message?
Can we add the exception message to the log statement?
final
We should make sure that group is non-null here.
We should make sure that Role is not null before default
We should make sure that Role is not null before default.
style nit: we don't use braces around single line blocks
Lines 86-88 and 103-105 should be extracted to a single line.
getAdapter can return null
![MAJOR](<LINK_1> 'Severity: MAJOR') Update this method so that its implementation is not identical to "run". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Update this method so that its implementation is not identical to "wait". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Update this test so that its implementation is not identical to "run". [![rule](<LINK_2>](<LINK_0>
No need to declare this.
No need to declare this..
No need to declare this variable.
why null check here?... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though it doesn't. (This looks uglier, but it's the better long-term solution.)
why null check here?... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution).
why null check here?...
Not sure about this; it's a little hacky.
Not sure about this; it's a little confusing.
See above about calling this::process
You don't need to cache anything.
You don't need to create a new ConfigurationBuilder.
You don't need to create a new one.
maybe should be /library.proto
maybe also include the /library.proto file?
in which case the /library.proto was used?
nit: could extract localDate.atTime(Integer.parseInt(hour), Integer.parseInt(min)); into a method
This is not needed as you prefer it before.
nit: could extract localDate variable for this.
Isn't it possible to add assert for the same behaviour?
Isn't it possible to add assert for the result of this test?
Isn't it possible to add assert for the next line?
This will create 0 connections. Didn't you mean <?
This will create 0 connections. Didn't we mean <?
This will create 0 connections
this method should be private, same for getVersionInfo().
this method should be private, right?
this should be private, same for getVersionInfo().
I would prefer to give the key a KeyPair that is used to prevent the thread from receiving the latch.
I would prefer to give the key a KeyPair that is used to notify it.
I would prefer to give the key a KeyPair that is used to prevent the thread from exiting, and activating it.
Why is this needed?
Why is this really a void?
Why is this a private method?
testEquals(true, false)
Why is this loop needed?
Why is this loop necessary?
public?
these setters could be private
Should be private.
You can probably use Collections.singletonList rather than new Object[] { (Object[])whitelist.split(","));
You can probably use Collections.singletonList rather than new Object[] { null}
You can probably use Collections.singletonList rather than new Object[] { null} in the method argument
This is good. I guess we can't pass the custom panelMenuCreatorField to the widget if we have a specialized class?
This can be removed.
This is good. I guess we can't pass the custom panelMenuCreatorField to the widget if we know it's the display name.
UnsupportedOperationException (which is a bad practice)
UnsupportedOperationException (not implemented)
UnsupportedOperationException
This is the default behavior of a sync, so we should remove this from the StateTransferLock class.
This is the default behavior of a sync, so we should remove this from the StateTransferLock instance.
This is the default behavior of a sync, so we should remove it from the StateTransferLock class.
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well?
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for? it will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well?
"%s/_job.%s.%s.log" is used for all the cancel methods. Should we make it a constant for? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well?
This code will only execute on [Jam](<LINK_0> and the other places where you have to use these.
This code will only execute on [Jam](<LINK_0> and the other places where you have to do it.
This code will only execute on [Jam](<LINK_0> and the other places where you have inJam. It's also in other places
This will not work. The compiler will warn you about this.
This will not work. The compiler will warn you about this. Putting System.random() in a lambda in the code base.
This will not work. The compiler will warn you about this. Putting System.random() in a function call.
If you replace the field with java @Override public Seq<E> getErrors() {
If you replace the field with java @Override public Seq<E> getErrors() { return this; }
If you replace the field with java public Seq<E> getErrors()
Equals should be done with ==
Equals should be done with equals().
Equals should be compared using equals.
I think this part is redundant with the settings in Cb project, isn't it?
I think this part is redundant with the settings in the same file, isn't it?
I think this part is redundant with the settings in the same commit?
Is this left over from debugging?
Is this leftover from debugging?
System.out.println?
I think it would be better to make the site name final.
I think it would be better to make the site name a constant. That way it is clear that we are sure the namespace is always the same.
I think it would be better to make the site name a static variable.
Let's change this to private, and remove the public modifier from the class.
Let's change this to private, and remove the public modifier.
Let's change this to private.
We should also check that the properties are not included in the property.
We should also check that the properties are present.
We should also check that the properties are not included.
And here. needs some validation.
And here. needs some checks.
And here?
Let's inline this: return doGetInputFieldsFromPMMLStream(modelInfo.getPmml());
Let's inline this: return doGetInputFieldsFromPMMLStream(modelInfo.getPmml);
Let's inline this: return doGetInputFields(modelInfo.getPmml());
I think that if you switch to the constructor, then you don't need the field mapping, right?
I think that if you switch to the constructor, then you don't need the field field, right?
I think that if you switch to the constructor, then we can avoid the need of the field mapping, right?
can you explain this? It's definitely not ts, but can you explain?
Should this be asset.getCreatedTime()?
can you explain this? It's definitely not ts.format()
"Unable to find or load default api key properties file"
"Unable to find or load default api key properties file..."
Should we rename this to something more meaningful?
suggestion if (keyedStateBackend instanceof CheckpointListener) { Since the instanceof operator always returns false for null, there is no need to have an instanceof check.
suggestion if (keyedStateBackend instanceof CheckpointListener) { Since the instanceof operator always returns false for null, there is no need to get a null pointer.
suggestion if (keyedStateBackend instanceof CheckpointListener) {
This is not the same error message as above.
This is not the same error message as above, since this can be logged in the warning.
This is not the same error message as above, since we have not even sure the command will be available in the message.
write nullable on the same line or don't write it
write the null check before the instanceof?
write nullable on the right side
We should also add a method: public void setVisible(boolean visible) { if (visible) { showItem(pendingShowItem); } }
We should also add a method: public void setVisible(boolean visible) { if (visible) { showItem (pendingShowItem); } }
We should also add a space between if and (visible) {
what is the priority here?
what is the priority for?
What is the priority for?
shouldn't this be done in the base class?
shouldn't this be synchronized?
shouldn't this be in the base class?
This function now returns false if it has not been called. The previous implementation returns false if it returns true.
This function now returns false if it has not been called. This is better to make it private.
This function non-static seems to be used outside this class.
![INFO](<LINK_0> Remove this unused method parameter "canExecute". [![rule](<LINK_1>](<LINK_2>
canExecute return false here
Empty method is not needed
move this method to PageObjectLogging.log method
move this method up to the next line
move this to method
no need to set it to 100
no need to set it to one time, you can just set it in the if block
no need to set it to one time, you can simply set it in the if block
Looks like we can remove throws CmdLineException now and use parseOptionMap(parameters, new ArrayList<String>()); here.
Looks like we can remove the throws CmdLineException and throw new CmdLineException again if it is not an argument to parseOptionMap
Looks like we can remove the throws CmdLineException and throw new CmdLineException.
I don't understand how this method is used, why cast to ArrayList? on the other hand, it should be List
I don't understand how this method is used, why cast to ArrayList? on the left side?
I don't understand how this method is used, why cast to ArrayList?
why do we need this change?
why is this public?
why do we need this additional throws?
this could be done more efficiently. Are all types handled in the visitors? What do you think?
this could be done more efficiently. Are all types handled in the visitors? Shall we create these objects only if they are related to extension.
this could be done more efficiently. Are all types handled in the visitors? Shall we create the cid object in the visitor and not do it here?
This can be private.
this can be private
this can be private.
Nit: numeric.tsv is default, you have an overload the IncrementalIndex method, and get the default index (which you added in getNoBitmapIncrementalTestIndex()). You could also put that checking here in makeRealtimeIndex and getNoBitmapRealtime().
Nit: numeric.tsv is default, you have an overload the IncrementalIndex class, which you can use to change its signature.
Nit: numeric.tsv should be changed to always
Please change cleanUp() to dispose of the session.
Please change cleanUp() to dispose()
Please change cleanUp() to dispose() in case of error
return this.major >= 0? this.major : this.major?
return this.major >= 0? this.major : this.major?
return Value
suggestion this.eosEnabled = eosEnabled;
nit: We are using this only for the constructor; maybe we should have a private constructor for the eosEnabled?
nit: We are using this to be more concise. I guess we can easily create a private constructor that takes in a String...
I wonder if it's worth to check the scenario in which a getter is executed. For example, if there is a node where the givenFlows are always non-null, then you always override the method.
I wonder if it's worth to check the scenario in which a getter is executed. For example, if there is a node with a same sameFlow as the one in the criteria, then it will return false.
I wonder if it's worth to check the scenario in which a getter is executed. For example, if there is a node where the givenFlows is always non-null, then you always override the method.
I think we should log exception here. NhincConstants.PATIENT_DISCOVERY_DEFERRED_RESP_SERVICE_NAME + ex.getMessage()
I think we should log the exception here. NhincConstants.PATIENT_DISCOVERY_DEFERRED_RESP_SERVICE_NAME.
I think we should log here the exception type so we can see it if it is not correct for service.
I believe this is not necessary. Skipping is done by original code.
I believe this is not necessary. Skipping for now. Please check the original volume.
I believe this is not necessary. Skipping for now. Please check the OS.
Could use the static import.
Could use the name of the parameter.
Could use the name of the method.
Same question as above, "Task-" should also be allowed in a single place.
The logic seems off. Just thinking out loud here, should we also have a unique static string or similar and use that in the other methods?
Same question as above, "Task-" should also be allowed in a name.
Ditto for the unit test.
The test case is not covered with unit test.
Ditto for the test case.
I think this is wrong. We should not call this with a configuration file. We should be able to override it by users.
I think this is wrong. We should not call this with a configuration file. We should be able to override it by a new one.
I think this is wrong. We should not call this with a system property. Can you please use this instead?
deregisterInterest() doesn't need to be public
Why not use lockClient.deregisterInterest()?
deregisterInterest() doesn't need to be public.
Let's use the construct which allows to use the request to construct the data from a private method. That could be passed to the _process(editingContext, data, recommendedFileName, mimeType, configurationName) method instead.
Let's use the construct which allows to use the request to construct the data from a private method. That could be passed to the _process(editingContext, data, recommendedFileName, mimeType, configurationName) method
Let's use the construct which allows to use the request to construct the data from a private method. That could be passed to the _process(editingContext, data, recommendedFileName, mimeType, configurationName) method and to the appropriate constructor instead.
Is it worth casting this to a different field? (I don't see a test)
Is it worth casting this to a custom interface? (I don't see a test)
Is it worth casting this to (TestingStatsCalculator) require changes?
Shall we reuse the constant?
Shall we reuse the constant for this?
Shall we reuse this method with a singleton
Can we use method reference here? I think we should be more defensive here.
Can we use method reference here? I think we should be more correct.
Can we use CircuitBreakerCircuitBreakerCircuitBreakerCircuitBreakerCircuitBreaker.decorate() instead? I think it should be private.
nit: I don't think you want to keep this print at all, its probably OK to rethrow
Make this printError.
Make this debug output.
In theory this is null, but if it does, it should be clear to me what it is.
In theory this should be final.
please use space for variable names.
the string Stream API has a toString() and where does this check get executed (null, null, etc.) should be replaced by flattenList(List), not by calling flattenList.
the string Stream API has a toString() and might return null. I'd suggest making it final and making sure that it's consistently instantiated from flattenList.
the string Stream API has a toString() and where does this check get executed (null, null, etc.) should be replaced by flattenList(List), not just by calling flattenList()..
Use using Preconditions.checkArgument for consistency.
Use using Preconditions.checkState() instead.
Use the readAsString() helper method.
Calling the getId() method here will remove the getId().
Calling the getId() method here will result in a null pointer exception.
It should be package level long
Left-over debug line?
Left-over debug code?
Left over the start of the app
Same issue as above.
Same thing as above.
Same question as above.
Should we use expandLocalRef(p) here? If the ProjectList doesn't implement equals and hashCode, the method below returns an empty list if the input is not a RexNode, so the caller of this method doesn't have to worry about it.
Should we use expandLocalRef(p) here? If the ProjectList doesn't implement equals and hashCode, the method below returns an empty list if the input is not a RexNode, so the caller of this method doesn't need to worry about whether the input is a RexNode.
Should we use expandLocalRef(p) here? If the ProjectList doesn't implement equals and hashCode, the method below returns an empty list if the input is not a RexNode, so the caller of this method doesn't have to worry about whether the input is a RexNode.
There should be a space after the if.
There is a lot of duplication that could be replaced by a LocalizedStringImpl.
There is a lot of duplication that could be prevented IMHO.
This needs to be in the request
This needs to be in the constructor.
This needs to be in the request for every API.
It would be better to use the same outcome as above: assertThat(response, is(RESPONSE_EXPECTED_BY_EPDQ))
It would be better to use the same outcome as above: assertThat(response.asString(), is(RESPONSE_EXPECTED_BY_EPDQ))
It would be better to use the same outcome as above: assertThat(response.asString(), is(RESPONSE_EXPECTED_BY_EPDQ))).extract()
TranslationFormat.USX
TranslationFormat.USX?
> Passwords?
Does this method need to be public? It seems like it would only be called from within the package.
Does this method need to be public? It seems like it would only be called from within this class.
Does this method need to be public? It seems like it would only be used for testing.
This will throw EOFException.
Same: why 8?
This will cause a lot of memory leak. Can you wrap this in a stringbuffer?
>byte[] [](start = 11, length = 6) DecryptResult
>byte[] [](start = 11, length = 6) Decryptor
Just use withContext()
Same here, see if these can be static
This doesn't compile the Pattern.compile()
This doesn't compile the Pattern.compile()?
style nit: we don't use braces around single line blocks
style nit: deepEquals use curly braces for single statements
style nit: deepEquals use curly braces for single line blocks
Do these need to be public final?
Do these need to be final?
if both are equal, then these can be 1.
You can use <LINK_0>
You can use GDKLabel.DEFAULT_SIE here as well.
You can can use <LINK_0>
It seems strange to me that a RexLiteral (and a RexLiteral) is created with a @Nullable Boolean, but why it is used here?
It seems strange to me that a RexLiteral (and a RexLiteral) can throw an exception. If it is, that should be handled by the caller.
It seems strange to me that a RexLiteral (and a RexLiteral) can throw an exception. If it is, that should be handled by the method above.
Map.of is superfluous.
By default, this is no longer needed. There are no more options to reach this code.
By default, this is no longer needed. There are no more options to reach this behavior.
I would change this to Collections.unmodifiableList(Arrays.asList(operands)); (since there is a java.util.Collections)
I think that we need to make this a List internally instead of a List.
I would change this to Collections.unmodifiableList(Arrays.asList(operands));
And this method should be private
And this method returns boolean
And this method returns boolean.
mock mock as you did in the other tests
mock to the value you want to pass in null
mock to the value, not the other way around
throw new IllegalArgumentException(value)
re-wording?
throw new IllegalArgumentException(value);
possible NPE?
possible NPE? eContainer is null
useful
return doubles[index] == null;
Probably this should return false? That way it's impossible for backward compatibility.
Probably this should return false?
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _getCurrentModel().setFocus(true);_
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _getCurrentActiveValue()_ once and store the result in a _context.getScenarioGridPanel().setFocus(true);_
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _getCurrentModel().setFocus(true);_?
Could we rename the method untrackView() so it's clear that the view is called after untrackView()?
Could we rename the method untrackView() so it's clear that the view is called even when we cancel the view?
Could we rename this method to super?
This line seems to be formatting too long.
This doesn't seem to test how the HyperLogPlus is built.
This doesn't seem to test how the HyperLogPlus is created.
use ShellIsAvailable
use ShellIsAvailable(this)
use ShellIsAvailable <LINK_0>
Please add @since 2.1.7 - experimental to all of them.
Please add @Override @Override public void setInbox(Inbox inbox) {
Please add @since 2.x. Also, please add curly braces.
you don't need to do this.
you don't want to do this.
you don't want to do this.printStackTrace()
If you're using Boolean.TRUE.equals( computeResource) then please remove the == true.
If you're using Boolean.TRUE.equals( computeResource) then please remove the == true test.
If you're using Boolean.TRUE.equals( computeResource) then please remove!.
I think you can do: java try (producerClosingLock) { try { Thread.currentThread().interrupt(); } finally { closed = true; } }
I think you can do: java try (producerClosingLock) { try { Thread.currentThread().interrupt(); } catch (Throwable t) { logger.debug("Error closing lock", t); } } }
I think you can do: java try (producerClosingLock) { try { Thread.currentThread().interrupt(); } finally { closed = true; } } }
Could we just have a toString() with the dataType and dataType as in the DataInfoImpl?
Could we use toString() here as well?
Could we use toStringHelper?
Please, also change this to Util.SDK_INT < 16?
Please, also change this to Util.SDK_INT < 23 || player == null
Why can't you synchronize this in onResume()?
is this method necessary?
is this method needed?
wait.forElementClickable()
public?
public
public is fine.
Asserting in the middle of the class is generally considered bad style. How about 'assertNotBefore'?
Asserting in the middle of the class is generally considered bad style. How about 'protected'?
Asserting in the middle of the class is generally considered bad style. How about 'assertNotSupport'?
Remember to put an else block here.
Remember to put an else block around the if/else block.
Remember to put else/else block after :smile:
Why is this needed?
Why isn't it public?
Why is this needed? It doesn't seem to be display the command.
Use a for-each loop here?
Use a for-each loop here too, to make the code more readable.
Use a for-each loop here too.
If we use Stream.ofAll() on the line above, we could remove the @Override annotation.
If we use Stream.ofAll() on the line above, we could collapse the overrides and keep the deprecation altogether.
If we use Stream.ofAll() on the line above, we could collapse the overrides and keep the method unchanged.
This should return /model/model.
This should return /model/model/
This should return List<String>.
will "return false" be enough here?
will "return false" be more readable?
will "return false" when it is null?
We should also call getArguments() in here.
We should also call getArguments() in this activity.
We should also call getArguments() in onCreate().
PR looks fine, but we should also have a test for this.
.format()
PR looks fine as though, about this.
rename 'child'
rename 'e'
rename to child
use Collections.singletonList()
ImmutableList.of
use ImmutableList.of()
Generally, I let eclipse generate this kind of code for me. Do you think it would be better to change the equals implementation to use Objects.equals for code field?
why are you removing the PrestoWarning class constructor?
why are you removing the null check?
to be consistent, cast to Config is unnecessary
to be consistent, cast to Config is sufficient
config is a non-primitive object, cast to Config is redundant
Could you please change this line to String.format("fullyQualifiedMethodName", element.getClassName(), '.' + element.getMethodName());
What if the className name is _are_ specific?
What if the _are_ adding the predicate?
Maybe rename this method to make it clear that it is not called anywhere.
Maybe make this method private?
Maybe make this method private.
If you use Collections.emptyList() here.
Missing null check
Missing final
This is wrong. EncloseRepairAction and forceUnlock throws RepairAction.RESET. That's why I suggested it.
This is wrong. EncloseRepairAction and forceUnlock throws RepairAction.RESET.
This is wrong. EncloseRepairAction and forceUnlock throws an Exception.
We can remove AuthorizationUtils.getHivePrincipal(principal) as it's not consistent with getHivePrincipal.
We can remove AuthorizationUtils.getHivePrincipal(principal) entirely.
We can remove AuthorizationUtils.getHivePrincipal(principal) as it's not consistent with getHivePrincipal().
Use ImmutableMap.withParameters(key, slice) instead of key.
Use ImmutableMap.withParameters(key, slice) instead of this line
Use ImmutableMap.Builder
Is it worth having a filterSpec.getBlobLimit() method that filterSpec.makeSortable()?
Is it allowed to return -1 or should it throw an exception?
Is it allowed to return non-null?
Please also log as error message.
Please log as error message.
Please also log ERROR message.
Could have @VisibleForTesting annotation. Also could public be removed?
Could public be removed? Also could public be removed?
Should public be removed? Also could public be removed?
this.ownerUuid = checkNotNull(ownerUuid, "ownerUuid")
same here. Add the ownerUuid and lockThreadId as well.
this.
Can you remove the public modifier?
Can you please remove the public modifier?
Can you please remove the public modifier? Thanks!
use new Guid(String) - this literal can't be null
use new Guid(result) - this literal can't be null
use new Guid(String) - this literal can't be null.
Please add braces on the for loop.
Please add braces around the for loop.
Please add braces on the for-loop.
Is this message more useful?
Is this message more useful? What happens if no form field value was found?
Is this message more useful? What if getValue is null?
We should probably add a message
We should probably add a message (must be backward compatible with <LINK_0>?
We should probably add a f parameter check
I don't think this should ByteString.Builder.
I don't think this should ByteString.Builder returns the right type of byte[].
I don't think we should use byte[] here, since it is not needed.
I would really hope that we would really fail more than just checking for the message. Why do we need this?
I would really hope that we would really fail more than just checking for the specific message.
I would really hope that we would not need the RateLimit, just above
Factor out.
Suggest throwing an exception instead.
Factor out logical variable.
Just a thought, but we must have a variable for value. What do you think?
Just a thought, but we must have a variable for value. It is safer to use as a variable.
Just a thought, but we must have a variable for value. It is safer to use value.
what's the purpose of modifying the code here?
Why remove the final?
why private?
You don't have to add this here. The resource will be added to PERUNOBSERVER when calling filterNotAuthorizedResource on the resource.
You don't have to add this here. The resource will be added to PERUNOBSERVER when invoked from the servlet container. And also, I think PERUNOBSERVER is not a supported operation...
You can use forEach here.
Do we need to create a new instance of ConnectionlessBootstrap here?
Do we need to create a new instance of this tracker here?
Do we need to create one of these?
Why not return an Optional here?
Why not return an Optional<Consumer>?
Why not return an Optional<Consumer> instead?
can we also remove this?
can we also refer the table \\* is not supported?
can we also refer the table \\* is defined instead of.?
you can check the content of the configuration file
you can check the output contains the one of the expected file
file
This logic duplicates the code in Entities.newDownloader
This logic is duplicated in 2 places, can we factor it out?
This logic duplicates the existing code.
Since this does not work correctly, use INTENT_PROCESS_TEXT()
Since this does not work withWIDGET, the line above is always executed.
Since this does not work correctly, use INTENT_PROCESS_TEXT() instead
@jglick-style violates the recommended code style. Please do something like: initializer.deterministicScheduler.tick(ASYNC_INIT_DELAY* 5 + 1, TimeUnit.MILLISECONDS);
@jglick-style violates the recommended code style. Please do something like: initializer.deterministicScheduler.tick(ASYNC_INIT_DELAY * 5 + 1, TimeUnit.MILLISECONDS);
@jglick-style violates the recommended code style
Looks like you should have null check here.
Seems like you should have null check here.
Seems like you should have null check here too.
again, please use logger.debug("DriverListener->captureUpContext(driver);
again, please use logger.debug("DriverListener->captureUpContext(driver)
'backUpContext'
I am unsure how to feel about the divider. I know it's in the dialog, but on this page, it just seems... off.
I am unsure how to feel about the divider. I know it's in the dialog, but on this table, it just seems... off.
I am unsure why the divider should be available, but on this page, it just seems... off.
(should be for (final LineRange line : this.lines.collection()) {
(should be on the same line)
(should be on the same line, but we should never use braces)
Local variable not required. You can directly populate the class level variable this.serversArr = new ArrayList<GlusterServerInfo>(serversArr);
Local variable not required. You can directly populate the class level variable this.serversArr
Local variables please.
missing ;
Nit: it is missing the ;
Nit: it is missing in ;
This would be more appropriate.
This would be smaller as a string.
This would be more verbose.
Should a string be declared as a constant?
Should be CHANGELOG_VALUE_KEY
Should be CHANGELOG_VALUE_KEY.
can vfsList.get(0).getCapabilities() return null?
vfsList.get(0).getCapabilities() is the equivalent of needsSequentialWriting?
vfsList.get(0).getCapabilities()
suggestion location.at(inputFile.newRange(issue.line(), issue.endLine(), issue.endColumn()));
suggestion location.at(inputFile.newRange(issue.line(), issue.endLine(), issue.endColumn()))
suggestion location.at(inputFile.newRange(issue.line(), issue.endLine(), issue.endColumn());
@ekondrashev move this assignment to line 103 above.
@ekondrashev move this assignment to the next line
@ekondrashev move this assignment to the next line.
either change the method name to refreshLunsToUpdateInDb (I guess the if is the same as the method name) or add the boolean flag to the method - its clearer what it is doing and what it returns.
either change the method name to refreshLunsToUpdateInDb (I guess the if is the same as the method name) or add the boolean flag to the method - its clearer what it is doing and what it's doing
either change the method name to refreshLunsToUpdateInDb (I guess the if is the same as the method name) or add the boolean flag to the method - its clearer what it is doing and what it's actually used
The API is only available in ASTNode as the parameter, so this line is not necessary.
The API is only available in ASTNode as the parameter, so this line is redundant.
The API is only available in ASTNode as the parameter, so this line can be removed.
this is a duplication of the code in traceToMap and above
this is debugToMap()
this.
suggestion fail("exception expected");
suggestion assertEquals(e.getMessage(), contains("bucketCount"));
suggestion assertEquals("Exception expected",e.getMessage(), contains("bucketCount"));
The original code just used to return p4.latestChange();
The original code just used the return value of this method. Is it really necessary to create a new copy of the file?
this method can be private
use the "MD5" key for a final field
1. Do we need to check for null here?
use the "MD5" constant
Unnecessary call to super
Unnecessary call to super()
Remove call to super
I would use a CountDownLatch here instead of sleeping because it doesn't make sense.
I think wait (1ms) should be enough here, right?
I think wait (1ms) is enough here, right?
after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().validateEntity( } remove union (like you did in name validation)
after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().validateEntity( new IntegerValidation(1, 1000000); }
after the former validation, add this line: int maxAllowedVms = getModel().getNumOfDesktops().validateEntity(
All of this can be replaced with an ExecutorService
All of these can be replaced with an ExecutorService
All of this should be replaced with an ExecutorService
Why don't we set these in the System.out?
Why do we need these output?
Why aren't this private?
How about the case where it is equal to processId and processId?
How about the case where it is equal to processId?
If statement is not needed.
Do you want to log this at info level for debugging purposes?
I would log this at info level for debugging purposes.
I know this is nitpicky, but " threads to enforce retention policy" is a typo in log message, not necessarily in the log message
please add final keyword.
please add final to the separate empty line.
please add final to the new line.
Extra spaces around =
Extra spaces around =,!=
Extra spaces around =,
We should rename this to use FileSizeExceededException or similar.
We should rename this to use FileSizeExceededException or some other naming convention.
We should rename this to use FileSizeExceededException or similar to the method above
I wonder if this change would result array allocation and extra cpu/memory consumption issues
I wonder if this change would result in changing the behaviour of the Context. The proper way to do this is to add paramaterized logging to the caller's execute method.
I wonder if this change would result in changing the behaviour of the Context. The proper way to do this is to add paramaterized logging to the caller's output.
Lines 95-102 should be extracted to a method since it is used in other tests.
Lines 95-102 should be extracted to a method since they are used in multiple tests.
Lines 56-76 can be removed.
This optimization should be done in the iterator as well, for performance reasons.
This optimization should be done in the iterator, optimize first, then loop over the elements.
This optimization should be done in the iterator as well, for performance reasons
remove "list"
This should be params.
This should be parametrised
Same as above: could use searchPacksAgain
Same as above: can use searchPacksAgain
Same as above, could use searchPacksAgain
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do some other tests really seem to be possible.
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation.
The list supplier should fail, using an empty list.
Name 'a' must match pattern '[a-z][a-zA-0-9]*'. [CheckStyle] <naming
Name 'randomImage' must match pattern '[a-z][a-zA-0-9]*'. [CheckStyle] <naming
Name 'coordinate' must be used at the same time.
suggestion final List<Permission> roles = jwt.getClaims().stream().filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)).map(Permission::valueOf).collect(Collectors.toList());
suggestion final List<Permission> roles = jwt.getClaims().stream().filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)).map(Permission::valueOf).collect(Collectors.toList()); return new User(subject, roles);
suggestion final List<Permission> roles = jwt.getClaims().entrySet().stream().filter(entry -> entry.getKey().startsWith(ROLE_PREFIX)).map(Permission::valueOf).collect(Collectors.toList());
I would prefer to include a line break here.
I would prefer to keep the explicit threshold like this in the other read functions.
I would prefer to keep the explicit threshold like this in the other read methods.
Use an else-if to combine the two nested if's
Use an else-if to combine the two nested if statements.
(and more line) tab
[minor] It's probably better to use Long instead of long
[minor] It's probably better to use Long instead of long here
[minor] It's probably better to use Long.valueOf(Long)
Is this still here? If so, I recommend removing this.
Is this still performing the normal case?
Is this still necessary?
Short of mPacket here, but I think this should be > 0_.
Short of mPacket here, but it would be simpler to move this change to handleStopKeepalive
Short of mPacket here, but I think this should be > 0?
This does not take a message, it takes the id of the resource that is missing. Here I would just use the no-arg constructor.
Here I would just use the no-arg constructor.
Here I would just use the no-arg constructor: <LINK_0>
This change should be reverted.
Typo
This change was only for testing / testing
We should remove previous call to printStackTrace() here as it will be re-spam the logs.
We should remove previous call to Util.createEmptyThread().
We should remove previous call to sleeps.
should the variable result[1] be replaced with result[1]
should the variable result[1] be get updated if it is not null??
Initialize with result[0]
try { } catch (Exception e) { }
try { } catch (Exception e) {
try { } catch block } catch(Exception e) {
else if (SecurityUtils.isHadoopWebSecurityEnabled())
else if (SecurityUtils.isHadoopWebSecurityEnabled()) {
Configuration and Configuration are not needed here
please rename to deviceList
u could inline _result variable here and in the next line.
u could inline _result variable
we should probably check in the canExecute whether we reached the end of the list
we should probably check in canExecute whether we reached the end of the list
we should probably check in the canExecute whether we reached the end of this list
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
Usually we use RequestMonitor.isSuccess() here
Usually we use RequestMonitor here
I'm not sure if this is right. This method could be made private
I'm not sure if this is right. This method is only called once per property. Is this why we don't have any callers?
I'm not sure if this is right. This method is only called once per property. Why not have the fetchHints take care of fetching both properties?
The Exception is never thrown.
The 'throws Exception' is never thrown.
The Exception is never thrown..
LOG.info("Ignoring request to connect(), ue.getClass());
LOG.info("Ignoring request to connect(), ue.getMessage());
LOG.info("Ignoring request to connect(), ue);
It's more readable to extract "filename" to a constant.
It's better to pass in DataHandler.getDataSource().getName(),ns and use it here
It's better to leave the default filename in here
How about having the timeout as a parameter to the return value of this method instead?
How about having the timeout as a parameter to the return value of this method instead of having the exception type?
How about having the timeout as a parameter to the throwHandlingMetrics?
Not sure if anyone is able to overwrite a table, but is there a reason for changing this?
Not sure if anyone is able to overwrite a table, but is there a reason for this change?
Not sure if anyone is able to overwrite a table, but is there something else?
This could use a soft assertTrue statement.
This could use a assertTrue statement.
This test case seems to be more comfortable.
Same here with the similar logic.
Same here with the similar logic
Same here with the usage of the same logic
Please add java doc
Please add java doc here: <LINK_0>
please add java doc
Basically the same issue as mentioned above, I believe.
Basically we don't need this assertion, I believe.
Basically we don't need this assertion. It is done by invoking abortProcessInstance() which ensures that task execution has been executed and it actually has finished.
not sure why we need this?
not a good idea to increment timeout here why you increment it in the first place?
not a good idea to increment timeout here why you increment it in the first place.
Typo: nitpick: _nonnull_
No need to check the type.is annotation() here. Warning is only called if the type is required
No need to check the type.isAnnotation() first
Why do we need this setting? Can't we set something of the sidecar properties here?
Why do we need this setting? Can't we set it to the value of setContainer attribute?
Why do we need this setting?
This isn't right. You'll stomp all over anything passed to it.
This isn't right. You'll stomp all over anything passed to it's own variable that was mutable.
Remove the parentheses and just!=
Instead of setting it in the slave, what do you think about it to be null or!instanceMetaData.isEmpty()?
Instead of setting it in the slave, what do you think about it to be null?
Instead of setting it in the slave, what do you think about it to be null or!null?
Since the survey is no longer used, it could be removed from the setMonitoringGroup to MonitoringGroup
Since the survey is no longer used, it could be removed.
Since the survey is no longer used, it could be removed from the setMonitoringGroup() method.
It's a bit strange to have the same name as keyToField, validated, keys.toArray(new String[0])
It's not a performance optimization, but if you move the redactedFieldNames to the beginning of the for loop you can avoid the two loops.
It's not a performance optimization, but if you move the redactedFieldNames before the loop you can get the index from the list directly.
I'd do it like this: java return String.valueOf(content);
maybe more of the work to do in a more general way?
maybe more of the work to do in this loop?
It looks like this one could be implemented with a single assertion too, e.g. RootWithOverloads(Collections.<Class<?>, Object> provider)
It looks like this one could be implemented with a single assertion too, e.g. RootWithOverloads(Collections.<Class<?>, String> provider)
It looks like this one could be implemented with a mock, or two (see below)
Could you remove braces
Could you please remove braces
Please remove braces
I also agree with DbWriteOperationsBlockedException
throws DbWriteOperationsBlockedException Same for other places use this method.
throws DbWriteOperationsBlockedException Same for other methods in this class
Maybe it would be better to move this to the beginning of the method.
Maybe it would be better to move this to the beginning of the function.
Maybe it would be better to move this to the beginning of the function?
no need for if
no need for this var
no need for this, can be removed
Style-nit: we don't use curly braces around single line blocks
Style-nit: we don't use curly brackets around single line blocks
According to this [the spec](<LINK_0>, the CommitService interface was deprecated and should not be updated.
This is too broad and is swallowing exceptions that need to be propagated.
this is too broad and is swallowing exceptions that need to be propagated.
You can directly return loaded here.
@m-g-sonar I don't think we should include the note in the error message.
@m-g-sonar I don't think we should include the note in the error message. I'm not sure what the user is trying to mark the note as read from the API.
@m-g-sonar I don't think we should include the note in the error message. I'm not sure what the user is trying to mark note as read from the API.
this can be done with streaming, right?
this can be done with streams, and be optimized
this is not localization friendly
Please use the new method, and extract the method to a new method.
Please use the new method, and method name.
why?
Could you please show me an example of how it works?
Could you please show me an example of how this works?
I'd suggest writing the parse (e.g., using Object) method to handle the type, and removing the else.
Instead of this, I would rather have it be a PREFETCH_DIR_NAME. It can be a constant.
Instead of this, I would rather have it be a PREFETCH_DIR_NAME. It's a constant.
Instead of this, I would rather have it be a PREFETCH_DIR_NAME. It's a unique file name.
@ikhvostenkov please name it json
@ikhvostenkov again json, please name it json
@ikhvostenkov again json, maybe this variable should be just json
nit: change this to String.format()
nit: change this to String.format()?
nit: add a space after "with id: "
We should mutualize a hasTag (probably in stats)
We should mutualize a hasTag (probably in stats) here.
We should mutualize a hasTag(probably in stats)
Can be replaced with call to computeIfAbsent.
Can be replaced with call to putIfAbsent.
Can be replaced with call to computeIfAbsent().
Isn't obs.getObsId() already tested on the previous line?
Isn't obs.getObsId() already tested on the previous statement?
Isn't obs.getObsId() already tested on line 103?
Please use injection for FenceVdsCommand
You should use here getVds().getVdsEventListener().
Please use injection for FenceVdsCommandBase.
This lost a warning here, I think we should let callers handle this method, something like: Optional<Symbol> resolved = types.stream().map(id -> t.resolveMember(memberName)).filter(Optional::isPresent).map(s -> s.orElse(null)).filter(Objects::nonNull)); return resolved.iterator().next();
This lost a warning here, I think we should let callers handle this method, something like: Optional<Symbol>> resolved = types.stream().map(id -> t.resolveMember(memberName)).filter(Optional::isPresent).map(s -> s.orElse(null)).filter(Objects::nonNull)); return resolved.iterator().next();
This lost a warning here, I think we should let callers handle this method, something like: Optional<Symbol>> resolved = types.stream().map(t -> t.resolveMember(memberName)).filter(Optional::isPresent).map(s -> s.orElse(null)).filter(Objects::nonNull)); return resolved.iterator().next();
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
I don't think these checks are needed - the NullPointerException will be thrown down the chain anyway?
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway? Or NullPointerException?
I'd move this above the shader-related lines, as it is related to the FBO instead.
I'd move this above line, as it is overly long.
I'd move this above the shader-related lines, as it is related to Line 324.
Could you replace this and any occurrences of this PR?
Could you replace this and any occurrences of LSSerializer with: LSSerializer.getDomConfig().write(Arrays.asList(n, encoding));
Could you replace this and any occurrences of LSSerializer with: LSSerializer.getDomConfig().write(Arrays.asList(jar, encoding));
Could this be at the trace level since it's not going to be seen by the callers?
Could this be at the trace level since it's not going to be used?
Could this be at the trace level since it's not going to be seen by the logs?
Should we be doing this in the outside if block?
Should we be doing this in the parent if block?
Should we be doing this in the R.id.imageTitle?
not needed, 'java.nio.file.Files#copy(in)' can be used here
not needed, 'java.nio.file.Files#copy(in)' can be imported statically
Update this file with the new code.
Is this related to metrics? Or something else?
Is this related to metrics? Maybe warn?
FakeVertxExecutor
I think this should be removed entirely here, because the adapter is also added in the WPAndroid ReleaseAdapterAdapter, but that's ok.
I think this should be removed entirely here, because the adapter is also added in the WPAndroid ReleaseAdapterAdapter, but that's ok
I think this should be removed entirely here, because the adapter is also added in the WPAndroid Adapter, but that's ok.
Are we sure that we should only import the Java type and not the LanguageType? Or include the installationType property.
Are we sure that we should only import the Java type and not the LanguageType? Or include the test in the version, right?
Why not use the data type of ToolClient here as the default?
Do we need to change this to FragmentationDuplexConnection?
Do we need to change this to FragmentationDuplexConnection?
do we need to change this to FragmentationDuplexConnection?
simpler to say if (clusterCenters.length!= 0) {
simpler to say if (StringUtils.isEmpty(clusterCenters)) { return new ClusteringModel(App pullingUtils.buildMiningSchema(i), i); }
simpler to say if (StringUtils.isEmpty(clusterCenters)) { return new ClusteringModel(App pullingUtils.buildMiningSchema(i).longValue())); }
This should be parseDomains(domainsArguments) and the method name should be parseDomains.
This should be parseDomainsString, to avoid the null check.
This should be parseDomainsString, to avoid the length of 8 lines.
Is this going to be a problem? Shouldn't we just call the notDisplayNotificationLogic(originalNotification) here?
Is this going to be a problem? Shouldn't we just call a method showNotification here?
Is this going to be a problem? Shouldn't we just want to display this?
Value currency
Do we really need 2 types of mappings? Should we just use getValue?
Do we really need 2 types of mappings? Should we just use getValue(newBucket)?
We can't compute here because of the content type and calculate progress reported on the collection.
We can't compute here because of the content type and setting it and it'll little up a bit here.
We can't compute here because of the content type and calculate progressing.
This method is not used. Why not just call this method in the File constructor?
This method is not used. Why not just call this method in this class?
This method is never used.
I would add the resourceType and resourceCrn as well to the msg.
I think it is worth to add the resourceType and resourceCrn as well to the msg.
I think it is worth to add the resourceType and resourceCrn as well to the msg. As it is now the only place it can be used to convert the resourceType and resource details to String values.
I think this is meant to be moved within the if (executor.inEventLoop()) { block below?
I think this is meant to be moved within the while (executor.inEventLoop()) { block below?
I think this is meant to be moved within the while (executor.inEventLoop()).
I don't like catching exception and just let it bubble up. Can you just throw Exception so that the test can handle it?
I don't like catching exception and just let it bubble up. Can you just throw Exception so that the stack trace is logged.
Can we just log the exception?
Embed the caught exception in the newly thrown exception
Embed the caught exception in the newly thrown ex
Embed the caught exception in the newly thrown exception?
That's not a good idea. :smile:
That's not a good idea. ;)
Call it acquireLock and acquireLock?
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a very rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace our service. I am ok with this, though.
prefer Strings.isNullOrEmpty()
need space after if
prefer Strings.isNullOrEmpty(umask)
IOException will be thrown if MappingMetaData is not valid json, right? (populateColumn doesn't throw, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think?
IOException will be thrown if MappingMetaData is not valid json, right? (populated table does that don't fail, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think?
IOException will be thrown if MappingMetaData is not valid json, right? (populateColumn doesn't throw, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think? (populate)
is this intentionally unused?
is this intentionally needed?
can you remove the catch?
"bytes 0-4194304" -> "4194304"
This should be header.
"bytes 0-4194304" -> "null"
I don't think this is necessary now, but just "releasedOnTime" is ok (and if the value is -1, the user can't set theReleasedOnTimeForOngoingAppDownload) either. The underlying issue should be that if the value is not set, the user can't see it and think about a bug.
I don't think this is necessary now, but just "releasedOnTime" is ok (and if the value is -1, the user can't set theReleasedOnTimeForOngoingAppDownload) either. The underlying issue should be that if the value is not set, the user can't see it and think about a failure.
I don't think this is necessary now, but just "releasedOnTime" is ok (and if the value is -1, the user can't set theReleasedOnTimeForOngoingAppDownload) either. The underlying issue should be that if the value is not set, the user can't see it and think about a better way to determine the value of the underlying frozen when it is set.
We need to be able to handle the exception message here.
Why do we need to catch this exception?
Why do we need to catch an exception here?
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, charsetMatch).
Not a fan of this if within the if which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the test?
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about final String charsetMatch = null?
why is this needed?
why is this necessary?
why is it necessary to cast this?
Same as above. Also you can return void
Same as above. Also you can return void.
Same as above, we should return void.
log the exception too
perhaps this should be debug
else
Do we want to remove remove "oldPost.getStatus()" as well?
Do we want to remove remove "oldPost.getStatus()" as well? Won't it be enough to just check the oldPost.getStatus() of the newPost at the beginning?
Do we want to remove remove "oldPost.getStatus()" as well? Won't it be enough to just check the oldPost.getStatus() of the newPost at the beginning of the method?
"To..." is baseline and not "and"
"To..." is baseline and not "is...
"To..." is baseline and not "and"...
This is still a bit difficult to follow. Perhaps it would be better to introduce a method for this.
This is still a bit difficult to follow. Perhaps it would be better to introduce a method "getSingleTask(String taskType)" which returns a List<String>.
This is still a bit difficult to follow. Perhaps it would be better to introduce a method "getSingleTask(String taskType)" which returns an ArrayList<String>.
I am wondering if we should also remove the non-deprecated output partitioning scheme from the original PartitioningScheme. But I understand it was an example before: PartitioningHandleReassigner executablePartitioningHandle = outputPartitioningScheme.getPartitioningScheme().map(s -> s.asFunctionPartitionedPartitioningHandleIfNecessaryHelper(s, fragment.getPartitioning(), isReplicatePartitioningHandleAny(), outputPartitioningScheme.isReplicatePartitioningHandleIfNecessary(s, fragment.getPartitioning(), fragment.getPartitioning()));
I am wondering if we should also remove the non-deprecated output partitioning scheme from the original PartitioningScheme. But I understand it was an example before: PartitioningHandleReassigner executablePartitioningHandle = outputPartitioningScheme.getPartitioningScheme().map(s -> s.asFunctionPartitionedPartitioningHandleIfNecessaryHelper(s, fragment.getPartitioning(), isReplicatePartitioningHandleAny(), outputPartitioningScheme.isReplicatePartitioningHandleIfNecessary(s, fragment.getPartitioning(), fragment.getPartitioning());
static import
This is really not needed. CommandBase#1256 sets CommandEntity.commandStatus to FAILED in this case.
I really don't like the concept of "command.proceedWithColdRun" to be honest, I feel like it will be better to just set it to FAILED in this case.
I really don't like the concept of "command.proceedWithColdRun" to be honest, I feel like it will be better to just set it to false in this case.
[minor] ImmutableList.<String>of should be enough here.
[minor] ImmutableList.<Row>of should also work and avoid the try
[minor] ImmutableList.<Row>of should also work and avoid the try catch
Maybe add a new variable for "m_excludedGroups"
Maybe we should use StringBuilder here?
Maybe add verbose "s" and "s" (or similar)
This may not fail if it's not an error. Have you tested?
This may not fail if it isn't a failure. Have you tested?
This may not fail if it's not a failure. Have you tested?
Do we need to handle the contextMenuHandler in the initContextMenu method? Also, do we need to remove the event.getError() here?
Do we need to handle the contextMenuHandler in the initContextMenu method? Also, do we need to remove the event.stopPropagation() here?
Do we need to handle the contextMenuHandler in the initContextMenu method? Also, do we need to remove the event.stopPropagation() line?
Shouldn't we wrap the dispose call in a finally block?
Shouldn't we at least dispose the disposed widget?
Shouldn't we dispose the Ebrs?
Is there any better way to wait for the connection to be sent? Reloading the server will block and wait for it to come up and fail.
Is there any better way to wait for the connection to be sent? Reloading the server will block and wait for it to come up each time.
Is there any better way to wait for this loop? It won't wait any more than the timeout for the next test case.
I think tests utilizing the actual logic would be preferable, either via utilizing the ConnectionMock or ESTestWithServer.
I think you'll need to use either Arrays.copyOf or iterate over the elements and print individual StackTraceElements if it's not null.
I think you'll need to use either Arrays.asList or iterate over the elements and print individual StackTraceElements if it's not null.
Space after "if"
Space between if and (
Space before "public"
iteration over the list?
iteration over list?
code style
Shouldn't we throw an exception here?
Shouldn't we throw an exception if the code fails?
Shouldn't we throw an exception here?
Do we really want to always assume Latin-1?
Do we really want to always hardcode one character?
Do we really want to always assume GIT?
Why do we need this set?
newHashSet?
newHashSet()
Can be simplified: java this.operatorSpec.registerNextOperatorSpec(partitionByOperatorSpec); return this.graph.getIntermediateStream(opName, serde);
Can be simplified: java this.operatorSpec.registerNextOperatorSpec(partitionByOperatorSpec); return this.graph.getIntermediateStream(partitionByOperatorSpec);
Can be PARTITION_BY.name().toLowerCase() in the IntermediateMessageStreamImpl class, to avoid creating a variable for it.
It should be true in the finally block.
It will not work if current is null. You need to check is not null.
It will not work if current is null.
there is no need to check for this.
there is no need to check for this. prefix
it would be better to have this as a constant
Can we add Locale.ROOT also on Windows?
Can we add Locale.ROOT also on the other directories that now use SSL?
Can we add Locale.ROOT also instead of new ClientConfiguration?
This is not needed since calculateLatency already takes a long.
I don't think we need to support this metric. Let's talk about it with @pfink
This is not needed since calculateLatency already takes a long
style nit: we don't use braces around single line blocks
You should not be passing the baseFile in as a parameter. Also, why not just pass the'refs/heads/*' as the parameter?
You should not be passing the baseFile in as a parameter. Also, why not just pass the'refs/heads/*' as a constant?
Use Map as variable name.
Use Map.of()
Use Map as variable name
nit: space between if and (
Nit: space after if
Possibly move the if statement to a separate method;
Use [String.format](<LINK_0>,%20java.lang.String,%20java.lang.Object...)) instead of string concatenation.
Use [String.format](<LINK_0>,%20java.lang.String,%20java.lang.Object...)) instead.
Use s.append(".SERVICE=wfs.service.url") instead of srs?
Should this be removed?
Should we need a logger?
Should we need a logger at least?
Same here; updateProductContentMappings should be private
Same here; please remove this semicolon.
Same here; please remove this java product class.
This code is code consistency, maybe we can call the file getE() method with getFileType() in PcapOldFile.
This code is code consistency, maybe we can get rid of this one.
This code is not available in PcapNg, if you have a file, it is a waste of time.
I prefer to keep the static import.
I prefer the static import.
I like the static import.
Was this the test test pass?
Was this change made sense?
Was this method name meant to be ignored?
I wonder if we could just do a set? What do you think?
I wonder if we could just do a set? What do we need to do about it?
I wonder if we could just do a set? What do we need to do for the concreteIndices?
rename to project
rename toDiffProject
rename to entry
Missing {} inside the if {}.
Personal preference: In this case you can use the Java 8 stream API.
Missing {} inside the if-clause.
I think this check is no longer necessary?
I think the logic here should be in the constructor(String sql, long startTimeNanos, long queryExecutionMillis) method.
I think the logic here needs to be in the constructor(String sql, long startTimeNanos ) method.
Won't this cause the perf impact?
error level: hence discontinuing chunk stream at {}
error level: {}
field.getChildren() is a pretty abstract class. Does this need to be public?
field.getChildren() is a pretty abstract class. Does it make sense to move this to ParquetStructColumnReader?
field.getChildren() is a pretty abstract class. Does it make sense to move this to a StructDescriptorImpl?
I think this is more readable if statements are followed by a condition: if (existing!= null) { return; }
Would it be better to change it to error level?
I think this is more readable if statements are followed by a while... single line blocks.
I usually like to the previous word if it just makes the code more readable, try again instead of the word "toggle"
I usually like to the previous word if it just makes the code more readable then "try again"
I usually like to the previous word if it just makes the code more readable, try again instead of the previous one
Seems like this can be null.
Seems like this can be null-safe.
Seems like this can be null-safe?
I think this should be: java new ConnectionException("Failed to retrieve Page", ConnectionException.CONNECTIVITY, ConnectionException.class);
I think this should be closed as a RuntimeException
I think this should be called.close()
this and the ones below are very similar - can we break them into smaller methods?
this and the ones below are very similar - can we break them into smaller ones?
this will throw a runtime exception, right?
are you sure you want to throw this exception?
are you sure you need to throw this exception?
Catch the exception to log the error.
Can you use a stream?
Can you use String.join?
Can you use ObjectUtils.join?
nit: put with the previous line
nit: put each argument in a separate line
nit: put colStatsList in a variable
We should ignore this, but the error message should be: "Resource Not Accessible".
We should never have any info to run because this is the only message we can't find. Please, but looks to be missing.
We should never have any info to run because this is the only message we can't find.
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In your case I'd consider doing leveraging function overloading to make this code have less conditionals.
Doing these instanceof checks in Java isn't an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.
Is this necessary?
We should also modify the same dialog still affects the same dialog.
The foreground colour should also be reset to true (and a refresh)
**equals**?
**f**ha!
redundant line
This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an error to the caller instead of ignoring and continue?
This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an exception to the caller instead of ignoring and continue?
This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an error to the caller instead?
We could declare message in the try-with-resources, then move the null check inside and delete the catch block.
We could declare message in the try-with-resources, then move the null check inside and delete the finally block.
We could declare message in the try-with-resources, then move the null check inside and delete the null check.
I'd rename this to getDiscrepanciesJson
I'd rename this to getDiscrepanciesJson to indicate it is a string.
you should have null check for Discrepancy before trying to parse this attribute.
Is there any way to avoid sleep here?
Is the sleep necessary? We are waiting for the kafka client to finish?
Is the sleep necessary? We are waiting for the kafka client to work on this thread.
Is it possible to do try-with-resources for this method instead of doing it manually?
Is it possible to do try-with-resources for this method too?
Is it possible to do try-with-resources for this method?
Isn't it one of the cases where there is no node instance?
Isn't it one of the cases where the nodeInstance is not the root node instance?
Isn't it one of the cases where the nodeInstance is null?
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
While we're in here, could you replace that with this: for (Object selectedObj : structured.iterator()) {
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {... }
style nit: missing braces
Put brackets around the if statement
Put brackets around conditional statements
Why do we need to create the EmitterProcessor each time we create the EmitterProcessor? Can we create the EmitterProcessor that will have the same logic?
Why do we need to create the EmitterProcessor each time we create the EmitterProcessor? Can we create the EmitterProcessor that will have the same options?
Why do we need to create the EmitterProcessor each time we create the EmitterProcessor? Can we create the EmitterProcessor that will have the same logic.
should we throw an exception here?
should this method return void?
should this method throw an exception?
volumeId can be null
volumeId
lock
The exception is being logged twice.
The exception is swallowed here.
The exception is Wikibase error, not the full user.
Why do you need this? Merge to the one in the other files.
Why do you need this? Merge to the one above.
Why do you need these?
I think we should still check the value of this step here.
I think we should still be checking the value of this step here.
I think we should fix this.
Can we use CalciteUtils.unparseSqlIntervalLiteral instead?
Can we use CalciteUtils.unparseSqlIntervalQualifier(writer, interval.getSign(), true);?
Can we use CalciteUtils.unparseSqlIntervalLiteral()?
How is this related to the refactoring? IMHO the placeholder for message here should be just the values of message
How is this related to the refactoring? IMHO the placeholder for the whole conversion is required.
How is this related to the refactoring? IMHO the placeholder in the'message' is required.
I see that it's not really a code that you've introduced, but do we need it for the future PR?
I see that it's not really a code that you've introduced, but do we need it in ErrorCodes?
I see that it's not really a code that you've introduced, but do we need it in an enum or a map?
Change this to store the class instead of reused?
Change this to store the class instead of reused.
Change to store the class instead of reused
This could be a static method, so it doesn't need to be instantiated every time we call this method.
This could be a static method, so it doesn't need to be instantiated every time we call toString().
static URI create(URI current, URI target)
This isn't right. The test will fail if the exception is thrown, which is what we want.
This isn't right. The test should fail without any message.
This isn't right. The test is throwing an exception.
This should also be private.
This could be private.
This can be private.
We should extract this to a method: getRefreshRepresentationsCommand(boolean isAutoRefresh)
We should extract this to a method: RefreshRepresentationsCommand(boolean isAutoRefresh)
We should extract this to a method?
Add a check here to verify that the serialDataReceived method was not called.
Add a check here to verify that the serialDataReceived method was not called?
Add a check here to ensure that the serialDataReceived method was not called.
nit: Please use Objects.equals for this in "isAssignableFrom"
nit: Please use Objects.equals for this.
nit: Please use Objects.equals for this in case of a list.
can you elaborate on the purpose of this change?
can you please rename the local host as well?
can you elaborate on the purpose of this PR?
[nit] use new ArrayList<>();
[minor] use new ArrayList<>();
[nit] use new ArrayList<>(2)
Shall we rename DB_LAST_VERSION to DB_LAST_VERSION_WITHOUT_MIGRATION_SCRIPT?
Shall we rename DB_LAST_VERSION to DB_NOT_FOUND or something like that?
Shall we rename DB_LAST_VERSION to DB_NOT_FOUND or something similar?
You can update the exception message a bit as: "The namespace of the edge must match the namespace (%s) in our namespace (%s)"
You can update the exception message a bit as: "The namespace of the edge must match the namespace (%s) in our namespace (%s). To add the namespace, you should add the namespace into the exception message.
This Extra Formatting seems off.
[Entity::getNumberOfUnitsByType](<LINK_0> always returns a non-null Vector. I wonder if this if test can be dropped to simplify the code (and perhaps future proof it). Thoughts @neoancient @mkerensky @NickAragua?
[Entity::getNumberOfUnitsByType](<LINK_0> always returns a non-null, I wonder if this if test can be dropped to simplify the code (and perhaps future proof it). Thoughts @neoancient @mkerensky @NickAragua?
[Entity::getNumberOfUnitsByType](<LINK_0> always returns a non-null Vector. I wonder if this if test can help to help future proof the code (and perhaps future proof it). Thoughts @neoancient @mkerensky @NickAragua
please remove alias setting (should be encapsulated in addManagedDevice
please remove alias setting (should be encapsulated into addManagedDevice
please remove alias setting
Tool tips can be slightly more detailed. Sometimes just a one word may not be enough.
Tool tips can be slightly more detailed than "col". Sometimes just a one word may not be enough.
Tool tips can be slightly more detailed than just "col". Sometimes just a one word may not be enough.
I think you should keep the try
The hashCode() and equals() implementations depend on the current position in each payload's ByteBuffer. The implementations can also process the same payload bytes as it recurses through the child packets. The payload should process the whole payload regardless of current position.
The hashCode() and equals() implementations depend on the current position in each payload's ByteBuffer. The implementations can also process the same payload bytes as it recurses through the child packets. The payload should process the current position in each payload's ByteBuffer.
.toString() not needed
toString is not needed
toString is not needed here
Might be better to use WARN level, but INFO level seems more appropriate.
You should check for ERROR_MESS_FAILED first.
I'd expect an WARN level message here.
What if timeoutMs > 0?
What happens if there is no timeoutMs?
What if timeoutMs > 0?
Why did you take out the isTraceEnabled() checks? Do you check for that elsewhere, or just decided to always write traces?
Why did you take out the isTraceEnabled() checks? Do you check for nulls somewhere, or just decided to always write traces?
Why did you take out the isTraceEnabled() checks? Do you check for nulls somewhere, or just not?
I think you should use the initialCapacity for these values.
I think you should use the initialCapacity for these parameters.
I think you should use the initialCapacity for the list.
@mderamos modify the assertion description appropriately
@mderamos modify the assertion message appropriately
prefer the assertion description appropriately
Shouldn't we have a null check here?
I think this should be done in a finally block.
I think this should be done in the finally block.
If the ConfigImpl is already called RxContext. The call to ConfigImpl will be call setContext in that case. The call to ConfigImpl will be not necessary
If the ConfigImpl is already called RxContext. The call to ConfigImpl will do that. The ConfigImpl will be called to create this class.
If the ConfigImpl is already called RxContext. The call to ConfigImpl will be call setContext in that case.
Can you replace this with: int i = addChild(fChildren.size(), child);
Can you replace this with: int i = Collections.binarySearch(fChildren, child, fComparator);
Can you replace this with: int i = addChild(fChildren, child);
I'm not sure about this. I think it's better to have a custom registries for this.
Wrong formatting.
Wrong formatting
use isEmpty()
you can use isEmpty()
use createNewFile
We usually use a BitSet for the blocks.
I think we can avoid using magic numbers here e.g. use CborObject.values().
We may want to use a BitSet for the size.
no need for this.
no need for this check
no need for an explicit remove
Can we rename this.policies to this.customerPolicies? This method is hard to follow with two different lists called "policies"
Can we rename this.policies to this.customerPolicies? This field is hard to follow with two different lists called "policies"
Can we rename this.policies to this.customerPolicies? This method is hard to follow with two different lists called "policies".
why not use the constructor with two arguments? (not so important)
This method is not very descriptive
why not use the constructor with two arguments?
For consistency, using entrySet() should be order.
:bug: you should be able to use a simple for loop here, and avoid the double checked locking.
:bug: you should be able to use a simple for loop here, and avoid the double iterate.
no need for the lock?
no need to do it in ctor.
no need to copy it again, there is no initiator
What happens if it is empty?
What happens if we don't have device id?
why is this extra debug?
This should be moved inside the if block.
This should be moved inside the if check
This should be moved inside the while condition.
This is public API, so there is no need to check for it.
This is public static, so there's a chance of having it public.
This is public static, so there's no need to go through a public static method, right?
also here, seems like we can return a PSI directly or change the message to something like: "WindingOrder is not set" or "WindingOrder is not set"
also here, seems like we can return a PSI directly or change the message to something like: "WindingOrder is not set"
also here, seems like we can return a PSI directly or change the message to something like: "WindingOrder is not set yet"
:thinking:
:-1: (style)
:D
This returns an optional. We should actually check if there are none in findFirst().
This returns an optional. We should actually log the error.
This returns an optional. We should actually log the warning.
This looks like it's not correct. ANNOTATION_PARAMETERS should be thrown before we catch.
This looks like it's not correct. ANNOTATION_PARAMETERS should be created with for loop.
This looks like it's not correct. ANNOTATION_PARAMETERS should be thrown from ClassCastException, not by throwing without having to catch this.
can the locking be skipped?
Do we want to confirm that this is a leader?
can the locking be skipped here?
![Codacy](<LINK_0> Issue found: [These nested if statements could be combined](<LINK_1>
![Codacy](<LINK_0> Issue found: [These nested if blocks could be combined](<LINK_1>
![Codacy](<LINK_0> Issue found: [These nested if conditions could be combined](<LINK_1>
Should not be empty line?
Should not be blank line.
Should not be blank line
Should we have a specific JavaProject here to handle loading of a file?
Should we give this connector to handle a specific exception?
Should we have a specific JavaProject here to handle this?
Should use <code>this()</code> in the base class.
Should use <code>this()</code> in the subclasses.
Might be better to go with PresenterWidget.UiMessages.REQUEST_STRING
Better use [AssertJ](<LINK_0> instead
Better use [AssertJ](<LINK_0> instead.
To be on the safe side, better to use [Optional](<LINK_0> here.
For general case, we should avoid duplicate logic in line 114.
For general case, we should avoid duplicate logic in the test.
Adapters.adapt
Why do we need to hit ARROW-DOWN? Perhaps select the first item then?
Why do we need to hit ARROW-DOWN twice?
Why do we need to do this KeyAdapter?
Worth extracting a new method which just uses one parameter with same name.
Worth extracting a new method with same name?
Worth extracting a new method with a nice name, so we could reuse the most common code.
same question here, do we account for the colo with single replica?
same question here, do we account for the number of contained in currentDcs?
same question here, do we account for the number of contained in currentNumberInDcs?
should be this
Is this intended?
should be this debugging output
Minor: we could use 'false' here.
Minor: we could use 'new'here.
Line break after L230?
I would prefer to define a generic String message in the constructor: "The class '%s' does not have the 'prototype' scope."
I would prefer to define a generic String message in the constructor: "The bean with name '%s' does not have the 'prototype' scope.", or we want to be consistent with that, and the applicationContext.getBean(Configuration.class).length!= 0.
I would prefer to define a generic String message in the constructor: "The bean with name '%s' does not have the 'prototype' scope.", 1L, 2L)
Please add a space after the cast.
Just servletRequest: there's no need to declare the return type as void.
Please add a space after the parentheses.
Missing version but I think we are missing it here.
Missing version but I think we are missing it
Version is a version rather than a default.
If we're called this before then we need to use the material library.
If we called this before then we need to use the material.
If we're called this before then we need to use the material.
You should run./gradlew spotlessApply -- I'm pretty certain that the tab spacing here is wrong (BTW, I personally prefer 4 spaces for tabs).
You should run.transform() here (BTW Specific param support) to run.transform() (without multiple spaces for tabs).
You should run.transform() on tab/ tabs here.
objectRefs.get().acquireReference(object) -> objectRefs.get()?
objectRefs.get().acquireReference(object) -> objectRefs.get()
objectRefs.get().acquireReference(object); is not needed
not necessary to add "this"
externalize string
externalize
this boolean is never used
this method is public
this method is public.
No, this method should be called directly.
No, this method should be called to start the cache.
No, this method should be called before startCounterCache()
System.exit should be used
System.exit should not be used. this is default class.
System.exit should be used better
Yes, we should throw an exception if we don't have a valid user list.
Yes, we don't need a List here.
Yes, we should throw an exception if we don't have a valid user data.
i18n
space
Typo?
this this can be mocked in a @Before method or to avoid duplication.
this this can be mocked in a @Before method.
this this can be mocked again.
For this case, it would be nice to have a static method that checks if the URI is available or not.
just make this an else if?
For this case, it would be good to have a dedicated method for the two roles.
Does this need to be a set?
Does this line need to be before the next line?
Should this be removed before merging?
Can you please change the visibility to only happen in the UI two places?
Can you please change the visibility to only happen in the new code?
Can you please change the visibility of this method?
are the keyValues being a list of missing keys in this list? I don't think this will merge with the first param values.
are the keyValues being a list of missing keys in this list? I don't think this will merge with the first agencyOrigins from input data.
are the keyValues being a list of missing keys in this list? I don't think this will merge with the first agencyOrigins list, and the second agencyOrigins list will be copied here.
@sznicci do we really need to use calendar.add(Calendar.MILLISECOND, estimatedCompletionMillis)?
@sznicci do we really need a Calendar.getInstance() here? Can't we just use System.currentTimeMillis()?
Create a new Date instance for each event.
Will this block have any effect? If so, what does this check generate? Should it be an NPE?
Will this block have any effect? If so, what does this check become needed?
Will this block have any effect? If so, what does this check become a callback?
this looks kind of weird. I'd rather see the variable named 'item'.
this looks kind of weird. I'd rather see the variable name as "item".
this looks odd. Why not use the same message as in the "The given ID is not found"?
Maybe we could factor out this line and use it here. Makes the code more readable.
This line is almost the same as the for loop above. Create a new VBox(elbox.getChildren()) below.
Maybe we could factor out this line and use it here. Makes the code more readable?
Doesn't this change override spilledLookupSourceSupplier from the spilledLookupSourceSupplier?
Why change this?
Doesn't this change override the current behavior?
I think we need to close the context as well
I think we need to close the context in a finally block
I think we should just go with the @Context annotation
I don't like this logging. info
I don't like this logging.info message. We should probably change this to debug
Why don't we use log.info?
Was this the copy-pasted?
Was this the one below?
Was this intentional?
This needs to be outside of the for loop to make sure the player is not null.
This needs to be outside of the for loop to make sure the layout is enabled before continuing.
This needs to be outside of the for loop to make sure the player is not null
Method name is set to English (should be something else, which is not very descriptive).
Method name is set to English (should be something else, but to be consistent with the rest.)
Method name is set to English (should be something else, which is not very descriptive). <LINK_0>
wrong order
Minor: this test is redundant, since it's the same test.
.equals(mockChannel)
Where else if clause is associated with the other methods?
Where else if clause is associated with the other PR?
Why do we need to synchronize on this method?
.append(KOTLIN_EXTENSIONS_OPTION) can be changed to.append(File.separator).append(';')
.append(KOTLIN_EXTENSIONS_OPTION).append(File.separator)
.append(KOTLIN_EXTENSIONS_OPTION);
assertFalse("users' or 'email parameters must be set");
assertFalse("users' or 'email parameters must be set")
Use assertFalse and assertFalse instead of assertEquals
Do we need to check that the environment is not null?
Do we need to check that the environment is _parsed here? I think that we will _always_ want to be able to invalidation when that property is not set.
Do we need to check that the environment is _non_ null?
Could you use a try-with-resources syntax here?
Is this System.out.println() call really needed?
Should this be debug?
Clever.
Unnecessary; you can still remove.
Clever..
Why do we need to convert it to a String here?
Why do we need to convert it to String here?
Why do we need to convert it to a String?
IllegalStateException is not required, we will just rethrow it with the message
IllegalStateException is not required, we will just rethrow it with fail().
IllegalStateException is better than getMessage
I would rather return something like this, because I'm not sure what the best way to allocate a new entry log for each entry.
I would rather return something like this, because I'm not sure what the best way to allocate a new entry log for each entry
I would just return here as we had before.
I don't see any reason to use.equals() here. This.getValue() is not a string, it can be just an array.
I don't see any reason to use.equals() here. This.getValue() is not a string, it can't be null.
I don't see any reason to use.equals() here. This.getValue() is not equal to.
try/catch, return the invoiceDetailEntity.isEmpty()?
try/catch, return a status that is not displayed.
try/catch
HealthComponent would be cleaner.
HealthComponent would be cleaner
not sure if this is needed.
Should this be moved to the info level?
Should this just be removed?
Should this also be removed?
Can we have this delegate to the existing constructor? That way we can reuse the same model twice.
Can we have this delegate to the other builder, to avoid repeated code?
Can we have this delegate to the existing constructor? That way we can reuse the same model again.
why not check for null?
why not check for null? Is it only the Databinding case?
why?
I'm not sure, but it's easier to use Integer.toHexString(id, ID_OTHER) rather than a null value.
I'm not sure, but it's easier to use Integer.toHexString(id, ID_OTHER) rather than a null check.
I'm not sure it's necessary to have a null check here.
Could you configure this pattern for the other extension points, please :)
Could you configure this pattern for the rest of our code (see [Java-81185](<LINK_0>
Could you configure this pattern for the rest of our code (see [JavaMail](<LINK_0>?
nit: if you have a long list, and you don't have to wrap it in a RuntimeException.
nit: if you have a long list, and you don't have to wrap it in a if (initialized.compareAndSet(false, true))
nit: if you have a condition here, and you can remove the if below and just do this.blockLocations.get(blockId).
Try to use Collections.emptyList()
Try to use CollectionUtils.isEmpty instead
Try to use Collections.emptyList() instead
isEmpty
make this first line a bit more readable
make this second if useless
Does not seem to be used
Does not seem to support FQN?
Does not have so much business logic
This is not right
This is not right, we only need to check for SAFE in this case.
This is not right. This should not fail with failure.
How about: if (editorTopIndex!= fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLine
How about: if (editorTopIndex!= fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLine
How about: if (editorTopIndex!= fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(newMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLinePixel(fMinimapTextWidget.getLine
why did you change to static? should be outside of the scope of the patch.
why did you change to final here? should be outside of the scope of the patch
why did you change to protected? should be outside of the public API
paramValues is never used
paramValues.addAll(paramValues)
addAll
please remove alias setting (should be encapsulated in addManagedDevice
missing ', should be VmDeviceUtils#addManagedDevice
missing, true = false
Please use IOUtils.closeQuietly()
I think the tab used elsewhere is spaces, not tabs.
Please use IOUtils.closeQuietly() here.
I bet it should be in another pull request <LINK_0>
I bet it should be in other pull request <LINK_0>
Please be consistent with other pull request <LINK_0>
I think this can be simplified to: if (existingPartitions.get(udbTable.getName() && udbTable.getSchema()) ||!Objects.equals(mName, udbTable.getSchema()) ||!Objects.equals(mStatistics, udbTable.getStatistics()) || udbTable.getPartitions().get(udbPartition.getParameters())) { return true; }
I think this can be simplified to: if (existingPartitions.get(udbTable.getName() && udbTable.getSchema()) ||!Objects.equals(mName, udbTable.getSchema()) ||!Objects.equals(mStatistics, udbTable.getStatistics()) || udbTable.getPartitions().get(udbPartition.getParameters())) {
I think this can be simplified to: if (existingPartitions.get(udbTable.getName() && udbTable.getSchema().equals(mSchema, udbTable.getStatistics()) ||!Objects.equals(mTable.getStatistics(), udbTable.getStatistics()) || udbTable.getPartitions().get(udbPartition.getParameters())) { return true; }
Shouldn't this something "switchNotifications switchNotifications = new SwitchNotifications(notifications.enabled, notifications.disabled);" instead?
Shouldn't this something "switchNotifications" instead of "setConnectionState"?
Shouldn't this something "switchNotifications" instead of "allowing"?
Since we already have the items, shouldn't we move it to the method refreshItems?
Since we already have the items, should we move it to the method refreshItems?
Since we already have the items, shouldn't we move it to the method refreshUserItems();?
I can't help but feel that FakePlayer was implemented here instead of ifs; they are redundant.
I don't think there is a need to either create a separate function or setup it in the manager, if not as ssd is not the default.
I don't think there is a need to either create a separate function or setup it in the manager, if not as ssd is not the default
getDisabledMenuTask() return the same value.
getDisabledMenuText() return the same value.
getDisabledMenuText() return the same name.
If partitionCapacity is null, then we can just return. So we can remove the capacityMap altogether.
If partitionCapacity is null, then we can just return. So we can remove the check.
If partitionCapacity is null, then we can just return the empty map.
Not an exception now. Should we log the exception and throw here?
Not an exception now.
Not an error, this is a log message.
I think we can use featureConfiguration.isEnabled(CppRuleClasses.TARGETS_WINDOWS) here instead
I think we can use featureConfiguration.isEnabled(CppRuleClasses.TARGETS_WINDOWS) here. That will allow the feature configuration to be added in the feature configuration.
I think we can remove the static modifier.
We should probably clean up here and invoke the banner code to render banner ad.
We should probably clean up here and invoke the banner code to render inter-screen.
We should probably clean up here and invoke the banner code to render inter-da
How about using ConfigurationManager.getArguments() for this?
while you are at it, please use Log.e() for this.
while you are at it, please use Log.e() instead of printStackTrace()
I don't think we need all the Math.pow calls.
I don't think we need this.
I don't think we need all the Math.pow() and read-only 1
better to use a thread pool instead of single thread sleep.
better to use a thread pool instead of single threads for performance
better to use a thread pool?
This is the only place where you first check if parameters.clientNameExist is true.
Can you remove the if?
This is the only place where you first declare credentials.
The monitor should be executed in a "before" test.
The monitor should be executed in a "new test" method.
The monitor should be executed in a "new test" method, no?
I actually don't like this solution, as we are now not really re-implementing the interface of sendMessage. Please add a method on the parent and just call it from here.
I actually don't like this solution, as we are now not really re-implementing the interface of the interface with no parameters and moving it to the implementations.
I actually don't like this solution, as we are now not really re-throwing the correct exception.
capability is a candidate for Objects.equals(name, host)
capability is a candidate for Objects.equals(capability)
capability is a candidate for Objects.equals(capability) (with capability)
What about group subject data can't be null?
What about group subject data can't be null or empty, at least group name has to exist.
What about adding validation?
s/is handled/is
.withXXX()
The query spec is always the same. If you don't want to do this.
I don't think we should modify the log level.
I don't think we should retry here.
I don't think we should modify the log level here.
Since these two lines are duplicated in 3 places, maybe we can extract a helper method?
Since these two lines are duplicated in 3 places, maybe we could extract a helper method?
Since these two lines are duplicated in this class you could probably refactor the code using a private utility method on the parent class instead of repeating them.
I know (SOAP_SUFFIX.concat(body) is very long, but still, imo. would be better to use (SOAP_SUFFIX.subStringPayload payload = request.getPayload().getRawContent().toString(); Payload payload = Payloads.newStringPayload(SOAP_PREFIX.concat(body));
I know (SOAP_SUFFIX.concat(body) is very long, but still, imo. would be better to use (SOAP_SUFFIX.subStringPayload payload = request.getPayload().getRawContent().toString(); Payload payload = Payloads.newStringPayload(SOAP_PREFIX.concat(body)); final Payload payload = Payloads.newStringPayload(SOAP_PREFIX.concat(body));
I know (SOAP_SUFFIX.concat(body) is very long, but still, can we use HttpServletResponse.SC_SOAP_SUFFIX.subStringPayload?
COuld we have a message like "Requesting paths for a non-Resource Collection [ {} ] returning empty results."
COuld we have a message like "Requesting paths for a non-Resource Collection [ {} ]; returning empty results."
COuld we have a message like "Requesting paths for a non-Resource Collection [ {} ], returning empty results."
missing the byte order: pcapPacketHeader.order(fByteOrder);
missing order of pcapPacketHeader.order(fByteOrder);
there are two possible performance concerns: 1. The file index is the size of the packet header (incorrectly if missing) 2. the included packet header is the same as the included packet header (incorrectly). That's not what we want to do.
object -> function?
object -> function? Or if you could change it to final Function<String, Long> parseTimestamp
function?
:bug: this will not be necessary.
:bug: this will not be related to the connector.
:-1: String.format
we need to test what happens when we select * from pack_getValue(?, result) and not sql select * from pack_getValue(?)
we need to test what happens when we select * from pack_getValue(?, result) and sql select * from pack_getValue(?) as result can be executed for any reason.
we need to test why i'm not sure about this test
Can we have a test for this?
Can we have a test for this?
Not sure about this one but we have a try/catch for these objects in the codebase, can we throw an exception here?
Don't really need to create a new instance of the class if you have a method: RuleModellerActionPlugin action = new RuleModellerActionPlugin( ruleModeller, eventBus, (ActionInsertFact) action, readOnly ); and then just call action.set( action );
Don't really need to create a new instance of the class if you have a method: RuleModellerActionPlugin action = new RuleModellerActionPlugin( ruleModeller, eventBus, (ActionInsertFact) action, readOnly ); and you can just do: return action.get();
Don't know why the "instanceof" check is there - there is no need to create a new instance for every action.
remove outputChannelOffset.
split this up
-1
Would it be better to call jwt.header(DEFAULT_HEADER_NAME, DEFAULT_HEADER_VALUE)?
Would it be better to use jwt.header(DEFAULT_HEADER_NAME, DEFAULT_HEADER_VALUE)?
Would it be better to call jwt.header(DEFAULT_HEADER_NAME, DEFAULT_HEADER_VALUE)? The benefit would be that the application can easily manage theHeader which is easier to understand by the end of the application.
Magic constant
Magic number
AFAIU, (4)
There's a method called setText(String), that you can use that here to simplify your code.
There's a method called setText(String), that you can use that here to simplify the code.
There's a method called setText(String), that you can use that.
It would be better if we can refactor this part to do the conversion. WDYT?
It would be better if we can refactor this part
It would be better if we can do this in constructor
Inconsistent exception
Inconsistent outcome
final
Please add null check for vdsRettunValueStatus
Please add null check for getStepDao
Please add null check for getVdsDao
You should use registerOperation(operation, localKeyRangesMap) directly.
We should use registerOperation(operation, localKeyRangesMap) instead.
Never.
Here is another one.
Here is another one. This is already loaded.
Here is a one-time check.
In this implementation we are technically susceptible to letting them slip through.
In this implementation we are technically susceptible to letting them slip through here.
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through.
For all the [ {} ] as it may be, but Asset [ {} ] is redundant.
For a null check, would it be considered as a Boolean?
For all the [ {} ] as it may be, but Asset or [name] as the property name.
Partitions must be ordered by ID before putting them into the IgniteInClosureX.
Partitions must be ordered by ID before putting it into the IgniteInClosureX.
Partitions must be ordered by ID before putting it in the IgniteInClosureX.
With the requireNonNull, the null check would be redundant... I think...
With the requireNonNull, the null check would be needed... I think...
With the requireNonNull, the null checks would be redundant... I think...
@xembly-b4 same as above.
@xembly-null might be clearer.
@xembly-null might be clearer to introduce a constant for this
you can use the Assert.fail(e) to avoid the catch
you can use the following : for(Tuple2<Integer, Integer> kgi : new ArrayList<>()
you can use the Assert.fail(e) to avoid the catch.
I see it's just being used for testing. But I think it makes sense to move the version into the repository layer. I am not sure if we want to show Stack for a given application. If it does then it should be probably demonstrating that something like what is happening with my mind.
I see it's just being used for testing. But I think it makes sense to move the version into the repository layer. I am not sure if we really need to read the Stack view internally. Can we keep it as a Stack view that holds the application.
I see it's just being used for testing. But I think it makes sense to move the version into the repository layer. I am not sure if we want to show Stack for a given application.
I'd use %s here instead of +
@bgeVam please remove the underscores from the messages
@bgeVam please use String.format()
You should make a constant of "GridFS files". Isn't it defined by someGridFS itself?
You should make a constant of "GridFS files" Isn't it defined by someGridFS itself? Isn't it defined by someGridFS itself?
You should make a constant of "GridFS files" Isn't it defined by someGridFS itself?
@danielezonca I would expect that we should have just: assertThat(result.get("Standard Deviation").is(false)); ServiceResponse<DMNResult> evaluateAll = dmnResult.getContext(); assertThat(result.get("Standard Deviation").is(true)); DMNResult dmnResult = evaluateAll.getResult(); assertThat(result.get("Standard Deviation"), is(false)); assertTrue(result.get("Standard Deviation").is(true));
@danielezonca I would expect that we should have just: assertThat(result.get("Standard Deviation").is(false))
Can we use assertTrue here instead?
you can mutialize this code
You can mutialize this code
you should mutialize this code
I'm not sure if this is the right place for an extra space or an else in the list. Should I be under the if condition since this will always be true?
I'm not sure if this is the right place for an extra space or an else in the list. Should I be under the if condition since this will always be 0?
I'm not sure if this is the right place for an extra space or an else in the list. Should I be under the if condition?
I think it should be "OK".
I think it should be new Address("Winterfell, West()).
I think it should be fine.
could you change the name to something better?
could you change the test in something better?
could you change the test should be something better?
Are lucene low level methods still supported?
Are lucene low level functions still supported?
Are ) there any reason to change it?
doc
check if index is in the range
doc?
Please, use "guid" instead of "asGuid(snapshot.getId())".
Please, use "guid" instead of "asGuid(snapshot.getId())", it's more readable.
Please fix the method signature. It's not clear what it is for - it's an "Command" method.
You can make it new this variable name
You can make it new this variable definition
You can make it new ArrayList<>();
I might be wrong but it seems that the classes.remove(other) is called twice in the same transaction. I would rather see a check on the return value of this method.
I might be wrong but it looks a bit strange to check if the parameter is null, rather than checking if it is null.
I might be wrong but it looks a bit strange to check if the converter is null here.
We can use this for loop: assertEquals(instructors, instructorAccountsActual.size());
assertSameContentIgnoreOrder has this, so you can remove the unnecessary import-access.
We can use this for loop: assertEquals(instructors, instructorAccountsActual.values());
suggestion filtered = StringUtils.replaceEach(input, searchList.toArray(new String[0]), replacementList.toArray(new String[0]));
suggestion filtered = StringUtils.replaceEach(input, searchList.toArray(new String[]{}), replacementList.toArray(new String[0]));
suggestion filtered = StringUtils.replaceEach(input, searchList.toArray(new String[0]), replacementList.toArray(new String[additionalValueValue])
Please change this to: log.debug("initializing {}", taskClass.getName());
Please change this to: log.debug("initializing {}", taskClass.newInstance());
Please change this to INFO level
Maybe } else if (request.getElements().length == 0) { request.done(); return false; }
Maybe we can extract this to a method since it is called in the UI thread?
Maybe } else if (request.getElements().length == 0) { request.done(); return false;
I think using Path.of() as a type parameter is less brittle and may be easier to understand later. It would be less brittle if you use File.createTempFile() as a stream object instead.
I think using Path.of() as a type parameter is less brittle and may be easier to understand later. It would be less brittle if you use File.createTempFile() as a stream object.
I think using Path.of() as a type parameter is less efficient than FileLocation.of().
final
Change the method name to getTableEditingDomain
formatting
why did we use cast here? can we change it to -1L?
why do we use cast here? can we change it to -1L?
why do we use cast here? can we just use LedgerCreateOp?
One of the need for acceptSession() API was to return user result. So, it should be one or the other.
One of the need for acceptSession() API was to return user result. So, it should be return object.
this should be closed as well
You probably want to expose the CorrelationData class so that we can have more than one set of attribute ids.
You probably want to expose the CorrelationData class so that we can use it here.
You probably want to use some StringBuilder here to add some isPresent checks
Could we make this a local variable instead of magic number?
This seems a bit strange to me. We set the exception to 1 in looperThread.testComplete(). Maybe we can make it a bit better?
This seems a bit strange to me. We set the exception to 1 in looperThread.testComplete(). Maybe we can make it a little better?
style nit: add a space after if
Nice.
sysModule
This variable is not needed here.
This part should be wrapped in a null, rather than returning null.
This variable should be here.
Could you move this to the try-with-resource?
Could you move this to the try-with-resource please?
useless
why not use the trace?
why not System.out.println?
why not System.out?
Can be replaced with java LOG.debug("Content is not dependent on baseURL: {}", message.getResponseHeader().getHeader(HttpHeader.CONTENT_TYPE)
Can be replaced with java LOG.debug("Content is not depleting a base URL", message);
Can be replaced with java LOG.debug("Content is not depleting a base URL", message);.
this is a no-op by design?
This is a no-op by design.
this is a no-op and filtered above, why?
Given that this is verifying "FIELD_NOTIFY_SETTINGS", I think this should be something like FIELD_PARAM_TOKEN and FIELD_PARAM_TOKEN
Given that this is verifying "FIELD_NOTIFY_SETTINGS", I think it's possible to name it as FIELD_PARAM_FORMAT?
This looks like it's possible this could be a NullNode
Make this public.
Make this private.
Make this public and extend the interface?
move to a deleteOnExit
move to deleteOnExit
why?
why do we need this? It doesn't look like we should be good enough. If we can't fix the condition, we should re-throw it.
why do we check for terminated thread? If it is not (or fail) we should log?
why do we need this? It doesn't look like we should be at the start of the method.
I think you need to pass Build.VERSION_CODES.LOLLIPOP here as well.
consider extracting this into a method onOptionsItemSelected(String path)
Can you remove this line?
I'm not sure this is the right way to read this given it's very difficult to read.
I'm not sure this is the right thing to do. The original checkCondition(radius >= 0 && radius < mapSize) should do what you think.
I'm not sure this is the right way to read this given that we only read the final values from the array.
I would just call  prefs.hideEmptyPane(e.getValue()).
I would just call 'if (view.diffTable.getChangeType() == ChangeType.ADDED)' here.
I would just call  prefs.hideEmptyPane(e.getValue()) here.
Why do we need to log this as info?
Why do we need to log this?
why do you need to log this?
assertNotNull please
assertEquals please
assertEquals please?
Add a constant for the name
Add a constant for the title.
Add something like: createEdgeMappingDescription(); createXXxMapping(diagram)
Why is it better to use more than one scope to test?
Why is it better to use more than 1 scope to test?
This is better as more than 1 scope to test.
Shouldn't the finally block be executed in case of exception?
Shouldn't the finally block be executed in case of exception?.
Shouldn't the finally block be executed in the finally block?.
Let's not throw RestAPIException directly, since it will be thrown by the RestAPIException.
Let's not throw RestAPIException directly, since it will be thrown by the client.
Let's not throw RestAPIException directly, since it will be thrown by the RestAPIException to client.
Can we just call a old method that calculates the headers so that we can get rid of this variable?
Can we just call a old handler that returns true?
Can we just call a old toString method that consumes the String?
We need to re-throw an exception here, otherwise it will be swallowed a lot of resources.
We need to re-throw an exception here, otherwise it will never be closed.
We need to re-throw an exception here, otherwise it will be swallowed a lot of exceptions.
this should be numInputChannels?
I'd avoid the hard-coded width here by introducing a new variable (i.e. numInputChannels)?
I'd use the real size here: numInputChannels = 1
This list isn't just an empty empty list?
This isn't just for debug
This list isn't just an empty list?
Missing final
Maybe you can modify src/main/java/org/kie/workbench/common/dmn/client/preferences/EntryLoader.java
No need to wrap
Consider to use negative condition here, so it will just return false when the result is false. Also use the formatter on the if condition (add space between the if and the call to super)
Consider to use negative condition here, so it will just return false when the the result is false. Also use the formatter on the if condition (add space between the if and the call to super)
Consider to use negative condition here, so it will just return false when the super.canDoAction is called. Also use the formatter on the if condition (add space between the if and the call to super)
suggestion Assert.notEmpty(query.getIds(), "No Id define for Query");
suggestion Assert.notEmpty(query.getIds(), "No Ids define for Query");
In what scenario would this throw an exception?
redundant type casting
redundant type declaration
redundant line
You don't need to test this with the current code
You don't need to test this with the previous test because Arrays.parallelPrefix() is the same.
You don't need to test is that we're using the parallelPrefix for the first element...
All of these attributes should be moved to E18n.
All of these attributes should be moved to parent class.
Throw exception?
Isn't a LinkedList better if we don't know about a list?
Isn't a LinkedList better if we don't know for sure?
Isn't a LinkedList better if a list is empty?
The first three lines should be done after the filter.
The first three lines should be done after the log statement.
Can you create a separate method in AbstractTransactionTest?
wrap it in try?
wrap it in try
wrap this in a try?
Not really sure that it should be done right now, because the current SSOStateContainer.serialize() will serialize all different metrics. So I think that we really should rely on the current behavior.
Not really sure that it should be done right now, because the current SSOStateContainer.serialize() will serialize all different metrics.
Not really sure that it should be done in client.
What about making this a public method in TSDB?
What do you think about making this a public method in TSDB? It would be much more intuitive and there isn't a need for a method that does this.
What do you think about making this a public method in TSDB? It would be much more intuitive and there isn't a need for the method to name it.
This method is static, can be made static
This method is "warn", not info.
Log message also
Executor is not needed here
Is this correct?
Is this msg accurate?
Not sure this can be replaced with isPresent()?
Not sure this can be replaced with isPresent()
Not needed
I'm not sure you need this. If you don't subscribe to visitID, then you're not checking for null.
I'm not sure you need this. If you don't subscribe to visitID, then you'll get an instance of the table in your onNext() method.
I'm not sure you need this. If you don't subscribe to visitID, then you'll get an instance of the table in that case.
assertThat(git, not(git)).hasSize(1)
assertThat(git, FILE_D, is(false));
assertThat(git, FILE_D, is(false))
This should be StringBuilder instead of StringBuffer.
I would change this to StringBuilder instead of StringBuffer.
I would change this to StringBuilder instead of StringBuilder
How do we allow for the groupBy to be ordered?
How do we handle short circuit as well?
How about passing in groupBy instead of just groupBy.isUngroupedAggregate().
This could be chained to a single line: AdHocPlannedStatement(ptask.getSQL().getBytes(Constants.UTF8ENCODING), corePlan, ParameterSet.fromArrayNoCopy(generateVoltParams(ptask)), null);
This is missing a space, please.
This is missing a space, no?
replace with log.infoFormat
replace with log.info.
replace with: log.infoFormat()
Can we just say cosmosItemFeedResponse -> Flux.fromIterable?
Can we just call CosmosClient.get().block()?
Can we just say cosmosItemFeedResponse -> CosmosResponse?
Adding try/catch to try block is unnecessary because try with it
Adding try/catch to try block is unnecessary because try with resources for each try can be used.
Adding try/catch to try block is unnecessary because try with resources for each try can throw an exception.
If we want to store the getActivityId in the field, please consider using the activity in the toString() method.
If we want to store the getActivityId in the field, please consider using the activity in the getDashedString() method
If we want to store the getActivityId in the field, please consider using the activity in the getDashedString method.
Is it possible to use try-with-resources with resource for statement? e.g. java try (Connection rs = session.execute(statement)) {
Is it possible to use try-with-resources with resource for statement? e.g. java try (Connection conn = session.execute(statement)) {
Is it possible to use try-with-resources with resource for statement? e.g. java try (ResultSet statement = session.execute(statement)) {
nit: addBlockEncodingFactory and addBlockEncodingFactory
nit: addBlockEncodingFactory and remove the factory, since it's a constructor parameter
nit: addBlockEncodingFactory?
why is this public?
why is this null?
why is this needed?
This codacy is complaining about duplicate call to FSM method. Consider moving it to an agnostic way to avoid duplicate FSM code.
This codacy is complaining about duplicate call to FSM method. Consider moving it to a separate util method.
This codacy is complaining about duplicate call to FSM method. Consider moving it to an agnostic way to avoid the duplicate FSM code.
final
Variable name should be sock or socket
Variable name should be sock or socket?
If you have a custom dayOfMonth, you should also set the dateRange. DATE_OF_YEAR and use it here.
If you have a custom dayOfMonth, you should also set the timezone here.
If you have a custom dayOfMonth, you should also set the dateRange.
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue(), "%") which basically does exactly the same.
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue().length(), "%") which basically does exactly the same.
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue().substring(0, volume.getParamValue().length() - 1))
may be replaced with the generator.setParent("Validation", generator.integer_data, valid.kafkaPort); here. This way we can remove the duplicated strings from the generator class.
may be replaced with the generator.setParent("Validation", generator.integer_data, valid.kafkaPort); here. This way we can eliminate the duplicated code.
may be replaced with the generator.setParent("Validation", generator.integer_data, valid.kafkaPort); here. This way we can remove the duplicated strings from the generator class?
Please add braces. It will be more readable.
Please add java doc.
Please add braces.
I think it could be moved to the top of the method
I think it could be moved to the try block
I think it could be moved to the try block.
shouldn't it be "max(min, max)"?
shouldn't it be "max(min, max), min + interval()"?
shouldn't it be "max(min, max), min + / 2)"?
These two lines should come before the if. (Remove in the other branch.)
This does the same, but is somewhat easier on the eyes: state.setCommitMessage(values[2])
These two lines should come before the if. (Remove in the other branch).
String.equals() should be used instead of ==, but with the visibility of the constants.
String.equals(field.getDatatype())
String.equals() should be used instead of the constant.
We should probably package package package.
We should probably package package package package.
they should probably package private
Why is this synchronized? I don't think, that the previous code was synchronized.
Why is this synchronized? I don't think, that the current code looks synchronized.
Why is this change necessary?
I would prefer to move this into the if statement below since we don't need to make it final.
I would prefer to move this into the if statement below since we don't need to create new objects
I would prefer to move this into the constructor.
Let's do this when it is collapsed into OzoneAcl.
Let's do this when it comes to the omKeyArgs map, just so we can remove the map.
Let's do this when it comes to the omKeyArgs map.
> 0
>FluxUtils.writeOrRead
>FluxUtils.readByDefault
We should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED
We should use FieldUtils.ISUAL_ID here.
We should have tests that pass FieldAttribute.INDEXED.
This should still be done using the executor; just cancel the scan task.
This should still be done using the executor; just immediately.
This should still be done using the executor; just in case evt.getNewValue() is not required.
can you make this final?
The metric is not added here.
The metric is not added here?
ms
ms?
start
Just want to make sure: do you really want to create a string with byteLenght - one single-byte character?
it's "magic numbers" to me. Can you pls..?
it should be package-private for testing.
resource
Could you write this in the try block?
entity
You prefer having a if / else instead of a or in the first if?
You prefer having a if / else?
You prefer having a if / else if?
This is not correct. 1. You must be able to compare the _host with that._cluster.equals( that._host) && Objects.equals(_host, that._cluster) && Objects.equals(_host, that._host.getId()) && Objects.equals(_host, that._host.getId()) The same goes to other methods.
you can use Objects.equals to check for nulls and for the rest of the code
you can use Objects.equals to check for nulls and for the rest of the code (null checks).
If whitelistedKeys contains a span, then there is no need to whitelist it. (It's not consistent with your hack)
If whitelistedKeys contains only one element, you don't want to update this. (It's not consistent with the other span)
If whitelistedKeys contains a span, then there is no need to whitelist it. (It's not consistent with the other sort of issue)
We also need to reset getMaxentModel().getOutcome() at the end (to save errors, test cases for null values).
We also need to reset getMaxentModel().getOutcome() at the end (to save errors, test cases for null values)
We need to reset all other changes as well.
I'd suggest logging here just in case.
I'd suggest logging here as well, for clarity.
I'd suggest logging here just in case. The caller is going to throw Exception.
Typo: "nit" -> "nit"
Is the replica _end_ to exit? If so, this won't work.
Typo: "nor" -> "nor"
used to commence
what is the reason of this?
used to commence?
Should be.filter(this::isNotCompatibleFor26x)
Should be.orElseGet(this::isNotCompatibleFor26x)
Should we also have a test for the 'else' case?
This is exactly the same as the one in the log, while the project is running in the LRU list. Make sure we log the project that come from the project cache size.
This is exactly the same as the one in the log, while the project is running in the LRU list. Make sure we log the project cache size at the same time.
This is exactly the same as the one in the log, while the project is running in the LRU list. Make sure we log the project that the project was hit and the project is deleted.
@bxf12315 the same as above, please use assertThat.
@bxf12315 the same as above, please use assertThat from the AssertJ library.
@vmaletta add final
Please use REQUEST_CONTROLLER_STANDARD_ENDPOINTS to make it more readable.
Please use REQUEST_CONTROLLER_NAME and REQUEST_PAIR_REQUIRED Line
Please use REQUEST_CONTROLLER_STANDARD_ENDPOINTS to make it more consistent with REQUEST_SET.
I guess this is a typo.
I guess this is one of the only reason I got rid of vdsm.
I guess this is a typo. Please change to "ipv4Address"
I think this can be removed.
Why do you need double check?
Why do you need double 'if'?
Could private methods be reduced to private?
Could private void non-public methods be used?
Could you move the null check into the constructor?
s/public//
don't hard code the default?
don't we want this to work with default?
Was it for purpose to fix the formatting?
why do you need to change the visibility of this method?
why do you need to change the visibility of the method?
The method should be declared private
This is a minor thing, but you probably need to call getClass() only once.
This is a minor thing, but you probably need to call getClass().getSimpleName() only once.
highlight this and extract maybe into a method that return bool
highlight this and extract maybe into a method that returns bool
highlight this and extract maybe into a method.
Shall we make ContractTestUtils.readDataset the first time?
Shall we make ContractTestUtils.readDataset the first?
Shall the 3 be replaced with srcs and structure?
@pynicolas Are you sure about this method name? As I understand, it does the opposite
@pynicolas Are you sure about this method? As I understand, it does the opposite
@pynicolas Are you sure about this? As I understand, it does the opposite
please double check that marking the end of things are being done in the right place (that is, do it in the finally if you want to cover all exit paths).
please double check that marking the end of things are being done in the right place (that is, do it in a finally if you want to cover all exit paths).
please double check that marking the end of things are being done in the right place (that is, do it in the finally if you feel like it's happening.
"heap" => "heap"
Should it be null or empty?
Should it be null?
log.debug("Exception while dealing with " + serverCnxnClassCtr,...)
note that we want to add the exception handler to the log.
note: if (serverCnxnClassCtr!= null)
If oobr is not a MIConsoleStreamOutput, then this method method can be private.
If oobr is not a MIConsoleStreamOutput, then this method can be simplified as 'pure' search for user-facing' feature, correct?
If oobr is not a MIConsoleStreamOutput, then this method can be simplified as 'pure'
Suggestion: "--active and --inactive options are mutually exclusive."
Suggestion: "--active and --inactive options are mutually exclusive.");
Maybe change this to addEmails("ALL")?
I think you can use String.format instead.
I think you can use String.format instead of \"\"");
I think you can use String.format instead of string concatenation.
Does it make sense to return index as well?
Does it make sense to add index as a parameter of this method? Or should it be explicit?
Does it make sense to add index as a parameter of this method?
I don't think we need this condition. This does not seem to be true.
I don't think we need this condition. This does not seem to be the case.
I don't think we need this condition. This does not seem to be the case, but just a typo.
Let's move this line below, just before the requiresFBO line.
Let's move the FBO.Type.DEFAULT to the top of the file, to be consistent with the rest of the file.
Let's move the FBO.Type.DEFAULT to the top of the file.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_3>](<LINK_2>![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_3>](<LINK_2>
This might not work. "The lower_SECURITY_SCHEME_FIELD is set to a long format." does it?
This might not work. "The lower_SECURITY_SCHEME_FIELD is set to a long format." There is no reason to use a orElse.
This will always return a long time.
You can't use static imports for those.
You can't use static imports for strings like this.
You can't use static imports for strings in this class.
No need to add these fields here since they are used above.
No need to add these variables here since they're just passing the value directly.
No need to add these variables here suggestion
We should consider to move this to the calling code.
I think we should move this to the calling code.
We should consider to move this method above the move it to the end of the method.
Please use static imports for all these tests.
Please use static imports for the field names.
Please use static imports for all assertEquals.
You could probably move that block to a method and call that method in all 3 places.
You could probably move that block to a method and call that method to have two lines.
You could change that part to a method to call the localTime(a1, b2) method. Similarly for the case in that method.
Style-nit: Space after for
s/Object/Object/
Style-nit: Unnecessary blank line
This object should be used to be a UserReference.
This variable is very badly name if it's the serializedUserReference.
This variable should be called userReference
Maybe "4xx" instead of "xx"?
Maybe "4xx" instead of "5xx"?
Maybe "4xx" is better?
Remove redundant casting.
Remove duplicate code.
List<ERepositoryObjectType> missing
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then it will add another *. We shouldn't add the slash if it already ends with *
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another *. We shouldn't add the slash if it already ends with *
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then it will add another *. We shouldn't add slash if it already ends with *
![MAJOR](<LINK_0> 'Severity: MAJOR') Avoid throwing null pointer exceptions. [![rule](<LINK_1>](<LINK_2>
Please return an empty RepositoryDTO here
can this be in an else clause?
This will throw IndexOutOfBoundsException if the channel names are empty.
This will throw IndexOutOfBoundsException if the channel name is empty.
This will throw RuntimeExceptions if an exception is thrown and just print the stack trace
Two issues here: use jc.getCommands()
Two issues here: have a look here?
Two ms
I think you need to change this method name, also I think you can get rid of a few simpler if/else entirely.
I think you should use here the "if ( null == other.department.equals( obj )" check can be done
I think you should use here the "if" check
This can be simplified to something like: "Plugin brokering process for workspace %s failed.
This can be simplified to something like "Plugin brokering process for workspace %s failed.
This can be moved inside the if statement
Please remove this
Just remove this
This change is a duplicate.
These strings don't need to be converted into constants, these are going to remain constant.
These strings don't need to be converted into constants, these are going to remain constants.
Constants.SETTINGS_TO_ME : TO_COUNT
use BooleanUtils
use null as returned value
use BooleanUtils nonNull
Please rename this to eObjectMatchEngineFactory or something more generic...
Please rename this to eObjectMatchEngineFactory
Please rename this "expression" to "expression"
It would be cleaner to have a method to get the stack trace of the method.
It would be cleaner to have a method to get the error message from the method.
It would be cleaner to have a method to get the exception from the method.
can we make this private?
Can we make this private?
can we make this package-private?
How about moving properties.getReset().getExpirationMinutes() into the AuthorizationUtils and do it there?
Have you tested with an issuedAtToNow?
How about moving properties.getReset().getExpirationMinutes() into the AuthorizationCommand?
I think this won't work. You need to set the private variable in the builder.
I think this won't work. You need to set the private variable in the parent class.
I think this won't work. You need to set the private field in the builder.
Do we want to put this in ContantHolder class?
Do we want to put this into ContantHolder class?
Do we want to put this method into ContantHolder class?
I don't think this optimization of repacing.equals by '=' is correct. I suspect there are cases with dynamic metamodels where the comparison fails?
I don't think this optimization of repacing :(
I would lift this optimization into a private method
String.valueOf()
String.format?
String.valueOf()?
why do we need to check this for null? I would just remove it.
why do we need to check this for null?
please remove this check
Those two lines should be moved to the finally clause
Those two lines should be moved to the else clause as they should be in an else clause
Those two lines should be moved to the else clause
method name should not be capitalized
method should not be public.
method should not be public
You can use a method reference here to "get". It will be more readable
You can use.orElseThrow(...) here to avoid the catch block
You can use Collections.singletonList() here to avoid the duplicate import.
I'd recommend using hasImageEqualTo(String) instead of SuppressWarnings
I'd recommend using hasImageEqualTo(String) instead of SuppressWarnings here, it might be more clear to me.
Is this safe? It might be probably best to just use hasImageEqualTo(ASTComponent.class)
@Serranya same here. See above.
@Serranya use try-with-resources syntax here and below.
@Serranya use try-with-resources statement
Does it make sense to do a check for first element in the list as well? Today if possible and even if something else is possible, the test in this PR is witching.
Does it make sense to do a check for first element in the list as well? Today if possible and even if something else is possible, the test in this PR is setText("mandatory", 3, true);
Does it make sense to do a check for first element in the list as well? Today if possible and even if something else is possible, the test in this PR is setText("mandatory", 3, 230
Instead of accessing the local variable, you can use PlatformUI.getWorkbench().getDisplay()
Instead of calling this, you can use the PlatformUI.getWorkbench().getDisplay() as in: <LINK_0>
Instead of accessing this color, you can use the PlatformUI.getWorkbench().getDisplay() for that.
suggest rename to innerHadoopShardSpecLookup - "hadoopy" is also a bit confusing
suggest rename to innerHadoopShardSpecLookup - "hadoopy" is probably more appropriate.
suggest rename to innerHadoopShardSpecLookup - "hadoopy" is also a bit confusing.
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
I am failing to see the bug in this flow. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFutures.anyOf() will be invoked for all CF which do not execute exceptionally.
You should add a check for the 'is file' too, either before the extension or use file names or both.
You should add a check for the 'not started' case before calling stop. Throwing an exception if the user didn't stop the container.
You should add a check for the 'is file' too, if the user didn't stop it before,
A duplicate?
A duplicate of the name and a class?
A duplicate.
this can be removed as you've added autoConstructionCandidates.
this can be removed
this can be removed.
instead of index.set(int) you could use result.longValue() and result.longValue()
instead of index.get() -> result.longValue() + result.longValue() -> result.longValue()
Consider using lambda here.
Why this change?
I'd rather use a long and double for this to be safe.
I'd rather use a long and double for this, since it's too small to discuss about
what is the reason for switching the back to ".."?
what is the reason for switching the number to the lowStom?
what is the reason for switching the number to the lowStom.getRest() or configurable?
This is a bit odd, let's remove it.
This is a bit odd, let's drop it. It is a relic of re-initing.
This is a bit odd, let's drop it.
> I would assume that authenticationResult.get() will always return null, even if there is an exception. WDYT?
> I would assume that authenticationResult.get() will return an AuthenticationException if there is no cause. WDYT?
intentional?
nit: public static <K, V> BlockBuilder<K, V> createMapBlock(MapType type, Map<K, V> map) { (...) }
nit: public static <K, V> Block createMapBlock(MapType type, Map<K, V> map) { (...) }
nit: let's have static import for
s/networkDto/networkDto
You can add a log to the validation process
You can add a log to the validation process.
Better to use.isEmpty() rather than.count()
Better to use.isEmpty() rather than.size()
Put a space after if
No, this is needed. It's at least in the test code
No, this is needed. It's at least in the test that happens to get the feature.
No, this is fine
I would add the exception to the log statement as SEVERE exception
I would add the exception to the log message as SEVERE exception.
I would add the exception to the log message as SEVERE exception
is it possible to call pools.setClass()?
isn't there a builder for this?
is there a reason to set this to an empty list?
Add a log message in the exception.
why is this being warning?
why is this log message different from the log level?
Incorrect error message. An empty list of what is missing.
Incorrect error message. An empty list of what was missing.
Incorrect error message.
any reason not to use simple.remove() if the group has a message group?
any reason not to use simple.remove()?
any reason not to use add() if the group's message group is a reference?
may want to externalise to a different variable. Please use "equalsIgnoreCase" instead.
may want to externalise to separate the possible values..
may want to externalise to a different variable. Please use "equalsIgnoreCase" or similar
Missing white-space changes.
Missing white-space.
Missing white-space before {
Please don't hardcode such strings in the strings.xml file
Please don't forget a sysout here
Please don't forget a sysout here in the logcat.
Why not keep the original method and move the @Nullable to the upper one?
Why not keep the original method as in the second one?
Why not keep the original method as in the second one? (just curious though)
Consider making this an enum and a constant to improve readability.
static import of PagingCriteria?
Consider making this an enum and a constant.
Don't need line break here as well.
Need to extract this to a method?
Unrelated change?
baseId +diagram
baseID +diagram
baseId +diagram?
What about adding the subscription query handler to the super class?
There's a typo here - I think it's fine to have the '@' in the 'Message'.
There's a typo here - I think it's fine to have the '@Override' annotation in front of it.
Extract to constant for improved readability.
Extract to a constant for improved readability.
Extract to a constant for improved readability, i.e.: String attachmentPrefix = identicalFileName(str);
GitHubSCMTraitDescriptor<?>> dedup = new ArrayList<>(); NamedArrayList.select(all, Messages.GitHub_repository(), NamedArrayList.anyOf(NamedArrayList.withAnnotation(Discovery.class), NamedArrayList.withAnnotation(Selection.class)),
GitHubSCMTraitDescriptor<?>> dedup = new ArrayList<>(all, Messages.GitHub_repository(), NamedArrayList.anyOf(NamedArrayList.withAnnotation(Discovery.class), NamedArrayList.withAnnotation(Selection.class)), true, result);
GitHubSCMTraitDescriptor<?>> dedup = new ArrayList<>(); NamedArrayList.select(all, Messages.GitHub_repository(), NamedArrayList.anyOf(NamedArrayList.withAnnotation(Discovery.class), NamedArrayList.withAnnotation(Selection.class)), true, result);
I think we should only use the set in case we ever need to pass the option in to the constructor. e.g.: public Set<Uri> getAdditionalAttachments() { return Collections.singleton(Uri.SUCCESS); }
I think we should avoid throwing the exception here, if possible.
I think we should only use the set in case we ever need to pass the option in to the constructor.
Please remove a space between LOG.debug and LOG.debug
Please remove the extra space after LOG.debug
Please remove the extra space before the LOG.debug
nit: extra space after 'if'
nit: extra space.
nit: extra space before 'if'
Maybe you can use Arrays.asList instead?
Maybe computeIfAbsent?
Maybe emptyList?
Shall we move character '|' to a constant?
Shall we move character '|' to a separate method?
Curious, why character's'?
I think it's possible to do that more elegant by streaming one list and using iterator of another list in that stream.
I think it's possible to do that more elegant by streaming one list and using lambda approach
I think it's possible to do that more elegant by streaming one list and using lambda, which is nice to have.
This is an extraneous debug statement.
This is an 'else' case. CannedExpression be changed to catch the exception?
This is an extraneous catch that might be removed
I think you also need to check that yamls.size() is also not empty.
I think you also need to check yamls.get(0)
I think you also need to check that yamls.get(0) is also null in some cases.
You should only log this case when there are no group and not VOADMIN. To be consistent with PerunUsers, you should be able to remove this case at all.
You should only log this case when there are no group and not VOADMIN. To be consistent with PerunValidator I suggest to have such case in handling EmptyResultDataAccessException.
Assert.notempty()?
don't you want to add a file?
don't you want to add a new line?
don't you want to add a file that wasn't in the name?
If we want to remove the Instrumentation.getReadTimerContext() call, are you missing a Instrumentation.getReadTimerContext()?
If we want to remove the Instrumentation.getReadTimerContext() call, are you missing a Instrumentation.getReadTimerContext(locatorStr)?
If we want to keep the Instrumentation.getReadTimerContext() call, another one is also fixing the missing Instrumentation.getReadTimerContext().
double check that no group is still here
double check that the group is still here
double check that no bitstream group is created
Use strings from the strings
Use the strings from the Locale parameters
Use the strings from the API
rename to importChange
rename to type
rename to element
did you want to remove this throws IOException as well?
did you want to remove this throws IOException as this method is not used
did you want to remove this throws RuntimeException?
Why is this not based on context.getCurrentUser()?
It seems like this method is not checking context for a special permission. Is this special case handled elsewhere?
It seems like this logic is not part of the API. Is it possible to abstract this out into a method?
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
Should we really use the same lint warnings around this call? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
Should we really use the same lint warning here for this call? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
Could this be declared as a method on the interface?
Could this be a bit more readable?
Could this be declared as a static method?
an extra space.
put "unimportant".
final
Is this necessary?
Is this bit necessary?
Is there a reason to use Runtime here?
Best to log the exception here.
Best to log the exception here as well as we've moved to the executor.
Best to log:
As with others, I would not assert on the result of the operation, only on the resilience strategy being invoked.
As with others, I would not assert on the return value of the operation
As with others, I would not assert on the return value of the operation, only on the resilience strategy being invoked.
This is a constant, so the value should be 10200753.
This is a constant, but the BytesOf metadata is constant.
This is a constant, but the BytesOf metadata is static final.
I believe we should check facility.isAssignedServices() here.
I believe we should check facility.isEntity() here.
I believe we should check facility is not null to indicate roles from the facility.
redundant, remove.
redundant, remove?
redundant
yes, maybe we should rename this type to ArrayNode
yes, maybe we should rename this type to ArrayNode(Object[])
yes, we should have some sort of 3 depends on the meaning of arrayNode here.
In case of db user is not present, please assert that user.getId().equals(sessionUser.getId())
In case of db user is not present, please assert that user.getId().equals(sessionUser.getId()))
In case of db user is not present, could be ">="
i think key.reset() can be moved to the if() block.
i think key.reset() can be moved to the if() statement
That's fine.
why not use the bitset?
why not use the bitset.copy()?
why not use forEach?
Shouldn't the set be inside the writeFile() method?
Shouldn't the intersects and checksumType be discarded here?
Shouldn't the intersects and checksumType be automatically inserted into the file?
I would like to keep the index in the loop. That way we will not need to account for currentMax + max.
Could this loop be avoided by adding a break to the loop? If yes, we would not need to account for currentMax + 1 here.
Could this loop be avoided by adding a break to the loop? If yes, we would not need to advance here, but the iterator might not know enough.
I would prefer to set the field default to null if it is not a non-existing element
I would prefer to set the field default to null if it is not a parameter, to avoid the risk of a concurrent modification exception
I would prefer to set the field default to null if it is not a parameter, to avoid the risk of a concurrent request exception
@mykelalvis please, rename to maven. s is meaningless :)
@mykelalvis please, rename to dashboard. s is meaningless :)
@mykelalvis please, rename to server. s is meaningless :)
please use {}
should it be hashset?
should it be hashset if possible?
This is the same error message as above, so there is no chance for the duplicated code.
This is the same error message as above, so there is no chance to distinguish between these two cases.
This is an error message
I am curious, why not just return the result from the call to reserveFilesForSize?
I am not sure it is useful to have this logic here. If it is possible, we need to have this logic in the future and maybe we can extract it to a method.
I am curious, why not just return the result from the caller?
Companion
Companion is only valid for kotlin...
Companion s
I'd extract diff.getMatch().getComparison().getMatch(diff).getReference().isContainment()) to a variable
I'd extract diff.getMatch().getComparison().getMatch(...) into a local variable
As from the previous patch set, we can check that diff.getMatch().getComparison().getMatch(...) is not null
I am a bit confused about this method. I think it should be private.
I am a bit confused about this method. I can't imagine how this could affect that. Now it's only about the join type definitions, so I believe the method should be protected (i.e. private).
I am a bit confused about this method. I can't imagine how this could affect that. Now it's only about the join type definitions, so I believe the method should be protected; not public.
why did we change the logging to not use assertEquals?
why did we change the logging to not use the annotation?
can we change the logging to assertTrue(schema.isExactly(a, b));
please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method if there is too much condition
please don't do in the middle of method return. use else instead. Also you can always refactor the branch into a separate method if there is too much condition
please don't do the return here. use else instead. also you can always refactor the branch into a separate method if there is too much condition
You should check to see if the bridge is present here to be either OFFLINE or OFFLINE.
You should check to see if the bridge is present here to be either ONLINE or OFFLINE.
You should check to see if the bridge is active on this connection.
This seems like it should handle the exceptionsl ike the Exception
This seems like it should handle the exceptionsl ike the FunctionalException
This seems like it should handle the exceptions that come in
Can downloadBatch be null?
can downloadBatch be null?
Can downloadBatch be null here?
Transport can't be null if it is provided by the try block.
Transport can't be null unless it is provided by the try block.
TransportException is not just a wrapper for other exceptions, so where it is passed to the new sources?
Nit: would be nice to log the content group name here
Nit: would be nice to log the content group name here, just in case we get it.
Nit: would be nice to log the content group name here.
looks like getDefaultStreamProperty will return Optional.empty() if the default StreamProperty is not empty. Is this intended?
looks like getDefaultStreamProperty will return Optional.empty() if the default StreamProperty is not set. Please remove that.
looks like getDefaultStreamProperty will return Optional.empty() if the default StreamProperty is not empty.
If someone calls offset.reset() (topN does this sometimes) then this will be wrong. I think you need some logic to detect the offset going backwards, and resetting the iterator in that case.
If someone calls offset.reset() (topN does this sometimes) then this will be wrong. I think you need some logic to detect offset going backwards, and resetting the iterator in that case.
If someone calls offset.reset() (topN does this sometimes), then this will be wrong. I think you need some logic to detect the offset going backwards, and resetting the iterator in that case.
@aertoria Can we add a well-defined constant here?
@aertoria Can you change the method signature to not have it?
@aertoria Can you add a method to Utils.toLongLong here?
If it is alerted, should we just ignore it?
this should probably be a separate method
this should probably be a separate method.
The optional parameter should be retrieved, like if (savedInstanceState == null) { // If the user is null, don't use Companion in the app.
The optional parameter should be false, but you're not going to use Companion in this class.
The optional parameter should be false, but you're not going to use it.
Should be qnIndx here.
Redundant parentheses.
Should be qnIndx here?
it2
i think this is redundant
it2 is redundant
I think we should use StringUtils.format() for this too
I think we should use StringUtils.format() for this.
I think we should use StringUtils.format() for such things
This should be logged, not info
This should be logged with error level
This should be logged with error
You should have a method that returns an old one then, not return it.
You should have a method that returns an old one and have a replace operation.
Is it necessary to have a method that does this?
Could use a constant here instead.
Could use a standard library for this.
Could use a different Version
Same thing, using this method here may cause the getLineIndex method to return erroneous result, which may cause regressions in customers (I think code minings actually use this method extensively to compute where to draw for instance)
Same thing, using this method here may cause the getLineIndex to return erroneous result, which may cause regressions in customers (I think code minings actually use this method extensively to compute where to draw for instance)
Same thing, using this method here may cause the getLineIndex method to return erroneous result, which may cause regressions in customers (I think code minings actually use this method extensively to compute where to draw for instance).
This is the same code block as below, right? Can we extract it into a constant?
This is the same code block as below, right? Can we extract it into a common method?
This is the same code block as below, right? Can we extract it to a common method?
make sure the restartServer() is called when the component is restarted?
make sure the restartServer() is called when the component is restartable?
make sure the restartServer() is called when the component is restartable
getBigtableStartRow() returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableStartRow() ValueProvider into a "true" or "false" for the ValueProvider.
getBigtableStartRow returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableStartRow() ValueProvider into a "true" or "false" for the ValueProvider.
getBigtableStartRow returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableStartRow() ValueProvider into a "true" or "false" for the ValueProvider. This way the config value will always be non-null.
else { Thread.sleep(); }
else { Thread.sleep(...); }
else { Thread.sleep(); } }
formatting
Why do we need new task plots every time. One should never have it?
Same suggestion here about consolidating like cases
String[].class is the type that might not be needed as a type parameter.
String[].class is the type that might not be needed as the type is String.
String[].class
The 808 will not show up in the output here, since you didn't add a placeholder for it.
The _isNew_ added for the build here, since you didn't add a placeholder for it.
The 808 will not show up in the output here, since you didn't add the list output here, right?
We should also set the theme by the new theme.
We should leave the theme as null by default.
We should leave the theme as null in the new configuration.
Please log the error, don't print it to stdout. What happens to the LAF if an exception is thrown here?
Please log the error, don't print it to console. What happens to the LAF if an exception is thrown here?
This return should be inside the catch block?
String.format?
>=' instead of '?
> BUILD_DATE <LINK_0>
You should not use dockerfile. to call it. You should use it as constructor of crawledDockerfiles and it should be tested.
You should not use dockerfile. to call it. You should use it as constructor of crawledDockerfiles and it should be assigned to it.
You should not use dockerfile. to call it. You should use it as constructor of crawledDockerfiles and command it as constructor of it.
I think this should be: java this.serverPort = FIRST_AVAILABLE_ATTRIBUTE + "-jwtproxy";
I think this should be: java this.serverPort = FIRST_AVAILABLE_ATTRIBUTE.toString(memoryLimitBytes) * MEGABYTES_TO_BYTES_DEVIDER;
I think this should be: java this.server.spi. che.cache.Constants.REQUEST_ATTRIBUTE
I don't think it makes sense to combine this if statement into the one below.
Missing whitespace
Missing space
should this be more strict? i.e. require at least one character inside the parens?
should this be more strict? i.e. require(Pattern.compile("\\s]*\\")
should this be more strict? i.e. require(Pattern.compile("\\s require( )?
It's better to use "Preconditions.checkArgument" here. And it's missing a period "." before "Transaction".
"due to".
it's better to use "Preconditions.checkArgument" here. And it's missing a period "." before "Transaction".
For consistency we should catch all exceptions from the call to getMessages().add(getErrorMessage("changeRequest.developer.notActive"));
For consistency we should catch all exceptions from the call to getMessages().add(getErrorMessage("changeRequest.developer.notActive"))
For consistency we should either throw an exception or log the error (in case this is a bug)
That's a separate variable and a parameter can be used here. Also, it is very confusing to read this log message every single time. Exception message shouldn't be logged as a separate variable.
That's a separate variable and a parameter can be used here. Also, it is very confusing to read this log message wrong. Exception should be logged as well.
That's a separate variable and a parameter can be removed as well.
@pynicolas No need to assign to variable.
@pynicolas No need to assign value of this variable.
@pynicolas No need to assign value of this field.
I think it is better to move the if (this.wrappedCommand instanceof BaseCommand) inside the synchronized block
I think it is better to move it to debug log.
I think it is better to move it to debug log, not info.
it looks like a lot of code duplication
this method should throw a UncheckedIOException
this cast is not needed
As I understand, this is not actually what we want, but why don't we pass the scriptPath to the LOG.info call?
As I understand, this is not actually what we want, but why don't we pass the scriptPath to the LOG.info statement?
As I understand, this is not actually what we want. The only thing that we have is to pass the scriptPath to the execute method. I think it's cleaner to have a method that returns a String or a String.
Why change from'sql' to'sql'?
Why change to '............'?
Why change from'sql' to 'join'?
Should we return an empty list when we intersect it?
Should we return an empty list instead of null? Or would it not be better to have that return an empty list.
Should we return an empty list instead of null? Or would it not be better to have this in another commit?
same thing as above, wdyt about using log4j?
same thing as above, this could be removed
same thing as above.
[minor] Use a switch with a meaningful name?
[minor] Space before the comma.
[minor] Use a switch with a meaningful name.
This seems redundant with the also nested change.
This seems redundant with the also nested change?
This seems redundant with the also nested changes.
This is a spurious change. back it out.
Same statement as above with using lambda and a predicate.
Same statement as above with using lambda could also be replaced with a lambda
It looks like this could be an infinite loop here: indexKeysRecordCursor.advanceNextPosition()?
It looks like this could be an infinite loop here: indexKeysRecordCursor.advanceNextPosition() || indexKeysRecordBuilder.isMemoryExceeded().
It looks like this could be an infinite loop. If indexKeysRecordCursor.advanceNextPosition() is called twice.
I think it would be clearer to create a method isValidTriple(Statement itemTriple) and then re-use that in these if statements instead of creating an arraylist here.
I think it would be clearer to create a method isValidTriple(Statement itemTriple) and use that in these 2 checks to check if the triple exists in the.asString().
I think it would be clearer to create a method isValidTriple(Statement itemTriple) and then re-use that in these 2 checks
It may be better to move the method above getHost and use it here as the base URL will happily use the local cache: URI uri = new HttpHost(uri.getHost(), uri.getPort(), uri.getScheme());
It may be better to move the method above getHost and use it here as the base URL will happily use the local cache: URI URI = uri.getHost(); HttpHost targetHost = new HttpHost(uri.getHost(), uri.getPort(), uri.getScheme());
It may be better to move the method above getHost and use it here as the base URL will happily use the local cache: URI URI = uri.getHost(); HttpHost targetHost = uri.getPort();
Ah yeah it is a set of ICE :)
Ah yeah it is a set of KeySet objects. I am wondering why we use a Set instead of a Set? It seems a bit odd to use a HashSet here instead of a Set.
Ah yeah it is a set of KeySet objects. I am wondering why we use a Set instead of a Set? It seems a bit odd to use a HashSet here instead of a HashSet.
IllegalArgumentException is possible here. I see it is not handled
IllegalArgumentException is possible here. I see it not handled
IllegalArgumentException is possible here. I think it is not handled
I would be more defensive here. I would say that if the container metadata does not contain OPENSHIFT_DEPLOYMENT_LABEL and OPENSHIFT_DEPLOYMENT_LABEL is present but the value is OPENSHIFT_DEPLOYMENT_LABEL is not added to the info.getConfig().getLabels().
I would be more defensive here. I would say that if the container metadata does not contain OPENSHIFT_DEPLOYMENT_LABEL and OPENSHIFT_DEPLOYMENT_LABEL is present but the value is OPENSHIFT_DEPLOYMENT_LABEL is not added to the configuration map. Is it sufficient to log for all container labels?
I would be more defensive here. I would say that if the container metadata does not contain OPENSHIFT_DEPLOYMENT_LABEL and OPENSHIFT_DEPLOYMENT_LABEL is present but the value is OPENSHIFT_DEPLOYMENT_LABEL is not added to the configuration map. Is it sufficient to log this value?
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "create" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "run" method. [![rule](<LINK_2>](<LINK_0>
Missing @Override annotation.
If we're using "just" here, perhaps we should also verify that the expected value is the same as the expected value?
If we're using "just" here, perhaps we should also verify that the expected value is the same as the expected value.
If you're using hamcrest matchers, you could probably write assertThat(..., is(containsString(expected))
One more times(1).
is this empty line ok?
is the same as the test case?
Why do you use a CommandInterceptor here?
Prefer to use TestUtils.catchAndThrow for this kind of test.
Prefer to use TestUtils.catchAndException to catch the exception
Can we pass in _helixManager.getClusterName() if _helixManager is null?
Can we change this to a "debug" log message?
Can we add a log message here?
Ok, but looks like issues with how it works. I was just wondering if we need to establish a connection when there's no connection?
We need to pass the exception down to the createSocket call.
Ok, but looks like issues with how it works. I was just wondering if we need to establish a connection when there's a connection.
Can you use a more relevant variable name?
Can you use a more relevant variable name please?
There's no need for this.
Small nit, but to be consistent, can this be defined as a constant?
Small nit, but to make it a constant, can the builder pattern be reused?
Small nit, but to make it a constant, can the builder be reused?
This code only gets called once after the update has been made, so why do we need another if branch?
This code only gets called once after the update has been made, so why do we need another if block?
This code only gets called once after the update has been made, so why do we need another if?
if maxLogins is 1 or maxLogins then we will assume that the user is not in the map. Is that what we want to do?
if maxLogins is 1 or maxLogins then we will assume that the account service will be locked. Is that what we want?
if this is a valid user we'll be sending.
in this case, the 'else' statement is always true so this could be removed.
in this case, the 'else' statement is always executed if!consoleEntry.isDefault()
in this case, the 'else' statement is always executed if!consoleEntry.isEmpty()
if (m_ifLabelDao == null) { return; }
if (m_ifLabelDao == null) { return ""; }
if (m_ifLabelDao!= null) {
Typo: cannot be read
Throw an exception (e.g....
Throw an exception (e.g. "Unable to read...".
should be part of above method
should be a single line
should be a single line only, not a nested line
Can we shutdown the thread before the shutdown hook?
Can we shutdown the thread before the shutdown hook is finished?
Can we shutdown the thread before the shutdown hook?
How many times this test is running in this PR?
How many nodes are written? (this is not enough. )
How many times this test is running in the teardown method?
This should change to a sleep to avoid sirius waiting for the test.
This should change to a sleep to avoid sirius waiting for a test.
This should change to a sleep to avoid waiting for a few seconds.
Consider extracting to a method for improved readability please.
Consider using parameterized logging format instead of string concatenation.
Consider extracting to a method?
I was thinking if we could end up with a condition in parkPaused, but I believe we could get rid of it then.
I was thinking if we could end up with a condition in parkPaused, but perhaps we could check for stop instead?
I was thinking if we could end up with a condition in parkPaused, but perhaps we should only check if it's a pre-initialized state, which will lead to a false positives.
You don't need to add the click handler here - the menu is missing the click listener.
You don't need to add the click listener to the pagination controller. Leave it as is.
You can probably extract a private constant
So two patterns show up above and it seems great to make them consistent. I wonder if there's a better way to do this.
So two patterns show up above and it seems great to make them consistent. I wonder if there's any better ways to do this.
So two patterns show up in the code? It seems great to make them consistent.
Use HistoryEntry here
Use observeOn here.
Use observeOn here
better to write: Flowable.range(1, 10).doOnCancel(new Action() { @Override public void run() throws Throwable { assertFailure("Unnecessary upstream.cancel() call in FlowablePublishMulticast", parentUpstreamCancelled.get()); } }).awaitDone(1, TimeUnit.SECONDS);
better to write: Flowable.range(1, 10).doOnCancel(new Action() { @Override public void run() throws Throwable { assertFailure("Unnecessary upstream.cancel() call in FlowablePublishMulticast", parentUpstreamCancelled.get()); } }).assertFailure(TestUtils.assertFailure(TestUtils.java: "Unnecessary upstream.run() call in FlowablePublishMulticast", parentUpstreamCancelled.get());
better to write: Flowable.range(1, 10).doOnCancel(new Action() { @Override public void run() throws Throwable { assertFailure("Unnecessary upstream.cancel() call in FlowablePublishMulticast", parentUpstreamCancelled.get()); } }).test().awaitDone(1, TimeUnit.SECONDS);
Can we move this into cGroupsMemoryResourceHandler.prestart()?
Can we move this above cGroupsMemoryResourceHandler.prestart()?
Can we move this into cGroupsMemoryResourceHandler.preStart()?
this could be moved to the maby-engine?
this could be moved to the mamute.properties file
this could be done more efficiently (and potentially save the amount of string concat)
I would have this test within the flow from yield method in fact, so the algorithm is pretty straightforward and the algorithm is pretty straightforward.
I would have this test within the flow from yield method in fact, so the algorithm is pretty straightforward and the algorithm is pretty straightforward so the algorithm is pretty straightforward.
I would have this test within the flow from yield method in fact, so the algorithm is pretty straightforward and the algorithm is pretty straightforward. (and the fact that this is so easy to test and maintain)
Is this still needed if the value gets overwritten in the next line?
In other places in the code we check if the parent is null first, so that we don't do any unneeded computation if the value gets overwritten.
In other places in the code we check if the parent is null first, so that we don't do any unneeded computation if the value gets null.
Would it make sense to move the list-stream into an init() that just configures the list. Instead of removing and re-initializing everything on each entry declaration?
Would it make sense to move the history into an update/refresh/reload function that just refreshes the model. Instead of removing and re-initializing everything on each reload?
Would it make sense to move the list-stream into an init() that just configures the list. Instead of removing and re-initializing everything on each entry that is setup.
Not sure why it is enabled by default. Is it?
This isn't something I wrote on purpose? Is it something for a reason?
This isn't something I wrote on purpose? Is it something for a purpose?
Was this intentional?
Was this intentional? (which I think?)
I think we can do something like the other ones here.
does this not make things fail to compile?
does this not make things run during runtime?
does this not make things a multi-threaded?
nit: "Array element should not be nulll"
Call me a bit more readable: java.util.Objects.isNullOrEmpty(arrayValue, i)
Call me a bit more readable: java.util.Objects.isNullOrEmpty(arrayValue, i);
Should be removed
I think this is a better approach if the extension list extension list is defined as a constant
I think this is a better approach if the extension list extension lists are defined as a constant
the same as above.
the same as above. we should throw a RuntimeException.
the same as above. we should throw a service exception.
I'm going to trust this is doing the right thing (I understand this code is basically just copied and pasted from Apple's examples)
I'm going to trust this is doing the right fix. I understand this code is basically just copied and pasted from Apple's examples.
I'm going to trust this is doing the right fix.
you may want to set a Value that contains the values you want to assert.
you may want to set a Value that contains the values you want to test.
you could use values()
could use a guard clause to reduce nesting.
Why is this needed? The query should return a number.
could use a guard clause
I'm thinking this could be moved into a separate method so you don't have to duplicate one.
I'm thinking this could be moved into a separate method so you don't have to keep track of the additional info here.
I'm thinking this could be moved into a separate method so you don't have to keep track of the extra info here.
I think it would be better to use.opt.value() here.
I think it would be better to use.opt.value here.
I think it would be better to use.opt.value() here since the value is of the house just to be consistent.
Same with the log4j
Same as above for log4j
Same as above for some trace logging
Should this be an IOException?
If an exception is thrown during the edit, could we throw an exception or something?
If an exception is thrown during the save, is it needed somewhere?
change this to node.isPartial()
change this to node.isPartial()?
change this to node.isPartial()?
@maria-farooq we should provide a description to the log message
@maria-farooq we should provide a description here of the log message
@maria-farooq we should provide a description to the log message, such as description
Can we pass in the action parameter?
Can we pass in the action parameter instead of passing down host and on downHosts?
Can we pass in the action parameter? This way we don't have to process the host when necessary.
Rename to "expiration"
Please remove this println.
nit: you can use a logger here and below
PerunClient is valid only for OAUTH2 clients. Otherwise its half empty object, especially client ID is not present. I would prefer logging whole PerunSession, but I understand, that this message should be rather short. But neither PerunSession or PerunPrincipal within it have a short toString(). Please add method in PerunSession like: getLogId() which will return value of actor property, so we can safely change such method to return also extSourceName or other properties. Thank you.
I would prefer the format to use single line, like log.info("{} removed attribute {} from esource.", sess.getPerunSession(), attribute.getName(), resource.getId());
PerunClient is valid only for OAUTH2 clients. Otherwise its half empty object, especially client ID is not present. I would prefer logging whole PerunSession, but I wouldn't prefer it.
the switch statement is not necessary here. The method is simple and it makes things more readable.
the switch statement is not necessary here. The code is simple enough to return if we're dealing with a simple switch.
the switch statement is not necessary here.
If you ever make this public this _ will break the JavaBeans specification.
Can be replaced with: hosts.stream().map(VDS::getVdsDao).collect(Collectors.joining(","));?
If you ever make this public this _ will break the JavaBeans specification. Take a look at the ProjectPropertyExtractor for an example.
this exception in line 76 is not caught.
this exception in line 76 is not thrown in this method
This exception is caught and ignored.
Should the UpdateSite be added to the message of the warning? "Could not collect update site features and plugins", e);
The UpdateSite doesn't need to be initialized with the "resource" version.
Should the UpdateSite be added to the message of the warning? "Could not collect update site features and plugins", e); }
please use StringUtils.join(noticeableTo())
please use StringUtils.join()
please don't use this method
why is it adding this later?
why is it adding this second parameter?
do we need it
Not sure if we need this.
Not sure about this, but maybe it is better to use the builder pattern here?
Not sure about this, but maybe it is better to use the builder pattern to start with the token token code?
there's a race condition here. If we are at the same time for both readers and 10001 then there's a different issue. I don't think you should seek to zero here.
there's a typo in log message
there's a race condition here. If we are at the same time for both readers and 10001 then there's a different issue. I don't think you should seek/seek with the specified number.
Style nit: please always use {} with if statements: if (iterator.hasNext()) { iterator.setAccessible(true); }
Style nit: please always use {} with if statements: if (iterator.hasNext()) { iterator.set(...) }
Style nit: please always use {} with if statements: if (optional.isPresent()) { iterator.setAccessible(optional.get()) }
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this useless assignment to local variable "jobId". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this useless assignment to local variable "server". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this useless assignment to local variable "jobId". [![rule](<LINK_1>](<LINK_2>
This catch block is doing weird things. This is better than using the Java API in the google library, because if you use @Deprecated, you might want to be consistent in this PR.
This catch block is doing weird things. This is better than using the Java API in the google library, because if you use @Deprecated, you might want to be consistent.
This catch block is doing weird things. This is better than using the Java API in the spirit of the code.
Use the jclouds predicates2.retry construct. If this is a common thing to be done, consider creating the predicate and make it injectable so other classes can benefit from it.
Use the predicates2.retry construct. If this is a common thing to be done, consider creating the predicate and make it injectable so other classes can benefit from it.
Use the jclouds predicates2.retry construct. If this is a common thing to be made, consider creating the predicate and make it injectable so other classes can benefit from it.
Sorry, but shouldn't this be AVAILABILITY_INTERVAL * 5);?
Sorry, but shouldn't this be AVAILABILITY_INTERVAL * 5?
Sorry, but I don't think this should be deleted.
Same here. If you read the file, it won't be obvious what is going on.
Same here. If you read the file, it won't be closed.
If you read the file, it will be hard to read.
Could you rename DirectDebitConnectorCreatePaymentRequest to remove the instance? It's not really that important.
Could you rename DirectDebitConnectorCreatePaymentRequest to remove the var? It's not really that important.
Could you rename DirectDebitConnectorCreatePaymentRequest to remove the method as it's used for both create and get
Why.toString() versus just printing the object?
Why.toString() versus just printing out the object?
Why are the.toString() and not.toString()?
This line should be removed, no?
This while loop could be simplified as a while ((Array<String>) {... }
This is a really good idea. The value should be compared as a long, and it should be if ((double) possible).
setErrorMessage
setting the file name is unnecessary here.
setErrorMessage?
final is unnecessary here
This can be final. E.g. final String a = query.suggestByPreferredEmail(a, b, limit - r.size()); final AccountInfo info = dbProvider.get().suggestByPreferredEmail(b, a, limit, visibilityControl);
This can be final. E.g. final String a = query.suggestByPreferredEmail(a, b, limit - r.size()); final AccountInfo info = dbProvider.get().suggestByPreferredEmail(a, b, limit, visibilityControl);
Could you please add clear message for case when assert failed?
Pls log: org.junit.Assert.fail; //we expect impl to return null at least org.junit.Assert.fail(Assert.java:925) at org.junit.Assert.fail("Got exception");
Pls log: org.junit.Assert.fail and get rid of this one
That's just space
This is just space
Typo
We can change this to just a counter.
We can change this to just after the synchronized block.
We can change this to just triggered if the monitor was cancelled after the next operation.
Same here, stage-->i is unused.
This is shared among all the cubes, not just the one registered under the cube.
This is shared among all the cubes, not just the one.
s/lastStartTime/lastEndTime/
s/long lastStartTime/lastStartTime/
s/long lastStartTime/lastStartTime
Do you want to create a separate private method IndexCreator?
Do you want to create a separate private method addColumnMetadataForTextIndex?
Do you want to clear the map index again?
Won't it be safer to use try-with-resources on the factory here?
Won't it be safer to use try-with-resources on the factory here? If not, then derive.
Won't it be safer to use try-with-resources on the factory here instead?
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below the line 187 and remove this check.
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below the line 187 and remove the check.
locks can only be non-null if we entered this code path with a null lock. It is safer to avoid that.
Call.toArray(new CurrencyValuesArray(omation, pair, reportingCurrency)) directly instead
Call.toArray(new CurrencyValuesArray(place, values) instead of copying via List.of
A double[] is a bit redundant, better.
Move this outside of BulkOptions, to keep the constructor private and expose its own access modifier.
Move this outside of BulkOptions?
Move this outside of BulkOptions, to keep the constructor private
just use context as sync obj.
just use context as synch obj
just use context as sync obj
Use the one-argument version of this method
Use the one-argument version of getProject() here
Use one style in this file that has the project name
tc.getResponseSender() == null?
tc.getResponseSender() == null
tc.mandatorySort() can be removed
Please use I18n.
Please add @LayoutRes annotation
Please use I18nife.
I don't think this method needs to be public. It's package private.
oh yea. This method doesn't have to be public.
I don't think this method needs to be public
I don't think you need to assert the result here...
I don't think you need to use await() here, because that is done by the test.
I don't think you need to assert the result here is correct
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused method parameter "protocol". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
This can probably be simplified to java return trade.getInfo().propertyNames().stream().filter(p -> p.equalsIgnoreCase(firstToken)).findFirst();
This can probably be simplified to just a single line return.
This can probably delegate to the method above.
There's already a getMask() method. Make sure to cover both cases.
There's not a guarantee that the first element exists in the list. Make sure to cover both cases.
There's not a guarantee that the first element in the list will be the first element. Make applyDropout check.
s/Count/Count/
s/Count/size()/
Strianging returns null for the first argument is the type that I asked
Please add a check that the file exists in the azkaban.properties file
Please add a check that value is not null
Please add a check that props.getBoolean() is called when it's called
Should be assertThat(e).hasMessageContaining("cannot be cast to java.util.List");
Should be assertThat(e).hasMessageContaining("cannot be cast to java.util.List").
Should be assertThat(e).hasMessageContaining("cannot be cast to java.util.List")
is this empty line ok?
is this empty check required?
is this empty expression ok?
Can you log this exception?
Can you log the exception stack trace before this call?
Can you log the exception?
Need to exit the function here if the table was null.
Need to exit the function here if the table was empty.
Need to exit the function here if theTable was null.
This is going to work reliably, you're making a call to UUID.randomUUID().toString()
This is going to work reliably, you're making a new instance of UUID using this new reference to UUID. So you need to use UUID.randomUUID().toString() to make it work.
This is going to work reliably, you're making a new instance of UUID using this new reference to UUID. So it would be easier to just pass the UUID directly to UUID#toString.
I would suggest using a try-with-resources block here, because that makes it more robust.
I suggest using a try-with-resources block here, because that would eliminate the IOUtils.closeQuietly() warning.
I suggest using a try-with-resources block here, because that would eliminate the IOUtils.closeQuietly() method.
Can we also use JavaConversions here?
Maybe we should pass a valid supervisor here?
Please propagate exception as well.
Tests also need to be context-aware unfortunately, otherwise they end up handling against globally defined sites.
Tests also need to be context-aware unfortunately, otherwise they end up testing against globally defined sites.
Tests also need to be context-aware unfortunately, otherwise they end up handling globally defined sites.
Does this need to be sorted?
Does that need to be sorted?
Does this have to be sorted?
Minor: maybe we can have a constant for this.
Wasn't there a reason why this is a separate declaration?
Wasn't there a reason why this is a different extension?
We should use CircuitBreakerConfig.custom() instead of creating a HashSet
We should use CircuitBreakerConfig.custom() instead of creating a HashSet.
We should use CircuitBreakerConfig.custom() instead of supplier
I would like to have a HyperlinkListener interface that extends HyperlinkListener. This way you can keep its responsibility of a HyperlinkListener in the future.
I would like to have a HyperlinkListener interface that extends HyperlinkListener. This way you can be able to get rid of it and add HyperlinkOnUI.
I would like to have a HyperlinkListener interface that extends HyperlinkListener. This way you can keep its responsibility of a HyperlinkListener in the future. Could you please try to link the refactoring tool?
I would put this to some class/method to avoid code duplication.
I would put this to a class-level static String field, and use that here rather than duplicated code.
I would put this to a class-level static String field, and use it in the class.
Please use [try-with-resources](<LINK_0>,%20java.lang.String,%20java.lang.Object)).
Please use [try-with-resources](<LINK_0> to ensure that the resource is closed even if the test fails.
Line length
This should be moved to the DiscussionPostsAdapter constructor.
This should be moved to, since it will be used only in one place.
This should be moved to the DiscussionPostsAdapter constructor since it's used only in one place.
the 'networksByHost' parameter is not needed, you can remove this line.
the 'networksByHost' parameter is not needed, you can remove this method.
why not using entrySet()?
add a logger
add to the logger
use logger
I think we should change it to debug and not include the actual credentials in the log
I think we should change it to debug and not include the actual credentials from system properties.
I think we should change it to debug and not include the actual credentials in the log.
Will it not be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded?
Will it not be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video and then check from its attribute if particular video or group of videos has downloaded?
Will it not be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded? If yes, this code should take care of that.
s/stashRequestFacade.extractIssueReport/buildNewProcessForm
s/stashRequestFacade.extractIssueReport/getAnalysisAnalysis/
Extra line
can we do this in the constructor so that we don't have to register a file creation time?
can we do this in the constructor and call super.createFileWriter?
can we do this in the constructor and call it here?
Other places we have a static method/class, which does exactly the same thing and does not need to be done explicitly.
Other places we have a static method/class, which will do the same thing and is more reliable.
Did you mean to make the code different?
maybe lets use the new name text?
I would prefer to have a new name text resource _seq_no or something like that.
Why it is "true"?
Just to be on the safe side, save a couple of lines by using TimeUnit.SECONDS.toMillis(timeToLiveInSeconds) without having to TimeUnit.SECONDS.toMillis(timeToLiveInSeconds)
Just to be on the safe side, save a couple of lines by using TimeUnit.SECONDS.toMillis(timeToLiveInSeconds) without having to TimeUnit.SECONDS.toMillis(timeToLiveInSeconds) twice.
Just to be on the safe side, save a couple of lines by using TimeUnit.SECONDS.toMillis(timeToLiveInSeconds) without having to TimeUnit.SECONDS.toMillis(lastAllowedTTLInMs)
"instanceof"
Make this constructor private.
"instanceof".
Should we log the exception in case we can't find the log file after the app is available?
Should we log the exception in case we can't find the menu after?
Should we log the exception in case we can't find the log file after the app is available?
Again, this should be 'error' or 'error'.
That is a good error message. If the developer is trying to read the collection, they can be logged in the user.
Again, this should be 'error'
This is a map, why not just use a list?
This is a string, you should use StringUtils.isBlank().
This is a map, you should use a list instead of casting.
Can be changed to List<MeasurementVariable>
Can be changed to String.format
add final
this is not required, we need to do this if we are not setting this to false.
this is not required, we need to do this if only
this is not required, we need to do this if we are not setting this class.
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the string.
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the message.
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the message from the existing exception.
final IPath pathString = 'path'; and then the local variable is never used
final IPath pathString = 'path'; and then the local path to open it is used again
final IPath tracePath
I think it would be better to store the entire ReaderBlog table in a local variable, so that we can be used for it in other places. wdyt?
I think it would be better to store the entire ReaderBlog table in a local variable, so that we can be used for it in other places. AS is complaining about a potential NPE here.
I think it would be better to store the entire ReaderBlog table in a local variable, so that we can be used for it in other places. AS is complaining about a hard-coded string, wdyt?
Typo: space
Typo: "update"
Typo: "entry"
What's the advantage of returning onBackPressed here since we're essentially passing the object and its contents to the fragment?
What's the advantage of returning onBackPressed here since we're essentially passing the object and its contents to the fragment, rather than the string manipulation?
What's the advantage of returning onBackPressed here since we're essentially passing the object and its contents to the fragment, rather than passing it in to the fragment?
move the check to FollowThreadAction?
move the check into FollowThreadAction
remove the if, it's too complicated.
Deleting the updateAndFeedbackWithStatus() call seems to be the only place where the network status is obtained and the _last_ value is getting set.
Deleting the updateAndFeedbackWithStatus() call seems to be the wrong place for the update.
Deleting the updateAndFeedbackWithStatus() call seems to be the only place where the network status is obtained and the _completed_
String actualText = Text.class.cast(e.widget).getText();
Strings.isValid(currentText)?
text can be changed text by calling Text.class.cast()
Why make a separate param here? This method already takes care of it.
Why subWPAndroid alarmBridge? This is not a question, but it sounds like it would only be relevant to the android app for the host.
Why subWPAndroid alarmBridge?
Bind these in the system module, aka Gerrit-Module. Its much less complexity for anyone to deal with.
Bind these in the system module, aka Gerrit-HttpModule. Its much less complexity for anyone to deal with.
Bind these in the system module, aka Gerrit-API module. Its much less complexity for anyone to deal with.
How about moving this line into the if statement, and remove the duplication?
How about moving this line into the if statement? It will help readability.
Magic number
Style-nit: Parens aren't necessary here around the loop.
Style-nit: Parens aren't necessary.
RevWalk needs to be released after use.
method.getMethod() is already clear. You don't need to extract this method.getMethod()
method.getMethod().equals("") -> method.getMethod()
method.getMethod().equals("") -> method.getMethod()?
Are we sure we can't reuse the activity for this?
Are we sure that we can't reuse the activity for this?
Are we able to use the conversionManager here?
I would add a blank line above this if. The point is in returning a blank list. No point in doing an if check.
I would add a blank line above this if. The point is in returning a blank list.
I would add a blank line above this if. The point is in returning a blank list. No point in returning a blank list.
if you are using this field then visibility can be removed
if you remove the variable then you can change the visibility of this field to 'public'
if you are using this field, then you can change the visibility of getKey to getValue
Should we do an eic?
I think we should make this final. It is not really needed.
I think we should make this final.
Shouldn't this be unsubscribe?
Shouldn't this be assertTrue?
Shouldn't this be unsubscribe()?
Is it great that you've copied this block into a method and just replaced the whole if-else statement in the previous block? For example, if it's more complicated, I think it would be better to be as follows.
Is it great that you've copied this block into a method and just replaced the whole lambda expression by simple method call?
Is it great that you've copied this block into a method and just replaced the whole lambda expression by simple method invocation?
on the catch, let's add a servere logger
Should the whole stack trace be logged? This exception is handled by the notificationSenderCallback
- The exception message should the be logged? This exception is handled by the notificationSenderCallback
I think we should prefer a setter here rather than member variable access.
I think we should prefer a setter here rather then member variable access.
I think we should prefer a setter here rather then member access.
Eh, I would prefer to use the following code: if (Arrays.stream(importedFiles).filter(Objects::nonNull).count()!= 1) { throw new AcceptableThriftTableOperationExceptionType.OTHER, TableOperationExceptionType.OTHER, TableOperationExceptionType.OTHER, TableOperationExceptionType.OTHER, "File referenced by exported table does not exist " + oldFileName); } else { throw new AcceptableThriftTableOperationException(tableInfo.tableId, tableInfo.tableName, TableOperationExceptionType.OTHER, "File referenced by exported table does not exist " + newFileName); }
Eh, I would prefer to use computeIfAbsent here too, and avoid the extra map lookup.
Eh, I would prefer to use computeIfAbsent here, too.
rename to childItem
rename to childItem?
rename to child
suggestion if (lon < 31.0f) { zoneNumber = Math.min(lon, 34.0f); } else if (lon < 33.0f) { zoneNumber = 35; } else if (lon < 33.0f) { zoneNumber = 1.5; } else if (lon < 33.0f) { zoneNumber = 1.5; } else if (lon < 33.0f) { zoneNumber = 1.5; }
suggestion if (lon < 31.0f) { zoneNumber = Math.min(lon, 34.0f); } else if (lon < 33.0f) { zoneNumber = 35; } else if (lon < 33.0f) { zoneNumber = 1.5; } else if (lon < 33.0f) { zoneNumber = 1.5; }
suggestion if (lon < 31.0f) { zoneNumber = Math.min(lon, 34.0f); } else if (lon < 33.0f) { zoneNumber = 35; } else if (lon < 33.0f) { zoneNumber = Math.max(b, 64.0f); }
IMO, it should be a warning, not a warning.
IMO, if there is a lot of a suspected members info, we could log a warning.
IMO, it should be private.
Is it necessary to use a mock here?
Nit: use static import for Mockito.mockitoSession()
Is it necessary to use the mockitoSession here?
Can you check that there is only one patient?
Can you use a more specific exception?
@bgeVam please use a negation here
We use a nonNull check here.
Use Objects.nonNull instead.
Use Objects.nonNull instead of a null check.
What's the up case?
What's the up button in reporter?
Thanks @ash!
new String[]{.txt} should be replaced with ""
new String[]{.txt} should be added to the context of the patch.
new String[]{.txt} should be added to avoid issues with the tests.
Perhaps also desirable to override the [DefaultContext Rule](<LINK_0> with a @Override on the interface.
Perhaps also desirable to override the [DefaultContext Rule](<LINK_0> in this PR and use the @AfterClass method here.
Perhaps also desirable to override the [DefaultContext Rule](<LINK_0> with a @Overrided on the interface.
don't construct a stream, use the logger
don't construct an InputSource on the InputStream, otherwise stack trace
don't wrap
Shouldn't the if clause be dropped?
Shouldn't the if condition be false?
This should be safe to remove the null check if the commonType is not null.
Should you try with resources?
Should you be closing the input stream here?
Should you be closing the input stream once in the file?
isPortMirroring()?
isPortMirroring should be true here?
Shahar, this is redundant.
Sad times, but I don't think we can easily work around this.
Sad times, but I don't think we can easily work around it.
Why does this need to be a separate test?
Shouldn't this be part of the wizard? Is this on one?
Shouldn't this be part of the wizard? Is this on purpose?
Shouldn't this be part of the wizard? Is it on purpose?
shouldn't this be public?
Shouldn't this be public?
shouldn't this return an Optional?
Nit: this is duplicated at line 48, I would get rid of this line.
Nit: this is duplicated at L67, I would get rid of this line.
Nit: this is duplicated at line 48, I would get rid of the line below.
Move the if full then reset logic to line 61 (before getting the block builder from line 68)
Move the if full then reset logic to line 61 (before getting the block builder from line 82 in this class)
Remove explicit initialization.
Suggest creating the replicationMetrics and replicationMetrics.update the same state. In the other methods, replicationMetrics.updateMetadataForRemoteColo() will have the same logic.
Suggest changing replicationMetrics.update to keep this logic.
Suggest changing replicationMetrics.update to keep this logic. In the next iteration, we will have the same logic twice.
Should these heuristics end up switching Chicago, too? I'd think Chicago should really be somewhere in the onedDateTime class
Should these heuristics end up switching Chicago, too? I'd think Chicago should really be somewhere in the one?
Should these heuristics end up switching Chicago, too? I'd expect it to easily be sorted.
In the alert message the alert is not clear if this is alert.
In the alert message the alert is not clear if this is the alert.
In the alert message the alert is not the cause.
I'd suggest to verify the path is the same as what is uploaded to the upload. The /tmp path is the same, no?
I'd suggest to verify the path is the same as what is uploaded to the upload. The /tmp path is the same, but this is the only one that is being created
I'd suggest to verify the path is the same as what is uploaded to the upload. The /tmp path is the same, but this is the only one that is being created.
Feels like this could be more readable: if (catalogEffectiveDate!= null && that.catalogEffectiveDate!= null) { return!phaseName.equals(that.catalogEffectiveDate); } return that.catalogEffectiveDate!= null && that.catalogEffectiveDate.compareTo(that.phaseName)!= that.catalogEffectiveDate;
style nit: we don't use braces around single line blocks
Feels like this could be more readable by inverting the condition first.
You didn't change the above line.
You didn't change the above line. Why you changed it again?
You didn't change the above line. Why closes the try block?
There is a lot of duplication between this and the existing parseResources method
There is a lot of duplication between this and the other parseResources method
Could be defined as a constant
This is meant to have the same effect as the previous one.
This is meant to have the same as public static String
There is no need to have this.
Instead of hardcoding the value, you could have the cluster's available network and get the unknownNodeUrl from that Map.
Instead of hardcoding the value, you could have the cluster's available network and get the unknownNodeUrls from that Map.
Instead of hardcoding the value, you could have the cluster's available network and get the unknownNodeUrl from the RM
typo _start_ -> _stop_
typo _stop_ -> _stop_
typo _start_ -> _stop_?
It would be better to strictly align these variable names with the method names. Since there are methods of both ResourceInformationMethod and ResourceInformationGetValueMethod, I would suggest to also include the class name. E.g., - resourceSetResourceInformationMethod
It would be better to strictly align these variable names with the method names. Since there are methods of both ResourceInformationMethod and ResourceInformationGetValueMethod, I would suggest to also include the class name. E.g., - resourceInformationGetNameMethod
It would be better to strictly align these variable names with the method names. Since there are methods of both ResourceInformationMethod and ResourceInformationMethod, I would suggest to also include the class name. E.g., - resourceSetResourceInformationMethod - resourceInformationGetNameMethod
@ivanarrizabalaga why adding this?
@ivanarrizabalaga Maybe we could add some conditionals in the sharedPreferences.getBoolean call?
@ivanarrizabalaga Maybe we could add some conditionals in the sharedPreferences?
Depending on the EnvironmentSwitchHandler, you may want to create a new instance of EnvironmentSwitchHandler (with a default handler).
Depending on the EnvironmentSwitchHandler, you may want to create a new instance of the EnvironmentSwitchHandler, with the InstanceSwitchHandler.
Depending on the EnvironmentSwitchHandler, you may want to create a new instance of the EnvironmentSwitchHandler, with the 'default' state.
well, the probability is very low, I know, but shouldn't be >= 0 instead of <= 0?
it would be safer to take the lock first and then check-and-update the time stamp
well, the probability is very low, I know, but shouldn't be >= 0 instead of < 0? in that case it should be >=?
So you have default settingsfor userId and NetworkAccessPointId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
So you have default settingsfor userId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
So you have default settingsfor userId and NetworkAccessPointId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. Why is that?
The logic seems backwards. If item.getUrl() returns null, and getUrl() returns null, as it's not used.
The logic seems backwards. If item.getUrl() returns null, and getUrl() returns null, you should check it for null.
The logic seems backwards.
Logic is weird here. I think it would be better to abstract this logic into a separate class.
Logic is weird here. I think it would be better to abstract this into a separate class.
Logic is weird here. I think it would be better to abstract this into a separate method.
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers? Also, I am wondering if it is a good idea to support templates without any id in the backend.
If it is set to true, I would like to handle it.
Seems like we may want to check if the shutdownExecutorService is managed by a single thread, right?
Seems like we may want to check if the shutdownExecutorService is managed by a single thread, and let it throw an exception when it is closed.
Seems like we may want to check if the shutdownExecutorService is managed by a single thread, and let it handle the case when it is created.
should be com.google.common.base.Preconditions.checkNotNull(component, "component is null");
should be com.google.common.base.Preconditions#checkArgument to check if component is an instanceof ISequential
should be com.google.common.base.Preconditions#checkArgument to check if a component is not an instance of ISequential
We should log the exception here too.
if the cluster is modified by another thread, it will be better to log the exception and return it.
We should log the exception here.
This method is only used in this class. Pls rename it to HeliumPackageSearchResult.
This method is only used in HeliumPackageSearchResult. CWL. Shouldn't there be a test to make sure this list works?
This method is only used in HeliumPackageSearchResult. CWL. Shouldn't there be a test to make sure this method always gets called?
If the result is null, that would be a bug.
If the result is null, that would be a bug. We should probably test for null too.
If the result is null, that would be a breaking change. Did you test it?
I'm not sure if this is the right check. If there is a project with the same name then we don't need to sloppy the same packages again.
I'm not sure if this is the right check. If there is a project with the same name then we don't need to recompute it again, which is not the case.
This method should be called after getEachClass.
please add curly braces around the if body
It seems to me that if there is a partition in the buffer, they both use the same partition data on the first call. If you don't, then here you could just have a list of entries in the buffer.
It seems to me that if there is a partition in the buffer, they both use the same partition data on the first call. If you don't, then here it would be a serious bug.
This can be simplified to Collections.emptyList()
This can be simplified to Collections.emptyList();
This can be simplified to something like this: java return Collections.emptyList();
is there a particular reason to catch this? And why not simply catch it?
is there a reason to reduce to one line?
is there a particular reason to catch this?
s/getByteBuffers().get(0).asNIO()/getByteBuffers()/
This is not going to be used here. Break it into 2 lines.
s/getByteBuffers().get(0).asNIO/NONE/
The purpose of this test is to throw inside the onError block. I don't understand why you removed the IAE
The purpose of this test is to throw inside the onError block, instead of inside the looperThread.testComplete().
The purpose of this test is to throw inside the onError block, instead of calling looperThread.testComplete();
interesting, I don't know what the reason to do this, but it would be nice to have the info log available in the code. Just to reduce the amount of code in this file
interesting, I don't see a reason to change the debug statements in this class. We have all the info logs in the method, including the time it's gone down. Just wondering.
interesting, I don't know what the reason to do this, but it would be nice to have the info log available in the code. Just to reduce the amount of code in this file.
Why is the type of Option<Seq<T>>? The result of 'add' is never used.
Why is the type of Option<Seq<T>>? It wasn't obvious why Option.some() was used?
Why not Option.empty()?
I think this could be used to have Assertions.assertThat(processInstanceId).isNotNull();?
You can probably use Set<ProcessInstanceField> params = new HashMap<>();
You can probably use Set<ProcessInstanceField> params = new HashMap<>();?
What's the case where mS3UnderFileSystem.stripPrefixIfPresent returns null?
What's the case where you want to strip the first /?
What's the case where you want to use one of the arguments?
Do we need this System.out.println?
No System.out please.
No System.out please
Can we use a constant instead?
Can we instead say 'this' while we are here?
Can we use a constant instead of hardcoding this?
this is not correct, b.getSymbolicName() should return null if padmin is null: no need to check it is not null.
this is not correct, b.getSymbolicName() should return null if padmin is null: no need to check it is not empty
this is not correct, b.getSymbolicName() should return null if padmin is null: no need to check it is not empty.
Multi-line if statements are preferred.
Not needed anymore.
Multiline if statements are not needed.
Can't you use prov.expandAll instead of explicit null?
Can't you use prov.expandAll() instead?
Can't you use prov.expandAll instead?
I think we have needed here already.
Why is this not a RuntimeException?
I think we have needed here already, right?
I'm not sure we need the deleteOnExit() here. It seems like the test would be dead if the file exists.
I'm not sure we need the deleteOnExit() here. It seems like the test would be dead if the file create files with weird names.
I'm not sure we need the deleteOnExit() here either. It was on purpose to ensure that we close the file.
Is it ok to move the code inside the synchronized block?
Is it better to move it to private saveInternal()?
Is it necessary to move the code to private saveInternal()?
For me this feature is not part of this 2004 issue, nor this is specified anywhere. I don't think this is a bad thing but this should be part of a broader reflexion about displaying path to users. I would personnally remove that part from this commit, but if you disagree feel free to let it like this.
For me this feature is not part of this 2004 issue, nor this is specified anywhere. I can't see how this is part of a broader reflexion about displaying path to users. I would personnally remove that part from this commit, but if you disagree feel free to let it as a bad idea
For me this feature is not part of this 2004 issue, nor this is specified anywhere. I can't see how this is part of a broader reflexion about displaying path to users. I would personnally remove that part from this commit, but if you disagree feel free to let it as a bad idea.
You should probably call "expected".
Why is this necessary?
Why are we setting Date value here?
Hmm. do we log tags? Probably a good idea but C Git doesn't.
Hmm. do we have any id there? Probably we can search for the repository.
Commit?
[minor] A null check and return?
ipFile(entry) may be a bit faster
ipFile(entry) may be a better choice.
Any reason why this is required?
Any reason why this is passing in the adapter? The adapter is setting the click listener
Any reason why this is passing in a callback? The fragment is default
EditedStyleItem item = (value instanceof EditedStyleItem)? (EditedStyleItem) value : null;
EditedStyleItem item = (value instanceof EditedStyleItem)? (EditedStyleItem) value : null;?
EditedStyleItem item = (value instanceof EditedStyleItem)? (EditedStyleItem) value: null;
can you please add braces
can you please add braces?
can be removed
This should be error, not info.
This should be error.
The name should be error.
only if name changes?
only if name changes? What does it mean?
only if name changes
Not relevant for this PR, but I'm curious: why is the TrustAllX509TrustManager necessary?
Not relevant for this PR, but I'm curious: what is the TrustAllX509TrustManager necessary?
Not relevant for this PR, but I'm curious: what is the TrustAllX509TrustManager necessary for?
Redundant replicationSpec.setPartitionStats()
Redundant replicationSpec().
Redundant replicationSpec.setDbName
Should we log a warning or throw an exception in the else of this if? I don't think we want to just warn in the else of this if.
Should we log a warning or throw an exception in the else of this if? I don't think we want to just warn in the else.
Should we log a warning or throw an exception in the else of this if? I don't think we have this if.
I'm not sure we should have this map here.
I'm not sure we should have this new method.
I think we should add some new support for this property param
Is it really necessary to have the testRules.isEmpty() check here?
Is this really necessary? The testRules.isEmpty() is still true.
Is this really necessary?
Hard code to use this one: final double score = -10 * Math.pow(10, -10);
Hard code to use here: java final RealMatrix[] counts = counts.keySet().stream().map(ArtifactMode::get).collect(Collectors.toList());
Hard code to use here: java final RealMatrix[] counts = counts.keySet().stream().map(ArtifactMode::get).collect(Collectors.toMap(HashMap::new, ColumnHandle::HashMap));
Since the Map is already checked as a Map, this change is not needed.
Since the Map is already checked as a Map, this change is redundant.
Seems like this change is not needed. groupByEqualityHash( bag, elementType ) already returns false.
Why did you remove the "protected" modifier?
Why did you change the logic here?
Why did you remove the "protected" annotation?
1. You can use == here
Deleting this logic could be in there
Deleting this logic could be in a method
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs)
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements and layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs)
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs) wizard.
please rename to vmDomain
please import it, it is not needed
please import it, it is an empty line
Do we need any tests for the changes in this plugin configuration on the agent side?
Do we need any tests for the changes in this plugin lifecycle to build tests?
Do we need any tests for the changes in this plugin configuration to ensure this plugin is not running?
This change looks unrelated to fluids? Seems like it belongs on a separate PR ;P
This change looks unrelated to fluids? Seems like it belongs on a separate PR ("stack")
This change looks unrelated to fluids? Seems like it belongs on a separate PR ;P?
can this be private?
can this be private? If yes, please make it private.
does this need to be private?
This might as well become if (this.creators.keySet()) { for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) {... } }
This might as well become if (this.creators.keySet()) { for (Entry<ITextHover, IInformationControlCreator> hoverControlCreator : this.creators.entrySet()) { if (children.isEmpty()) { return; } } if (children.isEmpty()) { continue; } }
This should be outside of for loop. A for loop would be simpler.
How about the following? java if (foundNum == MAX_MERGE_BUFFER_NUM + 1) { return foundNum; } // else return findChildren();
How about the following? java if (foundNum == MAX_MERGE_BUFFER_NUM + 1) { return foundNum; } // else return findFromChildren;
How about the following? java if (foundNum == MAX_MERGE_BUFFER_NUM + 1) { return foundNum; }
Same as above, please use (?<username>.*) here instead of (?<name>(.*)).
Same as above, use (?<username>.*) here instead of (?<name>(.*)).
Same as above, please use (?<username>.*) here
please remove.
please use logger
please use logger.
this.pushObjectList will be null
this.pushObjectList will always be null
this.pushObjectList will be an empty list when you initialize it as well
I'd suggest for debug/trace/remove any of the logging messages
debug/trace/remove?
I'd suggest for debug/trace/remove?
Optional: can't we just write to the permission and do the conversion there?
Optional: can't we just write to the permission and do the conversion at line 78?
Optional: can't we just write to the permission and do the conversion at line 71?
Do we need to add the _controllerPort_ to the log? We usually need to be able to provide an arbitrary default value when the table is loaded.
Do we need to add the _controllerPort_ to the log? We usually need to be able to provide an arbitrary default value when we want to debug the result.
Do we need to add the _controllerPort_ to the log? We usually need to be able to provide an arbitrary default value when we want to debug the table.
throw something if sqlCompatible
return val
return val?
This cannot be removed. The scheduled task needs to be saved.
This cannot be removed. The code needs to be removed.
This cannot be removed. The code needs to be removed, no?
.isEmpty()
isEmpty()
Typo on server
Use of this.getClass().getName() instead of getClass().getName()
Remove this.getClass().getName() not needed.
Remove this.
I think this might lead to unused space on the next line.
I think this might lead to unused space on the next line; when one of the columns has a higher preferred width than it's maximum (because you're using this anyway)
suggestion LOGGER.debug("...");
Is this one of the reasons that we're using a computeIfAbsent()? It looks like this would be an extra cost to eliminate the duplicate code.
Is this one of the reasons that we're ignoring the Missing docMatches?
Please, fix the indent.
Same here: should be able to pass a constant
Will this throw a RuntimeException?
Same here: should be a constant
Curious for the implementation for this case.
Curious for the name of the implementation.
The implementation will be modified.
this should be private.. or at least package protected.
this should be private.. or at least package private
this should be private.. or at least package private.
I don't like this. You can use the constant /test-domain.
I think these lines are repeated the same.
I don't like this.
in settingsDataSource you are already setting the presenter to the presenter and this class is the same code
in settingsDataSource you are already setting the presenter if you use it.
in settingsDataSource you are already setting the presenter to the presenter and this is the same code
Is it necessary to use Locale.US as the default?
Locale.US is only valid as it is used to start and end with HHBB, etc.
Locale.US is only valid as it is.
Needs a more descriptive name.
Needs a custom check for the return value of migrationOperations.
Needs a check for the return value.
You should be able to pull the conflict overrides directly without needing to rebuild from the string array. If that's not working, there's a problem with the name ConflictOverrides overrides.
You should be able to pull the conflict overrides directly without needing to rebuild from the string array. If that's not working, there's a problem with one of the above will get saved in the new serializer paths.
You should be able to pull the conflict overrides directly without needing to rebuild from the string array. If that's not working, there's a problem with one of the above will get saved in the new bundles.
If you don't return here, this will run only after current repl dump execution? What is the order of execution in the current case?
If you don't return here, this will run only after current repl dump is finished. What is the order of execution in the current case?
If you don't return here, this will run only after current repl dump is done. What is the order of execution in the current case?
This should probably be an error since it is thrown by app code
This doesn't seem right. It might be better to catch more specific exception and rethrow it with a descriptive message
This doesn't seem right. It might be better to catch more specific exception and rethrow it with a descriptive message.
I think e as a variable name would be prestartCoreThread
I think e as a variable name would be prestartCoreThread().
I think e as a variable name would be prestartCoreThread.
suggestion if (direction == Direction.OUTGOING) {
suggestion if (direction == Direction.OUTGOING) { For clarity
suggestion if (referenceInfo.isRelationshipEntity()) {
What about doing sqlite_master instead of sqlite_master?
What about doing a switch-case here to make it more readable? Creating a table-wide function and doing the same thing for all other objects in a single call.
What about doing a switch-case here to make it more readable? Creating a table-wide function and doing the same thing for all other objects in a single file.
it looks like createMergeConflictInfo() always shows the commit status, then adding the mergeResult should be an implementation detail of createMergeConflictInfor() and the mergeResult needs to be passed to it as a parameter
it looks like createMergeConflictInfo() always shows the commit status, then adding the merge result should be an implementation detail of createMergeConflictInfor() and the mergeResult needs to be passed to it as a parameter
it looks like createMergeConflictInfo() always shows the commit status, then adding the merge info should be an implementation detail of createMergeConflictInfor() and the mergeResult needs to be passed to it as a parameter
I think this is a bad smell. We should put a cause for the parser to be thread safe, and close both in the same block.
I think this is a bad smell. We should put a cause for the parser to be able to reuse the parser.
I think this is a bad smell. We should put a cause for the parser to be thread safe, and close both in the same way as below.
nit: should be removed I guess.
nit: should be removed.
nit: should be handled by a logger.
nit: this needs to be at the end of the method
nit: this needs to be at the end of the method.
nit: this needs to be at the end.
AJ, An encounter also has a time limit of 2 days set to read. Try [this](<LINK_0> instead.
AJ, An encounter also has a time limit of 2 days set to 0. An alternative would be to use the current time zone for a time-time activity. Try [this](<LINK_0> instead.
AJ, An encounter also has a time limit of 2 days set to read. Try [this](<LINK_0> - [this](<LINK_1> - <LINK_2> - <LINK_0>
resolvedBaseBranchName.matches(resolvedComparisonBranchName)
resolvedBaseBranchName -> resolvedBranchName
Can we please make this a variable?
Remember to put "filter" around map.get("bucket") into a RubyHash object, otherwise you'll need to do a check to see if it works as expected.
Remember to put "filter" around map.get("key").toString() into a private method to make it more obvious what it is doing.
Remember to put "filter" around map.get("bucket") into a RubyHash object, otherwise you'll need to do a check to see if it works for all cases.
I don't think it is a good idea to swallow interrupted exceptions here.
s/n/o
nit: missing a space after if
Oh! I see that this is a problem. It means that if a server has already been configured, the maxServerThreads is > 0 and the acceptorThreads is >= 0 then the acceptorThreads should not be -1. In that case, we still get a acceptor threads that have been configured because the server is not on the server. But that doesn't seem OK.
Oh! I see that this is a problem. It means that if a server has already been configured, the maxServerThreads is > 0 and the acceptorThreads is >= 0 then the acceptorThreads should not be -1. In that case, we still get a acceptor threads that have been configured because the server is not on the server. But that doesn't work as expected. They don't have been tried.
Oh! I see that this is a problem. It means that if a server has already been configured, the maxServerThreads is > 0 and the acceptorThreads is >= 0 then the acceptorThreads should not be -1. In that case, we still get a acceptor threads that have been configured because the server is not on the server. But that doesn't work as expected.
If you use org.dspace.app.util.AuthorizeUtil.removeMember(), you can use that method instead.
This should be outside the scope of the test.
move to a finally block
instead of?i)BOOLEAN DEFAULT FALSE. I would add it to the method below.
instead of?i)BOOLEAN DEFAULT TRUE.equals( "_" )
instead of?i)BOOLEAN DEFAULT FALSE
Should also be set to system property.
Should also be set in the test.
Should also be set by privileged actions
I'm wondering if it would be better to select the list of factories.length here since it's only used in the loop.
I'm wondering if it would be better to just select the list of factories.length here since it's only used in the loop.
I'm wondering if it would be better to select the list of factories.length here since it's only used in the first place.
Lines 86-88 and 95-102 should be removed and use the word cache as the second argument.
Lines 86-88 and 95-102 should be removed and use the word cache.
Lines 86-88 and 103-105 should be removed
This line is too long. Did you apply the formatting rules?
I think this line is too long. Did you apply the formatting rules?
This line is too long. Did you apply the formatting rules? :)
Looks like this is missing the promotionBuilder
Looks like this is the promotion is not used
Looks like this is the promotion is not used anywhere
Please add this Preconditions.checkArgument to check that certs is not blank.
Please consider using StandardCharsets.UTF_8 instead.
Do we need to add this case?
This check is not needed
This check is not needed since skipNull is checked before equals.
Please add a utility method to check if equals() is used.
nit: extract this into a static method (maybe isEmpty() or something?)
nit: extract this into a method (maybe isEmpty() or something?)
nit: extract this out into a method (maybe isEmpty() or something?)
consider creating a unit test for this method.
consider creating a method like verifyCollectionVersions(Collection, Set<Version>) which invokes this method.
consider writing the exception to the log statement.
rename this variable to 'previousSegmentRelationship'
rename this variable to hasObjectType or something
rename this variable
why are we retrieving this method and using it again in the beginning of the method? childElements and pass it in in variable
why are we retrieving this method and using it again in the beginning of the method? this is confusing, I would have expected and actual solution
why are we retrieving this method and using it again in the constructor? childElement
style nit: no braces here
unnecessary blank line
unnecessary actMonitor
couldn't be mapped to {}
couldn't be mapped to {} (available PEs: {}) mapped to {}
couldn't be mapped to {} (available PEs: {})
Replace this line by: assertNull(doc.getPropertyValue("dc:creator"));
Replace this line by: assertNull(doc.getPropertyValue("dc:creator"), event);
Replace this line by: assertNull(doc.getPropertyValue("dc:creator"), event.getTime());
Indentation looks off here.
Small thing, but I think worth mentioning: what do you think of isMlsPointUpdate?
Indentation looks off here too.
Is there a way to check the content of a blob? This would have a single black blob.
This is wrong. You should have a single one.
This is wrong. You should know what the returned list of blobs was from.
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like: if(!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(user)) &&!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(specificUser))) {.. }
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like: if (!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(user)) &&!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(specificUser))) {.. }
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like: if(!AuthzResolver.authorizedInternal(sess, "removeSpecificUserOwner_User_User_policy", Collections.singletonList(user))) {.. }
It seems like this could be replaced with a while loop to avoid the double async call.
This log line is odd.
This log line seems odd.
It would be better if we would show the user some message as toast as well!
It would be cleaner if we would show the user some message as toast as well!
It would be better if we would show user some message as toast as well!
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessors(...))
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getQuickAssistProcessors(...))
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getQuickAssistProcessors(...));
Instead of hardcoding this, can you check if this.inMemoryScope is an attribute in Config?
Instead of hardcoding this, can you check if this.inMemoryScope.get(... directly?
Instead of hardcoding this, can you check if this.inMemoryScope!= null and add a return here?
You can do this: java dto.setMaximumNumber(from.getPlatformType().name());
You can do this: java dto.setMaximumNumber(from.getPlatformType().name()); dto.setRepresentation(from.getPlatformType().name());
Maybe org.apache.commons.lang3.tuple.Pair instead, which will give you the number
Does this exception need to be caught?
Can you please add @SqlQuery?
Does this exception need to be wrapped?
why do you need to instantiate a new instance of this class? Could it be declared as private static final?
why do you need to instantiate a new instance of this class? Could be just as a static method.
why do you need to instantiate a new instance of this class? Could it be declared as private?
Could be simplified to: suggestion final Quaterniond.fromPrimitiveType(sion.getExtent(), cm.get()).direction(direction);
Could be simplified to: suggestion final Quaterniond.fromPrimitiveType(Entity.class)
Could be simplified to: suggestion final Quaterniond.fromPrimitiveType(Heg, fromPrimitiveType(H, Location.get()).get());
It'd be pretty sweet if you could return the original function instead of creating a new object. Really really cool!
It'd be pretty sweet if you could return the original function instead of creating a new object. Really Really no!
It'd be pretty sweet if you could return the original function instead of creating a new object. Really Really no! :)
Add a constant for the key
Add a constant for this.
Remove
getOrElse is enough?
getOrElse is _not_ necessary
getOrElse()?
Can you explain what problem this is solving? The jira does not tel much about leases.
Can you explain what problem this change is solving? The jira does not tel much about leases.
Can you explain what problem this is solving? The leases is already linked to the leases of all pending files.
I think this should be private.
I think this should be return null because it was not used anywhere
I think we should return the Item object rather than null.
This method seems a bit convoluted. Why not make it a method like setTitle(CharSequence)?
This method seems a bit convoluted. Why not make it a method like CitationStyleToClipboardWorker outputFormat, the DialogService would make it much clearer?
This method seems a bit convoluted. Why not make it a method like CitationStyleToClipboardWorker?
This log is unnecessary, we can use the class name instead.
This log is not very useful, let's use the class name.
This log is unnecessary, we can use the class name.
I don't think this is correct.
I don't think this is correct. If the session is already loaded, we can't call this method.
I don't think this is correct. If the session is already loaded, we can't do anything about it.
Should we move the check to the top of the method?
Should we move the check to the swipeContainer.onPageLoaded()?
When is this case handled?
@mykelalvis please, rename to maven. s is meaningless :)
@mykelalvis please, rename to path is meaningless :)
@mykelalvis please, rename to conf. s is meaningless :)
The message doesn't seem to be read.
This message doesn't seem to be a valid case.
The message doesn't seem to be used.
I think we should pass null and skip this if we do not publish workspace object.
I guess we can invoke this method :undefined instead of Boolean
I guess we can invoke this method :undefined.
The interceptors must not try to access the TM transaction via an atomic operation. Your call can be concurrent, it's only called once by a single thread.
The interceptors must not try to access the TM transaction via an atomic operation. Your call can be concurrent, it's only called once by the TM transaction.
The interceptors must not try to access the TM transaction via an atomic operation. Your call can be concurrent, it's only called once by the TM transaction manager.
Why doesn't it register custom type to NamedType?
Why do we need this method?
Why doesn't it register custom handlers?
SA == SERVICE_ACCOUNT? avoid abbreviations
Call this currentTimeMillis
Call this method in both tests make it clearer
why not keep using [iterator.next()](<LINK_0>
why not keep using 'this'?
why not keep using 'this' as a separate variable?
LOG.error("Could not create recovery file", e);
LOG.error("Could not create recovery file", e)
should be a 204?
Why not inject the mock in the constructor and use it here?
Why not inject the mock in preCheck()?
Why not inject the mock?
You can set the _last_ value to the api.getAllLoadBalancers()_ since you're using _safe_ the api.
You can set the _last_ value to the api.getAllLoadBalancers()_.
You can set the _last_ value to the api.getAllLoadBalancers() method.
this appears to be unused
Lets use VectorUtils.of(...).
Lets move this to after line 441
Was an extra ()?
Loading a new object from the persistent storage and then getting it from the client.
[minor] MessageEnd
Is there a reason you don't use [this](<LINK_0>
Is there a reason you don't just use spacingVertical here?
Is there a reason you don't just use spacingVertical as the param?
redundant : remove
redundant :]
redundant
The test should be inside the runnable, as the condition is set to true.
The test should be inside the runnable, as the condition is the same as the one in runnable()
The test should be inside the runnable, as the action is triggered directly after the snapshot is checked.
I think this would be clearer as a while loop, or a for with an empty third part. Certainly the codePoint declaration without an initializer brought me up short.
I think this would be clearer as a while loop, or a for with an empty third part. Certainly the'repeat' statement without an initializer brought me up short.
Can this be made a while loop? Or maybe a for with an empty third part?
how about replacing those with Objects.equals?
how about replacing those with Assert.assertEquals?
how about replacing those with Assert.assertEquals(blobId, referenceContainerId, referenceContainerId);?
Should we be throwing an exception instead of returning null?
Should we be throwing an exception instead of simply returning null?
Should we be throwing the NotFoundException instead?
no need to check this, I think if it's already attached to the field, and the code should be part of FormEntryActivity.getFormData().
no need to check this, I think if it's already attached to the field, and the code should be moved to FormEntryActivity.getFormData().
no need to check this, I think if this is already true, right?
I think this should be <LINK_0>
I think the repository can be moved to <LINK_0>
I think this should be <LINK_0>, which is fixed by <LINK_1>
I would change this to if(perun.isThisPerunReadOnly()) throw new InternalErrorException("This role is already present in DB {}.", role);
I would change this to if(perun.isThisPerunReadOnly()) throw new InternalErrorException("This role already exists in DB {}.", role);
I'd change this to if(perun.isThisPerunReadOnly()) {
Should be workbenchContext_.setBuildInProgress(false).
Should be workbenchContext_.setBuildInProgress(false)
How about we just look at sourceBuildHelper_.startBuild and targetBuildInProgress, and use java lambda syntax here?
it should use parameter.getFormulas
Split into smaller chunks
healthcheck
The number of attempts is debatable. Remove this line and just put the message in the IllegalArgumentException.
The number of attempts is debatable. Remove this line and just use the number.
The number of attempts is debatable. Remove.
This can be moved to line 69, right?
This exception is thrown from line 63, maybe we should remove this also?
This can throw a SecurityException, right?
This should be done before doing this check, as the cleanup policy is only called from on the shared table.
This should be done only if MANUAL is required to make it clear that the request was sent. For example, if it is ANY, it should be logged in the system.
This should be done only if MANUAL is required to make it clear that the request was sent. For example, if it is ANY, guest table should not be deleted.
cannot convert to boolean, can it be false?
can't you just use continue?
cannot convert to boolean, can it be null?
Is it better to use the javaSource.interactAndThrow() method instead of duplicating the code?
Is it better to use the javaSource.interact( SQLSource.interact) method instead of duplicating the code?
Is it better to use the javaSource.interactAndThrow() here?
Can you improve the performance of this method? Doesn't seem to be used anywhere.
Can't we improve the performance of this method? Doesn't seem to be used anywhere.
Can't we improve the performance of this method? Doesn't seem to be used anywhere?
@ochaloup Testing getting a JsonNode here, but I think it may be better to check this in the constructor of JsonNode.
@ochaloup Testing getting a JsonNode here, but I think it may be better to check this in the constructor instead
I think this should be private.
I think we might want to reuse the logic in SelectionUtils to validate the logic.
I think we might want to reuse the logic in the validatePredicateValue method to avoid this duplication.
I think we might want to reuse the logic in the validatePredicateValue method to avoid duplication.
Use camel case?
Use camel case? :)
Use camel case (?)
You need to use the formatter.format(new Date()) statement here.
You need to use the formatter.format(new Date()) method in this file.
You need to use the formatter.format(new Date()) method in this class.
I think here you should use the method Session.of(resourceResolver) in order to see if the Resource resolver is null (i.e. if the resource resolver is not null, do we want to see if it is null)?
I think here you should use the method Session.of(resourceResolver) in order to see if the Resource resolver is null (i.e. if the resource resolver is not null, do you want to see if it is null)?
I think here you should use the method Session.of(resourceResolver) in order to avoid the whole if-clauses.
this is an error message
this is an error
this is a bit confusing
Line longer than 120 cols. Extract a variable.
please move this line to the beginning of the method
Line longer than 120 cols. Extract a local variable
Please move this to FINE level.
@vgkholla made a good point that we should wait a hour to introduce timeout timeout, and maybe use TIMEOUT_MILLIS instead.
nit: can you make this a private method?
I think it's better to use try-with-resources, such as: try (InputStream fis = getResource(KEYSTOREType.class)) {... }
I think it's better to use try-with-resources, such as this Java try (InputStream fis = getResource(KEYSTOREType.class)) {... }
Isn't it better to use follow try-with-resources?
This is a bad idea to exception out, you need to wrap it in an if statement.
You need to use new Date(milliseconds)?
This is a bad idea to exception out, you need to wrap it in an if-condition.
This feels like a good candidate to be consolidated into a single test.
This feels like a good candidate to be consolidated into a single method.
This feels like a good candidate to be consolidated into a single call to system properties.
Why is this extra logic necessary?
This is unused.
Why is this extra logic?
Are not we un-conditionally showing the error message?
What about moving the code here and moving the common logic to a new method like isCourseDiscoveryEnabled()?
Are not we un-conditionally showing the error message here?
I'd use a different exception than exception, here to be able to pass the exception in the constructor.
I'mdialect is actually not thrown, should we use some custom exception instead of Exception?
I'mdialect is actually not thrown, the constructor exists only if the dialect is available.
I'd like to see what the format of the output is for JFlat. We may have specific requirements around how the JSON is flattened - so would also be good to see the customization options.
I'd like to see what the parsing code is for JFlat. We may have specific requirements around how the JSON is flattened - so would also be good to see the customization options.
I'd like to see what the parsing code is for JFlat. We may have specific requirements around how to handle this.
This doesn't seem like the user input was added to more places.
This is wrong, the test should now be **minAbundance**, not **Kemme.
This is wrong, the test should now be **minAbundance**, not _7.0 Build id?
just make this a constant and use it here.
just make this a constant.
just make this a constant
Write if (value == null) { continue; } instead
Write if (value.getBase()!= null) {
Replace HashMap with Map.Entry?
I think pt.toString() should be obfuscated.
I think pt.toString() could be null or empty
Use {} or even {}
You can just use Mod11ProxyAnnotation( 9, 14,...) here.
You can just use Mod11ProxyAnnotation( 9, 14, 45) == true instead of 17
You can just use this method here.
why not use the logger for this?
why not use the same error message as the other 2 messages below?
why not use the description instead of the error?
This should be on nanoseconds
This should be on nanoseconds = Math.ceil((parts[0]), Integer.valueOf(parts[1]));
This should be on nanoseconds = Math.ceil((parts[0]), Math.ceil(parts[1]));
You have two placeholders in the stream but only one argument, is this intentional?
You have two placeholders in the stream but only one argument, that is the same as the one below.
You have two placeholders in the stream but only one argument, that is the second argument from the method.
This is what we want. This is assertThat(actual, expected)) and gives better error messages as much as possible.
This is assigned in every test method. Can we make it private?
This is assigned in every test method. Can we make it private or add an assertion to verify the output is correct?
Code style: we don't use curly braces around single line blocks
Code style: we don't use braces around single line blocks
We should probably add an isComplete method to the MessageListener interface, to help with this.
Shouldn't we update the column name too?
Shouldn't we update the column name after ColumnStoreTableDataProvider?
I believe a setColumnOrder should be used for both Column and Column types, because they are optional and may be for some reason.
Ravi, if you just initialize this with false before the creation of the tasks then your fix will be perfect.
Ravi, if you just initialize this with true before the creation of the tasks then your fix will be perfect.
Ravi, if you just initialize this with false before the creation of tasks then your fix will be perfect.
we need to check for Checker.class.getPackage().getName() + "." + moduleClassLoader.
we need to check for Checker.class.getPackage().getName() + "." + moduleClassLoader()
we need to skip the default code here as we skip the configuration in a later stage.
This should be neoStore.isDoubleRelationshipRecordUnits( inputEstimates );
This should go to a separate PR, for consistency.
This should be neoStore.isDoubleRelationshipRecordUnits(..)
I don't think this should be triggered by the UI thread.
I don't think this should be triggered by a UI thread.
I don't think this should be a asyncExec.
do you want to do this every time executeHttpMethod?
do you want to do this every time runHttpMethod is called?
do you want to do this every time executeHttpMethod is called?
httpPost.toString() does not match equals(). I believe you can do response.getStatusLine()!= null && response.getStatusLine().getStatusCode() >= 200
httpPost could do response.getResponseBody().toString()???
httpPost.toString() does not match equals(). I believe you can do response.getStatusLine() == null && response.getStatusLine().getStatusCode() >= 200
I think that a simple iteration is more readable than the simple iteration.
I think that a simple iteration is more readable than the old implementation.
I think that a simple iteration is more readable.
Use already defined Constants
use already defined Constants
Use already defined Constants.
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address will be taken from the pool i think that releasing the mac addresses better be done at the end
there a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end
Also need to verify that the exception is not thrown.
Also need to verify that there is no exception thrown?
Also need to verify that there is an error you can get.
Minor: use isEmpty()
Disregard my question about moving this out to a separate private method, it seems like it would be useful to do that in the future
Disregard my question about moving this out here since it doesn't help here
A null check is necessary.
A null check is needed here.
A null check is needed here
So if you remove the file from the parent dir you will get to the parent directory, which is not what you want. I don't think you're doing anything.
So if you remove the file from the parent dir you will get to the parent directory, which is not what you want to remove. I don't think you're trying to remove the file from the parent directory. Perhaps it's time to just remove the child directory and add it to the parent directory.
"remove" is redundant
Is this always a.toArray(new Module[0])? And if the list is empty, toArray(new Module[])
Is this always a.toArray(new Module[0])? And if the list is empty, toArray(new Module[])?
Is this always a RuntimeException?
I would probably split this up and check the token type prior to getting and checking for credentials. It's a personal preference, though.
I would probably merge this up and check the token type prior to getting and checking for credentials. It's a personal preference, though.
I would probably split this up and check the token type prior to getting and checking for credentials. It's a personal preference, but I'm not sure if we really need to do this.
You need to use the default auth in the call to the read API and skip the check if options is null.
You need to use the above check, or better yet, move the check after the if condition in line 103.
You need to use the default auth in the call to the read API and skip the default auth if it's null.
Whitespace change!
Whitespace change
Whitespace
Can you please also log the workspace registration registration?
Can you please also clarify the purpose of the variable name
Can you please also clarify the reason of the additional variable name
Should this be "setAppToken"
Should this be an error or CredentialStoreException? Are we just going to catch that exception and not a DAOException?
Should this be an error or CredentialStoreException? Are we just going to catch that exception and not a CredentialStoreException?
This test can be executed for all the tests that parse the expected output as well.
This test can be executed for all the tests that parse the expected output as well, at the moment it's not that important, but that's the fix.
This test can be executed at some point.
Why do we need to set the aud rate here given that the setting is aud?
Why do we need to set the aud rate here?
Why do we need to set the aud rate here given that the setting is applied to on line 343?
make it final and move all extra logic to this class
move this into the if statement below. There's a helper method for handling an action that is invoked in two places.
make it final and move this into the if block below.
Can the cursor iteration block be tested too?
Can the cursor iteration block be an AutoCloseable?
Can the cursor iteration block be an AutoCloseable object?
Exception thrown = null is redundant
I think you shouldn't do this in the test method.
I think you shouldn't do this in the try block.
No need to mock in @Test. Same for other test methods
No need to mock in @Test. Same for other test methods.
No need to mock in @Test. Same for other tests
Combine this and others.
Inconsistent spacing.
Revert things.
please add assertThat(Parameters.merge(null, params1)).isSameAs(params1);
please log the result of the merge.
please log the result of the merge..
You can use [File.separator](<LINK_0>
You can use [URIBuilder](<LINK_0>
You can use [URIHelper](<LINK_0> here.
The timeout is for gracePeriod.
The timeout is for the gracePeriod. Something is weird, I think.
The timeout is for the gracePeriod.
please use Collections.emptyList()
please use Collections.singletonList()
please use diamond operator
Is there a reason why we don't want to use the logger.debug here?
Is there a reason why this is an else if?
Is there a reason why we don't want to use the annotations?
Do we need to check both of these?
Break this line (the ones below)
Do we need to check this?
We should not be passing the current value in if it is not null. The if current value is not set, which is not true if committingSegmentKMetadata.getSegmentLocation() returns null.
We should not be passing the current value in if it is not null. The if current value is not set, which is not true if committingSegmentKMetadata.getSegmentLocation() returns null. We should probably create a new method committingSegmentKMetadata to initialize the segment.
We should not be passing the current value in if it is not null. The if current value is not set, which is not the case (if current segment location is not set).
Can it it be more efficient to remove the watcher from the zkClient?
Can it actually happen that the watcher is removed?
Can it it be more efficient to remove the watcher from the zkClient that removed it?
If it's going to be a single value, better to use.equals() in the subsequent null check.
If it's going to be a single value, better to use.equals() in the subsequent null-check.
If it's going to be a single value, better to use.equals() (or Objects.equals()) instead of!=.
I would recommend instead to add a @Before annotation to artifact.getAttributes() to make sure that the value is not null before adding this to the attribute.
I would recommend instead to add a @Before annotation to artifact.getAttributes() to make sure that the value is not null before the BlackboardAttribute.
I would recommend instead to add a @Before annotation to artifact.getAttributes() to make sure that the attribute is not null before the BlackboardAttribute.
Can we use Stream API? So we should probably use only one instance of Java.
Can we use Stream API? So we should probably use only Java version is used for filtering.
Can we use Stream API? So we should probably use only Java version is used for reading only
remove
lock account
save account
Can you move this to debug level?
Why log this at info level?
Can you move this to debug?
[HaxeReference](<LINK_0> is a local variable, so you should not be calling it twice. Instead, try to use.filter(b->c instanceof HaxeReference)
[HaxeReference](<LINK_0> is a local variable, so you should not be calling it twice.
[HaxeReferenceImpl.](<LINK_0> is a local variable, so you should not be calling it twice.
I'm wondering if it would be better to do something like: if (prefix == null ||!prefix.equals(f.name)) { column = String.format( "TO_CHAR((%s ||'second')::interval, 'HH24:MI:SS') as %s", column, f.name ); } return column;
I'm wondering if it would be better to do something like: if (prefix == null ||!prefix.equals(f.name)) { column = String.format( "TO_CHAR((%s ||'second')::interval, 'HH24:MI:SS') as %s", column, f.name ); }
I'm wondering if it would be better to use.toString() here.
You check if all parameters are null before assigning it to a variable.
Again, this validation should not fail there.
You check if all parameters are null before checking for it.
Should these weights be int?
Should these weights be _long for consistency?
Should these weights be dances on construction?
The steps 36, 37, 38 are not necessary, please check this.... you should omit this steps
The steps 35, 36 and 38 are not neccesary
the steps 35, 36 and 38 are not neccesary
step on this to match myservice, no?
step on this to match your previous behavior, no?
step on this to match myservice, no?.build()
which exception are you avoiding?
which exception are you avoiding? Should the selectHostAction mean setTitle?
which causes NPE?
Typo: ig1
Typo: reassigned
assertFalse(ig2.active());
no.equals for strings
no point for.equals
no point for.equals()
instead of calling String.trim() multiple times here use map(), e.g. Files.lines(p).map(String::trim)
instead of calling String.trim() multiple times here use map(), e.g. Files.lines(p)
instead of calling String.trim() multiple times here use String.trim()
'listNode' is not defined anywhere. The code seems to be the same as listNode.get(kind)' and shouldn't be creating a new collection.
'listNode' is not defined anywhere. The code seems to be the same as listNode.get(kind)' and why not adding 'KIND' to an existing list?
'listNode' is not defined anywhere. The code seems to be the same as listNode.get(kind)' and why not adding 'KIND' to an existing method?
nit: do you need AuthMethodPickerActivity.this or could it be just this?
we can follow the same pattern as above, do you need AuthMethodPickerActivity.this or could it be just this?
nit: do you need AuthMethodPickerActivity.this or can it be just this?
Same as above here: use.isEmpty() rather than.equals for the empty checks.
Same as above here: use.isEmpty() rather than.equals for the empty string.
Same as above here: use.isEmpty() rather than.equals for the empty check.
@gsmet, why not just call UUIDGenerator.generateUuid()?
why not just call UUIDGenerator.generateUuid()?
@gsmet, why not just call uuidGenerator.generateUuid()?
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write: MockBattleState.builder().attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))).defendingUnit(givenUnit()).defendingUnit(givenUnitIsAir()).build();
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write: MockBattleState.builder().attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))).defendingUnit(givenUnit()).defendingUnit(givenUnit()).defendingUnit(givenUnitIsAir()).build();
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-static and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write: MockBattleState.builder().attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))).defendingUnit(givenUnit()).defendingUnit(givenUnitIsAir()).build();
This won't work if we just add a "startOffline" button to the page
This won't be called if a page is active. Do we just want to skip the previous page?
This won't be called if a page is active. Do we just want to skip the toggleOffline() state and do a real click?
Can these be declared at class level and used for both methods?
Can you make these variables final and they can be used for both methods?
Can these be declared at the top of the class and used for both methods?
suggestion } catch (Exception e) {.... } catch (Exception e) {... }
This should not be necessary, there is a @Override annotation on the method definition.
suggestion } catch (Exception e) {.... } catch Exception {... }
This method can be private
This is apparently out of date.
This function can be private
knows?
knows? Is there any reason for the POC from running?
knows? Is there any reason why we have to set 2 seconds?
Could use an instance method in ControlUtil.
Could be private.
Could use an instance of NetworkUtil.
Who does this throw a TajoRuntimeException?
Redundant qualifier.
Partitions should be defined in Partition or Partition
this is not needed.
this is not needed
this is not required.
same as above: why flatmap?
same: why public?
same as above: why flat map the strings?
This exception message with a clear message is not correct.
This method should not be executed by default. The proper test will fail even if the exception is not thrown.
This exception message with a clear message says the wrong variable name.
Don't you think that set in a static field will be simpler?
Don't you think that set in a static field will be easier?
Don't you think that in this case it's better to make the constructor private and set in fields?
This is a critical section, but it does not really matter. Maybe add a value to <LINK_0> instead?
This is a critical PR, but it does not need to be.
This is a critical section, but it does not really matter.
To be honest, I'm not sure what this is trying to do.
To be honest, I'm not sure what this is supposed to do.
For our tests, we should assert that there is an actual value in the enum.
Why not make tmp a final variable?
Why not inline tmp variable?
Why not make it protected?
we can do it in a try-with-resources block so that it gets closed even if it's not needed to check if the file is valid?
we can do it in a try-with-resources block so that it gets closed even if it's not needed to check if the file is malformed.
can be final
Should we use setText here?
Should use constants for both of these values.
Should use constants for both of these values
Yeah, I think it makes sense. IIRC, netty swallows the throwable silently, so it's difficult to figure out what's wrong.
Yeah, IIRC, netty swallows the throwable silently, so it's difficult to figure out what's wrong. I think it makes sense to log a message when it's interrupted.
Yeah, IIRC, netty swallows the throwable silently, so it's difficult to figure out what's wrong. I think it makes sense to log a message when it's fatal.
This would be false if newlyDisallowed && prevDisallowed &&!tetheringActiveOnDevice What does "status" actually represent in this parameter? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate?
This would be false if newlyDisallowed && prevDisallowed &&!tetheringActiveOnDevice What does "status" actually represent in this parameter? If it represents whether tethering is active then it should be false - seems like it's appropriate to only check newlyDisallowed if it's not a Tethering active
This would be false if newlyDisallowed && prevDisallowed &&!tetheringActiveOnDevice What does "status" actually represent in this parameter? If it represents whether tethering is active then it should be false - seems like it might be appropriate to only check newlyDisallowed if it's not a Tethering active
Instead of doing this, why not just put it after the if/else?
Instead of doing this, why not just put it to a map?
Instead of doing this, why not just use TimeUtils.toUtf8Bytes()?
Please split this out into multiple lines.
The second parameter (String) constructor is not used.
Please split this out into multiple lines if statements.
Why isn't this been copied?
Why isn't this been removed?
Why is this call needed?
This will generate a lot of warnings if the payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getUpdated(), chargeEventEntity.getUpdated());
This will generate a lot of warnings if the payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getUpdated(), chargeEventEntity.getUpdated() );
This will generate a lot of warnings if the payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeEventId={}] [chargeEventId={}]", fromChargeState, targetChargeState, chargeEventEntity.getUpdated(), isValid());
Cosmetic: Please let's change this to debug, please.
Cosmetic: Please let's change this to debug.
We should change this to warn
"missing retained size of block in eager compact PagesIndex smaller than the expected size of block in eager compactPagesIndex"
"missing retained size of block in eager compact PagesIndex smaller than initial size of block in eager compact PagesIndex"
"missing retained size of block in eager compact PagesIndex smaller than initial size of block in eager compactPagesIndex"
See earlier question.
you don't need to call these 2 fields.
See earlier question about possible values
Does it make sense to have a real test cases for this one test case?
Does it make sense to use an empty list here?
Does it make sense to have a real test cases for this?
If the error happen that early, can you map the error in early phase before mapping page result?
If the language is an error, can you map the error in early phase before mapping page result?
If the language is an invalid, can you map the error in early phase before mapping page result?
Conditional pass for the correct project.
Add a null check for getProject and setRawClasspath to make sure there is no project
Add a null check for getProject()
suggestion boolean notInGraphAtAll = candidatesForDeletion.isEmpty();
suggestion boolean notInGraphAtAll = candidatesForDeletion.size() == 0;
this should be candidatesForDeletion.isEmpty()
should becurrency.getDescription()
should becurrency.getMetadata().toUpperCase()
should becurrency.getMetadata().toLowerCase()
you could combine this with the line above.
you could combine this with the line below.
you can push this down to the flow, as you're doing it in the eventExecutor
Better to use a lambda and a predicate instead of a lambda (after L299).
Better to use a lambda and a predicate instead of a lambda.
Better to use a lambda and a predicate instead of a lambda (after lambda execution).
It would be nice to have a more generic method for this. It is repeated in 3 places.
It would be nice to have a more generic method for this than the old one.
It would be nice to have a more generic method for this. It is repeated in 3 places
Can we just use a clone()?
Can we just use a clone of the array?
Can we just use a clone of the collection?
Move this if block after all if blocks.
Can use final on all these variables and then put the type in a local variable.
Can use final on all these variables and then put the type in a private method.
Do we want to use a stream here?
Do we want to use a strategy on the query?
Remove {}
Please don't make any changes for this, we make sure that changes of the feature that modify the model. Here we make sure that changes of the feature mode, e.g. night mode switches to day mode.
Please don't make any changes for this, we make sure that changes of the model.
Please don't make a change for this, see above.
The "should" be part of "org.eclipse.debug.ui.browser".
The "should" be part of "org.eclipse.debug.ui.view.DefaultConfiguration"
The "should" be part of the original status, right?
Missed space before "ignite:thin://"
Missed empty line.
Missed space at the end of the line.
Suggestion: You can set notebookJobs as a local variable and call it in on line 46.
Suggestion: You can set notebookJobs to final here.
Suggestion: You can set notebookJobs to final here and move this method inside of broadcastUpdateNotebookFromMessagingService.
Won't this cause the password to be invalid?
Won't this cause the password to be closed once, rather than on each method call?
Won't this cause the password to be closed once we're done with the pool?
Why do we use iterators? I know the base class does, but why in the first place?
Why do we use a iterators? I know the base class does, but why in the first place?
Why do we use a iterators? I know the base class does, but maybe it's not.
Nit: Instead of passing mutableTables to this helper, please have a single method for dataTableFullName. It goes into one line only.
Nit: Instead of passing mutableTables to this helper, please have a single method for dataTableFullName. It goes further, the same on line 47.
Nit: Instead of passing mutableTables to this helper, please have a single method for dataTableFullName. It goes further, and only add one of them.
I would even check if the value is not null. That way the check is not necessary.
I would even check if the value is not null. That way the check we also have to make sure the value is not "null".
I would even check if the value is not null.
Delete this.
Delete this.. Let's make it a static method.
Delete this..
nit: Can you revise the guava build?
nit: static import
nit: This is subjective, so I guess the question is
I'd just pass in "outHeader" as an argument to the method rather than having to create a new one.
I'd just pass in "close" as well.
final
To avoid this check, you could just return access;
To avoid this check, you could just return access; and use return no need to check for null after the check.
To avoid this check, you could just return access; and use return no need to check for null at the end.
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "getEvaluatedInputExpressions" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Remove this unused method parameter "getEvaluatedInputExpressions". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "getEvaluatedInputExpressions". [![rule](<LINK_2>](<LINK_0>
You no need to add this to the button. The setting the style should have already been set in the super class.
You no need to add this to the button. The setting the style should have already changed in the super class.
You no need to add this to the view id if you call super.update
We can use org.junit.Assert to make sure the output is correct.
We can use org.apache.gitgit.index.v4.tools.api.util.io.FileUtils#writeTreeSize.
We can use DirCache.access.
Is there a way to remove this version of code from the SnomedSimpleMapRefSetImporter at all? It could be removed from all classes implementing applyRow.
Is the 'else' part part of this block? It could be removed from all classes implementing applyRow.
Is the uuid should be part of the reference set member?
do you need to 'final' for all these map operations?
do you need to 'final' for all these readers?
do you need to 'final' at all?
I think you should be able to use the waitUntil(timeout) method from the JUnit.
I think you should be able to use the waitUntil(timeout) method from the junit thread.
If we use the timeout here, perhaps it's worth extracting the testComplete() to a method?
You can add a null check here
Here, we can add a method publishTelemetryRequestOptions that takes a Context and does all the toString() call.
You can add a method publishTelemetryRequestOptions(String)
Use full name here, e.g. dashboardURL
Use full name here, e.g. dashboardURL.
Use full name
4 spaces
nit: You could add a private function to Util, with a static import.
nit: You could add a private function to Util, with a java.util.Arrays.contains(location_)
Class name is drools
Class name is BobStatus
Class name is Char
Actually I think this makes the ArrayList less verbose. :-)
Actually I think this makes the ArrayList less verbose. as a smaller byte is. But it is not a big deal, like 12 MiB I think.
Actually I think this makes the ArrayList less verbose. as a smaller byte is. But it is not a big deal, like 12 MiB worth of course.
no need to write "VmHandler::" in the log, the logger already have the entry
no need to write "VmHandler::" in the log, the logger already write the message
no need to check if isEnabled is null
Did you mean to use [org.apache.kafka.common.utils.Utils](<LINK_0> here?
Did you mean to use only the WARN log message?
Did you mean to use WARN level?
If the token refresh is going to be shown at the end of the user, then we should not return. Instead, we should return an error to the caller and let the caller handle the error.
If the token refresh is going to be shown at the end of the user, then we should not return. Instead, we should return an error if the token refresh is signal and the user should fetch the token.
If the token refresh is going to be shown at the end of the user, then we should not return. Instead, we should return an error if the token refresh is signal and the user should wait until it returns.
You're missing the logic around remove.
You're missing the logic on this.
You're missing the logic on Player.
you can simply use Predicates.notNull()
you can simply use Predicates.notNull(), the same for other places
you can simply use Predicates.notNull(), or similar to Predicates.notNull()
imout of curiosity, why does this need to be in the constructor?
imout of curiosity, why does this need to be here?
imouth, nice catch.
Why would you not do an ArrayList here? and you could return a List<ValueSnak> instead.
Why would you not do an ArrayList here? and you could return a List<ValueSnak> directly.
Why would you not do an ArrayList here? and you could return a List?
If you have a look on the code behind Guava, maybe you can use [Files.lineslines(java.nio.Files#toString(java.io.InputStream)](<LINK_0>
If you have a look on the code behind Guava, maybe you can use [Files.lineslines()](<LINK_0>
If you have a look on the code behind Guava, maybe you can use [testBuilder](<LINK_0>
We could avoid cloning here? (The message is not modified by the view?)
We could.cloneAll() here.
We could spam the logs with messages..
hmm.. why don't we just use CoreUtils.join(",", intsToConcatSize)?
hmm.. why don't we just use CoreUtils.join(",", intsToConcatSize)?
hmm.. why don't we just use CoreUtils.join(",", intsToConcat)?
You could use the String.format() method to build a String on demand.
You could use the String.format() method to build the string.
You could use the String.format() function here.
Why do we need extra comma here?
Why do we need extra comma here? We should just use it consistently for all attributes
Why do we need extra comma here? We should just use it consistently for all attributes.
is this necessary?
is this necessary if this is retrieved?
is this assertion necessary?
This is a race condition. Each thread reads the IP address. Won't this cause the IP address to be in a pre-existing port? Perhaps a way to do this?
This is a race condition. Each thread reads the IP address. Won't this cause the IP address to be in a pre-existing port? Perhaps a way to do this would be to avoid this issue?
I think this can be the first time an issue is in portName.
Don't printStackTrace, please.
Don't printStackTrace, call printStackTrace.
Don't you need to call printStackTrace()
I'd name it "field".
I'd name it "field" instead of "s"?
I'd name it "field" instead.
a question: Why do we need to do this check here?
a question: Why do we need to do this check and at the end of submit()?
a question: should this be an error message?
@Restricted(DoNotUse.class)
@Restricted(DoNotUse.class) is a better choice.
@Restricted(DoNotUse.class) is a better option.
Use ExpectedException here too? <LINK_0>
Use ExpectedException here too.
Maybe we should test what happens here as well.
I think this is incorrect - we shouldn't be placing files for variants of the same blueprint in the same directory. Can we add a pre-run.dir path to the same blueprint?
Please add a null check for this parameter.
Please add a space after,
this will print the lowerBoundForWindowTriggerTimeInMs twice, but maybe better to not have multiple threads at the same time.
this will print the lowerBoundForWindowTriggerTimeInMs twice. Is this really necessary?
this will print the lowerBoundForWindowTriggerTimeInMs twice, but maybe better to not get the same value at all.
The other examples all use ASCII table output - is there a reason for switching to CSV?
The other examples all use ASCII table output - should this be left in after testing?
The other examples all use ASCII table output - is there a reason for switching to CSV or has this just been left in?
Why initialize the object here instead of going through the supplier?
Why initialize the object with an empty array?
Why initialize the HashMap at the beginning of get?
I'm not sure why you're passing PythonTreeMaker().fileInput to the method getAllDescendant(fileInput, tree -> tree.is(Tree.Kind.CLASSDEF)).get(0) is the same as CALL_EXPR
I'm not sure why you're passing PythonTreeMaker().fileInput to the method getAllDescendant(fileInput, tree -> tree.is(Tree.Kind.CLASSDEF)).contains("foo.bar.A")?
I'm not sure why you're passing PythonTreeMaker().fileInput to the method getAllDescendant(fileInput, tree -> tree.is(Tree.Kind.CLASSDEF)).get(0) is the same as CALL_EXPR, but here we are asserting that the class is not...
We should not use ERROR. Please do that.
We should not use ERROR unless you are doing something special.
We should make this a constant.
What is the reason for this change?
What is the reason for doing this?
Consider adding a new method to createImageStreamTag that takes a String and a regex.
It seems to me that we could avoid reconnectOutgoing.
It seems to me that we could avoid to use try-with-resources.
It seems to me that we could use try-with-resources.
This method should return a new ILocationConfiguratorPlugin instead of null.
This method should return a List, not null.
This method should be private
this can be replaced with streams
this can be a switch statement with equals()
this can be replaced with streams.
Why it is not indefinite-length contents?
Why it is not (!mBuf.hasRemaining())?
Why it is not < 0?
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever occur...I just like being explicit :-)
Throw an Exception on _else_ and check explicitly for udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
Space after comma.
nit: line break after return.
Extra line break.
Follow the test prep.
Please check that do not the test gt(v) but the test prep.
Please check that do not the test gt(v) here.
This technically isn't the the intent of the method, and the variable name might be something that could be assigned. i.e. java final Principal authenticatedPrincipal = authn.getPrincipal(); final Map<String, Object> authenticationAttribues = new DefaultCompositeAuthentication(LoginPrincipal.valueOf(attrName)); authenticationAttribues.put(attrName, authenticationAttribues);
This technically isn't the the intent of the method, and the variable name might be something that could be assigned. i.e. java final Principal authenticatedPrincipal = authn.getPrincipal(); final List<String> authenticationAttribues = new DefaultCompositeAuthentication(LoginPrincipal.valueOf(attrName)); authenticationAttribues.put(attrName, authenticationAttribues);
This technically isn't the right exception to use. The service never returns null.
I'd replace (getDisk()!= null) with "getDiskProfile().setSelectedItem(diskProfile);" and remove the "if"
I'd replace (getDisk()!= null) with "getDiskProfile().setSelectedItem(diskProfile);" and solve it in the following lines
I'd replace (getDisk()!= null) with "getDiskImage().getDiskProfileId()"
Can you use a string format like logger.debug("Waiting for wait for {}", minBytes - minBytes - startTimeMs);
Can you use a string format like logger.debug("Waiting for wait for {}", minBytes - minBytes - startTimeMs);?
Can you use a string format here.
I think this should be part of the exception handling code.
I think this should be part of the exception message.
I think this should be InvalidTaskException as the exception states are not related to BaseTask.
if (Objects.equal(a, b)) {
if (Objects.equal(var, trgObj)) {
(Boolean)null
nit: put the whole statement in a separate line
nit: put the whole statement on a previous line
nit: these can be static
Please add assert on organization.getFacets().get(FACET_TAGS)!= null
Please add assertFacets().get(FACET_TAGS).containsOnly(FACET_TAGS); otherwise we will be good to understand what is happening here
Please add assert on organization1.getType().
I know this was not related to this commit, but as I have mentioned this, the variable should be non-final.
I know this was not related to this commit, but as I have mentioned this, the variable should be non-null.
I know this was not related to this commit, but as I have mentioned this, the parameter should have been marked @Nullable
you're setting value to null here to avoid NPEs in IndexOptions.java above. I think it's better to set it to missing if-else to false and throw an exception to set this to true with "null value".
you're setting value to null here to avoid NPEs in IndexOptions.java above. I think it's better to set it to true purpose and have overloaded method addFieldName() accepting the name.
you're setting value to null here to avoid NPEs in IndexOptions.java above. I think it's better to set it to missing if-else to false and throw an exception to set this to true with "null".
@ustcweizhou Thanks for your changes, we were returning an empty string when there is a problem. Because of this change, we are throwing the exception when we log the error, why are we throwing it here?
@ustcweizhou Thanks for your changes, we were returning an empty string when there is a problem. Because of this change, we are throwing the exception when a user store is not found. Is this intentional?
@ustcweizhou Thanks for your changes, we were returning an empty string when there is a problem. Because of this change, we are throwing the exception when a user store is not found. Can you change this to return a 200 instead?
readLines(final String s) is a little cleaner.
readLines(final String s) is a bit cleaner.
readLines(final String s)
suggestion Throwable exception1 = new RuntimeException("fake exception 1"); Throwable exception2 = new RuntimeException("fake exception 2");
suggestion Throwable exception1 = new RuntimeException("fake exception 1");
suggestion final Throwable exception1 = new RuntimeException("fake exception 1");
I think you forgot the type check here: if (propValue.isPresent()) {
I think you should not return null here. We should be throwing an exception here.
I think you should not return null here
Let's move this line to the FBO-related state change.
Let's move this line to the FBO line below. PerformanceMonitorLabel is redundant as the outputFboManager is created only once.
Let's move this line to the FBO line below. PerformanceMonitorLabel is redundant.
Not sure the correct message is to say DISALLOW_CONFIG_TETHERING here.
You should check the empty param here and return true if it is not null.
You should check the empty Binder.getCallingUid() correctly.
This should be moved to a constant to avoid duplication.
This should be moved to a constant to avoid duplication
This should be extracted into a constant.
Null-check
getLong?
System.currentTimeMillis()
The error message should be localized, not in this case.
The error message should probably be localized, not in this case.
The error message should be localized, not in this case. Why is the message "missing"?
unused
unused?
unused.
As far as I understand, this is somewhat misleading, because all the buildPlans() calls here are buildPlans().
As far as I understand, this is somewhat misleading, because all the buildPlans() calls here are buildPlans(), so it's not actually the buildPlans() method.
As far as I understand, this is somewhat misleading, because all the buildPlans() calls here are buildPlans(), so it's not actually the buildPlans() method that calls here.
After that, I think it's better to compile it in the constructor and set text to that.
After that, I think it's better to compile it in the constructor and set text to this.
Missed that space before the {
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldUpdateReadOnly() is being called.
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldGetReadOnly() is being called.
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldIsReadOnly() is being called.
Is it possible for for identPlayer to be null?
Is it a good idea to check for identPlayer here?
Is it a good idea to check for identPlayer being null?
You can do something like Assert.assertEquals(outputTestTargets, gtTargets.size()).collect(Collectors.toList());
You can do something like Assert.assertEquals(outputTestTargets, gtTargets.size());
You can do something like Assert.assertEquals(outputTestTargets, gtTargets.size()). You can also do something like gtTargets.get(i)
suggestion public String uploadPartCopy( String bucketName, String objectName, String uploadId, int partNumber, Multimap<String, String> queryParamMap, Map<String, String> result) throws InvalidResponseException {
This is not public.
suggestion
You can use GuiIDProperty.class::getSimpleName
You can use GuiIDProperty.class::getName
you can use GuiIDProperty.class::getSimpleName
We need to add the '@Override' annotation to the HTML view to enable these in the XML. Then if someone will add a link to the email to the end of the  HTML view it will be translated.
We need to add the '@Override' annotation to the HTML view to enable these in the UI to resolve the issue.
We need to add the '@Override' annotation to the HTML view to enable these in the XML. Then if someone will add a link to the email to the end of the  HTML view it will be displayed.
Can we remove "_partitionDiscoveryThreadMap.remove(datastreamGroup)" also?
Can we remove "_partitionDiscoveryThreadMap.remove(datastreamGroup)" prefix and use the same value for all the "partitionChangeCallback" variables?
also, should we remove the thread for interrupted state?
is this required?
java if (context.indexOf("{{BACKEND_HOST}}") > -1) { //... }
java if (context.indexOf("HIVE") == -1) { //... }
assertThat( query ).assertThat(...)?
assertThat( query )?
assertThat(...)?
Using try-with-resources makes it more readable and the code will be cleaner.
Using try-with-resources makes it more readable and the code will look cleaner.
Using try-with-resources seems to me unnecessary.
It would be nice to rename this method to match the AntiSamy implementation.
It seems to me that this method should be private.
We should rename this method to match the AntiSamy implementation, and match the overload with a new method that takes a boolean parameter.
It seems that IgniteClientException cannot be handled here
It seems that IgniteClientException cannot be thrown here
It seems that IgniteClientException won't return FAILED in this case.
log.error("Image prepare image {} on the SPM", getParameters().getParentCommand(), e);
log.error("Image prepare image {} on the SPM", getParameters().getParentCommand());
log the whole exception
Might be a good idea to return some string instead of an empty string.
Might be a good idea to return some string instead of an array of strings.
Might be a good idea to return some string instead of an object.
Eeek, eatin away exceptions?
Eeekek, eatin away exceptions?
try with resources would be clearer and more concise
s/vdo/host
s/vdo/action
typo in server.
use Arrays.asList(...) for short lists.
use Arrays.asList(...) for short lists. Same thing for above.
use Arrays.asList(...) for short lists. Same with above.
@dalifreire can't we use [this](<LINK_0> here?
@sebing Matchers.singleReturn(false)
@sebing Matchers.boolean?
nit: I'd prefer to move the parsing of the externalResourceAmountMap to a separate method, e.g. getExternalResourceAmountMap(Configuration config) {... } so we don't have to repeat the same code twice.
nit: I'd prefer to move the parsing of the externalResourceAmountMap to a separate method, e.g. getExternalResourceAmountMap(Configuration config)
nit: just one line
Add this logic into the certificatemanagerserviceImpl class.
Add this logic into the game based on the logic of this class
Add this logic into the game based on the logic of the method
please log in error
please have a log in the code
please have a log in error
Is this step needed? It seems to me this method's "protected" is redundant.
Is this step needed? It seems to me this method's "protected" is pointless.
Is this moved? It seems to me this method's "protected" is redundant.
Are you sure it is safe to determine which values are sorted according to the ConcurrentHashMap?
Are you sure it is safe to determine which values are sorted by unique values? Maybe check the seed in the hasher's values.
Are you sure it is safe to determine which values are sorted according to the equals method? My understanding is that it will work for v == 0.
I'm trying to understand if we need to write the test as follows? java ThriftTransportKey ttk1 = new ThriftTransportKey(HostAndPort.from(getResourceAsStream(token)).doAs((PrivilegedExceptionAction<SaslConnectionParams>) ).doAs((PrivilegedExceptionAction<SaslConnectionParams>) ).doAs((PrivilegedExceptionAction<SaslConnectionParams>) )).doAs((PrivilegedExceptionAction<SaslConnectionParams>) ))
I'm trying to understand if we need to write the test as follows? java ThriftTransportKey ttk1 = new ThriftTransportKey(HostAndPort.from(getResourceAsStream(token)).doAs((PrivilegedExceptionAction<SaslConnectionParams>) ).doAs((PrivilegedExceptionAction<SaslConnectionParams>) ).doAs((PrivilegedExceptionAction<SaslConnectionParams>) ).doAs((PrivilegedExceptionAction<SaslConnectionParams>) ))
I'm trying to understand if we need to write the test as follows? java ThriftTransportKey ttk1 = new ThriftTransportKey(HostAndPort.from(getResourceAsStream(token)).doAs(new ThriftTransportKey(SaslConnectionParams)), ttk2 = ttk1.hashCode()); // Do we care if the token is null?
Instead of having this here, wouldn't it make more sense to have a constant for "http" and "https://" with capital letter "http://"?
Instead of having this here, wouldn't it make more sense to have a constant for "http" and "https://" with capital letter "https://"?
Instead of having this here, wouldn't it make more sense to have a <LINK_0>
Missing final
Change this to an ImmutableList
missing final
Shall we have more than one SEARCH column?
Shall we have more than one plan?
Shall we copy the default value of the property itself instead of setting it twice?
Set this only if session details not null??
Set this only when session details not null??
final
Suppose there are two interfaces: public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.impl.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { } so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
Suppose there are two interfaces: public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.impl.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { } so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.p.s.i.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
Suppose there are two interfaces: public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.impl.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { } so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.p.s.i.i.p.s.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a LineSplitter, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a LineSplitter splitter, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a LineSplitter that takes a stream and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
I would recommend to change the assert so that the index model is updated only once.
GraphDatabaseService should removeEmbeddedDatabase from the test.
GraphDatabaseService should removeEmbeddedDatabase from this test.
Suggest adding an assert that the only task name in the list corresponds to the last invocation of setTaskName(...).
Suggest adding an assert that the only task name in the UI thread is the "Task Name".
Suggest adding an assert that the only task name in the UI thread is the "task" that has the task name.
Please use constructor with it's name.
Please use this.fieldLocation = Pair.of(fieldLocation)
Please use this.value instead of.toString()
Could we log the signature ("Entity validation failed." + certificate.toString()) instead?
Could we log the signature ("Entity validation failed." + certificate +certificate) instead?
Could we log the signature ("Entity signature", certificate)?
If instead throwing an exception when policyParameters[3] == null you log the error. I think it will return a NullPointerException when you do credentials = (byte[]) policyParameters[3].
If instead throwing an exception when policyParameters[3] == null you log a NullPointerException when you do credentials = (byte[]) policyParameters[3].
If instead throwing an exception when policyParameters[3] == null you log the error. I think you can use policyParameters[3].
In my opinion, it seems that most other metrics (memory preferred) would be the same. Any reason to change the memory vs the other metrics?
In my opinion, it seems that most other metrics (memory preferred) would be the reservation you made?
In my opinion, it seems that most other metrics (memory preferred) would be the reservation you made here *both* metrics and totalLoadTime. We can also keep that here but let's clean up some of them.
return irqState;
return irqState?
continue
This can not be public
This is not right. You should not call.trim() on them
This can not be private
This case is not so uncommon. I reported it because developers do mistakes in all weird ways. And this type of mistake causes confusion. If you push to plain git repo then please don't give up :)
suggestion final FileKey loc = FileKey.lenient(gitDirOf(name), FS.DETECTED);
This case is not so uncommon. I reported it because developers do mistakes in all weird ways.
new line
unused?
unused
is this expected to be logged? or is it supposed to be raised?
is this required?
is this required?
I'd suggest having this logic in a method to reduce duplication, like before returning the result.
I'd suggest to use [append(String)](<LINK_0> as it is simpler for this case.
I'd suggest to use [append(String)](<LINK_0> as it is simpler.
This log ends up being called multiple times, would it make sense to move this to a separate function?
This log ends up being called multiple times, would it make sense to move this into a separate function?
This log ends up being called multiple times, would it make sense to move this to a separate method?
Just curious. Why do we need to wait until this call to complete? Could this just be done in the callbackProcessorRef directly?
Just curious. Why do we need to wait until this call to complete? Could this just be done in the callbackProcessorRef?
Just curious. Why do we need to wait until this call to complete? Do we already have a callbackProcessorRef.shutdown()?
I think this can be more readable
I think this can be replaced with an ImmutableList.Builder<WorkflowScheme>.builder();
I think this can be replaced with an ImmutableList
I am confused. Assuming this is a "non-pending" reviewer, then if the Ics() is not a member of the same reviewer, then the error message with the name "testToolName". Is it a "non-pending" reviewer?
I am confused. Assuming this is a "non-pending" reviewer, then if the Ics() is not a member of the same reviewer, then the error message with the name "testTool.getIcs()" is either the or null value.
Same nesting questions
Not sure about this fix. To me this previous indentation was correct
I don't see a test where this is used (should be an invocation throwing an exception which is not caught )
Not sure about this fix. To me this previous indentation was correct and I don't see a test where it is used (I might be wrong)
I'd do: assertThat(logList.get(0)).isEqualTo(logEntry1);
I'd do: assertThat(logList.get(1)).hasSize(2);
I'd do: assertThat(logList.get(0)).isEqualTo(logEntry1);.
This cast is not needed anymore
This cast is not necessary.
This cast is unnecessary if you only type it in date
Please extract this into a private method, since it is used twice.
Please make this into a constant.
Please make this into a string constant.
Please use [org.springframework.web.util.JsonUtils](<LINK_0> for this common case.
Please use [org.springframework.web.util.JsonUtils](<LINK_0> for that.
Please use [org.springframework.web.util.JsonCodec#JsonCodec](<LINK_0> for better details
Better to create a protected method like createEngineCollectorRunner().
Better to create a protected method like createEngineCollectorCollectorRunner().
Better to create a protected method like createEngines() without create guards.
Can you elaborate why this should be in a try-with-resources block? Is it possible to get rid of the finally block?
Can you explain why this change? Is it related to this PR?
Can you explain why this change? Is it related to this change?
we should consider extracting this block to a method, since this method is used in many places.
We should consider extracting this block to a method, since this method is used in many places.
we should consider extracting this block to a method, since this is used in many places.
it can be replaced with.get(0)
it can be replaced with.get(0) here?
that's a bug. It should be expected...
inline
"git" not "send-pack"
"git receive-pack"
Should the exception be logged here?
Should be exception here.
Should just be exception here.
What is the point of this creation?
What will happen if this constructor is called?
What about other properties?
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method. You can just return the result metadata right?
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other method. You don't need a separate switch inside the method.
This is completely unnecessary.
This is by definition, we don't need to pass yaml name to the pipeline builder
This is by definition, we don't need to pass yaml name to the pipeline builder.
How about we use the isBetterOrEqual method from GeneticAlgorithm class?
How about we use the isBetterOrEqual method from GeneticsExtension?
How about we use the isBetterOrEqual method from GeneticAlgorithm class? That would force us to skip this logic now.
This is where the if statement should be for checking the value of the property for allowing for corrected times.
This is where the if statement should be for checking the value for whether it's time or not.
This doesn't seem to be used.
There are " missing" in this log message.
There's a bug in this code.
There are " missing" in this message.
encodings?
again, no need to create the array
again... :)
This is redundant with the else branch.
This is a duplicate of the else branch.
This is redundant with the previous line.
Could you update this to use String.format?
Can you update this to use String.format?
Could you update the toString method to include the table name?
Missing setAnalysis()
mon.done()?
mon.done()
put a while loop on a separate line
Lets move a while loop out of this while loop and put the iterator in a finally block
Lets move a while loop out of this while loop and put the iterator out of the loop
add java doc explaining the packageName is used for finding the package and if it is not found it is created. method name should be reflect this. Maybe this should be split up into separate fucntions
add java doc explaining the packageName of the raw type?
This method should be separate to this. Maybe throw an exception instead?
There is a lot of code duplication here. The only thing I'm afraid to do here is call the openSearch() method. Can we extract it to a method?
There is a lot of code duplication here. The only thing I'm getting a PR that makes this a bit confusing. How about just having a method that returns an Observable<Void> and call it whatever it is?
There is a lot of code duplication here. The only thing I'm getting a PR that makes this a bit confusing. How about just having a method that returns an Observable<Void> and call it whatever ends up happening?
DataByteArray.class should be replaced with StringUtils.isNotBlank(modelConfig.getWeightColumnName()).
DataByteArray.class should be replaced with StringUtils.isNotBlank(modelConfig.getWeightColumnName()). The check is in the getters.
DataByteArray.class should be replaced with StringUtils.isNotBlank(modelConfig.getWeightColumnName()). I would try to parse it here and in the enum.
if (
if ( (
final
I didn't think about the warn level here, but at least it's easier to debug.
I didn't think about the warn level here.
I didn't think about the warn level here, but at least it's easier to debug if warn is disabled?
We should change this to return Objects.equals(entry.getKey(), other.getValue());
We should change this to return Objects.equals(entry.getKey(), other.getValue());?
I guess you meant to use Objects.equals? If not, the code will be simpler.
@NielsCharlier great opportunity to simplify this to a single line (and the space after if).
@NielsCharlier great opportunity to simplify this to a single line (and a space after if).
@Serranya Please use TextUtils#isEmpty.
why aren't you using runInternalAction here?
why aren't you using runInternalAction?
Instead of calling getSucceeded(), you can add a log message.
This is duplicated code.
This method could be private.
This method could be package private
This can be removed and all the occurrences in this file
This can be removed and all related tests as well
This can be imo
Line too long
Line too long. Maybe this would be more readable?
Line too long. Maybe this would be more readable as: java if (![MINOR](<LINK_0>
I think we should load the trace in the first place. Although I do not see a reason to try to remove the trace if it is really needed.
I think we should load the trace in the first place. Although I do not see a reason to try to remove the trace if it is probably needed...
I think we should load the trace in the first place. Although I do not see a specific reason to remove the trace in the view.
@grainier Can you make this method private
@grainier Can you make this method private?
@grainier Can you please keep this method private
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Is it possible to make a check if we need to migrate outside a sync block? Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Is it possible to make a check if we need to migrate outside a Realm class? Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
I would move refreshAuthz(sess) inside the if condition (sess.getPerunPrincipal().isAuthzInitialized()) { refreshAuthz(sess); }
I would move refreshAuthz(sess) inside the if condition, so we can skip filtering when policyDefinition is not null.
I would move refreshAuthz(sess) inside the if condition, so we can skip filtering if policyDefinition is not null.
Is there a reason to use this, and put notebook() in a final block?
LOG.info, not info
Is there a reason to use this?
Please change to something like: if (value.equals(constants.preallocatedAllocation")) {... }
why is this done?
why is this needed?
What are these annotations for?
What is the point of catching the exception and then throwing it again?
What is the point of catching the exception and then logging it again?
This should be a PR
This should be a configuration
This should be a warn
Use a constant?
Use  covered by tests
Use a constant
@yesamer Maybe it is better to put this check inside if condition since it is the only place where it is used
@yesamer Maybe it would be better to extract this into a private method to be named something like scenarioGridModel.getScenarioGridColumns.
@yesamer Maybe it is better to put this check inside if condition since it is the only place where it is used.
you don't need to do this, we can just call "return" on success or failure
you can do this only once in the if statement
you don't need to do this.
The place here would be: if (new AssetDirectoryReader().setFilterExtension("js").setIncludeBundleDir(true) ) {
The place here would be one of the four extend methods.
The place here would be one of the four extend() methods.
timestamps should probably be a global static constant.
timestamps should be a local variable.
timestamps should be a global static constant.
this method can be simplified to 'getSelectedSite'
this could be simplified to!siteList.isEmpty()
this method can be static
"belonging" -> "which belong"
"belonging" -> "which belong"?
"belonging" -> "which belong")
> Sorry, I missed this in the first review. This command is not really executed - it does not really matter. But somehow it's a miss.
> Sorry, I missed this in the first review. This command is not really executed - it does not really matter. But I think this should throw an error.
> page
also assert the output schema
also assert the output schema isn't null
also test the output schema
Can you add the timestamp as an argument to the pipeRecord method?
Can you add the timestamp as an argument.
Can we add the timestamp as an argument here?
This log statement is redundant, should be warning as well
This log statement is redundant, should be logger.debug().
This log statement is redundant, should be warning as well.
why causeOfDeath is empty?
to simplify this code, maybe use new method to get the name and then use getters on it
do not add this
You might want to change the code to use isEmpty() rather than the if (!headerValues.isEmpty()) {
You might want to change the code to use isEmpty() rather than the if (headerValues.isEmpty()) {
You might want to change the code to use isEmpty() rather than the if (!headerValues.isEmpty())
Should be above *( matches(candidate) *.equals(candidate.toString())) *.add(newCandidate)
Should be above *( matches(candidate) *.equals(candidate.toString()) *.add(newCandidate)
Should be above *( matches(candidate) *.equals("*".equals(candidate.toString()))
It's strange to pass the accessor to the queryObject here, since it's already an instance variable.
It's strange to pass the query to the backend to call the backend method. I think there's a better way to do it that way.
It's strange to pass the accessor to the queryObject. Either of the following would be cleaner: 1) Created query in the updatePlaceholders method 2) The method name Created, in the update method 3) The method name Created, in the update method
{}
{} for single statement
{} for single statements
This is not needed. In super.tearDown(), all the time is restored automatically.
This is not needed. In super.tearDown(), all the test are restored automatically.
This is not needed. In super.tearDown(), all the replaced stuffs are restored.
what if the acl is not found? we should skip metadata update in this case and return false?
what if the acl is not found? we should skip metadata update in this case and return false.
what if the acl is not found? we should skip metadata update in this case and return true?
Name here would be more appropriate.
Name would be more appropriate.
Name should be before command.
java.map(dayActivity -> DayActivityDTO.createInstance(dayActivity, levelOfDetail)).collect(Collectors.toList());
java.map(dayActivity -> DayActivityDTO.createInstance(dayActivity, levelOfDetail)).collect(Collectors.toList()));
java.map(dayActivity -> DayActivityDTO.createInstance(dayActivity, levelOfDetail))
Could you please assign the URL to a local variable before opening it? This helps while debugging problems.
Could you please assign the URL to a local variable before opening the connection?
URL should be available and not hardcoded
@vilchik-elena I believe a regex here is a good idea.
@vilchik-elena I believe a regex here is a good way to handle this.
@vilchik-elena I believe a regex here is correct.
rename to extensionPointId
rename to element
rename
This does not compile.
This does not compile as that will already compile.
This does not compile as that will never be used.
this doesn't need to be a ScreenLoadCallback since it's already being handled by the PluginLoadCallback as well
this doesn't need to be a ScreenLoadCallback since it's already set in the callback above.
this doesn't need to be a ScreenLoadCallback since it's already being handled by the PluginLoadCallback as well.
move / to a constant
move this to constructor
move this to be a constant
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other 2 methods.
Consider adding an additional layer of abstraction for this block. This has very similar line as the other two methods.
In general, try to prefer Objects.toString() over string.
In general, try to keep the dc/port only if there is an invalid value. That's not the case, but it should be done by the mapper.
In general, try to prefer Objects.toString() over string().
Couldn't you move this case to the end of this switch statement?
Couldn't you move this case to the end of the switch statement?
Couldn't we move this case to the end of this switch statement?
EnvUtil.storeTimestamp should be used in the method as well.
Moving that up into the buildService.buildArchive(...) method looks a bit weird.
EnvUtil.storeTimestamp
Should be done using try-with-resources if resetPropertiesFile returns false.
Should be done using try-with-resources if resetPropertiesFile is null.
Should be done using /ObjectStore.class.
This debug output should be removed
This debug output should be removed.
This debug output is not needed
- [x] Use a constant to replace hardcoded strings
- [x] Use a constant to convert the State prefix to a string.
- [x] Use a constant to convert the State string to a String.
System.out.println("...... and path id (optional).......
System.out.println()...... and path id (optional).......
System.out.println()... instead (optional).......
Suspicious call to clientCache.get().
Should this be a concurrent Classes?
Should this be a concurrent Exception?
I think this could be replaced by : <LINK_0>
I think you should also speed up the loop to get the ItemStack.
I think you should also speed up the loop to get the ItemStacks, given the logic is just to test the presence of the ItemStack.
it would fit easily one line
one line please
one line
Perhaps we should add a new method to distinguish between these two cases: - a new Handler is created - the proxy is activated after passivation
Perhaps we should add a new method to distinguish between these two cases: - a new proxy is created - the proxy is activated after passivation
Perhaps we should add a new parameter to the FHandler to distinguish between these two cases: - a new F is created - the proxy is activated after passivation
Would be good to wrap this in a RuntimeException and log it.
Would be nice to wrap this in a new method e.g. isSchActiveTasks()
Would be good to wrap this in a new method?
@antonini > I am wondering if we should set timeoutException to null first, so that we can't throw an exception if there is no timeout, instead of throwing a TimeoutException.
@antonini > I am wondering if we should set timeoutException to null first, so that we can't throw an exception if there is no timeout.
@antonini > I am wondering if we should set timeoutException to null first, so that we can't throw an exception for this case if the timeout is less than the timeout, who knows it is the timeout. TimeoutException could be thrown if there was no timeout. The timeout is supposed to be printed twice.
This makes sense from a programming perspective. However, in our case it would be good to revert the changes.
This makes sense from a programming perspective. However, in our case it would be good to revert the changes to the sync method.
Missing braces here.
This should probably be a warn instead of an error.
This could easily be done with a call to init, then it's not that important.
This could easily be done with a call to init.
Unneeded empty line here.
Unneeded blank line here.
This also should be set in onActivityCreated
this is a temporary solution, I'd prefer to avoid the line length altogether
I see that this is a temporary edgeIndex, so I'm not sure it is safe to do the cast here.
this is a temporary solution, I'd prefer to avoid the line number (copyPairFlagsAndSpeeds)
why not use simple assertThat?
why not use simple assertThat instead of a single assert?
why?
extract DEVICE_ID_KEY and DEVICE_ID_KEY
extract DEVICE_ID_KEY and DEVICE_ID_KEY to constants, as they are used more than once.
extract DEVICE_ID_KEY and DEVICE_ID_KEY as constants, as they are used more than once.
Maybe I miss something about this, but what is the other thread?
You could declare this as private static final for brevity.
Maybe I miss something about this, but what is the other thread? For debugging?
all of these methods should be private
all formatting issues here?
all formatting
This block is scary, what happens if the view is in a text view that exists in the text view. Are we sure that we want to show the view in this case? For example, what happens if we try to highlight on a fragment in the text view?
This block is scary, what happens if the view is in a text view that exists in the text view. Are we sure that we want to show the view in this case? For example, what happens if we try to highlight on a view that exists in the text view?
This line is scary, what happens if the view is in a text view that exists in the text view. For example, what happens when you try to highlight on a different screen? Do we want to show the view in that case?
this check would be more readable: if (!allRegistryAccounts.isEmpty()) { // no default registry }
can be null and empty
can be null and empty?
I think we should also use Level.fromJulLevel here.
We should also use Level.fromJulLevel here.
We should only use UTC for the default timezone.
This should be org.apache.commons.lang3.StringUtils.isNotBlank(String) - that's what you want to do.
This should be org.apache.commons.lang3.StringUtils.isNotBlank.
This should probably be org.apache.commons.lang3.StringUtils.isNotBlank.
else not needed.
else not needed
else { is redundant
This isn't the same as the one used in the seeder. Any reason we can't use the hasher's hash function instead of a hasher?
This isn't the same as the one used in the seeder. Any reason we can't use the hasher's Hasher?
This isn't the same as the one used in the seeder. Any reason we can't use the hasher's hash function instead of the hasher?
assertThat(list).hasSize(1)
assertThat(list).hasSize(1) (and similar below)
assertThat(list).hasSize(1) (and same below)
I believe we should put private methods on SyncManager to get the account and then call those methods.
I believe we should put private methods on SyncManager to get the user from common place.
I believe we should put private methods on SyncManager to get the user user from common storage manager.
You don't need it in every Exception since you have a finally clause that will get executed at the end.
you don't need it in every Exception since you have a finally clause that will get executed at the end.
You don't need it in every Exception since you have a catch clause that will get executed at the end.
Can you factor out this block? I think it would be better than to have it in a method.
Can you factor out this code block? I think it would be better to read the whole thing inside the try block instead of db.open() here.
Can you factor out this code block? I think it would be better to read the whole thing inside the try block instead of db.open().
You can change the test to check that the effect is not _not_ aura.
You can change the test to check that the effect is on travis.
You can change the text to Deals.
you can use AssertJ assertions and check the proper error message.
you can use AssertJ assertions and check the proper messages.
you can use AssertJ assertions and check the proper messages
Missing space in "!"
two params are the same.
Missing space after "!"
You should replace GroupOperationException with checked exception if you still want to return value of this method.
Maybe it's better to use exception message to be consistent with other methods.
You should replace GroupOperationException with checked exception.
Will this cause a new feature in the compatibility version? If so, it needs to be fixed until that feature is completed.
Will this cause a new feature in the feature? If so, it needs to be fixed until that feature is completed.
Will this cause a new feature in the compatibility version? If so, it needs to be fixed until you can do it.
There is a singleton for OK Status: Status.OK_STATUS
There is a singleton for OK Status: Status.CANCEL_STATUS
There is a singleton for OK_STATUS in Status.OK_STATUS
Needs a null check for inputPath.
Needs a test for this.
Needs a null check for inputPath
should we combine the two into a single statement?
should we also check that the scanner is there?
should we also check that the scanners list does not contain the hints?
use Long.valueOf(0)
Use Long.valueOf(0)
Use Long.valueOf(0)?
Same question about maintaining type information.
Why isn't this considering an exception?
Same question about this method.
I would move this to stringutils.xml
I would move this to stringutils.
I would move this to stringutils
I can't find anything that requires unboxing but there are no methods like this: java private static Class<?> getNumericClass(int total, int total) { if (total > 18 || total <= 0) { return BigInteger.class; } else if (total > 2 || total <= 0) { return Long.class; } else { return Long.class; } }
I can't find anything that requires unboxing but there are no methods like this: java private static Class<?> getNumericClass(int total, int total) { if (total > 18 || total <= 0) { return BigInteger.class; } else if (total > 2 || total <= 0) { return Integer.class; } else { return Long.class; } }
I can't find anything that requires unboxing but there are no methods like this: java private static Class<?> getNumericClass(int total, int total) { if (total > 18 || total <= 0) { return BigInteger.class; } else if (total > 2 || total > 2 || total <= 0) { return Long.class; } else { return Long.class; } }
null check twice?
Null check twice?
if (cursor!= null) {
I don't understand this. It would be better to take a lock, but I understand that it has to be called on a different thread, and as far as I can tell, many ways to get the lock. How do you know that it is possible to get it?
I don't understand this. It would be better to take a lock, but I understand that it has to be called on a different thread, and as far as I can tell, many ways to get the lock. How do we know that it is possible to get it?
I don't understand this. It would be better to take a lock, but I understand that it has to be called on a different thread, and as far as I can tell, many ways to get the lock. How do you know that it is?
I think this is not needed since applyIfNotHandled already checks to true and the contentIfNotHandled should be set.
I think this is not needed since applyIfNotHandled already checks it.
I think this is not needed since applyIfNotHandled already checks to true and the contentIfNotHandled is not null.
* fail earlier by moving this check to DfsBlockCacheConfig.setBlockSize()? * I think we should also prevent blockSize == 0
* fail earlier by moving this check to DfsBlockCacheConfig.setBlockSize()? * I think we should also prevent blockSize == 0
* fail earlier by moving this check to DfsBlockCacheConfig.get().tSizeMustBeGreaterOrEqual1 to the above line. * I would remove the "!" check from line 96.
Shouldn't this be field declaration, in test?
Shouldn't this be field declaration, in test classes?
Shouldn't this be field declaration?
The test here seems not correct, it seems to test that the purpose of the change makes the test pass -- it's not "to test" but rather, it seems like the opposite test is not relevant here.
The test here seems not correct, it seems to test that the purpose of the change is to make sure the class is the same as the expected value. Then, it would be more "expertly expected"
The test here seems not correct, it seems to test that the purpose of the change is to make sure the class is the same as the expected value
Is this method doing anything? If not, please use Files.createTempFile.
Is this method doing anything? If not, please make it private
Is this file name acceptable? If not, please use Files.createTemporaryDir as below instead.
Use standard for loop if possible.
Use compare compare, it is easier to maintain.
Use standard for loop if possible..else if?
You can remove the log.info call and just log.info() in the while loop.
You can remove the log.info call and just log.info.
You can remove the log.info statement.
this can be simplified as: fields.stream().map(symbol -> if (isField(symbol) &&!symbol.isFinal() && (symbol.isStatic() &&!symbol.isFinal()) { fields.add(symbol); })
this can be simplified as: fields.stream().map(symbol -> if (isField(symbol) &&!symbol.isFinal() && (symbol.isStatic() &&!symbol.isFinal()) { fields.add(symbol); } )
this can be simplified as: fields.stream().map(symbol -> if (isField(symbol) &&!symbol.isFinal() && (symbol.isStatic() &&!symbol.isFinal()) { fields.add(symbol); } );
This isn't needed, there is a chance that the user will update the right title, which could be null.
This logic is duplicated in 2 places. Factor it out into a helper method.
This logic is duplicated in 2 places. Factor it out into a helper method?
maybe add a log message here? Maybe log the exception in the log message?
maybe add a timeout to the log message? Maybe log the exception in the log message?
maybe add a timeout to the log message?
Use an immutable list builder here? Or does the api support nulls?
Use an immutable list builder here? Or does the formatting check work?
Use an immutable list builder here.
s/leg/y/
Formatting issue
s/leg/los/
I think this should still be a List, since column count can be very large.
Collections.addAll(list)?
I think this should still be a List, since column count can be very large
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_0>
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_1>
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here? <LINK_0>
You don't need to check for null, the list will be empty.
You don't need to check for null, the list will be empty
You don't need to check for null, the list will be empty with "!".
I believe this line can be removed with the assertion for fileInfo
I believe this line can be removed with the next assertion.
I believe this line can be removed.
@Before methods are executed without any assertions, so it's better to remove them.
@since 9.3 skipNewDatabase()
@Before methods are executed without any assertions, is it?
This can be set in the field declaration
This can be set on the opaqueUser itself
This can be set to null.
Why miliseconds? You can't use TimeUnit.MILLISECONDS.toNanos(), which is more appropriate.
Why miliseconds? You can't use TimeUnit.MILLISECONDS.toNanos(), which is more efficient.
Why miliseconds? You can't use miliseconds.
Suggest!title.getStartDate()
Suggest!title.isEmpty()
Suggest!title.equals(title)
![MAJOR](<LINK_1> Merge this if statement with the enclosing one. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Change this comparison to use the equals method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Change this comparison to use the equals method. [![rule](<LINK_2>](<LINK_1>
I think Spotbugs complains about this. What was the reason for the else?
I think Spotbugs complains about this. What was your thinking?
I think the else branch should be removed.
is this needed?
Minor: Can you please add an overloaded method for NodeSourceNameAlreadyExistException instead of using it?
Minor: Can you please add a space after the instanceof?
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in this case.
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in this case but it fits the error message better.
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in this case but its not clear what the protocol is.
Move to the top of the class and use getBinding() to test if it is used.
Move to the beginning of the class and place this function where it's used.
Move to the beginning of the class and place this function where it is used.
It's better to use a constant for SEARCH_IN_COLLECTION.isActive() at least
It's better to use a constant for SEARCH_IN_COLLECTION.isActive() and METHOD_NAME.
It's better to use a constant for SEARCH_IN_COLLECTION.isActive() and METHOD_NOT_FOUND.
nit: The mocked environment creates 3 nodes (by default) that use AdminClientUnitTestEnv.get().
we can use TestUtils.assertFutureThrows() here too
we can use TestUtils.assertFutureThrows() here
Can you move this to CheckStoragePoolValidator?
Can you move this to CheckStoragePool?
Can you move the above check to CheckStoragePoolValidator?
Isn't this the number of mappers? Can the reducer get it instead and compare with it?
Isn't this the same as the first time? Can the reducer get it instead and compare with it?
Isn't this the same as the first line in the method?
ratePerTask -> ratePerTask?
ratePerTask => ratePerTask?
ratePerTask --> ratePerTask?
You have to do  System.out.println ;)
You need to increment depth in the loop as you do below.
You have to do  System.out.println in the code.
Missing null check on.
Missing Long id
Missing type parameter
Null check required?
Null check needed?
Null check required? :)
Same observation as WFS, often tests this test with a manual System.out
Same observation as WFS, often tests this test with a manual System.setProperty()
Same observation as WFS, often tests this test with a manual System.setProperty()?
isEmpty
size is 0
Useless.
the folder.isFile() may return null, shouldn't you check that listFiles returns null?
You could combine these two calls to folder.listFiles() and listFiles() into one.
You could combine these two calls to folder.listFiles()
@jglick why do we need to remove the declaration for the Strings? as they are unused now, no?
@jglick why do we need to remove the declaration for the Strings? as they are unused anyway, no?
@jglick In a test, there is no need to remove the declaration of the result. I'd have to update it.
Do you need the.toString() here?
Do you need the /if/else here?
Do you need the /if/else here? :)
Should this use a try { } finally? Otherwise other Throwables leak.
Should this use a try-with-resources? Otherwise other Throwables leak.
Should this use a try-with-resources block? Otherwise other Throwables leak.
This should be EntityNotFoundException#byName instead of EntityNotFoundException#byId
why did we change this. SchemaEntity should be unrelated to MLRegistry. We require having topic for schema registry to work with
This should be EntityNotFoundException#byId instead of EntityNotFoundException#byId
we have a test for asserting this? Seems like :(
inline this variable.
inline
i guess we can be more specific here?
is it necessary to send this response?
i18n
This looks like it should be a single b/c you're not duplicating the error message
Is it a good idea to throw an exception when this succeeds?
This looks like it should be a no-op.
setBot( BOT_VS_PLAYER ). make final int
setBot
setBot1 is used for internationalization, make final int
You can declare this in the scope of the if, it's only used once.
You can declare this in the scope of the if, it's not needed.
You can declare it as an empty array here.
I don't believe it is good to return null if actionMode is null. We should do something like that: boolean actionMode = actionMode!= null; if (actionMode!= null) { item.add(selectedPatientsId); }
I don't believe it is good to return null if actionMode is null. We should do something like that: if (actionMode!= null) { item.add(selectedPatientsId); }
I don't believe it is a good idea to wait for it to work before we cancel the dialog.
Can we save a line by using nextTask.getTimestamp()?
You can keep it on a local variable and use nextTask.longValue() twice.
Can we save a line by using nextTask.longValue()?
This should move to the spanRef
This should handle the case where the span is already set
This should handle the case where the span is already set.
This is an Optional if there's a chance in future to get a null pointer exception on line 135. Better to just use an Optional.ofNullable(nameIdTime)
This is an Optional where possible, however I don't think there's a better way to handle this. I'd suggest an Optional<String>, or something along those lines
This is an Optional where possible, however I don't like it.
Unnecessary; you can just pass a name argument to createProject.
Unnecessary; you can simply pass a name argument to createProject.
Unnecessary; you can just pass a name to createProject.
Nice to have a default value for includeDatabases.
Nice. I think that this field should be declared as a constant.
Nice to have a default value for includeDatabases. I think that this.sensitivity isn't required.
Should this be'refund_ref'?
Should this be an error?
Should this be a constant?
Surround connection with [Guava's ](<LINK_0> here.
I believe we should be writing to tmp key here.
I believe we should be writing to tmp dir here.
The error message should be like "Feedback session name not specified"
The error message should be something like "Feedback session name not specified"
The exception message doesn't match the condition. Is it possible to include the email type?
please rename to performOpenColorPicker
please rename to performOpenColorPickerPath
please rename to performOpenColorPickerService
if (mobileNativeBy!= null) { mobileNativeBy = new HashMap<>(); }
For better readability, please always use { and } in ifs.
For better readability, please always use curly braces
Indentation doesn't seem correct here.
Indentation doesn't seem right here.
Indentation doesn't look right
:bug: This won't work.
:bug: This is kind of weird. I'd suggest to not use '----------------' as name.
Redundant empty line
Can it be simplified to: return helixClusterAgentsFactory.getClusterParticipant();
Can it be simplified to: if (clusterParticipant == null) { clusterParticipant = helixClusterAgentsFactory.getClusterParticipant(); }
Can it be done in the constructor?
I think we should use the.append() pattern here and below.
I think we should use the.append() pattern here and get rid of the append() method below.
I think we should use the same behavior for the use of char[].
toString() is deprecated. Please use proposing.toString() instead.
getKey() and getTaskName() are duplicated in this class. Is it intentional?
getKey() and getTaskName() are duplicated
I am missing something, but isn't the primary key of the service at the end of the world? Can we make it package-private?
I am missing something, but isn't the primary key of the service at the end of the world?
I am missing something, but isn't the primary key here? This will silently overwrite the hostnames. I would suggest to remove the method from the super class, or make the default final.
Please, check whether the stream is in the ALL place.
Please check whether the stream is in the sqlIOML output.
Please, check whether the stream is in the sqlIOML output.
If you are sure that this code will not be called, how do you know that it's your last change?
If you are sure that this code will not be called, how do you know that it is a problem?
This should be error
I think we need to call for the case where the user modification the wizard or not.
I think we need to call for the case where the diagramHeaderComposite is not null in the DRepresentation.
Do you need to call the removeManager in the model?
@jaimecasero to @bxf12315 @cristianonicolai looks good, thanks!
@jaimecasero to @bxf12315 @cristianonicolai looks good. Thanks!
@jaimecasero to @bxf12315 @cristianonicolai is a great chance to include the @User annotation.
When this method is called in a try-with-resources block, I think we should call http.execute with this at the end of the method
When this method is called in a try-with-resources block, I think we should call http.execute with this at least
When this method is called in a try-with-resources block, I think we should call it in the else block and let the method crash
I think we should do IOException.warn(String, Throwable) otherwise we will still ignore the original exception and just add the original exception as the second parameter to LOG.warn(String, Throwable t);
I think we should do IOException.warn(String, Throwable) otherwise we will still ignore the original exception and just add the original exception as the second parameter to LOG.warn(String, Throwable t)
I think we should do IOException.warn(String, Throwable) otherwise we will still ignore the original exception and just add the original exception as cause.
Can a folder reference be used here?
This is a folder cache, a folder for a given file.
use edits.put
you can use Schema's isTypeForField here.
you can use Schema's isFieldInField method to encapsulate this conversion.
you can use Schema's isFieldInField method to encapsulate this type conversion
We could return at the start of this method, as it's no longer needed.
We could return at the start of this method, as it's already called in the constructor.
We could return at the start of this method, as it's already called in the interface
can we use org.apache.commons.lang3.AddressUtils#getInetAddress?
can we use org.apache.commons.lang3.AddressUtils#decode(int, int) instead?
can we use org.apache.commons.lang3.AddressUtils#writeAddress instead?
if it existed in containers, is it not sufficient?
if it existed in containers, is it not sufficient? check for container.add(container)
if it existed in containers, is it sufficient?
NaN if outputRowCount is 0
NaN if outputRowCount is zero
NaN if outputRowCount is 0?
nit: Waited here and
<LINK_0>
replace this with logger
Why are you using 0L here?
I can't imagine how this should be done, but I think it can be potentially called multiple times if the log is ledger and the data is ledger
Why are you changing the order of the log messages here?
this is the same as the method above, I think you should try to make sure that the jcrPath is not empty and you are 'empty'.
this is the same as the method above, I think you should try to make sure that the jcrPath is not empty
I think the jcrPath field should be renamed to jcrPath
maybe we can introduce a constant for INVALID_BLOCK_ID_V2 and use it here.
i'd recommend moving this to the top of the method
i'd recommend moving this to the top of the function.
Wouldn't we want to release the bug on each test?
Wouldn't we want to assert the whole bug is valid?
Wouldn't we want to release the bug on the rread?
again, this can be new ICommitMessageProvider2
again, this should be getCommitMessage(provider, finalMessage.length()).
again, test for ICommitMessageProvider2
Again, why is this outside of the if-else? It should be moved to a separate method.
Again, why is this outside of the if-else? It should be more than a switch-case.
Variable should be final.
why couldn't we return results before the analysis is completed?
why couldn't the double array be moved into the segStore?
why couldn't we return the double[]?
same issue with LOG.info. Possible configuration error.
same issue with LOG.info()
same issue
I think this should be > 0
I think this will be better as just StringUtils.trimArray to make it consistent.
I think this should be > 0 instead of > 1
I don't think this is the right place for the else. When there is a single click on the content, please change the name of the view to be "view".
I don't think this is the right place for the else. When there is a single else statement, please change the name of the method.
I don't think this is the right place for the else. When there is a single click on the content, please change the name of the page to be "view".
Please make it translatable
Why make it public?
Why make it a positive assertion?
s/public/private
s/public//
final
It should be int.
It should probably be int.
It could be Impl::new
I think this might be easier to read if youd move the parkedOffset, before the loop with a parameter, so that we don't get stuck in a loop with the 0-arg version.
I think this might be easier to read if youd move the parkedOffset, before the loop with a variable, so that we don't get stuck in a loop with the 0-arg version.
I think this might be easier to read if youd move the parkedOffset, before the loop with a parameter, so that we don't get stuck in a loop with the 0-arg version of parked.
Shouldn't we at least return at this point? Fail fast fail hard!
Shouldn't we at least log it?
Shouldn't we at least add a null value to it?
final
final?
final?
this will only work if the file is deleted, we should have a test to confirm it is being deleted.
this will only work if the file is deleted, we should have a test for that case.
this will only work if the file is deleted, we should have a check for that and abort the test.
As said in previous review: Add condition on isSequenceElement, the below code is unnecessary if isSequenceElement == false
As said in previous review: Add here a condition on isSequenceElement, the below code is unnecessary.
As said in previous review: Add here a non-Sequence case.
@Serranya Please add a else block for this if.
@vilchik-elena I think this if-else block could be removed
@vilchik-elena I think that in this case the assignment is redundant
Why do we need to check for null?
Why do we need to check for a directory here?
Why do we need to check for existence just return app?
nit: new line after }
nit: would you mind renaming ShardUtils.getReadRequests to something like isNotBlankToNull?
nit: would you mind renaming ShardUtils.getReadRequests to something like SlaveBuilder or similar?
Shouldn't the instantiation of the unsynced storage domains be moved to the domain?
Shouldn't this be unsyncedStorageDomains?
Shouldn't the instantiation of unsyncedStorageDomainsDomains be done in the constructor of StorageDomainDao?
Are these four lines necessary?
Are these two lines necessary?
Are these 5 lines necessary?
Minor nit, feel free to ignore: I prefer setCancelable(true) so you can hit the back button to leave the dialog.
Minor nit, feel free to ignore: I prefer setCancelable(true) so you can hit the back button to leave the callback.
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the setNegativeButton method call will lead to some unexpected behavior.
Btw. I think "parentCount" should be the first child of the parent, not the last child of the commit. In this case the commit creation should be moved outside of the progress view.
Btw. I think "parentCount" should be the first child of the parent, not the last child of the commit. In this case the commit creation should be moved outside of the for loop.
Btw. I think "parentCount" should be the first child of the parent, not the last child of the commit. In this case the commit creation should be moved outside of the UI.
Can we probably have an offheap resource like this? resources.computeIfAbsent(identifier, createOffHeapResource(identifier, identifierInBytes)).canExecute(OffHeapResourceIdentifier identifier)
Can we probably have an offheap resource like this? resources.computeIfAbsent(identifier, createOffheapResource(identifier, identifierInBytes)).canExecute(OffHeapResourceIdentifier identifier)
Can we probably have an offheap resource like this? resources.computeIfAbsent(identifier, createOffheapResource(identifier, identifierInBytes)).canExecute(readonly resources.put(identifier, updateConfiguredOffheap(capacityInBytes));
I am not sure if we want Exception or not, as the third arg is not used.
I am not sure if we want Exception message here. As you mentioned, the AzureException is not much useful.
I am not sure if we want Exception message here. As you mentioned, the AzureException is not log anywhere.
Is this actually possible?
Not sure if this is the right function to wait for the element to appear before the click.
Is this function used in tests?
Maybe trace here to logger instead of System.out, no?
Maybe trace here to logger instead of System.out.println?
Remove this
This can be private.
can we have this method in Log interface?
can we have this method in Log interface instead?
Can you move this condition to the beginning of the method?
You could move this condition to the beginning of the method.
You could move this condition to the if (principalId == null) block.
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class.
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class. What do you think?
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class. Perhaps a more explicitly initialized value would be nicer.
[minor] try with resources?
[nit] Space before {
[nit] formatting
I think it's not safer to call shutdownNow() inside a finally block. And should "return" be enough in case of an exception.
I think it's not safer to call shutdownNow() inside a finally block. And should "return" be enough in case of an exception?
I think it's not safer to call shutdownNow() inside a finally block. And should "return" be enough for a case where we want to return from this method?
This might be a little confusing, maybe move the initialize of the store to another place, and then line 74?
This might be worth adding a row of the store that failed to download the store.
This might be considered a bad idea, but it seems that we could save a bunch of lines of code by keeping the previous formatting in a PR
could be private.
could be private, and is more appropriate.
could be private
Can we just use Level.INFO here? suggestion LOG.log(Level.INFO, "iteration start: {0}, workload: {1}, computationRate: {2}, computationTime: {3}", new Object[]{iteration, finWorkload});
Can we just use Level.INFO here? suggestion LOG.log(Level.INFO, "iteration start: {0}, workload: {1}, computationRate: {2}, sleepTime: {3}", new Object[]{iteration, finWorkload});
Can we just use Level.INFO here? suggestion LOG.log(Level.INFO, "iteration start: {0}, workload: {1}, computationRate: {2}, computationTime: {3}", new Object[]{iteration, {3}", e);
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
i didnt see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
i didn't see change in the config.sql to make this value per-version, so it cannot be null.
Nit: Can be replaced with true.
Again, minor typo, minor typo.
Nit: Can be replaced with equals
You only need to keep this if trace logging.
You only need to keep this if trace level
You only need to keep this if trace level.
please remember formatting.
same here. formatting issue
same here. formatting.
please use getVdsGroup() instead of getParameters().getVdsGroupId()
please use here getVdsGroup()
please use getVdsGroup()
This should be a WARN instead of an ERROR.
This should be logger.error("Exception occured during bridge handler initialization of child '{}': {}", thing.getUID(), ex);
This should not be here.
We do the same ternary operator above - how about breaking this out into a seperate function.
We do the ternary operator above - how about breaking this out into a seperate function.
This logic could be simplified as: java if (StringUtils.isNotBlank(collectionId)) { sortOrderStr = sortOrder!= null? sortOrder.toString() : Collection.SortOrder.COLLECTION_DEFAULT.toString(); }
Looks like you can use "final boolean eventTypeNone = event.getType() == Watcher.Event.EventType.None;"
Is it possible that the watcher is null? Wouldn't it be better to throw an exception instead of returning null?
Is it possible that the watcher is null? Wouldn't it be better to throw an exception instead of silently ignoring it?
It would be better to deprecate toString() method. External classes may have toString() methods for some reason.
It would be better to deprecate toString() method. External classes may have toString() methods for some reason. What do you think?
It's better to deprecate toString method. External classes may have a append to the message.
This could be a static method.
This could be a get(String schema.getFieldCount()).toArray() for efficiency.
This could be a get(String schema.getFieldCount()).toArray() for readability.
Can you just test the reason reason and discontinueReasonNonCoded against an encounter?
Can you just test the reason reason and discontinueReasonNonCoded together?
Can you also test the reason reason?
I'm not sure we need to change this method. The otherOptionsGroup is already the default, so we don't need to change that.
I'm not sure we need to change this method. The otherOptionsGroup already has the default false.
I'm not sure we need to change this method. The otherOptionsGroup is already the default, so we don't need to change the name.
@adrielparedes shouldn't the Path object be in the canonical form?
@rady-krishan-singh3 Can you make this PR public?
@adrielparedes shouldn't the Path object be in the canonical form? I did not see it being used for the know
This should be private, so that it can be package-private
This should delegate to the other translateType functions.
This should be private, so that it can be package-private (no longer needed for this class)
Given we are doing multiple things at once I would prefer: Set multiple fax4ever at once at initialization time and do all the things at once.
Given we are doing multiple things at once I would prefer: Set multiple fax4ever at once I think we are doing multiple things at once I would prefer: Set<String> wsId = new OpenSourceProject(); and do all the things at once at initialization.
Given we are doing multiple things at once I would prefer: Set multiple fax4ever at once I think we are doing multiple things at once.
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously)
I am just wondering whether this snippet should not be surrounded by try/catch (as it was previously)
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously). What about in a follow-up PR?
Why not logging and then return -1;?
Does the deployment path mean that these exceptions are logged?
Nit: Space between exception and {
Could you give this exception a more specific description?
Could you give this a better name?
Could you give this exception a more specific info?
"Unable to locate app directory"
I think there should be a local variable for the Resource.
I think here should be localize() or localize()
II think you can simplify this code and remove the code duplication?
II think you can simplify this code and remove the code duplication
Does this code duplicate the code?
I think we want to have a way to pass in null here. We can get rid of that.
I think we want to have a way to pass in null for every workflow instance here. We can get rid of that.
I think we want to have a way to pass in null for every workflow instance here. We can use that to verify if we have one instance generated from the Checker thread
In the case of "cheated" there is only one time we're waiting for, but never actually receive the event (except for the time the user is interrupted). Therefore, this line can be removed.
In the case of "cheated" there is only one time we're waiting for, but never actually receive the event (except for the time the user is interrupted). Why?
In the case of "cheated" there is only one time we're waiting for, but never actually receive the complete future?
Why did you change this? It looks to me that this method is used more than once.
Why did you change this? It looks to me to "this" is in "this" method
Why did you change this? It looks to me you use this method
wouldn't it need to sort the list in this case, too? (I wonder if using a self-sorting list here would not be the better solution.)
wouldn't it need to sort the list in this case, too? (I wonder if using a self-sorting list here would not be the better way)
wouldn't it need to sort the list in this case, too? (I wonder if using a self-sorting list here would not be the better solution.)
I thought all the other onPrepareActionMode take a single try/catch can be removed.
I thought all the other onPrepareActionMode methods would do the current code as well. Currently it looks like you've fixed this activity to take a single try/catch instead of catching one.
I thought all the other onPrepareActionMode methods would do the current code as well. Currently it looks like you've fixed this activity to take a single try/catch
Class name is not needed when calling method on same class.
Class name is not needed when initializing the input.
Class name is not needed when calling method on same class
Exception can be thrown because this will be used in other places. Also, you need to be aware that the exception is thrown if it will be caught.
Exception can be thrown because this will be used in other places. Also, you need to be aware that the exception is thrown if it will be thrown.
Exception can be thrown because this will be used in other places.
Return ymax < y + width
Return xmax instead of x + width
Return xmax instead of x + width.
:x: yeah it should have a new variable with a new variable and it will be cleaner.
:x: yeah it should have a new variable with a new name
:x: yeah it should be if (visibleTerminal.hasExtension()) {... } else { // Empty code
We should probably log the error in this case the user is not attached to a request.
We should probably log the error in this case the user is not attached to the request.
I think the error message should be more descriptive.
The assert name of the project is misleading you're testing.
The assert name of the project is misleading you should explicitly mention the branch.
The assert name of the project is misleading you should explicitly mention the role.
s/ 1000/ 1000 should be a constant
.split?
s/ 1000/ 1000
I think the order of the checks here is relevant to minimize the work. We should check "firstParent" first, then SEEN and then parsing the headers if needed.
I think it makes sense to skip the parseHeaders, too, with the logic being that we haven't traversed into the other parents at all. If it causes trouble, we can make a followup change. :)
I think it makes sense to skip the parseHeaders, too, with the logic being that we haven't traversed into the other parents at all. If it causes trouble, we could make a followup change. :)
ugh again..
ugh again :smile:
ugh again wais!
Just want to make sure: do you really want to create a string with byte[], could you pls.
Just want to make sure: do you really want to create a string with byteLenght - 1 multibyte chars?
just want to make sure: do you really want to create a string with byte[], byte[], byte[], byte[].
I don't understand why you don't use the GroupGroup.Id and have simply the group as a parameter and you don't need to pass it.
I don't understand why you don't use the GroupGroup.Id and have simply the group as a parameter and you don't need to pass it as a parameter.
I don't understand why you don't use the GroupGroup.Id and have simply the group as a parameter and you don't need to pass it as the parameter.
Who uses this method? I know it was just moved to PojoIndexedTypeWorkPlan, but for now we might want to use it. Could you also re-use the method name here, for example?
Who uses this method? I know it was just moved to PojoIndexedTypeWorkPlan, but for now it seems you might want to use it. Could you also re-use the method name here, for example?
Who uses this method? Could you do this only with a return statement?
Shall we correct the indentation in line 175 and 176?
Shall we correct this block, line 175 and 176?
Shall we correct this block, the code looks looks block.
why is the lower bound 0? Should it not be at least 1?
why is the lower bound 1? Should it not be at least 1?
why is the lower bound 0? Should it not be at least 2?
Let's explicitly check whether numBlockOwnershipByEvalIdForServer is null
Let's explicitly check whether numBlockOwnershipByEvalIdForServer is null. Same for storeServerMetrics().
Let's explicitly check whether numBlockOwnershipByEvalIdForServer is not null
assertThat(getResultNonexistentUri.getFailures()).containsExactly("uri1", "uri2")
assertThat(getResultNonexistentUri.getFailures()).containsExactly("uri1", "uri2",...);
This check does not match the method name.
So ContextForUser = user == null? getStaticLooper() : thread?
So ContextForUser = user == null? getStaticLooper() : thread;
So ContextForUser = user == null? getStaticLooper() : thread; would be better.
can we simplify these if-else branches?
can we simplify these null checks by using StringUtils.isEmpty() from apache.commons.lang3?
can we simplify these null checks by using StringUtils.isEmpty()?
If anonymous Authentication is configured, this might be null so we shouldn't throw an exception here.
I'm not sure if this is the best way to handle anonymous access. In the case when anonymous Authentication is used for anonymous access, it means the publisher will be able to resolve the token without explicit access.
I'm not sure if this is the best way to handle anonymous access. In the case where anonymous Authentication is used instead of anonymous Authentication, this could be null
Also here, please check whether getServerRuntime returns returns returns not null.
Also here, please check whether getServerRuntime returns returns null.
Also here, please check whether getServerRuntime returns returns returns an empty list.
I think we should use the self-contained approach here. If the user is not on the list of exceptions, then the application won't crash. The configuration of the user is not available for them, for example, when you do throw new Exception() for it.
I think we should use {} and parameters for the exception in the log of exceptions.
I think we should use the word "HTTP" in these messages.
please remove redundant code - we have a task from parameters, and use it: getTaskIdList()
please remove redundant code - we have a task on the same VM, and use it as a parameter to update it.
please remove redundant code - we have a task on the same disk, and use it as a parameter to initialize it.
We don't need a mock here since we are just returning a new connection.
We don't need a mock like this.
We don't need a mock, we can just return the amqpConfig.
Kind of I would change DEFAULT_ORDERING to READ_ONLY
Kind of I think it is better to not set this code to DEFAULT_ORDERING at all places.
Kind of I think it is better to not set this code to DEFAULT_ORDERING before initComponents function call. line 108, probably will be good.
extra space
extra blank line
extra space.
I think it would be better to move the code inside refreshedFiles so that it starts with an empty list of projects. This way you could have two levels of projects that do not really need to be checked.
I think it would be better to move the code inside refreshedFiles so that it starts with an empty list of projects. This way you could have two levels of projects that do not start with an empty list.
I think it would be better to move the code inside refreshedFiles so that it starts with an empty list of projects. This way you could have two levels of projects that need to be checked.
Pls put the lambda into a separate line
Pls put the html string into a separate file.
Pls put the @Override annotation to a separate line
Not your fault but maybe we can fix the condition to follow: if (isPasswords) {... } else {
Not your fault but maybe we can fix the condition to follow: if (StringUtils.isEmpty(accountTypes)) {... }
Not your fault but maybe we can fix the condition to follow: if (isPasswordsEnabled()) {... }
Need to use Date.of(new Date(file), 0) instead.
Need to use Date.of(new Date(file, "UTF-8")); form to avoid the println()
Need to use Date.of(byte[], int, ) instead.
I think this is not necessary. If we have to do this, we should mark it as Nullable so that we don't need to do any null check.
I think this is not necessary. If we have to do this, we should mark it as Nullable so that we don't need to do any check here.
I think we should keep this change.
envVars
envVarsHash
envVars, entry
![BLOCKER](<LINK_2> Change this condition so that it does not always evaluate to "false" [![rule](<LINK_1>](<LINK_0>
![BLOCKER](<LINK_1> Change this condition so that it does not always evaluate to "false" [![rule](<LINK_2>](<LINK_0>
![BLOCKER](<LINK_2> Change this condition so that it does not always evaluate to "true" [![rule](<LINK_1>](<LINK_0>
Code style
Code will be more readable
Check code style
Why is this necessary?
Why is this necessary? Not sure, and wasn't the value used to be used.
Why is this necessary? Not sure, and wasn't the value used to be passed to the method?
These operations should probably be moved to ensure they are closed in case this method is called on every call.
These operations should probably be moved to ensure they are closed in case this method doesn't matter?
These operations should probably be moved to ensure they are closed in case this method is called on every call site.
It'd be nice to use a constant for this (or use it to be consistent with the other classes)
It'd be nice to use a constant for this (like Java)
It'd be nice to use a constant for this (or use it)
Maybe we can invert the if and remove corsFilterFactory the not null check in the if statement.
Maybe we can invert the if condition and remove corsFilterFactory the not null check in the if statement.
Maybe we can invert the if and remove corsFilterFactory the not null check in the if condition.
Please avoid calling getAncestorWithType directly. It's too expensive to call getInitializerClause.
Please avoid calling getAncestorWithType directly. It's also ok to call getInitializerClause.
Please avoid calling getAncestorWithType on AST. It's too early to call getInitializerClause.
this looks like a copy paste mistake
this looks like a copy constructor in GitAPIException
this looks like a copy paste mistake :D
Why aren't you using 'createNic(nic, "eth0")' here?
Why aren't you using 'createNic(nic, "eth0")'
Why aren't you using 'create Nic(nic, "eth0")' here?
I think you need to add a fix here
I think you need to add a workingDir parameter here
I think you need to add a workingDir parameter to the base directory
This doesn't seem right. Did you try replacing it with an Assert.nonNull(server) first?
This doesn't seem right. Did you try replacing this?
This try/catch block should be moved to a new method
No problem with using ITs, in tests, you use a hamcrest matcher to check that the result is the same. So status should be returned.
No problem with using ITsService.getServedPassiveEntities() here.
No problem with using Broker?
Space needed after "if"
Throwing an exception without a message is not a good idea or?
Throwing an exception without a message is a bad practice. Also, if we throw an exception in the middle of the file, we should handle it.
dar.getData() can be null
dar.getData()
dar.getData() can be null if they are
I think this can be truststorePasswordAlias instead of the string?
I think this can use truststorePasswordAlias instead of the string?
I think this can be truststorePasswordAlias instead of the truststorePath
Is this a warning? Why not throw an exception?
Is this a warning? Why not an error?
We can remove this exception or throw it with an extra message
How do we test if the first element is added to the list?
How do you know if the first element is a build result?
How do we test if the first element is present to be the list?
Any reason why this is not private?
Any reason why this is private?
Any reason why this function is private?
Small nit, you could use a constant instead of "location"
Small nit, you could use a constant instead of "location".
Typo: newLocation is unnecessary.
The selectSQL method is called for normal data extraction, there is already a separate method for that.
The selectSQL method is called for normal data extraction, there is already a separate method to handle visitors.
This is not necessary. selectSQL already returns the options.
minor: in case of a file name to path start with.java.template=> could you re-use it?
Could you make it a constant?
nit: could you make it a constant?
folder.setPropertyValue("/Folder", "DocNoFacet", "File"); doesn't exist anymore.
folder.setPropertyValue("/Folder", "DocNoFacet", "File"); doesn't mean it is obsolete.
folder.setPropertyValue("docNoFacet", "DocNotFacet"); and a single /Folder reference.
suggestion if (isClusterFormedByOnlyLiteMembers(memberList)) {
Can we fetch the member list from the client and compare it with the previous members as well?
Is this possible?
Using a switch on the String for the exception might be better here.
Using a switch on the String for the exception might be better.
Using a switch on the String for the exception might be better here?
This is not a valid log message, should it be warn?
This is not a valid log message, should it be warn or warn?
This is not a valid log message, should it be warn or error?
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set wasInterrupted to false.
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set wasInterrupted = false.
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set wasInterrupted = false..
Is it possible to avoid this initial kickoff by setting the listener before we set the listener?
Is it possible to avoid this initial listener by setting the listener on the refresh when it's done?
Is it possible to avoid this initial listener by setting the listener on the page listener?
How about using try catch instead of if else?
How about using assertTrue and assertFalse here?
How about using try catch instead of if condition?
Can we do the exact same logic here?
Can we do the exact same as return super.getCorsConfiguration(request); instead?
Can we do the exact same thing here?
What about encapsulateing this logic in a private method, something like "schedduler2 == null"...? This is not necessarily, but in my opinion, the code will be much more clean: public synchronized void start() { if (shutdown) { // do stuff } }
What is the reason behind this PR?
What about encapsulate this...
This test fails without the check.
This test fails without the catch.
This test fails without the check that the counter was updated to be 0.
Please add here the sleep in at least.
Please add here the sleeps.
Please add here the sleep above.
nit: remove empty line
nit: no need to other lines
Unnecessary?
Why are we throwing a NPE here?
Why are we throwing NPE here?
Why do we have to make this an NPE?
Why not use dependencies.addAll(diff.getRequiredBy())?
Why not use dependencies.addAll(diff.getRequiredBy()) instead of diff.size()?
Why not use dependencies.addAll(diff.getRequiredBy()) instead of diff.size()?
-> dat.hasExtendedGenotypingInfo()
Do you want to also check here that the dat is a Set?
Do you want to also check here that the dat is a collection?
suggestion.mapEntries((k, v) -> Maps.immutableEntry(v, k))
suggestion.mapEntries((k, v) -> Maps.immutableEntry(v, k)).filterKeys(CorruptionCheckViolation::raiseErrorAlert);
You can have a line break after the.mapEntries().
Should we propagate the InterruptedException to the caller? I'm a bit nervous that the thread was interrupted.
Should we propagate the InterruptedException to the caller?
Should we propagate the InterruptedException to the caller? I'm a bit worried about the original behaviour.
I don't think it's necessary to make this change here.
I don't think it's necessary to make this change here. We should just define the value as a local variable.
I don't think it's necessary to make this change here. We should just define the offset as a local variable.
Can we move this auditAcl to the common method?
Can we move this auditAcl to the auditAcl?
Why we need audit auditAcl?
I think this could be replaced with another store.remove() to avoid the cast.
I think this could be replaced with Matchers.singleton()
This could be replaced with Matchers.singleton()
I'd add a null check here: new NioNetworking(Context) and new NioNetworking(Context)
I'd add a null check here: new NioNetworking(Context) and NioNetworking(Context)
I'd add a null check here: new NioNetworking(Context) and NioNetworking(Context ctx)
No need to declare a variable here, since it will be always passed by getAbsolutePath()
No need to declare a private method, since it will be used by buildGraphs.
No need to declare a variable here, since it will be always passed by getAbsolutePath().
Please, try to do the same, as the rest of the test method.
Those 2 test cases do not belong to this test: <LINK_0>
Please, try to do the same, as the rest of the test: <LINK_0>
If this is an error, please add a message to the log.
If this is not handled, a listener must be handled and handled in the finally block.
If this is not handled, a listener must be handled and handled in the callback.
Do we want to lock this on the ResourceManager?
This is to prevent us from happening again, the lock is held by the lock
This is to prevent us from happening again, as this is a private method.
The test should verify the status of the enabled b2 of the connection. So if the test passes if the mentioned action is not a valid b3 of the test failed it will fail.
The test should verify the status of the enabled b2 of the connection. So if the test passes if the mentioned action is not a valid b3 of the test passes.
The test should verify the status of the action is NOT an error. So please do not mix this.
Based on <LINK_0> this does not work if the tag is not visible in the given tag. Changing it to \n will cause a diverired behavior that I think this is wrong.
Based on <LINK_0> this does not work if the tag is not visible in the given tag. Changing it to \n would cause a diverired behavior that I think is wrong.
Based on <LINK_0> this does not work if the tag is not visible in the given tag. Changing it to \n would cause a diverired behavior that I agrees.
Maybe you could remove this.
Maybe put this test by using @Before
Maybe put this test by tag {type}
Why this isn't static?
I think we can use project.exists() instead of "emptyArtifact.xml"
I think we can use project.exists() instead of "emptyArtifact.xml" as well.
As discussed, a metric would be useful.
I think this can just be true.
As discussed, I think this should be true.
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations.size()).isEqualTo(1); => assertThat(violations).hasSize(1);
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations.size()).isEqualTo(1); => assertThat(violations).containsAnyOf("A collection of privileges must be specified.");
This should be: assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations.size()).isEqualTo(1); => assertThat(violations).hasSize(1);
ReviewTaskEditorInput is unused now. Please remove it.
ReviewFormatter.applyReview()
ReviewTaskEditorInput is unused now. Please use editor.getActivePageInstance();
Aren't you calling this default operation?
Are you sure this is not going to work?
Aren't you calling this constant and not entry?
suggestion: keep track of the preloadedSearchResponseData.addComponents(singleton(project));
suggestion: create a new SearchResponseData(issueDto);
suggestion
Ticks don't line up. Change the 1 to match the number of calls to this method.
Ticks don't line up. The method body consumes 75 ticks.
Use the 2-argument constructor
This needs a null check, just in case.
This needs a new instance of the class. Take a look at [this](<LINK_0>
This needs a new instance of the class. Take a look at [this](<LINK_0> You can use it.
same question about if the "spent" param to getStorageDomain() might be null.
same question about if the "spent" param to getStorageDomain() may return null.
same question about if the "spent" param to getStorage() may return null.
add an error message
fail("Should fail to retrieve pipeline.");
This test doesn't seem to be used.
This is a serious bug. If the procedureName is null, why cannot call the method?
This is a serious bug. If the procedureName is null, why cannot call it?
This is a serious error message, no?
use style provided with callback instead
Why use the hardcoded numbers here?
Why use the hardcoded port here?
I suggest to get rid of the Optional.ofNullable() check.
I suggest to get rid of the Optional.empty() check.
I suggest to resolve these two references separately
I think this could be replaced with!items.contains(uploadItem))
I think this could be replaced with!items.contains(uploadItem)), because there is only one item.
Wouldn't this be better to use CollectionUtils.isNotEmpty()?
Unnecessary cast.
Unnecessary cast
Kinda pointless cast
Please use the correct logging format for the log statements.
Please use the correct logging format for the logging.
Please use the correct logging format for the log message and filter the result into the toString()
The ChatState should be set before the line above.
The ChatState.CURRENT should be updated after the line 47, not before.
The ChatState.CURRENT should probably be updated after the line 47, not before.
Can make checkOneNotNullOrEmpty and make sure it's non-null maybe?
Can make checkOneNotNullOrEmpty and make sure it's non-null?
Can make checkOneNotNullOrEmpty and make sure it's a primitive, right?
I think this lines are not required, but never mind.
I think this lines are not needed, but never mind.
I think this lines are not required, but never mind..
You can replace all the hard-coded "size" strings with constants.
You can replace all the hard-coded "Count" strings with constants.
You can replace all the hard-coded "size" strings with constants
There is a reason why the hard-coded strings are not used: newBuf.replace(newBuf, SortOrder.SUFFIX)
There is a reason why the hard-coded strings are not used here.. can you have a test with an interval
There is a reason why the hard-coded strings are not used here.. can you have a test with a comma separator
Should we consider using HttpLoggingInterceptorUtils.userCookie()?
Should we consider using HttpLoggingInterceptorFactory?
Should we consider adding an overload of this?
It would be better to check if context is a CEditor and return null if not (to avoid NPEs)
It would be better to check if context is not null and return null from resolveDebugContext()
It would be better to check if context is a CEditor and return null if not and return null.
Isn't this loop simpler?
I'm just wondering if we can move this method inside an if statement. It is totally unnecessary
I'm just wondering if we can move this method inside an if block to make it more readable
Please include clientTelemetryEnabled in toString() API
We should also rename the string wordings -> maxConnectionsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerConnection
We should also rename the string wording/info/size/
formatting
I don't think this is necessary, there is no need to check for [this]
I don't think this is necessary, there is no need to check for ModelTypeName
This removes an existing initialization from another sentinel configuration and copy it.
This removes an existing isEmpty check.
This removes an existing initialization from another sentinel.
This should probably be sslConfig.reuseSessions and sslConfig.reuseSessions.
This should be sslConfig.reuseSessions and sslConfig.reuseSessions.
This should be sslConfig.targetIsSsl =... ; sslConfig.reuseSessions =...
Can be replaced with : Collections.addAll(edge, edges)
Can be replaced with : Collections.addAll(edgeList, edges)
Can be replaced with : Collections.emptyList();
Should this be CF_METRICS_METADATA_NAME?
Should this be CF_METRICS_METADATA_NAME?
Should this return a non-null String? Is that intentional?
Do we really need to create the scriptEvaluators?
Do we need to create the scriptEvaluators for each evaluation?
Do we need to create the script codecs for each evaluation?
What's the purpose of this blank line?
What's the purpose of this if/else?
What's the purpose of this?
Should this be public? Seems like it should be protected or private.
Should this be "Open not supported"
Should this be public?
If you want to use.getUuid() to store real server instance?
If you want to use.getUuid() to store the real value.
If you want to use.getUuid instead of.get.
You will have to create an additional private method, shorter like private void submit( ActionUtil t ) {... }
You will have to create an additional private method, otherwise the service will be taking a Long time (for some reason) and it will be hard to remove.
You will have to create an additional private method, shorter like private void submit( ActionUtil t ) { // create the body }
it is not possible to mock this BrokerServiceDataHolder.getInstance().constructStoreConfiguration();
it is not possible to mock this BrokerServiceDataHolder.getInstance().constructStoreConfiguration() in particular.
it is not possible to mock this BrokerServiceDataHolder.getInstance().constructStoreConfiguration(configKey);
Use File.separator instead of "/"
Use File.separator instead of "/tmp"
Use File.separator instead.
Missing space before if
Missing space before else
Whitespace
Hm, so the logged message says that it is a thing type and not the thing of type?
Hm, so the logged message says that it is a thing type and not the thing type?
please change this to debug
Is there a reason to specify the retry factor?
Is there a constant that says that we should share it in the same class?
Is there a constant that says that we should use a static final int constant?
Minor: It's not a big deal, but you can use parameters.cutoffInclusive() if you want to be a static method. It's not a big deal though.
Minor: It's not a big deal, but you can use parameters.cutoffInclusive() if you want to be a static final variable.
Minor: It's not a big deal, but you can use parameters.cutoffInclusive() until you know are you sure.
this method looks like a leftover from the previous version of Spark 2. shouldn't it be <LINK_0>
this method looks like a leftover from the previous version of Spark 2. shouldn't it be Jedis?
this method throws an exception
I think it is not necessary to check if f2 is null, since it is above.
I think it is not necessary to check if f2 is null, since it is above
I think it is not necessary to check if f2 is null, since it is above?
I think you can move folder.exists() to ImportOperation constructor for better readability
I think you can move folder.exists() to ImportOperation.
I think you can move folder.exists() to ImportOperation constructor for better readability.
can this be called from multiple threads? If yes then there is a concurrency issue. fParameterProviders needs to be handle thread safe in this class.
Unnecessary?
can this be called from multiple threads? If yes then there is no concurrency issue. fParameterProviders needs to be handle thread safe in this class.
I'd like to pull IndexFileWriter.formatAnnotationValue into a method and reuse it as method IndexFileWriter.formatAnnotationValue
I'd like to use the method directly IndexFileWriter.formatAnnotationValue.
I'd like to pull IndexFileWriter.formatAnnotationValue into a method and reuse it as needed?
Do we need to check this?
Good to add a check for this.
Good to add a check for this!= null.
I think we may need a check for equality to the result TypeBinding.equals(bound.right, variable)
I guess we may need a check for equality to the result TypeBinding.equals(bound.right, variable)
I guess we may need a check for null. What do you think?
if (epdqGatewayResponse.getBaseResponse().ifPresent(epdqGatewayResponse -> epdqGatewayResponse.throwGatewayError())
if (epdqGatewayResponse.getBaseResponse().ifPresent(epdqGatewayResponse -> epdqGatewayResponse.throwGatewayError()) {
if (epdqGatewayResponse.getBaseResponse().ifPresent(epdqGatewayResponse -> {
nit: Indentation here is only 4 spaces.
nit: Did you mean to leave out the entire tuple after it's not being used?
nit: Did you mean to leave out the entire tuple after it's just tuple?
I think this can be shortened to: java final Ordering<String> dimValueLookups = Comparators.naturalNullsFirst(); // or for (int i = 0; i < filters.length; i++) { final Integer pValueLookups = dimValueLookups.length * Ints.rhs.peek(); if (nullHandling.nullToEmptyIfNeeded(input) ) { pQueue.add(Pair.of(i, iter)); } }
I think this can be shortened to: java final Ordering<String> dimValueLookups = Comparators.naturalNullsFirst(); // or for (int i = 0; i < filters.length; i++) { final Integer pValueLookups = dimValueLookups.length; for (int i = 0; i < filters.length; i++) { pQueue.add(Pair.of(i, iter)); } }
I think this can be shortened to: java final Ordering<String> dimValueLookups = Comparators.naturalNullsFirst(); // or for (int i = 0; i < values.length; i++) { final long long = ImmutableList.of(32); break; }
The "TableResult-await-thread" message doesn't seem to give any sense to me. The message says "TableResult-await-thread was interrupted".
The "TableResult-await-thread" message doesn't seem to give any sense to me. The message says "TableResult-await-thread was interrupted". Maybe something like "Table result-await-thread: interrupted"
The return value of this method is never used.
I would add a description when the 'error' output is already excistable
I would add a description when creating the quota with the pool.
I would add a description when the 'error' output is pretty large, and the quota should be updated.
Can you add @Override annotation?
Add final keyword.
Add final keyword
Yes this is the first thing i tried. But when I tried to empty the entry before invoking the new method.
This can be moved to the first line of the test method
This can be moved to the first line of the test
should not be new TmfNanoTimestamp
should be new TmfNanoTimestamp
should not be new TmfNanoTimestamp.
I think we could make the field field final. Please review the code and avoid that variable creation.
I think we could make the field field final. It is a best practice to specify the scope of the constructor.
I think we could make the field field final. Please review the code and avoid making object creation cost less.
I think you should use String.format("%n")
I think you should call this field userInfoUri instead of field name
I think you should call this field userInfoUri instead of id to avoid NPE
Make this something something like : boolean filter; if (Context.getGeofenceId()!= null) {... }
Make this something like : boolean filter; if (Context.getGeofenceId()!= null) {... }
Make this something like : boolean filter; if (Context.getGeofenceId()!= null) {... } else {... }
Have you checked that the test fails if the this assertion fails?
Have you checked that this test fails if the this assertion fails?
Have you checked that the test fails if this assertion fails?
Isn't it better to setReadOnly(true) here as well?
Isn't it better to setReadOnly as the status here?
Isn't it better to setReadOnly as the implementation of loadJobs in their respective maps?
It looks like DiagnosticsRequestType.DATASTREAM_STATE.toString() is redundant, since it is always datastreamed with path.
It looks like DiagnosticsRequestType.DATASTREAM_STATE.toString() is redundant here since it's used in 3 places.
It looks like DiagnosticsRequestType.DATASTREAM_STATE.toString() is redundant, since it's used in 3 places.
nit: This should be enough
nit: This should be.contains("Location", redirect)
nit: This should be.build()
Might be clearer if you actually assert that sampleRowKeys.size() and bundles.size() are 1. Also a constant might be clearer.
Might be clearer if you actually assert that sampleRowKeys.size() and bundles.size() are 1. Also a constant might be useful to make sure at least one of them is 2.
Might be clearer if you actually assert that sampleRowKeys.size() and bundles.size() are 1. Also a constant might be useful to put them in a table so that it could be updated
This also needs to be done once we decide to keep all the channels in a list.
This also needs to be reverted once #1922 is implemented.
This also needs to be done once we decide to keep all the conditions.
it is important to put dedicated method for temp workspace as well
it is important to put dedicated method for deleting workspace id, it makes sense
it is important to put dedicated method for external services as well
Please squash this commits into the commit.
Please squash this commit into the commit.
Please squash your commits into one.
this method could be changed to return a boolean value instead of throwing an exception.
this method could be changed to return a boolean instead of throwing an exception.
this method could be changed to return a boolean instead of throwing an exception (if it fails)
Please do not use asyncButOrdered.performAsyncButOrdered().
Please do not swallow exceptions silently.
Please do not repeat this over the runnable.
%s the same as %c
%s would be nice
%s
Huh, where does this go? :-)
:+1: for wrapping, move the break into a while loop and use lexer.getType()
:+1: for wrapping, move the break up into a helper method
I do not like this one. Let's make it configurable.
I do not like this. Why do we need to wait 100ms?
I do not like this one. Let's make it configurable
this is not good, we instead have it in one place..
this is not good, we instead log it
this is not good, we instead have it in the method, that is more understandable for users
this test doesn't need to be logged
this test can be replaced with assertFail(), because it will try to catch the exception.
this test can be replaced with assertFail(), because this call can be deleted later
This condition will either always be true or always be false; the code in the else should be the same as the one in FileChangeWatcher.
This condition will either always be true or always be false; the code in the else should be the same as the one in the path path
This condition will either always be true or always be false; the code in the else should be the same as the one in the path path.
You don't need to do this.
This is a really slow way to do this. At a minimum, if you are slow, do you think it's needed?
This is a really slow way to do this. It's not a blocker, it should be more probably a hoist into the if block.
Why not just pass null as an argument to constructTrieNode?
This is not necessary. You are already calling constructor for this.
Why not just _json?
Shouldn't this be debug level?
Isn't this a warning message?
Shouldn't this be a warning instead?
[optional] write this as a single line
[optional] write this as a single line or a separate 'if'
[optional] write this as a single line or several try{}finally{} block?
You can do the work and pass the Context to getContextMenuProvider
You can do the work and pass the scrachator to getContextMenuProvider
You can do the work and pass the Context to getContextMenuProvider.
We should move this into Validate.notNull() above.
We should also move this into the SignInValidator class.
We should also move this into the SignInValidator method?
Drop the cast here: diskImageList.size() > 1
Drop the cast here: diskImageList.size() >1
Drop the cast.
To verify the arguments, could you please use assertTrue(m_def.getId().equals(conditionId.FUNC_VOLT_REGEXP_POSITION)); here?
To verify the arguments, could you please use assertTrue(m_def.getId().equals(FunctionId.FUNC_VOLT_REGEXP_POSITION)); here?
To verify the arguments, could you please use assertTrue (m_def.getId().equals(conditionId.FUNC_VOLT_REGEXP_POSITION)); here?
:stuck_out_tongue:
:thinking:
:smile:
unrelated change
unrelated change?
exactRef
Does connection need to be closed for "Connection" since that is the default connection, and could be closed for "Connection"
Does connection need to be closed for "Connection" since that is the default connection, and could be closed for "Connection".
Does connection need to be closed in case of failure?
Should be in a try-finally block, otherwise it will never be closed.
Should be split into separate test cases.
Should be in a try-with-resources block here
It would be better to have an enum with values (FilterFilter) and use a map in the filter field.
It would be better to have an enum with values (FilterFilter) and use a filter value in this case.
It would be better to have an enum with default case (without a default)
This would be clearer as a for-each loop. Then you're not checking the expected number of times.
This should be assertEquals(serverErrorCodesInOrder, indexToSetCustomError); As a better alternative, the loop has just a counter of 1 iteration.
This would be clearer as a for-each loop.
I think that while getTextFoITimeRange(ISegment) is the same as getTextFoITimeRange(ISegment) but you may want to move this to the same method to keep it in its own method. Also, while you're at it, please rename it please!
I think that while getTextFoITimeRange(ISegment) is the same as getTextFoITimeRange(ISegment) but you should have only one segment and have a different aspect. In this case you will fall back to the same behavior...
I think that while getTextFoITimeRange(ISegment) is the same as getTextFoITimeRange(ISegment) but you may want to move this to the same method to keep it in its own method. Also, while you're at it, please rename it to getTextFoITimeRange()
a try/catch here is a little cleaner.
a try/catch here is a bit cleaner.
ah, I would say I'm missing something, here...
throw new IOException(ex)
Why not use try with resources?
Why not use the try with resource?
Argument exception is ignored, so this is no longer accurate.
Argument exception is ignored, so this is no longer necessary.
Argument exception is ignored, so this is no need
You should check that the returned logically exists.
You should use SoftAssertions 1. Create a new method _should().findOne(APPLICATION_ID)_ and then call it.
You should check the invocation of the mocks you created.
Is this check necessary? Seems like it would be done by parseFromSchemaFields() to have a non-null schema type.
Is this check necessary? Seems like it would be done by parseFromSchemaFields() to do it.
Is this check necessary? Seems like it would be done by parseFromSchemaFields() to have a non-null map.
nit: could you use failWithMessage here?
nit: could be catch (Throwable e) instead of toString
nit: could be catch (Throwable e)
This only runs on Gtk3. How about trying this on gtk2 instead? would this work on cocoa/win32?
This only runs on GerritGlobalModule. You can set this to not run on gtk2 instead.
This only runs on Gtk3. How about trying to set this to not run on gtk2 instead? would this work on cobdrag?
Shouldn't this be: java if (securityRealm == null) {
Shouldn't this be: String securityRealm = context.getServiceRegistry(true);
Shouldn't this be: String securityRealm = context.getServiceRegistry(true);?
what about type == Schema.Type.STRING (e.g., valueOf or STRING)?
what about type == Schema.Type.STRING (e.g., valueOf or STRING?
what about "Field to be of type string or array of strings or nullable string?
no System.gc() call?
no System.gc() before/after
no System.gc() before?
please rename to storagePools
please rename to storagePools.
please rename to storageDomainId
If it got deprecated in Gtk3.10, then it should still work between Gtk3.0. You may wanna put this around a version check instead perhaps?
If it got deprecated in Gtk3.10, then it should still work between Gtk3.0.
If it got deprecated in Gtk3.10, then it should still work between Gtk3.0. You may want to put this around a version check instead perhaps.
Is the iteration from times.type.toString() needed?
Is the loop simpler than checking the ASTValue yourself?
Is the iteration from times.type.toString() needed here?
This doesn't quite work, as create a new ModelNode for VERSION_1_2_0 and VERSION_2_2_0, but I think we should just use the value directly.
This doesn't quite work, as create a new ModelNode for VERSION_1_2_0 and VERSION_2_2_0, but I think we should not use the value directly here.
This doesn't look correct.
s/switchNotifications/switchNotifications
s/switches/switchNotifications
s/switches/switchNotifications/
s/workspace.getConfig().getEnvironments()/get(env)/
s/workspace.getConfig().getEnvironments()/cheConfig/
s/workspace.getConfig().getEnvironments()/get(env)/ is null/empty
suggestion if (sessionsBySetting.isEmpty()) {
Could return new TreeMap<>(sessionsBySetting).
Could this be the case?
the definition can be moved to the start
the definition can be moved to the CommandBase
the definition can be moved to the insertVmCommand
nit: I'd suggest inverting these two conditionals to improve readability: java if (primaryConstructorArgTypes == null) { return primaryConstructor.newInstance(generatedClass, argumentTypes); } return primaryConstructor.newInstance(class);
nit: I'd like to see the anonymous inner class here instead of calling newInstance directly.
nit: I'd suggest inverting these two conditionals to improve readability.
What is the purpose of this change?
what is the purpose of this change?
What is the purpose of this changed?
You should use a try-with-resources here to ensure that the client is closed even if an exception is thrown.
You should use assertFalse(latch.await(2, TimeUnit.SECONDS)) here instead of <LINK_0>
You should use assertFalse(latch.await(2, TimeUnit.SECONDS)); because the test is not failing if the assertion fails.
Remove, please, this variable.
Should this be a single event?
Remove, please, this should be a static variable
This is not IMHO the same as the one defined in the method name.
This is already done by the method.
This is already kept as a class constant.
- [x] Why is it necessary to change this?
We change the style in this file.
We change the order of parameters here.
There is no need to change this, the extension point should be removed.
There is no "else" here. Please remove it.
There is no "else" keyword in this method. Please remove it.
hmmmm.... how is this done for this specific session? nevermind... I guess you just need to addMinutes to the session, no?
what if extension does not return VALID_TO? I guess you have null pointer exception.
what if extension does not return VALID_TO? I guess you can return false?
can you check for empty list?
can you check for empty and add it?
can you check for empty and add it?
Please use Map<String, Object> metadata = new HashMap<>();
Please ensure that the result is logged in the constructor. In this case, we don't need to pass it inside the constructor.
Please ensure that the result is logged before calling createListenerContainer method.
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and should be removed. The same goes for the other fields.
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and should not be needed. The same goes for the other fields.
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and should not be removed. The same goes for the other fields.
Did I miss where you close this pattern?
Did I miss where you close this & the above pattern?
remove group
It's not obvious to me what a value is, but the code could be using List.of
It's not obvious to me what you mean, but the code could be using List.of
It's not obvious to me what a value is, but the code could be using List.of()
We already have a mechanism for detecting whether the port is available and this should be warn.
We already have a mechanism for detecting whether the port is available.
We already have a mechanism for detecting whether the port is available and this could be added to the Tccumulo Really.
I guess this check is not needed since we already checked for exception type in errorsToIgnore
I guess this check is not needed since we already checked for null in errorsToIgnore
I guess this check should be removed since it is handled by the annotation processor.
1. You could just make calculatedUser.getHostedEntryCountLimit() a local variable. 2. If you don't do that, I would make it final here to make it final.
1. You could just make calculatedUser.getHostedEntryCountLimit() a local variable. 2. If you don't do that, I would make it final here.
1. You could just make calculatedUser.getHostedEntryCountLimit() a local variable. 2. If you don't do that, I would make it final
maybe just throw exception instead of printing the stack trace to user?
maybe just throw exception instead of printing the stack trace to console?
maybe just throw an exception?
You could do this without asserting that metrics are not enabled.
You could do this without asserting that metrics are not enabled
You could do this without asserting that config is false, or do you need to return?
Ugh. Why do we have updatePresenceStatusForXmppProvider and updatePresenceStatusForXmppProviders? :/ I know that's not related to the PR, so I don't expect you to fix it
Ugh. Why do we have updatePresenceStatusForXmppProviders() that implement the same logic twice? :/ I know that's not related to the PR, so I don't expect you to fix it
Ugh. Why do we have updatePresenceStatusForXmppProvider and updatePresenceStatusForXmppProviders? :/ I know that's not related to the PR, so I don't expect any other changes to the PR.
This statement is never executed - it is always true.
This line is now unnecessary
final
This is not necessary as its is below
This is not necessary as it is below.
This is not necessary as its is below.
There seems to be a lot of duplicated code in this test. Would it be possible to extract the repeated code to a method?
You have this test method. Would it be helpful to have a unit test for the request token and the password, such as the expected authentication token.
You have this test method.
This check seems redundant, you can have a method that checks if the operation is not aPutOperation and a PutOperation.
This check seems redundant, you can have a method that checks if the operation is not an instance of PutOperation
This check seems redundant, you can have a method that checks if the operation is not an instance of PutOperation and if it is throw an AssertionError, and you can't do that.
this can be an error if it cannot be NULL
this can be an error if it is a valid json string.
this can be an error.
can we use a try/catch on concrete handlers
can we use a try/catch on concrete handlers like this? catch(Exception) { }
can we use the BUNDLE here?
why not make "mode" a constant too?
why not make "lux" a constant too?
why not make "set" a constant too?
we can set variable directly here.
We can set variable directly here.
There are many command with name which will be the name so please run add it only for specific commands.
CompoundRuntimeException sounds better than CompoundRuntimeException since it's not a generic RuntimeException
CompoundRuntimeException sounds better than CompoundRuntimeException since it's not a start class.
CompoundRuntimeException sounds like a bug. Should be fixed.
Also consider using StringBuilder instead of StringBuilder
Also consider this (up to you): sb.append(text.substring(low, i) + 1);
Also consider this (up to you): java StringBuilder sb = new StringBuilder(); sb.append(text.substring(low, i), 0);
Please benchmark this. The code was written this.
Does this work with a reason?
Please benchmark this.
I think better to use Util.readString(secretsFile.toPath())
I think better to use Util.readIfExists(secretsFile)
I think better to use Util.readIfExists(secretsFile) method
this should be a LOG.error to log.
this should be a LOG.error to remove.
this should be deletedMarker
flip the conditions, null check should be done before
Use NetworkUtils:isInternetConnectionEstablished
use NetworkUtils:isInternetConnectionEstablished
wait.forElementPresent(LOGGED_IN_USER_SELECTOR.replace("%userName%", userName.replace(" ", "_") );
wait.forElementPresent((LOGGED_IN_USER_SELECTOR))
wait.forElementPresent((LOGGED_IN_USER_SELECTOR) + " logged in", true);
Consider extracting validation step into a separate method
Consider extracting a method for computeEventName(String name)
Consider extracting a method for computeEventName
why swap?
why swap? I was assuming that irony was added.
why swap? They are not imported.
This is fine, but I don't think it should be part of the test using PreResponseAuthorizationCheckFilter. It should be fine to leave the auth config off the line above.
That is fine, but I don't think it should be part of the test using PreResponseAuthorizationCheckFilter. It should be fine to leave the auth config off the line above.
This is fine, but I don't think it should be part of the test using PreResponseAuthorizationCheckFilter. We should probably refactor the authConfig to have different CS status check?
this is not a good idea, you could move it into the try block and avoid the printStackTrace.
this is not a good idea, you could move it into the try block and save the dialog to only do the data validation.
this is not a good idea, you could move it into the try block and save the dialog to only do the.toString()
should we add a break here?
should we add a check to ensure the token is still there?
should we add a check to ensure this is closed?
we don't use braces around singe line blocks
we don't use braces around one line blocks
we don't use braces for such simple one-line blocks
nodeNames.length - 1?
nodeNames.length - 1?
rename to "maybe"
it will be better to use if (!StringUtils.isNotEmpty(rc.getClient())) { return null; }
it will be better to use if (!StringUtils.isNotEmpty(rc.getClient())) {... }
it will be better to use StringUtils.isNotBlank here
wrapper.getIncludedClasses already returns a list.
wrapper.getIncludedClasses() will be null safe.
wrapper.getIncludedClasses
java if ( recoveryManager == null) { recoveryManager.terminate(); } else { if ( recoveryManager!= null) { recoveryManager.terminate(); } }
java if (recoveryManager!= null) { recoveryManager.terminate(); }
java if (recoveryManager!= null) { recoveryManager.terminate(); } else { synchronized(this) { if (recoveryManager!= null) { recoveryManager.terminate(); } }
Instead of CSV, you could use [String#split(java.io.InputStream)](<LINK_1> to extract the regular expression.
Instead of CSV, you could use [String.split(DELIMITER)](<LINK_0>
Instead of CSV, you could use [String#split](<LINK_1> to extract the regular expression.
nit: can remove Arrays.asList by Arrays.asList
List<DetectedLanguageResult> -> List<DetectedLanguageResult>
List<DetectedLanguageResult>
The variable 'ninePatch' should be changed to 'days and text'.
The variable 'ninePatch' should be changed to 'days and not ninePatch'.
The variable 'ninePatch' should be changed to 'days and text' instead of ninePatch
Please remove this log entry.
Please remove this log.
Why do we need this?
This check is not required.
This check is not required. Since the table name is non-null and the default schema name is STRING, you can remove it.
This check is not required. You can remove it.
Use IWorkbenchCommandConstants.R_REMOTESIST here (also in other places).
Use IWorkbenchCommandConstants.EDIT_REMOTESIST here (also in other places).
Use IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST here (also in other places).
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> clause) and call it from the constructor.
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression>) and call it from the constructor.
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> likePattern) and call it from the constructor.
I think this is not necessary for the suspending and we're already running tasks on master right? I think you'd better pull this part outside the function
I think this is not necessary for the suspending and we're already committed this part
I think this is not necessary for the suspending
If you want to use Level.FINE, you could add this to the loggerContext.
If you want to use Level.FINE, you could put it to a loggerContext.
You don't need to collect this into a loggerContext. If you want to keep it FINE, replace Logger.debug.
In most places you've changed using of getter to direct access to the members, here you didn't do that, was that intentionally?
In most places you've changed using of null to comparison. Please, reformat your pull request.
In most places you've changed using of null to comparison to "".equals - Why?
Files.move(rootDir.toPath(), tmp.toPath()?
Files.move(rootDir.toPath(), "rootDir.getName())?
Files.move(rootDir.toPath(), "rootDir.getName())"
Log level should be warn
Should be "repositoryId"
Should be "repositoryId".
else if ( persistFile.length() == 0) { LOGGER.warn("found empty file no lookups to load", e); return Collections.emptyList(); } else if ( persistFile.length() == 0) { LOGGER.warn("found empty file no lookups to load [%s]", persistDirectory); return Collections.emptyList(); } lookupBeanList = objectMapper.reader(new TypeReference<LookupBean>());
else if ( persistFile.length() == 0) { LOGGER.warn("found empty file no lookups to load",", persistDirectory); return Collections.emptyList(); } else if ( persistFile.length() == 0) { LOGGER.warn("found empty file no lookups to load [%s]", persistFile.getAbsolutePath()); return Collections.emptyList(); } lookupBeanList = objectMapper.reader(new TypeReference<LookupBean>());
else if ( persistFile.length() == 0) { LOGGER.warn("found empty file no lookups to load", e); return Collections.emptyList(); } else if ( persistFile.length() == 0) { LOGGER.warn("found empty file no lookups to load from [%s]", persistDirectory); return Collections.emptyList(); } lookupBeanList = objectMapper.reader(new TypeReference<LookupBean>());
do we always want to log the response?
do we always want to log the successful response?
do we always want to log the error?
Please use new EntityModel<String>(Arrays.asList(network.getId(), ListModel<IpVersion>.class));
Please use the new EntityModel<String>(Arrays.asList(network.getId(), ListModel<IpVersion>.class));
Please use the new EntityModel<String>(Arrays.asList(network.getId(), ListModel<IpVersion>.class)); instead of doing these two lines manually.
Can you explain why you don't use the same test case? Is there a different test case?
Add an assertion to verify that the newQuestion is actually visible?
Can you explain why you don't use the same test case?
Why we need this lock?
Better to catch RuntimeException.
Why this catch block?
here we should use instead this line
here we need to use instead this line
here we should use instead this pattern with reference to the attribute
I don't think we should have a hash here. On the other hand, a hash of "put(key)" is ambiguous, but I'd prefer a hash here.
I don't think we should have a hash here.
I don't think we should have a hash here. On the other hand, a hash of "put(key, a)" will resize() will be called before the size is checked.
nit: if it's empty, might as well just pass the checkLevel into the constructor?
nit: if it's empty, might as well just pass the checkLevel into the constructor
nit: if it's empty, might as well just return compilationResult.errors?
Could you include the state in the error message?
Could you include the state in the message?
Could you include the state in the log statement, e.g.
should be removed.
is there a reason to change this to serverId?
is there a reason to change this?
Thanks, I'm a little bit squeasy about generating the factors from unit tests. Let's discuss this in <LINK_0>
Thanks, I'm a little bit squeasy about generating these exceptions: <LINK_0>
Thanks, I'm a little bit squeasy about generating these exceptions
I don't think there's a need to check the size of newData array here. If the data is empty, byte[] should be enough.
I don't think there's a need for this if statement.
I don't think there's a need to check the size of newData array here. If the data is empty, we should return a zero byte.
This seems wrong. We should be able to detect the default spiller which is not set by the caller. E.g. if the FORCED_SPARK is not set, the socket should be loaded.
This seems wrong. We should be able to detect the default spiller which is not set by the caller. E.g. if the FORCED_SPARK is not set, the socket should be available.
This seems wrong. We only push the unknown cost to the caller.
Can we change it to ongoing SNAPSHOT_SYNC?
Can we change it to ongoing SNAPSHOT_SYNC?
Can we change it to ongoing SNAPSHOT_SYNC before we start snapshot?
I wonder if we should log here a warning when we're reconnecting to the connection. What do you think?
This method doesn't need to be synchronized.
I wonder if we should log here a warning when we're reconnecting a connection. What do you think?
in.NET client, I think we should introduce a Util class for this.
in.NET client, I think we should introduce a Util class for this instead of null check.
In VmGuestContainerListModel you have to add a method "isQutoable()" which will handle this case automatically.
Can we use the package private methods here? I don't see any gain of using fully-qualified class names, but I'd have thought that we could also use the package-private methods here.
Can we use the package private methods here?
Can we use the package private methods here? I don't see any gain of using fully qualified names, but we could have a class with a package-private scope.
instead of project name create new path to make it generic
instead of this create table, shall we create an empty dump directory?
instead of project name createFunction0
try using stream API instead
try using streams instead
try using stream API
It's probably better to say: "Request to terminate work. Number of samples"
I'm not sure if that is a good idea. If that's the case, maybe it should just return false?
I'm not sure if that is a good idea. If that's the case, maybe it should just return false and let every node terminate work.
if (sigatureAlgorithm == null) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);
if (Strings.isNullOrEmpty(kid)) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);
if (sigatureAlgorithm == null) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);?
We're no longer using the stored values in the location. Let's call removeAll instead of getAll.
We're no longer using the stored values in the location. Let's call removeAll instead of getPoss()
We're no longer using the stored values in the location.
Would it not be sufficient to have isParticipant()() return a boolean here, like was done above?
Would it not be sufficient to have isParticipant()() return a boolean here, like was done in the other class?
Would it not be sufficient to have isParticipant()() return a boolean here, like was done in the other callbacks?
Do we need the fully qualified class name here?
Do we need the fully qualified name here?
Do we need the type cast here? if it could be just Stream<Archive<?>>
Instead of logging it here, could we log the ID of the entity as well?
Instead of logging it here, could we log the ID of the entity and return it?
Instead of logging it here, could we log the ID of the entity as well? (Or pass it to the scheduler.submit)
style nit: no braces around single line blocks
better use isEmpty()
don't use StringBuilder.
where do we check that the task is not null?
Basically the same issue as mentioned above, I believe.
Basically the same issue as with the changeUser method.
Google Java style always uses braces for single line blocks
Google Java style always uses braces for flow nothing
Please add a logger
s/isNamespaceEnabled/isNamespaceEnabled
s/isNamespaceEnabled/isNamespaceEnabled/
> // get root ACL status again
can you wrap this in a try-with-resources.
can you make this method private?
can you make this method private?
This is a bit confusing, I think this test method's basically the same as the one above. Could you please change this to assertThat(client.conjureLockRequest).lock()?
This is a bit confusing, I think this test method's basically the same as the one above?
This is a bit confusing, I think this test method's basically the same as the one above. Could you please change the tests above?
This wasn't wrong before? This should be a switch statement
This wasn't wrong before, this a fmald into presto-large PR.
This wasn't wrong before? This should be a switch, and no break.
Nit: for debug level, please use paramaterized logging
Nit: for debug level, please remove extra space before.
Nit: for space before the,
Why do you need this? It seems to me that the fix works fine without it.
Why do we need this? It seems to me that the fix works fine without it.
Why do we need this? It seems to me that the logic should be moved into the else block.
It's preferable to use slf4j's parametrization instead of string concatenation.
I think you can simply change the return value of Utils.readFile() to return null if the user does not pass the Exception.
I think you can simply change the return value of Utils.readFile() to return null if the line param does not exist.
I believe this doesn't need to be passed to the compile method. Yes, it's on purpose, but we should keep it on one line.
I believe this doesn't need to be passed to the compile method. Yes, it's on purpose.
I believe this doesn't need to be passed to the logger, in case any file needs to be created.
I think this is not needed as the next statement will take care of the thread.
can you post this change in the future?
I think this is not needed as the thread will take a while
Nit, I don't think this error message is appropriate. I remembered @lei-xia reviewed this in the previous ticket, this path invalidation is not an error in the server. So keeping info (or warn) may be good enough.
Nit, I don't think this error message is appropriate. I remembered @lei-xia reviewed this in the previous ticket, this path invalidation is not an error in server. So keeping info (or warn) may be good enough.
Nit, I don't think this error message is appropriate. I remembered @lei-xia reviewed this in the previous ticket, this path invalidation is not an error in the server. So keeping info (and warn) may be good enough.
Good candidate for a method like getIndexTask(String)
Good candidate for a method below.
Good candidate for assertTrue
I think for some reason this code is not working on older platforms, for instance relative to java, not DiagramUIPlugin.getDefault().logError("Invalid uri: " + e.getMessage());
I think for some reason this code is not working on older platforms, for instance relative to java, not DiagramUIPlugin.getDefault().logError("Invalid uri : " + e.getMessage());
I think for some reason this code is not working on older platforms, for instance relative to java, not DiagramUIPlugin.getDefault().logError("Invalid uri: " + e.getMessage(), e);
not necessary?
Minor typo in the variable name
not sure if we want to modify the live host name?
Is this method used? If not, maybe add a isEmpty method to the DigestUtils doesn't need to be updated?
Is this method used? If not, maybe add it to the DigestUtils doesn't need to be updated?
Is this method used? If not, maybe add a isEmpty method to the DigestUtils doesn't need to be merged?
please use "value".equals(attribute.getNodeName())
please use "value".equals(tag) instead of ==
please use "value".equals(tag) instead of == name
what's the reason for using Guid.Empty.equals()?
please use Guid.isNullOrEmpty
what's the reason for having two lines here?
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if we ever get offline support implemented. maybe we should just promise it will be there if we ever get offline support implemented.
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the user were offline. maybe we should just promise it will be there if we ever get offline support implemented.
This IMHO introduces a rather surprising piece of code that is hard to understand. What about extracting a relativeTo(U) method that returns the appropriate FunctionScope?
This is a bit hard to read. I would move it out of the if.
This IMHO introduces a rather surprising piece of code that is hard to understand. What about extracting a relativeTo(String) method to a very general method?
I think the logic should be inside solrLoggerService.postWorkflow(usageWorkflowEvent) method, no?
Needs to be done in the if (event instanceof UsageEvent) {
I think the logic should be in the solr logger service.
Can you check your identation settings?
Can you check your identation settings instead of CoinRewriter?
Please check your identation settings. You should check this settings.
"Finish calculating. Time spent: {} ms."
"Finish calculating. Time spent: {}ms."
"Finish calculating. Time spent: {} times."
What is the host used for? The host will be null if it is not set to null.
What is the host used for? The host will be null if it is not set to NO_ALIGNMENT_START
What is the host used for? The host will be null if it is not set to NO_DATA volumes
It's confusing to put this in the exception message instead of just the message.
Instead of duplicating the error message, it would be better to put it in the layout message itself (e.g.: The main content of the application's meta data), to reduce this exception message.
It's confusing to put this in the exception message instead of the generic Exception
Please remove this try/catch.
I think we should use the logger here
I think we should use the logger here.
Do we really need to return an empty list?
Do we really need to return an empty list instead of null here?
seems to be unused
Why should onUnityAds be called on ModelyAds? Can you check if mPlacementsInUse is null?
Why should onUnityAds be called on ModelyAds? Can you check if mPlacementsInUse is present?
Why shouldn't the adapter be on a placement ID?
Perhaps add the latch after unsubscribe and use it when eventually.
Perhaps add the latch after unsubscribe and use it when only for testing.
unsubscribing
are you sure thatrepresentation is not null?
what is this null?
what is this null check for?
I think that this message should be improved. Can you elaborate on why we didn't specify workspace name?
I think that this message should be improved. Maybe it makes sense to add machines, for example using default workspace name.
I think that this message should be improved. Maybe it makes sense to add machines, for example using default workspace.
I think this check should be part of the if (record.getSchema().getField(keyField).getSchema().isNullable()) check, right?
I think this check should be part of the emitter.emit((String) record.get(keyField).getSchema().isNullable()).
I think this check should be part of the emitter.emit((String) record.get(keyField).getSchema().isNullable()) check. It will be more clear if the record is null or not.
Isn't there some simple little library for generating JSON output?
Isn't there some nasty statement about generating JSON output?
Isn't there some nasty JSON-based parsing of JSON output?
you can flip the type after the flip call.
you can flip the order of the parameters in the callExpressionMetadata
you can flip the order of the parameters in the callExpressionMetadata (to order)
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL) as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as PDataType.TIMESTAMP.toObject(finalResult, PDataType.TIMESTAMP), as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as PDataType.TIMESTAMP.toObject() as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
I'm afraid we need to add an API in the interface, because if function was called in a json file you will be able to get back the String. But the function actually works, because we just add a convenience method to get the JsonNode using the JsonNode.
I'm afraid we need to add an API in the interface, because if function was called in a json file you will be able to get back the String. But the function actually works, because we just add a convenience method to get the JsonNode using the JsonNode constructor (method in this case) to make sure that we always return the same JsonNode as an InputStream and make use of the Jackson mapper in the JsonNode.
I'm afraid we need to add an API in the interface, because if function was used to get the String value from the json, and it is too big. In any case, function function can return the String value.
Can be replaced by s -> {}
Can be replaced by s -> {
Can be replaced by s -> { }
This log message should be changed to "ClearPRMessage.send: recipient is {}, msg is {}"
This log message should be changed to: "ClearPRMessage.send: recipient is {}, msg is {}
This log message should be changed to "ClearPRMessage.send: recipient is {}, msg is {}
It seems busy to stream/map the list into a string. We can go straight there java.put(TESTER_NAMES, testnames.stream().map(ProjectTesterImpl::maybeQuote).collect(Collectors.joining(",")));
It seems busy to stream/map the list into a list. We can go straight there java.put(TESTER_NAMES, testnames.stream().map(ProjectTesterImpl::maybeQuote).collect(Collectors.joining(",")));
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java.put(TESTER_NAMES, testnames.stream().map(ProjectTesterImpl::maybeQuote).collect(Collectors.toList())
I would suggest to move this into the constructor, and use that in both places.
I would suggest to use this instead: this.myField = "";
I would suggest to move this into the constructor, and use that in both places where you need the above.
Here we can just use fail() since it is the default value of fileSizeDir.setWritable(false).
Here we can just use fail() since it is the default value. (you'll need to add another.)
Here we can just use fail() since it is the default value of fileSizeDir.setWritable(true).
Why do we need frontend changes when we don't plan to expose VmPool in a separate patch?
Why do we need frontend changes when we don't plan to expose VmPool in a separate patch? We can just use migration to validate it.
Why don't we return here?
I'm not sure if this rule also applies to the remote plugin.
I'm not sure if this error message is correct or not.
I'm not sure if this iteration is correct or not, if we expect thread to start again, we should get interrupted back to the thread that starts the remote debugger.
I like how this method is called in many places, rather than logging the error. We should throw the exception instead.
I like how this is done in the operation
I like this
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this more time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration") since that's what we want?
Can we get rid of Integer.toString(numberOfSnapFilesToKeep)} the same way?
Let's replace this with a call to Integer.toString(numberOfSnapFilesToKeep)}
Can we get rid of this create method?
This would seem clearer as List<String> values = Arrays.asList(key, csRegex.getKeys(false))
Please move these out for a private method.
Please extract these out into a private method.
There are some project types that are not abstract by this module or, for example, unpublished project -> dependencies.
There are some project types that are not abstract by this module or, for example, unpublished project.
These should be warn
Shouldn't you reset it to true even if the template is not found?
Shouldn't you reset it to true even if the template has been initialized in the command before?
Shouldn't you reset it to true?
else is redundant
else is not needed
else is not necessary
The admin has access to this node. But this is only used by tests. I think it should be done within initializeDisksAndReplicasOnNode.
The admin has access to this node. But this is only used by tests.
The admin has access to Helix before.
Use getBackend() instead
1. On the other hand, this looks like a generic method. 2. RemoveImage is executed in the execute phase but there there is no other way to do it. 3. Add a new RemoveImageParameters() method to RemoveImageParameters and move the common code to it.
1. On the other hand, this looks like a generic method. 2. RemoveImage is executed in the execute phase but there there is no other way to do it. 3. Add a new RemoveImageParameters() method to RemoveImageParameters and move the common logic to it.
please add a null check for osId
please move to the next line.
please move this class to a constant.
Can this be done outside the try block?
fp fp.getSourceName()?
fp fp?
A good practice do not to negate condition. In this case you can do: if (lbConfig!= null && lbConfig.getPortRules()!= null) {
A good practice do not to negate condition. In this case you check if it's a managed service more than once.
Nit: we can use CollectionUtils.isNotEmpty()
java @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; DefaultValue<?> parameter = (Parameter) o; return Objects.equals(name, parameter.name); }
java @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; Parameter parameter = (Parameter) o; return Objects.equals(name, parameter.name); }
@Override
would it be better to debug this message?
would it be better to debug this message? I'm not sure what this number means.
would it be better to debug this message? I'm not sure what this is doing.
missing @Override annotation
Please fix this map
Please fix this map.
Would be nice to pull this logic out into a service service (like the one above)
Would be nice to pull this logic out into a service method and not have to repeat it in each call.
Would be nice to pull this logic out into a service class and have a descriptive name. Something like sendAddToPlaylistMessage(entry)
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>() );
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent(category, ignored -> new HashSet<>() );
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.getOrDefault( category, ignored -> new HashSet<>() );
Can be simplified to: if (depth >= depth) {
Can be simplified to: for (String childrenEnum : children) {
Can be simplified to: for (String childrenEnum : children) {...
Won't repairedPoints always be called in a thread-safe manner? Do you know what rollups is?
Won't repairedPoints always be called in a loop? Do you want to log something higher than warn?
Won't repairedPoints always be called in a thread-safe manner? Do you know what rollups is.
Should probably be: "Users:".
Should probably be: "Users:"
Should this be in the if/else statement?
s/1/INDEX/?
s/merge/
s/merge/delete
This looks strange. Can we use RecursiveSubMonitor in the fetch method?
This will be inconsistent with the value of subMon.newChild(work) in the Quota branch.
This will be inconsistent with the calcite branch of the subrick.
suggestion final List<String> userIds = Collections.emptyList();
suggestion } catch (final InterruptedException e) {
suggestion final List<String> userIds = Lists.newArrayList(jenkins);
This block is duplicated code. we can create a method initYoutubePlayerFragment() in SalesforceSDKManager instead of duplicating code.
Better to create a new initializeActivity method call after setVideoModel() is called.
Better to create a new initializeActivity method instead of using getChildFragmentManager().
I don't think this is needed. If we have only one workingTreeIterator in the file visitor, it will equal the attribute to false, right?
I don't think this is needed. If we have only one workingTreeIterator in the file visitor, it will equal the attribute to false, and also one is not 'true'.
I don't think this is needed. If we have only one workingTreeIterator in the file visitor, it will equal the attribute to false, and also one is not "true".
It would be good to validate that the Addresses are the same VOA and Addresses are equal.
It would be good to validate that the Addresses are the same VOA, otherwise all the Addresses are equal.
It would be good to validate that the Addresses are the same VO and not just AIUI.
I would prefer to use same code as in method getProjectRelease final Set<String> releaseIds = project.getReleaseIdToUsage().keySet(); for (string releaseId : releaseIds) {...
I would prefer to use same code as in method getProjectRelease final ProjectReleaseRelationship [] releaseIdToUsage = project.getReleaseIdToUsage().keySet() and use it.
I would prefer to use same code as in method getProjectRelease final ProjectReleaseRelationship.
instead of key -> expirationManager.handleInStoreExpiration(key), should we use getAccessInStoreExpiration instead?
instead of key -> expirationManager.handleInStoreExpiration(key)
instead of key -> expirationManager.handleInStoreExpiration(key), should we use log.error(message, e) instead?
Nit: if you are using a BigDecimal you wouldn't need to cast to String here
Nit: if decided to avoid using BigDecimal as mentioned above with Long.valueOf.
Nit: if decided to avoid using BigDecimal as mentioned in the other methods
I'd change this to logK8055 as well.
I'd change this to debug?
I'd change this to logK8055 too?
You don't want to move them all to hamcrest?
You don't want them all to move them all to hamcrest?
You don't want to move them all into hamcrest?
Why do you move this check to the beginning of the method?
Why do we move this check to the beginning of the method?
Why do you move this check here and in the next line?
Please remove this variable
Please remove this?
final?
please rename to "decimalPlaces"
please rename to "limit"
please rename to "otherId"
rename to fragmentSpecification
rename to fragmentRequiredBundle
rename to fragment_level
You can iterate over table.getGlobalMapKeysValues() instead of creating a new one.
You can iterate over table.getGlobalMapKeysValues() here, without creating a new ArrayList
You can iterate over table.getGlobalMapKeysValues() instead of creating a new list.
[/\\\\] -> [space][space]
[/\\\\] -> [space]
String#split() might be more appropriate here since it takes a regex.
This will cause the thread to hang if the project list is not connected to Gerrit server, I don't think that call to getConfig() is good enough.
This will cause the thread to hang if the project list is not connected to Gerrit server, I don't think that call to a finally block is needed if the command is not connected to Gerrit server
This will cause the thread to hang if the project list is not connected to Gerrit server, I don't think that call to a finally block is needed if the command is not connected to Gerrit.
Can you add some log that the query conf is already set
Can you add log for the user? Will be good to know if it already exists
Can you add some log that the query conf is already set?
The metrics should be added at the end of the file now
The metric names should probably be called'received'?
This should probably be called Metrics.newHistogram().
How come the tests are failing if the entry entry exists?
How come the tests are failing if the entry exists?
How come confirming that the entry exists in the map?
Typo, should be card1
Typo, should be card1.
Why is this still an NPE?
If we are testing and error message, we should have at least one test with a message like ".links[0].rel/{tagId} <LINK_0>
If we are testing and error message, we should have at least one test with valid data.
If we are testing and error message, we should have at least one test with a message like ".links[0].rel/{tagId}/{links[1]rel}
I believe it should be possible to refactor optJSONObject in a more general way. This is the same for all the other cases.
I believe it should be possible to refactor optJSONObject in a more general way. This is the place where the values are checked.
I believe it should be possible to refactor optJSONObject in a more general way. This is the place where the values are used.
This should also be moved to call loadFromServiceAsync
Move this outside of done listener to keep in mind for now.
This should be moved outside of the done listener, to keep it more clean?
Not sure if this works. Can you show a warning in Eclipse?
Not sure if this works. Can you show a warning message?
Not sure if this works. Can you show me a warning message?
unnecessary parens here and on lines 137-138.
unnecessary parens around the return.
unnecessary blank line
Can we make it a warning level log?
Can we make it a log message?
Can we make it debug level since it was silently empty?
maybe split by "," only, the list will be empty and the trim() will throw a NPE on line 135.
This cannot work. The f is a file or folder folder folder. It is not a valid constructor to add the subfolder.
maybe split by.trim()?
Pattern.compile should be done only once.
The pattern is designed to be a field of the class, so you don't need to use a field for the path. The toString method will be called for every request.
Pattern.compile should be called only once.
Shouldn't we be setters here?
na should be na?
Shouldn't we be calling setNamespaces for every NamespaceNode?
should this be an error instead of a debug?
should this be an error or error?
should this be an error instead of a warning?
Use 'instanceof' instead of a null check.
Use 'instanceof' rather than 'null'
Use a constant instead of a null check.
String.format?
String.format
not needed, I think.
please remove '=='
please, remove '=='
Please remove '== null' because it was added in java 11
static import
use this.
static
Consider making these constants at the top of the class. Makes it easier to read.
Consider making these constants at the top of the class. It is easier to read.
Consider making it final.
can we remove this?
can we remove this "if" too?
can we remove this "!" as well?
static import
(nit) for readability
... what about static imports?
cache?
Typo: "main"
Typo?
use [GantsConstants](<LINK_0>
[minor] Space before {
(minor) this can be simplified to just one line lambda
Is the old method, <code>updateFeedbackQuestion</code> still used in the code?
The old method, <code>updateFeedbackQuestion</code> still has to be changed. We should be able to replace it with the new method, <code>updateFeedbackQuestion</code>.
Are the old method, <code>updateFeedbackQuestion</code> still used in the code?
I think this line should be : java if (webViewActionMode!= null) { webViewActionMode.finish(); }
I think this line should be removed.
I think this line should be : slightly_smiling_face:
Code style: Always use curly braces.
Code style: Always use curly braces and the formatting rules.
Code style: Always use curly braces and else blocks.
It might be better to use a LinkedHashMap, which preserves the order in which the order is preserved. Otherwise, the caller may think there's a problem with the order by putAll, etc.
It might be better to use a LinkedHashMap, which preserves the order in which the order is preserved. Otherwise, the caller may think there's a problem with this iteration.
if you have a loop, then you can use the same stream instance as you did above, and avoid the double copy.
There are a couple of copy-paste lines here. try { reader.readEvents(10); reader.commit(); } catch (IOException e) { Assert.assertTrue("Unexpected files were sent", expectedLeftFiles.isEmpty()); }
There are a couple of copy-paste lines here. try { reader.readEvents(10); reader.commit(); Assert.assertEquals("Expected 0, not: " + trackerFiles, count); });
There are a couple of copy-paste lines here which has the same issue. try { reader.readEvents(10); reader.commit(); Assert.assertEquals("Expected 0, not: " + trackerFiles, count); });
The outlinePage is not null so we don't have to protect against this.
The outlinePage is not null so we don't have to protect against NPEs.
The outlinePage is not null so we don't have to protect against null.
refactor this method to use the non-static constructor in the base class.
refactor this method to use the non-static constructor in the base class?
refactor this method to use the multi-field constructor and a handle the error message with the error message.
I think we should close the StringReader after unmarshaling.
I think we should add an else statement here to make sure we're not adding any null information.
I think we should add an else statement here to make sure we're not adding the right importXML.
We may want to add a argTypes arrays as well as size2 and len2AuthorizedClientDataRowMapper.
We may want to add a argTypes parameter to this.jdbcOperations.query() method.
We may want to add a argTypes parameter when possible
This isn't really a good idea, as we're just adding resolver requests for every cubes
This isn't really a good idea, as we're just adding new cubes here and not needing to write them in the cubes. It's also good to make sure that they're used as map ofcube.
This isn't really a good idea, as we're just adding new cubes here and not needing to write them in the cubes. It's also good to make sure that they're actually used as map ofcube.
Can we change this to the field's local variable? RateLimiterRegistry::createRateLimiterConfig and rateLimiterConfigurationProperties.createRateLimiterConfig()
Can we change this to the field's local variable? RateLimiterRegistry::createRateLimiterConfig and rateLimiterConfigurationProperties.createRateLimiterConfig.
Can we change this to the field's local variable?
minor: remove empty line
minor: remove empty lines
more readable with size(1)
Please benchmark this. The code was written this way for a reason.
Please benchmark this. The code was written this way for applying this.
Does this work with a reason?
Change the name of the test when not used when not used
Change name to __ when not used
Change the name of the test when not used
Might be worthwhile to also factor this out into a method getInstructor to be consistent with getStudent below.
Why is this if statement necessary?
Why is this catch block?
well, of course I can read the code and understand, but - still, maybe enum is better.
well, of course I can read the code and understand, but- still, maybe enum is better.
well, of course I can read the code and understand, but... maybe enum is better.
It uses org.eclipse.sirius.common.tools.api.util.DebugUtil.getDebugEventListener(IStatus, String)
It uses org.eclipse.sirius.common.tools.api.util.DebugUtil.hasFocus(String, boolean)
It uses org.eclipse.sirius.common.tools.api.util.DebugUtil.hasFocus()
Please add final keyword.
should be if (logExceptions == null)
Please add final
I'm not exactly sure this is the correct way to do this. The block below is trying to get the header of the post. Might be better to just have one if clause with an empty string.
I'm not sure whether this is the correct way to do this. The cache must be able to read the image, not only the one that is being sent at a time. This is probably not a good idea, but might be worth moving it to the threadPresenter level.
I'm not exactly sure this is the correct way to do this. The block below is trying to get the header of the post. Might be better to just have one if clause with an empty line.
Shouldn't this be I18n already?
Shouldn't we also set the interrupted status in the launch?
I would remove this line as well
This doesn't seem to be possible?
This doesn't seem to be necessary.
This doesn't seem to be possible.
You did not think we should expose a bean class here - it should just be registered on the BeanClassLoaderAware object.
You did not think we should expose a bean class here - at least by the annotation @Bean annotation.
You did not think we should expose a bean class here - it should just be registered on the BeanClassLoaderAware bean.
What about using j.jenkins.getInjector() instead?
What about using j.jenkins.createProject() instead?
What about using j.jenkins.createProject() here?
please remove the type with: (EReference)feature instanceof EObject) && ((EReference)feature).isContainment() && removedValues!= null)
Can't you use the ownedComments.add(new DestroyElementRequest(this, newValues, false));?
please remove the type with: (EReference)feature instanceof EObject) && ((EReference)feature).isContainment() && removedValues!= null
Is there a reason to use the "message" instead of the "message"?
Is there a reason to use the EntityDoesNotExistException here instead of an IOException? Any reason to catch it at all?
Is this a EntityDoesNotExistException?
come from an else
come from?
come from an refactoring
Does this one need to be changed to '...' too?
Does this one need to be changed to '...' too?
Does this one need to have the '...' too?
No need to split, since you are not using subMonitor.split(...)
No need to split, since you don't need a split step
missing braces
may be we can use the method reference
you can use the method reference
may be this
We cannot convert to Double for the same reasons motivated below.
We cannot convert to Double for the same thing
cannot convert to Object
Wouldn't it be better to do: if (occurrences.size().equals(occurrence) && occurrence.equals(occurrence)
Wouldn't it be better to do: if (occurrences.size().equals(occurrence) && occurrence.equals(occurrence)...
Wouldn't it be better to do: if (occurrences.size().isValidated) {... }
Why are you checking the members inside the compute block? I smell race conditions since this is the synchronized block.
Why are you not using the partition handling manager here?
Why are you checking the members inside the compute block?
please rename to images
please use final for consistency
please rename to images or taskId
You should use configuration to check if the domain is locked, since the domain is already downloaded at this point.
You should use configuration to check if the domain is locked, since the domain is already downloaded at this point
You should use configuration to check if the domain is locked, since the domain is already downloaded in the storage domain
This is actually adding functionality, since in 3.0 only system-disk is bootable. I think method should have an oldAPI flag, and in case of failure, if non-system disks are not supported.
This is actually adding functionality, since in 3.0 only system-disk is bootable. I think it should use bootOrder.
This is actually adding functionality, since in 3.0 only system-disk is bootable. I think method should have an oldAPI flag, and in case of failure, if non-system disks are used.
Should this be a separate error?
Should we throw an exception?
Should we also log the page id?
Should be final
Should be final (as in srvResolver).
Should be final (and remove the setter)
Let's include VIEW constant here.
Let's see why there is a test for the _list_ fields.
Let's see why there is a test for this.
else throw exception
else throw exception?
else throw exception? used more than one place
rename to event
rename 'invalidMarkerEvent'
rename to event or model
Should there be a check for userInfo.isInstructor()?
Should the null check be moved up into the other checks?
Should the null check be moved up into the first branch?
If the prefix is not properly capitalized, then this should be renamed to something like "file/moved".
If the prefix is not properly capitalized, then this should be renamed to src.getName()
If this is a SOAP file, should we use the.exists() method instead?
nit: can we also assert that it's non-null?
nit: can we also assert on group names?
nit: can we also assert that it only has the name of the group?
Please remove this >> 24
Please remove this and make the message static.
Please remove this addition.
you can use waitFor(() -> assertThat(directClient.getBatches(), hasSize(6))) in the same line
you can use waitFor(() -> assertThat(directClient.getBatches(), hasSize(6))) in your tests
could you elaborate?
I would suggest that you can have a static method to retrieve the class name from the ManagementContext. Something like: public static Class<Class<?>> loadActualContext(String mgmt, RegisteredType type, RegisteredTypeLoadingContext context) { if (context == null) return null; if (context.getLoader()!= null) return context.getLoader(); } return null; }
I would suggest that you can do this the same way as in <LINK_0>
I would suggest that you can have a static method to retrieve the class name from the ManagementContext. Same do this.
I think this is also a Monitor.
I think this should be Monitor.new Monitor(), which is what we want.
I think this should be configurable to a Monitor.
Please keep the original name of the method, currently it is "protected Collection<Integer> translateForStreamingInternal"
Please keep the original name of the method, currently it is the set of input parameters.
Please keep the original name of the method, currently it is not validated during the transform.
Is it possible to retrieve just one job for a single job?
Is it possible to move the job inside the try block?
Is it possible to retrieve just one job?
rules contain only one color since colorList will never be null.
rules: return after if and log the error, to be sure we are not throwing an exception.
rules: return after if and log a warning.
We need to check for zero, otherwise it will lead to an IndexOutOfBoundsException.
We need to check for zero of cell case.
We need to check for row -1 (no selection).
I'd call it "ssaoBlur" to be consistent with the other methods.
I'd call it "ssaoBlur".
Is this intentional?
Can we define aliases as a constant?
Can we define aliases somewhere in the Constants class?
Can we define aliases somewhere as a constant?
Could have used Bindings here :D
Could be generic, maybe variable somewhere, and can be computed
Could be generic, maybe variable somewhere, and can be used
@komaz We're only using the same Node object within the statement, right? So it makes the subsequent statement @danieldietrich?
@komaz We're only using the same Node object within the statement, right? Can it be replaced by a method reference?
@komaz We're only using the same node here and with nodeIds we should rename it to node_level?
Not a fan of this +.
There's a missing space between the @ keyword.
There's a missing space between the @ prefix and the method.
Couldn't you just use ctx.release() here?
Couldn't you leave it as is?
Was it necessary to change this value? I think that is what you want.
Maybe we can rename this to 'any' instead of 'any'
Maybe we can rename this to 'anyany' instead of 'any'
Maybe we can rename this to 'any' instead of 'any'.
Would be better to use the primitive 0L.
Would be nice to have a test for the count() method of the response (it's just a set of long).
Would be nice to have a test for the count() method of the response (it's just a string).
I'm a little wary of this PR, but I would have expected to add a ChannelChunkResponder to keep sending all the headers for a single case. Is there any other case where this method will need to be called?
I'm a little wary of this PR, but I would have expected to add a ChannelChunkResponder to keep sending all the headers for a single case. Is there any other case where this method would need to be implemented?
I'm a little wary of this PR, but I would have expected to add a ChannelChunkResponder to keep sending all the headers for a single case. Is there any other case where this method will need to be implemented?
For consistency, it should be.putAll(commonApplicationPropertiesContributor.class)
For consistency, it should be.map(Class::getSimpleName).
Can we inline these locals?
the names are no longer consistent. it would be nice to indicate the contents of the diff set
the names are no longer consistent. it would be nice to indicate the contents of the collection
the names are no longer consistent. it would be nice to indicate the columns's names.
Add a break to this if? Then, this condition is not needed.
Add a break to this if? That way, this condition is not nested.
Add a break to this if? That way, this condition is not needed.
Try: for (PoolBagEntry bagEntry : bag.size()) { if (removable > 0L) {... } }
Try: for (PoolBagEntry bagEntry : bag.size()) { if (removable > 0L) {... } } }
Ew, that just looks icky. Admitedly less efficient... bypassing the reservation but still not breaking the loop. Likely less than that.
I guess we can just call fireJobStartListeners() directly in the method.
I guess we can just call fireJobStartListeners() only once in the method.
I guess we can just call fireJobStartListeners() directly in the method..
please move the if (configuration.isPassingPartitionKeyAsOptionOnWrite()) { inside the if body.
please move the if (configuration.isPassingPartitionKeyAsOptionOnWrite()) { inside the if body, please.
please move the if and else branches to the same line as the preceding if condition.
CacheEntry.values() makes asyncGet() more sense.
CacheEntry.values()?
CacheEntry::getCacheEntryAsync is synchronized, could we avoid using asyncGet()?
Shouldn't this be: final HostStatus.Builder statusBuilder = HostStatus.newBuilder().setProps(emptyMap()).setStatuses(emptyMap()).setJobs(emptyMap());
Do we need to use emptyMap() here? It's a bit unclear to me.
Shouldn't this be: final HostStatus.Builder statusBuilder = HostStatus.Builder.
nit: no need to check 'log.error' when it's null
nit: no need to check 'log.error' when it is null
Minor: I think just passing the current errorMsg directly is redundant.
If Environment.containsKey(env.getValue()) return null then the condition becomes true.
If Environment.containsKey(env.getValue()) return null then the method will be executed twice.
Should this be an error?
Can we test the case where there are no files in the table?
this test is not executed by the parser and you're not testing anything
Can we test the case where there are no results in the file?
should just be inside try block
should be inside try block
should be inside try
this line is gone, why?
this line is gone, why? It doesn't seem to be necessary?
this line is gone, why? It doesn't seem to be necessary.
Is this change necessary?
Is this change related to the issue?
Is this change related to the fix?
Typo: attemptToUpdate
s/update/update?
s/and/or
add final
add final to add.
add add handler(new Entity<Boolean>()
Should be done in the finally block
Should be done in the finally block? It's hard to read
Should be done in finally block
You know what StoreFailureException is for, but it seems like it would be useful to throw StoreFailureException here as well.
You know what StoreFailureException is for, but it seems like it would be useful to throw StoreFailureException, if there's no catch body.
You know what StoreFailureException is thrown here?
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgToRegenerateAntiCsrfTokenValueIfRequired)
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgToRegenerateAntiCsrfTokenValueIfRequired).
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromRequest with loginMsgToRegenerateAntiCsrfTokenValueIfRequired)
Shouldn't this be inside the if(isWifiConn) {?
Shouldn't this be inside the if (isWifiConn) {?
Shouldn't this be inside the if(isWifiConn) {?
This is unnecessary, it can just be float.
This is unnecessary, it can just be floated from float.
This is unnecessary now.
This doesn't run as the condition is always true. It would be nice to handle the case where the element is already in the tree.
This doesn't need to be done in the CompilerInput
This doesn't run as the condition is always true.
this should be moved out of the try/catch at all filters
this should be moved out of try/catch at all filters
this should be moved out of the try/finally block
assertTrue(evaluator.evaluateUnaryExpression(null, "", String.class))
assertTrue(evaluator.evaluateUnaryExpression("Raw value should be a String");
assertThatThrownBy should be squashed.
you could use isWildcardQuery instead of Boolean
this variable with a descriptive name
this variable with a descriptive name.
missing @since 4.10 tag
there is no need to check if the global config is set before using it.
there is no need to check if the global config is present before using it.
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to put fileInfo into both write cache and read cache. And we need to increment refCount by 2 because we put that FileInfo into both read cache and write cache
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to add fileInfo to both write cache and read cache. And we need to increment refCount by 2 because we put that FileInfo into both read cache and write cache
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to put fileInfo into both write cache and read cache. And we need to increment refCount by 2 because we put that FileInfo into both read cache and read cache
Precondition to provide more information about the issue.
Precondition here seems to be incorrect.
Precondition to provide more context.
We can do the String.format inside of a String.format() call
We can do the String.format inside of a String.format block.
We can do the String.format inside of a String.format() call.
isUnauthorized 401
isUnauthorized 403?
it should be hasSize(false)
if you made remove the import, the method has no visibility too.
when you made this change please change the method name to getHocik.
this should be deleted right?
you can use try with resources here as well
you can use try with resources as in the try with resources
you can use try with resources to get the stream
Why use JDK map map and not map?
Why use JDK assertions and not fail()?
Why use JDK map map and not the size of the map?
why do we need this hbaseAdmin?
Why do we need this hbaseAdmin?
Looks like this should be separate method.
Please add a log the exception.
Please log the exception.
Please add a log the error.
Suggest making this package-private to avoid cluttering the test. I would leave it package-private to avoid cluttering the test.
Suggest making this package-private to avoid cluttering the test. I would leave it package-private to avoid clutters.
Suggest making this package-private to avoid cluttering the test. I would leave it package-private to avoid cluttering API changes.
NIT: are we sure we don't want to use this inside the command?
NIT: are we sure we don't want to use this inside the constructor?
same - missing null check
could you put an identical for loop for the childStart loop?
could you add a separate method for setting the parent and setting that here?
could you put an identical for loop for the childStart loop? Or is this a lot cleaner?
@euphzj-Was "i=1" missing? If not used.
@euphzj-Was "i=1" allowed here? If not used.
@euphzj-Was "i=1" missing?
Extra line
Needs to be rewritten.
Format this line
BoostTargetEffect has to be used with the BoostTarget.
BoostTargetEffect has to be used with the BoostTargetEffect.
We can use the BoostTargetEffect here.
If commonColumns contains some names then you'll need to do the commonColumnsWithNewSessionColumn variable below
If commonColumns contains some names then you'll need to do the commonColumns as well
If commonColumns contains some names then it should be commonColumns...
what is the point of taking the string and converting it to a int? is it enough to do a String.format?
what is the point of checking this after?
what is the point of taking the string and converting it to an int?
We have this logic in somewhere else. Consider using constant
We have this logic in somewhere else. Consider using CoreUtils
We have this functionality in common somewhere else. Consider using a constant
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is not enabled", request);
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request);
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is not enabled yet.");
Does it really make sense to have a plugin with multiple secure-stores? What would be the rationale behind it?
Does it really make sense to have a plugin with multiple secure-files? What would be the rationale behind it?
Does it really make sense to have a plugin with multiple secure store types? What would be the rationale behind it?
break the if conditions
break the if
break the if statement
could you make this method private?
could this be moved into the if ( outputStream instanceof IErrorMarkeredOutputStream ) block?
could this be moved into the if( outputStream instanceof IErrorMarkeredOutputStream ) block?
The failure mode should be restored on line 406. It should be in an else clause.
The failure mode should be restored on line 390. Same for the snapshot.
The failure mode should be restored on line 390.
Should there be a space after the comma?
Should use {} instead of string concatenation
Should there be a space after the + sign?
Shouldn't this code run even if mHasWifi is false?
Shouldn't this code run even if mHasWifi is true?
Shouldnt this code run even if mHasWifi is false?
nit: "for distribution factor" would be better
nit: "for distribution factor" would be better here.
nit: "for distribution factor" would be better here
can you explain why do we need to register the participant but not the task?
can you explain why do we need to register the participant?
Actually I would be consistent and use == here.
method name should be 'DependencyConfiguration'
method name should be good.
method name should be 'get'
This probably should be moved in the else clause of this class
This probably should be moved in the else clause of this method
This probably should be moved in the else clause of this class.
This part can be removed, we don't want to expose AggregationMode.NONE.
This part can be removed, we don't need to check for basePath.toString()
This part can be removed, we don't need to check for basePath.toString() below.
This doesn't log the exception.
this doesn't log the exception.
This doesn't log the stacktrace.
You can just use addOutputItem.addListener(SWT.Selection, Listener.class)
You can just put this inside addOutputItem.addListener(SWT.Selection, Listener.class)
You can just put this inside addOutputItem.addListener(SWT.Selection, Listener.class);
maybe add a check for NumberFormatException too
better to add a check for NumberFormatException too
maybe add a check for NumberFormatException too?
This should be private.
This should be a constant, since it is used in multiple places
This should be a constant, since it is used in multiple places.
In the test class, the sleeps should be the Gold api call. In the test class, the app is responsible for the thread sleeps for the test!
In the test class
"//...
@theck13, what is the point of showing the error activity _why_ the user is not found?
@theck13, what is the point of showing the error dialog?
@theck13, what is the point of showing the error activity _why_ the user is not available?
Can we also check for null?
Can we also use the logic to check for null?
Can we also add the following code to the model: parmCmd = null;
I'm not sure this is good behavior. Before, we were expecting a value of Property 'No such property', now it will throw an exception if it has not been set. I think this is better than throwing the fail.
I'm not sure this is good behavior. Before, we were expecting a value of Property 'No such property', now it will throw an exception if it has not been set. I think this is better than throwing the test.
Checker.fail() isn't needed, it makes no sense.
s/newOrEditedBondInterfaceForAttachement/newOrEditedBondOptionsForAttachement/
s/newOrEditedBondInterfaceForAttachement/newOrEditedBondInterfaceForAttachement/
s/newOrEditedBondInterfaceForAttachement/newOrEditedBondOptionsForAttachement/g
is the advisor.useResourceLock() already executed from the branch above?
is the advisor.useResourceLock() should be called from the branching order?
is the advisor.useResourceLock() should be called from the branching cycle?
FTR this method is available as a static method on the class, but not at the places where this method is used. It is probably better to have a static method in the engine to do this.
FTR this method is available as a static method on the class, but not at the places where this method is used. It is probably better to have a static method in the class that serves only the static files, then call that method here.
FTR this can be made static final.
shouldn't we change the order here?
static imports
shouldn't it be equals here?
Please use ""
Please use StringUtils.isEmpty()
Please use StringUtils.isEmpty.
Why is this change needed?
Why do you need to manually set the SSL_FACTORY as well?
I don't think this change is needed.
Avoid variable names like eventList
Avoid variable names such as eventList
Could this be extracted to a method?
Could be final
Could be getchooseButton().
Could probably be final
Before this change, we had the eventDeliveryLock semaphore which was only released upon receiving the ack. So if we take the ack from the queue, then the ack would be lost immediately, since we are in the queue. This looks suspicious. Let me know if my understanding is wrong.
Before this change, we had the eventDeliveryLock semaphore which was only released upon receiving the ack. So if we take the ack from the queue, then the ack would be lost immediately, since we are in the queue. WDYT?
Before this change, we had the eventDeliveryLock semaphore which was only released upon receiving the ack. So if we take the ack from the queue, then the ack would be lost immediately, since we are in the queue. This looks suspicious. Let me know if my understanding makes sense.
This should go on the error message "NOT_SUPPORTED"
This should go on the error message
This should go on the error message "NOT_SUPPORTED".
Shouldn't this method should be in the "if" block?
Shouldn't this method should be in the "if" block? In the case that it's just setting the value of srcHdc and then it's a snapshot of DPIUtil.
Shouldn't this method should be in the "if" block? In the case that it's just setting the value of srcHdc and then it's the same as the final field?
Shall we check if the interval is >= 10?
this should probably be repsOK
this should probably be repsOK >= 10
Data word can't exceed 32 bytes:
ByteUtil.numberOfLeadingeros(data);
Overload to ByteUtil.
Extra space
Won't this be made public?
Won't this be made in a separate method?
The first argument should be expected to be the last argument in this test.
The first argument should be expected to be the second argument
Remove blank line.
Can you please use logger.error String.format instead of String.format?
Can you please use request.getSkip() here instead?
You should be able to remove this line since the next statement logs the exception
Consider using one call to driver.findElement(By.id("WikiaPageBackground"), wikiaArticle.getLocation().x + wikiaArticle.getSize().getWidth());
Consider using one call to driver.findElement(By.id("WikiaPageBackground", wikiaArticle.getLocation().x + wikiaArticle.getSize().getWidth())
Consider using one call to driver.findElement(By.id("WikiaPageBackground"), wikiaArticle.getLocation().x + wikiaArticle.getSize().getWidth())
how about adding a parse method to JSONObject and then splitting the string?
how about adding a blank line after the if clause?
how about adding a parse method to json in String to avoid parsing the response?
Again, 2000 seems strange. Maybe better to have a constant in the code?
Why not toImmutableList()?
Again, 2000
you can try with resources here: try (FileReader main = new FileReader(config.trim())) {... }
you can try-with-resources so you don't need the "else" block
you can try-with-resources directly
pass in the metric registry
this will be incorrect
pass in the metric name
Do we not return anything from this method here? I think that you're making this a MLModelBuilderException (or throw MLModelBuilderException). If we return MLModelBuilderException, the exception will be thrown here.
Do we not return anything from this method here? I think that you're making this a MLModelBuilderException (or throw MLModelBuilderException).
Do we not return anything from this method here?
Can you please add a debug log with an appropriate message?
Can you please add a debug log with an appropriate error?
Can you add a debug log with an appropriate error?
Is this really what you want? If you get an exception, you'll be returning null for a query on a record that exists, but that can't be parsed.
Is this really what you want? If you get an exception, you're returning null for a query on a record that exists, but that can't be parsed.
Is this really what you want? If you get an exception, you'll be returning null on a query on a record that exists, but that can't be parsed.
RocksPageStore will be closed after a shutdown.
RocksPageStore will be closed after the test.
RocksPageStore will be closed after all page stores are descriptors.
do you need this?
do we need this?
do you need to call this method?
nit: space before {
nit: use try-catch block to make sure that method throws Exception is thrown
nit: use try-catch block to make it more readable
This is strange..map(CharSeq::rpString) can be replaced with.map(CharSeq::mkString).
This is strange..map(CharSeq::rpString) can be replaced with.map(Double::valueOf)
This is strange..map(CharSeq::rpString) can be replaced with.map(CharSeq::asString).
final?
Make it final
final
please use Logger.debug()
Remove all System.out.println.
please use Logger.debug, not System.out.
I think we want to use a switch statement here to avoid typos.
you can use a switch statement with an _ prefix
you can use a switch with a default case
I think using a localBibEntry instead of a localBibEntry would be better.
I think using a localBibEntry instead of a localBibEntry would be clearer
I think using a localBibEntry instead of a localBibEntry would be better
This is probably not necessary as it should be a value.
We should probably have a test that verifies that it doesn't exist, in the future.
We should probably have a test that verifies that it doesn't work on a specific port.
You can simplify this a bit by: return (List<SimplePage>) getHibernateTemplate().findByCriteria(d);
You can simplify this a bit by using ternary operator in the if and then returning the result.
You can simplify this a bit by: return (List<SimplePage>) getHibernateTemplate().findByCriteria(d).isEmpty();
I think this check is not necessary. When callback.onFailure() returns null, the check for it is to return a non-null.
I think this check is not necessary. When callback == null, the response from callback.onFailure() will return null.
I think this check should be removed.
Another test where the deposit is not found? I would make it fail, but verify that the folder doesn't exist.
Another test where the folder doesn't have a specific deposit. I would undo this change.
Another test where the folder doesn't have a specific deposit. I think this is cleaner.
This will use formatTimeForId(new Date(time)) instead of formatTimeForId(new Date(time))
This will use formatTimeForId(new Date(time)) instead of formatTimeForId(new Date(time));
Why don't you use formatTimeForId() which is the general param type for the line of the line?
suggestion final Boolean dark = PreferenceManager.getDefaultSharedPreferences(ctx).getString("theme", "dark");
suggestion final Boolean dark = PreferenceManager.getDefaultSharedPreferences(ctx).getString("theme", "dark").equals("dark");
suggestion final Boolean dark = PreferenceManager.getDefaultSharedPreferences(ctx).getString("theme", "light");
I don't think this should be a lambda.
I think this should not be here if we can add more fields, like "command", etc.
I think this should not be here if we can add more fields, like "commandType".
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "customer" 3 times. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "customer" 3 times. [![rule](<LINK_2>](<LINK_0>
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "static" 3 times. [![rule](<LINK_1>](<LINK_2>
check if the client is practicable
check if the client is not null - it should be...
check if the client is find storm event before send the event
Why do you need this?
This assertion should be moved to the setup method.
This assertion should be moved to the setup method itself
s/i.getBondName()/type()/
this does not compile.
s/i.getBondName()/type()
According to our code style, join() on a new line. It's nice to have a space after "||". It might be easier to understand if you change this line to be: while ((start = assignedSplits.get(currentSplitIndex))!=!= 0;
According to our code style, join() on a new line. It's nice to have a space after the = operator.
According to our code style, join() on a new line. It's nice to have a space after "||".
Isn't this a typo?
why not use rs.getInt("network_id")
Isn't this a typo? (btw why not use Guid.createGuidFromString())
Since this is a public API change, we should probably rename this to make it easier to reason about.
Since this is a public API and not public, we should rename to toResolve since this class provides the service reference.
Since the subclass
what about just build.getNumber() + ""?
what is this for? build.getNumber()
what about just build.getNumber() + "" instead?
we should still be gracefully closing the connection#close() method.
could we make this value configurable?
we should still be gracefully closing the connection here.
Instead of this duplicated logic, you can override the List<Project.NameKey> getParentByParent() method above: public List<Project.NameKey> getParent(final Project p) { if (p.getParent()!= null) { return projectControlFactory.controlFor(p.getParent()); } if (!r.contains(p.getParent().equals(wp)) { r.add(p.getParent()); } } return proc; }
Instead of this duplicated logic, you can override the List<Project.NameKey> getParentByParent() method above: public List<Project.NameKey> getParentByParent() { return new ArrayList<Project.NameKey>(); }
Instead of this duplicated logic, you can override the List<Project.NameKey> getParentByParent() method above: public List<Project.NameKey> getParentByParent() { return projectControlFactory.controlFor(p.getParent()); }
Wizard dialog has its own shell, you should not use default here.
Wizard dialog has its own shell, you should not use default one.
This should not be included in the job.
Shouldn't this be a RuntimeException rather than a WebApplicationException?
Shouldn't this be a RuntimeException instead of a WebApplicationException?
Shouldn't this be a 500, not a WebApplicationException?
let's change this if to - if (storagePoolId == null || storagePoolId.equals(Guid.Empty)){ return new Pair<>(false, null); }
let's change this if to - if (storagePoolId == null || storagePoolId.equals(StoragePoolId.Empty())) { - return new Pair<>(false, null); }
let's change this if to - if (storagePoolId == null || storagePoolId.equals(Guid.Empty())) { - this is no longer needed because of the if-condition.
lowestTimeAxisOffset is used above. Looks like a bug in IC2?
lowestTimeAxisOffset is used above. Looks like the code already tested above.
lowestTimeAxisOffset
per the style in rest of this file, add a space after "if": s/if(/if (/ and same for similar if statements below
per the style in rest of this file, add a space after "if": s/if(/if(/ and same for similar if statements below
per the style in rest of this file, add a space after "if", same for similar if statements below
I think that this method should be private.
I think that this method should be private by default.
I think this method should be private.
I would have checked any not null length but not first
I would have checked any not null return value here.
I would have checked any not null return as firstNonNull.
Same as above, should probably be "osgi.resolver.usesMode"
Same as above, should probably be "osgi.service.usesMode"
Same as above, should probably be public.
initialize to empty map.
initialize to "" and remove the null check here.
initialize to "" and remove the null check after.
It's better to boolean instead of Boolean
It's better to boolean instead of Boolean.
It's better to boolean and throw exceptions.
I think that if the configuration properties are not provided, we need to use the "mail configuration" message.
I think that if the configuration properties are not provided, we can use the "mail configuration properties" message.
I think that if the configuration properties are not provided, we can use a custom <code>mail configuration</code> </code>
Can you get rid of the static import?
Can you get a custom data type here?
Please remove _
Can this be made package private?
Can this be caught by the original method below?
Can this be caught by the original method above?
This is a bit hard to follow. What happens if no property exists? There are no values in the property.
This is never used.
Should this be done in a loop?
If we have a condition on this line, it would be nice to have!thread-style.
If we have a condition on isLeaf as there is no level, it is greater than a condition. Make it a constant.
If we have a condition on isLeaf as there is no level, it is greater than the first.
maybe use java.nio.Files.createTempFile?
maybe use string concat instead of the : character?
maybe use string concat instead of the :?
This works, but the implementation of this method should be listener with the callback (i.e. mSearchMenuItem.getActionView()).
This works, but the implementation of this method should be listener with the callback (i.e. add mSearchMenuItem to the button when it is currently selected).
This works, but the implementation of this method should be listener with the callback (i.e. mSearchMenuItem). Calling mSearchView.clearFocus() is not necessary.
Missing space after!
Missing space after,
should not be empty
In this case, the 'if' statement is not needed.
In this case, the "active" button is disabled immediately. Even though it won't happen happen by user, it doesn't matter that UI is restarted, so fine.
In this case, the "active" button is disabled immediately. Even though it won't happen happen by user, it doesn't matter since we won't call this method.
assertFalse(e)
This test should assert the setting since it was set before.
This test should assert the setting since it was set before and the uph2 is called.
So now we're sure it's working?
I'm not sure this is a good idea.
So now we're sure it's safe to delete sanitizedExt if not specified in the input stream...
can be simplified to just closestValue = i;
can be simplified to if (iconSizes!= null)
can be simplified to just if (iconSizes!= null)
I'm thinking to avoid having to work this out later we should probably also record the server URL in a finally block. However, I'm not sure that's what you want.
I'm thinking to avoid having to work this out later we should probably also record the server URL in a finally block. However, I'm not sure that's what's being done in the io. One of the issue is that the reader can be closed both if there's an issue with it.
I'm thinking to avoid having to work this out later we should probably also record the server URL in a finally block. However, I'm not sure that you can move this into the finally block.
suggestion RepositoryPath packedIndexPath = indexPath.resolve(IndexingContext.INDEX_FILE_PREFIX + ".gz");
I think using static import for readability is more concise and easier to read. Same for the entire method.
I think using static import for readability is more concise and easier to read.
Why was this changed?
Why did we change this?
I think this should be >
I don't think you can cast to TreeIterator<?>
I don't think you can cast to TreeIterator here
I don't think you can cast to TreeIterator<?> here
We usually use android.R.string.cancel = new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { target.onActivityResult(getTargetFragment, which); } }));
We usually use android.R.string.cancel = new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { target.onActivityResult(getTargetFragment, index); } };
We already have getButton() which is available from builder.setNegativeButton(R.string.cancel, null); here.
why not just break at end of the loop?
why do we need to reset these?
why not just break here?
I don't think you need to collect all the classes that are not declared in the context.
I don't think you need to collect all the classes that are declared in the context.
I don't think it's necessary to check that symbol.usages().stream().allMatch.
Label should be reporting.parameter.onOrAfter
The names of these parameters are fine, but we should be consistent with how they are used in other methods. They should be in a way that people know what to expect, or bime in because they are exposing parameter names (eg. startDate, endDate, location). With this in mind, I would favor simply exposing all parameters as they are named, modifying only onOrAfter=startDate and onOrBefore=endDate and locationList=location @djazayeri did you have other visions for these libraries and how they expose parameters?
The names of these parameters are fine, but we should be consistent with how they are used in other methods. They should be in a way that people know what to expect, or bime in reporting.parameter.onOrAfter
Since both code paths are identical this whole block, perhaps you can replace this with a method to minimize code duplication?
Since both code paths are identical now, you might want to replace this with a method to minimize code duplication.
Since both code paths are identical this whole block, perhaps you can replace this with a method to minimize the complexity?
What do you think changing the name to vm. We do not know whether it is in kilobytes?
What do you think changing the name to is We do not know whether it is in kilobytes?
What do you think changing the name to vmOs?
This code doesn't seem to be included in the DollarSignFromType.
This code doesn't have to be made static in the DollarSignFromType. I think it's counter-intuitive. It's counter-intuitive to the DollarSignFromType.
This code doesn't have to be made static in the DollarSignFromType.
I would rename getValueObject to getValueObject
I would rename getValueObject to something more generic since it's confusing.
I would rename the variable since it's confusing.
nit: could you use CollectionUtils.isNotEmpty here?
nit: maybe join the ifs with one line?
nit: could you use CollectionUtils.isEmpty()?
no need for this line.
no need for this else
no need for this else if statement
I think we should use the  fNot variable here
I think we should use the  fNot variable here.
I think we should use the constructor of  fNot and not get the time here.
I thought there was going to be a separate monitor for this CM integration descriptor, the handling of which would be contained in the cm-integration module.
I thought there was going to be a separate monitor for this CM integration descriptor, the handling of these would be contained in the cm-integration module.
I thought there was going to be a separate monitor for this PR.
Not sure this would work if the workspace is not in the workspace.
Not sure this would work. but I prefer to close the inputstream in finally block
close streams
Since this is a singleton, I think it could be made into a local variable.
Since this is a singleton, I think it could be made into a method.
Since this is a singleton, I think it could be made into a private method.
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the value anymore.
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the block anymore.
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be changed.
You can create a new file and only update the one. This should be in the database and the user to read it.
You can create a new file and only update the one. This should be in the database and the user to create the database.
You can create a new file getString(String) to retrieve the xml from string and pass it into the toString method.
What's the commit behind this commit?
What's the rationale behind this commit?
What's going on behind this?
@YuryBY. This code looks very close to the original, but it does not modify the state of the bloodTestingRule below. Perhaps it is better to create a protected method like the following: public BloodTestingRule createEntity(BloodTestingRuleBackingForm ) { BloodTestingRule bloodTestingRule = new BloodTestingRule(); }
@YuryBY. This code looks very close to the original, but it does not modify the state of the bloodTestingRule below. Perhaps it is better to create a protected method like the following: BloodTestingRule bloodTestingRule = new BloodTestingRule();
@YuryBY. This code looks very close to the original, but it does not modify the state of the bloodTestingRuleBackingForm. It is never modified.
For OM square braces are better.
Why we need this?
Why are we not able to use the previous session?
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it.
Please use LOGGER.debug("copyDiff(Diff, Diff, Monitor, Boolean)
Please use LOGGER.debug("copyDiff(Diff, Diff, Monitor, Boolean) - diff
Do we need to do another lookup here? We already have the consumer.getType() == null block and it's not null.
Do we need to do another lookup here? We already have the consumer.getType() == null check.
Do we need to do another lookup here? We already have the consumerTypeCurator.lookupByLabel method in the consumer.
Can this be static?
If you want to go for an exception you should add a log.debug here.
If you want to go for an exception you should add a log.fail() to the catch.
The indentation should be in a 'onShowListener' method.
The indentation should be in a 'if' statement.
The indentation should be in a 'onShowListener' callback
Change is to keep the log message more accurate.
Will this be a problem given the task is that logs from the exception to the user?
Change is to keep the log message more accurate
Is this change related to the PR? I don't see it, so I would prefer to make this protected; it should be in the Log interface
Is this change related to this PR? I don't see it, so I would prefer to make this protected since we can subclass the RequestTimedOutException
Is this change related to this PR? I don't see it, so I would prefer to make this protected; it should be in the PR.
don't we necessarily need to wait for that?
don't we necessarily need to wait for this?
don't we necessarily need to set this?
We could have a faster method like this: java public List<String> get() { return Stream.of(variables, Collections.emptyMap(), "skipping"); }
We can have a test that covers this when we call this method with a smaller number of items.
We can have a test that covers this when we run into it.
Isn't this methods used elsewhere?
I think this could be moved to the beginning of the method.
I think this could be moved to LeftToRightBitSet?
Should this be try with resources? I don't see the reader closed
should this be try with resources? I don't see the reader closed
Should this be try with resources? I don't see the reader closed.
nit: this could be collapsed to return sourceUri.getScheme().equals(optUri.getScheme()) && Objects.equals(sourceUri.getScheme(),...
nit: just use Path::new
nit: this could be collapsed to anyMatch
suggestion: consider returning Collections.emptyList() instead
We should probably add java docs on why this method is called
suggestion: consider returning Collections.emptyList();
This looks like it would be better to remove the audio files from the dataset file and delete them from the dataset file
This looks like it would be better to remove the audio files from the dataset file and the file could be deleted from the physical disk.
This looks like it would be better to remove the audio files from the dataset file and the file could be deleted.
Can be possibly moved to shouldShowLog of PageData class so all the checks for whether a emailLogEntry should be included is located in one place.
Can be possibly moved to shouldShowLog of PageData class
Can be possibly removed
This is same for standalone as well as domain ;-)
This model is same for standalone as well as domain ;-)
This initialization is same for standalone as well as domain ;-)
i think this is dead code, the retry policy would be dead if there's an error. Otherwise the retry policy will never be scheduled to be removed.
i think this is dead code, the retry policy would be dead if there's an error. Otherwise the retry policy will not be scheduled to be ignored.
nit: this change looks unrelated
this method should be private
please, move this part to the function below.
please, move this method to the minimum package.
refactor into class variable
I think it might be better to just have a Pair<String> with the code parameter called AddBudgetActivity and have dataAdapter take care of that.
I think it might be better to just have a Pair<String> with the dataAdapter and have access to set budgetNameList.
Same as above, it should use Strings.isNullOrEmpty
Same as above, this should use the.equals()
Same as above, it should use String.equals
use.map(expression)
use com.google.common.collect.toImmutableList()
use toImmutableList
The duration variable is not needed
Could have a max value for duration.
Could have the duration variable be removed?
shouldn't we have an array of configs (just like the others)?
shouldn't we have an array of configs (if there are no values in the builder)?
shouldn't we have an array of configs (if there are one)?
The other formats are actual formats (HTML or MD) whereas simple for reading an option for those implementations it could be txt or text for plain-text. Maybe instead of milliseconds, it could be txt or text for plain-text?
The other formats are actual formats (HTML or MD) whereas simple for reading an option for those implementations it could be txt or text for plain-text. Maybe instead of milliseconds, it could be txt or text for plain-text.
Maybe better to add the other formats as well?
There is no point in checking if it contains the given url. This can be fixed in a few places below.
There is no point in checking if it contains the given url. This can be fixed in a different commit.
There is no point in checking if it contains the given url. This can be fixed in a different patch to resolve it.
You can use the envelope.getXMin() method and other constructors.
You can use the envelope.getXMin() helper method to avoid this code.
You can use the envelope.getXMin() helper method to avoid this null check.
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down to selectReadReplica?
Perhaps we could compute time.milliseconds() once at the beginning of this loop and pass it down to selectReadReplica?
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down?
Should we get the non-null value here?
Should we get the non-null value here (and in the other tests)?
Should we get the non-null value here, or a custom value?
Can you extract a constant for this?
Can you extract a constant for this pattern?
Can you extract this regex to a constant?
Does this need to be a KualiDecimal? Or is there a possibility of an exception here?
Does this need to be changed because of the rebase? Might be much cleaner to have a rebase on top of the change (which is the KualiDecimal).
Does this need to be changed because of the rebase? Might be much cleaner to have a rebase on top of the change (which is the already used).
I believe that setters normally return the getter/setter methods, even when the getter is not necessary.
I believe that setters normally return the getter/setter methods, even when the getter is not set.
I believe that setters normally return the getter/setter methods, even when the getter is not on the setter.
I think this should be logged at the end of the method.
I think this should be logged at the end of the method so it will be translated to the user
I think this should be logged at the end of the method so it can be translated to the user
Please, use the JLS suggested modifier order. This is less important.
Please, use the JLS suggested modifier order.
This can be a static method on the class.
Could we use the same log levels in the code block?
Could we use braces around this block in the block above?
Could we use braces around this block?
suggestion log.info("jboss-as not killed and shutdown");
- This seems unused - use checkDurableTime * 1000
suggestion log.info("jboss-as not killed/shutdown");
please put {} around if block
please put {} around if block please
please put braces
I'm a bit confused about this method. Do you want to parse out all the output stream in the same step?
I'm a bit confused about this method. Do you want to parse to a file and to convert to a file stream?
add a space after }
Log message shouldn't be something like "filedir" instead of "filedir"
Log message shouldn't be something like "filedir" instead of "filedir"?
Log message shouldn't be something like "filedir" instead of "getOriginalFilename"
might be nice to rename this to isSelf while in other sleve tags
might be nice to rename this to isSelf while in this case
These can be static
Please check with "function" is more appropriate.
Please check with "function" is more appropriate
Please use switch-case
Does the log need to be in a finally block?
Does the log need to be in its own try/finally block?
Does the log need to be in its own try/catch block?
mController.isMoveCapable(account)) {
Same here: use SUBJECT_COLUMN
Same here - use SUBJECT_COLUMN
You updated the capabilities in DistributorVersionCapabilityDTO on purpose.
You updated the capabilities as well but not strong feelings.
You updated the capabilities as well.
json string
json string always and not "\"");
json string always instead of "\"");
Why did you use a TreeMap here?
Why do you use a TreeMap here?
Why do you use a unique key set here?
Why we want to use here compara_dbre.getName().
Why we want to use here compara_dbre.getName()
Either it is equal chaosing.
Does this need to be null?
Do we need to throw this exception ourselves? We just need to throw the exception itself.
Do we need to throw this exception ourselves? We can then construct a new one with the default hostname and get the class name.
Parsing XPathEvaluator should be done in a loop. Make it static, and have a getter for it in the class.
Parsing XPathEvaluator should be done in a loop. Make it static, and have a getter for it in TestHelper
Parsing XPathEvaluator from a Configuration should be done in a separate PR.
Could this check be in the constructor?
Could this check be in the base class?
I guess this can be dropped.
Remove
Remove?
Remove debugging
I don't think this is necessary for this case
This doesn't get logged in xml
I don't fully understand the logic for this. This method doesn't belong here.
It seems to me that we could avoid to collect all methods.
It seems to me that we could avoid to collect every method by using try-with-resources.
It seems to me that we could avoid to collect every method?
I think here we should just us a file-handler just the configuration is less complex and slight less overhead as there is no WriteHandler.preWrite() invoked. Really not a big deal though.
I think here we should just us a file-handler just the configuration is less complex and slight less overhead as there is no WriteHandler.deleteIfExists() or something.
I think here we should just us remove the file-handler from the management client. In this case the file-handler is removed from the proxy.
Redundant with version.
Redundant with version check
Redundant with version handler and version.
This is wrong because Type inv is a container item. It is not the last item.
This is wrong. OpenShift modules are using IngredientFluidStack.item to remove the container item.
This is wrong because Type inv is a container item. It is not the last item. It is the ItemStack that has been copied.
why do we want to set options in the constructor?
why do we want to set -1 and not use the default one?
why do we want to set -1 and not a check here?
same thing here, it's hard to read.
same thing here, it's hard to tell what happens if you drop this test :)
same thing here, it's easier to read, plus is this test readability
Why not do it like this: String aggregatedBuildInfo = StringUtils.isNotBlank(buildInfoFromContext, GenericData.class);
Why not do it like: String aggregatedBuildInfo = StringUtils.isNotBlank(buildInfoFromContext, GenericData.class);
Why not do this after the initial call?
one.HAND
Missing! operator.
Missing!
No need for final here.
Same question as above, this one should probably be using Arrays.stream(args).forEach()
Same question as above, this one should probably be using Arrays.stream(args).forEach(...)
I would move the logic to the if (exception instanceof BKException.BKNoSuchLedgerExistsException) block.
I would move the logic to the ledger metadata branch, so it is easier to read and change the logic.
I would move the logic to the ledger metadata branch, so it is easier to read and there isn't the purpose of this task.
new String(settings.getOauthTokenUrl()).setPrompt(settings.getOauthApplicationId()).buildQueryMessage();
new String(settings.getOauthApplicationId()) looks always more content.
new String(settings.getUsername())
What is the reason for this test? Why are you stop container in finally block?
What is the reason for this test? Why don't you just start container in finally block?
What is the reason for this test? Why are you stop container in finally block? Same question on MkAnswer.
Inconsistent use of this.
Inconsistent use of 'final' keyword inside method.
Inconsistent use of this keyword.
Maybe you could remove groups from the test and just do something like below.
Maybe you could remove groups from the group1?
assertFalse
Please correct the capitalization of the casing everywhere.
Please correct the capitalization of the param names.
Please remove final.
Maybe we can extract this part to a helper function getSourceCode(String name)
Maybe we can extract this out to a method in the 'canFicBinding' method?
Maybe we can extract this part to a helper function getSourceCode(String name)?
What's the purpose of this?
What's the point of this? If it's QUALIFIER and then the Increment should be part of the key?
What's the point of this? If it's QUALIFIER and then the Increment should be part of the key.
The range should be calculated at the end of the method, and here we can get rid of the "range" variable.
The range should be calculated at the end of the method so we can get rid of the "range" variable.
The range should be calculated at the end of the method, and here we can get rid of the "Range" variable.
why not to use the command parameter directly?
why do we need this?
why do we need to keep this?
This code is not used. This should be removed.
This code is not used. This is the keep in mind, I think that the code should be removed.
This code is not used. This should be removed, that is the check for this variable now.
Maybe we could consider adding a check on getDrawables() to new ArrayList<>(pe.getDrawables()) before using it.
Maybe we could consider adding a check for getCategoriesForType() to new ArrayList before using it.
A List is no longer needed here.
This should be i2.hasNext() || i2.hasNext()
This should be in the while loop.
This should be in the while condition.
the logic in the rule.match() should be extracted to a common method with the logic in the RuleApplication.
the logic in the rule.match() should be extracted to a common method with an optional parameter
the logic in the rule.match() should be extracted to a common method with the repeated logic
java if (!notification.getEventNotificationsEnabled()) { return; }
java if (notification.getEventNotificationsEnabled()) { return; }
java if (!notification.getEventNotificationsEnabled()) { return; }?
Integer.parseInt
This isn't Integer.parseInt
This isn't Integer.parseInt()?
This would be better as: java if (projectsAdded.add(targetProjName)) { IProject targetProj =... } That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate contains check.
This would be better as: java if (projectsAdded.add(targetProjName)) { IProject targetProj =... } That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate add.
This would be better as: java if (projectsAdded.add(targetProjName)) { IProject targetProj =... } That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate add logic.
nit: Can we use java.nio.Paths.get(baseDirCandidate).resolve("pom.xml") instead?
nit: Can we use java.nio.Paths.get(baseDirCandidate) instead?
nit: Can we use java.nio.Paths.get(baseDirCandidate) and static import?
WrongReferenceAttributeValueException and WrongAttributeAssignmentException are not thrown in this method.
WrongReferenceAttributeValueException, WrongAttributeAssignmentException is not thrown in this method.
WrongReferenceAttributeValueException
Perhaps 'Not unpacking {file name}... 'would be better - this gives the impression that there are no unpacked variables in the file - but this may not be the case - config could be overriding this.
Perhaps 'Not unpacking file name' could be better - this gives the impression that there are no unpacked variables in the file - but this may not be the case - config could be overriding this.
Perhaps 'Not unpacking file name' would be better - this gives the impression that there are no unpacked variables in the file - but this may not be the case - config could be overriding this.
What's the point of this? If it's not, it doesn't seem to be the case?
What's the point of this? If it's not, it doesn't seem to be a problem to be able to just happen.
What's the point of this? If it's not, it doesn't seem to be a problem to sort.
Add some standard message like "Expected object with id= %d, but not found in result",
Add some standard message like "Expected object with id= %d, but not found in result"
Add some meaningful message here.
suggestion String[] configuredAssetFolderPaths = new TreeMap<>();
suggestion if (configuredAssetFolderPaths!= null && configuredAssetFolderPaths.isResourceType("sling:OrderedFolder")) {
suggestion if (configuredAssetFolderPaths!= null && configuredAssetFolderPaths.stream().filter(String -> Boolean.isNotBlank(configuredAssetFolderPath)) {
Im not sure if it is better to return null here? As @jglickly thoughts?
Im not sure this is better, but this check could return null if the given key is in the array in the for loop.
Im not sure this is better, but this check could return null if the given key is in the array in redis and it doesn't return null.
I'm not certain what the correct thing to do here. If there are multiple concurrent threads waiting for the unsubscribe to happen, do we want to unsubscribe the open process?
I'm not certain what the correct thing to do here. If there are multiple concurrent threads waiting for the unsubscribe to happen, do we want to unsubscribe the open node?
This will not add value until all enqueues are finished.
We should create a separate, generic class for this execution, since the body of the method is always the same.
We should create a separate, generic boolean variable for this execution, since the body of the if block is always the same.
We should create a separate, generic boolean variable for this execution, since the body of the method is always the same.
Please change to!message.trim().isEmpty()) {
Please change to!message.trim().isEmpty());
Please remove...
looks like you missed these
looks like you missed these...other than that.
looks like you missed some usage of this
Since there is only one place to modify it, you can extract it to a method
Since there is only one place to modify it in this class it's better to use [this](<LINK_0>
Since there is only one place to modify it in this class you can extract it to a method
Let's adjust the formatting to here. This would be better.
Let's adjust the formatting to here.
Let's adjust the formatting to match the standard format.
This is missing the type information, I believe
This is missing the type @Override
This is missing the type @Nullable annotation
I can't remember why it needed this? And I get paranoid about it since I spent months tweaking the multi server configurations to not break.
I can't remember why it needed this? And I get paranoid about it since I spent months tweaking the multi server configurations to not break?
I can't remember why it needed this? And I get paranoid about it since I can definitely see it used anywhere
nit: could be written as "return for VERSION_1_2_0_0"
nit: could be written as "return for loop" here
nit: could be written as "return for VERSION_1_2_0_0".
Need to use placeholders for those as well
We should probably use placeholders for those as well
We will probably use placeholders for those as well
I would change this to params.getString("user")
I would change this to a log.warn
I would change this to params.getString("users")
Missed this one before.
Suggest to change this to be a constant.
Suggest to use a constant for this.
Can you use java 8 stream API?
Can you use java 8 stream API here?
Can you use java 8 stream?
nit: List<Object> list = getListeners()
nit: List<Object> list = getListeners();
rename 'list'
Missing final
Missing assert.
Missing assert,
Please always use this library to calculate the max size, old-style parametrization is only available for API 7 and 16.
Please always use this library to calculate the max size, old-length and new-size methods.
Please always use this library to calculate the max size, old-style parametrize it (used here)
What happens if the seed is less than the timeout? The current strategy is to create an connection, it should be in the loop till the specified timeout (server-timeout), right?
What happens if the seed is less than the timeout? The current strategy is to create an connection, it should be in the loop immediately. If this is the case, client will be stuck in a loop forever.
What happens if the seed is less than the timeout? The current strategy is to create an connection, it should be in the loop till the specified timeout (server-timeout), right? throwing an exception here will return before the specified wait times
Doing it this way will not update the actual Pod status. I think we need to add this in createOpenShiftDeployment() PodSpec pods = new PodSpecBuilder().withContainers(container).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).buildMetadata()
Doing it this way will not update the actual Pod ID. I think we need to add this in createOpenShiftDeployment() PodSpec pods = new PodSpecBuilder().withContainers(container).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).buildMetadata()
Doing it this way will not update the actual Pod status. I think we need to add this in createOpenShiftDeployment() PodSpec pods = new PodSpecBuilder().withContainers(container).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).withVolumes(getVolumesFrom(volumes, workspaceID)).buildMetadata()
We should just expose getRemoteAddress()
"Send per key" is un-blocking. We should just expose getRemoteAddress()
"Send per key" is un-blocking. This needs to be in a separate commit.
![MAJOR](<LINK_1> 'Severity: MAJOR') Format specifiers should be used instead of string concatenation. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce the number of returns of this method 4, down to the maximum allowed 3. [![rule](<LINK_2>](<LINK_0>
If you're going to get a EntityType which is a Copy, why not just get this list and do.map(this:: pasteDefaultValues).collect(toList())?
If you're going to get a EntityType which is a Copy, why not just get this list and do.map(this:: pasteDefaultValues).orElse(null)?
If you're going to get a EntityType which is a Copy, why not just get this list directly?
'e' is not logged
' e' is not logged
gacb.getMessage()
You should use here errorFormat instead errorFormat and "...{0}",domain.getId());
You should use here errorFormat instead errorFormat
Please iterate using DiskImage instead
Please don't print the file names here. This will be confusing to debug and not error prone. Can you move this to a class constant?
Please don't print the file names here. This will be confusing to debug and not error prone. Can you move this to a try/catch?
Please use lambda
Please refactor DbFacade.getInstance().getLunDao() to a method...
please refactor DbFacade.getInstance().getLunDao() to a method...
please use java.util.dbFacade.getInstance().getLunDao()
Style-nit: We don't put braces around single line blocks
Style-nit: We don't put braces on single line blocks
Suggest doing this on a separate line.
This can be inlined.
This can be inlined into a single line.
This can be made private.
You should use here getStoragePoolIsoMapDAO()
You should use configuration to check if the domain is locked, since the domain is already downloaded at this point.
You should use configuration to check if the domain is locked, e.g. if the domain was already locked, the domain was already downloaded.
why is this being in a synchronized block?
this is probably not needed. You are synchronizing on this for iteration anyway.
this is probably not needed. You are synchronizing on this for loop in a 'this' loop.
We could potentially replace this with asserts to check it.
We could potentially replace this with asserts to check input parameters.
We could potentially replace this idiom with asserts, please.
@vilchik-elena This method should be imported statically
@vilchik-elena This method should be extracted to a method.
this method should be private
Let's try to keep it as is, and introduce a method in our code : class  /* \* @param x and y
Let's try to keep it as is and introduce a method in our code : class  /* \* @param x and y
Let's try to keep it.
What is the purpose of this change? It is not immediately clear to me.
What is the purpose of this change? It doesn't seem to be related to the PR.
What is the purpose of this change? It doesn't seem to be related to the milestone's input parameter.
this might be easier to user to get rid of the String and Version
this may be easier to user to get rid of the String and Version
this might be easier to user to get rid of the String based on what "/version" mean
child
child extends File
child?
assertEquals()
assertEquals?
assertEquals()?
Can we remove this log statement as well?
Can we remove this logging statement as well?
We should either delete or use log4j.
It would be nice if you could instead write these lists using Arrays.asList(). If you do that, you don't have to worry about the order of the parameters.
It would be nice if you could instead write these lists using Arrays.asList(). If you do that, you don't have to worry about the size of the list.
It would be nice if you could instead write these lists using Arrays.asList(). If you do that, you don't have to worry about the size of a list.
This is going to fail out of bounds. Can we instead simply not print out the exception, for example, at DEBUG level?
This is going to fail out of bounds. Can we instead simply not print out the exception, for example, at DEBUG level
This will probably not warrant a whole try/catch, as there is no guarantee that a NullPointerException is thrown.
would be nice to move the GTFSDB updateSession method to the query instead of duplicating the body of this method
would be nice to move the GTFSDB updateSession method to the query instead of doing it here.
would be nice to move the GTFSDB code to a separate method to avoid this duplication
Do we need to make sure that CBs's labels are not treated differently?
Do we need to make sure that CBs's labels are not treated as Hard-coded strings?
Do we need to make sure that CBs's labels are not treated as Hard-coded label?
I think it would be cleaner to have the check for isSelected only here and inside an else if to avoid calling all the time.
I think it would be cleaner to have the check for isSelected only here and inside an else if to avoid calling all these functions.
I think it would be cleaner to have the check for isSelected only here and inside an else if checking.
We probably want an overload of addQueryProvider that takes a Collection<Variable> and Consumer<QueryProvider> directly.
We probably want an overload of addQueryProvider that takes a Collection<Variable> and Consumer<QueryProvider>.
We probably want an overload of addQueryProvider that takes a Collection<Parameter> and let the user know that this is running.
rename to childNode
rename to key
rename
intellij inspections recommend using method reference instead of file.getOptionalCallbacks()
intellij inspections recommend using method call.
intellij inspections recommend using method reference instead of objclomatic complexity.
This should probably be a logger
I think better use a logger
This should be logged as a RuntimeException
The method name is 'this' is not really clear.
The field name should be 'this', not 'this'
The field name should be 'this', not 'this'.
Why do you add a new message here?
Why do you add a message here?
Does it make sense to add a constant here?
else if
else is unnecessary
else is missing
I think this might be shorter: if (ObjectId.zeroId().equals(newId) || ObjectId.zeroId().equals(oldId)) { throw new IllegalArgumentException( JGitText.get().updateRequiresOldIdAndNewId); }
I think this might be shorter: if (ObjectId.zeroId().equals(oldId) || ObjectId.zeroId().equals(oldId)) { throw new IllegalArgumentException( JGitText.get().updateRequiresOldIdAndNewId); }
I think this might be shorter: if (ObjectId.zeroId().equals(newId) || ObjectId.zeroId().equals(oldId)) { throw new IllegalArgumentException( JGitText.get().updateRequiresOldIdAndNewId); } for a greater length?
Remove this one too, let's keep it.
Remove this one too
Remove this one
@ivandalbosco Why not just use parameter.symbol().isPublic()?
@ivandalbosco Why not use parameter.symbol().isPublic()?
this should only be done once, no?
There should be a case where listStartNumber is a Double
I think, that should be hasTime
There should be a case where listStartNumber of pageNumberCount
I don't think this is good but if the cache had "dkey" in front of a few values and <= BinaryTagCodec.MAX_VALUE is okay, because this is a different API and doesn't support that dkey
I don't think this is good but if the cache had "dkey" in front of a few values and <= BinaryTagCodec.MAX_VALUE is okay, because this is a different API and doesn't work for that. If that's the case, we can just use dkey.equals(value)
I don't think this is good but if the cache had "dkey" in front of a few values and <= BinaryTagCodec.MAX_VALUE is okay, because this is a different API and doesn't work for that. If that's the case, we can just use a different strategy than the values returned in to us.
I think CDA is not the place to check if DbPoolStatus is not null - as it's an internal exception
I think CDA is not the place to check if DbPoolStatus is not null - in the vdss db this fails.
I think CDA is not the place to check if DbPoolStatus is not null - in the vdsm side it is dead code.
It looks like it is an archaius TaskExecutor arch
It looks like it is an archaius TaskExecutor archaius TaskExecutor.
It looks like it is an archaius TaskExecutor.
no need for this temporary bitmap, right?
no need for this temporary image
no need for this temporary image, right?
It seems like you discarded my edits in the PR description. Why is the changes done in master?
It seems like you discarded my edits in the past but I believe there is no need to implement all the changes done in this PR. Just related to the PRs.
It seems like you discarded my edits in the past but I believe there is no need to implement all the changes done in this PR. Just related to the TODOs :)
It would be nice if this were the same as the old one.
It would be nice if this were the same tests using the [clientId](<LINK_0> class.
It would be nice if this were the same as the old tests?
What about if(unAssignedActor.getUser() == null) { return null; }
What about if(unAssignedActors.isEmpty()) { return null; }
final
Is it possible for the cache to be closed before this method is called?
Is it possible for user to use zookeeper path instead of a table name?
Is it possible for the node to be closed before this method is called?
NPE possible.
NPE possible, if there is a race condition?
NPE possible?
This is wrong. [plice-java-version](<LINK_0>
We can use [StringUtils.nonEmpty(..)](<LINK_0>
We can use.isEmpty() here.
Please re-format this method in your IDE, I suggest using the Eclipse code formatter located at config/engine-code-format.xml (If you're using IntelliJ IDEA, you can install the "Eclipse Code Formatter" plugin.)
If the option should be enabled also without a DC, then check that it is enabled already with the dc cluster. If it is enabled, it should be like this if (!getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)
If the option should be enabled also without a DC, then check that it is enabled already with the dc info.
This should be NonNullUtils.equals().
This really should be NonNullUtils.equals(). You could add a case insensitive check for trace, like Objects.equals(), but this makes it into an unrelated PR.
This really should be equals, but.equals() should always return false for nulls.
order of operands
order of checks
order of parameters
@vilchik-elena test name looks wrong here.
@vilchik-elena test name sounds like a missing assert, but it is not...
@vilchik-elena test name sounds like a missing assert.
I'm not sure if this is right or not but the content can also be concatenated with the actual encoding.codePointAt(i) could be safer.
I'm not sure if this is right or not but the content can also be concatenated with a separator.codePointAt(i) probably shouldn't?
I'm not sure I like this convention. Why not simply let the user know the content's current content?
I was thinking in having REST operations that involves multiple servers under a separate resource: /rest/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf
I was thinking in having REST operations that involves multiple servers under a separate resource: /rest/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/metadata/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v
I was thinking in having REST operations that involves multiple servers under a separate resource: /rest/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/protobuf/v2/query
Formatting
Too long line
Too long line.
suggestion assertNotNull(strategy);
suggestion assertNotNull(strategy, "UnsupportedBlockStrategy.class");
suggestion assertTrue(strategy.getClass().equals(getClass()));
Sorry, I just realized that the ss is not correct. The only thing I can see is that this will set the end of the range of events on the resource thread. If you have a memory issue, it will happen and the UI thread will fill the range of entries for the same start and end. So you'll end up with a new count of the entries. We need to update the end time here too.
don't use Thread.sleep() :)
don't use Thread.sleep()
Move this binding to StorageManagerConfig.
Move this binding to StorageManagerConfig?
Move this binding to StorageManager.
2 should be the first result of create table t (if the database is present), right?
2 should be the first result of the test case.
you can remove this line
Could you, please, explain, why it was needed here?
Could you, please, explain, why it was needed?
Could you, please, explain, why it was needed here,?
Should also assert the not null?
Where does this local variable get used?
Should we use a standard resources/file here?
You could think about extracting the call to the constructor but it's not worth the effort.
You could think about extracting the call to the constructor but we could have it return a new instance of the class.
You could think about extracting the call to the constructor but we could have it return a new instance of the parent appsController.
Same as above, why use a list?
Same as above, why not use the create call?
Same as above, why not use ooKeeperOperation.
In this case "parent" is not a directory. It is defined as try-with-resources, but it's using the default namespace.
In this case "parent" is not a directory. It is defined as try-with-resources, and it will interrupt the current thread
In this case "parent" is not a directory. It is defined as try-with-resources, and it will interrupt the stream whenever it is closed.
I would not go for the this.service!= null check since this.service may be null.
I guess the 'this.service!= null' part could be removed...
I would not go for the this.service!= null check since this.service!= null
suggestion return response.getStatusLine().getStatusCode() >= 200 && status < 300) {
suggestion return response.getStatusLine().getStatusCode() >= 200 && status < 300);
suggestion return response.getStatusLine().getStatusCode();
Again, these should not pass validateInputs()
Again, these should not be 'null'.
Again, these should be 'debug' level.
How about using SUCCESS_RESPONSE.asCharSource(UTF_8)?
You should never write to the Bytes in the Bytes constructor, like we do for Bytes.
You should never write to the test.
the code duplication
the code duplication here isn't there a util method
the code duplication here isn't there a util method to get all the URL and does it?
Why this is changed?
this whole method should be private.
this whole method should be private
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already an error, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm probably missing something.
Missing braces
isEmpty() is not a good name for methods, if it is a no-op.
isEmpty()
can you please move this to separate method's assignments?
can you please rename these variables according to current name?
can you please move this to separate method, and remove the null check.
I think this can be moved to the ElasticsearchWorkOrchestratorFactory class.
I think this can be moved to ElasticsearchWorkOrchestratorFactory.createStreamOrchestrator( List<String> elasticsearchIndexNames, ElasticsearchWorkOrchestratorRegistry ) like we do in ElasticsearchWorkOrchestratorFactory.
This can be moved to the ElasticsearchWorkOrchestratorFactory class.
If you are going to return true, you can remove nonBlocking variable and you can safely use execEnvVars.get(MyriaConstants.EXEC_ENV_VAR_EXECUTION_MODE) directly
If you are going to return true, you can remove nonBlocking variable and you can safely use runEnvVars.get(MyriaConstants.EXEC_ENV_VAR_EXECUTION_MODE) directly
If you are going to return true, you can remove nonBlocking variable and you can safely use execEnvVars.get(MyriaConstants.EXEC_ENV_VAR_EXECUTION_MODE)
add "try.." here
Why are you changing this?
Why?
BooleanValueMatcher(value == null || StringUtils.isEmpty(value))
BooleanValueMatcher(value == null || StringUtils.isEmpty(value)
BooleanValueMatcher(value == null || StringUtils.isEmpty(value) )
Is this really more readable? (IMHO it's not)
Is this really more readable? (IMHO it's not)
Is this really more readable? (IMHO it's not):)
_minor_ I prefer _ if_ the user flag is set to null. This is how _never_ configure a session to be created, and _never_ construct a session.
_minor_ I prefer _ if_ the user flag is set to null. This is how _never_ configure the session to be null.
Formatting
if getString() returns null then line 202 will throw a NPE
if getString() returns null then line 202 will throw an NPE
Actually, in the previous version, this line of code is not needed and the field can be removed (i18n).
The only thing I see here is that we don't want to visit any variable if it's a LIST_EXPRESSION.
The only thing I see here is that we don't want to visit any variable.
The only thing I see here is that we don't want to visit any variable if it's a _Variable_.
This variable is not used.
Shouldn't this be is allowed?
Shouldn't this be isAllowed?
readLine copies the character sequence? If so, this should read into a new byte[sizeHint](<LINK_0>, and avoid the lengthHint class.
readLine copies the character sequence? If so, this should read into a new byte[sizeHint](<LINK_0>, and avoid the buffer copy.
readLine copies the character sequence? That's dangerous. Can you create a new char[] instead?
Use 'policy' instead of 'policy'.
This doesn't need to check the direct parent class of the effect.
This doesn't need to check the direct parent class.
I think it can avoid some readFullys by using java.util.Arrays.format which takes a long.
I think it can avoid some readFullys by using java.nio.io.Files.copy() which takes a long.
I think it can avoid some readFullys by using java.util.Arrays.format which takes a byte[], it takes a long.
Minor nit: We should also rename this to "default" and "default"
Any reason not to log ERROR here? There are issues with this. We should not have to care about the case.
Any reason not to log ERROR here?
We can get rid of this method, since it is already a public method
How about a method for this?
We can get rid of this method, since it is already public
Should go into @ After method to make sure it clears authorizations even if an assert statement fails.
Should go into @After method to make sure it clears authorizations even if an assert statement fails.
Should go into @Before method to make sure it clears authorizations even if an assert statement fails.
Should this be reading up at the end of the file?
Should this be reading up on 'json' instead of here?
Should this be reading up at the start of the init method?
This test is a bit hard to read. I think it should be a JUnit assertThrows() if you want to see the actual exception message.
This test is a bit hard to read. I think it should be a JUnit assertThrows() if you want to see the actual exception message, if the test fails.
This test is a bit hard to read. I think it should be a JUnit assertThrows() if you want to see an actual message.
what if storageDomainDR.getJobId()!= null, won't we need to use storageDomainDR.getGeoRepSessionId and storageDomainDR.getStorageDomainId instead of getParameters().getGeoRepSessionId() and getParameters().getStorageDomainId()
else if (storageDomainDR.getJobId()!= null) {
what if storageDomainDR.getJobId()!= null, won't we need to use storageDomainDR.getGeoRepSessionId and storageDomainDR.getStorageDomainId instead of getParameters().getGeoRepSessionId() and getParameters().getStorageDomainId().
Could this be moved to the finally block?
Could this be moved to the finally block? Seems like it's used in more than one place?
Could this be moved into the if clause?
This can't be true, as Math.min() would return max if ns What happens in this case? Tried to run on Windows and "shocked files" on /tmp/a.eclipse.cdt.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/b
This can't be true, as Math.min() would return max if ns What happens in this case? Tried to run on Windows and "shocked files" on /tmp/a.eclipse.cdt.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bal/src/main/java/org/apache/hadoop/hbase/
This can't be true, as Math.min() would return max if ns What happens in this case? Tried to run on Windows and "shocked files" on /tmp/a.eclipse.cdt.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-e.core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bll-jgit/core/bal/src/main/java/org/apache/git/internal/
Actually, there is not the elementNameFilter, not the elementNameFilter.
Minor whitespace issue.
Minor whitespace
Why did you make this variable final?
Why did you make this change?
Wouldn't it make sense to just use the value of the String array here?
This flag should be added to the beginning ChineseEntry while it is added.
Is this flag needed here? _is isStageEnabled_ is true_
Is this flag needed here? _is isStageEnabled_
Refactor into method PatientController getPatientOnServer()
Refactor into method PatientController getPatientOnServer
Refactor into method PatientController getPatientForServer()
please remove the "Guid.Empty"
please remove the part in a separate patch.
please remove the 'else'
please add toString() method here and in other places.
please add toString() method here and below.
please use toString()
Why this change?
Why this changed?
Why 400?
I'm not quite following what you are doing with the TypedEntity class. It seems like you are using it primarily to convert from TypedEntity returned in this loop to an Entity. If that is the case, you should be creating a new TypedEntity and use that here.
I'm not quite following what you are doing with the Entity FieldNames
I'm not quite following what you are doing with the Entity FieldNames.
I just do not understand the reason for the change. Existing impl does not work as expected
finalclients are not needed
finalclients are not needed here
subMonitor should be used here
subMonitor.newChild with 1 tick
subMonitor must be used here
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
Why write it back to a field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update. I think we should have some kind of synchronization here.
If this is never going to happen, why modify this to be less chatty?
If this is never going to happen, what if there is no End point?
If this is never going to happen, what if there's a cause?
can we set this to null first? otherwise we'd get a NPE on the next line...
can we set this to null first? otherwise we'll get a NPE on the next line...
can we set this to null become a valid value?
This is pretty dangerous because alerts bigger than 1MB will break the emitter
This is pretty dangerous because alerts bigger than MAX_MISSING_RULES will break the emitter
This is pretty dangerous because alerts bigger than MAX_MISSING_RULES will break the other rules.
Extra space
Extra parentheses
Missing space here
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner: Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri().isEmpty(), "Config server URI is undefined.");
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner: Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri(), "Config server URI is undefined.");
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner: Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri().isEmpty(), "Config server URI is undefined");
Should this use a constant instead of a literal "otherwise"?
Should this use the iterator?
Should this use a constant instead?
Is there a reason not to use ByteString.copyFrom(entry.getKey(), entry.getValueArray()) here, and below?
Is there a reason not to use ByteString.copyFrom(entry.getKey()) here, since that is more common?
nit: I would use the newly created ByteString.copyFrom(entry.getKey()) here instead of this conversion.
Do we want to log the exception in this case?
Do we need this?
Do we want to log this in the future?
Add newline before return.
Add newline before return...
Add newline before return..
Could you explain how this fixes the issue? We are trying to sanitize the previouslySentResponseIndex and then incrementing it upon the request. Maybe we should add a paren to the if?
Could you explain how this will work with the [bug](<LINK_0> that is a CL? I think it is possible to get an explicit close() method on the ByteBufHolder because that is a subclass of AutoCloseable.
Could you explain how this will work with the [bug](<LINK_0> that is a CL?
Did you measure anything more than just using a double value? Is there a more sense to set the floored bounds to the end of the file?
Did you measure anything more than just using a double value? Is there a more sense to set the floored bounds to the output bounds?
Did you measure anything more than just using a double value? Is there a more sense to set the floored bounds to the file?
No need to use a separate variable (especially as it's a local variable, but preferably)
No need to use a separate variable (especially as it's a local variable, but preferably). As an instance variable, I think we don't need to modify it.
No need to use a separate variable (especially as it's a local variable, but preferably) just inline the original variable.
I'm not sure what the reason for this change: it doesn't seem to handle exceptions on the same block. If it's a bad idea to throw a NuxeoException from a catch, then the exception will be caught and the stack trace is printed.
I'm not sure what the reason for this change: it doesn't seem to handle exceptions, but if it's a bad idea to let the exception be thrown.
I'm not sure what the reason for this change: it doesn't seem to handle exceptions on the same block. If it's a bad idea to throw a NuxeoException from a catch, then the exception is caught and the stack trace is printed.
null pointer exception here
Use == instead.
null pointer exception here?
why is it for instead of just if?
why is it again?
if (
There is only one ITypeMarshalBuffer.BASIC_TYPE | shiftedKind | ITypeMarshalBuffer.LAST_FLAG. It makes sense to define ITypeMarshalBuffer.BASIC_TYPE | shiftedKind | ITypeMarshalBuffer.LAST_FLAG and use ITypeMarshalBuffer.BASIC_TYPE.
There is only one FLAG7 check. It makes sense to define ITypeMarshalBuffer.BASIC_TYPE | shiftedKind | ITypeMarshalBuffer.LAST_FLAG and use ITypeMarshalBuffer.BASIC_TYPE.
There is only one FLAG7 check. It makes sense to define ITypeMarshalBuffer.BASIC_TYPE | shiftedKind | ITypeMarshalBuffer.LAST_FLAG and use ITypeMarshalBuffer.BASIC_TYPE. I'll fix it in another PR.
this shouldn't run the thread during the running UI thread
this shouldn't run the thread for all visible filters.
this should also use a forEach
I'm not sure what this is for. Why do you need to filter out CaseVariableInstance again? The original code is clear.
I'm not sure what this is for? Why do you need to filter out CaseVariableInstance again? The original code seems to be missing 'FUNCTION'.
I'm not sure what I mean with this change.
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can use.
I think it would be better to run the VmNetworkInterfaceDAO first and then check if it is null.
I think it would be better to run the VmNetworkInterfaceDAO first and then check if it is null or empty.
Why do we need to wait?
Why do you wait?
Why do we wait?
nit: maybe replace this with: java Optional<ApplyNode> applyNode = searchFrom(plan).where(ApplyNode.class::isInstance).findFirst(); if (applyNode.isPresent()) { throw error(applyNode.get().getCorrelation(), applyNode.get().getOriginrg()); } else if (lateralJoinNode.isPresent()) { throw error(applyNode.get().getCorrelation(), lateralJoinNode.get().getOriginrg()); } return plan;
nit: maybe replace these three lines with: java Optional<ApplyNode> applyNode = searchFrom(plan).where(ApplyNode.class::isInstance).findFirst(); if (applyNode.isPresent()) { throw error(applyNode.get().getCorrelation(), applyNode.get().getOriginrg()); } else if (lateralJoinNode.isPresent()) { throw error(applyNode.get().getCorrelation(), lateralJoinNode.get().getOriginrg()); } return plan;
nit: maybe replace this with: throw error(applyNode.get().getCorrelation(), applyNode.get().getOriginrg());
nit: you can share the instance creation with each buffer and then use separate decoder from each buffer.
Can we reuse the ByteBuf instance? And we have to handle the EOF.
Can we reuse the ByteBuf instance?
Do we need to init state? Isn't this method called when the operator was not finished?
Do we need to init state? Isn't it enough to call it afterInvoke method?
Do we need to init state? Isn't this method called when the operator was already executed?
@original-brownbear oh, I see, it's \u
@original-brownbear oh, I see, it's \u+
@original-brownbear what's the point of calling this?
This is the pattern that's used to instantiate a new OUT on declaration, but it's not that important.
This method should be synchronized.
This looks like it's not necessary.
Better: append this unconditionally, and only append the other part based on the condition.
Better: suggestion if (StringUtils.isNotEmpty(user.getName())) {
This should be public.
It's wrong, but if we are on the top of the file, let's say that neither of them should be set.
It's wrong, but Assert that neither of these entries are set.
It's wrong, but if we are on the top of my head we should set these.
Please don't introduce labels, as I removed them in anoher pull request because sonarcloud complains about them (and not just sonarcloud)
Please don't introduce labels, as I removed them in anoher pull request because of a sonarcloud complains about them (and not just sonarcloud)
Please don't introduce labels, as I removed them in anoher pull request because of a sonarcloud.
shouldn't this be private?
should this be private?
use this.transform()
Can you rename this to checkContent?
Can you rename to checkContent?
Can you rename this to checkContentEquals?
Should be public.
Should be error if version is unknown
doc
suggestion if (builder.headers!= null) { Collections.unmodifiableMap(caseInsensitiveCopyOf(builder.headers)); }
suggestion Collections.unmodifiableMap(caseInsensitiveCopyOf(builder.headers));
suggestion Collections.unmodifiableMap(caseInsensitiveCopyOf(builder.headers)) : new LinkedHashMap<>();
This test does not look correct, it seems that this test does not run...
This test doesn't look correct, it seems that this test does not actually run this feature.
This test doesn't look correct, it seems that this test does not actually run...
This filter is also redundant since the infoStream.map(MetaTypeInformation::getFactoryPids) will always filter null.
This filter is also redundant since the infoStream.map(MetaTypeInformation::getFactoryPids) will always return a non-null value.
This filter is also redundant since the infoStream.map(MetaTypeInformation::getFactoryPids) will always return a non-null infoStream.
When passing an error, bad practice, use Branch.INVALID_RESPONSE instead.
When passing an error, bad practice, use Branch.INVALID_ENTRY instead.
When passing an error, bad practice, use log.error.
this seems to be a breaking change.
this whole else seems to be a bit redundant.
this seems to be a bit brittle. If we have a worker with a min and max worker, we should check whether the workers are out of sync.
If oK and VDS are not specified then it should be null. The behavior must be handled like this.
If oK and VDS are not specified then it should be null.
If oK is used or or value, then it should be null.
And call it longValuesMV[i] instead?
And call it longValuesMV
braces
It would be better to avoid for loop and make the tabAt be in the loop.
This doesn't seem right, the tab will be null if tab.length is 0
This doesn't seem right, the tab will be nulled in this case.
IResourceDeltaVisitor.create(IResourceDeltaVisitor.class)
IResourceDeltaVisitor is a private method, so you can run this code directly without needing the resource delta.
IResourceDeltaVisitor.create(IResourceDeltaVisitor.class, () -> new IResourceDeltaVisitor(this));
I think that is not a good idea to pass an empty string here. If the link is null, the code will look like a simple Optional<Integer>.
I think that is not a good idea to pass an empty string here. If the link is null, the code will look like a simple Optional<String>.
Shouldn't this be link?
Will this code run on windows?
Will this code crash on windows?
Will this code fall through to K?
s/createPolygon()/createMultiPolygon()
s/createPolygon()/createMultiPolygon(input)
s/createPolygon()/createMultiPolygon(null)
we could probably refactor this to a method, something like: java private String getVdsGroupId() { return app.getName() + " is not available."; }
we could probably refactor this to a method, and call it from the else block
we could probably refactor this to a method, something like: String updatePath(String applicationName)
I think we should change this to "return (T) 1"). I think that is a bit easier to understand.
I think we should change this to "return (T) 1"). I think that is a bit more clear.
I think we should change this to "return (T) 1"). I think that is a bit easier to understand and maintain.
Since the subject isn't initialized until the callback returns. Won't this most likely lose the race and cause an NPE? I think this could be solved by making an AMLoginInfoTask subclass that provides latching mechanisms like AMSubject and Subject. So the code here would look something like (super approximately): LoginInfo info = new LoginInfo(); info.execute(); info.await(); assertThat(info.result(),...); // Even more approximate if (info.legacyAuth()) { Subject subject = new Subject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(),...); } else { AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(),...); }
Since the subject isn't initialized until the callback returns. Won't this most likely lose the race and cause an NPE? I think this could be solved by making an AMLoginInfoTask subclass that provides latching mechanisms like AMSubject and Subject. So the code here would look something like (super approximately): LoginInfo info = new LoginInfo(); info.execute(); info.await(); assertThat(subject.result(),...); // Even more approximate if (info.legacyAuth()) { Subject subject = new Subject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(),...); } else { AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(),...); }
Since the subject isn't initialized until the callback returns. Won't this most likely lose the race and cause an NPE? I think this could be solved by making an AMLoginInfoTask subclass that provides latching mechanisms like AMSubject and Subject. So the code here would look something like (super approximately): LoginInfo info = new LoginInfo(); info.execute(); info.await(); assertThat(info.result(),...); // Even more approximate if (info.legacyAuth().logError() {... } else { AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(),...); } }
if statment needs to be at least one line
if statment needs to be improved/review
if statment needs to be at least one check.
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason. It's safest to simply return in that case.
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason. It's safest to just return in that case.
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason. it's safest to simply return in that case.
why do we need to set ReleaseClearingStateSummary if we're going to use it?
why not to use toImmutableList() here?
why do we need to set ReleaseClearingStateSummary?
what's ".jor"? can we extract it to a constant?
what's ".jor"? can we extract it to a constant variable a meaningful name?
what's ".jor"? can we extract it to a constant field?
It should also be.setDiscard(DiscardAttributeChecker.UNDEFINED, Attribute.INITIAL_LOAD.getDefinition())
It should be.setDiscard(DiscardAttributeChecker.UNDEFINED, Attribute.INITIAL_LOAD.getDefinition())
It should also be.setDiscard(DiscardAttributeChecker.UNDEFINED, Attribute.INITIAL_LOAD.getDefinition());
null check.
null check here
null check style
Maybe we can just use a LinkedList here
Maybe you can just use a LinkedList here
Same here as well.
Could you use the TasksListener.isRun()?
You could do it in one line (or above if you prefer).
You could do it in one line (or above if you want to include the failed count as well).
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
I know I have a split opinion. I'd would take a stance that this constructor should be used only when you start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades API.
Should this go into doReturn rather than raw values?
Should this go into doReturn instead of raw values?
Should this go into doReturn rather than raw returns of null?
Please extract to a constant
Please extract to constant
Please consider adding a constant to the name of the constant
I'd prefer to have a test that verifies the span type of the name, and use the traceId of the span.
I'd prefer to have a test that verifies the span type of the created trace, and use the traceId of the span.
I'd prefer to have a test that verifies the span type of the created trace.
This will create a new Story description - Success <LINK_0>
This will create a new Story description - Success, Success, Expires, will not be called
This will create a new Story description - Success, Expires, is not called
double
double extra
newline
Why is this extract as a constant?
Why is this extract as a separate method?
Why is this extract to a function?
Please change this to use the "SchemaUtil.join()" method in the public EmbeddedMysql() method. That way, it's more readable and concise.
Please change this to use the "SchemaUtil.join()" method in the signature of the public EmbeddedMysql() method. That way, it's more readable and readable.
Please change this to use the "SchemaUtil.join()" method in the signature of the public EmbeddedMysql() method. That way, it's clear that we are always using the default Version.
Suggest a check if the task exists or not.
Suggest a check if action exist for the workflow or not.
Suggest warn
Is it necessary to stop the tasks that need to be started?
In general, I think we should start the tasks that need to be started. The other way around could potentially introduce latency.
Is toCancel should be called in the constructor?
Since we're already making this optional, it may be nice to move it to the caller and throw an exception.
Since we're already making this optional, could you move it to the if statement above?
Should be the first filter of CREATED
This would be UncheckedIOException.
Could you have a LayoutClient with INVALID_EPOCH variable?
Could you have a LayoutClientImpl that takes a Collection<Layout>, and have the callers use it?
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit a domain class for. * Indeed, the test does not cover all the use cases, I don't see why going though so much Java code to edit a VSM via hard to read and duplicated logic. Simply craft a VSM with the set of all possible combinations and make the test simply call validation on it. * The test does not cover all the scenarios.
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit a domain class for. * Indeed, the test does not cover all the use cases, I don't see why going though so much Java code to edit a VSM via hard to read and duplicated logic. Simply craft a VSM with the set of all possible combinations and make the test simply call validation on it. * The test does not cover all the case.
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit a domain class for. * Indeed, the test does not cover all the use cases.
Use try-with-resources for connection usage
Nit: Doesn't matter much because the user might be using an opaque strings to this?
Use try-with-resources for close
rename to launch
typo in launch
typo
lets make this an exception
lets update container size in exception
this update is good, but we don't need to know if the account is update
please put in a separate method or rename this support method accordingly
please put in a separate method or rename this one to reflect the intent.
please put in a separate method or rename this one to reflect its purpose.
put the log in the for loop so its clear
for (BaseCheck chk : chk.getDescription()) {
put the log in the for loop so that its not visible
Shown on the UI so should be i18n aware.
Shown on the UI so should be i18n aware?
Shown on the UI so should always be i18n aware.
change this to: this.containers.addAll(containers)
change this to AssertionError
the logic should be a bit complex
what's the bridge status here? Shouldn't this be OFFLINE, right?
what's the bridge status here? Shouldn't this be OFFLINE, but the bridge status should be OFFLINE?
what's the bridge status here? Shouldn't this be OFFLINE?
Not sure if this text should be externalized.
Not sure if this is a good idea, but probably it could be a constant (like PROPERTY_TABLE_NAME)
Not sure if this is a good idea, but probably it could be a constant (like PROPERTY_PROFILE_NAME)
Can remove the 4635 and make it final and reuse the speedLimit variable
Can remove the 4635 and make it final and add a null check
Can remove the 4635 and make it final and add a null check.
Please use PSQLState instead of Exception.
Please use PSQLState instead of Exception. Also, you can use ExceptionUtils.getStackTrace(Throwable)
Please add an assertion.
[minor] Use IllegalArgumentException instead of Exception
[minor] Use IllegalArgumentException instead?
Float.parseFloat
hmmm... maybe we should have a @SuppressWarnings("unchecked") here?
hmmm... maybe we should have a @SuppressWarnings("unchecked") here? It's not really necessary
hmmm... could you write this one more?
we should check if mMediaUploadHandler!= null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
we should check if mMediaUploadHandler!= null before accessing its methods here, as they are only used in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
we should check if this is called prior to onDestroy().
Minor nit: please move the blog here.
;)
;;
Looks like this now should be withing if (result && this.fullStatsEnabled) as well.
Looks like this now should be withing if (result && this.fullStatsEnabled), not just logging.
Looks like this now should be with System.nanoTime().
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those properties to Jackson (ObjectMapper) directly.
I don't want to have an instanceof check here
There should be only one return statement.
There should be a check for the'showProducts' and'includedInProduct'.
There should be a check here, if the feature is already added.
IIRC anonymous users will crash here because they have no user account to get the prefs from.
IIRC anonymous users will crash here because they have no user account to get the path of the file.
IIRC anonymous users will crash here because they have no user account to get the path.
I think it is fine for this to be "RyaStreams-Query-" + query.getQueryId()
I think it is fine for the message to be "Sparql".
I don't think we can simply define the string as a final static field.
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still improve readability of the code. What do you think?
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still help. What do you think?
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still be worth. What do you think?
do you think it would be more efficient to filter on the partitionKeyFields directly?
do you think it would be more efficient to convert the partitionKeyFields directly on the event?
do you think it would be more efficient to convert the partitionKeyFields directly to a List?
Please remove System.out.printXX, as they are done via logging
Please remove System.out.printXX, as are done twice
System.out?
In fact, it's better to use org.apache.ignite.testframework.GridTestUtils#waitSuccess.
If you use assertEquals(expected, actual) and then you will call assertTrue in case of exception.
If you use assertEquals(expected, actual)
maybe use dnsRecordFactory.getInstance()
maybe use dnsHandle.getName()
maybe use dnsRecordFactory.get().
Is there a reason to add this message in azkabanFlow.properties?
Is it a test that retrieves the yaml files in the directory? Does it mean the directory is missing in the azkabanFlow.properties?
Is it a test that retrieves the yaml files? It looks like a directory which is not in the directory.
This code is already non-null. It can be simplified to: if (vungleBanner!= null) { publisher.getParent(); }
This code is already non-static. It can be simplified to: if (vungleBanner!= null) { publisher.getParent(); }
This code is already non-null. It can be simplified to: if (vungleBanner!= null) { Log.d(TAG, "vungleBanner"); }
I would move the logic to the RestInvocationException class, and remove the catch clause.
I would move the logic to the RestInvocationException class and remove the catch clause.
I would move the logic to RestInvocationException
Yes, I should have @SuppressWarnings("unchecked") for boolean expression, in which case I think it's better to write: if (predicateValue.booleanValue()) { return false; } return predicateValue.booleanValue();
Yes, I should have @SuppressWarnings("unchecked") for boolean expression, but this isn't a particularly strong feeling.
Yes, I should have an assertion for simple boolean.
We should assert that this is the expected value.
We should not use assertEquals for the two instances when the default is false.
We should assert that the result is the expected value.
Can you check that addr.get() is the same?
Can you wrap this try-catch in a try-catch block, and have only one test for it?
Can you wrap this try-catch in a try-catch block?
The monitor should be made in a JobManager
The monitor should be made in its own background.
The monitor should be made in its own background thread.
Can we remove this in the race condition?
Can we remove this synchronized block?
Wrong method name here.
It seems like it's safer to use the builder pattern.
BulkCommand.GET
It seems like it's safer to use the builder pattern to generated generated streams.
Need to use placeholders for those as well
Missing braces.
Missing braces?
We should log a warning here too.
We should be closing the activity here any more.
We should be catching (or log) and call getClass().getName() just in case.
Please send a metric here.
Conventional header strings
BarcodePrintPrintPrint?
Use { } even for one line if/else bodies.
Use the else bodies even for the switch/case bodies.
There needs to be an else bodies.
Fine for me, but I'd like to leave that line as it was before (and remove the try/catch)
Fine for me, but I'd like to leave that line as it was before (the empty line would be fine here).
Fine for me, but I'd like to leave that line as it was before (the null check here is ok).
This is confusing for me. What about the following? Set<UMLRTProtocolMessage> protocolMsgs = new ArrayList<>(); for (UMLRTProtocol protocol : allProtocols) { allProtocols.addAll(ProtocolUtils.getAllProtocols(protocol)); }
This is confusing log message.
This is confusing to me. What about the sorting rule?
Do we have a use-cases that need to override this?
Do we have a use case for this?
Do we have a factory method for this?
I would prefer to add a handler.setControllerListener(handler) as well
I would prefer to add a handler.setControllerListener(false) on your handler.
I would prefer to add a handler.setControllerListener(false) on your handler as well
just use an EnumRenderer in the view instead of localization in the model
just use an Enum here.
just use an Enum here
Could you rename the animationListToLoop to animation and animationListToPlay to animation?
Could you rename the animationListToLoop to animationListToPlay?
Could you rename the animationListToLoop to animation and then add an conditional variable to it's named 'loop'?
What happened to the checkbox between name and potential value?
What happened to the checkbox between the left and the right?
What happened to the checkbox between the left and the left text?
This may not be needed at this point.
This method is not needed at all.
This may not be needed at all.
This should be inside the if block, it's not just a reminder.
This should be inside the if block, it's not just a return statement.
This should be inside the if block, right?
can we also throw a more specific exception?
can we also include a test where we set this to be true?
can we also include a test where we set this to fail?
"Must have a snapshot" or "Must have a snapshot"
"Must have a snapshot" --> "Must have a snapshot"
"Must have a snapshot" or something
s/type/name
s/type/getName
GeometryType
Why 5? It looks like the constant is not being used.
Why 5? It looks like the constant is not used.
Why 5? It looks like the constant is changed, but it is not.
You can consolidate these into a single method. I.e.: oos.writeObject(obj); try { oos.writeObject(obj); } finally { oos.close(); }
You can consolidate these into a single method: oos.writeObject(obj); try { oos.writeObject(obj); } finally { oos.close(); }
You can consolidate these into a single method. I.e.: oos.writeObject(obj); byte[] buf = new ObjectOutputStream(baos); oos.writeObject(obj); Configuration conf = new ObjectOutputStream(entries);
Should this really be../FOO/FOOFOO and.._FOO/FOO
Should this really be../FOO/FOOFOO and../FOO/FOO
Should this really be..FOO/FOO and.._FOO/FOOFOO
Isn't it just enough to do: assertThat(occurrence.getDiseaseOccurrence().getId()).isNotNull();
Isn't it just enough to do: assertThat(occurrence.getAlert().getCreatedDate()).isNotNull();
Isn't it just enough to do: assertThat(occurrence.getAlert().getCreatedDate()).isNotNull();?
Should these be removed?
Should these be removed or removed?
Should be removed
can we use the data.mark() directly here?
can we use the azure-core library here?
Do we need this?
I would change it to lag[index] = offset; it is often more expensive. Same for the other two alerts.
I would change it to lag[index] = offset; it is often more efficient than synchronized(this) which does not take into account the offset.
I would change it to lag[index] = offset; it is often more expensive. Same for the other iterations.
Can we use aggregateStorage.ifPresent(result -> { result.play(aggregateStateRecord); return Optional.of(result); });?
Can we use aggregateStorage.ifPresent(result -> { result.play(aggregateStateRecord); return Optional.absent(); });?
Can we use aggregateStorage.map(AggregateStateRecord::commit) instead of this where it is used?
You are not using the getDrawable() method here. If you want to return picasso.context, use the ContextCompat method
This shouldn't be needed.
This should be package private.
log the sleep duration maybe? and maybe remove the exception?
log the sleep duration maybe? and maybe remove the if?
log the sleep duration maybe? and maybe remove the sleep?
If you're going to do this right, I think you can get rid of the last check.
Couldn't these all get back the same thing?
Couldn't these all get back 1st does not work?
Please remove the System.out, e.g.:  log the relevant information?
Why log the failure?
Please remove the System.out, please
[\n\r]+ would perhaps be safer
[\n\r]+ would perhaps be more useful
[\n\r]+ would perhaps be more readable
This doesn't seem right. Pull it out.
This doesn't seem right. Pull it up and then call it from the constructor.
This doesn't seem right. Pull it up and then call getConfig()
Should be a.filter(lock -> lock.getAcquired().isBefore(limitForAcquired))
.filter(lock -> lock.getAcquired().isBefore(limitForAcquired))
Should be a.filter().
If we are in the future, should we also check if fullState.get(fQuark).getStateValue().isNull()?
If you want to be sure it's getEndTime() is not null you should do a!= null test on fullState.get(fQuark).getStateValue().isNull()
If we are in the future, should we also check if fullState.get(fQuark).getStateValue()!= null?
Same as above, use isDebugEnabled
Same as above, use method modifies
Same as above, use method modifies consumer.
Why is this needed? I don't see this being used in anywhere.
Why is this needed?
Why is this not a new method?
The newly added empty line makes me think that you can skip it.
The empty line is not needed here.
The newly added empty line makes me think that you can remove it.
Should do "region == null".
Should this be passed along to executePut()?
Should do "region!= null".
Should we throw an exception?
Should there be an assertion for this?
Should this be thrown?
Should this be an enum?
Should this be an integer?
Should the method be used instead?
you could use Entities.removeAll(attachment) here
please use Entities.filterOnly
please use Entities.removeAll(attachment)
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
Think @sandeepSamudrala mentioned in the another pull request. Should add location to to the resultObject.
Think @sandeepSamudrala mentioned in your another pull request. Should add location to the resultObject.
This can be small D double
This can be small *2
This can be small D double.
why not use the human-readable message of the mediator with the attribute?
why not use the human-readable message of the mediator under the log?
why not use the human-readable message in errorHandlerAttr?
checkNotNull
checkNotNull()
checkNotNull?
s/Started/Starting
Was this change intentional?
Was this intentional?
Minor suggestion to make this less readable: if (p.getFullProtectionAgainst(ProtectionType.FLYING_INTO_WALL)) {
Minor suggestion to make this less readable: if (profile.hasFullProtectionAgainst(ProtectionType.FLYING_INTO_WALL)) {
Minor nit, no space after if
Why do we want to return here? Even if we retVal is null, it will be added with the output of fListenersByPartId.get(listenerPartId)
Why do we want to return here? Even if we retVal is null, it can be added with the output of fListenersByPartId.get(listenerPartId)
Why do we want to return here? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fListenersByPartId.get()
Should this test that the task is returning the active state?
Should this test that the task is returning AGGREGATbyTask?
Should this test that the task is returning AGGREGATbyTask.
Shall we use ROOT_PATH instead of "/"?
Shall we use ROOT_PATH instead of "/" from the constants?
Shall we use ROOT_PATH instead of "/" from the constant?
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should check its own overflows.
I don't think it is the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should check its own overflows.
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps with a different value, the user should check its own overflows.
could we have a message explaining which operation is being retried?
we don't need this condition
could we have a message explaining which operation is being executed?
I Don't like this at all: the superclass is now doing different things based on the result of the test if the check fails. Prefer: factor out into an abstract method where each method does their own thing.
I Don't like this at all: the superclass is now doing different things based on the result of the test if the check fails. Prefer: factor out into an abstract method where the tests can enable looking-up stats if the logic was successful
This should also be done in an after method where the result is > 0
This should be getIntent().getStringArrayListExtra(SESSION_ENDPOINT_ARGUMENTS) - to make it more readable.
hasArgs(endpointArguments) should be singular with map.
This should be getIntent().getStringArrayListExtra(...).
we still need this snapping logic if its time is not n-23?
we still need this snapping logic, right?
we still need this behavior.
use get() to create new Location() if it can be null.
use get() to create new Location() if it's not available for Jclouds.
use get() to create new Location() if it's not specified.
addChangeListener(this)
addChangeListener(layoutAlgorithm)
this.layoutModel = checkNotNull(network);
This could just be a nested if statement. The "else" block would throw an exception.
This could just be a nested if statement. The "else" block would throw an exception of the first if statement.
This could just be a nested if statement. The "else" block could be removed.
you don't have to change the name of the node here
don't use brackets here
you don't need to change the name of the node here
This needs to be in a finally block.
This looks a bit like a debug statement - could you please remove it?
This looks a bit like a debug statement - could you please remove it please?
assertFalse(...);
assertFalse( crashReporter.storeUnhandledException(exception));
assertFalse("Error
Please use GTK4 as with GTK4.
Please use GTK4.
Please use gtk3.10.
Check what happens with an empty file: Looks like on replay, both openFile() and closeFile() calls are skipped since there are no recovery entries for that file.
Check what happens with an empty file: Looks like on replay, both openFile() and closeFile() calls are skipped since there is no recovery entries for that file.
Check what happens with an empty file: Looks like on replay, both openFile() and closeFiles() calls are skipped since there are no recovery entries for that file.
suggestion if (numToRequest > 0) {
Can you wrap this block in a block like this? int numToRequest = Math.min(2 - requested.get(), n);
Can you pull the Math.min call out of the loop so it is more readable?
In my testing on Linux I see another SWT.Selection between MouseDown and MouseMove. Maybe you can also do this in SelectionDialog.onboard?
In my testing on Linux I see another SWT.Selection between MouseDown and MouseMove.
In my testing on Linux I see another SWT.Selection between MouseDown and MouseMove. Maybe it would be better to not use mouseUp here (and only use MouseDown)?
![MINOR](<LINK_1> 'Severity: MINOR') Refactor your code to get this URI from a customizable parameter. [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Refactor your code to get this URI from a customizable parameter. [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Refactor your code to get this URI from a customizable parameter. [![rule](<LINK_1>](<LINK_0>![MINOR](<LINK_2> 'Severity: MINOR') Define a customizable parameter. [![rule](<LINK_1>](<LINK_0>
close streams
close the stream
close the stream.
We can probably use a constant for this.
I know you didn't change any of these parsing code, but I think we can probably do a static import for Optional.
I know you didn't change any of these older constructors but I think these could be null?
Actually, this is pretty inefficient. It should take the maxCreatedDate directly in the constructor. You could add a method to getMaxCreateDateAndCreatedDateForInterval(Segment segment, Map<Interval, List<DataSegment>>>) toDropInterval. The loop below won't guarantee order.
Actually, this is pretty inefficient. It should take the maxCreatedDate directly in the constructor. You could add a method to getMaxCreateDateAndCreatedDateForInterval(Segment segment, Map<Interval, List<DataSegment>>>) toDropInterval. The fix is already incorrect.
This piece of code is duplicated below, could you make a helper function?
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F1, return fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F1, return fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F1, return fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
I don't understand why this change and not a part of the test?
I don't think this is right, the message should be a little more descriptive.
I don't understand why this change is necessary.
Should this return a MigrationException instead?
Should this return a MigrationException instead of a null?
Should this return false?
You forgot parentFile and it also must be aliased name
You forgot parent directory and it also must be aliased name
doc please
lets make the account name into "RestRequest"
lets make the account name into a constant
lets make the account name into a constant.
addHandler(ProjectMessage.class, m -> maybeRefreshIndexSearchers(m.getTags())).
This handler is used at several places, so it's probably better to factor it out into a method.
This can be refactored into a addHandler method.
we can just use "Reporting.logger.error("Message.error.ioexception", e);" to avoid code duplication.
we can just use "Reporting.logger.error("Message.error.ioexception", e);" instead of full stacktrace handling.
we can just use "Reporting.logger.error("Message.error.ioexception", e)" instead of full logging
@grkvlt3 let's change the variable name back to just _anomalies_
@grkvlt3 let's change the variable name back to just _ anomalies_
@grkvlt3 let's also describe the use of the _cluster_ variable and the corresponding argument.
Why are you using a ImmutableList here? And then by extension a signature is defined to be List<String>. This method could then be called in the getAllRequests() method.
This should use the LOG.error() unless we want to log the exception.
This should use the LOG.error method.
Why not compare the version?
Why?
Why not just use the enum here?
I'm not sure that we need this to be a default state. What is the impact of it?
I'm not sure that we need this to be a default?
I'm not sure about this. Why do we need to pass a default state to the command?
This is an example.
This is an example. Please remove it
This is an example. Please test all variables.
I don't know if there is a reason to get a NPE here? Just use a null check.
I don't know if there is a reason to get a NPE here, or if it is not found it should just throw exception? Just :(
I don't know if there is a reason to get a NPE here, or if it is not found, it will throw exception?
This IntervalUtils.compareLocatables(o1, o2) -> IntervalUtils.compareLocatables(o1, o2, o3)
This IntervalUtils.compareLocatables(o1, o2, o2) -> IntervalUtils.compareLocatables(o1, o2, o3)
This IntervalUtils.compareLocatables(o1, o2) -> IntervalUtils.compareLocatables(o1, o2, o2)), is just a duplicate.
It's definitely not a sloppy path. And, should we rename it to something that reflects the purpose of this object? It's definitely not a map.
It's definitely not a sloppy path. And, should we rename it to something that reflects the purpose of this object?
It's definitely not sligible to create two map. The map should be adapted to this object
There's a typo in RyaInstanceName
There's a typo in RyaInstanceName. Should be "RyaInstanceName".
There's a typo in RyaInstanceName. Should be "RyaInstanceName"
This block only compares the MethodAccessItemDto objects. It should compare them to the MethodAccessItemDto objects from the corresponding indexes of the MethodAccessItemDtoList.
This block only compares the MethodAccessItemDto objects. It should compare them to the MethodAccessItemDto objects from the corresponding indexes of the methodAccessItemDtoList.
This block only compares methodAccessItemDtos. It should compare them to the methodAccessItemDtos.
There are a few checkstyle errors left: [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (
There are a few checkstyle errors left: [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found
There are a few checkstyle errors left: [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedOrderDialog.java:29: Line is longer than 120 characters (found
This is a bit clunky, it should be read using a try-with-resources pattern here.
This is a bit strange, it should be read using a try-with-resources pattern here.
This is a bit clunky, we should not be printing the stack trace here. It is helpful for debugging.
[minor] Turn this into a try/finally? It might be easier to read.
[minor] Turn this into a try/finally block?
[minor] Turn this into a try/finally?
Shouldn't we be moving the elevator while we're moving the clamp?
Shouldn't we do something. If there's an error occurs, we'll never be able to start the action?
Shouldn't we do something if the elevator is at the top?
"for method..."
"for method {}" -> "for method {}
"for method..." -> "for method..."
Can you remove these?
Can you remove the - at the end of the method?
Can you remove the - at the end of the function?
change to List<Issue> issues = Lists.newArrayList();
change to List<Issue> s = Lists.newArrayList();
change to List<Issue> s = Lists.newArrayList(); copyResource(set, ones);
Can use else if here.
Can use CollectionUtils.isNotEmpty here.
Can use aliases
Is this always a ((NameCallback) callbacks[0]).getName();? I have this block of code hard to read.
Is this always a ((NameCallback) callbacks[0]).getName();? I can't think it's a for google search
Is this always 'e' not null?
Add a check for null here - in case the isAssignableFrom fails, this will throw NPE.
Add a check for null here - in case the isAssignableFrom fails, this will throw ClassNotFoundException if it does not match the regex.
Add a check for null here - in case the isAssignableFrom fails, this will throw ClassNotFoundException if it doesn't match the regex.
Minor: Instant.ofEpochMilli(ime.getEventTime()).toString() is unnecessary?
Minor: Please add whitespace before if.
Minor: Please add whitespace before if statement.
bricksButton.edit(bricks); can be used here.
bricksButton.edit(brickModel); has been added here.
volumeType can be null
change to: if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {
change to: if (VERSION.SDK_INT < VERSION_CODES.LOLLIPOP) {
change to background.scheme
This is not going to work on HTTPS. Dstance
This is not going to work on HTTPS. Configuration has no ssl-only set, but it should be > 0.
This is not going to work on HTTPS. Configuration has no ssl-only set, but it should be removed from here.
This doesn't necessarily make sense to me. V_4_2_0 would be better.
This doesn't necessarily make sense to update the version to V_4_2_0_(.+)_VERSION above
4.2
This code will be called after the user run7 logic: java if(site == null) { return null; }...
This block can be return without knowledge of null.
This code will be called after the user calls.
Please refactor to different methods
Please refactor to different method
Please refactor to different tests.
This seems to be changed, but it's not very nice to break.
This seems to be changed, but change it to use startTime instead.
This seems to be changed, but it's not very nice to go.
is this only used inside applyMigration?
is this only used in tests? It might be confusing to have tests.
is this only used in tests? It might be confusing to have a migration without h.update.
Is it safe to change this to return Optional<String> and remove the returned value? The result is the same, right?
Is it safe to change this to return Optional<T> and remove the returned value from getCaseTimeMs?
Is it safe to change this to return Optional<String> and remove the returned value? The result is the same, but is likely to be a change in behaviour here.
Consider breaking this up into multiple lines for readability.
Consider using the one-liner for this if statement.
Consider using the one-liner for readability.
Should we move this up to the default value?
Should be "#exists"
Should be "../#"
Can be simplified to use PAD::new
Can be simplified to use PAD.
Can be simplified to use PAD::map
also need to handle case where programArt == null
handle null case (same for rest below)
handle null case (like #1991)
I'd break this up as java StringBuilder sb = new StringBuilder().append(formatExpression(column.getName(), parameters)).append(" ").append(column.getType());
I'd break this up as java StringBuilder sb = new StringBuilder().append(formatExpression(column.getName(), parameters)).append(column.getType());
I'd break this long line into multiple lines.
I think we can avoid creating a variable for the mediaCharset stuff. negotiateMediaType can be equals to negotiateMediaType.equals(accept, Charset.MATCH_ALL_TYPE)
I think we can avoid creating a variable for the mediaCharset stuff. negotiateMediaType can be equals to negotiateMediaType.equals(accept, Charset.MATCH_ALL_TYPE));
I think we can avoid creating a variable for the mediaCharset stuff and just return the result immediately.
This is an internal implementation detail of the applications. You should probably use the identity instead of the strings. <LINK_0>
This won't be logged as debug.
This is an internal implementation detail of the applications, and the implementation is not able to properly incorporate the underlying network proxy as well. <LINK_0>
Instead of using Streams, can we just use Stream.concat?
Instead of using Streams, can we just use Stream.of()?
Stream.of()
Use logs instead?
How about using a waitFor()?
How about using a waitFor here?
I'm not sure, but it seems like it might leave some commas in the case where it's legitimate to add a method named 'getContainingClass'. What do you think? ( UsefulPsiTreeUtil.getChildrenOfAnyType, and/or something similar)
I'm not sure, but it seems like it might leave some commas in the case where it's legitimate to add a method named 'getContainingClass'. What do you think? ( UsefulPsiTreeUtil.getChildrenOfAnyType(haxeClass, HaxeVarDeclaration.class))
I'm not sure, but it seems like it might leave some commas in the case where it's legitimate to add a method named 'getContainingClass'. What do you think? ( UsefulPsiTreeUtil.getChildrenOfAnyType(haxeClass, HaxeMethodDeclaration.class))
s/any(List.class)/anyList/
s/any(List.class)/anyList()
s/any(List.class)/anyList()/
Could you add a log message here?
Could you add a log message that says that the flush has not been done at the end of the command?
Could you add a log message that says what did you try to solve?
this would be a nice change; original exception in the catch() method.
this would be a nice change; original exception was not thrown in the catch block
this would be a nice change; original exception was not thrown in the catch().
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Since connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close it in the original place where it originally (create and )close the dbConnection.
Would be nice to have a different test that verifies that the intent was set and that the FedoraTransaction was created?
Would be nice to have a different test that verifies that the intent was.
Would be nice to have a different test that verifies that the work was indeed created?
[minor] Throwables.propagate(e) will wrap the exception in an RuntimeException
[minor] Throwables.propagate(e) can be replaced with s.propagate(e)
[minor] Throwables.propagate(e) can be replaced with s.propagate(e);
The "key" and "value" looks different from the key.
The "key" and "value" looks different from the rest of the code.
The "key" and "value" looks different from the rest of the message.
I guess the idea is to have this as part of the builder pattern, but we should be consistent and use it everywhere.
I guess the idea is to have this as part of the builder pattern, but we should be consistent and use the builder pattern here.
I guess the idea is to have this as part of the public API.
You could use the code like this: if (now.getTime() - date.getTime()) { holder.txtDate.setText(OneDayText); } else if(days==1) { holder.txtDate.setText(firstDayText); }
You could use the code like this: if (now.getTime() - date.getTime()) { holder.txtDate.setText(OneDayText); } else if(days==1) { holder.txtDate.setText(OneDayText); }
You could use the code like this: if (now.getTime() - date.getTime()) { holder.txtDate.setText(OneDayText); }
You should add a null check to translations.get()
since getSearchFilters can return null you should add a check to make sure getSearchFilters never returns null.
since getSearchFilters can return null you should add a check to make sure getSearchFilters returns an empty list
what if partition.getReplicas() returns null? shouldn't we just throw an exception?
what if partition.getReplicas() returns null? shouldn't we just return null?
what if partition.getReplicas() returns null? should we throw an exception?
Guava style in this way: java return getBySingleKey(key, rangeKey1, rangeKey2, limit);
Guava's List.of()
Guava's stream API?
this empty line should not be here but missing
this empty line should not be here but missing itself
this empty line should not be here but missing itself?
We should probably test both cases with a try/finally block.
We should probably test both cases with a non-null order as well. In the other hand, it might be better to remove the try/catch and test.
We should probably test both cases with a try/catch and a failure
I don't see the difference between testWriteAdvHandle and testWriteAdvHandle. I image you need to verify the different behavior between without and with ledger id. but the test cases don't actually do this validation.
I don't see the difference between testWriteAdvHandle and testWriteAdvHandle. I image you need to verify the different behavior between testWriteAdvHandle and testWriteAdvHandle
I don't see the difference between testWriteAdvHandle and testWriteAdvHandle
i18n
I'm a little bit confused. Should we check if this is the right check?
I'm a little bit confused. Should we check if this is a valid URL?
We can update the ChainingStrategy to be consistent with the line 104 (or in the 85): <LINK_0>
We can update the ChainingStrategy to be consistent with the line 79-70: <LINK_0>
We can update the ChainingStrategy to check thechainingStrategy, and move the transformation transformation transformation down to the top line.
if this is a problem, please add an error message to the exception.
if this is an error, it should not be a ADALError.AUTH_REFRESH_FAILED_PROMPT_NOT_ALLOWED
if this is an error, it should not be a ADALError. More info: "Token not found from acquireTokenSilentFlow"?
This should be a switch statement, not a switch.
This should be an error rather than a string
This should be a switch... not a switch.
Use the primitive long type.
Long.BYTES
call serialize(Page)
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right? 1 2337032 rs1129171 C T,<NON_REF> 480.77. BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,0:45:99:509,0,330,565,407,97 2:9,10,13,13
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right? 1 2337032 rs1129171 C T,<NON_REF> 480.77. BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,15
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right? 1 2337032 rs1129171 C T, that's why the tests fail.
I am not sure this is a good idea. You can consider an element's parent element. What if the element is a Element?
I am not sure this is a good idea. You can consider an element of the text in the template and use that method in both places.
I think this method name should be something like "getElement"?
@cvrebert why can't we use Tv.THREE here?
@cvrebert why can't we use Tv.TEN instead?
@cvrebert Let's use Tv.TEN instead.
do we need to sleep(1000) here? can we make this test sequence more deterministic rather than depending on time, to reduce the sleep time?
do we need to sleep(1000) here? can we make this test more deterministic rather than depending on time, to reduce flakiness?
do we need to sleep(1000) here? can we make this test faster?
nit: this can be private.
nit: this can be shortened to: java return Objects.equals(o, o);
nit: this can be shortened to: java return deepHashCode(o).stream().collect(toImmutableList());
You may want to allow this to be a Id that is already encoded.
You may want to allow this to be a Id that is already set on the client.
Why is this change required?
should be renamed.
should be renamed to showChangeChange
should be renamed to allowChangeChange
This is certainly wrong. You should probably output something and pass that along.
This is certainly wrong. You should probably output something and pass it along and pass it to the rp.markScan and pass it to the method.
This is certainly wrong. You should probably output something and pass that along instead of the rp.
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say -- that stops option parsing.
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say -- -- that stops option parsing.
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say -- that stops option parsing. And it doesn't take into account the -- that stops option parsing.
Maybe we could replace both two lines with NLS.str("tabs.smali"); with NLS.str("tabs.smali");
Maybe we could replace both of these two lines with NLS.str("tabs.smali"); to remove redundancy and other lines.
Maybe we could replace both of these two lines with NLS.str("tabs.smali"); to remove redundancy and other lines..
style nit: no braces
Weird to have braces on both single line block.
style nit: no braces around single line block
If the interpreterGroups list is empty, it doesn't mean that we don't run the task again in the case of exception message.
If the interpreterGroups list is empty, it doesn't mean that we don't run the task again in the case of exception.
If the interpreterGroups list is empty, it shouldn't be closed
code formatter missing? At least there should be a space before the curly bracket and you have a lot of tabs in here...
Is it by intention that you set the status outside of the "synchronized" block? Before you set the status within it...
Is it better to store the status in a local variable instead of calling it twice?
The logic is in ServersInfoExtractor. So it is better to extract this logic into a static method, and also use that in this method.
The logic is in ServersInfoExtractor. So it is better to extract this logic into a static method.
The logic is in ServersInfoExtractor. So it is better to extract this logic into a static method, and also use that in this class.
I think it is better to return an empty collection instead of null.
I think it would be better to return an empty collection instead of null.
I think it is better to return an empty collection rather than null.
Too much logic in this method. Please remove logic from all these methods.
Too much logic in this method. Please remove logic from these checks.
Too much code duplication. Please extract method.
I'm not sure this is correct. If the thread is not fully shutdown, I would prefer to throw an InterruptedException. However, we usually do it like @Override public void processEntry(MarshalledEntry<K, V> marshalledEntry) throws InterruptedException {
I'm not sure this is correct. If the thread is not fully shutdown, I would prefer to throw an InterruptedException. However, we usually catch the InterruptedException from the async method, but I'd like to catch it this way too.
I'm not sure this is correct. If the thread is not fully shutdown, I would prefer to throw an InterruptedException. However, we usually catch the InterruptedException from the async method, and then throw.
not sure whether this is also what we want to do with the qualifier in the error message.
not sure whether this is still needed
not sure whether this is also what we want to do with the qualifier in the error message?
I think this should be a java.util.Objects.equals(source.getTopKey())
I think this should be a java.lang.String. Also, it appears that we might want to log if I am wrong.
I think this should be a java.lang.String.
I'm not sure about this one. The config map is not stored in the cache, it gets accessed by any user. Is this a temporary thing?
I'm not sure about this one. The config map is not stored in the cache, it gets accessed by any user. Is this a temporary state?
I'm not sure about this one. The config map is not stored in the cache, it gets accessed by any user. Is this a temporary assumption to hold?
please use more descriptive names here.
please use some more descriptive names here.
please use more descriptive names here ;-)
Do you want to be re-throwing this into unsuccessfulFinish?
Do you want to be swallowing this? Don't log as a debug log that any other went wrong.
Do you want to be swallowing this? Don't log as a debug log.
This looks like a fall-through case. Perhaps add an empty default case to the AlertRiskTableCellItem.
This looks like a fall-through case. Perhaps add an empty default case to the AlertRiskTableCellItem?
This looks like a bad condition to me: makes the code throw an exception if the default case is missing
Any reason why we don't use the AndroidAPIUtils.getPendingOperations() method here?
Any reason why we don't use the AndroidAPIUtils.getPendingOperations() method?
Any reason to handle this?
You should check isDelete() first
I think we should check isDelete here
You should check isDelete()
Can we use already-defined constants for the following three strings?
Don't create constants for the following three strings?
Don't create constants for the following three strings
This will throw an exception if the logger is not found.
This will throw an exception if the retry occurs.
This will throw an exception if the retry occurs. Perhaps we should set the status to 1 during the first retry rather than leaving the api call failing.
This line is not needed. Remove it.
This line is not needed.
This can be null, you can return that instead
relevant non-logging code change here
relevant non-logging code change here  This is in the class that's log4j-azure-core uses.
relevant non-logging code change
I am not sure if we can try to change this file, but this logic could be moved into prepareServiceRoles(sess) method.
I am not sure if we can try to change this file, but this logic could be moved into prepareServiceRoles(sess); method.
I am not sure if we can try to change this file, but this block can be moved to method like refreshAuthz(sess) which has the impact of method with perunPrincipal()
For sake of readability, you could use splitAllPositions and findLastPosition using previous method so that the searchHits can be greater than the previous one.
For sake of readability, you could use splitAllPositions and findLastPosition using previous method so that the searchHits can be greater than the next one.
For small save, you can use setFieldWithElement(hit) as a parameter instead.
Seems like this will return "null" for the toString() method.
I am not sure about the toString() method. It looks like it's the same as state.toString() below.
I am not sure about the toString() method. It looks like it will return a String and if the toString() method is added to the Value.
duplicate code
shouldn't you be doing the same thing as before?
shouldn't you be doing the same thing as before?
can be a method reference: jobMasterGateway
can be a RuntimeException here
can be a RuntimeException here.
nit: Change? Should it be a constant? As it is a set, this does not make sense.
nit: Change.equals to.equals.
nit: Change? Should it be a constant?
Since this block is repeated in above, shall we move it to a separate private method?
Since this is repeated in above, shall we move it to a separate private method?
Since this block is repeated in above, shall we move it to a separate method?
I would recommend using SolverStatus.NOT_SOLVING here
I would recommend using TimeUnit.SECONDS.sleep( solverInstance.getStatus()) if it fails to sleep. The test will pass if the solver hasn't started yet.
I would recommend using TimeUnit.SECONDS.sleep( solverInstance.getStatus()) to get rid of the sleep.
Is this for debugging?
Please remove this line.
Please remove the debugging output
@gmalanga rights It looks like this could be changed to Strings; but I'm not sure this is correct. I want to make sure that any command that takes a arrival time, and if it returns a String, we want to return an array ofArrivalInfo. So this should be in the caller as well.
@gmalanga rights It looks like this class is in the latest arrivals collection. I'd suggest to check the arrivals for them as well and return an Optional<Long> instead of throwing an exception.
@gmalanga rights It looks like this could be changed to Strings; but I'm not sure this is correct.
.take(limit) is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
limit is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
limit is an alias (take advantage of flatmap). limit is a value in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
When an empty list is returned, it should be allowed to continue with the rest of the method.
When an empty list is returned, it has a name that is just the empty value.
When will this happen?
could you remove the tab and use spaces for indents?
could we remove the tab and use spaces for indents?
could you remove the tab and use StringUtils instead?
Please introduce custom error message (<LINK_0>
please introduce custom error message (<LINK_0>
Please introduce custom error message (in case of failure during parsing of XML file) to improve readability.
Can we just use builder for this?
Can we just use builder for 100?
Can't we just use B-B :)
Any reason not to use this at all?
Any reason not to use the much simpler default?
Any reason not to use style.debug()?
ditto :)
let's inline this one :)
ditto, line too long
We already have a private utility method somewhere, but we should make this method private.
We should make this method private since we are removing all "final" strings from the class.
We already have a private utility function to do this without modifications.
Shouldn't that be done in GlusterCommandBase?
Shouldn't that be UNKNOWN for GlusterStatus?
Shouldn't you use'returnList' here?
This may be OK in this circumstance, but there's a restriction on the implementation type. Is there any chance this restriction will be violated in this code as a surprise?
This may be OK in this circumstance, but there's a restriction on the implementation that doesn't implement getAdapterType. Just throw an IllegalArgumentException. Is there any chance this restriction will be violated in this code as a surprise?
style nit: we don't use braces around single line blocks
Suggest "false" if we're not using anything else, right?
Suggest "false" to be more descriptive in the message.
Suggest "false" if you don't have to use anything else, right?
buffer size 1, why?
can you mark this as final?
can you mark the response as final?
Please don't use final for local variables.
Please use try with resources here.
Please, use try with resources and avoid explicit close()
The AllCleanRule should do the work of lines 158..159, so you can skip this code.
The AllCleanRule should do the work of lines 158..159, so you don't really need to do this. @Test(expected =...)
The AllCleanRule should do the work of lines 158..159, so you don't need to do it here.
you could merge this to 1 line above
you could merge this if statement with the one above
You should be able to reverse this to use the previous if condition.
Minor thing: "referer!= null"
Minor thing: "referer!= empty"
Minor thing: "referer!= blank"
can this use increment util?
can this call be increment rather than increment?
can this call be increment util?
use new names?
use new names??
call?
Do we want to turn this on by default?
Do we want to turn this on by default in JSON?
Do we want to turn this up?
"http:// should be a constant or something.
I think you could make the path path configurable.
Space before +
Not sure why you don't use ctx.client.reloadIfRequired() here, like this: java if (replaceExisting) { //... }
Not sure why you don't use ctx.client.reloadIfRequired() here, like this: java if (replaceExisting) { // do this stuff }
Not sure why you don't use ctx.client.reloadIfRequired() here, like this: java if (replaceExisting) { //... } else { // do the logic }
please throw an exception instead of returning value
please throw an exception if editConsumer cannot be null
please review code formatting
does this test throw an exception?
does this test throw a NPE?
does this test have to be run?
Curious why we should have a separate DASH than preferIPv4Stack?
Curious why we should have a separate Handler for this as we are already having a HandlerController property for both threads, and I think having it here is possible.
Curious why we should have a separate Handler for this?
can we invert this if to avoid creating a delay in case the task fails?
can we invert this if to avoid creating a delay by checking kickedOff in the else if instead?
can the following scenario happen?
You can inline this variable: suggestion if (state.getSumC() == 0) {
You can inline this variable: suggestion state.getSumC() == 0) {
You can inline this directly.
This duplicates the previous one?
space after if
This duplicates the previous one.
This check fails on <LINK_0> (in the else case) java if (contentletIn == null) { return; }
this check is ok, because the contentletIn is Object and the if is null, please add a check here.
this check is ok, because the contentletIn is Object and the if is null, please add a check
nit: just simplify to throws Exception
nit: just simplify this to throws Exception
nit: just simplify streamInstanceOne and use throws Exception
Can be done in viewEntityDetailsById(..)
Can be done in viewEntityDetailsById().
Can be done in viewEntityDetailsById(..).
This should come from the DataWritable.
This should come from the DataSegmentInfo cache, and instead we may need to do some sort of randomization here.
This should come from the DataSegment TODO here, and also the next CF map lookup?
plz format all ifs into one line
It would probably be cleaner to have a common if statement after if, e.g. if (assignedUMI!= null) {... }
plz format this if only one if.
Why this get deleted? Your code depends on this function?
Why this get deleted? Your code depends on <LINK_0>
Why this get deleted? Your code depends on text being tested here.
ping
NewIndexDescriptor is almost the same as the other test, so maybe we can factor out a method?
NewIndexDescriptor is almost the same as the other test, so maybe we can factorize this code to a method?
typo. previous constructor?
Suggest removing the setter.
Suggest removing the line break.
@lmontrieux Despite the fact that I think that calling this method here is a bad idea. It's not a big deal, but I would prefer to just store a string here to avoid calling it twice. Instead, you can use the stringEscapeUtils code in the first place where you call it.
@lmontrieux Despite the fact that I think that calling this method here is a bad idea. It's not a big deal, but I would prefer to just store a string here to avoid calling it twice.
static import
this is not a good idea. I would be more comfortable if you simply return in this case and do something like java if (Tasks.get(task.getId())) { taskRunnerWorkItem = new RemoteTaskRunnerWorkItem( task, zkWorker, task.getId(), status); } else { taskRunnerWorkItem.getResult(); }
this is not needed since it is already done in addPendingTask()
this is not a good idea. I would be more comfortable if you simply return in this case and do something like java if (Tasks.get(task.getId())) { log.info("task[%s] that is already running but no worker is doing anything", task.getId()); }
Should invoke StarlarkData. xor(StarlarkInt) directly.
Should we check that the StarlarkData contains the StarlarkData?
Should invoke StarlarkData.
better to do this in the first place.
better to do this in the loop instead of using index
better to do this in the loop instead of using index loop
Seems like you can re-use the same code.
Seems like you can re-use the same code here if you don't have to.
Seems like you can re-use the same code here if you don't have to put the exception message.
Maybe this should be: final DWORD result = new DWORD(privileges.size()); to keep the code more readable.
Maybe this should be: final DWORD result = new DWORD(privileges.size()); final DWORD stats = new DWORD(FILE_GENERIC_READ);
Maybe this should be: final DWORD result = new DWORD(FILE_GENERIC_READ); mapping.setStatus(result.getValue());
Formatting
uee can be made final
uee
This is kinda a duplicate, as it can be misleading.
This is kinda a duplicate, as it can be misleading. We can see the timeout in the next line.
This is kinda a duplicate, as it can be misleading. We can see the timeout in the first place.
I think it would be more readable if you use Preconditions.checkNotNull(rs, "ResultSet should not be null when iterating");
I think it would be more readable if you use Preconditions.checkNotNull(rs, "ResultSet should not be null when iterating an iterable.");
I think it would be more readable if you use Preconditions.checkNotNull(rs, "ResultSet should not be null when iterating an Iterable.");
I suggest to call this method "availableSizeBytes"
I suggest to call this method "return"
I suggest to call this method "hides"
Looks correct to me. I think you can remove this check.
Looks correct to me. I think this check should be in an else clause.
Looks correct to me. I think this check should be moved to size > 2 if.
Is there any purpose to check for _debounceTimerMs instead of being false?
Is there any purpose to check for null, rather than accessing it on the client?
Is there any purpose to check if the owner is deadInstances?
Should the API be new WebTarget(secret). It's currently a test, but in a case like createSecretResponse() throws an exception, which would be nice to avoid a lot of code duplication.
Should the API be new WebTarget(secret). It's currently a test, but in a case like createSecretResponse() throws an exception, would be nice to have a test that fails with a status code.
Should the API be new WebTarget(secret). It's currently a test, but in a case like in the SecretCreateResponse class you can just add a constructor that takes a Continuation and converts it to a CompleteableResponse.
If this vector is constant, it would be a good idea to create only one instance of this file to create only one instance of this file.
If this vector is constant, it would be a good idea to create only one instance of this vector on class instantiation.
If this vector is constant, it would be a good idea to create only one instance of this file to create only one instance of this vector.
When we get here, we've hit the "poison pill", so there should be no other real intervals left. I'm assuming you used a for loop because you can't do Iterable.get(0)? You could use (Guava's) Iterables.getOnlyElement() though.
When we get here, we've hit the "poison pill", so there should be no other real intervals left. I'm assuming you used a for loop because you can't do Iterable.get(0)? You could use (Guava's) Iterables.getFirstRange() though.
When we get here, we've hit the "poison pill", so there should be no other real intervals left. I'd prefer to keep it as a for loop because this is complicated.
@bxf12315 Merging with SECOND_EVENT_ID?
@bxf12315 Merging with SECOND_EVENT_ID
@bxf12315 Merging with SECOND_EVENT_ID.
if we fail here we have a stale VM version in hand. we should roleback
if we fail here we have a stale data in hand. we should roleback
if we fail here we have a stale field, we should roleback
This is a bad idea with the hard length. How about making the method DIRECT_REPLY_ERROR as a constant with the int value?
This is a bad idea with the hard length. How about making the method DIRECT_REPLY_ERROR as a constant with a low length?
This method seems to be deprecated. I think it should be on a higher level.
@gkholla made a good point that we're not actually relying on the use of the try-with-resources style here.
@gkholla made a good point that we usually don't use static methods.
@gkholla made a good point that we're not actually relying on the use of the try-with-resources.
move to channel close()
move this up to the channel close() method
move this up
Can we get rid of this new ArrayList<>? Why not just new ArrayList<>(cachedPostMatch)?
Can we get rid of this new ArrayList<>?
Can we get rid of this new ArrayList<>?
Please replace this with : if (ps == null) { throw new ResourceNotFoundException("i.e.g. IOException"), e); }
Please replace this with : if (ps == null) { throw new ResourceNotFoundException("i.e.g. IOExceptions"); }
Please replace this with : if (ps == null) { throw new ResourceNotFoundException(id); }
Assertj has a fluent API. You have to do assert.
Assertj has a fluent API. You have to do assert. Also, please use AssertJ
Please use AssertJ
Can we use method.getModifiers() here since it's the same type?
Why are you calling this twice?
Can we use method.getModifiers() here since it's the same type.
nit: newline
nitpick: newline
nitpick: space
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is an unexpected error?
I think we shouldn't just catch and silently ignore. Would be nice if we could somehow alert that there is a malformed URL.
If you are returning an empty map when the key is null, you should return an empty one.
If you are returning an empty map when the key is null, you should return Collections.emptyMap().
If you are returning an empty map when the key is null, you should return an empty map.
It might be better to write a mock here. It will work the creation of the mock, and not only when the exception occurs.
It might be better to write a mock here. It will work the creation of the mock, and not only the creation of the mock.
It might be better to write a mock here. It will check the return value and not only if the exception occurs.
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ) <review, layout
Ye, but it causes a PMD warning.. ;) <review, layout
Can we simplify the code and use the same constants constants for both of these?
Can we simplify the if statement?
Can we simplify the code and use the same constants constants for both of these conditions?
Can you break this long line?
Can you break; out of the switch?
Can you break; after this line?
Needs to be unboxed
Needs to be unboxed.
Needs to be more explicit.
Please remove this retry variable.
Please remove this retry
Please remove this retry parameter.
Consider making this a constant.
Consider changing to a constant
Consider making this a constant?
I think this should be in an else clause.
I think that this should be in an else clause.
I think that this should be inside the try/catch block
This needs to be changed
This needs to be changed for a whole migration
This needs to be changed for every ldi ldi
why not to use file.getCanonicalPath()
why not private?
why not private method isMatchFolder
Minor: can we use getOrDefault(Config.TOPOLOGY_TASKS, 0);?
Overall. This is a good option.
Overall the method name looks a bit weird here.
Check args?
No need to store the VolatilitySurface.
No need to assign.
Maybe we could grab the SshTool object and if its already available, and if the SshTool object can be null?
Maybe we could grab the SshTool object and if its already available, and if the stats are available, we don't need to ask for this algorithm anymore
Maybe we could grab the SshTool object and if its already available, and if the SshTool object can be used.
suggestion final MessageDTO messageDTO = new MessageDTO("1", "1", "Title", "Test Body");
suggestion String messageDTO = new MessageDTO("1", "1", "Title", "Test Body");
suggestion Source<JsonNode,?> in = new MessageDTO();
Could this be merged with my logic below?
Could this be merged with my approach above?
Could this be merged with my logic from cancelPollTask?
@mackaypeter When using Log, why not just let the exception be thrown?
@maria-farooq we should not be catching this exception.
The exception is not thrown.
Missed it for the change, but there's another way to make this an warn, or an error.
Missed it for the change, but there's another way to do this.
Missed it for the change, but there's another way to do this - read-only, create the handler for the thing?
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further logic since no further information is provided (e.g. type or format).
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further information is provided (e.g. type or format).
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further logic since no further information is provided (e.g. type or type).
nit: can we also assert the issuccessful flag explicitly so that the last node you are testing is the last node you want to verify?
nit: can we also assert the issuccessful flag explicitly so that the last node you are testing is the last node you want to verify? (So it is probably not late in the other tests)
nit: can we also assert the issuccessful flag explicitly so that the next two lines are the same?
pls change to: for (int i = 0; i < stackFrame.length; ++i) {
pls change to i++
why changing this?
Typo: jpaQuery.getLimit()
Typo.
Typo. But I guess it doesn't matter.
Maybe a test for Lalls of the cases for logging instead of logging _out-of-the-box in the codebase :)
Maybe a test for Lalls of the cases for logging instead of logging _value_.
Maybe a test for Lalls of the callbacks of the fixed action needed.
I think we can use TestUtils.assertResult
I think we can use TestUtils.assertEqual()
It would be good to test with less than one element.
nit: throw new PrestoException(NOT_SUPPORTED, "map key cannot be indeterminate: " + e);
nit: throw new PrestoException(NOT_SUPPORTED, "map key cannot be indeterminate: " + error);
ditto about: throw e;
Is this still required?
Is this correct?
Is it okay to remove the group?
How about adding a new code to the existing "setNull" and argNull = args.length > 1 && args[1] == null;
How about adding a call to java.util.Arrays.copyOfRange()?
How about adding a new code to the existing "setNull" and "setNull"?
why do we need to check for nullity of operand?
why do we need to copy this set?
nit: this is not needed because of the check below
I'd say rename it to "item" instead of "item", as it's a collection.
After that it's a matter of personal preference, I'd find it more readable to break the loop directly into the "if (button.hasClass("button")) { return button.hasClass("primary") }
I'd say rename it to element
I would suggest to change these to if (authType == null || authType.equals("auth_type_email")) here.
I would prefer to leave the switch as it is for NPEs.
I would prefer to leave the switch as it was for NPEs.
Could be replaced by.map(this::replaceSubRelation)
Could be replaced with getOrDefault()
Could be replaced by _this::replaceSubRelation_
what is the purpose of the renaming to includeTextDetails?
boolean includeTextDetails = true; and outputViewer.getTextText();
Add a log message here?
nit: this seems like it's already done in the ParquetInputFormat. No need to break the loop
nit: this seems like it's already handled by the exception type
nit: this seems like it's already done in the ParquetInputFormat. No need to break the loop here
We should not be hard code path to path to a file. We should be doing the same for all files.
We should not be hard code path to path to a file. We should be doing something like (".
Make a constant
seems like you are no longer necessary to change this method?
seems like you are no longer necessary to change this to determine the maximum length in next method
seems like all these extract to a method
Do not return null;.
Do not return null; also, add the username and password out of the message.
Do not return null; also, add the text of the account?
Not sure about this. Arrays.equals()?
Not sure about this. Arrays.equals()
What about deepEquals?
The logic should be inside Converters.convert(String, Object) since it will be much more readable and more readable.
The logic should be inside Converters.convert(String, Object) since it will return a list if the item is not a float.
The logic should be inside Converters.convert(String, Object)
Why are you adding the comma separated URL to the URL? Shouldn't that be the same as the other ones? (no strong feelings)
Why are you adding the comma separated URL to the URL? Shouldn't that be the same as the other ones? (no strong opinions)
Why are you adding the comma separated URL to the URL? Shouldn't that be an option? (no strong opinion)
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
We shouldn't need separate method for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into a different method (like createPool).
Could you please log the transaction ID here, instead of the entire transaction?
Could you please log the transaction id here, instead of the entire transaction?
Could you please log the transaction ID here, instead of the entire transaction ID?
I think this should be logger.log instead of println
I think this should be WARN
I think this is a bit too abstract, would be useful
@danielezonca I don't understand this.
"DefaultSegmentedDataContainer"
@nvazquez this condition is not needed
dp.resetValue(Double.NaN);
'resetValue(Double.NaN);' is enough
'resetValue(Double.NaN);' is better
Same here with not needing the local variable.
Same here with not needing the local variable. Same for below.
Same here with not needing the variable.
invert
invert this
invert the if
Would we be able to find a set for conditionalStreamListenerHandlerMethod.size() instead ofconditionalStreamListenerHandlerMethod.size()?
Would we be able to find a set for conditionalStreamListenerHandlerMethod?
Would we be able to find a set for conditionalStreamListenerHandlerMethod.size() instead ofconditionalStreamListenerHandlerMethod.size()?
Please change message to "Error while parsing properties file" instead of "Error while parsing properties file"
We can print the stack trace here as well.
We should not log and throw. Exception is too specific.
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list font assets from %s" so it's less ambiguous, it's not really failing to load fonts if you get me!
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list font assets at font path" so it's less ambiguous, it's not really failing to load fonts if you get me!
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list font assets to empty" so it's less ambiguous, it's not really failing to load fonts if you get me!
Nitpick: might be better to use constants for these.
Nitpick: might be better to use constants for these?
Optional: might be better to use constants for these.
This seems unnecessary. What advantage is there here versus before? Both guarantee the order is respected.
This seems unnecessary. What advantage is there here versus after? Both guarantee the order is respected.
This seems unnecessary. What advantage is there here versus before? Both guarantee the order is respected. Or if the order is respected, we can't wait for the next event to come up.
Wouldn't it be better to detect the lastConsumedOffset < endOffsets?
Wouldn't it be better to ignore the lastConsumedOffset here?
Wouldn't it be better to detect the lastConsumedOffset < endOffsets.size()?
Move it down. We don't need to check for null if it's not an IContainer.
Move this line down. We don't need to instantiate a new object if it is not an IContainer.
Move it into the if block.
We should update the message slightly here. Maybe something like "This code should never be reached."
We should update the message slightly here. Maybe something like "The fault zone data data is not supported for quick-up tasks"
We should update the message slightly here. Maybe something like "This code should never be reached. It is very confusing that we read it from the user.
We can drop this System.out.println()
This System.out.println can be removed.
This System.out.println should be removed.
is it easier to read the code behind [completionFilter.matches](<LINK_0>
is it easier to use constant instead of using magic numbers?
is it able to ignore this one?
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-local. Also please annotate @VisibleForTesting
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-private. Also please annotate @VisibleForTesting
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-private (and the name).
What about using a boolean as the first check?
Where is the logic for determining if we have one?
What about using a boolean here?
As I understand the intention, if we throw an exception, we can't continue to catch it. As I understand the intention, if the partition is corrupted, we should fail loudly and not throw it.
As I understand the intention, if we catch Throwable the same exception is thrown, we know that the catch block is a dead code path. In that case, the Throwable will be re-thrown as a cause and then catch-chain is dead code.
As I understand the intention, if we catch Throwable the same exception is thrown, we know that the catch block is a dead code path. In that case, the Throwable will be re-thrown as a cause and then catch-chain is visible. This can be fixed by adding a new error message to the log.
PartOfDay.getCorrespondingConstant(location.get(point).getLocationId()) is more readable than getCorrespondingConstant(location.get(point).getSingular()
PartOfDay.getCorrespondingConstant(location.get(point).getLocationId()) is more readable than getCorrespondingConstant(location.get(point).getSingular())
Same as above, try to simplify this by adding a method to PartOfDay.
This can be handled by waitForRunningTaskToComplete accepting a callback function to have the following code.
This can be handled by waitForRunningState(runnable);
This can contain the following code.
Should we check that the branch state is nil if the branch state is not null?
Should we check if the branch state is nil or not?
Should we check if the branch state is in the "IN_PROGRESS" state?
Missing "assertEquals"
Missing "!"
Missing "assertEquals".
- please, move this check to consolidated into a single method and make it readable
- please, move this check to a consolidate method and make it readable
- please should be using parameterised logging here
Are you mapping this string to a constant? Isn't it a better name for a service?
Are you mapping this string to a constant? Isn't it a better idea for a VM or something?
Are you sure this StrictMode.set notifications were added? In that case, maybe we could just set the currentAppId to a variable?
Don't call getConfig() twice.
Don't call ConfigConfig.getDomain()
Don't call ConfigConfig()
val is better here.
val can be converted into val.
val can be converted into ArrayList<MultipartUpload>.
This seems really weird. What do you think about asserting the error message here?
assertSame?
assertSame
java if (Build.VERSION.SDK_INT >= 18) {
java switch (id) { case DIALOG_SHORT_WAIT: // default to "true" }
java switch (id) { //... }
Can we return the challengeFuture, if there was an error caused by request.
Can we return the challengeFuture, if there was an error caused by calling this method?
Can we return void
It doesn't need to be necessary. Just call the method directly.
It doesn't need to be necessary. Just set the text of the job in the BuildThread object.
It doesn't need to be necessary. Just set the field directly.
This should be called before super.onBind() in case of 'AbstractErrataListModel'.
This should be called before super.onBind() in case of 'AbstractErratum' it's a widget.
This should be called before super.onBind() in case of 'AbstractErratum', as it is a 'parent' case.
Shouldn't this be an int?
Shouldn't this variable be initialised to 0?
Shouldn't this be applied to the set?
Worth adding the FIXME here to check that it is not the right cause.
assertFalse(afterPixel, beforePixel);
Worth adding the FIXME here to check that it was not the right cause.
Should we also log to prevent double log statements?
Should we also log to log if we're failing?
Should we also log to prevent double log files?
Just stuff all this logic in "selectMarketingInsightToGenerate" so you have no if statement. Then the case statement just has return pickRandomInsightCategory(marketingInsightPool, marketingSeenCategories, random);
Just stuff all this logic in " selectMarketingInsightToGenerate" so you have no if statement. Then the case statement just has return pickRandomInsightCategory(marketingInsightPool, marketingSeenCategories, random);
Just stuff all this logic in "selectMarketingInsightToGenerate" so you have no if statement
What do you think about making this method private?
What do you think about making this method final?
What if the save state is false?
Hasn't the code under 'else' block be removed?
Hasn't the code under 'else' condition already checked on line 145?
Hasn't the code under equals (as else) also possible?
Second parameter of Status is the pluginId. Why to pass path here?
Second parameter of Status is the pluginId. Why to pass path here? What happens if path is null?
Second parameter of Status is the pluginId. Why to pass path?
I think it is better to have PAResourceManagerProperties.RM_TOPOLOGY_DISTANCE_ENABLED.getValueAsBoolean() as it is clearer and what is the meaning of the property. Same for the PAResourceManagerProperties.RM_TOPOLOGY_TOPOLOGY_DISTANCE_ENABLED.getValueAsBoolean().
I think it is better to have PAResourceManagerProperties.RM_TOPOLOGY_DISTANCE_ENABLED.getValueAsBoolean() as it is clearer and what is the meaning of the element in PAResourceManagerProperties.RM_TOPOLOGY_TOPOLOGY_DISTANCE_ENABLED.getValueAsBoolean()
I think it is better to have PAResourceManagerProperties.RM_TOPOLOGY_DISTANCE_ENABLED.getValueAsBoolean() as it is clearer and what is the meaning of the method. Same for the PAResourceManagerProperties.RM_TOPOLOGY_TOPOLOGY_DISTANCE_ENABLED.getValueAsBoolean().
why do we need to change the order of the parameters? can we extract to a method?
why do we need this change?
why do we need to change the order of the images?
Maybe refactor this whole block to be a private method?
Maybe refactor this block to be a private method?
Maybe refactor this whole block into a method?
Because there's only one param here, you can use getOrDefault()
Because there's only one column in the schema, you can use SchemaBuilder here.
use isEmpty()
The check should always fail if the order is not null because it will fail with an NPE
The check should always fail if the order is not null because it's not set
The check should always fail if the order is not null because it will fail with an NPE.
May we detail the logger message a lit like > error in cache flow trigger <PojrectName_FlowName> in Quartz,
May we detail the logger message a lit like > error in project <PojrectName_FlowName> in Quartz,
May we detail the logger message a lit like > error in cache manager has some kind of error code?
This is the only place where the reference is of the identifier. I tend to think that we could better remove it and use the symbol name.
This is the only place where the reference is of the identifier. I tend to think that we could better remove this
This is the only place where the reference is of the identifier. I tend to think that we could better remove it and use the symbol index only once.
Why is setoomRatioInternal() being called from setoomRatioInternal()?
Why is this check inside setoomRatioInternal()?
Why is this check inside setoomRatioInternal function?
this is a little hard to read
These can be extracted to a utility method.
this is a closed file
Can we move this logic to the constructor?
Can we simplify this?
Can we simplify this logic?
> Can you use try-with-resources to ensure this is properly closed?
> Can you use try-with-resources?
spelling error.
:ant: Deserves a functional test.
:ant: Deserved a functional test.
:ant: Deserves a functional change.
I don't think we should be using this.enabledHeaderIdsBySection. We should crash if we're not showing something like Solved or Solved.
I don't think we should be using this.enabledHeaderIdsBySection. We should crash if we've present something like Solved or Solved.
I don't think we should be using this.enabledHeaderIdsBySection. We should crash if we've present something like Solved or Solvedd.
would this still full fill the smooth transition path without checking the predicate?
would this Iterable be better here?
would this still full fill the smooth transition?
Remove System.out.println
Remove System.out.println?
Remove System.out.println and use logger.debug
You can put auto-start = System.currentTimeMillis() before.
You can put auto-start = System.currentTimeMillis() here.
You can put auto-start = System.currentTimeMillis() before the split.
Please move this to a warn as well.
Please move this code to a different method, since it should not be invoked for all agents.
Please move this code to a different method, since it should not be localized.
I'd choose to check for an empty list first here.
I'd choose to check for unknown_CONFIG.id here.
I'd choose to check for unknown_CONFIG.id here too.
why not check for null?
why not check for CDT == null?
why not check for CDT?
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base will be left empty.
Is there a possibility that jetty.home is isn't empty, but jetty.base is? In that case, jetty.base will be left empty.
Is there a possibility that jetty.home is empty, but jetty.base is? In that case, jetty.base will be left empty.
Hardcode the URL to "message" is missing in this case.
Status exception?
Great!
This will add the org.eclipse.egit.ui.internal.actions.RepositoryManager.registerMappingDiscoveryRequest(IStatus, String) constructor and should be added to the constructor.
This will add the org.eclipse.egit.ui.internal.actions.RefreshedListener ;) Wouldn't it be better to have another method like getIDOrFinishListener and get the Head?
This will add the org.eclipse.egit.ui.internal.actions.RefreshedListener ;) Wouldn't it be better to have another method like getIDOrCopyEventListener and have it call the openProposals method?
Maybe we could make the strings a constant?
Maybe we could make the strings a static final and store it in the.properties file
Maybe we could make the strings a static final and store it in the.properties file?
using ConcurrentUtils.withLock()
use ConcurrentUtils.withLock()
using ConcurrentUtils.withLock()?
@rohitsoni77 suggestion if (_metrics.isEmpty()) {
@rohitsoni77 suggestion if (_metrics.size() == sizeJVMMetrics){
@rohitsoni77 suggestion if (_metrics.size()!= sizeJVMMetrics) {
You can use a foreach loop of the query instead of the full for loop of the loop
You can use a foreach loop of the entire for loop of the loop
You can use a foreach loop of the entire for loop of the loop.
This block is a bit convoluted. Do you think it would be better to move it inside the if block?
This block should be in a separate method.
This is a bit confusing. It's hard to follow the logic.
swap the 7] as a variable
We can use final here.
We don't like this code.
The key should be renamed to something like "data"?
The key should be renamed to something more meaningful.
The key should be renamed to something like "data" to make it clearer what it is.
This error message should be changed to "The export for versionCode."
What's with the the problem in the error message?
What's with the magic numbers.
Can we change this to something like: java future.channel.closeFuture(); if (future!= null && future.channel.isOpen()) { future.channel.closeFuture(); }
Can we change this to something like: java future.channel.closeFuture(); if (future!= null && future.channel.isOpen()) { future.channel.closeFuture(); } The same applies to the other handlers as well.
Can we change this to something like: java if (future!= null && future.channel().isOpen()) { future.channel.closeFuture(); } The same applies to the other handlers as well.
I think we should _not_ do this here. (for a reason, we can't use jvb.sendPresenceExtension internally)
I think we should _not_ do this here. (for a reason, we can't use jvb.sendPresenceExtension internally) This can make logic simpler.
I think we should _not_ do this here.
Reduce the complexity of this on the warning and simply return.
you can simply say "return" here.
you can simply say "return" here
I think the following is more readable. if (p!= null) { if (p == null) { throw new IllegalStateException(); } else { if (p!= null) { m.close(); } }
I think this line is unnecessary, because the completionFuture.complete(null) future.fail() will complete the future.
I think this line is unnecessary, because the completionFuture.complete(null) will complete the future.
we tend to like initialization like this: final boolean left = false; if (cond) { left = true; } else { right = false; } This make very clear when a is set to null;
we tend to like initialization like this: final boolean left = null; if (cond) { left = null; } else { right = false; } This make very clear when a is set to null;
we tend to like initialization like this: final boolean left = false; if (cond) { left = false; } else { right = true; } This make very clear when a is set to null;
This is more efficiently stored as: java if (bean instanceof AbstractBuiltInBean<?>) {... }
This is more efficiently stored as: java if (bean instanceof Transformation<Bean<?>>) {
This is more efficiently stored as: java if (bean == null) {
Shall keep this declaration declaration after the if?
Shall keep this declaration after the if?
Shall keep this declaration declaration as it is before the if
may be a good idea to be careful with this (I mean, it canEditToNewPackType (foo canEdit)
may be a good idea to be careful with this (I mean, it canEditToNewPackType can be called after the constructor is called)
may be a good idea to be careful with this (I mean, it canEditToNewPackType can be called after the block must be transaction with the active status and that can be OPEN)
same question about this change
rather than move this to the previous line.
same question about this
See above about title, description, and active parameters.
See above about title, description, and date parameters.
See above about title, description, Boolean active, and date parameters.
Ah, yes, there's a default case - why did we set it explicitly?
Ah, yes, I understand why this is used? It is only available for numReplicas and the first partition.
Ah, yes, I understand why this is used? It is only available for numReplicas and partition size.
For null values, we just do not supply those properties in the autoGenerationOption
How sure are you that these values were null, even before the rest call?
How sure are you that these values are not null, even before the rest call?
Also include the values here?
Also include the values here
We don't need this?
Wrap in try-catch to allow the error flow to be visible in the future.
Wrap in try-catch to allow the error flow to be visible for the user.
Wrap in try-catch to allow the error flow to be visible for the server.
I think all Job cleanup should be done in cleanUp()
I think all Job cleanup should be outside of the try...
I think all of this should be moved up into the ACL.impersonate(ACL.SYSTEM).
I think it is better to put the logging of the exception inside of the function, instead of logging "Error".
I think it is better to put the logging of the function inside of the lambda.
I think it is better to put the logging of the exception inside of the Runnable.
workerMetrics.getTable(inputTableId) can be final.
workerMetrics.getTable(inputTableId) can return null if there is no partition assigned.
workerMetrics.getTable(inputTableId).getPartitionInfo().size() + 1, condition can be used here to avoid the switch.
this "else" is redundant. If a node is not found, the log will be logged.
this "else" is redundant. If a node is already logged, the message will be logged.
this should be the last thing after the error log
What does this test actually buys us anything?
What have a blank line after the assertTrue?
What does this usually test?
I think this should be state() == State.CLOSED, since we don't want to resume processing. The new queue size is > maxBufferedSize.
I think this should be state() == State.CLOSED and not State.STARTED
I think this should be state() == State.CLOSED, since we don't want to resume processing of the records.
i think this should be moved to some util class?
These last cell types need to be extracted to some util class?
i think this should be moved to the inner class?
Probably better to name the variable "error".
Probably better to name the cookie in _http_
Probably better to name the cookie in _http_?
Should also handle the case where currentBatch.size() <= deleteBatchSize).
Should also handle the case where currentBatch.size() < deleteBatchSize).
Should also handle the case where currentBatch.size() <= maxBatch.size().
suggestion final MockHttpServletRequest request = new NoOpFilterChain();
suggestion final MockHttpServletRequest request = new UnmodifiableList<>();
suggestion final MockHttpServletRequest request = new Context() { @Override public void unsupportedPrefix() throws Exception {
The same like in the getResourcesManagerBl() method above. We should have parameter check for admins.
The same like in the getResourcesManagerBl() method above.
The same about PERUNADMIN check.
Cast to double[] to avoid compilation errors.
Cast to double[] to double[]
Can be removed, it seems fine.
Should this be caught/unwrapped?
Should this be warn?
Should this be caught and ignored?
missing null check?
missing null check & use isEmpty()
missing null check
You could probably move this line along with the if (redefinedAttribute!= null) check since we want to do an if-else if the root is valid.
You could probably move this line along with the if (redefinedAttribute) statement above to make it clear that this is the root of the enclosing element.
You could probably move this line along with the if (redefinedAttribute!= null) check since we want to do an if-statement instead of if-return.
Would it be better to pass in the channel as a parameter to the constructor?
Would it be better to pass in the channel as a parameter?
Not needed?
what if codenvyDir == null?
what if codenvyDir == null?
why this kind of exception is thrown?
Just make this an int and use getOrDefault? int physicalSlotId = slotMapping.getOrDefault(mSlotId, -1); if (physicalSlotId!= -1) { // for loop }
Could this be int physicalSlotId = slotMapping.getOrDefault(mSlotId, -1); if (physicalSlotId!= -1) { // for loop }
Just make this an int and use getOrDefault? int physicalSlotId = slotMapping.getOrDefault(mSlotId, -1); if (physicalSlotId == -1) { // for loop }
.collect(Collectors.toList())
I think this should be: java public static ModeInfo findMode(String mime, String path) {
.collect(Collectors.toMap(ModeInfo::get, Function.identity()));
If there is a location, should we just pass through the location info or the page object?
If there is a location, should we just use location?
If there is a location, should we just pass through the location info or the page type?
I'm a bit confused by this line.. why is it called from here?
I'm a bit confused by this line.. why is this private?
move this to done in the constructor
category
category names should be included in the name
category names should be declared as final
shouldn't need the throws declaration?
shouldn't need to throws declaration?
shouldn't need the throws statement
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway? Or am I missing something?
I don't think these checks are required - the NullPointerException will be thrown down the call stack anyway?
It seems that AuthenticationTokenProvider.getToken("admin") should be used instead of accessing the AuthenticationTokenProvider.
It seems that AuthenticationTokenProvider.getToken("admin") is redundant here.
I believe this delay should be performed only once.
This probably should be called from the widget itself, not here.
This should be called from the widget itself, not here.
This probably should be called from the widget itself, not from the widget.
Can we not use ArrayList<> here?
Can we not use ArrayList<>?
Can we not use ArrayList<> here?
Should be externalized.
"null!= manager"
trace
I don't think we want to retry here. Can you elaborate on the logic here?
is 500 seconds a retry strategy?
is 500 seconds not enough?
We could rename getClass() to something like "processorName" or something similar.
We can avoid this line altogether and use Mockito.times(1) here.
We could rename getClass() to something like "processorName" or something similar
shouldn't this be assertThat(results[0].listCells())?
shouldn't this be assertThat?
If it's not correct, this is run only once.
If value.getSum() returns an int, this check will be redundant.
If value.getSum() returns an int, this check should be removed.
I think this should be private.
I think you are starting to use.m(s) for this.
I think you are starting to use.m(s) for this. The method should be named after the word "yum install -yum.repos.d/".
I think you are starting to use.m(s) for this, as it might work.
Wrap in try-with-resources
Wrap in try-with-resources.
isDirectory()
In this case I don't think it matters, but I think in general as we write new tests with operations we shouldn't use the constants. It's mainly a regression check to ensure the operation names don't change in the state.......though I should probably bring this up on wildfly-dev and not this PR :)
In this case I don't think it matters, but I think in general as we write new tests with operations we shouldn't use the constants. It's mainly a regression check to ensure the operation names don't change in the constant value.......though I should probably bring this up on wildfly-dev and not this PR
In this case I don't think it matters, but I think in general as we write new tests with operations we shouldn't use the constants. It's mainly a regression check to ensure the operation names don't change in the state.......though I should probably bring this up on wildfly-dev and not this PR
suggestion log.error("Error while parsing dynamic config at location {}", e.getMessage());
suggestion log.error("Unable while parsing dynamic config at location " + localFilePath);
suggestion log.error("Unable while parsing dynamic config at location {}", localFilePath);
The name of this function is not set as a member of the parent class.
The name of this function is not correct.
The name of this function is not set as a member of the class.
I would prefer to make an assertion here that the specific sql is expected. This way, the code is too complicated, and the error message will make sure that all the other tests do the same.
I would prefer to make an assertion here that the specific sql is expected. This way, the code is too complicated, and the error message will make sure that the test does not get executed.
I would prefer to make an assertion here that the specific sql is expected. This way, the code is too complicated, and the error message will make sure that the test does not apply to the other arguments.
It is fine to throw a note here, but if you don't have a note, you can use e.getMessage() instead.
It is fine to throw a ForbiddenException here because you don't need to catch it.
It is not clear which is the exception message here. Add a note to the log.
Isn't it a RuntimeException?
Isn't it a warn level message?
This is a  hack to remove.
This should be done using a UIPlugin
This should be done using a UIPlugin (following and not scoped)
shall not exception at all
Let's use BooleanUtils.parseLocale(context) here.
Let's use BooleanUtils.parseLocale(x) here.
Shouldn't it be ((MetadataType) oc)?
The semi-colon is unnecessary. :)
This is not re-entrant.
This is not in Java 8, so you can call path.isEmpty()
This returns a body of the method so it can be all replaced with addRow().
This returns a body of the method so it can be all replaced with addRows().
This returns a body that doesn't match the query parameters.
vector.info -> actual?
vector.info -> expected
vector.info -> application constants
Wondering if we can use the conversionTemplate.replace(String.format("{{%s}:", key.getOriginalKey()) here too?
Wondering if we can use the conversionTemplate.replace(String.format("{{%s}:", key.getOriginalKey()), stringValue ) here?
Wondering if we can use the conversionTemplate.replace(String.format("{{%s}:", key.getOriginalKey()) here instead of String.format.
The contexts is only relevant to this component, right? If the application has already gotten the maps, we should call super.process(event) here.
The contexts is only relevant to this component, right? If the application has already gotten the maps, we should call super.process(event).
The contexts is only relevant to the pipeline, true or false. Should we add a check?
is it worth to log the role key?
is it worth to add a log here?
make it final
This should be a GerritView instead of a hardcoded string.
There is a potential bug here. Once the fragment is destroyed, this ends up with a NullPointerException.
There is a potential bug here. Once the fragment is destroyed, this will be a lot of this. Therefore this should be protected.
nit: missing space after =
nit: missing space after keywords
nit: missing newline
After the test, the CI system will be running in a different thread and the test is shut down. It would be better to do it as a loop in @AfterClass and stop() the thread.
After the test, the CI system will be running in a different thread and the test is shut down. It would be best to do this as part of the @AfterClass and stop() it before the test execution.
After all, the test has deleted the test already. So, it is not necessary to worry about that.
The formatting is off here.
The idea here is "Incompatible schema between master" and "securityprovider" is on the separate stylistic field. Could you please move this into a separate PR?
The idea here is "Incompatible schema between master" and "securityprovider" is on the separate stylistic field. Could you please move the strings to private static final variables and use it here?
set a flag here saying : atleastoneunsetevent
set a flag here saying : atleastoneunsetion
typo
Please use KPaths.makePath(SERVICES_FORMAT, entry.getKey()) instead of KPaths.makePath(servicePath, upstream).
Please use KPaths.makePath(SERVICES_FORMAT, entry.getKey()) instead of File.separator
Please use KPathUtils.makePath(SERVICES_FORMAT, entry.getKey()) instead of File.separator
Sorry for the back and forth, this should probably include an assertion that the first result is a List<String>.
Sorry for the back and forth, this should probably include an assertion that the first result is a list of List<String>
Sorry, @somandalbosco Why not just throw IllegalStateException?
Line is longer than 120 characters (here and below)
Will it be possible to replace.toString with String.format?
Line is longer than 120 characters.
any specific reason we have to use FormulaClassName here?
any specific reason we have a separate function for this? I would think it would be a nicer fit for this function
any specific reason we have to use FormulaClassName?
no need for this change now
no need for the cast here
no need for fully qualified class name
Does this need to be public?
Looks like this is wrong.
Same here.
going to be incorrect here, too, if a user passes in a site that is not a valid image the user will get a NPE.
going to be incorrect here, too, if a request comes from a site it does not work with the blacklisted screen.
going to be incorrect here, too, if a user passes in a site that is not a valid image the user will get a READ request
please have a test with if (Objects.isNull(includedElement.getLink().getUri())
please have a test with if (Objects.requireNonNull(includedElement.getLink().getUri())
We should log a WARN
Why thread.currentThread().getClass() instead of NioThread.class?
Why thread.currentThread().getClass()?
Why thread.currentThread().getClass() instead of NioThread.class?
Why have you started to use taskScheduler? ImapIdleExceptionEvent.....
Why have you started to use taskScheduler? ImapIdleExceptionEvent..
Why have you started to use taskScheduler?
add whitespace to coalesces on same line
add whitespace to coalesces on same line.
add whitespace to coalesces
Can't we just use n.size() > 0 instead of n.get(0)?
Can't we just use n.size() > 0 || n.get(0) instanceof ImportDeclaration?
Can't we use n.isEmpty(n)?
Does it have to be the same then the same string?
Does it have to be the same then the same log?
Does it have to be the same log?
I am sure that this first part is an exact copy, but as you mentioned below, it would be nice to use equals.
I am sure that this first part is an exact copy, but as you mentioned below, it would be nice to use equals() to compare array length only.
I am sure that this first part is an exact copy, but as you mentioned below, it would be great to use equals.
please reduce to debug or trace level. like Discovery package sent!"
please reduce to debug or trace level.
please reduce to debug or trace level. like Discovery package sent!" instead of "Discovers"
Can we do this more simply by adding a new method to BoundedRestoreSnapshot.java?
Can we do this more simply by adding a new function to BoundedRestoreSnapshot.java?
Could we somehow add the table name as the column name?
Can we please mock the Future?
Could we please mock the Future?
Can we use Future?
I'm not sure how we should handle this; I was thinking about the fact that we use the constructor of the DefaultTraversableResolver (which probably makes sense). But, I'd like to understand the idea of the code here.
I'm not sure how we should handle this; I was thinking about the fact that we use the constructor of the DefaultTraversableResolver (which probably would be better as a separate constructor). I'm not quite sure how we should handle it.
I'm not sure how we should expose this method. I was not quite sure about the constructor of the string...
We're no longer using the IncrementalIdGenerator strings. No need to use its own strings.
We're no longer using the IncrementalIdGenerator strings. No need to use its own strings, please remove it.
We're no longer using the IncrementalIdGenerator strings. No need to use its string names.
Please remove the ;.
Please remove extra semicolon.
Please remove extra ;.
Does this English ever change? If it's not, it'd be good to use the word "look for MPI site"?
Does this English ever change? If it's not, it'd be good to use the "active" User-Id.
Does this English ever change? Does it ever change?
suggestion while (length > 0) {
Do we need to add a check for null here?
Do we need to add a check for bufferWithContext.isWritable() here?
Curious why you needed to set the volatile flag?
Curious why you needed to set the volatile flag.
Curious why you needed to set the volatile flag for all the other methods.
Setting the style isn't needed for this component as this is the default already.
Setting the context isn't needed for this component as this is the default already.
Setting the style isnt needed for this component as this is the default already.
minor: can you put the "{" up a line?
Can you combine the above three lines into a single line?
minor: can you put the "{" up a line
You should also lazily check the exclusion and group names when exclusion is not provided by the provider.
You should also lazily check the exclusion and list in the constructor.
You should also lazily check the exclusion and group names when exclusion is not provided, as it will slightly improve performance.
Use of this.getClass().getName
Use of this.getClass().getSimpleName()
Use of this.getClass().getSimpleName
> if (networkExtras!= null) { AdColonyAppOptions options = appOptions; } else if (appOptions == null) { options = appOptions; }
> if (networkExtras!= null) {
> 0 if adRequest is null
Also verify that the response comes back.
Please write an assertion, which makes the tests more readable.
Please write an assertion, which makes the assertion more readable.
Shouldn't you create a method in the RuleSetFactory#wrapExternalEntry()? I don't think it's a good idea.
Shouldn't you create a method in the RuleSetFactory#wrapExternalEntry()?
Could you create a method for this? I don't think it would be clearer.
It might be better to use addMember(memberName, value) to ensure that the member is an instance of a Enum and we don't support for other types.
It might be better to use addMember(memberName, value) to check for the Enum in a comma.
It might be better to use addMember(memberName, value) to ensure that the member is an instance of a Enum and we don't support for the Enum implementation.
Remove this.
Flag.split() uses regex which isn't needed.
remove unnecessary this.
For all of the user types, parsed.getUserType() should be null.
For me, it's better to use String.valueOf to.
For me, it's better to use StringUtils.isEmpty()
Can you make these 5Log.w 3 a constant like PAGE_LOAD_TIMEOUT?
Can you make these 5 Log.w(TAG, "AuthenticationActivity was not closed")
Can you make these 5 Log.w(ERROR, "AuthenticationActivity was not closed", e.g. via constructor?
null check?
null check/isNull
null check/empty
instead of a magic number, can you rename the variable to failureFuture?
instead of a magic number, can you rename the currentContext as well?
instead of a magic number
This method should be used to construct the list, not to it.
This could be just  redeployAllToTarget.
This method should be used for  redeployAll.
As a reply to your TODO in line #126- Seems that your code ("moveMacsFromOldMacPoolToNewOne();") should be moved to line 92. And should be in the same transaction with "getStoragePoolDao().updatePartial(getStoragePool());"
As a reply to your TODO in line #126- Seems that your code ("moveMacsFromOldMacPoolToNewOne();") should be moved to line 92. And should be in the same transaction with "getStoragePoolDao().updatePartial(getStoragePool());" (line 304)
As a reply to your TODO in line #126- Seems that your code ("moveMacsFromOldMacPoolToNewOne();") should be moved to line 92?
Can use slf4j instead of string concatenation here
Code style: remove the space before the &&
Code style
0 is the default value for an int field; do we need that here?
0 is the default value for an int field; do we need to do this here?
0 is the default value for an int field; do we need to do this?
Did you mean to keep this magic number?
Did you mean to keep this PR?
Did you mean to keep this?
Why is this method protected?
Why is this protected?
Why is this method public?
return platformLoginAPI.login(System.getProperty("org.bonitasoft.platform.username", System.getProperty("org.bonitasoft.platform.password"));
return PlatformAPI.login(System.getProperty("org.bonitasoft.platform.username", System.getProperty("org.bonitasoft.platform.password"));
return platformLoginAPI.login(System.getProperty("org.bonitasoft.platform.username"), System.getProperty("org.bonitasoft.platform.password"));
Maybe we could use a Redis pipe here as well.
Maybe we should use a Redis pipe here as well.
Maybe we can use a Redis pipe here as well.
Should be OGC.TYPE.equals(t)
Should be OGC.TYPE.equals(t) && t!= OGCMultiPolygon.TYPE
Should be t!= OGC0,.TYPE
Why not this 'else' block? Why isn't this just part of the conditional at line 154?
Why not this 'else' block? Why isn't this 'else' part of the block above?
Why not this 'else' block? Why isn't this just part of the conditional on line 84? Why not move it into the "if" block?
No need for final
Also create a singleton Gson instance.
No need for final here.
Since getArguments() is mutable, the map might be modified, which makes sense to me.
Since getArguments() is mutable, I think it's better to modify getArguments() to return a copy?
Since getArguments() is mutable, I think it's better to modify getArguments() to return an array.
I think that this test must wait for the page to be cancelled.
I think that this test must wait for the page to finish, just the page should not be canceled
I think that this test must wait for the page to finish, the test should do the trick.
I'd use output.format here: throw new CredentialNotFoundException("Credentials '"+credentialsId+"' is of type '"+ cred.getDescriptor().getDisplayName()) + " where type.is expected");
I'd use output.format here: throw new CredentialNotFoundException("Credentials loaded in " + credentialsId + " where type '"+ credentialsId+"' is of type '"+ credentialsId+"'.");
I'd use output.format here: throw new CredentialNotFoundException("Credentials loaded in " + credentialsId + " where type '"+ credentialsId+"' is of type '"+ cred.getDescriptor().getDisplayName());
Is this line removed by mistake?
Can be just connectionText.isEmpty()
Can be just connectionnectionObservable now.
I think we should add "Test" to MemoryUsersRepository so that we don't have to set their host names.
I think we should add "Test" to MemoryUsersRepository so we can set this on the client side.
I think we should add "host" to MemoryUsersRepository, right?
This variable should be declared inside the loop, because it is not used anywhere else.
This variable should be declared in the for loop.
This variable should be declared inside the for loop, because it is not used anywhere else.
File.separator
Again, filesList will be created afterwards.
listFiles can be called only once.
Should this be a one-liner?
Curious why you are not using a ternary operator in the for loop.
Curious why you are not using a ternary operator?
[optional] Could you also verify that you got a HEAD?
[optional] You could just inline this and save a couple of lines.
... and this one
The error message should be a little more descriptive.
Why we need to add this special handling?
Why we need to create handlers for each service?
where does this get used? It's to be a private method. I think you can make it public.
where does this get used?
where does this get used? It's to be a private method.
You can do this by using a builder, which.add()
Don't use builder, this could be final by using I18n
Don't use builder, this could be final by using
log.debug("Could not connect to server {}", this.host, e);
log.debug("Could not connect to server {}", this.host, e.getMessage());
log.debug("Could not connect to server {}", this.host, e.getMessage()));
Can you remove "MOBS" and use "this." as part of the rest of the codebase?
Can you remove "MOBS" and use "Util.close" as part of the rest of the codebase?
Can you remove "MOBS" and use "ww" as part of the rest of the codebase?
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace this with a try-with-resources block. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused private "run" method. [![rule](<LINK_1>](<LINK_2>
Can you extract tmpBCF to a constant?
rename to filter
rename to fileName, obj
rename to fileName, not fileName
Why not use model?
Why not use streams?
Why not use model? (Index++)
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the client since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to exist in the first place. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
if there's a bug and no configuration should be set here
if there's a bug and no configuration should be set as arguments to this method
if there's a bug and no configuration should be set as default values
:ant: We may have a race condition here. if there's an error then we'll try to migrate a file with a different coverages list.
:ant: We may have a race condition here. if there's an error then we should try to migrate a file with the source store.
:ant: We may have a race condition here. if there's an error then we'll try to migrate a file with the source store.
How about adding a break; after the partition is full?
How about adding a break; after the if?
How about adding a break; after the loop?
Should be Reflections.getAllConfig() to get interfaces on superclass and so forth. Returns a List<Location> instead of a String.
Should be Reflections.getAllConfig() to get interfaces on superclass and so forth. Returns a List<Class<?>> instead of a String.
Should be Reflections.getAllConfig() to get interfaces on superclass and so forth. Returns a List<Location> instead of a List<String>.
why final variable? :-)
why final String variable? :-)
why final variables? :-)
folder.listFiles() will return empty array if no files in the directory. We do not need to do a null check for empty folder.
folder.listFiles() will return empty array if no files in the directory. We do not need to do a null check for empty array.
folder.listFiles() will return empty array if no files in the directory. Not sure does this fix.
This should either be at the end of the test, or at least the reference to the index.
This should either be at the end of the test, or at the end.
This should be something else.
If possible, I think renting can be replaced with ==
If possible, I think renting can be replaced with ==.
If possible, I think renting can be replaced by == operator
It seems we don't need to check for null before calling equals.
It seems we don't need to check for null before comparing the value.
It seems we don't need to check for null here.
Should we get the username and password from this PR, rather than just "indexing item"?
Should we get the username and password here as well?
Should we get the username and password from this PR?
try/catch
this could be private
try/finally
Is it better to assert that it's not equal to the expected value?
Is it better to assert that it's equal to the expected value?
get rid of all these assertions, if possible
100 * projects.size()
you can use " progress.newChild" here
100 * projects.size()?
I think it's better to change this value in a constant, and then set it in the setUp method.
I think it's better to change this value in a constant, and set it in the setUp method.
should this be configurable?
Consider replacing getFilter() and getFilter() into a private method. It would make the code more readable.
Consider making it private.
Keep it private.
This should be used when the result is used, I think.
This should be used when the result is used, i.e. only if the result is present.
This should be used when the result is used, I think
suggestion logger.warn("Could not add {} with key '{}': {}", element.getClass().getName(), uid);
suggestion logger.warn("Could not add {} with key '{}': {}", element.getClass().getSimpleName(), uid);
suggestion logger.warn("Could not add {} with id!", element.getClass().getName(), uid);
@cvrebert let's inline this one
@cvrebert let's remove this one too
@cvrebert let's avoid using.isEmpty()
>.subscribe(unused -> {
Same. >.subscribe(unused -> {
>.subscribe(unused -> {... });
Please remove, I think is an error in the middle of the expression (e.g. file.getName()).
Please remove expression from line 97 to 98. suggestion val file = file.getName();
Please remove expression from line 97 to 98.
Any reason to add a line when the partition >= 0?
How about (rowSize >= 0)?
What happens when the rowCount is negative?
Some left overs..? :)
Some leftovers..? :)
Some left-overs..? :)
This should be moved to the blockBlobClient (right before the null check).
This should be moved to the blockBlobClient (right before the transferTo). Otherwise it will just log the exception and rather than throw it.
This should be moved to the blockBlobClient (right before the transferTo(blobOutputStream)).
@jglick In this case IMO it's better to log the exception too.
@jglick-style violates coding style. Why do we need to have braces here?
@jglick In this case IMO it's better to log the exception as a debug log.
deadlocked_monitor would be more typical. I'd suggest expanding the help a bit too so users will get idea of the difference between these two metrics.
deadlocked_monitor is more typical. I'd suggest expanding the help a bit too so users will get idea of the difference between these two metrics.
deadlocked_monitor would be more typical. I'd suggest expanding the help a bit too so users will get idea of the difference between deadlocks and thread-safety.
Why did you add this to the constructor?
Why did you move this to the constructor?
Why are you using this outside of the try block?
Use an empty map instead of null, as it's the header.
Use an empty map instead of null, even if it's empty.
Use an empty map instead of null.
The "if" block should be inside the "if" block. That would be, but perhaps up to you.
The "if" block should be inside the "if" block.
The "if" block is not needed, the condition can be removed.
Consider using getClass().getSimpleName() instead of this
Maybe we should move this outside the try block? The log message could be more useful than the actual requestBody.getFirst(CERTIFICATE)
Maybe we should move this outside the try block? The log message could be condensed.
could use the same log format as in the other log statements.
could use the same log format as in the other log statements
could use slf4j already log the stack trace
Whitespace
Unnecessary cast
Unnecessary cast.
Change to: if ((operation instanceof CreateGraphicEditPartOperation) && (diagramType == null || diagramType.equals(currentDiagramType))) { return false; }
Change to: if ((operation instanceof CreateGraphicEditPartOperation) && (diagramType == null || (!diagramType.equals(currentDiagramType))) { return false; }
Change to: if ((operation instanceof CreateGraphicEditPartOperation) && (diagramType == null || (diagramType == null || currentDiagramType))) { return false; }
This could be moved to the top of the constructor, i.e.: public StreamOptions getInstance() { return StreamOptions.builder().cacheEntries(!runtime.getParameters().isCacheDisabled()).build(); }
This could be changed to StreamOptions.fromView(TableRegistry.getFullyQualifiedTableName(namespace, tableSchema, startAddress), or something along those lines.
This could be changed to store the stream id in the constructor and store it here.
SegmentLoadingException is specifically checked for in a few places that treat it differently from a generic runtime exception. Please keep it.
SegmentLoadingCallback is specifically checked for in a few places that treat it differently from a generic runtime exception. Please keep it.
SegmentLoadingCallback is specifically checked for in a few places that treat it differently from a generic runtime one. Please keep it.
Can you add the head to the log message? So the entire stack trace will be printed twice.
Can you add the head to the log message? So the entire block will be receiving or send.
Can you add the head to the log message?
ditto constructor
This line should not be changed.
This method is not used.
Code style: try { SimpleFeatureWriter w = new DefaultTransaction(); } catch (Exception ex) { }
Code style: try { SimpleFeatureWriter w = new DefaultTransaction(); } catch (FeatureEntry e) {... }
Code style: try { } finally { w.write(); }
This is not very important, but I think this is just a debug statement.
This looks rather complicated. I think this is just one value and then the value is checked.
This looks rather complicated. I think this is just one value and then you can get key as a value.
I think, in the case of model, you should add an 'Entity' field to the model, and have the 'template' field here.
I think, in the case of model, you should add an 'Entity' field to the model, and have the 'template' field in the API. This way, if the user didn't explicitly define a new Snapshot() method, they wouldn't be able to pass this mapping.
I think, in the case of model, you should add an 'template' parameter to the model, and set'model.setId(entity.getId().toString())'.
it is not reasonable to ask the KeeperException code for the original cause. We should log it as a warning.
it is not reasonable to ask the KeeperException code for the original cause. We need to allow retry even if it is not a leader error.
it is not really a good idea to log this
This is not directly related to unit tests, but use IWorkbench.getInfo() instead.
This is not directly related to unit tests, but use IWorkbench.getWorkbenchWindows() instead.
This is not directly related to the information, the Bundle bookmarker should be logged as well instead.
You can use aliases = ImmutableList.<String>builder().add(getChecksumAlias(column)).map(field -> getChecksumAlias(column, field)).collect(Collectors.toList());
You can use aliases = ImmutableList.<String>builder().add(getChecksumAlias(column)).map(field -> getChecksumAlias(column, field)).collect(Collectors.toList())
You can use aliases = ImmutableList.copyOf(getChecksumAlias(column).stream().map(field -> getChecksumAlias(column, field)).collect(Collectors.toList())
again IBM-specific i would go with "IBM specific"
again IBM-specific am i would go with "IBM specific"
again IBM-specific
What is this else branch for?
what is this else branch for?
what is this else block?
Could be simplified to: suggestion final Quaterniond.fromDummyEntities(Entity<EntityHit> looker, double distance, Predicate<EntityHit> filter) {
Could be simplified to: suggestion final Quaterniond.fromDummyEntities(Entity<EntityHit>, boolean distance, Predicate<EntityHit> filter) {
Could be simplified to: suggestion final Quaterniond.fromDummyEntities(Entity<EntityHit>, Function<EntityHit, Optional<EntityHit> filter) {
You could use DOT_GIT.name() here instead.
You could simplify this by calling setMustExist(true) here.
final
Is there a way to check if the definithement is not null?
Is there a reason why we don't use RNotebook.this here?
Is there a way to check if the definithion is not null?
Do we still need to check the non-null value?
should this be StringUtils.defaultString() instead?
Do we still need to set the default byte code for the object code?
I think it would be better to check if the Tenor is negative.
I think it would be better to check for [months](<LINK_0>
months can be negative
Can we make this a compactEntryLog method?
It would be nice to move this into the compactEntryLog method above, so we don't have to make a function call
Can we make this a double-negative?
I think this should be 'else' rather than 'if'
I don't think this should be done outside of the if statement. Could you please make it 'else'?
I think this should be 'else' rather than 'else'
Space between if and (
Space after the cast?
Space after the cast?
Shall we move this to a method?
It looks like there's a problem here, that will trigger this method.
It looks like there's com.google.checkstyle.base.Path already present in method
This code is only intended to be inside the if (disposableImages.isEmpty()) { block.
This code is only intended to be inside the if (disposableImages) { block.
This code is only intended to be inside the if (disposableImages.isEmpty()) { block; } block.
please check if getDbUser is null.
please throw exception instead of returning null.
please check if getDbUser is null
Since we already have a mechanism to access it from the cache, I think we can keep it simple and avoid an additional cache lookup.
Since we already have a mechanism to access it from the cache, I think we can keep it simple and add it to the cache only.
Since we already have a mechanism to access it from the cache, I think we can keep it simple.
I don't think it's required to update the host_uuid here. It should be biosInfo.getPartitionId().toPathString()
I don't think it's required to update the host_uuid here. It should be biosInfo.getDdsStaticDao()
I don't think it's required to update the host_uuid here. It should be validated during the run of the command.
If we decide to keep the exception message, would it be better to use a self-defined message?
If we decide to keep the exception message, would it be better to have a more specific exception message?
If we enter this method, then we must be consistent.
Should the null-check be in the first place?
This is a bit too complex to understand. I'd extract it to a method/method in the ConstraintCheckIssue so you don't have to trim everything.
This is a bit too complex to understand. I'd extract it to a method/method in the ConstraintCheckIssue so you don't have to trim the input here.
There's no need to create a local variable for this.
There's no need to create a local variable here.
There's no need to collect all fields and filtering them. We can directly return them.
same here as above
return value is not used
return missing
we can replace this with (diff > 0)? -1 : (diff > 0)? 1 : 0);
we can replace this with (diff > 0)? -1 : (diff > 0)? 1 : 0)
Yes, I think is better: if (minItemsBeforeRefresh <= 0) { return 0; }
Is it sufficient not to compare getId() because TrackInfo#equals already considers mId? (ditto for others)
Is it sufficient not to compare getId() because TrackInfo doesn't depend on getId() because TrackInfo#equals already considers mId? (ditto for others)
Is it sufficient not to compare getId() because TrackInfo#equals already considers m id? (ditto for others)
Would it be better if this validation logic would be in  VisitRescheduleDto's save method?
Would it be better if this method's saveVisitWithId() only once?
Would it be better if this validation logic would be in  VisitRescheduleDto's save() method?
You need to check that the contents of the file is not empty here as well.
You need to make sure that each test is executed.
You need to check that the contents of the file are not loaded here as well.
Does this need to be public?
Does this mean you're going to have to check for top and right bounds?
Does this have to be public?
%n
nit: can remove final
nit: can remove final.
Can you please add curly braces for the if statement on line 951?
Can you please use curly braces for the if statement instead of string concatenation?
Can you please add curly braces for the if statement on line 96 to make it more readable?
nit: add a space between ) and {
add a default to false
nit: add a default to the intent
we don't use braces around single line blocks
we don't use old stream for exceptions like below. can we change log message like below to improve readability. LOG.error("Some action expired right after being ignored.", e);
we don't use old stream for exceptions like this. Move to update intellij error.
The old code was a bit too late, but I still think it would be better to revert these two lines: String defaultNamespace = writer.getModelNode().substring(0, defaultNamespace.length());
The old code was a bit too late, but I still think it would be better to revert these two lines: String defaultNamespace = writer.getModelNode().substring(0, defaultNamespace.length());?
The old code was to revert these fixes, but we should really fix that.
May be you can give a more widespelling: throw new IOException(String.format("Error occurred while closing BufferedReader"));
May be you can pass the input stream to the while loop :(
I would suggest you put a space after the opening bracket in here.
Is that method needed?
Is that method necessary? This should be private.
Is that method necessary?
removed
remove!
removed?
suggestion.map(bibFile -> bibString.endsWith(BIB_EXT)).map(bibFile -> bibFile.toFile().exists()).map(bibFile -> bibFile.toFile().exists()).collect(Collectors.toList());
suggestion.map(bibFile -> bibString.endsWith(BIB_EXT)).filter(bibFile -> bibString.endsWith(BIB_EXT)).map(bibFile -> bibFile.toFile().exists()).collect(Collectors.toList());
suggestion.map(bibFile -> bibString.endsWith(BIB_EXT)).map(bibFile -> bibFile.toFile().exists()).collect(Collectors.toList());
I'd prefer entry.getWidgetCount() - 1).setEnabled(!becomingGhost) { toggleGhost(value, widget, becomingGhost); } about the 'if' statement.
I'd prefer entry.getWidgetCount() - 1).setEnabled(!becomingGhost) { toggleGhost(value, widget, becomingGhost); } else { toggleGhost(value, widget); }
I'd prefer entry.getWidgetCount() - 1).setEnabled(!becomingGhost) but why isn't it better?
Shouldn't the above line be moved to the cacheManager.getCache() call?
Shouldn't the above line be moved to cacheManager.getCache(name);?
Shouldn't the above line be success?
Minor: have you seen a constant for "Offending token"
Minor: have you seen a constant for it?
Minor: have you seen a point on a link?
I don't really like this static method. It seems to be cleaner to have a single method like dumpHadoopCounters(HadoopCounter). Or if the job is running, it should be pulled out of the JobGraph.
I don't really like this static method. It seems to be cleaner to have a single method like dumpHadoopCounters(HadoopCounter). Or if the job is running, it should be pulled out of the inner class too.
I don't really like this static method. It seems to be cleaner to have a single method like dumpHadoopCounters(HadoopCounter). Or if you should say why the job is being pulled?
Do you need to set the variable on the next line?
I think this is not good. It will be'serverVariablesObject'. You have to set it to a ServerVariable.
I think this is not good. It will be 'caused by the user.
Probably, there is something wrong with idenations.
Probably, there's something wrong with idenations.
Probably, there is something incorrect with idenations.
I always thought this was the original behaviour. The system.gc() should be enough.
I always thought this was the original behaviour. The thread pool was based on the metrics's current state, and the metrics was based on the metrics's value. So it should be something like 'timestamps.value'

This and the other modified test can be removed?
This and the other ones can be removed since they're re-used. Should we make them private?
This and the other ones can be removed
Ouch... ;)
Don't forget to remove...
Sysout?
This cast is redundant. You are casting to byte and then cast to byte.
This cast can be removed.
This cast is redundant. You are casting to byte and then doing a cast.
you should use IOUtils.toString to not escape the code.
you should use IOUtils.toString to a String instead.
you should use IOUtils.toString to not escape the string.
Nit: Unnecessary catch blocks.
Nit: Wrap the try/catch with a log statement.
Nit: Unnecessary catch clause.
Another or more readable: assertEquals(parameterSet.inputTimeString, parameterSet.inputTimeString);
Another on-liner, would also be nice to assert this becomes a more descriptive name.
final
code style: could be extracted into a method because it is more readable.
code style: could be moved into the if statement
code style: could be extracted into a method because it is more readable
This entire method is redundant. What you should do is implement updarteAllInBatch(Collection<T>) in MassOperationGenericDAO in a similar fashion to updateAll(Collection<T>) and then call it from there. There's no point in having this type of method in all the DAOs.
this entire method is redundant. What you should do is implement updarteAllInBatch(Collection<T>) in MassOperationGenericDAO in a similar fashion to updateAll(Collection<T>) and then call it from there. There's no point in having this type of method in all the DAOs.
This entire method is redundant. What you should do is implement updarteAllInBatch(Collection<T>) in MassOperationGenericDAO in a similar fashion to updateAll(Collection<T>) and then call it from there. There will be no point in having this type of method in all the DAOs.
not sure if this is a good idea?
not sure why this is needed?
not sure why this is here
use isEmpty() instead of get(0)
add isEmpty() check for call id
null check for call id
Remove this line.
Remove println.
Remove
This is the actual bug fix, but it seems that we could get rid of refresh() method.
This is the actual bug fix, but it seems that we could get rid of the refresh logic.
This is the actual bug fix, but it seems that we could get rid of the refresh call above.
please use the HOSTED_ENGINE_SD_NOT_ACTIVE log in the log.info the Hosted Engine VM.
please use the HOSTED_ENGINE_SD_NOT_ACTIVE log in the log, as we do in other places.
please remove this HOSTED_ENGINE_SD_NOT_ACTIVE
It's better to use local variable here instead of breaking out into two cases.
It's better to use local variable here instead of using m.
It's better to use local variable here instead of breaking out to a random call.
Isn't this an exception?
Isn't this an error?
lock is present?
maybe it would be better to move this logic to the caller of the for loop, so it keeps the flow more readable
maybe it would be better to move this logic to the caller of the for loop.
maybe it would be better to have a retry mechanism for the ResourceProfile.
Pull this uri logic out into a separate method and then call it from these methods
Pull this uri logic out into a separate method and call it from these methods
Pull this uri logic out into a separate method and reuse it in the methods
This should check that the output of the supplier has not been invoked.
This should check that the output of the supplier has the correct value. Same for the tests
This should throw a RuntimeException instead of AssertionError
Hello @mcimbora I believe the changes and the approach is good, but the invocation to the ValidatonService and this logic here should go in the Presenter
Hello @mcimbora I believe the changes and the approach is good, but the invocation to the ValidatonService and this logic here should go in the presenter.
Hello @mcimbora, the changes and the approach is good, but the invocation to the ValidatonService and this logic here should go in the Presenter
should we assert that this value will be positive?
should we assert this value?
should this be never negative?
suggestion.withObj("cardholder_name", "PayMc").withHttpHeaders("request-name", is(value))
suggestion.withObj("cardholder_name", "PayMc")
suggestion.withCredentials(allOf(String.class),
It's better to fix this kind of thing in the DecimalShatter#getDecimalWidth method too.
It's better to fix this kind of thing by using the.getDecimalWidth()
It's better to name the value part in the DecimalLiteral here
Not sure. I think this can happen.
Not sure. I think this should be "getActiveUser"
Not sure. I think this should be "user==null"
You need to pass result._source instead of just result as a parameter.
nitpick: wouldn't it be easier to just use the KuzzleRoleAdapter.class.isInstance(result) method?
nitpick: wouldn't it be easier to just use the KuzzleRoleAdapter.class.isInstance(result) syntax?
anyway we are doing this for every user of the repository. Is that possible to do it? Because if it is not, then we should do that.
anyway we are doing this for every user of the repository. Is that it? Because if it is not, then we should do it.
anyway we are doing this for every user of the repository. Is that possible to do it? Because if it is not, then we should do it.
nit: I'd add a cast to Optional to avoid having to go this way over.
nit: I'd add a cast to Optional to avoid having to go this down to a static class.
nit: I'd add a cast to Optional to avoid having to do this: java if (expression instanceof Integer) { return Optional.ofNullable(expression); }
you are passing'rebalanceStatusEntity' to'rebalanceStatusEntity' here
you are passing'rebalanceStatusEntity' to'rebalanceStatusEntity'
you are passing'rebalanceStatusStatus' to'rebalanceStatusEntity' here
Can we replace this with stream API?
nit: remove this line
Can we replace this with stream api?
Why do we need to clear transaction here?
Why do we need to clear transaction and clear it up?
Why do we need this test?
This is not needed and should be done in a loop.
This is not needed and should be handled in the interface, no?
This is not quite right. If you have a.equals method, you can use the asserts for this.
As before, it would be nice to not store the state as frozen in the constructor (and set it to null in the else case).
As before, it would be nice to not store the state as frozen in the constructor (and set it to null here).
As before, it would be nice to not store the state as frozen in the constructor (and set it to null in the other usages) I think.
Check source data. And same for below.
Check source data. Should be a set.
Check source data.
I feel like the previous code was better, since we still create a new map for our own internal data structure. What does the new code fix? We could change this code a little bit to be something like: if (parameters!= null) { glueParameters = glueParameters; }
I feel like the previous code was better, since we still create a new map for our own internal data structure. What does the new code fix? We could change this code a little bit to be something like: if (parameters!= null) { glueParameters = glueDatabase.getParameters(); }
I feel like the previous code was better, since we still create a new map for our own internal data structure. What does the new code fix? We could change this code a little bit to be something like: if (parameters!= null) { glueParameters.putAll(parameters); }
Do we still need this line?
Do we want to create the schema for this in the new APIs?
Do we expect this to be null?
This is bound to a non-null Buffer in the frame, so leave it set to the current time.
This is bound to reduce severely performance when we reuse a frame. You'll need to make a release of these frames at that point.
This is bound to reduce severely performance when we reuse a frame. You'll need to refactor so that there is no need to re-use the identation in a frame.
This should be changed in the QUERY_LOGGER.buildSearch() method.
This should be changed in the QUERY_LOGGER.buildQuery() method.
This should be changed in the search builder.
try to exploit map and co for this method
try to exploit map and co for this method :)
try to exploit map and co for the same thing
Looks to me like it was left from debugging. On my system, it looks to me like it was left from debugging.
Looks to me like it was left from debugging. On my machine it was going to work with 3+.
Looks to me like it was left from debugging. On my machine there is it
This will fail in case we don't have, which is the behaviour.
This will fail in case we don't have, so we should use [JUnitTestUtils](<LINK_0>
This will fail in case we don't have, so you should verify it.
why not just pass it to the logger?
why not just pass the NUM_HEADLINES...?
why not just pass the Tracing?
Please add the permission needed => "Requires 'Administer' permission on the specified project"
Please add the permission needed => "Requires 'Delete a non-main branch of a project"
Please add the permission needed => "Delete a non-main branch of a project"
Assert that the message is correct.
assertThat(x).hasSize(2);
Assert that the message is correct
Would it be hard to track what happens if there are multiple filters with the same name?
Would it be hard to track the user of the filters by their identifier?
Would it be hard to track what happens if there are multiple filters with one filter?
Would prefer to add log inside the writeResponse method
Would prefer to add log or throw (if we're not familiar with the graph)
Would prefer to add log or throw (if we're not familiar with the publishing API)
I think it would be better to handle the case where the deployment spec is not null and handle that case. Something like this: String deploymentURI = String.format( "%s/api/v1/namespaces/default/pods", this.kubernetesURI); if (deploymentURI == null) { LOG.log(Level.SEVERE, "Failed to process deployment API successfully"); return false; }
I think it would be better to handle the case where the deployment spec is not null and handle that case. Something like this: String deploymentURI = String.format( "%s/api/v1/namespaces/default/pods", this.kubernetesURI);
I think it would be better to handle the case where the deployment spec is not null and handle that case. Something like this: String deploymentURI = String.format( "%s/api/v1/namespaces/default/pods", this.kubernetesURI); // ignore the null byte array array. return null; }
Why do we need to check this?
Do we need to check this?
Why do we need this check?
why do you not assign it to a variable and use it in the else {}?
why do you not assign it to an instance status?
this is not configurable
I would prefer to take the opportunity to update the GeoServer model to support this.
I would prefer to take the first branch out of the try block.
I would prefer to take the opportunity to update the GeoServer model to be able to retrieve an existing one.
This appears to be unused.
This appears to be unnecessary, just because you're changing it anyway.
This appears to be unnecessary, just because you're changing it anyway
Can you move the jiraRestClient.getIssueClient().createIssue(issueInput) out of the catch block?
Why we have to change this?
Can you move this into the constructor?
Why is only a remote lock? I know right now we don't actually need the lock.
Why is only a valid lock? I know right now we don't actually need to protect the lock, but would it complicate things to allow them anyway?
Why is only a remote lock? I know right now we don't actually need the lock, but would it be simpler to just return right away if it was a remote lock?
does this method need to be public?
could this method be static?
does this method need to be public?
Just try to write this instead? NucleusObjectNotFoundException| catch (NucleusObjectNotFoundException nfe) {
Just try to write this instead: NucleusObjectNotFoundException nfe = t.getObjectsById( clazz.getCanonicalName(), clazz);
Just try to write this instead: NucleusObjectNotFoundException nfe = t.getObjectsById( clazz.getCanonicalName());
Can you simplify this assertion by using a assertTrue(alleles.isEmpty())? then you'll have a nicer error message.
Can you simplify this assertion by using a assertTrue(alleles.isEmpty())?
Can you simplify this assertion by using assertTrue(alleles.isEmpty())?
If you're pulling out the extra code, it should be included a call to the above method. There's also no need for the 'fallthrough' part.
If you're pulling out the extra code, it should be included a call to the above method. There's also no need for the.equals() statement.
If you're pulling out the extra code, it should be included a call to the above method. There's also no need for the 'fallthrough' variable.
should it be internationalized like others buttons?
should it be internationalized like others buttons?
should it be internationalized like others buttons)?
I am still confused why this is a public method, why doesn't it have to be public?
I am still confused why this is a different method call than that in the shares. It is probably a more typical way to do this, but why does it have to be public?
I am still confused why this is a different method call than that in the shares. It is probably a more typical way to do this, but why does it have the same logic?
Is there an equivalent regular expression on the desktop client that this will need to be done?
Is there an easy way to move this logic to the if (potentially combined with the above line) and then after the if (potentially combined with the if (existing) conditional?
Is there an easy way to move this logic to the if (potentially combined with the above line) and then after the if (potentially combined with the above line? I think you should be able to remove this replaceAll to make it public.
Is there any reason why we use BAD_REQUEST instead of BAD_REQUEST?
Is there any reason why we don't use.getSchema() here?
Is there any reason why this test is failing?
Why not just letting the DispatcherGateway fail if shutDownCluster is being called?
Why not use FlinkRuntimeException? Couldn't we write this as the Exception is thrown here?
Why not use FlinkRuntimeException? Couldn't we write this as the DispatcherGateway for the DispatcherGateway?
I think we should handle this case in the baseQualityDepthCount
I think we should handle this case in the same way to be safe. Let me know what you think.
I think we should handle this case in the same way as we did for the baseQuality depth.
the set of dataSizePerContainer is not used.
the set of dataSizePerContainer is not needed.
the set of data size is not used.
I think you can save a couple lines of code by using mRemoteJpSettings.serveImagesFromOurServers
I think you can save a couple of lines by using mRemoteJpSettings.serveImagesFromOurServers
I think you can save a couple lines of code by using mRemoteJpSettings.serveImagesFromOurServers().
Rather than use this, I think you could just just call Screen.getPrimary()...
Rather than use this, I think you could just just call the constructor directly (instead of duplicating the lines).
Rather than use this, I think you could just just call Screen.getPrimary().getVisualBounds()....
nit: this might look nicer if we collapse the code into a single line.
nit: this might look nicer if we collapse the into a single line.
nit: this might look nicer if we collapse the code into a single line each.
Why did we switch to throw BadRequestException?
Why did we switch to throw an exception here?
Why did we switch to throw an exception here??
Also wondering why this condition is always false? watcher.poll(5, TimeUnit.SECONDS)
Not sure why we need this logic, but maybe it should be warn?
Not sure why we need this logic, but maybe it should be in a loop?
Can we use TemporaryThread here?
Can we use TemporaryFuture instead?
Can we use TemporaryFuture?
Pattern.compile should be done in a static final field to avoid re-compiling on each call
Pattern.compile should be done in a static final field
Pattern.compile should be done once in a private final field
I think you can copy this method from the Context constructor, but you shouldn't hardcode the configuration here.
I think you can copy paste artifacts from the linkstatic field
I think you can copy this method from the Context constructor, but you wouldn't need the temp variable.
LGTM = Looks Good To Me
Aren't you just supposed to remove the deprecated annotation and not change the method code? Because it was already delegating to the DefaultComparator anyways, i think this deprecation was invalid
LGTM
would you want to change the isFragmentActive method name to isFragmentActive(SurveyFragment)?
would you want to change the isFragmentActive method name to be isFragmentActive(SurveyFragment)?
would you want to change the isFragmentActive method name to isFragmentActive(SurveyFragment)
It looks like the sourceId can be null, even though we don't know what the getPath() method returns above. Is it needed?
It looks like the sourceId can be null, even though we don't know about this later.
It looks like the sourceId can be null, even though we don't know about this condition at all. Is it needed?
This is a bit strange, because you are copying the value out of the card you _could_ to change kickReason to an actual reason, because you're parsing it into an object that you can't do anything.
This is a bit strange, because you are copying the value out of the card you _could_ to change kickReason to an actual reason, because you're parsing it into an object that you can't do anything with it
This is a bit strange, because you are copying the value out of the card you _could_ to change kickReason to an actual reason, because you are parsing it into a new string, and not doing it in the command.
Use Cubes.size
Use Cube.size
use Cubes
Another option would be to check that sInitDeinitFuture.addListener(() -> { Futures.propagate(cameraX.initInternal(context, appConfig), completer); return sInitDeinitFuture; });
Another option would be to check if sTargetInitialized is not null. If we give a Throwable, the ErrorProne would fail with an NPE.
This should probably be synchronized
Please use the method instead of the method both here and the method instead of doing the same thing.
Please use the method instead of the method both here and the line above.
Please use the method instead of the method both in this and the flushRaw.
For this kind of thing, I'm not sure if this is the correct handling of the button. Would it make sense to clear the button when the button is paused?
For this kind of thing, I'm not sure if this is the correct behavior
Move this to a 'crash' method?
suggestion LOGGER.error("Could not delete container (" + engineId + ".shortcuts.reader\");
Do we really need a catch here? I think we should at least log the exception
Do we really need a catch here? I think we should at least log the exception too.
Please use the java7 template to retrieve the Class and pass it to the constructor.
Please use the java7 auto-generated custom class loader instead of the default one.
Please use the java7 auto-generated custom class loader instead of the String.
I would prefer to break here through the addPrivateDnsRouteSet and add privateDnsRouteSet to add the privateDnsRouteSet of HostPack. That way we can reduce the number of calls to addPrivateDnsRouteSet and remove the privateDnsRouteSet to be a singleton.
I would prefer to break here through the addPrivateDnsRouteSet and add privateDnsRouteSet to add the privateDnsRouteSet of HostPack. That way we can reduce the number of calls to addPrivateDnsRouteSet and remove the privateDnsRouteSet to return a boolean.
I would prefer to break here through the addPrivateDnsRouteSet and add privateDnsRouteSet to add the privateDnsRouteSet of HostPack. That way we can reduce the number of calls to addPrivateDnsRouteSet to be a separate function.
Doesn't this now need to be @Nullable?
Doesn't this need to be public?
Doesn't this now need to be public?
Oh, so the number of iterations actually includes the first try as well.
Oh, so the number of retries actually includes the first try as well.
Oh, so the number of null checks actually includes the first try as well.
Do we support this for now? the operation is run with a READ lock so it won't work
Is this in preparation for multiple-tick operations? the operation is handled there.
Is this in preparation for multiple-tick operations? I don't see how this would ever be used
we could use a constant for i.e. 1000L
we could use a constant for i.e. 1000 or 1000
we could use a constant for i.e. 1000 or 5
No need to add the type check.
No need to check the sourceFigure.
No whitespace
Does this line have to be too long?
Does this mean we don't have to define this line more?
Does this mean we don't have to define this line a bit more?
Please remove as this is related to the fix required in #6610
remove as this is related to the fix required in #6610
Please remove as this is related to the fix required in #661.
assertThat(statistics).hasOnlyKeys("keyA");
s.o.
This seems unnecessary.
Similarly, can you make this part of the equals() method to make it consistent with the rest of the codebase?
Similarly, can you make this part of the equals() method to make the condition more readable?
Similarly, can you make this part of the equals() method to make it consistent with the other fields?
You need to make sure that it works on Windows using the CI plugin.
You need to make sure that it works on Windows using the CI server.
You need to convert this to a File and then use the DirectoryStream with a.withTier(...) clause
OPEN_PET_FACTS = 6; is the name of the product type?
OPEN_PET_FACTS = 6; is the name of the product.
OPEN_PET_FACTS = 6; for clarity?
is this change needed anymore?
space after String.format
space after String.
style nit: we don't use braces around singleStep, more below
nit: can be replaced by maybeMail.get().run();
style nit: we don't use java while syntax :)
We don't need to log this here. If we log, we can consider the exception above.
We don't need to log this here. If we log, we can consider using {} instead of string concatenation
We don't need to log this here. If we log, we can consider using {} syntax
final
final.
final?
Multiple space before {
Multiple space before the if
Multiple space before :
I would prefer you use here the representation of the widget type.
I would prefer you use here the name of the method: 'createDatastoreButton' or something like that
I would prefer you use here the name of the method: 'createDatastoreButton' or something like that.
Not sure if this is new, but you could simply create a method on BL that checks if params is ponsored, and remove it from here. The same goes for other methods.
Not sure if this is new, but you could simply create a method on BL that checks if params is ponsored, and remove it from here. Then you can call both methods without arguments.
Not sure if this is new, but you could simply create a method on BL that checks if params is ponsored, and remove it from here.
Remove the redundant log.
Remove the redundant msg.
Remove the redundant logging.
Same question here, if the resource is a reservation resource, then it will be removed from the reserved resource list.
Same question here, if the resource is a reservation resource then the value is the same as the resource?
Same question here, if the resource is a reservation resource, then we will have the reservationResource value within the bound resource.
same here, just return here.
map?
map
Again this should be renamed to say something like "owningCommunity"
Again, "owningCommunity" isn't optional in this method
Again this should be renamed to owningCommunityUuid
Same here, this line is too long
Same here, you need to wrap into a List
Same here, you need to wrap into a new ArrayList
This is a discrepancy between multiple instances. You should reuse the code.
Why do you have this logic in the constructor?
This is a catch for ClassCastException. Try to declare such logic as CloudBlobContainerException
rename to fDirToLook or at least fFileName
why not use fDirToLook?
rename to fDirToLook
"Fatal Error".equals(matcher.group(3))
"Fatal Error".equals(matcher.group(3)) is clearer.
Make "Fatal Error" and "Enter Error".
does it mean we should remove one of them?
does it mean we should remove one of them?
does it mean we should remove one of them a new client?
I'm wondering whether it's better to catch a specific exception type here.
I'm wondering whether it's better to catch a more specific exception type here.
I'm wondering whether it's better to catch a more specific exception type here..
I would prefer to use the constants from TestData.class, that is more readable.
I would prefer to use the constants from TestData.MODULE, "/ogr".
I would prefer to use the constants from TestData.class, that does not require a charset.
change the session status here.
change the session status here as well
change the session status here. The session's status is not updated.
ERROR->NOT_FOUND
This should be ERROR.
ERROR -> ERROR
This check should be added to the GridQueryConfig.CTX_KEY_PUSH_DOWN_LIMIT to have the reverse order. The cases where we introduce a new method, we set it to false.
This check should be added to the GridQueryConfig.CTX_KEY_PUSH_DOWN_LIMIT to make it clear that they are not used in the GridQueryConfig.
This check should be added to the GridQueryConfig.CTX_KEY_PUSH_DOWN_LIMIT to have the reverse order. The cases where we introduce a new method, we set the sorting will be required.
This should be a tableBuffer.position() + 0x80)
You could use keyBuffer.remaining() here.
This should be a tableBuffer.position() - 1 or the other so that you can verify if you are equal?
the principalRecords is not a parameter of the method. It's used only in loginOnBehalf, but from the code, it's a little confusing.
the principalRecords is not a parameter of the method. It's used only in loginOnBehalf, but from the code, it's a bit confusing.
the principalRecords is not used anywhere anymore.
I like the approach of throwing an exception, in case case we could add support for it. It is safer to explicitly throw an exception, e.g. NullPointerException. Some other code (e.g. NPE) could be thrown.
I like the approach of throwing an exception, in case case we could add support for it. It is safer to explicitly throw an exception, e.g. NullPointerException. Some other code (e.g. NPE or some other error), an exception.
I like the approach of throwing an exception, in case case we could add support for all cases of PullRequestEvent.Action.
Please use log.error(message, e) instead of e.printStackTrace()
I don't think this is necessary. If an exception is thrown from cleanupSim() it should be logged as an "exception".
Please use log4j parametrization instead of e.printStackTrace() ;)
This should probably be removed.
This should probably be used to "System.sleep()". I guess that's not what the user intended.
This should probably be removed
I would move this log message to hangupWaitingOrBackground, since that's the default log message.
I would move this log message to hangupWaitingOrBackground, since that's the same as above.
I would move this log message to hangupWaitingOrBackground, since that's the only place it is used
Not related to this PR but I'm curious if we should log or throw an exception when we get.
Not related to this PR, but I'm curious if we should log or throw an exception when we get.
Can this be logged as an error?
this sNPs can be replaced with getEnd()
this trim should be on the snps instead of snps.target
this sNPs can be -1, in which case this must be -1, in which case this must be -1, in which case this must be -1, it is not fixed.
- why postSetUp isn't called from applyInlineDeployments - should we use pushInlineDeployments here? - use of deployContrib with a test contribution
- why postSetUp isn't called from applyInlineDeployments - should we use pushInlineDeployments here? - use of deployContrib with a test bundle
- Why postSetUp isn't called from applyInlineDeployments - should we use pushInlineDeployments here? - use of deployContrib with a test contribution
Another question: would it make sense to include the path in the log message?
Another question: would it make sense to include the path into the log message?
Another question: if you're renaming the variable to "topics" in this log message then I think it's better to pull them into a private method.
This check (and the one above) are going to break DEX preverification. Can you instead move these to a util class, similar to this:... if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { OreoUtils.setColorSpace(options, colorSpace); }.... import com.facebook.annotations.DoNotOptimize; @DoNotOptimize private static class OreoUtils { void setColorSpace(...) { options.inPreferredColorSpace =... } } } }
This check (and the one above) are going to break DEX preverification. Can you instead move these to a util class, similar to this:... if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { OreoUtils.setColorSpace(options, colorSpace); }... }... import com.facebook.annotations.DoNotOptimize; @DoNotOptimize private static class OreoUtils { void setColorSpace(...) { options.inPreferredColorSpace =... } } }
This check (and the one above) are going to break DEX preverification. Can you instead move these to a util class, similar to this: java public static class OreoUtils { void setColorSpace(...) { options.inPreferredColorSpace =... } } }
Revert this change please
Revert the changes here.
Revert the change here.
Can this be named iPart?
Can you also cover the case where the lengths are different?
Can you also cover the case where the element is longer than 120?
Can you explain what your doing here? What do the following variable do: for (ILogicalExpression expression : ds, ILogicalExpression.class) {
Can you explain what your doing here? What do the following variable do: for (final ILogicalExpression expression : ds, i - 1)); and why not using a single variable?
Can you explain what your doing here? What do the following variable do: for (final ILogicalExpression expression : ds, i - 1)); and move the statement after if (typeId > 0) {
style nit: no braces around single line blocks
style nit: no braces around single line block
style nit: no braces here
Is it really correct to mark the method as RexCall and OTHER_FUNCTION as deprecated?
Is it really correct to mark the method as RexCall.isItem and cast to RexCall?
Is it possible to call this translateOp2?
instead of using hard coded strings, consider using android.R.string.ok
instead of using hard coded strings, let's use auto-format.xml
Unused variable
please print the value
please print the value of the log, not sure where it was implemented.
please print the value of the log, not sure how it is displayed.
@yingsu00 Ying, could you please add a space after the semicolon?
@yingsu00 Ying, could you please add a check for isEnabled. If user is not already deleted the secondary storage, we should show the user what the user is trying to delete.
@yingsu00 Ying, could you please add a check for isEnabled(Snapshot.State.STATE_ACTIVE).
You should add a fail-fast condition to the if (wip.decrementAndGet() == 0) {... }
Please add a log statement.
Please remove this as we're not adding an event for a void message.
I know this has been here before but this can easily exploited by holding normal shears or even a multi tool in your off hand and then using a normal Wind staff. It would probably be better to check if a wind staff is held in any of the two hands, you can use isItem(...) for this.
I know this has been here before but this can easily exploited by holding normal shears or even a multi tool in your off hand and then using a normal Wind staff. It would probably be better to check if a wind item is held in any of the two hands, you can use isItem(...) for this.
I know this has been here before but this can easily exploited by holding normal shears or even a multi tool in your off hand and then using a normal Wind staff. It would probably be better to check this wind staff only once in any of the two hands, you can use isItem(...) for this.
You can reuse isTimerRelatedEvent here.
You can reuse isBindEvent here.
You can reuse isTime method here.
I can't tell it here. Would it be better to have a static import for all these sleeps?
I can't tell it here. Would it be better to have a static import for all these timeouts?
I can't tell it here, but probably it's better to use.map(Event::toMap)
A minor grammar error is in the description: "Only after paragraph run we should see the new output "
A minor grammar error is in the description: Input should not display any of the output ("Only after paragraph run we should see the new output ", e)
A minor grammar error is in the description: Input should not display any of the output ("Only after paragraph run we should see the new output ")
Static import?
This can be public.
This can be simplified because it is only used to do this.
"the input %s list must not contain nulls", roleName)
"The input %s list must not contain nulls", roleName)
"the input %s list must not contain nulls"
nit: "client"
nit: "in" -> "in"
nit: print keyPhrases.ErrorMessage
Thissignum() can be removed.
Thissignum() shouldn't be the correct way to calculate this. Please remove this code.
Thissignum() should be removed.
How about use [Hasher.firstLong()](<LINK_0> here?
How about use [Hasher.firstLong()](<LINK_0> which will handle the assertion?
How about use [Hasher.firstLong()](<LINK_0> that will handle the assertion?
We need to assert that the addedAcl is not null, if we add it to the other setAcls.
We need to assert that the addedAcl is not null, if we add it to the existing ozoneAcl.
We need to assert that hasAcl returns false.
The PR description says "Create access tokens"
Please do not use val in variable names.
Please remove this.
Is it possible to still call execute() here?
Is it really possible to still call execute() here?
Is it really possible to still call execute() here? I think this is an example of how it should be tested.
add log message
add log line
add log message?
@slubwama I'd do a check for null and return the indication that the service is not found
@slubwama I'd do a check for null and return the indication that the service is not found or null
@slubwama I'd do a check for null and return the indication that the service was found
java8-isation [forEach][map][methodReference]
This may be an improvement.
java8-isation [forEach][filter]
This test could be simplified to: given(parent.isCustomPage(message, type)).willReturn(true); given(parent.isCustomPage(message, type);
This test could be simplified to: given(parent.isCustomPage(message, type)).willReturn(true); given(parent.isCustomPage(message, type));
This test could be simplified to: given(parent.isCustomPage(message, type)).willReturn(false); given(parent.isCustomPage(message, type);
This should be improved by iterating over all topicsLeft.
This should be improved by naming the method, the user knows what the retries are.
This should be one line to avoid braces
Maybe sex instead of "sex"?
Maybe sex instead of "sex"
Maybe sex instead of "Space"?
This is a bit too coarse-grained IMO. Can we create a small class for this?
This is a bit too coarse-grained IMO. Can we create a small class that can be used by both Java objects?
This is a bit too coarse-grained IMO. Can we create a small class that can be used by both save and persist?
could you test this behaviour?
could you also test the.next()?
could you also test the.next port separately
We could highlight this in the error message. this isn't a warning, and should not be an error.
We could highlight this in the error message. this isn't a warning, and should not be a warning.
We could highlight this in the error message. this should be an explanatory message.
Before this change, we had the eventDeliveryTime was set to true (because Publisher thread can be reused by the receiving container). WDYT?
Before this change, we had the eventDeliveryTime was set to true in the first place, so add it to the list all the time with that new field?
Add this to the log
Why do you use this variable and not 'empty'?
Please use assertThat, so you'll get a more clear error message
Please use assertJ assertions instead.
I'm not sure about the catch-block in this method. Is it needed to do something like the following? java if (obj == null) { return true; } else if (obj == null) { return true; } else { return _theAction.equals(txControl); }
I'm not sure about the catch-block in this method. Is it needed to do something like the following? java if (obj == null) { return true; } else if (obj == null) { return true; } else { return _theAction!= null && (txControl == null); }
I'm not sure about the catch-block in this method. Is it handled somewhere else? I'm sure this is handled by the AtomicTransaction condition test.
This won't be closed.
This line is pretty long, please use a try-with-resources.
This line is pretty long, please wrap it in a try/finally block
Same question as above.
Same here, move the call to annotation.
AssertJ has been changed.
I think this could be more readable as: java long rowsPerPartition = node.getPartitionBy(); double rowsPerPartition = (symbolStatistics.getDistinctValuesCount() ==  0.0)? 0 : 1;
I think this could be more readable as: java long count = partitionCount; if (count < partitionCount) { partitionCount = max(rowsPerPartition, node.getMaxRowCountPerPartition().get()); }
I think this could be more readable as: java long count = partitionCount; if (count < partitionCount) { partitionCount = max(rowsPerPartition, node.getMaxRowCountPerPartition().get()); } return count;
Should be defined in the 'if' statement
please don't remove the "O=", "" is not a valid certificate"
Should be a constant.
Same as in CompletionTest.java (add type of 'unchecked')
Same as in [L1 ](<LINK_0>
Same as in Operator test.
This is modifying the existing method which is modifying the existing one.
This is modifying the existing method and is modifying the existing one.
This is modifying the existing method which is modifying the existing one in the ContractTest
Can use a format placeholder instead of spaces here.
Can use a format message instead of spaces here.
Can use a format message instead of spaces
The empty builder is probably not required.
The empty builder is probably not required, to test this for it.
Seems like you're having a method for nextFixing such as private static method.
Can we set a fault with some info on the command somehow? Also, no need for the time - the log itself should contain it
Can we set a fault with some info on the command somehow? Also, no need for the time - the log itself can contain it
Can you set a fault with some info on the command somehow? Also, no need for the time - the log itself should contain it
style nit: missing space after 'if'
style nit: no braces around single line blocks
style nit: missing space after 'for'
please rename this to hasCpuPinning
can this be moved into the if statement since it is only set once in the if statement.
please rename this to hasCpuPinningMatch()
I don't think it's useful to have the info log displayed to users.
I don't think it's useful to have the info log displayed to users. "Delete operation failed" is not a useful message.
I don't think it's useful to have the info log displayed to users. "Delete operation failed" is not a useful information.
this test is not necessary because it is annotated with @Before by @After
this test is not necessary because it is annotated with @Before by itself.
this test is not necessary because it is partitioned file.
nit: space between ) and!
suggestion if (relatedItems.get(0)!= null) {
nit: space after (
@vmaletta assertEquals will be more elegant
@vmaletta add static import
@vmaletta assertEquals will be more appropriate
You can reduce this to a single line return monitors.stream().map(monitorName -> monitorName.replace(OLD_METAMX_PACKAGE_NAME, NEW_DRUID_PACKAGE_NAME)).collect(Collectors.toList());
You can reduce this to final List<Class<? extends Monitor>> monitorNames = new ArrayList<>(); for (String monitorName : monitorNames) { final String effectiveMonitorName = monitorName.replace(OLD_METAMX_PACKAGE_NAME, NEW_DRUID_PACKAGE_NAME); throw new RuntimeException(conflicte); }
You can reduce this to a single line return monitors.stream().map(monitorName -> {.... });
Let's put requireNonNull around this.
Let's put requireNonNull on this.
requireNonNull
lookup in the multimap here
aspectClass
why not just use aspectClass
You can replace the for loop with handleIds.forEach(HandleId::close);
You can replace the for loop with handleIds.forEach(HandleId -> handleIds.next())
You can replace the for loop with handleIds.forEach(HandleId -> handleIds.next());
"Successfully wrote header" in this case?
"Successfully wrote header" -> "Connection header"
"Successfully wrote header" in this test.
Why didn't you add it here?
Why didn't you add it to 'f' like the 'param name?
Why didn't you add it?
@Suseika hm.. looks like code duplication to me. how about this: if (this.users.containsKey(user) && this.users.get(user).equals(pwd)) { } else { }
@Suseika hm.. looks like code duplication to me. how about this: if (this.users.get(user)) && this.users.get(user).equals(pwd)) { } else { }
@Suseika hm.. looks like code duplication to me. how about this: if (this.users.containsKey(user)) { //... } else { //... }
You could provide this as a method in KoreUtil so if the logic for isServiceSupportedByKore(tag.getMetadata().getServiceId()) should work
You could provide this as a method in KoreUtil so if the kodi button is centralized and not copied over 3 places.
You could provide this as a method for showKodiButton
not sure why we need this.
not sure why we need to have this.
again.
shall we have try-with-resource?
shall we add debug log here as well?
shall we add debug log here like this?
This block was removed.
This is not necessary, right?
This block was removed. Let's remove this.
We can shorten the code by removing Optional<URL> historyServerURL = historyServerURL.map(URL::toString).orElse("");
We should also log the exception.
We should further simplify the code by removing the return empty string and returning the empty string.
same here as unpacker.unpackMapHeader()
same here, unpacker is not necessary. Please remove it.
same here, unpacker is not necessary. Please remove it
can we explicitly have a test that verifies the order of the parameters, and make sure it's the same order?
Why is this assertion necessary?
can we explicitly have a test that verifies the order.
Previous version checked T as well here. By the way, there is something basic I don't understand here. Since Instances table has all the TaskColumns as well, does it mean that all those values are always in sync? Shouldn't we always test both tables for those values then?
Previous version checked T as well here. By the way, there is something basic I don't understand here. Since Instances table has all the TaskColumns as well, does it mean that all those values are always in the right transaction? Shouldn't we always test both tables for those values then?
Previous version checked T as well here. By the way, there is something basic I don't understand here. Since Instances table has all the TaskColumns as well, does it mean that all those values are always in the right order? Shouldn't we always test both tables for those values then?
Could be simpler to do: Map<String, String> map = new HashMap<>();
Could be simpler to do: Collections.singletonMap(key, ", "value");
Could be the order of the headers
can we move this to the "else" block?
can we move this to the else block block?
can we move this to the else block?
assertEquals(excpected, actual)
assertEquals(excpected, actual)?
assertEquals(excpected, actual) would be better
nit: you can use checkpointStorage::getCheckpointType()
nit: you can get rid of the negation and just use takeSnapshotSync() directly.
nit: you can get rid of the negation and just use takeSnapshotSync(Duration)
s/x/partitionKey/.
s/x/partitionKey/
s/x/partitionKey/?
No auditlog and throw here; we can at least log the actual exception too.
No auditlog and throw here.
No auditlogRequestException
how do you handle "BEGIN" here?
how do you handle "BEGIN", not "stop" here?
how do you handle "BEGIN", not "Heads"?
This should be a fail() with a 500, and catch it with e.getMessage().
This should be a fail() with a 500, and catch all exceptions in the test method
Use fail() instead of e.getMessage().
Suggest moving the call to reset() (and return it in the if block).
Suggest moving the call to reset()
Suggest making this method synchronized.
This logic looks like a lot of logic that can be factored out. Not sure if it's worth doing it.
This logic looks like a lot of logic that can be factored out. Prior method, no need to override the listener method or do an addEventListener.
This logic looks like a lot of logic that can be factored out. Prior method, no need to override the listener method or do an assert in the if statement.
java /** * @ tests void testNoAlignment() {... }
java /** * @ tests void testNoAlignment() {.... } @Test public void testNoAlignment() {... }
java /** * @ tests void testNoAlignment() {.... }
We should log this properly too, no?
We should log this properly too, I think.
We should log this with a warn
nit: unrelated change
Nit: unrelated change
Optimize editor
Map instead of concrete type
Map instead of concrete class
Map instead
should be mAirplaneModeObserver!= null before this
should be mAirplaneModeObserver!= null before setting the flag
should be a class field
please use Cluster#hasGateway
please use ClusterDeletionBasedExitCriteriaModel
please use Cluster#getGateway
You can avoid declaring a local variable and just return on the next line.
You can avoid declaring a local variable and just return on the next line
You can avoid declaring a local variable and just return eventConsumers.values()
Style inconsistency: space after 'if'
Style inconsistency: space after 'ListModel'
Style inconsistency: space after comma
It's better to log the complete sentence there, something like "Recovering LUN device size: {0}, previous size: {1}, new size: {2}.",
It's better to log the complete sentence there, something like "Recovering LUN device size: {0}, previous size: {1}", lunFromMap.getDeviceSize());
It can be static
Let's change the spelling of the "reopen" to "reopen"
Why not just move the'reopen' string to the end of the file?
Why not just move the'reopen' string to the end of the string?
Maybe easier to include the segment id in the exception message
Can this use a regular while loop?
Can this use a similar method to getSegment()?
If we need to pass in a list of hits, use the provided one rather than System.err
If the syserr is meant to be the log, keep the stack trace.
If the log4j log is meant to be the standard log file, keep the log clean
The method should be private.
The method should be private
The method should be protected.
If this dialog is already closed, I would add a NullProgressMonitor to the export dialog, and compare the selection before opening the dialog.
If this dialog is already closed, I would add a NullProgressMonitor to the export dialog and compare the selection before opening the dialog.
If this dialog is already closed, I would add a null check before it.
We should use android.R.string.ok.
We can use attach(AuthenticatedWebViewFragment.this) instead.
We can use attach(AuthenticatedWebViewFragment.this) here.
Missing braces.
Ticks don't line up. The method body consumes 75 ticks.
This is unused.
you should set the default constructor, don't need to concatenate strings
you should set the default, i.e. make sure the row alias is not null
you should set the default, i.e. true
change the name to 'network'
Better change the name to 'network'
change the name to ENROLLMENTS
I think that also the tests are wrong. What about to do it by using @Rule public void setupResetChanges() { Properties props = new Properties(); try { properties.putAll(mojo.project); } catch (DateFormatException | SomeOtherException e) { assertEquals("expected", "result", e); } }
I think that only the tests are executed if the () is missing.
I think that also the tests are wrong. What about to do it now?
This should be new Linkifier(TestGitilesUrls.URLS, expected).
This needs to be in the same order, no need to break the test
This needs to be assertEquals(String message, String expected, String actual)
This doesn't look like an exception is thrown.
This if statement is redundant.
This doesn't look like it should be an exception.
why not use getImagesToCheckDestinationMap.put(image.getId(), makeNewImage(image, image));
why not use getImagesToCheckDestinationMap.put?
why not use getImagesToCheckDestinationMap.put instead of so many times?
This is not the same as the field. Please pass all of this logic to getAttributeValue(sess, user, A_U_D_preferredMail) and add this check to getAttributes().
This is not the same as the method getAttributeValue(PerunSessionImpl)
This is not the same copy.
can be: final Contentlet reward = new banner2 = new LanguageDataGen().nextPersisted();
can be: final Contentlet engine = new LanguageDataGen().nextPersisted();
can be: final Contentlet reward = new banner2 = new LanguageDataGen().nextPersisted(); T publisher2 = supplier.getBannerLikeContent(true, language1, null);
Are we missing new methods here? Can this be made private?
Are we missing the String.format?
Are we missing Platform.ID here?
This could be moved inside GroupDbAccessManager#select()
This could be moved into a separate method.
This could be moved into a separate method
400 errors are Bad Request errors which are usually populated as IllegalArgumentException errors.
Can we add a check so this only applies to the version negotiation requests, and propagate the exception otherwise?
Can we add a check so this only applies to the version negotiation requests, and propagate the error otherwise?
Don't need to be in a catch block, only one catch is good enough
Don't need to be in a catch block, only one catch is good enough.
Don't need to be in catch clause
I think this would be better as: java if (!queryParameters.isEmpty()) { return ""; }
I think this would be better as: java if (queryParameters.isEmpty()) { return ""; }
I think this would be better off as: java if (queryParameters.isEmpty()) { return ""; }
After that line, you're asserting that olf.f.exists() is equal to olf.f.exists(), so it's a lot more readable.
After that line, you're asserting that olf.f.exists() is equal to olf.f.exists(), so it's a lot clearer to call.
After that line, you're asserting that olf.f.exists() is equal to olf.f.exists(), so it's a lot shorter.
I believe we can add a log message here about how long retries are left.
I believe we should catch a specific exception here.
I believe we should add a log message here about how long retries are left.
This should be a field so it gets an instance of DfsPackFile.
This should be an instance of DfsPackFile.
This should be a field on the class.
The error message should be updated to something like "The table expiry period cannot be empty or we try to convert the files to the glob syntax."
The error message should be updated to something like "The table expiry period cannot be empty or we try to obtain the stage."
The error message should be updated to something like "The table expiry period cannot be empty."
Should we add the class name here?
Should this be logged before you declare it?
Should we check the context of the setting of the awsConfig here?
Delegate to the behavior in this test.
Delegate to this
Delegate to the behavior in this case
why setRevFilter() called twice?
why setRevFilter()?
I think you need to mark this as an IOException. Why not just throw it?
I would use Stopwatch it is more readable and gets rid of the ternary.
I would use Stopwatch it is more readable and gets rid of the conditional.
I would use Stopwatch it is more readable and gets rid of the line of code.
Braces
This should be a CoinbaseException
This should be externalized
lets keep things consistent with the connection pool.
Since we are changing connection behavior, should be in the request.
lets keep this one line :-)
Typo?
Typo? OrganizationUrl?
:-1: Space after,
I don't think it is necessary to construct a list of other nodes manually. I would prefer this method. Util method could be used to construct the list.
I don't think it is necessary to construct a new list. I would prefer this method.
I don't think it is necessary to construct a list of other nodes manually. I would prefer this method. Util method could be used here.
I would log an error here.
Please add a space between if and (
Please log an error here.
Should be debug
remove.
remove
forgot to mention the exception
We should mention the exception using the Logger (from ERROR)
forgot to mention the name of the method
Do we think we need to check if queueName is empty or not, instead of assuming we have a message from the queue before it has been initialized?
Do we think we need to check if queueName is empty or not, instead of assuming we have a message from the queue before that?
Do we think we need to check if queueName is empty or not, instead of assuming we have a message from the queue before it has been set?
I'd also change the assertion to assertion with property name. I'd go with property name now.
I'd also change the assertion to assertion.assertTrue(taskProps.getProperty("someProperty")
I'd also change the assertion to assertion with property name. I'd go with property name.
If read fails, why is this always true?
If read fails, why is it always returning null?
If read fails, why is it always returning null? Also read should be read already?
I don't think it's the right place to do this.
I don't think it's the right place to do this. Suggest removing this if-else branch.
Don't need this.
I'd left this as-is because we don't want to have a single error message for the authorisation
I'd left this as-is because we don't want to have a single error message for our authorisation. We can discuss how to handle this.
I'd left this as-is because we don't want to have a single error message for our authorisation. This will just cause us to get the information about what's missing, no?
shouldn't you return temp boolean here?
shouldn't it be if(!validateSpaceRequirements())?
shouldn't you return false at this point?
please implement equals() to provide debugging state information for debugging purposes.
serverTemplate.getId()!= that.serverTemplate.getId()
serverTemplate.getId()!= that.serverTemplate.getId()?
why not check if the backup file delete succeeded?
why not check if the backup file exists?
why not check if the backup file delete succeeded?
Might be worth adding a fail() here.
Might be worth checking that the upper bound is exactly what you expect?
senderoAndWait
@sopel39 sueggestion: Is this one still needed? I think this one is a different way to handle this.
@sopel39 sueggestion: Is this one still needed? I think this one is a different thing than the one in a PR?
@sopel39 sueggestion: Is this one still needed? I think this one is a different on a CI server? If so, we should throw an exception instead.
replace with checkArgument: isAtLeastSqTablesEnabled(kind, Kind.INTERFACE, Modifier.STATIC, Modifier.FINAL);
replace with checkArgument: isAtLeastSqTablesEnabled(kind);
replace with checkArgument: isAtLeastSq62
should call ch.modifyEvents() here instead ofch.voidPromise()
should call ch.modifyEvents() here.
should it be named something like isEpollChannelEnabled()?
how about this error message instead of e?
how about this error message as well?
how about this error msg instead of e?
I don't think the variable updatedChange is needed here. atomicUpdate returns what the update method of the AtomicUpdate class returns... which here is always null.
I don't think the variable updatedChange is necessary here. atomicUpdate returns what the update method of the AtomicUpdate class returns... which here is always null.
I don't think the variable updatedChange is needed here. atomicUpdate returns what the update method returns, which is also weird.
If we are doing this it means that we will be able to read the tenant ID by system. If we do this it means that we need to be able to read the tenant ID by system. If we do this it means that we need to be able to read the tenant ID by system. In addition, shall we check the status of the request?
If we are doing this it means that we will be able to read the tenant ID by system. If we do this it means that we need to be able to read the tenant ID by system property and then just use the username to get it to the log.
If we are doing this it means that we will be able to read the tenant ID by system. If we do this it means that we need to be able to read the tenant ID by system. If we do this it means that we need to be able to read the tenant ID by system property and then just use the username to get it to get the tenant ID.
Is this really a 400 or is it a 500?
Is it worth adding some logging about the error?
Is this really a 400 or is it a 500? If so, what is the advantage of not logging the error?
Is there a reason to throw IOException instead of IOException?
shouldn't be on DetailedQcStatus?
Is there a reason to throw IOException?
Do you want to keep the space here?
No need to make the variable final, instead of re-creating it here.
Is there a reason we are closing the connection twice?
We should have something like: assertNotEquals( validUrls[i]), "Tenant ID=1");
We should have something like: assertNotEquals(connection, validUrls[i]), "Tenant ID=1");
We should have something like: assertNotEquals(connectionUrls[i]), "Tenant ID=1");
why not set the default value to NIOServerCnxnClass.forName(serverCnxnClass).asSubclass(ooKeeperServerCnxnClass);
why not set the default constructor path to NIOServerCnxnClass.forName(serverCnxnClass) (to NIOServerCnxnClass.forName(serverCnxnClass)), right?
why not set the default constructor path to NIOServerCnxnClass.forName(serverCnxnClass) (to NIOServerCnxnClass.forName(serverCnxnClass.class, SocketChannel.class, ooKeeperServerCnxnClass))
why do you need to cast to String? You can use String.equals()
why not use MultiValue.equals(expectedRow.get(i))?
why do you need to cast to String?
ImmutableMap.of(
ImmutableMap.of
ImmutableMap.of()
Maybe List<LayoutTemplate> templates = Arrays.asList(lt, lt); Just a suggestion
Maybe List<LayoutTemplate> templates = Arrays.asList(lt, lt); Just a suggestion?
Maybe List<LayoutTemplate> templates = Arrays.asList(lt, lt2); Just a suggestion?
How about List<String> filePaths =... if (loadStatusChangedEvent.getNewLoadStatus()) { return loadStatusChangedEvent.getNewLoadStatus() } else { return loadStatusChangedEvent.getMessage(); }
How about List<String> filePaths = new ArrayList<>();
Maybe a proposal, more descriptive name
How about using a for-loop here? java List<RowData> previousTimestamp = (int) (i - lowerBoundary) { // previousTimestamp = iter.previous();... }
How about using a for-loop here? java List<RowData> previousTimestamp = new ArrayList<>();
How about using a for-loop here?
@mbarbieri you could also do something like ParsingErrorCheck".equals(check.getClass().getSimpleName()) here
@mbarbieri you could also do something like ParsingErrorCheck".equals(check.getClass().getSimpleName()) here (RecognitionException e)
Why is this method called ParsingErrorCheck? It is not testing this method.
I assume this is always true here, too?
Did you mean to leave it as a String since it's always an int?
Did you mean to leave it as a String since it's always an int.
What is the reason to validate the results if the queue is empty?
What is the reason to validate the input for the queue here?
What is the reason to validate the results if the queue is not in the queue?
I think you need to rewind the copyBuf reader's index, otherwise it might only print the part of the buffer that's unread.
I think you need to rewind the copyBuf reader's index, otherwise it might only print the part of the buffer that's unallocated.
I thought you were going to rewind the copyBuf reader's index, but it might be worth a note.
What does this change do?
Maybe a bit shorter?
What is this?
Don't use literals for node's reasons, so it should be ok.
Don't use literals for node's equals() (as it looks to me)
Don't use literals for node's equals() (as it looks wrong)
Is this needed? It looks like you've removed all the occurrences of this in this PR.
Is this needed? It looks like you've removed this.
Is this needed? It looks like you've removed all the occurrences of this in the PR.
Is there a guarantee that the resultFilePath is an HDFS path?
Is there a guarantee that the path is an HDFS path?
Is there a guarantee that the resultFilePathFilePath is an HDFS path?
since this is not initialized, better to save it to a variable
since this is not initialized, better to save it in a variable
since this is not initialized, better to encapsulate it in an interface
this logic should go in the HistoryButtonBuilder
this logic should be part of the if/else
this logic should go in the HistoryComponent logic
Can you please add className to error message?
Can you please add className to error message as well?
can you please add className to error message?
This is awkward as a singleton. Strongly prefer new.... In particular, it makes it possible to edit the singleton state without going through Network which makes the code harder to explore and reason about. Instead, expose a getter or, better yet, have Network offer the register methods directly and forward them internally.
This is awkward as a singleton. Strongly prefer new.... In particular, it makes it possible to edit the singleton state without going through Network which makes code harder to explore and reason about. Instead, expose a getter or, better yet, have Network offer the register methods directly and forward them internally.
This is awkward as a singleton. Strongly prefer new.... In particular, it makes it possible to edit the singleton state without going through Network which makes the code harder to explore and reason about. Instead, expose a getter or, better yet, have Network offer the register method to do so.
the test should check the deleteIdempotencyCheckOp.
Too much indentation.
Too much indentation..
Please change this to spriteBase.move() and remove the call to setChanged().
Please change this to spriteBase.move() and remove the call to notifyObservers().
Please change this to spriteBase.move() and remove the line below
Extract the building of the ResponseMessage to it's own variable?
Extract the building of the ResponseMessage to it's own variable in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable in eclipse/ select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
@vilchik-elena minor: this could be done in [assertTrue(!scanFileForIssues.isEmpty())](<LINK_0>
@vilchik-elena minor: this could be done in [assertTrue(!scanFileForIssues(FILE, MESSAGE).withCost(42));
@vilchik-elena minor: this could be done in an else block
part of this code could be pulled out into a method that is used by both checking and checking the result.
Was this supposed to be removed? I'm not sure how this code was supposed to be working.
part of this code could be simplified using Jatter annotation.
Do not use union() to merely set the min value. Use setMin() instead. suggestion BlockRegion region = new BlockRegion().setMin(mins.get(i)).union(max.get(i));
Do not use union() to merely set the min value. Use setMin() instead. suggestion BlockRegion region = new BlockRegion().setMin(mins.get(i)).union(max.get(i)).setMin(max.get(i));
Do not use union() to merely set the min value. Use setMin() instead. suggestion BlockRegion region = new BlockRegion().setMin(mins.get(i)).union(max.get(i));
This should be allowed as a Set
This should be called outside the if block
This should be called outside the if block.
![MAJOR](<LINK_1> 'Severity: MAJOR') Change this condition so that it does not always evaluate to "false" [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Change this condition so that it does not always evaluate to "false" [![rule](<LINK_1>](<LINK_2>
How about returning an empty map instead of null?
Remove this try/catch and return null
Why is this catch block necessary?
Why throw IOException here?
1. Why do we need double conversion? What happens when the column isn't a float? 2. Why do we need double conversion?
1. Why do we need double conversion? What happens when the column is null? 2. Why do we need double conversion?
It looks like the default case can be removed.
can be replaced by List<IMember> list = Arrays.asList(membersToPushDown);
can be replaced by List<IMember> list = new ArrayList<>(membersToPushDown);
rename to type
can you explain why this check is no longer needed?
can you explain why this check is throw?
can you explain why this check is not done?
You should be able to run.toLowerCase() in here.
You should be able to run CacheManager.startAllServices() in parallel.
You should be able to run.toLowerCase() in order to make sure that the toLowerCase() is valid
won't this be package-private?
isn't package private?
isn't this package private?
@sebing we put a space after the brackets
@sebing should this be a class variable?
@sebing we put all of this in a private static variable
You're using String.format here, perhaps you should use %s?
Again, please report an extension in the string.
String.format?
This should be changed to a.getMemberships()
This should be changed to a.equals()
This should be changed to an enum
Why add empty string?
StringUtils.EMPTY_LIST
StringUtils.EMPTY
This throws an IOException at line 110 and be removed. The finally block is doing Utils.deleteQuietly(toFile);. We may use that in both places.
This throws an IOException at line 110 and be removed. The finally block is doing Utils.deleteQuietly(toFile);.
This throws an IOException at line 99. The specific error cause is OutOfMemoryError rather than a runtime one. We could use that in the finally block.
Could we get the table descriptor back into the system?
Could we get the table descriptor back into the source?
Could we get the current exception?
A knowledge of the code is obscure here. I think we should use target.collation = theQuery.collation; target.collation.addAll(theQuery.collation);
A knowledge of the code is obscure here. I think we should have target.collation = theQuery.collation; target.collation.addAll(theQuery.collation);
A knowledge of the code is obscure here. I think we should use target.collation.addAll(theQuery.collation);
can you please explain why to put false? the absent of property is a good marker... what is it used to?
you must begin all in if already authenticated so you do nothing....
can you please explain why to put false? the absent of property is a good marker... what is it used for?
is this conditional necessary?
is this condition necessary?
is this check necessary?
Looks like you missed a space after the {
Looks like you missed a space after )
Looks like you missed a space after the { here.
Does this need to be public?
Is this correct? At least for me, it should be TimePeriod.DEFAULT.
Does this really need to be public? At least for me it should be private.
if this is in the condition in your tests, how about using your getClass().getSimpleName() method instead of the package name?
if this is in the condition below, how about using Assert.assertTrue()
If this is in the body in your tests, how about using your getClass().getSimpleName() method and removing the package prefix from the tests?
Can't we just use checkArgument? This is much nicer...
Can't we just use checkArgument? This is much nicer in the general case.
Can't we just use checkArgument?
Would a query break here?
Would a query break here by some words?
Would a query break here down at the end?
Don't we handle this case as well?
Don't we want to print resource ID as well?
Don't we already have a get method that does this?
abbrevs is not enough. I would opt for FeatureHit or enumerations.
abbrevs is not useful. I would opt for FeatureHit or enumerations.
abbrevs is not useful.
Since this and the tumorFwdPosMedian check already have been moved down to the beginning, I think it's cleaner to have a single method that accepts a boolean as parameter to this boolean, and then returns true if it's not null.
Since this and the tumorFwdPosMedian check already have been moved down to the beginning, I think it's cleaner to have a single method that accepts a boolean as parameter to this condition, as it returns true when the parameter is set.
null check
For readability. Same for other checks suggestion Preconditions.checkState(arguments.contains(column), "The arguments of transform function '%s' should not contain the destination column '%s'", transformFunction, column);
For readability. Same for other checks suggestion Preconditions.checkState(arguments.contains(column), "The arguments of transform function '%s' should not contain the destination column %s", transformFunction, column);
For readability. Same for other checks suggestion Preconditions.checkState(!arguments.contains(column), "The arguments of transform function '%s' should not contain the destination column '%s'", transformFunction, column);
Why this is also done by union operator?
Why this is also done by union operators?
Why is this change required?
you have a generic try/finally block here for completeness I guess.
you have a generic try/finally block here for completeness
you have a finally block with this method
Name 'queueName' is not needed because we're not doing anything with a MessageView.
Name 'queueName' is not needed because we're not doing anything with this.
Name 'queueName' is not needed because we're not doing anything with a value object.
Braces
Braces are missing.
braces
I think we can remove this 'if' since it is a byte array
I think we should remove this 'if' since it is a byte array
I think we should remove this 'if'
rename to occurrence
rename toOccurrence
rename
A matter of taste, but I don't think it really matters. What do you think about doing canvasHandler.getContent() instanceof Definition and just call getContent() here?
A matter of taste, but I don't think it really matters. What do you think about explicitly calling a method that does what you need?
Missing final
is there a reason we can't use getType() here?
is there a reason we can't use MessageConverters for this?
is there a reason we can't use 'Argument'?
Please remove System.out.println from tests.
This test method doesn't seem to be testing anything.
Please remove System.out.println from test methods.
Catch Exception instead of Throwable.
Getter should be a static variable.
RuntimeException?
need space after if
space after if
need space after if.
should be 'ddf.home'
should be ddf.home
should be ddf.home
please use asGuid() instead of asGuid()
please use asGuid() instead of asGuid(disk.getId())
please use asGuid() instead of asGuid()()
this is strange to me
replace 2 with InputSymbols
replace 2 with distinct
if (!currentCase.getSecond().isEmpty()) { switchStructure.add(oneSwitchCase); }
@vilchik-elena Suggested implementation to avoid having to declare the list as final.
you can use diamond operator here
This line should have a line break.
Use  GL11.GL_SRC_ALPHA, PLICYYINVOCATION
This is a bit redundant, with the line below you can just call disableStandardItemLighting()
We should also catch the exception in case of the exception
We should not catch this exception
We should also catch the exception
this change is not going to be in the future?
this change is unrelated to the PR.
this change is not going to be in the future? I can see just one more principal there.
By the way, I understand if the vertex.getValue() and vertex.getNumEdges() are not empty, but in this case, it looks like it is always empty.
By the way, I understand if the vertex.getValue() and vertex.getNumEdges() are not empty, but in this case, it seems to me that the code below will query the complete vertex multiple times, but let's handle it first.
By the way, I understand if the vertex.getValue() and vertex.getNumEdges() are not empty, but in this case, it seems to me that the code below will query the upper bound vertex.getSuperstep() again.
If you removed Optional from shardDeltaMap, this check can be simplified as: java return createPageSource( context, hiveFileContext, columns, predicate, attributes, transactionId, columnTypes); Same for the below one.
If you removed Optional from shardDeltaMap, this check can be simplified as: java return createPageSource( context, hiveFileContext, columnNumber, columns, predicate, attributes, transactionId, columnTypes); Same for the below one.
If you removed Optional from shardDeltaMap, this check can be simplified as: java return createPageSource( context, hiveFileContext, tableSupportsDeltaDelete, bucketNumber, columns, predicate, attributes, transactionId, columnTypes);
here you may want to partition the list of blobs, as opposed to the size
here you may want to partition the list of blobs, as opposed to the list size
here you may want to partition the list of blobs, as opposed to the size of it
Revert
Revert.
Revert?
one more :-)
final
final?
Is it possible to merge multiple groupers with same name?
Is it possible to keep this method private?
Is it possible to merge multiple groupers with same name, like totalDictionarySize + maxDictionarySizeForCombiner? I feel like it would be worth having a method for this, like updateMergeDictionary
Maybe use non-zero as parent.
Maybe use non-zero as parent?
Was this intended?
what are these tests doing here?
This _is_ wrong with an estimation on the number of instances returned by the user. We need to know what the actual amount we're testing.
This _is_ wrong with an estimation on the number of instances returned by the user. We need to know what the actual amount we want to test.
What is the purpose of this test? Are we interested in how often exactly the slicer is called? For the client, yes, I can see the point of this test where we have more than one slicer that has something to do with a slicer.
What is the purpose of this test? Are we interested in how often exactly the slicer is called? For the client, yes, I can see the point of this test where we have more than one slicer?
What is the purpose of this test? Are we interested in how often exactly the slicer is called? For the client, yes, I can see the point of this test where we have more than one slicer that has something to do with a slicer...
This API shouldn't be visible in the test.
This API shouldn't be visible in the test. These variables are local variables and they should be final.
This API shouldn't be visible on the user.
I think it would be better to create the driverContext in the constructor and move driverContext initialization inside the constructor.
I think it would be better to name it createMergeOperator, createPartitionOperator, and move the call to factory.createOperator.
I think it would be better to name it createMergeOperator, createPartitionOperator, and move the code below it here.
That is confusing. You are adding the conversion context to the queryCustomizer in order to those 2 parameters.
That is confusing. You are adding the conversion context to the queryCustomizer in order to those two methods.
That is confusing. You are adding the conversion context to the queryCustomizer in order to those 2 parameters, but the ones on the other side.
Can we at least log something if no retry is found?
Can we at least log something if you don't use System.out?
Can we at least log this instead?
I think this one needs to be unsigned
I think this one needs to be unsigned
seems to be this one needs to be unsigned
can you also append operationTimeMs?
why V1 is removed?
why V1 is removed? I dont think that you need to partition everything.
Same as above, we should test that the result is correct.
Same as above, we should test that the result is correct as before
Same as above, we can use Wombat's testType.
You're changing the behavior, but I think you can use SWTBotUtils.waitForJobs() instead.
You're changing the behavior, but I think you can use SWTBotUtils.deleteProject()
You're changing the behavior, but I think you can use SWTBotUtils.deleteProject() to fix it.
"Idf" should be a constant
"Idf" should be a constant.
"Idf" should be " parameter".
This doesn't seem to work for the view id. Wouldn't it be possible to only use the viewId of the view object? Also, I would not use any viewId like this: primaryId = viewId.substring(0, index);
This doesn't seem to work for the view id. Wouldn't it be possible to only use the viewId of the viewId? Also, I would not use any viewId like this: primaryId = viewId.substring(0, index);
shouldn't it be the view id? Btw, I would not use the view id here
Could the condition be just if (hasMutable) and not?
Could the condition be just if (hasMutable == true) and not much else?
Could the condition be just if (hasMutable == true) and not?
Suggest to add a retryAttempt = -1 to make it consistent with the rest of the code.
Suggest to add a retryAttempt = -1 to make it consistent with the rest of the code. That way we only end up with / request/request.
Why this change?
You should rename the all these variables to authenticateHeader
You should rename the all these variables to just "construct" and "this" to be honest.
You should rename the all these variables to the context.
I know it is not part of this test, but we can get rid of the duplication with this one: java assertThat(copied.hasUnresolvedTypeHierarchy()).isExactlyInstanceOf(Symbol::kind).map(Symbol::kind).collect(Collectors.toList());
I know it is not part of this test, but we can get rid of the duplication with this one: java assertThat(copied.hasUnresolvedTypeHierarchy()).containsExactly(() -> { copied.hasUnresolvedTypeHierarchy(); List<String> copiedSpec = copied.declaredMembers().stream().map(Symbol::fullyQualifiedName).collect(Collectors.toList()); assertThat(columnName -> assertThat(result)); });
I know it is not part of this test, but we can avoid it by refactoring this method to avoid duplication with this one.
I think this should be made final and the following lines are not really needed.
I think this should be made final and the following lines are consistent, GlideExecutor cannot be null if we're doing something on a previous line.
I think this should be made final
This log message is quite long, maybe at least include the value of the filter.
This log message is quite long, maybe at least include the name of the filter.
This log message is quite long, maybe at least include the name of the query strategy.
why not for(int i=0; i<2; i++) {
why not for(int i = 0; i < 2)?
why not for(int i=0; i<2; i++) {... }
I understand this number of times, but did it mean that we can't use a thread timeout anywhere?
I understand this number of times, but did you intentionally remove it?
I understand this number of times, but did it mean that we can't use a thread timeout like this?
This is fine, but how about this: this.login = Objects.firstNonNull(Strings.emptyToNull(gitHubUser.getEmail()), author.getName());
This is fine, but what you want?
Why checkstyle?
You can return the actual type DTO type.
You can return the actual entity type.
You can return the actual type DTO type here
Do you think we should send a taskLauncher to the taskLauncher? Something like: java if (nodeConnected && isPAMR &&!isPAMR) {... } catch (Throwable t) {... }
Do you think we should catch Throwable?
Do you think we should catch Throwable here?
This is why we need to set the offset of the ContentProtos.SegmentEvent as it's own field, right?
This is why we need to set the offset of the ContentProtos.SegmentEvent as is. If there is a separate field, we could use the visibility of the ContentProtos.SegmentEvent as well.
This is why we need to set the offset of the ContentProtos.SegmentEvent as it was before.
This message is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message
This message is not valid for getReplicas, but maybe it's not worth changing, since it will be handled as well.
This message is not valid for getReplicas, but maybe it's not worth changing.
Why is this necessary?
Please use StandardCharsets.UTF_8 instead.
Please use StandardCharsets.UTF_8
You don't need to pass in null.
You could try to use Optional.ofNullable() instead.
suggestion
Is there a possible race condition here where multiple threads could read the same file?
Is there a possible race condition here where multiple threads could read the same file and have the same file in the same file?
Is there a particular reason why we need to call sd_pipe.available() in the loop loop?
This is now unnecessary.
This is now not used anywhere else.
This is not used anywhere else.
Can we refactor this into a method?
Can we refactor this to use a string format? parseDatestamp(String line, ParseInformation pos) {
Can we refactor this to use a predefined method from string and call it from number of times?
Why this change?
I don't think this log should be removed. If the user is not connected to the app then they will have no idea why the log should be sent to the server
We can pass the exception in here too.
could we define a long mb = 1024 * 1024?
I would prefer to have a dedicated log method on AbstractRecord.
I would prefer to have a dedicated log message in this class.
use bindings.keySet() instead of calling getScript()
use bindings.isEmpty()
use curly braces
I know this is supposed to work, but I am pretty sure if we can do this inside the Parser. The exception handling code is shows up in the main thread, which is visible to the user.
I know this is common pattern in the agent, but I am pretty sure to have a static pattern.
Why public?
Is it possible to convert BlobProperties and userMeatadata to bytebuf first, and then use Bytebuf bufferToSend?
Is it possible to use getVersionId() == PUT_REQUEST_VERSION_V4 to construct an object? Would it be an error that we need to add an enum check?
Is it possible to use getVersionId() == PUT_REQUEST_VERSION_V4 to construct an object? Would it be an error that we need to add a flag in the interface?
no need to get the host toHaVmsMapping
no need to get the host toHaVmsMapping. This is simpler and more efficient.
no need to get the host toHaVmsMapping.
no System.out please
just remove this system out
just remove this system out in tests
Do we need to check Null of the input?
Do we need to check Null of the rest of the logic?
Do we need to check Null of the rest of the method?
Ditto.getName() comparison.
Ditto.getName() comparison here
Ditto.getName()!= null
i haven't looked at all the edge cases, but can buffer.length() - offset ever be less than 0? if so, i suspect this could throw. is it worth wrapping it in a Math.max(0,...)?
i haven't looked at all the edge cases, but can buffer.length() - count ever be less than 0? if so, i suspect this could throw. is it worth wrapping it in a Math.max(0,...)?
i haven't looked at all the edge cases, but can buffer.length() == 0 be less than or less? if so, i suspect this could throw. is it worth wrapping it in a Math.max(0,...)?
> We have to set this to non-null, it should be passed to the constructor (it doesn't really make sense).
> We have to set this to non-null, it should be passed to the constructor (it doesn't always change the default).
> We have to set this to non-static field
The name of the parameter seems right to me. How about just calling the addObjectInstrumentation(...)?
The name of the parameter seems right to me. How about just calling the addObjectInstrumentation()?
The name of the parameter seems right to me. How about just calling the addObjectInstrumentation(...) at all?
Is this check needed?
Is this the same as "app"?
Is this a different change?
Should it be something like the following? suggestion Set<String> pairsToFill = gson.toJson(queryPairs, Arrays.stream(source.split("&")).collect(Collectors.toMap(p -> p.substring(0, delimiterIndex)));
Should it be something like the following? suggestion Set<String> pairsToFill = gson.toJson(queryPairs, new HashMap<>(source, Map.class));
Should it be something like the following? suggestion.stream(source.split("&" + delimiterIndex + 1));
Why are we returning from the HttpConnectionInterceptorException here?
If some of the functions, then we need to be able to simplify these by using the java switch(statusCode) {... } case HttpURLConnection.HTTP_FORBIDDEN || statusCode == HttpURLConnection.HTTP_AUTHORIED) {... }
Why are we returning from the HttpConnectionInterceptorException?
It would be much easier to follow if we leveraged utils from org.apache.commons.lang.reflect. They seem fit here perfectly :)
It would be easier to follow if we leveraged utils from org.apache.commons.lang.reflect. They seem fit here perfectly :)
It would be much easier to follow if we leveraged utils from org.apache.commons.lang.Reflections. They seem fit here perfectly :)
use StandardCharsets.UTF_8
Isn't it better to also mark all 3 files up?
Isn't it better to also mark all 3 files with this name?
Is this true? I mean, move the birthdateEstimated below the else block
Is this still needed?
Is this true? I mean, move the birthdateEstimated to a separate variable
I lost a lot of changes to this class, as these are not related to this PR. I think there are a few more changes to this class that would be great.
I lost a lot of changes to this class, as these are not related to this PR. I think there are a few more changes to this class that are missing.
I lost a lot of changes to this class, as these are not related to this PR. I think there are a few more changes to this class that would be great. I'll review this.
Can we drop this?
This should probably be private, right?
This should probably be private, as we're not being used anywhere.
Is this meant to be debug?
Is this meant to be ignored?
Why do we want to keep this in here?
nit: space after 'if'
nit: we could name this class (and other places too)
redundant
These strings need to be externalized
This shows you're not using a local view. Something like: "MyTaskReview".
This shows you're not able to display the question.
You're still deploying the chat messages in htsjdk, and 173 in the other cases (at least here it's still enabled for production)
You're still deploying the chat messages in htsjdk, and tracking the player's heads up immediately after clicking it. Is there a reason?
What's the point of this?
Why not just create a real ID by the test?
Why not just create a real object in the test?
Why not just create a real object here?
Could you move it to the "else" of the "if" above?
Could you move it to the "else" of the "else" below?
Could you move it to the "else" section?
I think you want a better line breaking after the previous line.
I think you want isEmpty() check on the line below.
I think you want to also fire mMap instead of fing on it.
The result of this is not used. It could be removed, but for new code it could also be removed.
The PopupMenuAddFormHandler has been deprecated. Please use that instead.
The result of this is not used. It could be removed, but for new code it could be removed.
Could you use ConfigurationItemMap.of() here? Or even better, I'm not even sure what or where :)
Could you use ConfigurationItemMap.of() here? Or even better, I'm not sure if it's a practical reason to use Configuration here?
Could you use ConfigurationItemMap.of() here? Or even better, I'm not sure if it's even possible to use Configuration here.
Curious why you needed to set the action.
Curious why you needed to set the volatile flag?
weird formatting
Can we remove this check and just set the list to null?
Can we remove this check and just set the list to empty list?
Can we remove this check and just set the list to empty list?
nit: please break this line into two
shouldn't drawer.selectFolder be called here as well?
nit: please break this line if (singleAccountMode) {
Can you keep the method order closer to the previous revision, so that the gerrit diffs can match them?
Can you keep the method order closer to the previous revision, so that the google style methods can match them?
Can you keep the method order closer to what it is?
nit: extra space before ) {
are you sure this is necessary?
nit: extra space after )
This should probably be a FilePathUtils.
This should be a static constant.
This should probably be a FilePath.
This doesn't seem right. If there are two possible values for SCHEME_TEL and SCHEME_TEL are set, it will return the first one. This means that SCHEME_TEL is set to 0 (because you're getting the first one). If there is only one allowed account, we need to keep a local variable to set it twice.
This doesn't seem right. If there are two possible values for SCHEME_TEL and SCHEME_TEL are set, it will return the first one. This means that SCHEME_TEL is set to 0 (because you're getting the first one). If there is only one allowed account, we need to keep a local variable to set it to null.
This doesn't seem right. If there are two possible values, it will return null. We need to check for that first.
The same RuntimeException
The same 'L'
The same.
You could use a filter, filter, and filter to make sure that all the cwlPrimaryDescriptor points to the CWL.
You could use a filter here, too, to be consistent with the other method
You could use a filter, filter, and filter to make sure that all the files are there, instead of using a filter
might be cleaner to use a foreach loop here instead of the two nested for loop
might be cleaner to use a foreach loop here instead of the two-liners
might be cleaner to use a foreach loop here
1. You can replace this with assertClusterSizeEventually(...) call in the same test as above. 2. You can create new instance on each test and put it in a method assertClusterSizeEventually(...) with the same name.
1. You can replace this with assertClusterSizeEventually() in the test itself. 2. You can create new instance on each test and put it in a @Before method and call it in the test as well.
1. You can replace this with assertClusterSizeEventually() in the test itself. 2. You can create new instance on each test and put it in a @Before method and call the assertion in the test as well.
[minor] Always add curly braces to conditionals.
[minor] Please put curly braces around the if block
[minor] Please put curly braces around the if
Log the index name here.
Log the index id in the message.
Log the index id here, and above
Collections.emptyMap() could be used here
HashMap.of() could be used here
Collections.emptyMap().
And here, are we OK with catching generic Exceptions?
And here, the error message is misleading.
And here, the code is duplicated by maybeAddAdapter.
if (jsonInfo.equals("err")) {
if (jsonInfo.equals("err")) { It's a good idea to remove this, I'm asking you to push it to master instead.
if (jsonInfo.equals("err"))
I actually liked it more when the line was shorter than 120.
newVm().getCommandType() == Plugged?
I actually liked it more when the line was shorter and more readable.
I would rename this variable to newIds
I would rename this variable to isCompact or isCompact
null check
I think you could add the following codes: SWTBotTreeItem linkedNode = resourcePropertiesItem.getNode(LINKED_ITEM_NAME);
What about other cases? SWTBotTreeItem has the same text and the other two tests already have the same code.
What about other cases? SWTBotTreeItem has the same text and the other two tests already have the same text.
This is unused, so why make it?
This is unused, so why do you want to remove it?
This is unused, so why do you want to reuse it?
Shall we handle the exception as well?
What is the problem with catching the exception?
Shall we move this to a common method?
Could you move the type timestamp and date logic below the constructor?
Could you please add a message in the exception message?
Could you please add a message to the exception?
No, this method should not throw interrupted exceptions.
No, this method should not throw interrupted exceptions. No?
No, this method should already throw interrupted exceptions.
This should probably use Guard methods to also check for null
This should probably use Guard methods to also check for null and empty
This should probably use brackets.
I would prefer to move this logic into the mbean class.
I would prefer to move this logic into the config class.
I would prefer to move this logic into the one above.
Why is this not also NODE?
Why is this not also equals?
Why is this not also NODE?
By defining a encode and decode function to the Format enum itself, this switch statement can be eliminated which improves performance.
By defining a encode and decode function to the Format enum itself, this switch statement can be rewritten, like e.g.: Format.valueOf(format.toUpperCase(Locale.ROOT)))
By defining a encode and decode function to the Format enum itself, this switch statement can be eliminated which improves performance. Also the error handling should be improved, like e.g. catching the not-found string value business.
I think the code in this line is same as if (factModelTreeHolder.getFactModelTuple()!= null) { dmnFilePath.getDmnFilePath(); } else { try { dmnTypeService.call(getSuccessCallback(rightPanelPresenter, scenarioGridModel), getErrorCallback(currentPath, dmnFilePath)); } catch (Exception e) { } }
I think the code in this line is same as if (factModelTreeHolder.getSimulation().getDmnFilePath()) {... }
I think we could have just one if statement in this if clause...
if (segments == null || segments.size() == 1) { throw new FileNotFoundException("No package segment segment: " + data.uri); } else if (segments.size() == 2) { throw new FileNotFoundException("No package segment. " + data.uri); }
if (segments == null || segments.size() == 1) { throw new FileNotFoundException("No package segment segment: " + data.uri); } else if (segments.size() == 1) { throw new FileNotFoundException("No package segment. " + data.uri); }
FileNotFoundException is a subclass of IOException, so there is no need to catch it here.
Simpler proposal: registerResourceInCrossReferencer(sessionResource); It should be equivalent, but putting the adapter at the resource level instead of on one of its root elements (there can be several roots now) feels a little safer.
Simpler proposal: registerResourceInCrossReferencer(sessionResource); It should be equivalent, but putting the adapter at the resource level instead of on one of its root elements (there can be several roots now) feels a bit safer.
Simpler proposal: registerResourceInCrossReferencer(sessionResource); It should be equivalent, but putting the adapter at the resource level instead of on one of its root elements (there can probably be several roots now) feels a little safer.
Separator again :-)
Separator-over?
Separator-over +
It is like a hack. Probably reset() would be a better choice.
Looks like a hack. Probably reset() would be a better choice.
That is like a hack. Probably reset() would be a better choice.
Should this be moved into the method below?
Should this be moved into the method "isSecurePath()" too?
Should this be moved into the method "isSecureFeatureRepo" too?
Keeping variables.
(nit) typo.
Keeping accesses to intermediate list.
@maciekberry here is missing "duplicate"
@maciekberry here is missing "duplicate" symbol.
@maciekberry here is missing }
Could not just be new DefaultTreeItem(new DefaultTree(1), natureParent, natureID).getCell(1)) I think
Could not just be new DefaultTreeItem(new DefaultTree(1), natureParent, natureID).getCell(1)?
Could not just be new DefaultTreeItem(new DefaultTree(1), natureParent, natureID).getCell(1).equals(version)
remove finally {
remove finally
remove finally block
this is a bug, but I think it should be handle both the first and the second.
this is a bug, but I think it should be handle both the original and new properties with the same name.
this is a bug, but I think it should be handle both the first and second properties missing.
Should we assert that the return value of the method is not null?
Should we assert that the return value of the method is not valid?
Should we assert that the returned value contains a specific value?
this should not be an error, it should be logged
this should not be an error, as there's no need to handle the exception
this should not be an error. We should return a boolean instead of an exception.
Use FileUtils.listFiles here as well?
Use FileUtils.listFiles here as well.
Remove this line?
please add the exception as the second argument to log it, otherwise it'll print the stack trace (which is what it was before)
please add the exception as the second argument to log it, otherwise it's not harsh.
please add the exception as the second argument
Arg may not always have a shape. We might have some place holder logic we want to put in here. At least checking for null shapes before you do this would be good.
Arg may not always have an shape. We might have some place holder logic we want to put in here. At least checking for null shapes before you do this would be good.
Arg may not always have an argument. We might have some place holder logic we want to put in here. At least checking for null shapes before you do this would be good.
Does this need to be final?
Does this need to be static?
Does this test have any data? Can we provide the test with multiple metadata?
Wonder if this would work/read better if PDPrintStyle had the default values itself and we could just return early instead of creating new objects to make the rest of the code work properly.
Wonder if this would work/read better if PDPrintStyle had the default value itself and we could just return early instead of creating new objects to make the rest of the code work properly.
Wonder if this would work/read better if PDPrintStyle had the default values itself and we could just return early instead of creating new objects to make the rest of the method work properly.
when would this happen and if it happens then the window will simply have progress indication and actually nothing will happen
when would it happen and if it happens then the window will simply have progress indication and actually nothing will happen
when would this happen and if it happens then the window will simply have progress indication.
This line needs a colon, to make it "TypeId" lower than "TypeId" lower.
This line needs a colon, to make it "TypeId" lower than "TypeId"
This line needs a colon, please.
To be consistent with the other code, is it better to retrieve the items of the given KeyRecord / KeyRecord?
To be consistent with the other code, is it better to retrieve the items of the given key?
To be consistent with the other code, is it better to retrieve the items of the given KeyRecord?
remove 'if'
remove ()
remove
you don't need that line, verifyTitleUrl is already included in the filePage.
you don't need that line, verifyTitleUrl is already tested at the beginning of the method.
I don't think we should need this.
I think we should add a method like this: <LINK_0>
I think we should put the password into a constant like this: <LINK_0>
I think we should include the authentication headers in the this custom format. [here](<LINK_0>
this is an internal error. Not a good idea to use HEAD through the repository builder. Just a nitpick. I'd be happy to push that later into the same method.
this is an internal error. Not a good idea to use HEAD through the repository builder. Just a nitpick. I'd be happy to push that later.
this is an internal error. Not a good idea to use getFullBranchName() instead.
How about using a ringbuffer instead of the linkedlist while we are at it?
The polishing of my head wondering if we could use a different strategy than the [whitespace-ignoring diff](<LINK_0> which can be simplified.
How about using a queue, since this won't be very large?
@pynicolas it looks like we can remove this variable and set it on line 78.
@pynicolas Can you please use org.sonar.api.rules.RuleParamDto instead?
@vilchik-elena Why not use the description?
why was this removed?
Why was this removed?
why remove this?
This may be more readable with a single if-else.
This may be more readable with a single call to the non-null method.
This may be more readable with a single call to the non-method.
you can move this else block outside of the if
you can move this else block to after line 110
you are modifying it anyway
Add an assertion to check that the new container is no longer set
Add an assertion to check that the new container is no longer set to 2048?
Add an assertion to check that the new container is no longer set as a default one
Hopefully this does not happen often.
Hopefully this will return a file which is not available.
Hopefully this does not work.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AS1481)
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this use of System.out or System.err by a logger. [![rule](<LINK_2>](<LINK_0>
This will not work correctly for the table. We need to use getAdapter(). Returning the first element in a table may be null.
This will change the semantics of 1. All the other getAllPaths method want to return the first selected file 2. If the table is a table and this method returns the second one with a path of the given file, we can assume that the same one is in the file system.
This will not work correctly for the table. We need to use getAdapter().
s/glusterd/EXISTS/
s/glusterd/hasSucceeded/g
there is no need to check the arguments of the method.
this should throw an exception instead of just logging it.
this should be a warn instead of an error.
this should be a Map<String, List<Object>>.
At this point, the info log should probably be updated.
Once you merge the two checks above, we should not allow null search.
Once you merge the two checks above, we should probably use the info log level and not the info
I don't think this should be needed. We already know that the format is valid for the reader.
I don't think this should be needed. We already know that the format is valid in the old code.
I don't think this should be needed. We already know that the format is valid in the old code. All files created are already initialized as one time time.
.first(Audience.class) ->.getAudience() (audiences do have special handling in command causes)
:bug: this is not clear. I believe this _should_ be one of the paginations, but this PR is mis-merge.
:bug: this is not clear. I believe this _should_ be one of the paginations, but this PR is mis-read.
I would prefer to have the following line as : catch (ClassNotFoundException | IllegalAccessException | NoSuchMethodException e) { return Collections.emptyList(); }
I would prefer to have the following line as : catch (ClassNotFoundException | IllegalAccessException | InstantiationException | NoSuchMethodException e) {
I would prefer to have the following line as it's only a single line.
Why not just assert that new question is OK?
Why not just assert that it's equal to the new question visibility?
Why not just assert that it's equal to the one you expect?
Can this be replaced with a defaultAutoCommit = Boolean.valueOf(db.getProperty("defaultAutoCommit", "true")));?
Can this be replaced with a defaultAutoCommit = false?
Can this be replaced with a defaultAutoCommit = Boolean.valueOf(db.getProperty("defaultAutoCommit", "true")))?
Does this reconstruct the entire content if a new plugin is created? I would have expected there to be a more efficient way to identify the actual data (like the existence of the plugin) without a potential memory allocation.
Does this reconstruct the entire content if a new plugin is created? I would have expected there to be a more efficient way to identify the actual data (like the existence of the plugin) without a reallocation of the data (which is there), but I don't see how this works for me. It may be a good idea to have the representation of the data that is not in the UI.
Does this reconstruct the entire content if a new plugin is created? I would have expected there to be a more efficient way to identify the actual data (like the existence of the plugin) without a reallocation of the data (which is there), but I don't see how this works for me. It may be a good idea to have the representation of the JSON object passed into the PluginDescriptor. Or, to identify the plugin, not the plugin. (Unless users should not have to know if they have a data representation of the plugin.)
I think you can use the ERROR_INVALID_REGISTRATION_DOMAIN
I think this should be ERROR_INVALID_REGISTRATION_DOMAIN
I think this could be an issue.
how about moving the 3rd expression to be before the previous if?
how about having the extra code in the if clause?
how about moving the 3rd expression to be before the else?
If I understand this change right, these changes need to be _necessarily_ deployed to the server first and then the front ends? If that is the case, we need to make sure we remember this fact. It seems like we can _read_ both versions - but write only in the latest version.
If I understand this change right, these changes need to be _necessarily_ deployed to the server first and then the front ends? We need to make sure we remember this fact. It seems like we can _read_ both versions - but write only in the latest version.
If I understand this change right, these changes need to be _necessarily_ deployed to the server first and then the front ends?
Similar to above, this could instead be assertArrayEquals(new byte[] { 0x1, 0x2, 0x3, 0x4, 0x5});
Similar to above, this could instead be assertArrayEquals(new byte[] { 0x1, 0x2, 0x4})
This would need to be a assertEquals(int, int) as these are just expected to be the expected value.
We don't need to get the font for font data. It would be preferable to just set it to the editor's default font when the font is loaded.
We don't need to get the font for font data. It would be preferable to just set it to the editor's default font when the font is created.
We don't need to get the editor from the Preference store. For our reason, I don't think we should just set it to protected.
This should be move to the setup of the ReportExecutionContext.
This should be split of the setup of the ReportExecutionContext.
This should be split into multiple lines, i.e. move this to the setup of the ReportExecutionContext.
The state system scales well. You need to have a test, and test the case where you can get an exception and call refresh() on it.
The state system scales well. You need to do an if check, and call the refresh() method instead.
The event should have the state system's sId.
why do we need a cast here? The logic below seems to reduce the amount of colors it is in the input constructor and not in the input constructor.
why do we need a cast here? The logic below seems to reduce the amount of colors it is in the input constructor and its getter as well
why do we need a cast here? The logic below seems to reduce the amount of colors it would be done in the input constructor
The url doesnt give a sense that the request is to get "metrics". May be something like this? /v2.0/:tenantId/metrics/info", new HttpMetricQueryHandler()
The url doesnt give a sense that the request is to get "metrics". May be something like this? /v2.0/:tenantId/metrics/info", new HttpMetricQueryHandler()?
The url doesnt give a sense that the request is to get "metrics". May be something like this? /v2.0/:tenantId/metrics/info", new HttpMetricMetricQueryHandler()
The other formats are actual formats (HTML or MD) whereas all other formats are actual formats (HTML or MD) whereas the plain-text would be more appropriate here.
The other formats are actual formats (HTML or MD) whereas all other formats are actual formats (HTML or MD) whereas the plain-text would be more appropriate here. Maybe instead of an explicit message?
The other formats are actual formats (HTML or MD) whereas all other formats are actual formats (HTML or MD) whereas the plain-text would be output-only.
@tmjee same here shutdown complexType and complexTypes
@tmjee same here shutdown awaitTermination shutdownNow
@tmjee same here shutdown complexType and CorrelationId
Looks like we will need to remove this line.
Looks like we will need to remove this line. When clicking on the "Translate description" card it will still be added to the "Add description" screen.
Looks like we will need to remove this line?
You can just use the following: java if (connectFuture.isDone()) { handler.cancel(true); }
You can just use the following: java if (connectFuture.isSuccess()) { handler.cancel(true); }
You can do this in the constructor.
I would council you to omit the duplication between "if" and "else" as this is a legacy method.
I would council you to omit the duplication between "if" and "if" statements without braces.
I would council you to omit the duplication between "if" and "else" as this is the only one we need.
How about a test where it fails if no barcode files are found? How about a test if not all the tiles were found? My apologies if they are already there.
How about a test if it fails if no barcode files are found? How about a test if not all the tiles were found? My apologies if they are already there.
How about a test where it fails if not all the tiles were found? My apologies if they are already there.
Would a timeout be better here?
Why have you provided a LTS?
Would a timeout be better fit here?
this change is not required, since this is set in the ctor
this change seems unrelated to this patch
this change is not required, please remove
This can be simplified to just accountByEmailOptional.orElseThrow(Response.Status.NOT_FOUND).build();
This can be simplified to just accountByEmailOptional.orElseThrow(Response.status(Response.Status.NOT_FOUND).build());
This can be simplified to just accountByEmailOptional.orElseThrow(Response.status(Response.Status.NOT_FOUND).build(),
I think it is better to fix the message in the MessagingException directly here, because the lock might be acquired by the same thread.
I think it is better to fix the message in the MessagingException directly because the lock might be acquired by the same thread.
I think it is better to fix the message in the MessagingException directly here, because the lock might be acquired on the same thread.
Why is this called from two places?
Why is this called outside the loop? Also, this should be called only once.
Why is this called from the trade thread?
suggestion Deadline.fromNow(Duration.ofSeconds(10), 20L);
suggestion Deadline.fromNow(Duration.ofSeconds(10), TimeUnit.SECONDS);
nit: suggestion Deadline.fromNow(Duration.ofSeconds(10), DEFAULT);
static import?
static import
ImmutableMap.of()
this is now outside of the if (isImagesAlreadyOnTarget()) scope. is it on purpose?
this is now outside of the if (!isImagesAlreadyOnTarget()) scope. is it on purpose?
this is now outside of the if (isImagesAlreadyOnTarget()) scope. can be extracted to a separate method
Should be.firstMatch(withAdminAccess()).orNull()
Should be _firstMatch_ instead of just _firstMatch_.
Should be removed.
I don't know how this Build works, but can we have a whole project in it?
I don't know how this Build works, but can we a whole MyProject be compatible with the error on project with no compiler compliance?
I don't know how this Build works, but can we have a whole project in it? We may a file for other types in the project.
Just an idea, I will remove it from the old PR.
Just an idea, I will remove it from the old code.
Just an idea, I will remove it from the list without having to worry about performance.
120 isn't needed? IMHO it should be deleted.
Unclear to delete?
120 isn't needed.
what is this change does?
what is this change doing?
what is this change good?
This exception makes no sense to the caller and it will always be false. If you are just sanity checking, throw an AssertionError.
This exception makes no sense to the caller and it will always be false. If you are just sanity check, throw an AssertionError.
This exception makes no sense to the caller and it will always fail. If you are just sanity checking, throw an AssertionError.
Will it be better to put this logic in Configuration#setupConfig() method?
Will it be better to put this logic in Configuration#setupConfig() method? I remember that we want to increase config behavior but not necessarily here.
Will it be better to put this logic in Configuration#setupConfig() method? I remember that we want to increase config behavior but not necessarily to allow that option.
Are we sure we want to keep the previous behavior? i.e., it's not clear to me what's the case?
Are we sure we want to keep the previous behavior? i.e., it's not clear to me what's the most commonly used way?
Are we sure we want to keep the previous behavior for note? i.e., it's not clear to me what's the most commonly used way?
Should be a warning from TTransportException.
I believe we should be returning a LongTransportException here.
I believe we should be returning a Long rather than an int.
Should this return an empty string instead of null?
Should this return an empty string instead?
Will this read better as a Screen.Parser?
isn't the default 2?
isn't the default 2? is the default 2?
isn't the default 2? should we pass in 1?
typo: at row
typo: variable
Line too long
7 is not a constant?
7 is not a constant
7
That's what I meant. But now that I see it I'm asking myself why we don't use diff.getPath here, it returns the old path in case of a directory. It would be useful to be able open a file that was deleted in a commit but was later restored. Could you change it to just use getPath and also change it in Action#run? Sorry about that :).
That's what I meant. But now that I see it I'm asking myself why we don't use diff.getPath here, it returns the old path in case of a delete. It would be useful to be able open a file that was deleted in a commit but was later restored. Could you change it to just use getPath and also change it in Action#run? Sorry about that :).
That's what I meant. But now that I see it I'm asking myself why we don't use diff.getPath here, it returns the old path in case of a file, so I think it would be useful to be able open a file that was deleted in a commit but was later restored. Could you change it to just use getPath and also change it in Action#run? Sorry about that :).
suggestion final DateFormat f = UTC_MILLIS.get();
suggestion logger.write(500)(true);
suggestion final DateFormat f = UTC_MILLIS.get()
Why can't we return here?
Why did this have to be true?
Why is this true?
This isn't what you want. You need to append the name of the interceptors to the entity model - it doesn't matter if you use the type.
This isn't what you want. You need to append the name of the interceptors to the entity model - it doesn't matter if you add the class or not
This isn't what you want. You need to append the name of the interceptors to the entity model - it doesn't matter if you add the class or not.
It might be better to rename PerformanceMonitor line 75: java PerformanceMonitor.startActivity("rendering/copyImageToScreen");
Depending on what we mean with "scene" this might not be correct. I personally do not like the term "scene" but in other parts of the renderer it seems to be used to indicate the 3d scene, as if the final buffer is mostly the end point of a series of 2d post-processing steps: no 3d is involved by the time we get to fill it with pixels and send it to the HMD and elsewhere. So, I'd just call bindFbo() and add the FBO line below.
It might be better to rename PerformanceMonitor line 75: java PerformanceMonitor.startActivity("rendering/copyImageToScreen);
it seems that storeId is unnecessary, can be removed
it seems that diskIOScheduler and DiskSpaceAllocator are already used for useDirectIO
it seems that diskIOScheduler and diskSpaceAllocator are already used for useDirectIO
why was this removed?
why was this removed? it seems to me like it should be removed.
why was this changed?
1. There's no need to load the snapshots if the disks checks hasn't passed succesfully, same way that we don't load the disks if the vm is locked. 2. you should load the images for each of the disks IIRC, take a look on what's being done on ExportVmCommand and handle synchronization with other flows like preview/restore/stateless run.
1. There's no need to load the snapshots if the disks check hasn't passed succesfully, same way that we don't load the disks if the vm is locked. 2. you should load the images for each of the disks IIRC, take a look on what's being done on ExportVmCommand and handle synchronization with other flows like preview/restore/stateless run.
autobixing?
do we need to manually register the handler?
do we need to manually register the query handler?
do we need to manually register the handler? Is it really needed?
can we move this null check into the ProcessorContext constructor (line 488)?
can we pass in the original ProcessorContext and use it here?
can we move this null check into the ProcessorContext constructor (line 68)
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 22 to at most 20. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this anonymous class number of lines from 22 to at most 20, or make it a named class. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this anonymous "StringBuffer" method number of lines from 22 to at most 20. [![rule](<LINK_2>](<LINK_0>
Nitpick: this should probably be t.sendResponseHeaders()
Nitpick: this should be t.sendResponseHeaders()
job_id?
why do you use toString()?
why use toString()?
why use error?
As links[0].rel", "abc" and "https://repo_NAME" are the same.
As links[0].rel", "abc" and "https://server/1/base/com/s2/api/accounts/ results, they don't give you the combined version.
As links[0].rel", "abc" and "https://repo_NAME" are the same gives you the combined version. Thus, it doesn't make sense to combine the two with a single request.
isPmKdumpDetection == other.isPmKdumpDetection() and vdsType == other.changes?
isPmKdumpDetection == other.isPmKdumpDetection() and vdsType!= other.sshPort?
isPmKdumpDetection == other.isPmKdumpDetection() and vdsType == other.sshPort?
Can we get the logic of SortOrder.DESCENDING and why is the same?
Can we get the logic of SortOrder.DESCENDING and why is the reverse order?
Can we get the logic of SortOrder.DESCENDING and do the logic in BookieOrder?
Update this file with StringBuilder
Update this file with format.
Update this.
Why does this need to be done?
Why does this need to be done? Can't you just pass the Context object?
Why does this need to be addressed?
If charset is not a valid charset, use UTF-8 instead.
If charset is not a valid charset, use UTF-8 instead: UTF-8
If charset is not a valid charset, use UTF-8 instead: UTF-8?
OK. sounds good. Anybody step up and tell me where to put the code and parameter, and I will happily do the work :)
OK, sounds good. Anybody step up and tell me where to put the code and parameter, and I will happily do the work :)
OK. sounds good. Anybody step up and tell me where to put the code and parameter, and I will happily do the work :) If you don't put it in the context of "Executor" then SshSessionFactory.getInstance().releaseSession(session) we can replace the code and SshSessionFactory.getInstance().releaseSession(session) with a single method that builds the errorThread and returns it. That's a bit hard to follow.
Can you use { } and } else {?
Can you use { } and else {?
Can you use { } here?
assert fail
"assert" is redundant here.
"assert", is redundant here
Probably better to make it package-private for testing.
Probably better to make it package-private for now.
Probably want to make sure: {...}
Strings.isNullOrEmpty, diagramCategory.equals(diagramCategory.equals(template.getLanguage()))
java if ((diagramCategory == null || diagramCategory.equals(template.getLanguage())) {
java if (next instanceof String) { return (String) next; } // then you can delete the above expression.
This function should be private.
This will throw NPE if there is no such part.
This will throw NPE if there is no such part. I suggest removing the exception.
This one does not seem to be used.
This one does not seem to be an efficient way to test for a single file - on the first put the.dat=... and you are 4 more ;)
This one does not seem to be an efficient way to test for a single file - on the first put the.dat=... and you are 4 more 3 access.
I think it would be better to use the EntityType.FEED here instead of EntitySLAMonitoringService.get().getFeedSLAMissPendingAlerts(feedName)
I think it would be better to use the EntityType.FEED here instead of EntitySLAMonitoringService.
I think it would be better to use the EntityType.FEED here instead of EntitySLAMonitoringService.get().getFeedSLAMissPendingAlerts(feedName).
Let's be consistent with use of try-with-resources.
Let's change this to a Continuation?
Let's change this to a callable rather than a callable.
this should be a "schema-version" not a "preamble"
this should be public method
this should be public
are you sure this is the correct way to ignore this?
are you sure the intent of this check is to see whether a start_time has been reached?
are you sure the intent of this check is to be safe?
Do we need to care about the error case here?
Do we need to be careful with this?
Why are we catching an exception here?
Code from line 137 to 154 can be extracted as a private method (createLegacyFile) to avoid code duplication
Code from line 137 to 100 chars, please.
Code from line 137 to 100 chars.
I think this method is called toolbox.getIndexerMetadataStorageCoordinator().updateSegmentMetadata(segments);
It's helpful if this method is called toolbox.getIndexerMetadataStorageCoordinator().updateSegmentMetadata
It's helpful to call this something like segmentMoved/lastUpdated in DataSegment.
Use getLastInsertId(model) method
What is a case when this happen?
Use getLastInsertId(model) method.
Shall we need a config for with WORKFLOW_CONTEXT_KW or something?
Shall we need a config for with WORKFLOW_CONTEXT_KW and use it here?
Shall we need a config for this or can we i think?
prefer readability as there's no real need to split into 2 lines.
prefer readability as there's no real need to split into two lines.
prefer readability as there's no real need to split into two statements.
No permissions needed to make the test pass.
no permissions needed to make the test pass.
No permissions needed to both of those.
I think you added "public" modifier to the method argument as well.
I think this will be better as part of the code path.
I think this will be better as part of the code.
What would you think of suggestion } catch (JsonParseException e) { throw new IOException("The response was not valid JSON.");
What would you think about setting it as a List and then parsing it on the next line?
What would you think about setting it as a List and then parsing it on the stream?
This test would be easier to read if you extract some of the 75 lines of code into a separate method, e.g..userDao.findNotificationSubscribingUsers()
This test would be easier to read if you extract some of the 75 lines of code into a separate method.
This test would be easier to read if you extract some of the 75 lines of code into a separate method, e.g. getIdForPipelineSubscribingUsers()
rename to substitution
better test for both cases
better test for all equality checks
Let's add a default case
Let's add a default statement after the log.
Let's add a default statement here.
Does it make sense to use the default value here?
Does it make sense to use the FileFilter implementation?
Does it make sense to do this here?
do you want to output something here?
do you need a buffer.append(int) here?
do you want to output the result of the cycleLogs?
Maybe it could be the case that the session was not created and this test actually failed.
Maybe it could be the case that the session was not created.
Maybe it could be the default value of args.
Exception is not logged or thrown
:ant: We are not logging or throwing exception here.
:ant: We are not logging or throwing exception
Shouldn't the log level be warn?
Shouldn't the log message be: "Invalid syntax and will not be supported"
Shouldn't the log message be: "Invalid syntax and cannot be supported"
nit: Should we make metricsQuery non-final and change it here (e.g. metrics=...)?
nit: Should we make metricsQuery non-final and change it here (e.g. metrics=request.body().asJson())?
nit: Should we make metricsQuery non-null at this point?
In other places we check that the Files.isDirectory(file) contains the.class, rather than using the class loader to load the class and all the classes.
In other places we check that the Files.isDirectory(file) contains the.class, rather than using the class loader to load the class and all the files.
In other places you put the class name in a final variable outside the loop.
Not sure how to be sure that explicitNulls are not null.
Not sure how to be sure that explicitNulls are not null. "Only gr_id should be " + "
Not sure how to be sure that explicitNulls are always not null.
If you need to pass null in the file, you can use ModListHelper.sortFileList(ObjectArrays.asList(new File[0])
If you need to pass null in the file, you can use [FileListHelper.sortFileList](<LINK_0>
If you need to pass null in the file, you can use ModListHelper.sortFileList(ObjectArrays.asList(new File[0]) here.
(nit) s/still/has/?
(nit) s/still/hasMessage?
(nit) s/still/the same for "if"
The above if statement is not relevant.
The above if was not properly indented
The above if was not properly indented.
This is throwing an IllegalArgumentException, which is not an IAE. This will lead to a NullPointerException.
This is throwing an IllegalArgumentException and the one above a line above this one is not necessary. You could simply move this into this if block
This is throwing an IllegalArgumentException and the one above a line above this one is not necessary. You could simply add the message to this method
above should be validated too.
nit: we can move the check for the made port to the exception message
nit: we can move the check for the made port to the exception message.
is the mini cluster required? starting a mini cluster takes time and prone to flaky failures. Would be nice to avoid using it.
is the mini cluster required? starting a mini cluster takes 5 seconds and prone to flaky failures. Would be nice to avoid using it.
is the mini cluster required? starting a mini cluster takes 1000ms and prone to flaky failures. Would be nice to avoid using it.
I think it should also check if responses are present in output.get()
I think it should also check for the response code.
I think it should also check for the path to define if it is <LINK_0>
unrelated bug fix?
unrelated bug fix.
unrelated to this change
add message to exception
add some message to exception
add some message to error
I would divide this method into 3 methods. One for final aggregation, one for final aggregation, one for mappings. Then you could remove Parts. Parts is not passed anywhere so you don't need such entity.
I would divide this method into 3 methods. One for final aggregation, one for final aggregation, one for mappings. Then you could remove Parts. Parts is not passed anywhere so you don't need such entity
I would divide this method into 3 methods. One for final aggregation, one for final aggregation, one for mappings. Then you could remove Parts. Parts is not passed anywhere so you don't need such entity, and it would be nice if you wouldn't pass it as parameter.
what about conflicts? if a successful connection is specified in the response?
what about conflicts? if a successful connection is specified in the json file?
what about conflicts? or is this a noop?
This check is not needed
This check is not needed.
This check is not necessary.
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_1>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_3>](<LINK_2>![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_3>](<LINK_2>
Why do we need to stopSelector() if we're no longer running accept thread?
Why do we need to stop the selector when we're no longer running?
Why do we need to stopSelector() if we're no longer running accept thread? If this is the case, why not provide a new method stop()
You can put this line into the nextPointers.set method.
You can leave this one with the requireNonNull
You can leave this one with the requireNonNull.
previously it was also 'null' for the operand, but now the operand is not null (although this is not a valid sign). Is this correct?
previously it was also 'null' for the operand, but now the operand is not null (although this is not a valid sign). I'm not sure why you decided to handle nulls in the code later.
previously it was also 'null' for the operand, but now the operand is not null (although this is not a valid sign). I'm not sure why you can't fix it though.
You can use String.join directly.
You can use String.join(String, StringBuilder) instead.
You can use String.join(String, int) directly.
suggestion.filter(b -> isValidCatchBlock(b, 0), ps, true)).findFirst()
suggestion.filter(b -> isValidCatchBlock(b, 0), ps, true));
suggestion.filter(b -> isValidCatchBlock(b, 0), ps, true)) {
No need to call Integer.parseInt(getUuid()) more than once.
You don't need to call Integer.parseInt(getUuid()) more than once.
How sure are you that these values were not already false, even before your changes?
you cannot loop only one time on the full entryset?
You cannot loop only one time on the full entryset?
you cannot respond with a >
This code block is duplicated within the test, it can be extracted to a separate method.
This code block is duplicated within the test, it can be extracted to separate method.
This code block is duplicated within the test, it can be extracted to another method.
Opening a stream without closing it - it is a bad practice.
Catch Exception instead of generic IOException
Space after ",
The key for the properties is unnecessary, we don't have changes in this patch.
The key for the properties is unnecessary, we don't have custom values for it
The key for the properties are not used.
The merge is flipped. You're trying to fill the SneakingData with SneakingData.
The merge is flipped. You're trying to fill the SneakingData with SneakingData. Same for the previous one.
The merge is flipped. You should use the previous one.
Missing "run".
Missing "run" in the error message.
This is not needed.
If you want to make this more explicit then you can add a.setLength(x) method to AbstractTimespanTest.
If you want to make this more explicit, it would be wise to create a helper method in AbstractCheckpointWriter that takes a Builder<T>. And then validate the type of the parameter. This will make it more clear.
If you want to make this more explicit then you can add a.setLength(true) (or a utility method somewhere)
Same here, this should probably be equals.
Add final keyword.
Same here, this should probably be equals().
You could have simplified to (system): Boolean.parseBoolean(args.get("sftpPort"));
You could have simplified to (system): Boolean.parseBoolean(args.get("sftpPort"))
You could extract the three lines in a dedicated private method for (to make it more readable).
Can we have a utility method for this?
Can we have a test instead of catching xpath exception?
Can we have all the logAndThrowException method as this one?
I'd suggest to change this to logger.debug("Unregistering service {} at {}:{} ({})", description.serviceType, instance.getInetAddress().getHostAddress(), description.servicePort, instance.getName());
I'd suggest to change this to LOGGER.debug("Unregistering service {} at {}:{} ({})", description.serviceType, instance.getInetAddress().getHostAddress(), description.servicePort, instance.getName());
I'd suggest to change this to logger.debug("Unregistering service {} at {} ({})", description.serviceType, instance.getInetAddress().getHostAddress(), description.servicePort, instance.getName());
This is an anti-pattern - you should not do.assertNoErrors() in the test. Just a style thing.
This is an anti-pattern - you should not do.from(Arrays.asList(4, 2, 3)) or write something to it
This is a duplicate of line 59, maybe you can extract to a function?
What about: java if (fulltextDescriptor.getFulltextDisabled()) { RowId rowId = new RowId(fulltextDescriptor.getFulltextDisabled());...
What about adding a constant instead of using "binarytext" here?
What about using here: java if (fulltextDescriptor.getFulltextDisabled()) { return null; }
Shall we just use the logger? And extract the error message to a constant?
Shall we just use the logger?
Shall we just use the logger? And extract the error message to a separate method.
same, this is not worth a method with the task-id prefix.
Do we need to do this?
same, this is not that important.
I'm going back and forth on this but actually I think it's best to push this into the Assignor as well, and not *just* because it's more symmetric. I see two arguments for doing it this way: 1) the PartitionAssignor doesn't necessarily know anything about owned owned by the Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer, and the ConsumerPartitionAssignor's subscriptions.assignedPartitionsList() * actually). And actually the ConsumerPartitionAssignor doesn't know about owned owned by the Consumer Consumer, but just a name and not as a property. To address this, I think it would be reasonable to assume/force a **Cooperative** assignor to have some knowledge of owned owned by the consumer. (Or as a side-effect of setting owned by the ConsumerCoordinator) class to have the knowledge of owned owned by the consumer and subscriptions.assignedPartitionsList(); and not the consumerPartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting owned by the ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned owned by the ConsumerCoordinator. I think the first alternative is to transition the PartitionAssignor to an existing assignor, then pass it through PartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting owned by the ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned owned by the ConsumerCoordinator.
I'm going back and forth on this but actually I think it's best to push this into the Assignor as well, and not *just* because it's more symmetric. I see two arguments for doing it this way: 1) the PartitionAssignor doesn't necessarily know anything about owned owned by the Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer, and the ConsumerPartitionAssignor's subscriptions.assignedPartitionsList() * actually). And actually the ConsumerPartitionAssignor doesn't know about owned owned by the Consumer Consumer, but just a name and not as a property. To address this, I think it would be reasonable to assume/force a **Cooperative** assignor to have some knowledge of owned owned by the consumer. (Or as a side-effect of setting owned by the ConsumerCoordinator) class to have the knowledge of owned owned by the consumer and subscriptions.assignedPartitionsList(); and not the consumerPartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting owned by the ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned owned by the ConsumerCoordinator. I think the first alternative is to transition the PartitionAssignor to an existing assignor, then pass it through PartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting owned by the ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned partitions.Imagine we have a heavily stateful app and a consumer sticky assignor which is more promising and allows it to react to anything other than the current assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned owned by the ConsumerCoordinator.
I'm going back and forth on this but actually I think it's best to push this into the Assignor as well, and not *just* because it's more symmetric. I see two arguments for doing it this way: 1) the PartitionAssignor doesn't necessarily know anything about owned owned by the Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer Consumer, and the ConsumerPartitionAssignor's subscriptions.assignedPartitionsList() * actually). And actually the ConsumerPartitionAssignor doesn't know about owned owned by the Consumer Consumer, but just a name and not as a property. To address this, I think it would be reasonable to assume/force a **Cooperative** assignor to have some knowledge of owned owned by the consumer. (Or as a side-effect of setting owned by the ConsumerCoordinator) class to have the knowledge of owned owned by the consumer and subscriptions.assignedPartitionsList(); and not the consumerPartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting owned by the ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned owned by the ConsumerCoordinator. I think the first alternative is to transition the PartitionAssignor to an existing assignor, then pass it through PartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting owned by the ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned partitions.Imagine we have a heavily stateful app and a consumer with a more terse scope to hold a lock for the consumer offsets which is more likely to be over-one-day. Thoughts?
It's recommended to ask the workbench for the display: PlatformUI.getWorkbench().getDisplay()
It is recommended to ask the workbench for the display: PlatformUI.getWorkbench().getDisplay()
It is strange to ask the workbench for the display: PlatformUI.getWorkbench().getDisplay()
I have a concern here, we introduced WorkbenchFeatures.PLANNER_AVAILABLE as local private constant, while WorkbenchFeatures.PLANNER_AVAILABLE is still used in org.kie.workbench.common.workbench.client.authz.WorkbenchDockEntry.createWorkbenchDock(WorkbenchDockEntry.java:33) at org.kie.workbench.common.WorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbench
I have a concern here, we introduced WorkbenchFeatures.PLANNER_AVAILABLE as local private constant, while WorkbenchFeatures.PLANNER_AVAILABLE is still used in org.kie.workbench.common.workbench.client.authz.WorkbenchDockEntry.createWorkbenchDock(WorkbenchDockEntry.java:33) at org.kie.workbench.common.WorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchExecutor
I have a concern here, we introduced WorkbenchFeatures.PLANNER_AVAILABLE as local private constant, while WorkbenchFeatures.PLANNER_AVAILABLE is still used in org.kie.workbench.common.workbench.client.authz.WorkbenchDockEntry.createWorkbenchDock(WorkbenchDockEntry.java:33) at org.kie.workbench.common.WorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchWorkbenchExecutor.create
This is should be moved inside the for loop, to avoid unnecessary checks.
This is not good, but you should use the!isWor() method to check for nulls to avoid NPEs.
This is not good, but you should disable preemption, not be able to get preloads to the server.
nit: "hidden tables cannot be read in this transaction"
nit: "hidden tables cannot be read in these transaction"
nit: might want to pull out the string
This should be done in the validate() method of the DiskControllerType enum. When the function is all the same, DiskControllerType.lsis1068, DiskControllerType.getType() can return null.
This should be done in the validate() method of the DiskControllerType enum. When the function is all the same, DiskControllerType.lsis1068, DiskControllerType.getType() can be static.
Suggestion: For each of these 'else' blocks, try to use the if.
Extract this to a method please
Extract a variable for the filename.
Extract this to a method please.
@dmzaytsev I don't think this can be null. Why not throw an exception instead of logging it?
@vack-shoylev Do you know if the message is null?
@dmzaytsev I think this can be simplified to: java String message = StringUtils.EMPTY;
Why do you use a class name here instead of using a function? It would get the menu's name from the menu.
Why do you use a class name here instead of using a getter? It is cleaner to follow the code pattern
Why do you use a class name here instead of using a getter? It is cleaner to follow the code pattern.
Perhaps we could return an Optional instead of null here?
Perhaps we could return an Optional instead of null?
Maybe we could return an Optional instead of null?
Is it safe to not using epsilon value for comparing double type result?
Is it safe to not using epsilon value in comparing double type result?
Is it safe to not using epsilon value in comparing double type -> double type -> double type -> double
Should also outputExpectsExpiredEvents
Should also outputExpectsExpiredEvents?
Should also outputExpectsExpiredEvents as a boolean parameter
sorry, but Line too long.
sorry, but append now the list is soingly hard to understand.
sorry, but append here the message is so we know how many rows there is in the list.
I'd be happy to have this as: java if (response.getCharge().map(WorldpayOrderStatusResponse::isSoftDecline).orElse(false)) { return worldpayAuthoriseHandler.authorise(request, true); } else { return inlineResponse; }
I'd left this because <LINK_0>
I'd be happy to have this as java if (response.getCharge().map(WorldpayOrderStatusResponse::isSoftDecline).orElse(false)) {
This can be simplified as Assert.assertEquals( resolveResult.kind, InodeMountPointFileSystem)
This can be simplified as Assert.assertEquals(resolveResult.kind, InodeMountPointFileSystem)
This can be simplified as Assert.assertEquals( resolveResult.kind, InodeMountPointFileSystem.class);
Needs null checks.
Needs null checks for size
putString
you could do here itself if(getSelectedItem() == null)
you could do here itself if(getSelectedItem() == null) return;
you could do here itself if(getSelectedItem() == null) return; here
This would deserve a new method not public.
Might want to notional = false here.
This would deserve a protected static method.
This should be parameterized: java for (String g : m_metaGroups) { List<String> mggroups = m_metaGroups.keySet().stream().map(e -> e.append(e).append(","); }
This should be parameterized: java for (String g : m_metaGroups) { List<String> mggroups = m_metaGroups.keySet().stream().map(e -> e.append(e).append(","); for (String n : m_metaGroups) { result.append(g).append(","); } result.append(n).append(" "); for (String n : m_metaGroups) { result.append(n).append(","); } result.append(g).append(n); } ); ] );
This should be parameterized: java for (String g : m_metaGroups.keySet()) { List<String> mggroups: = m_metaGroups.keySet().stream().map(e -> e.append(e).append(","); }
Do we have a test that ensures that a workspace is updated or not?
Do we have a test that ensures that a workspace is not updated?
What does commit mean?
Shouldn't you be using a logger here?
Shouldn't you call fail() here?
Shouldn't you call the constant EXPECT.
Why the change?
Why the change seems to be Level.FINE?
Why the change to Level.FINE?
I think these should be in a finally block on the first line: java fileListView.getItems().add(File.class)
I think these should be in a finally block to fix typos.
I think we should put in a finally block on NavigationHelper.
In this case rather than throwing the RestException here, you can return Status.BAD_REQUEST instead.
In this case rather than throwing the RestException here, you can return the error message here and below.
In this case rather than throwing the RestException here. If the extension is not defined, it should be a RestException and not an RestException.
BUG? Should be log the exception instead of logging it.
BUG? Should be log the exception instead of log it.
BUG? Should be log the exception instead of logging it
Is the check needed in the first step of the upload? Ideally, it can be moved to the last step.
Is the check needed in the first step of the upload? Ideally, this can be moved to the last step.
Is the "prev_upload_" a constant?
It might be worth asserting that the table and update methods are expected to be empty.
It might be worth asserting that the table is expected to be added to the end?
It might be better to add the param to the log?
nit: I think the map is not thread safe. The usage of containsKey is usually not guarantee thread-safe usage.
I think this if is not necessary. The containsKey() method is going to create a new map.
nit: I think the map is not thread safe. The usage of containsKey is usually not guarantee thread-safe usage of the map.
Prefer Assert.assertEquals(actual, loadedVertex.getAttributes())
Prefer Assert.assertEquals(actual, loadedVertex.getAttributes()).
Missing final
if (Build.VERSION.SDK_INT >= 18) {
if(Build.VERSION.SDK_INT >= 18) {
Its not recommended to use an extra parameter here
is this a bug fix?
is that a bug fix?
is that right? recievedFirstRow scheduled
one more test needs to make sure that it is safe to touch only the files that are needed
one more test needs to make sure it is deleting the dir with NFiles
Nice touch! @sjd6t, please fix also on this PR
Shouldn't this throw the exception? Otherwise the caller of this method would end up with the same result.
Shouldn't this throw the exception? Otherwise the caller of this method would be responsible for handling the exceptions.
Shouldn't this throw the exception? Otherwise the caller of this method would end up with the NoSuchMethodException
I think we should be able to handle this <LINK_0>
I think we should be able to handle this case: <LINK_0>
I think we should change the API signature here. Should be STANDD, not 'Password', since it requires a proper 'Password'. <LINK_0>
Is this a *warn* log statement?
is this a *nodo* log statement?
- [x] Make this a LOG.info line.
II think this code was also inherited but I think it can be removed.
II think this code was also inherited but I think it might be clearer if we refactored the code into a method and also re-use the code in the NavigationFragment.
I think this code was also inherited but I think it might be clearer if we refactored the code into a method and also re-use the code in the NavigationFragment.
just a thought, why not newIdentifierName.equals(fetchedIdentifierDisplay))?
just a thought, why not newIdentifierName.equals(fetchedIdentifierDisplay)?
just a thought, why not newIdentifierName.equals(fetchedIdentifierDisplay))
I would put this.sourceIncludes = ScansDirectory.DEFAULT_INCLUDES to the log message.
I'd put this.sourceIncludes = ScansDirectory.DEFAULT_INCLUDES to the log message.
I would put this.sourceIncludes = ScansDirectory.DEFAULT_INCLUDES to the log message. That way we are sure that if the log4j2 will print the old values.
@sakama If we use both idGetter and idGetter, then checking this for you.
@sakama If we use both idGetter and idGetter, then checking this for you. Is that right?
@sakama If we use both idGetter and idGetter, then checking this for you. Is that not enough?
If we're both using Math.min() and Math.max() respectively, the code is still readable.
If we're both using Math.min() and Math.max() respectively, then we could also just use Math.min() for all cases
this is an improvement.
objectCollection is not declared as final.
objectCollection is not declared as final. It will be misleading in the test.
objectCollection is already of type Collection so no need to check object instanceof List please.
Is this change related to the fix?
Is this change necessary?
Is this change related to the patch?
Can this method be private? It should not be accessed outside.
Can this method be private? It should be no longer
Can this method be private?
This value can be static, no need to read it once again.
This value can be static, no need to read it twice.
This value can be static, no need to local variable it twice.
lambda java if (Boolean.parseBoolean(System.getenv("CHE_SINGLE_PORT"))) {
Makes sense to limit to multiple overrides, otherwise default to Java may be more restricted.
lambda java if (Boolean.parseBoolean(System.getenv("CHE_SINGLE_PORT")) {
we're doing this differently, is there a way to save off the value of matchingTaskIds list by using the Collections.emptyList()? I haven't seen that the callers seem to do in this particular case.
we're doing this differently, is there a way to save off the value of matchingTaskIds list by using the Collections.emptyList()? I haven't seen that the callers seem to do in this case though.
we're doing this differently, but we can get rid of the last two assignments to the for loop here.
This should be replaced with a single StringUtils.hashSubRow(tb, new int[] {convertedColumns[j].getBitsPerRow(), hyperCubeDimensions[mappedHCDimensions[j]].
This should be replaced with a single StringUtils.hashSubRow(tb, new int[] {convertedColumns[j]}, i, mappedHCDimensions[j]],
Why not do if (tb instanceof Integer) { return (Integer) obj; }?
We can do this in the PR if we can. If we can't do this in all the plugins, I might be missing something.
We can do this in the PR if we can. If we can give context, I don't think we'll want to do it unless we can.
We can do this in the PR too, maybe we can just use mBounds.
I think it would be better inside the perAPI.getUsers method.
I think it would be better inside the perAPI.getUsers method. This way the logic can be moved outside the lambda and the result is slightly different. The same for that on line 631.
I think it would be better inside the perAPI.getUsers method. This way the logic could be moved outside the lambda and the result is slightly different. The same for that on line 631.
rename to ignored
rename to "ignored"
remove
What is the difference between this if and the else block? Looks like a bit strange.
What is the difference between this if and the else block? Looks like they are always going to be the same. The previous code was a bit hard to understand.
What is the difference between this if and the else block? Looks like they are always going to be the same. The previous code was a bit strange.
this should be an atomic operation since the darkServiceName is already the same as the key
this should be an atomic operation since the darkServiceName is already the same as the darkServiceName
this should be an atomic reference
This might make more sense, but it's not a public method. I'm not sure it's needed (it's just a getter)
This might not be needed, we can remove it.
This might make more sense, but it's not so easy to miss it.
This should be moved inside the constructor
This should be called initializer
This should be called initializer.
Should this be in a try-catch block or so?
Should this be in a try/finally block?
Should this be in a try-catch block or so be removed?
Please add a space after the commas.
Please add a space after the cast here
This change is incorrect.
orElse(null) is easy to read. IMO it is better to use lambda java return resourceSet.createResource(airdResource).map(repResourceURI::getResourceSet).orElse(null);
We don't want to return an empty resource. Consider: airdResource.getResourceSet().stream().map(repResourceURI::getResource).filter(res -> res == null).findFirst()
orElse(null); is better
a copy of the files would be nice here, e.g. if (!ALLOW_SYMLINK_ESCAPE.equals(root.toString().length()) {
a copy of the files would be nice here, e.g. : if (!ALLOW_SYMLINK_ESCAPE.equals(root.toString().length()) {
a copy of the files would be nice, if it was a problem
Please use a different name for the properties here. The properties used to shorten the code is possible to shorten the code.
Please use a more meaningful name for the variables here.
Please use a naming statement for the variables.
This is misleading as the list of fields is not contained at the end. I would synchronize on the exposed field and return it.
This is misleading as the list of fields is not contained at the end. I would test using the "contains" method.
This is misleading as the list of fields is not contained at the end. I would synchronize on the exposed field.
Shoudn't use Response.Status.INTERNAL_SERVER_ERROR as well?
Shoudn't use Response.Status.INTERNAL_SERVER_ERROR as cause here?
Shoudn't use Response.Status.INTERNAL_SERVER_ERROR as cause here.
"Class of class name [" + classId + " is not supported by an trusted source"
"Class of class name [" + classId + " is not supported by a trusted source"
getClass().getClassLoader() might not work.
Looks like the logic is in setInReplyTo() but not here.
Looks like the logic is in setInReplyTo() but not in the if (inReplyTo!= null) block.
Looks like the logic is in the wrong place. Does this make sense?
can you extract the test codes to a separate method?
can you extract the test to a method and reuse in each test?
can you extract the test to a method and reuse in the test?
Shouldn't we set this setting only if.jar is defined?
Shouldn't we set this setting only if.jar is present?
The warn message should probably be changed from "Couldn't resolve plugin dependency format: Endpoint is not loaded.
@manuelplazaspalacio this class is not part of the public api and it's a public method. I suggest using <code>getEntity()</code> instead of <code>getSurvey()</code>
@manuelplazaspalacio this class is not part of the public api and it's only used within the services of the controllers
Here too, is this duplicated?
please add getMessage : {}\n{}
please add'space after '
please add'space after '.
this PR was added to PR #3031. It appears that we have FEDERATED a few lines above. Can you remove this part?
this PR was added to PR #3031.
this PR is added
This should befactory.getBranch(p).getName().
This method should be private.
This method should be private
unchanged partition, nothing to commit:
unchanged partition?
unchanged partition or log?
We can simplify this code further by using if-else statement.
We can simplify this test a bit by using if/else statement.
We can simplify this test a bit by using if/else statement here.
I'd prefer to use getHostName() to ease correlation with other issues and logs
I'd prefer to use getHostName() to ease correlation with other messages
I'd prefer to use getHostName() to ease correlation with other issues and log
Nit: the style guide would ensure the correct spacing between if and (.
Nit: the style guide would ensure the correct spacing between methods.
Nit: the style guide would ensure the correct spacing between if and (
I think we cannot do an exceeding maxrety at the end :(
I think we cannot do exceeding maxrety at the end :(
I think we do not want to catch the exception here. It should be enough to only log the exception at the end of the test.
Since we're inconsistent with the [Guava syntax](<LINK_0>, I think that you can safely use it instead of joining as a while loop.
Since we're inconsistent with the [Guava syntax](<LINK_0>, I think that you can safely use it instead of'JOIN '.
Since we're inconsistent with the [Guava syntax](<LINK_0>, I think that you can safely use it instead of joining as it is.
I'm not sure this should be equals and hashcode.
I'm not sure this should be equals, but instead it doesn't check that they match the expected values in the map.
I'm not sure this should be equals, but instead it doesn't check that they match the expected values in the map. I think it would be clearer to have the comparison as well.
Can this be done outside the loop?
Can this be extracted to a method?
please remove
note that in the case of 'vm.getName()' exception, please move the call to 'executeCommand'
note that in the case of 'vm.getName()' exception, please move the call to 'executeCommand' method
note that in the case of 'vm.getName()' exception, this will be NPE
using log template is preferred
using two threads is common in here
using logging is preferred
@vilchik-elena Why don't you simply return without the else?
@vilchik-elena Why don't you simply return true here?
same here. Can be simplified to return true;
Missing method header.
Errr, @Baughn?
Errr, @Baughn!
Use new BusServices[0]
use sorting parameters Generic variable
use sorting parameters
this can never happen now, can it (assuming you are checking for bytesWritten < size).
this can never happen now, can it (assuming you are checking for bytesWritten < size)
this can never happen now, can be a separate loop
Can we create a function to get the status/health for the same name?
Can we create a function to get the status/health for StatusResponseHandler?
Can we delay this to 500ms so that we don't have to wait for it?
should probably be named m
seems to be named m
should be named m
Tip: consider adding the correct value to the error message and put the optional value on the correct value. Just in case.
Tip: consider adding the correct value to the error message and check the argument order in the exception message. Just in case.
Tip: consider adding the correct value to the error message and put the optional value on the correct value.
You should use.collect(Collectors.toList()) here.
You don't need to catch this line.
You should use singletonList
can we use a Stream or Stream API here?
can we use a Stream API here?
can we use a self-defined constant instead of an expression?
"assert false" will always fail. I expect this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in case it breaks.
"assert false" will always fail. I expect this is because if it fails, with a message, would probably make things easier to debug in case it breaks.
"assert false" will always fail
I would make this more readable like java List<Pair<Mutation, byte[]>> localUpdates = new ArrayList<>(); for (Map.Entry<Mutation, byte[]> next : indexUpdates) { if (localUpdates.isEmpty()) { localUpdates.add(next.getFirst()); } } }
I would make this more readable like java List<Pair<Mutation, byte[]> localUpdates = (indexUpdatesItr.hasNext()? new ArrayList<>() : indexUpdatesItr.next();
I think it would be nice to have a generic method for this.
If we're already doing this in Hawkular, we should also update the global configuration with the ActivityLifecycleManager.updateSubscription() method.
If we're already doing this in Hawkular, we should also update the global configuration with the ActivityLifecycleManager.updateSubscription() method instead.
The bus should be initialized with Companion
nit: move this to a separate method
nit: move these messages to a separate method
nit: move these checks to a separate method
I think it would be cleaner to have all this logic in flattenParams in the query itself. You can then just put it in the query string.
I would suggest something like: "You cannot set '"+key+"' to an empty string. Use a format string for the parameters."
I think it would be cleaner to have all this logic in flattenParams in the query itself. You can then just put the string in the flat format.
Probably a nitpick, but we need to test here that getEditorSetting is mostly duplicated. It can be in one place.
Probably a nitpick, but we need to test here that getEditorSetting is mostly duplicated. It can be in a private method
Probably a nitpick, but we need to test here that getEditorSetting is mostly duplicated. How about we have a helper method to get getEditorSetting?
Why not test with empty string?
Why not to test with empty string?
Why 2?
Since we need to do this change, we can continue processing, BeansUtils.getAllPropertiesFromCustomConfiguration is not available from the DB. What do you think?
Since we need to do this change, we can continue processing, BeansUtils.getAllPropertiesFromCustomConfiguration is not available from the DB. What do you think @stavamichal?
Since we need to do this change, we can continue processing, BeansUtils.getAllPropertiesFromCustomConfiguration is not available from the outside. So this is not necessary.
please wrap file.get() in a variable. You can use it in the lambda: filePromise.exists()? filePromise : null
you can use file.orElse(null) to catch the exception and remove 'throws Function<File, Breakpoint>, Breakpoint>
please wrap file.get() in curly brackets
I find the logic more readable if we extract this into a method, something like isVmInAsyncRunningVm(vmDynamic)
I find the logic more confusing. Why do we need to check the exit status if the Down command is running?
please remove the exit status as well
It may be useful to add some information about the routing data.
It may be useful to add some message about the routing data.
It may be useful to add some information about the routing data, for example, in case of error.
Why not use the param.getDataIndex()?
please move this to separate method
Why not use the param?
assert return value
assert return value is not used.
assert return value is not used
can you move this allocation down to line 540?
nit: could you move this allocation down to line 540?
nit: could you make this 'final' to make it clearer?
get rid of this log message as it's not a warning.
get rid of this log message as it's not a good idea
get rid of the catch block now.
This implicitly creates an iterator,.stream() will do the same thing. You can use (int i = 0; i < lines.size(); i++) { String[] strings = lines.get(i);... }
This implicitly creates an iterator,.collect(toMap(Map.Entry::getKey, Function.Entry::getValue));
This implicitly creates an iterator,.collect(toMap(Map.Entry::getKey, Function.Entry::getValue))
nit: private final String mCallback;
nit: private final
nit: private final String mCallbackName;
Refactor to deal with the non-CG tag that will be cached in this case.
Refactor to deal with the CG tag that will be used as many times :)
Refactor to deal with the non-CG tag that will be used
Calling the setOffscreenPageLimit here means we are setting the topscreenPageLimit to true. We can then restore the previous setting to true or false by default.
Calling the setOffscreenPageLimit here means we are setting the topscreenPageLimit to true. We can then restore the previous setting to true.
Calling the method here is unnecessary.
It would make sense to assertNull here.
It would make sense to assert null in both values and values (BigDecimal.class).
It would make sense to assert null in both values and values (BigDecimal.valueOf(123), "val")
You may want to use ObjectUtils for this null check.
you may want to use ObjectUtils for this null check.
You may want to consider using ObjectUtils for this null check.
Would make sense to mExportFileName here as well.
Would make sense to mExportFileName!= null before the export file creation.
Would make sense to mExportFileName!= null before the check for 'getParameters.
Is there any reason for not using WaitFor.condition(() -> listThreadsMatchingMatchingClientListener-ClientListenerLeakTest-.*").size()
Is there any way to test that there is no nics for this shutdown?
Is there any way to decrease the timeouts here?
"consider changing the plugin filename"
"consider changing the plugin", pluginName
"consider changing the plugin", pluginName)
If you don't call this on the line above it will fail the test. So it doesn't assert the result of this call, I think it's not useful
If you don't call this on the line above it will fail the test. So it doesn't assert anything about the rows.
If you don't call this on the line above it will fail the test. So it doesn't assert the result of this call.
I don't think this is necessary and can be simplified by making a lambda here: java.register(name(), new SessionFactoryHealthCheck( environment.getValidationQueryTimeout().orElseGet(() -> Duration.seconds(5)));
I don't think this is necessary. This codacy wil complain.
I don't think this is necessary. This might be simplified by passing the config through the builder
assertEquals(excpected, actual)
assertEquals(e.g., "file0", "mofified file0");
This doesn't seem right.
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
Think Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
Think @sandeepSamudrala mentioned in the another pull request. Should add location() and location() as parameters to the resultObject.
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
![Codacy](<LINK_0> Issue found: [Entity<String> values = new HashMap<>();](<LINK_1>
![Codacy](<LINK_0> Issue found: [Entity<String> values = new HashMap<>();](<LINK_2>
is calling removeClientListener thread safe?
is calling removeClientListener thread safe? We should probably call it only once when removeClientListener is called.
is calling removeClientListener thread safe? We should probably do a null check somewhere else
The ListModel<String> is redundant.
Please use the 'NonAvailable' flag instead.
Please use the 'NonAvailable' button instead.
you could use one if statement here.
you could replace all this if with switch
else if
suggestion result.add(TestResult.skipped(null));
I think it would be clearer if this type of test methods were just included in the returned list.
I think it would be clearer if this type of test is just asserting that the returned list.
Why this sleep? Maybe we can use the @Before method from kafkaConsumer.createTopic()?
Why this sleep? It seems like it would be better to use a latch.
Why this change?
The return value of this method is never used.
Great! The static import of 'plugin.xml' is already quite big, but please use the full package name instead.
Great! The static import of 'plugin.xml' already exists. I suggest to change this to java.nio.file.Path.
Unable to locate configuarion folder.
Override
Removed
Yielder is actually not needed.
Why not Yielder<OutType> toYielder(initValSupplier, accumulator)?
Why not Yielder<OutType,T> accumulator = null;
This needs to be moved to a utility class.
This does not look right. We have figured out that that a general case is more complicated for it.
This does not look right.
Feature should work without any property set. But should be turned off in generic configuration.
Feature should work without any property set. But should be a separate part.
Feature should work without any property set. But should be turned off in generic state.
I think we get rid of the setDate(dateFilter.getEndDate())
I think we get rid of this line: startCipher.setEnabled(dateFilter.getEndDate());
I think we get rid of this variable.
If you want to return false, don't you want to return false?
If you want to return false, don't you want to return true?
If you want to return false, don't you want to continue processing the error?
Nit: Add a space after the comma.
Nit: Add a space after the &&
Nit: Add a space after the &&.
I'd like to remove an extra setFallback method here, one should be fine. On the other hand, the EntitlementManager will re-read the context from the outside of the try-finally block, changes the contextRegistry.js may not be re-read.
I'd like to remove an extra setFallback method here, one should be fine. On the other hand, the EntitlementManager will re-read the context from the outside of the try-finally block, changes the contextRegistry.js may not be re-written..
I'd like to remove an extra setFallback method here, one should be fine. On the other hand, the EntitlementManager will re-read the context from the outside of the try-finally block, will be created.
I don't think we need this synchronized block here.
I don't think we need this synchronization here.
I don't think we need this synchronized block here?
put arguments on the same line: input.readBytes(Slices.wrappedDoubleArray(samples), size * SizeOf.SIE_OF_DOUBLE);
put arguments on the next line: input.readBytes(Slices.wrappedDoubleArray(samples), size * SizeOf.SIE_OF_DOUBLE);
put all parameters on the same line: input.readBytes(Slices.wrappedDoubleArray(samples), size * SizeOf.SIE_OF_DOUBLE);
Please use bitset.asBoolean() instead of assertTrue
This is not really a test ;)
Please use bitset.asBoolean() instead
maybe getOrPutableMessage?
maybe getOrPut/create?
maybe this is back to the original code as well?
"person. voided.bit" should be renamed to "peerName"
@personeccessary thanks for refactoring
ident
I think it's a common part of this error message. Should we simply say "The aggregate (or some of its subtypes) [%s] doesn't provide a no-arg constructor". If we can do this, we should also enhance the message to say "The aggregate (or some of its subtypes) [%s] doesn't provide a no-arg constructor".
I think it's a common part of this error message. Should we simply say "The aggregate (or some of its subtypes) [%s] doesn't provide a no-arg constructor"?
I think it's a common part of this error message. Should we also catch Exception instead?
We could use TcpIpConnection::close instead of this duplicated code.
We could use TcpIpConnection.handleError(Error) to handle this exception.
We could use OutOfMemoryErrorUtil.handleError(error) to handle the errors in the error case.
this should be either separated or runtime exception
missing space after "!"
method name no longer correct.
Can we move it to private method?
Can we move it to a separate method?
Can we move this code to separate method?
If you're looking at the code, why not move the VisibilityEvaluator.unescape to a static variable?
If you're looking at the code, why not move the VisibilityEvaluator.unescape to a separate variable?
If you're looking at the existing code, why not move the test into a static method?
minor: can be final.
minor: can be final?
minor nit: can be isData
1. i don't think this should be based on the "potential" of the host, rather the DC its in. 2. also, if my DC is 3.0, you shouldn't let me create a useless V3 storage domain since the host i selected is 3.1. i wouldn't be able to do anything with it until i have a 3.1 DC. 3. while at it, I'm guessing this line is buggy and would cause quite a headache if a 3.2 vdsm would be released, collections.
1. i don't think this should be based on the "potential" of the host, rather the DC its in. 2. also, if my DC is 3.0, you shouldn't let me create a useless V3 storage domain since the host i selected is 3.1. i wouldn't be able to do anything with it until i have a 3.1 DC. 3. while at it, I'm guessing this line is buggy and would cause quite a headache if a 3.2 vdsm would be released, collections. 3. while at it you're at it...
1. i don't think this should be based on the "potential" of the host, rather the DC its in. 2. also, if my DC is 3.0, you shouldn't let me create a useless V3 storage domain since the host i selected is 3.1. i wouldn't be able to do anything with it until i have a 3.1 DC. 3. while at it, I'm guessing this line is buggy and would cause quite a headache if a 3.2 vdsm would be released, collections. 3. while at it you're at it... Did you try to solve that by using the new storage domain?
This is fine, but for future reference there is also a instanceOf method.
This is fine, but for future reference there is also a PR that executes the task for you, and returns the submitted task.
This is fine, but for future reference there is also a PR that executes the check for success.
> off topic: I'd go with a simple "//x" and "y" in AbuseFilterEditResult.java instead of doing this hard-coded string.
> off topic: I'd go with a simple "//x" and "y" in AbuseFilterTriggerWarn" when going to fail. The code will be more readable than the previous version.
> off topic: I'd go with a simple "//x" and "y" in AbuseFilterEditResult.java instead of doing it hard to read and reuse the same "x" everywhere.
suggestion log.warn("Encountered {} while trying to fetch offsets in the next loop.", id, partitions);
suggestion log.warn("Encountered {} while trying to fetch offsets in the next loop.");
suggestion log.warn("Encountered {} while trying to fetch the metadata in the next loop.");
Alternatively, you could use bitwise OR.
Alternatively, this could use bitwise OR.
Alternatively, this could be written as boolean flags.
Method needs to be private.
I'd prefer to move this constructor call up and return it directly.
Method needs to be private. Users can pass in a builder instance directly.
You can just use.orElse(null) or.orElse(null)
You can just use : BlockUtil.fromNative(worldIn.getBlockState(LocatableBlock.class))
You can just use.orElse(null) to avoid the null check.
Can we get rid of this whole block? The parsing of the schema is probably not necessary.
Can we get rid of this whole block? The parsing of the schema is trivial. OrmException is already caught.
Can we get rid of this whole block? The parsing of the schema is trivial.
is there a reason for the ringbuffer creation?
is there a reason for the ringbuffer to be 0?
is this correct?
I don't think savedInstanceState should be null. (Or it should be null)
I don't think savedInstanceState should be null. (If it's not null, it's fine)
Use savedInstanceState instead of savedInstanceState.
Please improve this log or remove it.
Please improve logging or remove.
Please improve the readability.
Remove this line.
Remove this.
Remove this System.out
I don't understand why we want to log an error if the Fragment task is not connected to the current one.
I would prefer to break the loop here to avoid the rest of the logic.
I don't understand why we want to log an error if the Fragment task fails to be reset?
Why did you change this to a regular finally block?
Why did you change this to use the one File constructor?
Why did you change this to use a one-liner?
Similar code as if I am not mistaken, this may throw NullPointerException and then the check are needed.
Similar code as if I am not mistaken, this may throw NullPointerException and then the check of the sequence should not be necessary.
Similar code as if I am testing this
Transaction is opened the fun begins
optional: I'd use Collections.emptyList()
why I need variable that is used only inside a scope of if?
What happens when the query fails to commit?
What happens when the cursor doesn't have an offset?
this can be static.
@ivandalbosco I think it is better to extract variable.usages() into a dedicated variable.
@ivandalbosco I think it is better to extract variable.usages() into a dedicated method.
@ivandalbosco You can use anyMatch(symbol -> symbol.usages().stream()).filter(symbol -> symbol.scope().equals(symbol.scope()))
will it work fine if the path is not available?
will it work fine if the check is not enabled?
will it work fine if the  is not enabled?
This method is not necessary. You might want to leave it out
This method is not necessary. You might want to update the log level
This method is not necessary. You might want to leave it this way
if you invert this condition, then you'll avoid the null check.
if you invert this condition, then you avoid the double negation.
Locking in this method is necessary.
When running for example it's already exactly the same as the Command instance, does it?
When running for example it's already exactly the same as the last one.
When running for example it's already exactly the same as the Command instance, do we need this?
Do you need to check/use the param length?
Do you need to check/use the existing method?
The name of the parameter is misleading.
I'm not sure if it would be better to check the type of asyncInvokeNext.
I'm not sure if it would be better to check if the secondary index is possible.
I'm not sure if it would be better to check if the secondary index is the same as before.
Can you explain this? Should this be an actual String?
Can you explain this? Should this be an actual type?
looks like this should be a switch.
I don't think this will work for multiple package types. For example, why you test the method?
I don't think this will work for all packages. For example, why you want to use the packageBinding?
I don't think this method should be called in the packageBinding
You don't need the null check here since you are done before the for loop.
You don't need the null check here.
This function must be called before the for loop.
This can be replaced with assertThatThrownBy(() -> message.doLocalPutAll(partitionedRegion, mock(InternalDistributedMember.class), 1).isInstanceOf(PrimaryBucketException.class); to make things a bit neater.
This can be replaced with assertThatThrownBy(() -> message.doLocalPutAll(partitionedRegion, mock(InternalDistributedMember.class), 1); to make things a bit neater.
This can be replaced with assertThatThrownBy(() -> message.doLocalPutAll(partitionedRegion, mock(InternalDistributedMember.class), 1);.isInstanceOf(PrimaryBucketException.class); to make things a bit neater.
any reason for two ifs instead of if? if (domain == null ||!domain.isEmpty())
any reason for two ifs? I'm not sure if we should just check for this.
any reason for two ifs instead of if?
This check has become too stringent since you're not checking if it's zero.
This check has become too direct.
This check has become too stringent since you're less concerned about checking if the buffer is null.
validate paddingBlockSize int value?
can you rename the variable to translator?
Can you rename the variable to translator?
should be able to use.setClientRequest()
should be able to use.setClientRequest to check for null and empty cases.
should be able to use.setClientRequest to check for null
The Exception is never thrown.
Exception is never thrown.
Typo: shapeDefId
I wonder what the unrecognized value may be. What is the best way to count this?
I wonder what the unrecognized value may be. What do you think about adding some logging for it?
So why is this necessary? See below?
throws RuntimeException
why do you deregister the trace?
why do you return trace?
Is the order of bits in the result?
if the type is int, try to stay consistent with the rest of the code. Please consider moving this out of the switch case and use the 'case' pattern.
Is the order of bits in the result more than necessary?
could just use WAKEUP_INTERVAL_MILLIS here since the loop is only ever executed
could just use WAKEUP_INTERVAL_MILLIS here...
could just use WAKEUP_INTERVAL_MILLIS here since the loop is only ever executed if condition is true
- This should be useless now.
- This should be useless, no?
The same question.
s/vds.getName()/ host
s/vds.getName()/ host.getName()/
Shall we rename this variable to something like processAsyncCpuHost?
Missing the super class name.
Missing the super class name?
Missing ;
It would be clearer to rename the variable to anchorY and this.
This code is repeated three times
It would be clearer to rename the variable to anchorY
rather than checking for empty and then getting logged here...
"Downloading via proxy {}"
"Downloading via proxy: {} to this is silently slow
If this array isn't meant to be modified aftewards, you can now use ImmutableList, which will have better read performance (and no potential synchronization issues).
If this array isn't meant to be modified aftewards, you can now use ImmutableList, which will have better read performance (and no potential synchronization issues). However I think it would be better to create a static final list which will contain all the lists.
If this array isn't meant to be modified aftewards, you can now use ImmutableList, which will have better performance (and no potential synchronization issues).
Move this in the "else" block to make it clearer?
Move this in the "init" method to make it clearer?
Move this in the "else" block to make it clearer.
Minor: We might not need to set response code if we return true.
Minor: We could set response code to final.
Can this be made final?
SWT.HideOn SWT() is the default, I don't know about the behavior that it's not in the project nor in the project. This would be a leftover because it's the button that is created when the left widgets are hidden. Also, should this not be removed?
SWT.HideOn SWT() is the default, I don't know about the behavior that it's not in the project nor in the project. This would be a leftover to call the hard-coded width.
SWT.HideOn SWT() is the default, I don't know about the behavior that it's not in the project nor in the project. This would be a leftover because it's the button that is only visible when the user calls the load on the left in the Project Project.
You can static import QueryResult.singleResult
You can move all this logic to the first line.
You can static import
I think there is a potential race condition here since the locking is not acquired. Same applies to the other tests too.
I think there is a potential race condition here since the lock2 and lock2 are already acquired. Same applies to the other tests too.
I think there are only two locks being acquired here and in the other tests that the RedisLockRegistry did not have the same ensure-lock as well.
final
You should move this logic to the constructor.
You should move this logic to the top of the class
make this method private
set it here too
make it more readable
Please add message entity here by describing the error.
Please add the message entity here by describing the error.
I'd add the message entity here by describing the error.
I didn't think this is more readable. I'd suggest: if (currentFile.isProject() &&!currentFile.isProjectUnderGit(resource.asProject())) { alteredFiles.removeFile(itemRelativePath); } else if (delta.equals(currentFile)) { alteredFiles.removeFile(itemRelativePath); }
I didn't think this is more readable. I'd suggest: if (currentFile.isProject() &&!currentFile.isProjectUnderGit(resource.asProject())) { alteredFiles.removeFile(itemRelativePath); } if (currentFile.isProjectUnderGit(resource.asProject()) { //... }
I didn't think this is more readable. I'd suggest: if (currentFile.isProject() &&!currentFile.isProjectUnderGit(resource.asProject())) { alteredFiles.addFile(itemRelativePath); } if (currentFile.isProjectUnderGit(resource.asProject()) { //... }
Can this method be package private?
Can this be package private?
Can this method be private?
Please consider adding an overridden version of the'scheduleTaskShutdown' method that takes a task name as parameter. This will allow you to get rid of the "synchronized".
Please consider adding an overridden version of the PR.
Please consider adding an overridden version of the'scheduleTaskShutdown' method that takes a task name as parameter. This will allow you to get rid of the 'final' keyword.
Line too long. Maybe you can extract it to a function and call the variable?
Line too long. Maybe you can extract it to a function and call it from the if block.
Line too long. Maybe you can extract it to a function and call it from the else branch?
Declare templateStream hear, as a local variable.
Declare template stream hear, as a local variable.
Declare templateStream hear, as a variable.
Better to use Opcodes.ASM4_6) here instead.
Better to use Opcodes.ASM4_6) here as well.
Better to use Opcodes.ASM4_6) here instead of any longer
revert?
update
revert
During the build, when the info == null, we need to fetch the file from the resource. All inashWindowsMngr should be the first step of the method.
During the build, when the info == null, we need to fetch the file from the resource. All the other exceptions are wrapped in a Resource.
Should be removed.
This variable should be final.
This variable should be declared final.
This variable can be final.
maybe this could be 'type'?
maybe this could be'static'?
maybe this could be 'type'
This could be improved by checking if fieldNotInitializedTest(ifTree.condition()).
This could be improved by checking if fieldNotInitializedTest() == false.
This could be implemented in if statement!
Is there any advantage to convert this to a byte[] here?
Is this necessary? There is no test for this.
Is there any advantage to convert this to a byte[]?
Just pass it all the other hashcodes directly to equals(). Don't do it.
Just pass it directly. We are the bad hashcode implementation.
Just pass it directly. We are the bad hashcode implementations here.
why not use an iterator?
minor: you can use an ImmutableList here
minor: use Collections.singletonList()
Any reason for this change?
Any reason for this extra line?
Any reason for this extra check? Is it needed?
I think we should move these lines to the following: java Table table = classToTable.get(clazz); if (table!= null) { table = transaction.getTable(realm.configuration.getSchemaMediator().getTableName(originalClass)); }
I think we should move these lines to the following: java Table table = classToTable.get(clazz); if (table == null) { table = transaction.getTable(realm.configuration.getSchemaMediator().getTableName(originalClass)); }
I think we need to move these lines up to the top of the method?
Let's use a logger.
Let's use a logger if we can.
Let's use a more descriptive name.
What's the difference between this loop and the previous one?
What's the difference between the else branch and the else branch?
What's the difference between an empty string and the previous one?
Is it more likely to be severe?
Is it more likely to be collapsed to ||?
Is it more likely to be collapsed to Discover.all?
I would prefer public execute(Method.PUT, US_EAST_1, bucketName, null, ErrorResponseException, InternalException) to reduce code duplication.
I would prefer public execute(Method.PUT, US_EAST_1, bucketName, null, headerMap, null, ErrorResponseException, InternalException) to avoid code duplication.
I would prefer public execute(Method.PUT, US_EAST_1, bucketName, null, headerMap, null, ErrorResponseException, InternalException) and not public.
do we need a separate logging here?
do we need the "else" log here?
do we need the "else" log line here?
else we should probably just be here. If we are only setting the bean to null, should we instead validate that the class is aGroovyPresent?
else we should probably just be changed for the isGroovyPresent() case.
else we should probably just be here. Could also be changed later.
Why is that removed?
Why is that necessary?
Why is that needed?
"err".equalsIgnoreCase(...)
default constant!
Nice!
suggestion if ((name!= null) && crewMember.Role.fromPossibleKey(role).isNothing()) {
suggestion if ((name!= null) && (CrewMember.Role.fromPossibleKey(role).isNothing()) {
suggestion if ((name!= null) && (((String)(name).trim().replace(" ", "_").toLowerCase())) {
This should continue to use the ParseUtils for the already existing PrimitiveType() method. Use Types for those cases.
This should continue to use the ParseUtils on the class. Use Types for those cases.
This should continue to use the ParseUtils for the already existing PrimitiveType() method. Use Types.LONG for this.
Would it be better to just write to the log statement of the Exception? Do the same in all other places.
Would it be better to just write to the log statement of the Exception? Do the same in all other places too.
Would it be better to just write to the log statement of the Exception? Do the same in other places too.
please extract to a method
why protected?
why not to run it on edit command?
@ivandalbosco do we really need this assertion?
@ivandalbosco Why did you make core changes here?
Remove this assertion.
Can you move this into private method?
Can you move this into 'protected'?
why public?
Should probably be refactored out some method also, like: java void onViewCreated(View view, Bundle savedInstanceState);
Should probably be refactored out some method also, like: java public void onViewCreated(View view, Bundle savedInstanceState);
This should also be replaced with some function, like TransformModel.
Why are we incrementing this with the list?
Why we are incrementing this with the list?
Why are we incrementing this?
This doesn't seem to be the right name. Why remove the index?
This doesn't need to be public.
This doesn't seem to be the right name.
This block can be optimized to avoid having a similar key-value pair inside registeredEvents.computeIfAbsent().
This block could be optimized to avoid having too many nested calls.
This block can be optimized to avoid having a similar issue in histograms and timers.
why not to use assertEquals?
why not Assert.assertEquals?
why not assertEquals?
Same here, needs to test with different validations.
Same here, I think you should use the @BeforeMethod setup
Same here, I think you should use the @Before methods
I think we should throw exception.
I don't think we need to catch Exception.
I think we should throw an exception.
The logic is Simplification(simplification) from this condition.
The logic is Simplant. It's not limited to the maximum call.
Could be declared final
This should be logged with warn level
This is always true right?
This is not really related to this PR
Would you mind to change this to: if (way.hasTag("motorroad", "ford") || (way.hasTag("motorroad", "ford"))
Would you mind to change this to: if (way.hasTag("motorroad", "ford") || way.hasTag("foot", restrictedValues) return acceptBit;
Would you mind to change this to: if (way.hasTag("motorroad", "ford") || way.hasTag("foot", restrictedValues) return acceptBit;?
The log statement is not necessary. Remove it.
The log statement is not needed. Remove it.
The log statement is not needed.
Perhaps use a negative check here to make sure there is an index that can be negative?
Perhaps use a negative check here since this will always be the last element in an array.
Perhaps use a negative check here since this will always be the last element in the list.
Redundant braces
Redundant initialization.
Redundant log.
Your existing code should be replaced by: File[] existingFile = new File(filePath); if (existingFile.exists()) { existingFile = new File(filePath); } refreshLocation(filePath); }
Your existing code should be replaced by: File[] driveFile = new File(filePath); if (filePath == null) { //... }
You can just use "editorPart.getTitle()" here
This should probably be a NPE. We should try to remove this in order to make this NPE safe.
This should probably be a NPE. We should always catch this in a finally block.
This should probably be a NPE. We should try to remove this in order to make this into a check.
This equals implementation should include attributes from the task.
Please add {}
Please add {}.
why would you add this line?
I would think the call to the super should be moved to the calling method.
why not use the relevant Exception type?
I think you can instead change.value == Value.PENALTY_BOX to Value.containable
I think you will also need to check for null, or.value!= null.
I think you will also need to check for null, since havnet or Cam
The fix here should go into where sortBy[0] is used, instead of creating manually a specific implementation of SortBy
The fix here should be to assign sortBy[0] to the result of the invocation below
The fix here should go into where sortBy[0] is not null.
This should be protected by a default method 'public'
This should be protected by a default method in the class.
This should be protected by a default method
Should this be done in the BeaconHandler?
Should this be done in the BeaconHandler, or is it missing a null check?
Should this be done in the BeaconHandler, or is it missing here?
please decrease to TRACE level
please decrease to trace level
please decrease to TRACE level and remove statement
I think this method should be private.
I think this method should be private
I think this method should be public.
Can this be new ProjectListPopupOnOpenRowEvent(descingUp, row).getName() for Reviewers
Can this be new ProjectListPopupOnOpenRowEvent(descingUp, row).getName() for Title.
Can this be new ProjectListPopupOnOpenRowEvent(descingUp, row).getName() for ReviewElement?
If possible, tests should not share any state between them as it may hide bugs.
Will this in a whole bunch of log statements be removed?
If possible, tests should not share any state between them.
@vilchik-elena This condition could be simplified to!sameSymbol(element.parent().parent()!= null && element.parent().is(Tree.Kind.CAST_LIST))
@vilchik-elena This condition could be simplified to!sameSymbol(element.parent().parent()!= null && element.parent().is(Tree.Kind.CAST_FUNCTION));
@vilchik-elena This condition could be simplified to!sameSymbol(element.parent().parent()!= null && element.parent().is(Tree.Kind.CAST_LIST)).
use stream instead of collect
use stream and map?
use stream instead of filter
Can you make sure that if the topic is not found then hintClusterMap should throw a runtime exception.
Can you make sure that if the topic name is hint_name is not provided then you can use the zk URL?
Can you make sure that if the topic is not found then hintClusterMap should throw a runtime exception?
Is it really needed to keep this?
Is this really needed?
Is it really needed to append new methods to a file?
You should log also "Group id".
You should log also "Group ID".
You should remove this whole method.
should the signature be VNTRequest?
should be VNTRequest
should the return value be VNTRequest
Could you please change this to if (newConfigurationMap.containsKey(stringMapEntry.getKey())) { newConfigurationMap.putAll(stringMapEntry.getValue()); } else { newConfigurationMap.putAll(stringMapEntry.getValue()); }
Could you please change this to if(newConfigurationMap.containsKey(stringMapEntry.getKey())) { newConfigurationMap.putAll(stringMapEntry.getValue()); } else { newConfigurationMap.putAll(stringMapEntry.getValue()); }
Could you please change this to if (newConfigurationMap.containsKey(stringMapEntry.getKey())) { newConfigurationMap.putAll(stringMapEntry.getValue()); }
rename to simple
name == simple
rename
This DateFormat object never changes. Maybe make it static final in the class scope and save a bit of performance?
This DateFormat object never changes. Maybe make it static final in the class scope and add a constructor to avoid the double format?
This DateFormat object never changes. Maybe make it static final in the class scope and add a constructor to avoid the performance bottleneck.
It's a debug level?
Do we need a explicit integer access?
One question: Should we end the log message on dfsClient?
Why do we need separate test?
Why do we need this test?
Why do we need separate test case?
This is an abuse of the API, but I would prefer to check the cache contains the current one.
This is more efficient, but maybe less important.
This is an abuse of the API
Why this change? I think it should be ERROR and not ERROR.
Why this change? I think it should be ERROR
Why this change?
I think you should be able to check the exception type here. Same for the next line.
I think you should be able to check the outcome of the tx tx in the same try block.
I think you should be able to just use the in-memory cache here instead of cache.
if (monitoringId!= null) {... } else {... }
if (monitoringId == null) { continue; } else {... }
if (monitoringId!= null) { continue; } else {... }
@ikhvostenkov why not have this local variable?
@ivanarrizabalaga why adding brackets? :)
@ivanarrizabalaga why adding String.format? :)
We should also have a test for the case where the file has no modification.
We should also have a test for the case where the file cannot be read.
We should also have a test for the case where the file path is filtered from
Where is this being used? I couldn't see it being used anywhere. In either case I would use a name not including Java. Perhaps "advancedMsg"?
Where is this being used? I couldn't see it being used anywhere. In either case I would use a name not including Java. Perhaps "advanceding"?
Is there a reason not to use a name not including Java? Perhaps "advanceding"?
Can be replaced with: hosts.stream().map(VDS::getName).collect(Collectors.toList())
Can be replaced with:.map(VDS::getName).collect(Collectors.toList())
Can be replaced with:.map(VDS::getName).collect(Collectors.toList());
@vmaletta do we record this hardcoded value?
@droneboost this should be in a constant since it's set to 0.
@droneboost this should be in the if statement below.
Use the stream with try with resources
Consider using the stream with try with resources
Use the stream with try with resource.
Spe
Spe will be getting a NPE here.
Spe will be getting a NPE here?
bigtable-hbase.properties
Please put identation into a method.
Please put identation into a static method.
why not just do name.toLowerCase()?
why not just put it as a lambda?
why not just put it as a lambda???
File
style nit: we don't use braces around single line blocks
What happens if there is a workspace which is not a workspace?
This setting should not be enabled by default since headers may be C++-specific and not protected by # of JDK
This setting should not be enabled by default since headers may be C++-specific and not public.
This setting should not be enabled by default since headers may be C++-specific
Another issue I noticed while trying this out: getDefaultLSLocation() can return null (e.g. if the chosen language server is not found in your PATH), in which case the next line will throw a NullPointerException. So we need to add a check here.
Another issue I noticed while trying this out: getDefaultLSLocation() can return null (e.g. if the chosen languageServer is not found in your PATH), in which case the next line will throw a NullPointerException. So we need to add a check here.
Another issue I noticed while trying this out: getDefaultLSLocation() can return null (e.g. if the chosen language server is not found in your PATH), in which case the next line will throw a NullPointerException. So we should probably add a check here.
Minor: please move this method to JobManager or use JobManager.
Minor: please move this method to a private method so this can be reused by both places.
please move this method to JobManager
We're no longer catching an exception here, but I'm a bit worried about it :)
We can't catch this exception, but just ignore it
We're no longer catching an exception here, but just catch it directly. What about having a specific runtime exception type?
I guess we could have a bit more logic here with an unparseCall().
I guess that we don't have to add the extra parens here.
I guess we could have a bit more logic here with an unparseCall.
Now it's translated. [testng-tests.zip](<LINK_0>
Now it's preferable to return directly
Now it's translated. [testng-java.zip](<LINK_0>
This is a race condition (at line 74) since TumorType instances are created in each TumorType, which means that we have to use the TumorType's serialize method to get the hash. Can you do that only once? I think that would require to add this to TumorType, since TumorType is a class.
This is a race condition (at line 74) since TumorType instances are created in each TumorType, which means that we have to use the TumorType's serialize method to get the hash. Can you do that only once? I think that would require to add this to TumorType, since TumorType extends TumorType
This is a race condition (at line 74) since TumorType instances are created in each TumorType, which means that we have to use the TumorType's serialize method to get the hash. Can you do that only once in the constructor?
If we are in the format format then we should not be in the try/catch here.
If we are in the format format than we should probably make the default constructor cleaner by using the format of the message here.
If we are in the format format than we should probably make the default constructor cleaner by using the builder (without catching exception).
you're not checking the filter right?
I think one should use the authentication attributes from the configuration file
I think one should use the authentication attributes from the filter name
maybe consider using a ternary here.
maybe use a ternary here. if (color!= null) {
maybe use a ternary here.
Arguments should be switched with SLF4J Logger
Arguments should be switched
Magic number
the return value is not used. I suggest removing it and throwing an IllegalStateException if a message type needs to be handled, but there is no mapping to a handler.
the return value of this method is not used. I suggest removing it and throwing an IllegalStateException if a message type needs to be handled, but there is no mapping to a handler.
the return value is never used. I suggest removing it and throwing an IllegalStateException if a message type needs to be handled, but there is no mapping to a handler.
no need to pass the method, you are just passing the method reference
no need to pass the method, you are just calling super.init
minor: Are you sure this is done automatically?
LocalDate.now().minusMonths(MAX_OLD_OF_ACTIVE_USER_EXTSOURCE); -> jdbc.query(query, USEREXTSOURCE_MAPPER, user.getId());
LocalDate.now().minusMonths(MAX_OLD_OF_ONE);
LocalDate.now().minusMonths(MAX_OLD_OF_ACTIVE_USER_EXTSOURCE);
Can cache's return value be null?
I'd prefer to return a map instead of null, and force a null check.
I'd prefer to return a map instead of null.
Instead: java if (consumerCapacity.get() == 0) { onCompleted = new Subscriber(); } child.onCompleted();
Instead: java if (consumerCapacity.get() == 0) { onCompleted = new Subscriber(); } child.unsubscribe();
Instead: java if (consumerCapacity.get() == 0) { onCompleted = new Observable(); } child.unsubscribe();
I am not sure why you changed the formatting here.
I am not sure why you pushed the log in the TILJ_LOGD.
I am not sure why you pushed the log in the TOS bultDB
Maybe it'd be a personal taste, but using stream seems simpler to me as follows: dataKeyRanges.forEach(keyRange -> { final Map<Integer, Pair<Long, Long>> blockToSubKeyRangeMap = blockResolver.resolveBlocksForOrderedKeys(keyRange.getFirst(), keyRange.getSecond()); blockToSubKeyRangeMap.forEach( (blockId, subKeyRange) -> { blockToSubKeyRangesMap.put(blockId, new LinkedList<>()); } blockToSubKeyRangesMap.put(blockId, subKeyRangeList.add(subKeyRange)); });
Maybe it'd be a personal taste, but using stream seems simpler to me as follows: dataKeyRanges.forEach(keyRange -> { final Map<Integer, Pair<Long, Long>> blockToSubKeyRangeMap = blockResolver.resolveBlocksForOrderedKeys(keyRange.getFirst(), keyRange.getSecond()); blockToSubKeyRangeMap.forEach( (blockId, subKeyRange) -> { blockToSubKeyRangesMap.put(blockId, new LinkedList<>()); } blockToSubKeyRangesMap.get(blockId); subKeyRangeList.add(subKeyRange); } ); });
Maybe it'd be a personal taste, but using stream seems simpler to me as follows: dataKeyRanges.forEach(keyRange -> { final Map<Integer, Pair<Long, Long>> blockToSubKeyRangeMap = blockResolver.resolveBlocksForOrderedKeys(keyRange.getFirst(), keyRange.getSecond()); blockToSubKeyRangeMap.forEach( (blockId, subKeyRange) -> { blockToSubKeyRangesMap.put(blockId, new LinkedList<>()); } blockToSubKeyRangesMap.add(subKeyRange); subKeyRangeList.add(subKeyRange); });
Use error logAndThrow
Use Log methods instead of throwing exceptions
Use error log and throw the exception
This message makes me think that it should be a ConfigurationException (or ConfigurationException).
This message appears to be wrong. Can we fix that?
This message appears to be wrong. Can we fix that? Also, it would be nice to keep a message about whats happening.
why would you use assertTrue and assertFalse?
why 4.
why you have to catch more than one?
It would be nice if we could skip that when statistics.isStatisticsEnabled() is true. System.nanoTime() adds some overhead.
It would be nice if we could skip that when statistics.isStatisticsEnabled() is true. Currently that's the case.
It would be nice if we could skip that when statistics.isStatisticsEnabled() is true. Currently we put a snapshot of the cache in a configuration.
Why not use a Set<StoragePool> here?
Why do you need to have a set here?
Why do you need to have a Set here?
This doesn't look like it should be a prefix
Doesn't this do anything?
Good catch
Why do we support filtering by default?
Why is this needed?
Why is this needed?
Please remove unnecessary blank line.
s/ luns/create
Please remove unnecessary brackets.
Could you please elaborate on the change in this PR?
Could you please elaborate on the change in this PR? Thanks.
Could you please elaborate on the change in this file?
This is already fixed in [this file](<LINK_0>, so shouldn't this use ObjectUtility.getTaskInfo().getJobInfo().getTaskId?
This variable name should be taskStateMap
This is already fixed in [this file](<LINK_0>, so please keep it.
Why does this check be outside the try block?
Why does this check be outside of the try block?
Why does this check be inside the try block?
Could you please rename this to something like globalData? It is confusing since the scheduler does not have to do a global data instead of this.
Could you please rename this to something like globalData? It is confusing since the scheduler does not have to do a global data object.
Could you please rename this to something like globalData? It is confusing since the scheduler does not have to do this.
this will throw NoSuchElementException
this is pretty dangerous. hasNext() will be called for every label while it will be called several times. We should log a debug log.
this is pretty dangerous. hasNext() will be called for every label while it will be called several times. We should log a DEBUG log.
Change the null check to something like: if ((task.projectName!= null) && e.controlFor(user).isVisible()) {
Change the null check to something like: suggestion if (user.getCapabilities().canViewQueue()) {
Change this to: "Project Id is required" to be populated with 'projectName'.
This is common enough that there's a util for that and is used extensively: suggestion Utils.closeQuietly(retryWithToleranceOperator, "retry operator");
This is common enough that there's a util for it and is used extensively: suggestion Utils.closeQuietly(retryWithToleranceOperator, "retry operator");
This is common enough that there's a util for that and is used extensively: suggestion Utils.closeQuietly(retryWithToleranceOperator, "retry operator"); This way, the logger doesn't need to have a try-catch.
No new line here.
There's a lot of these new methods in DeviceUtils, can you use that instead?
No new line here
How about: if (repoRelativePath.isEmpty()) {
How about: if (repoRelativePath.isEmpty())
How about: rm.getRepoRelativePath(resource.getPath());
I think we can change these calls to use timer.currentTimeMs() so that we do not add any additional calls to system time. These have been a performance issue in the past.
I think we can change these calls to use timer.currentTimeMs() so that we do not add any additional calls to system time.timer() in the past.
I think we can change these calls to use timer.currentTimeMs() so that we do not add any additional calls to system time.timer() in pollForFetches(). > 0 would be more robust than long.
If you throw an exception, and this line of code is not logged.
If you throw an exception, and this line of code is not needed.
If we throw an exception, and this is going to be a little confusing. Maybe call it responseSize and getResponseSize?
Why do we need to write to the stream while it's been already closed?
Why do we need to write to the stream while it's not the cookie?
Why do we need to write to the stream while it's not the cookie? If anything could be more complex than just check for the header.
Use Preconditions.checkArgument(id, "Device identifier cannot be null.");
Use Preconditions.checkArgument(id!= null)
Use CollectionUtils.isEmpty()
Would it make sense to move the getName() method out of the getCompilerArgumentsAsMap() method?
Would it make sense to move the getName() method out of the if condition since it is always a prefix?
Would it make sense to move the getName() method out of the if condition?
ERROR->NOT_FOUND
ERROR->NOT_FOUND.
We don't have to handle this yet.
The situation where we expect to be able to read the data source from the file data view. Is that the case?
The situation where we expect to be able to read the data source from the fileData first in the source and then have to check if it is an int.
i18n
I don't think the indent is necessary (the next line)
I don't think the timeout is necessary in this test, the test would still pass.
I don't think the timeout is necessary in this test, the test would run before the timeout has already been set.
negotiatedProposalNum > reqProposalList.size()
negotiatedProposalNum > reqProposalList.size()?
negotiatedProposalNum - 1
This is a brittle test. If the RVVV is null, it's likely that the value that's changed might be negative (see the assertion). Why not just return from the in-place?
This is a brittle test. If the RVVV is null, it's likely that the value that's changed might be negative.
This is a brittle test. If the RVVV is null, it's likely that the value that's changed might be wrong.
I'm just wondering, if this would be more logical to just call a findCompileTimeConstant(ASTPrimaryExpression expression)
I'm just wondering, if this would be more logical to just call a drop-in loop with an expression (thus we don't do that check)
I'm just wondering, if you can add a second parameter for this loop
The second null check is unnecessary, as equals will return false for null argument.
The second part of equals and hashCode are identical, can be factored out.
The second part of equals and hashCode are identical.
I would suggest to add a method that will shutdown the executor, and use that in all cases.
I would suggest to add a method which will shutdown the executor, and use that in all cases.
I would suggest to add a method which will shutdown the executor based on the refresh rate limiter
remove this and following our.println?
remove this and following our logs?
remove this and following our LOG.info?
throws IOException is not needed; remove it
@bhhari @sayhar Sahar found that this is buggy. See fixes in #13208
throws IOException goes into method
This should probably be mockableStreamTask and not the class.
This should probably be done and no need to mock the executor
This should probably be done and no need for the mock of the executor
I don't think we need this. build.getDistributionManagement() is a better choice.
I don't think we need to have build.getDistributionManagement() in the writeProperties() method.
I don't think we need to have build.getDistributionManagement() in the write repository. This may lead to some issues with the CI server.
Weird to have producerMethod. I think it should be private.
Weird to have producerMethod. I think this should be private.
Weird to have producerMethod method public
Remove all System.out calls.
Remove all System.out calls
Remove these.
I feel like we should use the actually defined scope HibernateValidator instead of PredefinedScope HibernateValidator, rather than the PredefinedScopeHibernateValidator from the first place.
I feel like we should use the actually defined scope HibernateValidator instead of PredefinedScope HibernateValidator, rather than the PredefinedScopeHibernateValidator from the first place. Not a big deal, also...
I feel like we should use the actually defined scope HibernateValidator instead of PredefinedScope HibernateValidator, rather than the PredefinedScopeHibernateValidator from the first place. Not a big deal, but we have ValidatorFactoryImpl...
[nit] Please remove the static import.
[nit] Use the full path.
[nit] Use of the static import.
Again, I think it's better to remove the duplication of the data processors, and use a different Map implementations to do the same.
Again, I think it's better to remove the duplication of the map map and simply add the keys to the map. You can use a plain HashMap and then do the put(x, y) in the map.put.
Again, I think it's better to remove the duplication of the map map and simply add the keys to the map.
mapAtRoot is a Map. No need to do it here. Also, please rename k to it.
mapAtRoot is a map. No need to do it here
mapAtRoot is a Map. No need to do it here again
Move the creation of the pointables object to the constructor. In the evaluate, just reset or clear the pointables variable.
Move the creation of the pointables variable to the constructor. In the evaluate, just reset or clear the pointables variable.
Move the creation of the pointables object to the constructor. In the evaluate, just reset or clear the pointables object.
i think this logic works to identify the given resource group is static or not. But a much cleaner way would be, if we mark each segment of ResourceGroupId being static or not when we create them via group.expandTemplate call, then we can easily put the flag here. And no need to rely on the context. i.e. this line will become something like this group = parent.getOrCreateSubGroup(id.getLastSegment().getValue(), specVersion);
I'm a little confused why we need a separate monitor. Won't it be synchronized the same as this?
i think this logic works to identify the given resource group is static or not. But a much cleaner way would be, if we mark each segment of ResourceGroupId being static or not when we create them via group.expandTemplate call, then we can easily put the flag here. And no need to rely on the context to keep the method static.
Perhaps you can make the condition here more readable?
Perhaps you could move the check for currentUser.getCurrent() to a variable
Perhaps you can make the condition here more clear?
This doesn't read the entire screen.
This doesn't look right to me. The behavior is the same that we just read in the render method.
This doesn't look right to me. The behavior should be > 0, 0x77ff.
This variable is used only once, I'd suggest just calling the method more readable.
This variable is used only once, I'd suggest just calling the method directly without the instanceof.
This variable is used only once, I'd suggest just calling the method directly without the instanceof check.
Get a reference to the hardWrapSegmentListener on you
Get a reference to "hardWrapSegmentListener"
Get a reference to the value of this on every call.
a QuadrigaStorageException should be created inside the loop. You just have to re-use the networkNodeInfo from the loop.
a QuadrigaStorageException should be created inside the loop. You just have a map of the networkNodeInfo to the network interfaces and use that.
code style
message should also be changed to "false"
message should also be changed to "false".
please include assert text
Could you write this in a try-catch block and assert the error message does not get thrown?
Could you write this in a try-catch block and assert the error message does not contain it?
Could you write this in a try-catch block instead?
these debug statements are not necessary
these debug statements are redundant - please remove.
these debug statements are redundant.
It would probably be safer to return at least the number of counters, and simply return the number of them in the method signature.
It would probably be safer to return at least the number of counters, and simply return the number of them.
It would probably be safer to return at least the number of counters, and return the number of them in the method signature.
I wonder if we should have a static method somewhere getAbsoluteUrl(String) and call that instead, making the code ever so slightly higher level. Config.getAppUrl never returns null?
I wonder if we should have a static method somewhere getAbsoluteUrl(String) and call that instead, making the code ever so slightly higher level. Config.getAppUrl(Const.ActionURIs.PUBLIC_IMAGE_SERVE)
I wonder if we should have a static method somewhere getAbsoluteUrl(String) and call that instead, making the string concatenation may be more expensive.
Great! The static import of 'private' access modifier to simplify this method.
Great! The static import of 'private' methods was more appropriate, but please change to java.util.Properties.
Great! The static import of 'private' methods was more appropriate, but please change to java.util.AbstractPlugin instead.
I'm assuming this function is only used once?
I'm assuming this function is only called once?
I'm assuming this function is only used once. But should be called timeTakenNs after that?
Please format the code according to the Eclipse coding standards
You could move it to where it is used.
You could move it to line 94 and change the selection to be before the "if" statement at line 62 and 63
List<Host> pools = pools.stream().map(host -> HOST.getId()).collect(Collectors.toSet());
please remove.and()
List?
Please remove the return statement now that you are done with both methods.
Please remove the return statement now that we are changing this to if.
Please remove the return statement
I would like to see a fail fast if there's an error here. I'd like to see an attempt to make the command fail if it did not send the result to the server.
I would like to see a fail fast if there's an error here. I'd like to see an attempt to make the command fail if it did not send the result to the user.
I would like to see a fail fast if there's an error here. I'd like to see an attempt to make the command failed.
These two lines should come before the if. (Remove in the other branch.)
This does the same, but is somewhat easier on the eyes: state.setCommitMessage(ObjectId.fromString(values[4]));
This does the same, but is somewhat easier on the eyes: state.setHeadCommit(ObjectId.fromString(values[4]));
How can this be moved out of the loop? int c = 0; for (Query query : queries) {...
How can this be moved out of the loop? int c = 0; for (Query query : queries) {... }
How can this be moved out of the loop?
Please update test date/timeInMillis so it would look like an issue with date.
Please update test date/timeInMillis so it would look like an Wrong date.
please test with dateInLocale.
Please remove as this is related to OAuth2AuthorizedClient
The whitespace here is not needed.
Please remove as this is related to the fix
nit: %s
nit: %s (or post-aggregators)
nit: %s (or post-aggregators.)
@TShapinsky nice find! Store the retrieved view in an instance field instead. it should be available as soon as this is called.
@TShapinsky nice find! Store the retrieved view within an instance field instead. it should be available as soon as this is called.
@TShapinsky nice find! Store the retrieved view within an instance field instead.
Shouldn't this be if (validChildType == null)?
Since this is a "if (validChildType == null)" block, it can be removed as you don't have the!childType.equals(target) check.
Shouldn't this be "else if"?
Does this test actually work if someone calls the "backspace" method and then the reader reader is closed? (i!= 0)
Does this test actually work if someone calls the "backspace" method? (i!= 0)
Does this test actually work if someone calls the "backspace" method and then the reader reader is closed?
We can replace this whole block by: event.post!= null && event.post.getLocalSiteId() == site.getId().
We can simplify this condition by doing: if (event.post == null || event.post.getLocalSiteId() == site.getId()) { return; }
We can replace this whole block by: if (event.post == null || event.post.getLocalSiteId() == site.getId()) { Wdyt?
It might be better to serialize the string value into an object into AzureAccountInfo.
It might be better to serialize the name into the json data, and make the consumer handle it.
Double check equal?
@since 3.13 missing
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")?
It's strange to me that here you don't have to consider the null-check (as well as several other places). Please extract it to a variable.
It's strange to me that here you don't have to consider the null-check (as well as several other spots in this file)
It's strange to me that here you don't have to consider the null-check (as well as several other places). Please verify with a situation when you are using null as expected.
This should be a _static_ field - it's on the UI thread.
This causes _current_ input to be null.
This causes _any_ exception to be thrown, right?
Why not: values.add(object);
Why not: values.add(object);?
Why not cache the values?
I think it'd be better to catch more specific exception like this: log.debug("Error details: ", e);
I think it'd be better to catch more specific exception like this: log.debug("Error details: {}", e);
I think it'd be better to catch more specific exception like IOException and rethrow it. So we can get rid of the catch block.
i think we can move this logic inside the if statement. Look for example on VmDynamic.getVmDynamic().getId()
i think we can move this logic inside the VmDynamicDao which is also used in many places.
i think we can move this logic inside the VmDynamicDao which is also used in case of dbVm == null and i remove it from here.
This technically isn't needed since we throw an exception in runtime...
This technically isn't needed since we throw an exception
This technically isn't needed since we throw an exception in runtime.
We don't need this check, it's already done by the lock.
We don't need this if-statement anymore, right?
We don't need this check, it's already done in line 44.
please do not use hard coded strings.
please do not use assertEquals on line 103.
please remove line
Not that it's good practice to declare the assertion as Assert.assertThat(toAdd, Matchers.hasItems(1));
Not that it's good practice to declare the assertion as Assert.assertThat(toAdd, Matchers.hasItems(1)) first
Not that it's good practice to declare the assertion as Assert.assertThat(toAdd, Matchers.hasItems(1)) first in the method. Normally you have expectation as the first argument is the expected pattern.
![MAJOR](<LINK_0> 'Severity: MAJOR') Change this condition so that it does not always evaluate to "false" [![rule](<LINK_1>](<LINK_2>
![MIN_VALUE](<LINK_0> The Cyclomatic Complexity of this method "is" is 14 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Change this condition so that it does not always evaluate to "true" [![rule](<LINK_1>](<LINK_2>
This can be private static final
This can be private static right?
This can be private static
You're not checking for empty string here, but just to make sure you're not throwing an exception anyway...
You're not checking for empty string here, but just to make sure you don't call the function to check it exists.
You're not checking for empty string here, but just to make sure you don't call the function to check it's null safe.
perhaps we should log the exception to RuntimeException, not just that exception.
perhaps we should log the exception to RuntimeException?
perhaps better to use a more specific exception that is caught, something like RuntimeException is not a good practice
I'm wondering why we want to use a private method here?
There's a private method MutationRetryCallable<Long>... (and a private method as well). Consider using that instead?
I'm wondering why we want to use a private method here? Can we add some useful message here?
Shouldn't this be "4.0"? If so, also you should add to the constant.
Shouldn't this be "4.0"? If so, also we should add to the constant.
Shouldn't this be "4.0"? If so, also please rename to " online"
@sebing we have compilation problems here as well
@sebing BytesOf here?
@sebing we have compilation problems here?
Can you move this if to the beginning of the method?
Can you explain this change?
Can you move this if to the beginning of the function?
you can use.stream().map(String::getName).forEach(obj -> writer.addParameter(obj, OptionsUtil.areDeletedArtifactsIncluded(writer.getOptions())));
you can use the following code: public boolean addPredicates(AbstractSqlWriter writer) throws OseeCoreException { Collection<String> ids = criteria.getIds(); if (ids.size() > 1) { writer.addParameter(seqId, OptionsUtil.areDeletedArtifactsIncluded(writer.getOptions()))); } else { writer.write(ImmutableMap.of(".query_id", TemporaryFolder.new(obj))); } }
you can use the following code: public boolean addPredicates(AbstractSqlWriter writer) throws OseeCoreException { Collection<String> ids = criteria.getIds(); if (ids.size() > 1) { writer.addParameter(seqName, OptionsUtil.areDeletedArtifactsIncluded(writer.getOptions()))); } else { writer.write(ImmutableMap.of(".query_id", OptionsUtil.areDeletedArtifactsIncluded(writer.getOptions()))); }
These should be moved to JDBCDataStore instead of the DataStore
I would prefer to use GeoServerResourceLoader.parseFrom(InputStream) and delegate to the DataStoreInfo constructor.
These should be moved to JDBCDataStore
Missing the toString()
Missing the toString() call in the order here?
Missing the toString() call?
Can we pull this into a isGoodPath helper method or something?
Can we pull this out into a isGoodPath helper method or something?
Can we pull this into isGoodPath helper method or something?
I just noticed that this is already handled in line 403, is it intentional?
I'm assuming this is already handled in line 403, is it intentional?
I'm assuming this is already handled in line 403, is it intentional? If so, shall we remove this?
Please use Camera.CameraInfo.UNASSIGNED
Please use Camera.CameraInfo.UNASSIGNED.
Please use Camera.CameraInfo. video_action_ barcode_save.
This can just be squashed up.
This can just be squashed into the String above.
This can just be squashed into the previous if
Please consider adding the following characters to the message: "Project name found: " + project.getName() + "digits or..."
Please consider adding the following characters to the message to explain the motivation. suggestion "Duplicate project name found: " + project.getName() + " onto " + project.getName() + ". Name must contain only._-", project.getName())
Please consider adding the following characters to the message to explain the motivation.
@pynicolas can we check that condition is always of type CfgBranchingBlock?
@pynicolas let's remove this filter and make it a Set
@pynicolas let's remove this filter and make it a Set always.
Needs defaults
Don't need this check. Needs defaults
Needs defaults.
I don't think this is safe -- won't it mask other types of errors that have nothing to do with connectivity? And do so indefinitely since we'll never pass those ConnectExceptions along? We do want tasks to fail eventually, we just want them to retry for some time if they can.
I don't think this method is safe -- won't it mask other types of errors that have nothing to do with connectivity? And do so indefinitely since we'll never pass those ConnectExceptions along? We do want tasks to fail eventually, we just want them to retry for some time if they can.
I don't think this is safe -- won't it mask other types of errors which have nothing to do with connectivity? And do so indefinitely since we'll never pass those ConnectExceptions along? We do want tasks to fail eventually, we just want them to retry for some time if they can.
I think this line should be moved to its own method.
I think this line should be moved to its own function.
I think this may not be necessary
This should be a private static final String ERROR_DIRDIR_MAPPER = new File(targetDir, "tacococo.cp").exists();
Formatting is off.
This should be a private method.
Hmmmm... I would remove the "OpenGLingText" part.
Hmmmm... I guess this line should not be in in the GUI, as there might be some layout issues.
Hmmmm... I guess this might be a good place for in GUI the instance.
This will be a whole lot slower. Maybe we can store the actual user name in a variable and use it.
This will be a whole lot slower. Maybe we can store the actual user name in a variable and assign it to the exception later.
This is a extra lock.
The result of get() has the same behavior as it was before.
The result of get() has the same functionality.
I think it should be an error if this is invoked and the impersonatedCredential constructor.
<LINK_0>
Grammar Nazi: "Unable to index file {}"
Grammar Nazi: "Unable to index the file with object id of {}"
I would prefer to remove the System.out here and add it to the request.
I'd prefer to remove the System.out here and add it to the request.
I'd prefer to remove the System.out here and add it to the log statement
Move this to use getPermanentOrLKI if possible
Missing the tapped field at the end of the filter
Missing the 'if'.
It could be interesting to see if it's empty or not. But if it's not, you can do a test for this method.
It could be interesting to see if it's empty or not, right?
It could be interesting to see if it's empty or not.
s/object/package-private/java-doc-files/File.java
s/object/package-private/java-doc
s/object/package-private/java/lang.java.lang.Object...
The full name of the test isOracle() and what it does. Should be something like: assertThat(result.get("field_length"), is(nullable_value()));
The full name of the test isOracle() and what it does. Perhaps use something like: assertThat(result.get("field_length"), is(nullable_value()));
The full name of the test isOracle() and what it does. Perhaps use something like: assertThat(result.get("field_length"), is(nullable_value"));
please use configuration to have per version values (it will save doing the per-version checks)
please replace with configuration to have per version values (it will save doing the per-version checks)
please use configuration to have per version values (it will save doing the per-version checks).
Please update this implementation.
This loop wastes time, wonder if we should just skip this.
Why is this inside the for loop?
Use guava [ExpectedException](<LINK_0> suggestion try { Thread.sleep(Duration.ofSeconds(20).toMillis()); System.out.println("Received Message Id: " + message.getMessageId()); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); }
Use guava [ExpectedException](<LINK_0> suggestion try { Thread.sleep(Duration.ofSeconds(20).toMillis()); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); }
Use [ResilientOperation](<LINK_0> Using the [CME](<LINK_1> implements the same contract.
Can we improve on this?
Can we improve on the usage of Optional?
Can we improve on the usage of this method?
This else block is redundant since the if block returns.
This else block is unnecessary since the if block returns.
This else clause is redundant since the if block returns.
Is this more a use-case than a while-loop? Maybe use an assert here.
Is this more a use-case than a for-loop? Maybe use something like: java while (count >= maxStackSize) {... }
Is this more a use-case than a while-loop? Maybe do something like: java while (count >= maxStackSize) { // Update this more.
Just double checking: Was it intentional to go from test result?
Just double checking: Was it intentional to go from ExecutorTest to Thread-sleep?
Just double checking: Was it intentional to go from ExecutorTest to test this?
suggestion this.primaryKeySymbols = Collections.uniqueIndex(tableInfo.clusteredByIdx).valueType();
suggestion this.primaryKeySymbols = null;
suggestion
@vilchik-elena Why not return Stream.empty();?
@vilchik-elena Why not return Stream.empty();?
@vilchik-elena Why not return Stream.empty()?
I'm not sure if we even need to do this when we're getting from a Retryer
I'm not sure if we even need to do this when we're getting from a Retry listener.
I'm not sure if we even need to do this when we're getting stuck in a loop...
Undo
we can handle the Exception here?
we can handle the Exception here and simplify the code.
I would just propagate the exception instead of e.printStackTrace() here.
I would just propagate the original exception instead of swallowing it. there is no need to catch it.
I would just propagate the original exception instead of swallowing it. there is no way to handle stacktrace.
It seems this could be defined as a constant somewhere?
It seems this could be defined as a constant somewhere, purposely it should be referenced from elsewhere.
It seems this could be defined as a constant somewhere, something like EMPTY_MAPQ_NAME.
Coding style :(
Coding style s/theirs/resource
Format?
This doesn't take a context. It should be named 'location_uuid'
This needs to be inside the if statement.
This doesn't take a context. It should be called getLocationService().
This method name is misleading, it doesn't give you the model, but you are calling it. Is that really needed?
This method name is misleading, it doesn't give you the same name.
This method name is misleading, it doesn't give you the model, but you are calling it. Is that really a problem?
Use CollectionUtils.isNotEmpty
Use CollectionUtils.isEmpty
use CollectionUtils.isNotEmpty
Better not to use this method directly, let's just return the list of images.
Better not to use this method directly, let's just return the list of locations.
Better to use Stream API for such operations
Do you need to restore this property?
Do you need to restore this?
Do you need to restore this property? The 'github' parameter is created for the servlet container?
You should create your own test.
You should create a new commented implementation with this.
suggestion
Can you define this variable outside the loop?
Can you declare this variable outside the loop?
Can we define this variable outside the loop?
This code could be extracted to a property or something like " edit.role%s.noparent" + trb.getString("access.role%s.noparent", roleIterator.next())
This code will be a lot of code that has the same code that is repeated in the "access.role%s.noparent" list and it might be a little more readable.
This code could be extracted to a property or something like " edit.role%s.noparent".
We could rename the test method into executePredicate.
Maybe using the lambda approach?
Maybe using the test method into the conditionalReplaceAll method and call it once?
.split(","))
Could we rename this to accessControlSecurityConfiguration?
.split(",")
Can you please switch to a basic for loop?
Can you please rename request.getScmAccounts to scmAccounts
Can you please update the condition to with the first argument?
Why not just add check for!?
Why it's not enough?
Why not just add instanceof?
Format
Use a try/finally
Use a logger
Please, use Collections.singletonList() which performs a null check.
Please, use Collections.singletonList() which performs a null check as soon as possible.
Please, use Collections.emptyList();
what about memory and network costs?
why memory and network costs?
why do you need these?
I can see the code follows the [project name](<LINK_0>
I can see the code follows the [project style](<LINK_0>
I can see the code follows the [project name](<LINK_0> :)
why changed toBuilder().id(null)?
why do we need a loop here?
why changed toBuilder().id(null)?
this is dangerous. This means that UNSPECIFIED will return something that is not set by the parent context of the trace manager. I don't think that's a good idea.
this is dangerous. This means that UNSPECIFIED will return something that is not set by the parent context of the trace manager. I don't think that's the case here.
this is dangerous. This means that UNSPECIFIED will return something that is not set by the parent context of the trace manager. I don't think that's a good idea here.
Are you logging this as a debug log?
Are you logging this as an info log?
Are you logging this as well?
This should be done in [this](<LINK_0>
This should be: OOMOUTFACTOR, shouldn't we keep the diff level in some kind of state?
This should be: OOMOUTFACTOR, shouldn't we keep the diff level in some sort of state?
assertTrue(queues.isEmpty(), "Expecting empty queues but was %s", queues)?
assertTrue(queues.isEmpty(), "Expecting empty queues but was %d", queues)?
assertTrue(queues.isEmpty(), "Expecting empty queues but was %s", queues)
You can remove the test using java.util.Objects.requireNonNull()
This test is wrong. You should check that the contactPoints are correctly added to the local metadata.
You can use the method reference instead of the 2 inetSocketAddress.
Why caps ANY_VALUE?
Why caps the entire string?
Why caps this?
It looks like this exception is handled by parser.getCurrentLocation()
It looks like you are using parser.getCurrentLocation() for each field...
It looks like this exception is handled by parseValueNode() method
minor: could you use TimeUnit.SECONDS.toNanos(mapName) instead?
minor: could you use TimeUnit.SECONDS.toNanos(entryCount) instead?
minor: could you use TimeUnit.SECONDS.toMillis(int) as it is more readable
I wonder if we should be caching the data. And also, we maybe decide to display it in Vectors.java.
I wonder if we should be caching the data. And also, we maybe decide to display it in Vectors.
I wonder if we should be caching the data. And also, we maybe have a Math.abs(b) method and public.
Please move this line into the if/else branch.
Please move this line into the if/else statement
Please move this line into the if/else branch, as it is not needed, in case profileList.getItems() is empty
:-1: I would prefer if the output of the test may not be too big.
:-1: I would prefer if the output of the test may be too strong.
I think it would be better to use the constructor of CommandInterpreter
Same here. We don't need to do this.
Did you mean to push this header into the one below?
Did you mean to push this header into the one above?
For all asserts, provide a 3rd parameter "message", which will be printed in case if the assert fails.
For all asserts, provide a 3rd parameter "message", which will be printed in case if assert fails.
For all asserts, provide a 3rd parameter "message", which would be printed in case if the assert fails.
Can cellProcessor be null? Is it possible to do this?
No need for cellProcessor, we already set cellProcessor to null.
No need for cellProcessor, just use addStrLength for those
I suggest using getPath() instead of getPath().
I suggest using getPath() instead of append(), it's more robust
I suggest using path.toString()
config.getPluginDirectory() this is ok without locking?
Only thing I've got here is that perhaps when you use this approach of design (interface - implementaion) then the implementation class should never occur anywhere in the code except for the constructing. So maybe a factory, or factory method would be a better fit here?
Only thing I've got here is that perhaps when you use this method, configuration.getSourceRoot() it is ok and it is a little confusing.
this will still work well, when the file is expired, it shouldUnzip = true
this will still work well, when the file is expired, it shouldUnzip = 0
this will still work well, when this is false, you should change it to throw an exception instead
You can use ListenableFuture<?> instead of Boolean and remove the null check.
You can use ListenableFuture<?> instead of Boolean and avoid the extra ListenableFuture in this block.
You can use ListenableFuture<?> instead of Boolean and avoid the extra ListenableFuture<?>.
I think this can be replaced by: return protocol.getSupportedTextCommands()? protocol.getSupportedTextCommands() : protocol.getSupportedDataCommands();
I think this can be replaced by: return protocol.getSupportedTextCommands()? protocol.getSupportedTextCommands() : protocol.getSupportedDataCommands())
I think this can be replaced by: return protocol.getSupportedTextCommands()? protocol.getSupportedTextCommands() : protocol.getSupportedDataCommands()
long hashCode;
long hashCode; try { hashCode = (long) mapBlock.getRawKeyBlock(); } catch (Throwable throwable) { throw handleThrowable(throwable); }
long hashCode; try { hashCode = computePosition(hashCode, hashTableSize); } catch (Throwable throwable) { throw handleThrowable(throwable); }
do we need 44 + _ here?
wait.... lets put _next_ to the initial position, _next_ is missing
wait.... lets put _next_ to the initial position, _next_ is too big.
Why exclude the -ea switch?
We do not want to replace the whole if-else with {} to make it more readable.
We still need to add the 'continue' step here.
Please check exception message
Please check exception message too
Please check exception message too.
since this really change is not related to the bug fix, the generics on the left side can be removed
since this really change is not part of the review, I think the generics on the ProxyHosts will be cleaner.
since this really change is not part of the review, I think the generics on the ProxyHosts will be better.
@vrushaliwaykole @dhanasp -- There is a null check inside branch.getBranchById and we're already checking null value for branch.getAssociatedArtifactId() as well.
@vrushaliwaykole @dhanasp -- There is a null check inside branch.getBranchById and we're already checking if it's null. Let's remove the null check verification from all null checks @Override
@vrushaliwaykole @dhanasp -- There is a null check inside branch.getBranchById and we're already checking if it's null. Let's remove the null check verification from else block and let the rest of the code return null.
Missing white space after =
Nice touch!
Missing white space after the =
"Failed for user {}."
"Failed for user '%s' not found"
Could you please add it to the "message" string?
Should we validate that it's not null?
Should we be swallowing the MalformedURLException?
Should we be swallowing this?
I'm wondering if this would be more readable if the JobRepositoryFactory.getJobRepository().getJob(context.getStep().getStep() == ExecutionMethod.AsStep) { Job job = JobRepositoryFactory.getJobRepository().getJob(context.getStep().getStep()); job.endJob(exitStatus); } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) { job = JobRepositoryFactory.getJobRepository().getJob(context.getStep().getStep()); job.endJob(exitStatus); }
I'm wondering if this would be more readable if the JobRepositoryFactory.getJobRepository().getJob(context.getStep().getJobId() is called only once?
I'm wondering if this would be more readable if we use an else if to reduce the nesting level. What do you think?
I don't see a reason for this Exception.
I don't see a reason for this Exception handling.
I don't see a reason for this. Is it only used in tests?
White line between methods
is "WGS 84" a constant?
is "WGS 84" a typo?
The same goes for all the changes in this file.
The same goes for all the changes in this file
The same goes for all the changes in this file,
Same question. E. g. in constructor, it uses NullHandling.emptyToNullIfNeeded(value). Could you also self-review once again ALL usages of emptyToNullIfNeeded(), emptyToNull() (if there are any remaining in the codebase), and reverse methods?
Same question. E. g. in constructor, it uses NullHandling.emptyToNullIfNeeded(value). Could you also self-review once again ALL usages of emptyToNullIfNeeded(), emptyToNull(), and Strings.emptyToNull() (if there are any remaining in the codebase), and reverse methods?
Same question. E. g. in constructor, it uses NullHandling.defaultString() (if there are any remaining in the codebase), and reverse methods?
I'd prefer to have this return an unmodifiable list.
I'm not sure this can be public, it should be private.
I'm not sure this can be public, it would be private.
Why do we need to wait here?
why do we need to wait here?
why do we need this?
This is the wrong error message. Should it be HIVE_PARTITION_DROPPED_DURING_QUERY? Or a generic HIVE_METASTORE_ERROR?
This is the wrong error message. Should it be HIVE_PARTITION_DROPPED_DURING_TIMESTAMP? Or a generic HIVE_METASTORE_ERROR?
Throw HIVE_METASTORE_ERROR
Can we append this logic to the app builder? It would be more readable as some other string resource.
Is there any case where users would want to set the same summary for the app? Could we extract the actual value from the database?
Is there any case where users would want to set the same summary for the app? Could we extract the actual setting from the Activity?
Null check on batchRyaStatement
Null check on this
Null check on the input parameters
suggestion if (!TextUtils.isNull(userObject.getId()) &&!userService.isLoginValid(login)) { I think this should be negated.
suggestion if (!TextUtils.isEmpty(login)) { I think this should be negated.
suggestion if (!passwordToAuth.isLoginValid(login)) { I think this should be negated.
this will be entry.getValue().executionDelay = entry.getValue().executionDelay + 1.
this will be entry.getValue().executionDelay = entry.getValue().executionDelay * 1.
this will be entry.getValue().executionDelay - POLLING_RATE
The space between getMuteCommands and its brackets doesn't match the style conventions followed by the rest of EssentialsX's code.
The space between getMuteCommands() and its brackets doesn't match the style conventions followed by this.
The space between getMuteCommands() and its brackets doesn't match the style conventions followed by the rest of google-code.
There's no need for this.
Not sure about this. Why don't we have checked for isSuccess here?
There's a better way to have this.
Use FileUtils.mkdirs
you want to check FileUtils.mkdirs
use FileUtils.mkdirs
Please use StringUtils.isEmpty()
please use StringUtils.isEmpty
please use StringUtils.isEmpty()
java builder.path(classPathAnnotation)
java builder.path(String.isEmpty());
isEmpty()
LOCATION_SPEC?
I'd go for something like this.
I'd go for something like this: java app.createProject().configure(...
Please throw an AssertionError instead of an error.
throw new KeeperException("Invalid flag value", flag);
Please throw an AssertionError instead of an error message.
suggestion Preconditions.checkArgument(authentication instanceof InternalAuthenticationException);
suggestion Preconditions.checkArgument(authentication instanceof InternalAuthenticationException, "InternalAuthenticationProvider: Empty Username");
suggestion Preconditions.checkArgument(authentication instanceof InternalAuthentication, "InternalAuthenticationProvider only supports InternalAuthentication.");
Small int is probably enough?
Would be nice to have something like ColumnInfo.
It looks like there's probably some other and the variable names should be ColumnInfo.
Single line for nodes not necessary.
Single line for nodes not needed here
Single line
If this method is called, why we still want to return null?
If this method is called, do we need to check it?
If this method is called, should we also log the error and continue?
This test should also assert that a literal is in a BigDecimal, not a literal.
This test should also assert that a literal is in a BigDecimal, not a String, and the new Path, which makes the test pass.
This test should also assert that a literal is in a BigDecimal, not a String, and the new Path, which can be used to be a String, which is the most expensive.
Opportunity to use it.
:+1:
Why this change?
I guess it's possible that field name is NULL_MARKER?
I guess it's weird that this method is static.
I guess it's unused
Typo: "Command Shell" should be a constant
Typo in line "Command Shell"
Typo: "Command Shell" should be a constant.
Did you mean to close the stream here?
space after " and h.uuid not in (select h from HostVO h)
space after " and h.uuid not in"
I don't understand why we need a delta delta delta delta. If anything else is true, the delta delta is set to true.
I don't understand why we need a delta delta delta. If anything else is true, the delta delta is set to true.
I don't understand why we need a delta delta delta. If anything else is necessary, I think the logic is to go into the constructor.
Can you use getOrDefault()?
Can you use parseInt() instead?
Best practices do not recommend using Exception.
suggestion Assert.state(!unitOfWork.phase().isAfter(PREPARE_COMMIT), () -> "It is not allowed to publish events when the last Unit of Work has already been published.");
suggestion Assert.state(!unitOfWork.phase().isAfter(PREPARE_COMMIT), () -> "It is not allowed to publish events when the current Unit of Work has already been published.");
Shouldn't this be caught somewhere else? Or is it set in the commit() method?
Being paranoid here, is it possible for the checksum retrieval code to fail?
Being paranoid here, is it possible for the checksum retrieval code to return null?
Variable 'cwl' is never used
why the.poll()?
why do we need to wait here?
why do we need to use getSubAttributes?
We may want to log the operation / chain id? I'm not sure "this operation" will be useful in the server.log.
We may want to log the operation / chain id? I'm not sure "this operation" will be useful in the server.
We may want to log the operation / chain id? I'm not sure "this operation" will be useful in the server.log. Also, the operation could be useful in the server log.
variable can be initialised with null
default should be false
variable can be initialised with null?
suggestion throw new TableException("FIXME SETTER");
Could you rename this variable to something like'static'?
suggestion } else {
You could just use Process proc = processBuilder.environment();
You could just say: Process proc = processBuilder.start();
You could just say: Process proc = processBuilder.start();?
This should be public
This should be public static
This can be declared as private static
Is there a reason for not using assertTrue(SourceWindowManager.isMainSourceWindow())?
Is there a reason why we are using an AbstractObjectExplorerEvent here?
Is there a reason why we are using an AbstractObjectShell here?
Make this readable, e.g. java return i == Const.POINTS_NOT_SUBMITTED? "<span class=\"color-neutral\"></span]" : ""
Make this readable? e.g. java return i == Const.POINTS_NOT_SUBMITTED || i == Const.POINTS_NOT_SURE?
Make this readable? e.g. java return i == Const.POINTS_NOT_SUBMITTED? "" : "";
This failure should not be handled by the BakingActionResult.failure(String path, String object)
This failure could not be implemented for multiple reasons. The caller should know what the action is.
This failure should not be required. The test should catch both exceptions and its not failure.
Looks like lastAckedTs.getTimestamp() is an Optional. Then you can just get rid of the lastAckedTs.getTimestamp().
Looks like lastAckedTs.getTimestamp() is not necessary.
nit: space after if
This message should be updated at debug level.
The message should be updated at the error level.
This message should be a little more detailed. Maybe warn?
1. this file isn't related to create snapshot flow. 2. do you persist the placeholder to keep it compatible with the rest of the code?
1. this file isn't related to the create snapshot flow. 2. do you persist the placeholder to keep it compatible with the rest of the code?
/s/NewSnapshot/CreateSnapshot
If the path doesn't exist, this will result in NPE.
Why is this necessary?
why is this necessary?
Sharable??
Sharable?? Also, please rename a method to "isDataDomain"
Sharable?? Also, please rename a method.
Can be simplified to: helper.waitForRegistrationAtServerSide(0);
Can't we use 'this' to try to avoid it?
Can't we use RegistrationAtServerSide here?
Should this be removed?
Should that be removed?
Should we consider performing this for NPE?
Please check whether task is shutdown or not.
Please check whether task is shutdown for the given user1
Please check whether task is shutdown for the given user?
It's better to use the lambda syntax here instead of the method.
It's better to use the method directly.
It's better to use the method name here as well.
Could not find mapping JavaScript function. Use string.format instead. It would make code more readable.
Could not find mapping JavaScript function. Use string.format instead.
Could we avoid throwing an exception? Could make it more specific.
Perhaps we should throw an exception if this is not supported.
Perhaps we should add a reference to the estimation on this message, I think.
Perhaps we should add a reference to the estimation on name.
Will this cause trouble later in this method? I'm wondering if this is validation we need to be doing in all cases & report on it.
Will this cause trouble later in this method? I think this can be done in other PRs
Will this cause trouble later in this method?
I'm not sure this is necessary, as are the when the offset needed to be set to 1, but the indirection needs to be added to.
I'm not sure this is necessary, as are the when the offset needed to be set to 1, but the indirection needs to be added to world
I'm not sure this is necessary, as are the when the offset needed to be set to 1, but the indirection needs to be added to world.
suggestion public void induceDeleteFailure(int count, ServerErrorCode errorCode) {
suggestion public void induceDeleteFailure(int count, ServerErrorCode errorCode) throws Exception {
suggestion private void induceDeleteFailure(int count, ServerErrorCode errorCode) throws Exception {
8192 isn't _that_ difficult to figure out why it's needed. If the file isn't already being 'null', then it could be an un-null value.
8192 isn't _that_ difficult to figure out why it's needed. If the file isn't already 'null', then it should be created and assigned to a local variable. Also, it should be "channel" instead.
8192 isn't _that_ difficult to figure out why it's needed. If the file isn't already 'null', then it should be created and assigned to a local variable. Also, it seems that the null check is redundant.
"protected" is redundant.
".." is redundant.
"...is not a valid value"
these two lines can be removed?
Missing whitespace.
Missing space after if
We don't need to check here if the first element is already present
We don't need to check here if the first element is already present.
It's better to use MessageUtils.getRabbitTypes() here
I don't think it needs to be this907?
I don't think it's the same as the name.
I don't think it's the same test that the user can set in this case.
Shall we use some assertions for the path variable?
Shall we use some assertions in the test
Formatting
These are missing the originatingAndId?
These are missing the originatingWhenId?
These are missing the originatingForAdmin() method?
Shouldn't it be template.match()?
Shouldn't it be template.2.3?
Shouldn't it be template.
Use parameterized logging instead of string concatenation.
Thanks for the fix.
Use parameterised logging.
I don't think we need to use PojoIndexedTypeIdentifier::convertToLegacy here, otherwise we'll be making the assumption that we're actually using it.
I don't think we need to use PojoIndexedTypeIdentifier::convertToLegacy here, otherwise we'll be making the assumption that we are actually not using it.
I don't think we need to use PojoIndexedTypeIdentifier::convertToLegacy here, otherwise we'll be going to write a version of it.
refactor
It'd be good to make this variable final
refactor?
Please change to assertThat(connection.getChunkLength(), 4096)
Please move gzip to something like this
Please move gzip to a finally block
@cagryInside Could you also add dispatchLocalHits() after reporting this event?
@cagryInside Could you also add a default value in R.string.analytics_label_regions to the user?
@cagryInside Could you also add the default value of getCurrentRegion() in this case?
Why do we retry pending requests while we are in the lock manager?
We should probably also update the log message to the lock state.
Why do we retry pending requests while we are in the lock server?
nit: you can use Objects.equals for other classes
nit: you can use Objects.equals for class equality checks
nit: you can use Objects.equals for class equality checks instead
The runtime-level API is a bit strange, maybe up to 100 columns, and create a private method inside this class, like is done in the "if (p.isQuery(query))" block, otherwise it's hard to understand, and very hard to follow. Maybe up to you, and use it here to determine which method is use.
The runtime-level API is a bit strange, maybe up to 100 columns, and create a private method inside this class, like is done in the "if (p.isQuery(query))" pattern, otherwise it's hard to debug
The runtime-level API is a bit strange, maybe up to 100 columns, and create a private method inside this class, like is done in the "if (p.isQuery(query))" block, otherwise it's hard to understand, and very hard to follow. Maybe up to you, and use it here to determine which filter the filter is actually used.
Does this test expects a IndexCache to be present on the cm?
Does this test expects a IndexCache to be present?
Does this test expects no index cache to be present on the cm?
Please use the common util method: java private static final String TEXT_MUTED = "URL";
Please use the common util method: java private static final String TEXT_MUTED = "URL_URL";
Please use the common util method: java private static final String TEXT_MUTED = "URL_http";
Please have test for this branch.
Please have test for null result.
Please add some space in the else clause.
Should also verify that the body is generated
Should also verify that the body is generated.
Should also verify that it is created using expected values.
as discussed offline, remove true and false by default.
If you really want to test this, you should just use a boolean that is passed to the thread started (with a parameter for the true) and then remove the synchronized block.
If you really want to test this, you should just use a boolean that is passed to the thread started (with a parameter for the true, false).
I think we should be able to use a stream here: for (final Path dmnModelPath : pathsHelper.getDMNModelsPaths(metadata)) { return definitions.stream().map(d -> Objects.equals(d.getNamespace(), modelNamespace).filter(Objects::nonNull)).findFirst().orElse(false); }
I think we should be able to use a stream here: try (final Path dmnModelPath : pathsHelper.getDMNModelsPaths(metadata)) { return definitions.stream().map(d -> Objects.equals(d.getNamespace(), modelNamespace).filter(Objects::nonNull)).findFirst().orElse(false); }
I think we could simplify this code by using Stream API
I think this should be: assertThat(symbolicValue("42").isAlwaysNullOrUndefined()).isFalse();
I'd prefer to have the constant symbols for each entry point.
I'd prefer to have the constant symbols for each of the three assertions.
Is this intended for this method to be called? If yes, please remove it.
Is this intended for this method to be called? If yes, just remove it.
Is this intended for debugging? If I understand correctly, this method is called for every @Override
nit: Removed stored segments
nit: Removed stored segments -> removed?
nit: Removed stored segments -> removed
Again, multiple exception types that are handled identically can be grouped in a single catch block.
Group exception types handled identically in a single catch block.
Again, multiple exception types which are handled identically can be grouped in a single catch block.
It seems this is an unnecessary change and should be removed.
It seems this is an incorrect log message
Consider changing this to debug.
Should this be an interface?
Should this be an implementation detail?
Use diamond operator.
Perhaps, isn't it possible to get the IPIdentification and connect into a new TechnicalException, since the IP is not available in the log?
Perhaps, isn't it possible to get the IPIdentification and connect into a new TechnicalException, since the IP and username are different in the message?
Perhaps, isn't it possible to get the IPIdentification and connect into a new TechnicalException, since the IP and username are different in the log message?
I think it would be better to call it 'hosts' here as well.
I think it would be better to call it 'hosts'.
I think it would be better to call it 'hosts' here.
Also with explicit contentType check java if (contentType == null) { return callApi(data,..); } else { return data.windowUntil(..).flatMap(fluxes -> { var contentType = getContentType(cachedBuffers); if (fluxes.size() == 1) { return callAPI(Flux.fromIterable(cachedBuffers)); } else { return callAPI(Flux.fromIterable(cachedBuffers)); } }).flatMap(fluxes -> { var contentType = getContentType(cachedBuffers); return callAPI(Flux.fromIterable(cachedBuffers)); }
Also with explicit contentType check java return getContentType(cachedBuffers).map(Response::fromIterable);
Consider using data.windowUntil(..).
You're missing a space after the parenthesis.
You're missing a && here.
You're missing a space after the ||
Do we need these escapes?
Do we need to call it before creating a new object?
Do we need this variable?
plz remove all this code
plz remove all this code.
plz
please log the exception before processing this.
please log the exception before processing this part
please log the exception before processing this part.
I would suggest to move this try/catch inside the finally to avoid the leak.
I would suggest to move this try/catch inside the finally block.
I would suggest to move this try/catch inside the finally to avoid the extra method.
Move this to the reader?
Move this to the test?
Move this to the test
> The message should be MarshalledCredentials.
> Use assertFalse(new Text()) here instead of concatenating strings.
Who uses the CouchDbClient?
Errr... you should verify this before you even push a new commit! =)
@r... you should verify this before you even push a new commit! =)
Errr... you should verify this before you even push a new commit! =]
Why public?
rename to key
rename to key?
This doesn't seem to be public.
This doesn't match the old version of the old version.
This doesn't match the old version of the existing equals() implementation.
why not keySize? from all parameters of the target parameters are different from source parameters
I select the bound key from the parameters
I select the bound key from the passed parameters
This hashCode() is probably not working, as it's always the same, but you can use Objects.hash()
This hashCode() is not working.
This hashCode() is probably not working.
What about doing one thing at a time? java assertThat(error).hasMessage("Lakers", "Bulls", "Spurs", "EpadTo", player.getName().getLast()).isGreaterThanOrEqualTo(player.getName().getLast()).isNotNotOnPpg("Lakers", magic, 30))).create();
What about doing one thing at a time? java assertThat(error).hasMessage("Lakers", "Bulls", "Spurs", "RDDkers", player.getName().getLast()).isFalse(); assertThat(error).isNotNull();
What about doing one thing at a time?
Should be removed
Should be removed.
Should be removed here
nit: you can replace those 2 lines with just call retrieved.values().iterator().next()
Why not just use an empty map?
Why not just use an empty List?
It looks like clientPorts can be initialized with a default port, thus we don't need to set it here.
It looks like clientPorts can be initialized with a default port, thus we don't need to worry about it.
It looks like clientPorts can be initialized with a default port.
See earlier question.
you can use values like you do in the other classes too.
you can use placeholders.
Doesn't this line wrap any.get call?
As far as I can see, we can use findFirst() in both cases to make it cleaner.
As far as I can see, we can use findFirst() in both cases.
Can you change this to something like below? java try { return entries.stream().map(file -> new JarFile(root)).collect(Collectors.toCollection(() -> { throw new RuntimeException("Classpath element is not a file: " + url)); } });
suggestion JarFile jarFile = new JarFile(root);
Can we use try-with-resources here?
Nit: missing space after equals.
Nit: missing space after equals
Nit: Wrap the body with a new line after the if.
Instead of this synchronized block, can we just use a method directly?
Instead of this synchronized block, can we just call pingMyServerTask directly?
Instead of ';'
i think we should have logic of this method. Can't we make it private?
i think we should have logic of this method. Can we make it private?
i18n
Could the above two lines be refactored into a method?
Could the above two lines be refactored into a method? That would help us more quickly.
Could the above two lines be combined into one?
can we just be a RuntimeException?
this will be adjacent to the buildTask, right?
can we just be a RuntimeException? case conversion is not necessary
This is an unrelated change
this is an unrelated change
Can you return this directly?
no need to cast to Map here
no need to cast to Map here?
no need for the cast to Map here?
Since the VM instance is being initialized just once, just remove the "isWindowsOsType" variable.
Since the VM instance is being initialized just once, just add a check: if (entity.isInitialized() &&!entity.isInitialized()) {... }
Since the VM instance is being initialized just before getting the VM object, couldn't we just initialize it inside the constructor now?
could arr[0] be null?
nit: arr[0] -> arr[0]
could be arr[0] == null
Can you move these declarations to the if block?
Can you switch to the logger logger?
Can you move these declarations to the if clause?
should probably be Integer.valueOf(100) to be a constant.
should probably be Integer.valueOf(100)
should probably be Integer.valueOf(100) to avoid any confusion.
I think it can be more efficient to use a StringBuilder here, and not worry about the fact that this might break for some parts of the code.
I think it can be more efficient to use a StringBuilder here, and not worry about the fact that this might break for other parts of the code.
I think it can be more efficient to use a StringBuilder here, and not worry about the performance.
This will fail if there are no entries in an existing list.
This will fail if the adapter has a null array.
This will fail if there are no strings in an object.
You might want to use Stream API here, but for the sake of readability, it seems we could easily use Map.of( keyColumnExpressions, creationProcess ).collect(toList() );
You might want to use ImmutableList.Builder instead, to avoid the need for a list.
You might want to use Stream API here, but for the sake of readability, it seems we could easily use Stream API with a bit more SLAP wrapper around it.
Isn't it better to use equals here? That does not taking args.
Isn't it better to use equals here? That does not taking advantage of the regex special.
Would it make sense to have a table with lowercase brackets?
The operation runs in a background thread; this access to get the checkout result may not work.
if this touches workspace files lock on repository level and use WorkspaceJob
Instead of a hard coded String can you use BranchOperationUI.parseFromBranch(...).
I think we should create a defensive copy of the Map
I think we should create a defensive copy of the map.
I think we should create a defensive copy of the map
this catch block is unnecessary.
this catch block is not needed
this catch block is redundant.
what is the difference between this build and the above build?
I think this should be in a constant
I think this should be a constant
redis() should be accessed as static method.
This line can lead to a DNS lookup (blocking call).
This line can lead to an exception (blocking call).
Please, use try-with-resources: try (Thread future = executor.submit(secondThread)) { future.get(1, TimeUnit.SECONDS); } catch (TimeoutException ex) { // TimeoutException should not be thrown }
Please, use try-with-resources: try (Thread future = executor.submit(secondThread)) { future.get(1, TimeUnit.SECONDS); } finally { future.unlock(); }
Please, use try-with-resources
I'm wondering why do we need this cache? These looks like classes that are already added in the cache?
I'm wondering why do we need this cache? These looks like classes that are usually in the base class, are it?
I'm wondering why do we need this cache? These looks like classes that are usually in the base class, are there?
final List<CompletableFuture<PhysicalSlotRequest>> executionVertexSchedulingRequirements.stream().map(ExecutionVertexSchedulingRequirements::getExecutionVertexId).collect(Collectors.toSet()); final List<PhysicalSlotRequest> executionVertexSchedulingRequirements = createPhysicalSlotRequestFutures( physicalSlotRequestFutures, executionVertexSlotRequestIds, executionVertexSlotRequestIds);
final List<CompletableFuture<PhysicalSlotRequest>> executionVertexSchedulingRequirements.stream().map(ExecutionVertexSchedulingRequirements::getExecutionVertexId).collect(Collectors.toSet());
suggestion final List<PhysicalSlotRequest> executionVertexSchedulingRequirements = getAllPhysicalSlotIds();
woudln't it make sense to have the system register only if all dependencies are present? (Also I am not sure if this is a good concept in general, but since some people want it i won't object)
woudln't it make sense to have the system register only if all dependencies are present? (Also I am not sure if we want it i since most people want it i won't object)
woudln't it make sense to have it Storage Common?
reorder
add 'e'
add getMessage
I think this should be IMAGE_SIE since you have a vanilla StepVerifier
I think this could be a static method in the ClusterShardedDeployment. Then you don't need to instantiate it each time.
I think this could be a static method in the ClusterShardedDeployment. Then you don't need to create it each time.
Return empty string instead?
Return empty string here?
Return empty cursor?
You should encode the URI to a URL and rename it to just typeSpec.
You should encode the URI to a URL and rename it to something more meaningful.
You should encode the URI to a longer-qualified path.
What is the purpose of this change?
What is the purpose of this check?
binaryKeys
This could be done in a single call since it is only called from two places.
This could be done in a single call since it is only called from within the loop.
This again gets logged.
nit: if the only usage is to find diff b/c if it's now replaced with System.currentTimeMillis() might be preferred option?
nit: if the only usage is to find diff b/c if it's now available, directly using System.currentTimeMillis() might be preferred option?
nit: if the only usage is to find diff b/c if the only usage is to find diff b/c if the method is called?
Suggest a local private method for this, so that it's more readable.
Suggest using a local private method for this in the activity.
Suggest a local private method for this, so that this one can be reused by the UI
can you update this path to set in TaskRunnerUtils?
can you update this path to set in TaskRunnerUtils
@Nullable
Should we return null in this case? Or would it be better to throw an exception?
Should we return null in this case? Or would it be better to throw exception?
Should we return null in this case? Or would it be better to throw an exception instead?
Why should we have this condition as a boolean?
Why should we have this condition as a boolean rather than a boolean?
Why should we have this condition as a constant?
I still think you should use pluginInfo to be null, so pluginInfo can be null
Should be pluginInfo.
I still have an idea of how you use plugin names, so I would use resource names for all plugins, and also plugin.
Can this be moved into the finally block?
Can this be moved into the else if?
Should this be "ugo+"?
please replace this with an instance variable
please replace this with an import rather than import
please replace this with an import rather than import.
We should turn the auth system back on after creating the test data.
I believe the Auth system should remain on in this method.
We should turn all auth system back on after creating the test data.
I think you want to use CodingErrorAction.REPORT instead of CodingErrorAction.REPORT
I think you want to use [this](<LINK_0> instead.
I think you want to use CodingErrorAction.REPORT instead of CodingErrorAction
This logic is duplicated in the createEndpoint() method. Maybe we can introduce a new method that returns the channel name as a parameter?
This logic is duplicated in the createEndpoint() method. Maybe we can introduce a new method that returns the poller and this method all checks for not-null?
This logic is duplicated in the createEndpoint() method. Maybe we can introduce a new method that returns the poller and this method all checks for not null?
You should probably not store the previously started true value until the user completes the changing room and proceeds to the map, so in case the action stops in the middle, you don't leave an inconsistent state
You should probably not store the previously started true value until the user completes the changing room and proceeds to the map, so in case the action stops in the middle, you won't leave an inconsistent state
Please store the previously started true value until the user completes the changing room and proceeds to the map, so in case the action stops in the middle, you don't leave an inconsistent state
Now it's correct! :+1:
Now it's correct! :+1: We've moved the old code back, let's fix this.
@squilter great! :+1:
Again, instead of clone(), pass in an object state listener.
Again, instead of returning Observable.empty().
Again, exception.
no need to do it now, you can just do it in constructor
no need to do it.
no need to do it here.
When you open a repository you have to ensure to close it after you're done with it, so that the resource handle is decremented. I think you need to have a finally block where you call repo.close().
When you open a repository you have to ensure to close it after you're done with it, so the resource handle is decremented. I think you need to have a finally block where you call repo.close().
When you open a repository you have to ensure to close it after you're done with it, so that the resource handle is decremented. I think you need to have a finally block where you call repo.close.
I think we could have a protected method here that takes a byte buffer instead of a character here. Something like void putKeyValueSize(byte buffer, int keySize, int valueSize ) { byte firstByte = (byte) (keySize & MASK_ONE_BYTE_VALUE_SIE ); if ( hasAdditionalKeySize ) { cursor.putByte( (byte) (keySize & Flag.MAX_VALUE_SIE ); } else { cursor.putByte( (byte) (keySize & Flag.MAX_VALUE_SIE ); } }
I think we could have a protected method here that takes a byte buffer instead of a character here. Something like void putKeyValueSize(byte[] keySize, int valueSize ) { byte firstByte = (byte) (keySize & MASK_ONE_BYTE_VALUE_SIE ); if ( hasAdditionalKeySize ) { cursor.putByte( (byte) (keySize & Flag.MAX_VALUE_SIE ); } else { cursor.putByte( (byte) (keySize & Flag.MAX_VALUE_SIE ); } }
I think we could have a protected method here that takes a byte buffer instead of a character here. Something like void putKeyValueSize(byte[] keySize, int valueSize ) { byte firstByte = (byte) (keySize & MASK_ONE_BYTE_VALUE_SIE ); if ( hasAdditionalKeySize ) { cursor.putByte( (byte) (keySize & Flag.MAX_VALUE_SIE ); } else { cursor.putByte( (byte) (valueSize > SHIFT_LSB_VALUE_SIE ); } }
You can annotate this example with @JvmStatic and remove this preprocessors.
You can annotate this method with @VisibleForTesting.
You should not remove these changes.
Does this need to be modifiable? If not, List.of() is the conventional preference for empty lists.
Does this need to be modifiable?
Does this have to be the same for all JSON files?
Extraneous whitespace
Same here, do we subscribe to the SUBNET_ADDRESS?
Same here, do we have any subscribe()?
I think you can just use Objects.hash( ) here.
I think you can just use Objects.hashCode for all these variables.
I think you can just use Objects.hashCode for all these variables
This should be too complex.
This should be too complex, e.g., throw OrmException
This should be too complex, e.g., a.
what is this new condition about? is this related to the original story? anyway, this seems a good place to use 415/Unsupported Media Type
what is this new condition about? is this related to the original story? anyway, this seems a good place to use SmsSessionRequest.class.equals(msg.getSid()))
what is this related to the ticket? anyway, this seems a good place to use 415/Unsupported Media Type
I don't think you need to add a default case for ANY and ONLY?
I don't think you need to add a default case ANY_ADDRESS and SUBNET_MATCH?
I don't think you need to add a default case for ANY and OFF attributes; there is no default case for OFF.
Might be worth logging something here (e.g. warning)?
Might want to wrap the lhs/rhsMaterialized in a try/catch, to make it consistent with the constructor and line 44 below.
Might want to wrap the lhs/rhsMaterialized in a try/catch, to make it consistent with the constructor?
why don't you just use the method getCollisionCategory().autoPopulateData() instead of inside the if/else above? Then the name method will be more generic.
why don't you just use the method getCollisionCategory().autoPopulateData() instead of this? Then the name method will be more generic.
Can this return an empty set instead to avoid the exact size?
@piddubnyi full path LastModifiedCachingWire.LAST_VERSION
@lautarobock Why this change?
@piddubnyi full path LastModifiedCachingWire.SEPARATOR
No need to use UriBuilder
Use formParam() instead
Use UriBuilder
I think you need to assert that the return value is 0.
I think that you need to assert that the return value is 0.
I think this test could also assert that the return value is 0.
I guess that it is already done in line 55, no?
I guess that it's better to load the data before binding.
I guess that it's better to load the data before binding to the DB.
This is not thread safe. In case of an exception, the writeLock is not set at all.
This is not thread safe. In case of an exception, the writeLock is not created.
You need to lock the writeLock here since it is not acquired.
I prefer: java for (String t : types) { if (strict) { return Collections.emptyMap(); } }
You could just do a [Expected TreeMap](<LINK_0> here to avoid the extra indentation?
I prefer: java for (String t : types) { if (strict) { throw new IllegalStateException("Some useful message"); } }
Add doc Add @Override
I am not sure if this is the right implementation. If we want this to work with existing hbase code, we should always return false. If we do not allow user to call this method, we should throw an exception.
I am not sure if this is the right implementation. If we want this to work with existing hbase code, we should always return true. If we do not allow user to call this method, we should throw an exception.
This is not what I would expect. Wrong method name says: "org.apache.commons.lang.Validate..."
This is not what I would expect. Wrong method name says: "org.apache.commons.lang.Integer" is not cast to long, but rather a long".
This is not thread safe.
Use.orElseThrow(() -> new RestClientException(new RuntimeException(message)) instead
Use.orElseThrow(() -> new RestClientException(new EntityNotFoundException(message)) instead
Use a orElseThrow with a descriptive message here?
Could you please change this variable name to 'IProject' or something like that
Could we change this variable name to 'IProject' or something like that
Could we change this variable name to 'IProject' or something like that?
This can be split into two lines.
This could be split into two tests
This can be split into two tests
Not sure if this is good, but I'd prefer to use ContextCompat instead of getDrawable(nodeMainExecutorService, 0);
Not sure if this is good, but I'd prefer to use registerNodeMainExecutorService instead of letting it listen to the service.
Not sure if this is good, but I'd prefer to use registerNodeMainExecutorService instead of letting it listen to the service completion.
You should better catch NumberFormatExceptions here and set 0 as a fallback.
you should better catch NumberFormatExceptions here and set 0 as a fallback.
Use braces for this if statement.
It is not good to use "--".
It is not really needed.
typo.
Could you also check that the timeout wasn't set because of the timeout?
Could you also check that the timeout wasn't set?
Could you also verify that the timeout wasn't changed because of the timeout?
Why not collapse these three lines into one?
Why not collapse these two lines into one?
Please add the final keyword.
style nit: we don't use spaces around single line blocks
style nit: we don't use braces around single line blocks
Please use String.format(...) with an overload to replace multiple stringbuilder
this code is not handled directly in the UI thread; could we move to a private method
this code is not handled directly in the UI thread; better to have a bullet local
this code is not handled properly
A double negative. Use isEmpty instead?
A double negative. Use isLogId instead?
A double negative. Use isEmpty or CoreUtilities.isEmpty?
Is there a reason to have the pattern as an instance variable rather than simply passing it as a parameter? That's not the end of the method...but I'm not eager to accept it as a change in the end of the method.
Is there a reason to have the pattern as an instance variable rather than simply passing it as a parameter? That's not the end of the method...but I'm not eager to accept it as a change in the end of the method...
Is there a reason to have the pattern as an instance variable rather than simply passing it as a parameter? That's not the point of view of this method.
This is not the right way to do this. It needs to be revEdits or revEdits ;)
This is not the right way to do this. It needs to be revEdits or revEdits, or.
This is not the right way to do this. It needs to be revEdits or revEdits, if you want to change this after it is accepted.
If result is an instance of Map, the code is redundant because result.isAcknowledged() already returns false.
If result is an instance of Map, the code is redundant because result.isAcknowledged() already returns true for the Map case.
If result is an instance of Map, the code is redundant because result.isAcknowledged() already returns false
Here is an example. Suggest using a factory instead.
Here, you should never set the lock to false.
Here, you should never set the lock flag. Is that intentional?
I think it would be more clear to log the exception in this case?
I think it would be more obvious to log the exception in this case.
I think it would be more clear to log the exception
Consider extracting this into its own function called addBuyOrderToOrderBook or simply addBuyOrder.
Consider extracting this into its own method called addBuyOrderToOrderBook or simply addBuyOrder.
Consider refactoring this into a function called addBuyOrderToOrderBook or simply addBuyOrder. Extract method refactoring.
Method on the minimum level of the name.
Method on the minimum level of the name. Consider refactoring.
Method on the minimum level of the codebase is allowed to consider.
if (getWindow()!= null ) {..} may help
if(getWindow()!= null ) {..} may help
if(getWindow() == null ) {..} may help
The macs are just'marked' as to be removed, only on 'commit' it will be actually removed from the pool.
pleas make sure that if compensation isn't null then you don't have to check it.
The macs are just'marked' as to be removed, only on 'commit' it will be actually duplicates.
remove changes in this class
remove changes from this class
remove
To make it easy to read the code it would be better to handle case-insensitive comparison as well, consistent with the rest of the code.
To make it easy to read the code it would be better to handle case-insensitive comparison.
To make it easy to read the code it would be better to handle case-insensitive comparison as well, consistent with the rest of the file.
rather calloutContent.setText("PlaceName" + graphic.getAttributes().get("StAddr").toString() //
String.format
String.format()
This seems wrong. The fact that MavenSlf4jWrapperFactory is in the same as the cluster. So we could do something like: if (logger.isInfoEnabled( "..isThresholdHit() ) ) { MavenSlf4jWrapperFactory loggerFactory = (MavenSlf4jWrapperFactory) iLoggerFactory; loggerFactory.getLogLevelRecorder().filter( LogLevelRecorder::isThresholdHit ).forEach(recorder -> log.debug("Trace for {}", event.getSession() ); }
This seems wrong. The fact that MavenSlf4jWrapperFactory is in the same as the cluster. So we could do something like: if (logger.isInfoEnabled( "..isThresholdHit() ) ) { MavenSlf4jWrapperFactory loggerFactory = (MavenSlf4jWrapperFactory) iLoggerFactory; loggerFactory.getLogLevelRecorder().filter( LogLevelRecorder::isThresholdHit ).forEach(recorder -> log.debug("Trace for %s", event.getSession() )); }
This seems wrong. The fact that MavenSlf4jWrapperFactory is in the same as the cluster. So we could do something like: if (logger.isInfoEnabled()) { return; }
this should be an error instead of logging
this should be an error instead of info
this should be an error
The idea of creating the span is that we don't want to use the method. Couldn't we just call it once and re-use it?
The idea of creating the span is that we don't want to use the method. Couldn't you just call it once and re-use it?
The type of the span will be sufficient to avoid the casting.
I think it is better to use parameterized logging here.
If a debug log level is configured, we should specify error message in warn
I think this should be DEBUG
Could use a multi-try-with-resources try (Scanner commands = new FileWriter(tmpCertFile, false)) { fw.write(C.WINDOWS); commands.add("verify"); }
Could use a multi-try-with-resources try (Scanner commands = new Closeable(); fw.write(pki.getCACertsDir(caType), "ca-chain.cert.pem"));
Could be combined with the multi-try-with-resources
Do we need that log?
Do we want to recover here if the environment is not found?
Do we want to log the environment name here?
remove all System.out
Remove all System.out
remove all this println
if you have enum... never will append it anyway
if you have enum... never will 'null' throw exception, all 'throws' is not necessary.
if you have enum... never will 'null' throw excisable
we should at least log a message here.
we should at least log a failure event here.
we should at least log a failure event here too.
consider using org.jboss.weld.environment.Platform.DefaultLogger.IS_UTF_8.
consider using org.jboss.weld.environment.Platform.Encoding.UTF_8.
consider using org.jboss.weld.environment.se.Assert.assertEquals(..., m -> {...});
probably should remove the andFinally() since it is already called in the end.
probably should not be andExceptionally more appropriate.
Merging(item)
what if value is invalid?
What if value is null?
What if value is invalid? It is not a valid value.
Let's keep the s() business rule for now.
Let's keep the s()
Let's keep the s() business rule for the user.
Super nit: unintentional additional white space I assume.
Super nit: unintentional additional white space I guess.
Super nit: no need to call consume here.
Should we use the attribute name here too?
Should we use the attribute name here as well?
Should this element be a constant?
This is not going to work. The plan tree JSON can be the json for both "test" and "test".
This is not going to work. The plan tree JSON is supposed to be the job of the plan tree. So all the calcitePlanTree JSON queries to the plan tree should be the job of the plan tree.
This is not going to work. The plan tree JSON is supposed to be the job of the plan tree. So all the calcitePlanTree JSON queries to the plan tree should be the split of plan tree.
I don't like System.out.println, use a logger.
I don't like System.out.println, use a logger. (And add a parameter for the message)
I don't like that we must use System.out.println() for the test
Minor: this is not used anymore, is it intentional?
Minor: is this timeout value for this test?
Minor: this is not handled properly, you may want to test it more, and return it instead of throwing an exception.
Why isn't the test for the version being null? At this point we'll have stale data, at least it's not.
Why isn't the test for the version being null? At this point we'll have stale metadata, at least it's not.
Why isn't the test for the version being null? At this point you'll need a test for the version.
Better to use forEach here?
Better to use isEmpty instead of equals.
Better to use isEmpty instead of equals?
You should create the FileChannel in a try-with-resource block, otherwise it is never closed.
You should create the FileChannel in a try-with-resources block, otherwise it is never closed.
You should create the FileChannel only once, otherwise it is never closed.
The logic in this method is quite heavy for each click. It's better to create a new method in AppPage.
The logic in this method is quite heavy for each click. It's better to create a new method in GroupsElementFactory to avoid passing the List<String>.
The logic in this method is quite heavy for each click. It's better to create a new method in GroupsElementFactory to add those options and return only the title of the element.
You have to use psiElement here. E.g., import com.intellij.erlang.psi.ErlangFile and use it here.
You have to use psiElement here. E.g., import com.intellij.erlang.psi.ErlangFile and use it directly.
You have to use psiElementUtil#isClassLiteral here.
I am a little worried about this test. It looks like this should be fixed in the test1.
I am a little worried about this test. It looks like this should be fixed in the test1. I'm not sure this is what it really means.
I am a little worried about this test. This is the same as the one in UnifiedTests.
.switchIfEmpty(event.getTimestamp().isAfter(dateTime) || event.getTimestamp().isAfter(dateTime))
.min() isn't needed since.orElse(createHeadToken()) already returns a boolean. Up to you.
.min() isn't needed since.orElse(createHeadToken()) already returns a boolean..min() is enough.
I'm not sure this one is correct. In this case, we need to get the host ID from the uniqueId map. Shouldn't the container ID be the identifier of the project?
I'm not sure this one is correct. In this case, we need to get the host ID from the uniqueId map. Shouldn't the container ID be the identifier?
I'm not sure we need to do this. part of the PR
Does this need to be changed? It's unrelated to this PR, but this change should go into a separate commit.
Does this need to be changed? It's unrelated to this PR, but this change should go into a different commit.
Does this need to be changed? It's unrelated to this PR, but this change should be unrelated.
This can be simplified to () -> endTime.value() > 0, 10_000);
This can be simplified to : startGridsWithCache(2, dfltCacheCfg, SNAPSHOT_METRICS);
Please make error more informative
[minor] style-nit: no braces around single line blocks
[minor] style nitpick: no braces around single line blocks
[minor] style nit: no braces around single line blocks
"[a-z][a-zA-0-9.:"
add the '!key.getText()'?
Separated lines?
I think we can use some constants here. What do you think?
This should be a constant.
I think we don't need this else. If user does does the refresh task, it is initialized in the class constructor.
We need to add an assertion to make sure this is valid
We discussed this test to make sure it is valid and not invalid.
We should use assertThat.
please add this method to the nested class.
please add this method to the builder as well.
please add a space after if
Can you please make it public?
Can you make it an else?
could you please make it a VDS?
Consider saving the instance to c.getAdvancedCache().getTransactionManager().begin() and making it a local variable.
Consider saving the instance to c.getAdvancedCache().getTransactionManager().begin(); in a local variable.
Consider saving beginTransaction or commit() in a finally block.
This should not be here; it's part of the gtk_size_allocate.
This should not be here; it's part of OS.gtk_monitor_point.
This should not be here; it's a debug message.
I think it is better to use pathCache.get(key) instead of calling.get() again.
I think it is better to use PathCache.get(key) instead of calling.get() again.
I think it is better to use pathCache.get(key) instead of.get() to avoid the lookup twice.
this is generally an anti-pattern in the tests and leads to flakey tests. e.g. we can see on some test environments that are oversubscribed. I'd suggest something very short, e.g.: public static final StringBuilder append(String indent) { return buffer.append(Character.toChars(characterSet[indices[i]]); }
this is generally an anti-pattern in the tests and leads to flakey tests. e.g. we can see on some test environments that are oversubscribed. I'd suggest something very short, e.g.: public static final StringBuilder append(String string) { return buffer.append(Character.toChars(characterSet[indices[i]]); }
this is generally an anti-pattern in the tests and leads to flakey tests. e.g. we can see on some test environments that are oversubscribed. I'd suggest something very short, e.g.: public static final StringBuilder append(String indent) { return Arrays.copyOf(characterSet[indices[i]]); }
Please don't print stack trace like this. Any way to avoid it?
Please don't print stack trace like this. Log.error(e, t);
Please don't print stack trace like this. Log.error(message, e)
Don't bother. This doesn't help, as we found out.
Don't bother. This does not help, as we found out.
Don't bother. This doesn't help, as we found out. ;)
what if this is an exception?
what's the reason for the double-checked locking?
what's the reason for the double-checked locking to do this?
This seems to be duplicated. Can you extract it to a private method?
This seems to be duplicated. Can you extract it to a static method?
This seems to be duplicated. Why not just iterate over the taskFormModel?
You should probably split this into a method so that the code doesn't get called if the filter is false.
You should probably split this into a method so that the code doesn't get executed where it throws an exception.
You should probably split this try/catch into a new method so that the code doesn't get executed where it throws an exception.
why do we need to put the String.format() logic inside the constructor? (Line seems more readable to me).
why do we need to put the logic behind the config? Can't we just pass the getStreamId to the config?
why do we need to put the logic behind the config? Can't we just pass the getStreamId to the config?
call super.hasMailAuth()
call super.getCurrentMailAuth()
call super. no attributes
Constants.DEFAULT_PANDBY_NAME = "xdg-open".
Constants.DEFAULT_PRIBUTING
Constants?
I'd rather this loop be split in to : "return diff.getEquivalence().getEOpposite() && candidate.getState() == DifferenceState.UNRESOLVED"
I'd rather this loop be split in to : "return diff.getEquivalence().getEOpposite()" and "return candidate.getState() == DifferenceState.UNRESOLVED"
I'd rather this loop be split in to : "return diff.getEquivalence().getEOpposite()" and "return candidate.getState() == DifferenceState.UNRESOLVED" to avoid the loop and the loop.
Please use StringBuilder.append() - otherwise will use String.format() in case of performance.
Please use StringBuilder.append() - otherwise will use String.format() in case the compiler is not presented to the user.
Please use StringBuilder.append() - otherwise we miss one element
what is the motivation for changing this method?
what is the motivation for this change?
what is the motivation for removing the extra line?
Shouldn't this be the thingType id instead of the modelId (modelId can be logged as well, but the primary information should imho be the thing type)?
Shouldn't this be the thingType id instead of the modelId (modelId can be null)?
Shouldn't this be the thingType id instead of the modelId (modelId can be logged as the primary key)?
Extraneous whitespace
Extra line of code
Unused variable
If you want to use the RuntimeException of the return value of the method, you can use here.
If you want to use the RuntimeException of the return value of the method, you can use that.
If you want to use the RuntimeException for the parameter you can use here.
No need to use refresh here.
No need to use refresh here
No need to use a refresh here
suggestion if (args.length > 0) {
suggestion if (args.length > 0) { throw new AxeRuntimeException(error); }
Please remove this redundant check as we discussed in another PR if we need to touch it.
This is inconsistent with the test on whether an element is active or not. Why do you need unchecked check in both cases?
This is inconsistent with the test on whether an element is active or not. Why do you need unchecked check in the for loop?
rename to child
It's a warning. Do we want to log the complete stack trace for a warning? Check with <LINK_0>
It's a warning. Do we want to log the complete name for a warning? Check with <LINK_0>
It's a warning. Do we want to log the complete check? Check with <LINK_0>
Hi @stevenschlansker, I think this should be Throwable (_the father of all errors_). The Error case is very specific and I assume it was only provided in #1405 as an example to demonstrate the problem, but in a wild there is a bunch of Throwable monsters (especially in Scala) which are neither Exception nor Error but which extends Throwable and can easily flip stack trace upside down. Therefore, if there are no other reasons to limit a range of throwables being caught here, I think this should be changed to: java } catch (Throwable t) { Both Error and Exception are instances of Throwable, but the Error is **not** instance of X extends Exception. I guess this works only because IDE or compiler did not pick it up, because generics are erased in compile time and X extends Exception disappears, or maybe, just hypothetically, because Error is a magical monster which can be cast to any other exception (but I'm not aware of such magical Error properties).
Hi @stevenschlansker, I think this should be Throwable (_the father of all errors_). The Error case is very specific and I assume it was only provided in #1405 as an example to demonstrate the problem, but in a wild there is a bunch of Throwable monsters (especially in Scala) which are neither Exception nor Error but which extends Throwable and can easily flip stack trace upside down. Therefore, if there are no other reasons to limit a range of throwables being caught here, I think this should be changed to: java } catch (Exception e) { Both Error and Exception are instances of Throwable, but the Error is **not** instance of X extends Exception. I guess this works only because IDE or compiler did not pick it up, because generics are erased in compile time and X extends Exception disappears, or maybe, just hypothetically, because Error is a magical monster which can be cast to any other exception (but I'm not aware of such magical Error properties).
Hi @stevenschlansker, I think this should be Throwable (_the father of all errors_). The Error handling is very specific and I assume it was only provided in #1405 as an example to demonstrate the problem, but in a wild there is a bunch of Throwable monsters (especially in Scala) which are neither Exception nor Error but which extends Throwable and can easily flip stack trace upside down. Therefore, if there are no other reasons to limit a range of throwables being caught here, I think this should be changed to: java } catch (Throwable t) { Both Error and Exception are instances of Throwable, but the Error is **not** instance of X extends Exception. I guess this works only because IDE or compiler did not pick it up, because generics are erased in compile time and X extends Exception disappears, or maybe, just hypothetically, because Error is a magical monster which can be cast to any other exception (but I'm not aware of such magical Error properties).
why not use the static String.equals(resultLine)
why not use the static String.isEmpty(resultKey)
why not use SUCCESS!
nit: Could statically import assertEquals()
nit: Could statically import these assertions.
nit: Could statically import assertEquals
There is no need to test the upper case.
There is no need to test method that accepts a list as an argument.
There is no need to test method that accepts a list instead of a list..
I wonder if using type().toString() would already perform the same.
I wonder if using type().toString() would be better.
I wonder if using class.getName() instead of c.getName().
nonVmMtu5000 ==> nonVm
nonVmMtu5000==true
nonVmMtu5000==false
is this the 'button' described in commit message? do we really need this Label?
is this the 'button' described in commit message? do you really need this Label?
is this the 'button' described in commit message? do we really want this Label?
This line does not match with the method name.
This line does not match with the previous check
This line does not match with the previous one.
this is not needed, you can use "?includeSLA=true" instead.
this is not needed, you can use "?includeSLA=true" instead.
this is not needed, right?
It doesn't need to be public
Could you rename the variable name to distinguish it and use it in the future?
It doesn't need to be public.
I think we can even call entry.getValue() for the sake of consistency.
I'd prefer using [ImmutableMap.of](<LINK_0> instead of the raw type.
I think we can even call entry.getValue() here.
suggestion pullWaitStat = pullWaitStats[threadId];
suggestion pullWaitStats = pullWaitStats[threadId];
suggestion LOG.log(Level.INFO, "Please print "PS Elapsed Time: {0}, Sum Push: {1}", pullWaitStats[threadId];
You need to do early-exit if (jenkins == null) { return; } to avoid 1 second param.
You need to do early-exit if (jenkins == null) { return; } to avoid 1 second liner.
You need to do early-exit if you're interested at this.
LASUtils.BLACK_TEAM should be removed.
LASUtils.BLACK_TEAM should be moved to a constant.
LASUtils.BLACK_TEAM should be done in the checks.
please use.collect(...)
Use.orElseThrow(...) instead
Use.orElseThrow(...)
Please use diamond operator
Please use ArrayList
Please use use diamond operator
This isn't necessary.
This doesn't seem to be the right way to fix it.
This doesn't seem to be necessary.
[minor] this can be replaced with binding(TemplateInterfaceListModel.class).in(Singleton.class);
:+1: for using the binding
[minor] }
Would nice to have the default value 4 minutes as well
Woulds nice to have the default value 4 minutes as well
Would nice to have the default value 4 minutes as well.
suggestion } catch (InvocationTargetException e) {
suggestion } catch (InterruptedException e) {
rename to role
For better readability, we use: if (isCurrentUser() && getSessionToken()!= null &&!newState.get(KEY_SESSION_TOKEN)) {... }
For better readability, we use: if (isCurrentUser() && getSessionToken()!= null) { if (isCurrentUser() && getSessionToken()!= null) { newState.newBuilder().put(KEY_SESSION_TOKEN, getSessionToken()) } }
For better readability, we use: if (isCurrentUser() && getSessionToken()!= null) { if (isCurrentUser() &&!getSessionToken() &&!isAuthData()) { // create state } } if (isCurrentUser() && getAuthData()!= null) { // create state }
Shouldn't this be getNonNullRequestParamValue?
Is it possible for userInfo to be null? For example if it is null, I would prefer if (StringHelper.isEmpty(getRequestParamValue(Const.ParamsNames.REGKEY)) to be consistent with the other logic.
Is it possible for userInfo to be null? For example if I send a non-null username/password pair you should fall back to the default case.
if traceToken is null, then you can initialize this with traceToken = null.
if tracingToken is null, we dont want to initialize this with null.
no need for this variable
nit: extract this to a method
nit: extract this to a private method
s/test/search
I think we could use.stream().anyMatch() or.collect() to make it more readable
I think we could use.stream().anyMatch() or.collect() to have a lambda here
I think we could use.stream().anyMatch() here
This should be asserted as well.
This should be asserted as well to reduce code duplication
This should be asserted.
It should be new TajoRuntimeException(new UnsupportedDatum(new UnsupportedDatum(new SourceCode.UNSUPPORTED_DATATYPE, type.name()));
It should be new TajoRuntimeException(new UnsupportedDatum(new UnsupportedDatum(new SourceCode.UNSUPPORTED_DATATYPE, type.name()));.
It should be new TajoRuntimeException(new InvalidCastException(...).
This method is too complicated. Any way to avoid it?
This can just be'return false'
This can just be'return false' instead of'return false'
You don't need to do the null check on the params of XAStore.
You don't need to save parens here.
You probably want to add null checks to the XAStore and get rid of the boilerplate?
this should be moved to a well defined method
this should be moved to a separate method
Should we change this to!TextUtils.isEmpty?
you can use the method schedulePage.createMeetingWithStartTime(Integer)
you can use org.assertj.core.util.AssertJUnit.\* methods instead
you can use org.assertj.core.util.AssertJUnit.\* methods instead.
This method should be public.
This method should return true.
Should be here ac.stateChangingCheck();
Potentially you can use <LINK_0>
Prefer using ExceptionUtil.getStackTrace(Throwable) to handle the response code
> what can go wrong, especially here?
Wouldn't it be easier to debug if we don't have a exe instance in the process?
Wouldn't it be easier to debug if we don't have a exe instance in the code?
Wouldn't it be easier to debug if we could get rid of the temporary variable altogether?
I tend to do this as a static method on a class, not something that's public.
I tend to do this as a static method on a class, not something that's public on the class.
I tend to do this as a static method on a class, not something that's public API.
Can you use the new InventoryUtil.createAndManage InventoryUtil please? ;)
Can you use the new InventoryUtil.createAndManage InventoryUtil? ;)
You are right, but it would be nice if you include spaces next to potentially consistent line if you use tabs instead of spaces. Missed it before the PR.
we can use private method createLogEventSecureObj() and createLogEventSecureObj()
we can avoid this code duplication as we have created the method createLogEventSecureObj
we can use private method createLogEventSecureObj()
Why are you using assertEquals() and below? It is usually better to use better error message than assertTrue(expected, actual)
Why are you using assertEquals() and below? It is usually better to use better error messages than assertTrue(expected, actual)
Why are you using assertEquals() and below? It is usually better to use assertThat()
That's a separate behavioural change, should be done in a separate patch.
That should be a separate switch/case.
That should be a separate switch/case also.
Redundant parentheses
Formatting
Unnecessary catch.
Please add null check for entity.
Minor- you could reuse entity here.
Please add null check for entity
Any reason for asserting the states.get(i)!= 1?
Any reason for asserting the states.get(i)!= null?
Any reason for asserting the states from the cache here?
move it to a new test
why you changed this?
why you changed this
should be: SafeHtmlBuilder builder = new StringBuilder(); if (b!= null) { builder.append(b); } return builder.toString();
should be 'continue' rather than 'break;'
can you extract this into a method?
this should go into the else block.
this can be moved into the else block.
this can be private.
Expected before actualScores.size() == 2
Expected before actualScores.length == 2
assertEquals(actualScores, actualValue)
do you need to create a variable for this?
do you need to create a variable with this name?
do you need to create a variable with a name?
This should be a addBatch, no?
Another way to do that is to use a addBatch (or add a separator after the first line) and then use that in both places.
Another way to do that is to use a addBatch (or add a separator after the first one) and then use that in both places.
The MappingImplementor must not be null, so that we are doing an unchecked cast.
The MappingImplementor must not be used, so that we can remove it.
The MappingImplementor must not be a fix, because it is being used by the MappingClient.
You can use CollectionUtils.isNotEmpty() here.
You're missing a filter here, [.get()](<LINK_0> filters as well.
You can use CollectionUtils.isNotEmpty() here
The purpose of the 'if' block is to put the else branch in a single line after the return.
The purpose of the 'if' block is to put a line after the return.
The purpose of the 'if' block is to put the else branch in a single statement, so it is easier to read.
Cannot render interstitial ad. -> Cannot render interstitial ad. AdMob console -> AdMob UI. Please apply this across all messages.
Cannot render interstitial ad. -> Cannot render interstitial ad. AdMob console -> AdMob console
Cannot render interstitial ad. -> Cannot render interstitial ad. AdMob console -> AdMob console. Please apply this across all messages.
I think this method is only called in the afterPropertiesSet() if there is an issue with an Optional.empty() if there is no @Configuration annotation. It is created just from the spring bean and that's the case.
I think this method is only called in the afterPropertiesSet() if there is an issue with an Optional.empty() if there is an Optional.empty() is the thing to have.
I think this method is only called in the afterPropertiesSet() if there is an issue with an Optional.empty() if there is an Optional.empty() is used?
Why do we have 2 different steps?
Why do we have separate steps?
Why do we have waitAndSelectItems here?
add notebookId to log
add notebookId to log message
LOG.error("Error from run notebook")
White space.
Remove this System.out.println
Remove this System.out
I would throw AssertionError here - this must be impossible from an AssertionError
I would throw an AssertionError here - this must be impossible from the platform.
I would throw AssertionError
There is no need to create a new ResteasyProviderFactory here. This is not a main issue, but it should really be done once when the ResteasyProviderFactory is instantiated.
There is no need to create a new ResteasyProviderFactory here. This is not a main issue, but it is a bit easier to read.
Why not use ResteasyProviderFactory.newInstance()?
Please remove unnecessary parenthesis:!ag.getVdsIds().isEmpty() || ag.isVmAffinityEnabled() && runningVms.size() > 1 && ag.isVmAffinityEnabled() && runningVms.size() > 1
Please remove unnecessary parenthesis:!ag.getVdsIds().isEmpty() && ag.isVmAffinityEnabled() && runningVms.size() > 1 && ag.isVmAffinityEnabled() && runningVms.size() > 1
Please remove unnecessary parenthesis:!ag.getVdsIds().isEmpty() || ag.isVmAffinityEnabled() && runningVms.size() > 1
It would be nice to create constants for **"/"** and **"/"**
Shouldn't be better to throw exception here, like we did in the other methods
Shouldn't be better to throw exception here, like we did in the other methods?
It looks annotation is only used in the if (injectedTypes.contains(parameterType)) so this part could be moved there (and we will gain a bit)
It looks annotation is only used in the if, so this part could be moved there (and we will gain a bit)
It looks annotation is only used in the if (injectedTypes.contains(parameterType)) {... } block (and we will gain a bit)
Can you make this method private?
Can you make this method package private?
Can you make this a method with two params instead of two?
We should stop using String.join as we are doing string split.
Maybe we should stop using String.join as we are doing this ugly check
We should stop doing this in every test case.
This should be in the try-finally block.
This could be private as it is used in the other class.
This should be private, as it's only used in test code
Hi Ravi, First of all, congrants on finding this out. Second - I think that while you're on the process of working on KerberosManager, I think we're making a mistake here that we're not throwing an exception if krb5 conf file in case we do want to use kerberos auth. Regardless, I think that the system property you discovered. should be set only if the krb5File exists.
Hi Ravi, First of all, congrants on finding this out. Second - I think that while you're on the process of working on KerberosManager, I think we're making a mistake here that we're not throwing an exception if krb5 conf file in case we do want to use kerberos settings. Regardless, I think that the system property you discovered. should be set only if the krb5File exists.
Hi Ravi, First of all, congrants on finding this out. Second - I think that while you're on the process of working on KerberosManager, I think we're making a mistake here that we're not throwing an exception if krb5 conf file in case we do want to use kerberos authentication. Regardless, I think that the system property you discovered. should be set only if the krb5File exists.
I don't think that's right. I find it easier if this method were written with more characters than that. I guess it would maybe be easier if this method were written as: if ( tok.hasMoreTokens() ) {... } else {... }
I don't think that's right. I find it easier if this method were written with more characters than that.
I don't think that's going to work. I wonder if it's a bit better to fail with this change.
We should use a StringBuilder here
We should use StringBuilder here
We should avoid using String concatenation
while(it.hasnext())
while (it.hasnext())
don't need to create a variable here
you should use the merged log method - that way it is easier to debug.
you should use the builder pattern, otherwise it is hard to debug.
you should also change the second argument to a logger.
Doesn't it override user decision when user de-selects these changes?
Doesn't it override user decision when user de-selects the user?
Doesn't it override user decision when user de-selects this radio button?
I don't think it is a good idea to throw an exception here. Having a message like the Exception would be a better error case IMO.
I don't think it is a good idea to pass null.
This looks a bit confusing.
Why is success variable in 'false'?
why is success variable needed here?
why is success variable needed?
onErrorMap?
onErrorMap.error?
onErrorMap
Please rename to activity or fragment.
Can you rename to activity or fragment since it is used only once.
Can you rename to activity or fragment?
Please use a utility method for duplicating code.
Please reuse existing code to construct links.
Needs to be in a generic way.
why are we catching the exceptions here?
why are you catching the InputStreamReader?
Why are we catching the exceptions here?
might be worth logging here, JiC
might be worth refactoring this, JiC
might be worth logging here, JiC?
I don't think it's necessary to change it, but it's just a trivial change.
I don't think it's necessary to change it in the future.
I don't think it's necessary to change it, but it's still not a bug
Can you elaborate on why this is necessary?
Can you elaborate on why we don't use the "start" operation here?
Can you elaborate on why we need this?
add a check that no bitstreamformat has been created
add a check that the bitstreamformat is still here
add a check that no bitstreamformat is still here
Optional: better to invert equals to avoid potential NPE
Optional: IConfigurationElement[] children = new IConfigurationElement[wizardPageList.size()]
Optional: IConfigurationElement[] children = new IConfigurationElement[wizardPageList.size()] == null
You could also use.collect(Collectors.toMap(Map.Entry::getValue, Function.Entry::getValue))
You could also use.collect(Collectors.toMap(Map.Entry::getKey, Function.identity()));
You could also use.collect(Collectors.toMap(Map.Entry::getValue, Function.identity()));
This is the tooltip, you should be able to disable the widgets and you can get it to the trace.
This is the tooltip, you can use fTrace.getImage().getDelay() instead.
This is the tooltip, you should be able to disable the widgets and you can get the trace selections.
Please simplify this function to: suggestion final String local = name == null? -1 : name.indexOf(':');
Please simplify this function to: suggestion final String local = name == null? -1 : name.indexOf(':'); final String local = name == null? -1 : name.substring(0, colon);
Please simplify this function (then, it returns the value of the 'name' variable).
this is not used
this is not code correct

Shouldn't this be a constant in this class or something?
Shouldn't the default value be 0, or something similar?
Shouldn't this be a constant in this class?
This should be public. For example, you can create a private static final String JO_NEUTRAL; even though you're only using it.
This should be public. For example, you can create a private static final String JO_NEUTRAL = ""; and then use it.
This should be public. For example, you can create a private static final instance of this class with the default value.
You don't need this, as the consumer doesn't add it.
You don't need this, as the default is "keystorePassword".
You don't need this, as the default is "keystorePassword"
please double check that the buffer exists and throw the exception, to avoid resize the buffer
please double check that the buffer is not compact
Double negative.
does it make sense to return null here?
does the tid need to be cached?
does the tid need to be a field?
Why do you need this?
Why do you need this variable?
Why do you need this? The method already checks in the constructor.
this should be "if (library.hasCards()) {"
this will break the loop
This should be "if (license(...) {".
This should probably be done using the logger instead of printed stack.
This should probably be done using a logger.
This should probably be done using the logger instead of manually HttpConnection.
Can we use try-with-resource pattern here?
Can we use try-with-resource here?
Can we use a try-with-resource pattern here?
Add a space before "("
Add a space after "("
does this break on a line?
nit: assertFalse(table1.getAdmin().getVersion().instanceOf("reject"));
nit: assertFalse(table1!= null)
nit: assertFalse(table1.getAdmin().getVersion().isOlderThan());
This was going to cause PMD to complain about it. I don't see the explanation to the user.
This synchronized block is not necessary
This synchronized block is not necessary?
why is this synchronized?
why is this static?
why is this needed?
Do we need these escapes?
Do we need these escapes? Reloading the CR/O will be done here
Do we need these escapes? Reloading the secret
I think this can be simplified to: java return!(currentTime.isAfter(startTime) && currentTime.isBefore(endTime) && currentTime.isBefore(endTime) || currentTime.isBefore(endTime)) { return true; } The'return false' code is now identical to the method above.
I think this can be simplified to: java return Stream.concat(onedDateTime.now().truncatedTo(ChronoUnit.MINUTES));
remove
This seems to be doing two different things, so the initialization should be done in the loop
This seems to be doing two different things, so the initialization of the logStoreAddress is un-necessary.
This seems unused
IMHO, we should move this to a common utility function.
IMHO, we should move this inside a try-with-resources block to not duplicate the code
IMHO, we should move this inside a try-with-resources
nit - move the deceleration one line up..
add CDA here and return false, if it fails you'll end up with NPE
add CDA here.
just do if (file.exists(dumpRoot)) { return null; }?
just do if (file.exists(dumpRoot)) { return null; }
just do if (file.exists(dumpRoot)) { continue; } after dump is done successfully
I would think that you should have some kind of synchronization/locking to avoid that several threads are requesting the client concurrently and executing the initialize method in parallel.
I would think that you must have some kind of synchronization/locking to avoid that several threads are requesting the client concurrently and executing the initialize method in parallel.
I would think that you should have some kind of synchronization/locking to avoid that multiple threads are requesting the client concurrently and executing the initialize method in parallel.
set.isEmpty() is better
set.isEmpty()?
set.size() is called in this method and is never used.
Can we remove this and "new" logic from the list of column names?
Can we remove this and "new" from the list of nested fields?
Can we remove this and "new" from the list?
Please change the methods to use assertThat
Typo: run => insert
Please change the methods to use this for readability
Would you also add an empty filter here?
Would you also add an assertion here?
Missing final
Just wondering whether we could be consistent with the logic in this method by either checking if the leader is enabled or not.
Just wondering whether we could be consistent with the logic in this method by using a switch, or is there a case where we know the leader is available?
Just wondering whether we could be consistent with the logic in this method by using a switch, or is there a case where we know that the leader is ready?
nit formatting 2 spaces.
Why empty line?
nit formatting 2 chars.
Minor thing, but we could also use a single synchronized here.
Minor thing, but din't see the synchronized below.
Typo. s/unnecessary
This could be a for-loop. No need to increment its value here.
Is there a case where there's no retry and the one is running?
This could be a for-loop. No need to increment and decrement after doRun
does "can't wait anymore" -> "can't wait anymore"
does "can't wait anymore" -> "cannot"
does "can't wait anymore" -> "can't wait anymore"?
Why not use AssertJ?
Why not use AssertJ offers?
Why not using verify(logger)?
suggestion throw new SearchException( "Trying to use Hibernate Search without an Hibernate EntityManager: " + delegate );
Was the changes made here to the warning?
Was the changes made here to this commit?
Use 4 spaces for indentation.
Same, 4 spaces.
Use 4 spaces for indent.
The null check above won't be needed anymore.
The null check above won't be necessary.
The same here and in the delete below. So yeah, we should try to delete the code.
This should be done in the "protected" method.
Unnecessary log.
This should be done in the "protected" class.
if VALID_GENOTYPE_VALUES.values()
final
ligically i'd say
There is no need for Log in this method.
There is no need for Log in this case
No need for Log
Can this method be declared private? I know it will be called in a test class and when we call it anywhere else.
Can this method be declared private?
Can returnType be null?
I don't think this is the right thing to do. When the dq is closed, we'd be in the if(closed) check.
I don't think this is the right thing to do. When the dq is closed, we'll be able to send the "dq" in the callback to the record that is being sent (if the callback is closed). I'd be interested to hear what you're doing here to avoid calling close on the record.
I don't think this is the right thing to do. When the dq is closed, we'll be able to send the "dq" in the callback to the record that is being sent (if the callback is closed). I'd be interested to hear what you're doing here to avoid calling close on the record that is being called in the record.
suggestion processInstanceList.stream().map(p -> p.getId()).collect(Collectors.toList());
Please change to ProcessInstance.STATE_ABORTED and ProcessInstance.STATE_ABORTED.
i think we can replace this with ProcessInstance.STATE_ABORTED and ProcessInstance.STATE_ABORTED.
What does this assert mean here?
What does this test mean?
That's the tested version?
Does it make sense to return false here if it's not needed?
Does it make sense to return false here if it's not set?
Does it make sense to return false here if it's not needed.
Can this be apiAuthenticationHelper::checkUserOrGroupAdmin?
Can this be apiAuthenticationHelper::checkUserOrGroupAdminUserAnd403?
Can we change this to apiAuthenticationHelper::checkUserOrGroupAdmin?
check whether Exception throwing
check whether param is used
check whether param is null
Add the value of proQB and memberProfileList.get(0) instead of hard-coded string
Please use proQB.get(0) instead of hard-coded string, which is faster than the one at line 155.
Please use proQB.get(0) instead of hard-coded string, which is faster than the one at line 718
Exception#printStackTrace goes to stderr by default.
Won't this cause the refresh to be done in a background thread?
Won't this cause the connection to out of sync?
Similar
Similar to the one above: can you factorize the two lines?
Similar?
jobEntityName is incorrect.
The job is executed by the job.
The job should receive a FEED.
println
Remove
println?
Use parameterized logging instead of string concatenation.
No need to use parameterized logging instead of string concatenation.
No need to use parameterized logging, please use parameterized logging instead of string concatenation.
What do you think about making this package private static?
What do you think about making this private static?
Better to use private static final String PORT_RESPONSE = "blue 1.4"...
:bug: this will fail with an out of bounds.
:bug: this is not thread-safe
:bug: this is not thread-safe.
if we log this as error, maybe we should only throw the exception?
if we log this as error, maybe we should only show it as a warning.
if we log this as error, maybe we should only show it as a warning?
Maybe this should be NamedStyleUtils.removeBooleanNamedStyle(createBooleanNamedStyle(editingDomain, table, NatTable.class));
Maybe this should be NamedStyleUtils.removeBooleanNamedStyle(createBooleanNamedStyle(editingDomain, table, NatTable.class)?
Maybe this should be NamedStyleUtils.removeBooleanNamedStyle(createBooleanNamedStyle(editingDomain, table, NatTable.class))
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this call from a constructor to the overridable "set" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "protected" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this useless assignment to local variable "length". [![rule](<LINK_2>](<LINK_0>
In general, this checkBasicAPIs is unreliable test : <LINK_0>
In general, this checkBasicAPIs is unreliable because of negatives.
In general, this checkBasicAPIs is unreliable because.equals will be called on line 41
hmm, the hasSize..
hmm, the hasSize. Also, if you delete the hasSize so the test becomes pointless.
please make this private
@piddubnyi let's define it once in the class.
@SuppressWarnings("unchecked")?
@SuppressWarnings("unchecked")
should be '!='
should be 'null == flags'
should be '!StringUtils.isEmpty</code>
You could use projects.isEmpty() here instead of projects.isEmpty()
You could use projects.isEmpty() here instead of asking for null (which is what is used before).
Why can't we use projects.isEmpty() here?
When there's no object in the list you can use Collections.emptySet() instead of Arrays.asList
When there's no object in the list you can use Collections.emptySet instead of Arrays.asList
When there's no object in the database it can be removed
Typo?
Hand won't work as expected by default.
Hand won't be available in the world?
please use bracket {}
you should use StringUtils.isNotEmpty
you should use StringUtils.isNotEmpty.
<code>home</code> may be null here
<code>home</code> and <code>j!= null</code> should be present in parameter
<code>@CheckForNull</code>
Shall we include the table name in the exception message?
Shall we include the table name here as well?
Shall we add a message here that we can determine if the table is not supported?
white space
white space.
white space?
I think that we should have a more efficient way to query the size of the list once and return it for each thread.
I think that we should have a more efficient way to query the names using the iterator() method.
I think that we should have a more efficient way to query the size of the list once, in case threadName is too big.
This change is in the original code.
This change does not seem to be necessary.
This change does not seem to be necessary?
Is it possible to break this out into a separate file as a subclass? I think adding a bit of it could be easier to read.
Is it possible to break this out into a separate file as a subclass?
Is there a reason why we need this?
getItems() can't be null. You need to check if getSelectedItems() is null.
getItems() can't be null. You need to check if getItems() is not null.
getItems() can not be null. You need to check if getSelectedItems() is null.
u can use spy.positionBeforeGII variable
these three lines can be put in a method to make them shorter
these three lines can be put in a method to make them static
"Hadoop in your classpath. For more information refer to the " +
"Hadoop in your classpath. For more information refer to the sthth."
"Hadoop in your classpath. For more information refer to the sthth. Please correct the message.
Ok. But so to be extra clear, we should still always block commits from happening during a rebalance then 429 is still useful for active throughput of eos..
Ok. But so to be extra clear, we should still always block commits from happening during a rebalance when eos is used, yes? I'm guessing it has to be that way since that makes sense.
I think this should be error.getMessage()
Is this needed?
Is this catch needed?
Is it possible to catch Exception here?
instead of better reference to tuples of the filter and check if the property is FALSE.priceprice doesn't exist
Why do you need to cast something to list and check the right element?
Same here too.
The relaxedNames can be null, but not enabled.
The relaxedNames can be null, but not null.
The relaxed name must be not null because it is already a Relaxed name.
Can be removed (this loop is not required)
Can be removed (this loop is not required *i* loop).
unnecessary loop
I would prefer to use String generatedPassword=""; if (addproperty == null || addproperty.equals("")) {... }
and empty string,?
Let's use text formatting like above for method name and formatting
isTrue(property.getType() == String.class, "Version property %s must be of type Long"
suggestion Assert.isTrue(property.getType() == String.class, String.format("Version property %s must be of type Long", property.getField()));
isTrue(property.getType() == String.class, "Version property %s must be of type Long", property.getField(), parentAnnotation.type()))
It is better to change this variable name to workspace-stop
It is better to use projects name which should be exported in a constant.
It is better to change this variable name to workspace-stop or name.
What's the purpose of this change?
What's the user facing outcome here? The user is not supposed to know when an error occurs, but just let the user know for sure.
What's the user facing outcome here? The user is not immediately sure when an error is logged.
I would suggest to modify the CSV file to be consistent with file operations (since there's configuration information for publish-id and publish-timestamp as well).
I would suggest to modify the CSV file to be consistent with file operations (since there's configuration information for publish-id and publish-timestamp)
I would suggest to modify the CSV file to be consistent with file operations (since there's configuration information for publish-id and publish-timestamp) so that there's no need to do the isPresent check.
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "i" 3 times. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "c" 3 times. [![rule](<LINK_1>](<LINK_2>
Add context specific message without using e.getMessage().
Add context specific message without using e.getMessage()
Add specific message without using e.getMessage().
Shouldn't we use![image](<LINK_0> instead?
Shouldn't we use![image](<LINK_0> here?
Shouldn't we use![image](<LINK_0> here? Thanks!
Use Flogger, not System.out.
Use Flogger, and do not log and re-throw exception - this is anti-pattern.
Use Flogger, and do not log and return.
Is there a reason to use AtomicBoolean instead of a boolean?
Override?
Override
This variable is not used for anything. Could we remove it?
I don't think we should be returning here. Consider removing it.
This variable is not used for anything.
[minor] Use StringBuilder instead.
[minor] Use StringBuilder.append(String.join())
[minor] Use StringBuilder's String.join()?
I would expect the default to be false. Don't allow remote installation.
I would expect the default to be false. Don't allow remote installation. Don't allow remote installation.
I would expect the default to be false. Don't allow remote installation. Don't allow the file size.
It's better to have this be a log message?
It's better to have this be private rather than public, so that clients can configure their configuration without prding.
It's better to have this be private rather than public, so that clients can configure their configuration via prduck.
@Godin I don't know, but do we really need this blank line?
@Godin I don't know, but do we really need this blank line here?
@Godin I don't know if this is the right way to handle exceptions. You need to check for null first before calling convert.
I think this will actually be an issue since you can't use contains() to find the child, and you will get the children if the child matches the tree, while you are doing that to test the tree. I'd actually suggest making this a ShadowDOM. Then you can drop the child of <Object> and just add it to the ShadowDOM. Note that the base objects of the childhes are the end of the childhes, so the end of the childhes are the end of the child.
I think this will actually be an issue since you can't use contains() to find the child, and you will get the children if the child matches the tree, while you are doing that to test the tree. I'd actually suggest making this a ShadowDOM. Then you can drop the child of <Object> and just call.equals() to <Object>
I think this will actually be an issue since you can't use contains() to find the child
The message should be the same as the one above: suggestion logger.debug("Batch size string = {}", strBatchSize);
I think this should be at the info level.
I think this should be at a level higher than debug.
Please use if (body!= null) { }
How is that possible here?
Please use if (body!= null) {
Do we need a list here?
Do we need to check for a list here?
Do we need to check for a list here? Set<MpackInstance> already here.
Instead of going through the try-catch, why not just move this out of the try block and have only the catch block?
Instead of going through the try-catch, why not just move this out of the catch clause and have only the exception thrown?
Instead of going through the try-catch, why not just move this out of the catch block and have only the exception thrown?
It still takes a significant amount of time to figure out what this code block does, but we should at least give a significant amount of time to take over the service.
It still takes a significant amount of time to figure out what this code block does, but we should at least give a significant amount of time to change this.
It still takes a significant amount of time to figure out what this code block does, but we should at least give a significant amount of time to change.
This should be moved to where the locking code is invoked.
This should be moved to where the locking is done.
This should be moved to where the map is added to listeners.
Should this fail the test? (same with other catch locations)
Should this fail the test? (same with other code).
Should this fail the test? (same with other code)
java.subscribe(new Action1<List<User>>() { });
java.subscribe(new Action1<List<User>> { });
java.subscribe(new Action1<ResultType> { });
I think it would be better to use here luceneReader.query( multiProgressor, indexOrder, predicates[0], ); that will give the usual error message, and not just "error".
I think it would be better to use here luceneReader.query( multiProgressor, indexOrder, predicates[0], ); here
I think it would be better to use here luceneReader.query( multiProgressor, indexOrder, predicates[0], ); that will give the equivalent query in the first place.
I would inline this method and just return Tuple.of(generators._2, generators._1))._1.apply(random);
I would inline this method and add a method to the lambda: java return Tuple.of(generators._2, generators._1))._1.apply(random);
I would inline this method and add a method to the Block
These 2 lines don't need to change.
These two lines don't need to change.
These 2 lines don't seem to match anything.
It would be nice to use StringUtils.equals() here.
It would probably be more efficient to use Object#equals(Object, Object) to do a lower case conversion.
It would probably be better to use Object#equals(Object, Object)
Leftover debug statement?
Is this debug statement still needed? Since you are doing it, you should be able to remove it.
Is this debug statement still needed? Since you are doing it, you should be able to remove it. Just change the log level to debug.
Might be better to pass pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists), OptionalLong.empty())) to the record method.
Might be better to pass pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && pathExists), OptionalLong.empty())) in order to avoid the null check.
Might be better to pass pathStatRecord.recordPathStat(getStat(path, hasListeners(path)) && pathExists), OptionalLong.empty()); to the record method.
Is this needed?
Is there a reason why you log it as error?
Is it needed to throw at construction time?
entity
Internal code
Internal code style
Once this is done, we could just call connectCalled = connectToService();
Once this is done, we could just call connectCalled = connectToService() to connectToService() and move the code here.
Once this is done, we should close the executor!
is == null should be on the next line?
is this problematic?
is == null should be added
hideCanDestroy().get()
hideCanDestroy().get() doesn't really make sense in this case, it might be worth squashing the two enum values.
hideCanDestroy().get() doesn't really make sense in this case, it might be worth squash this
this virtSupported value is not a good name
this virtSupported value is not a good name, this is how it should be implemented
this virtSupported value is not a good name, this is how it's done internally
This doesn't seem to be an right way to go. Probably want to be /foo/bar instead of /foo.
This doesn't seem to be the right way to go.
This doesn't seem to be the right way to go. Probably want to be explicit about both a Request (e.g. Response.Status.GENERAL_ERROR there is also the toString() method that does the httpExchange check.
getLabelFormat will never return an empty collection?
getLabelFormat will never be null
This method should not be public
Why not the default instance?
Why not the following: final CmdLineException e = null; try {... } catch (IOException e) { // Extra space.
Why not pass it as a parameter?
Remove this if block?
Remove if statement?
Remove the if statement?
This is wrong. We must always exported the property name as String. @BeanExpressionResolver public void getExportProperties() { this.exportProperties = Objects.requireNonNull(this.properties); if (this.exportProperties!= null) { this.exportProperties.clear(); } else { // than logic }
This is wrong. We must always exported the property name as String. @BeanExpressionResolver public String getExportProperties() { return String.valueOf(value); }
This is wrong, it must be mapped to beanExpressionResolver.
Shouldn't the output need to be {".
Shouldn't the field.get(null) need to be {".
Shouldn't the field.get() call be {".
Same again here, just pass db into it.
Same again here.
Same again.
I think it's better to remove this duplication with the next one: String columnName = colFamilyName.getFamilyName().getString();
I think just calling String.format(column.getFamilyName(), colName) is going to be a bit odd.
I think just calling String.format(column.getFamilyName(), colName) is going to be a bit skewed.
why not use field directly? It would be easier to read and manage a bit more readable.
why not use field directly? It would be easier to read and use the fields for this expression and in the call below.
why not use field directly?
we can get here with null
we can get here with null by default
you can get here with null
Please make sure the order of the results comes from the previous test.
Please make sure the order of the results comes from the previous test too.
Please make sure the order of the results comes from the previous test
I think you'll want to fill this line by adding a method to the setUp method.
I think you'll want to fill this line by adding a method to the @Before annotation.
I think you'll want to fill this line by adding a method and removing the 39 there.
change to AbstractStackEvent and use the variables from here
@vzool one more time, this should be Context.getException()
change to AbstractStackEvent and use the variables from here.
suggestion ______TS("only instructors of the same course with modify session", Const.ParamsNames.FEEDBACK_SESSION_NAME, "abcRandomSession",
suggestion ______TS("only instructors of the same course with modify session",
The code here is duplicated.
consider this one: "n"
make it final
make this final
this can be dbSnp, outext and outext.
this can be dbSnp, outext and outext
this can be dbSnp, outext.
...with try-with-resources
isn't this better?
...with try-with-resources.
I think this is good, but I would prefer to use a ternary operator, or move away from ternary operator.
I prefer String.format for this: elapsedTime.append(seconds)
I think this declaration is missing some return statements.
You need to look at other tests in this file.
You can use new File(parent, child) function
You can use new File(parent, child) method
change to boolean[] hasLoop = false;
change to boolean[] hasLoop = false; to preserve readability.
change to boolean[] hasLoop = false; to simplify the code
add the exception message to this log.error(customErrorMessage, e);
add the exception message to this log.error(customErrorMessage, ex);
This is a copy&paste error.
Maybe this should be before the test for infinity?
Maybe this should be before the test if (event.getMessage()!= null) {
Did you mean to leave this?
Release needs to be adjusted as well.
This is a bit complex. We should probably keep a single method with the header.
Release needs to be safe.
we may throw exception for case of a column not found in the output.
we may throw exception for this case, too
Not thrown
The above code is too long, can you break it up into smaller methods?
The above code is too long, can you break it up into multiple lines?
The above code is too long, can you break it up into some implementations?
Typo?
Typo? "What is twenty" is not sound better.
Too many spaces, please.
Use parameterized logging instead of string concatenation.
If you want to avoid the debug output that would be much easier to read.
If you want to avoid the debug output that could be improved, it should be debug and not trace.
please extract a variable for the 3rd argument in the iterator() method.
please extract a variable for the 3rd number.
please extract a variable for the 3rd argument in the stream
use lang.safe Hamcrest here.
use lang.safeArg.
use lang.
Why not use the private method to immediately exit? Seems like this check only needs to happen in one place, and if it does happen in two they should both throw an exception.
Why not to use the private method to immediately exit? Seems like this check only needs to happen in one place, and if it does happen in two they should both throw an exception.
Why not use the private method to immediately exit? Seems like this check only needs to happen in one place, and if it does happen in two they should both throw an exception (ie its not printed).
You could use NFSConstants.EDIT_USER_CONFIGSIVE_REMOVE_MANAGEMENT_BE_REPLACED
You could use NFSConstants.EDIT_USER_CONFIGSED_PERIOD_MS instead.
You could use NFSConstants.EDIT_USER_CONFIGSIVE_SYNC
could you change log message a little bit to make it more readable?
could you change log message a little bit to make it consistent with other log messages?
could you change log message a bit to not retrieve entries in allotted timeout?
This should be replaced with Adapters.adapt
This will only work once. No need to call start twice.
rename to element
I think the hardcoded numbers should be the same as before
I think the hardcoded number is a constant declared in the beginning of the class, if you're editing it here, will be more robust.
I think the hardcoded number is a constant declared in the beginning of the class, if there is a DP_NAME defined it
Here's an example why the impact would be that a job change listeners cannot be called. The UI should be shown to the view before the view is show.
Here's an example why the impact would be that a job change listeners cannot be called. The UI should be shown to the view before the view is disposed.
Here you're also using the same job as the launch view.
I think we should include the secret here as well.
Perhaps we should include the secret here as well?
Maybe we should include the secret here as well?
This method is used to create the DescribableList<FolderHealthMetric>, no need to instantiate it here.
This method is used to create the DescribableList<FolderHealthMetric>, no need to create a new list here.
This looks like a RuntimeException, no?
Could you move this the following the code in the Timber.java file and keep the list as final?
Could you move this the following the code in the Timber.java file and keep the list as final
Could you move the string formating to the xml definition?
Is it necessary to have the curly braces?
Is it necessary to have the above switch statement?
Is this change needed?
The number instanceof Number should be good enough.
The number instanceof Number should be sufficient and you can change the method to be equals/hashCode.
The number instanceof Number should be sufficient and you can change your tests to use equals()
style nit: no braces around single line blocks
style nit: no braces here
style nit: no braces around single line block
I think you can add some "while" here to make it more obvious that the run in parallel would be more obvious to the user
I think you can add some "while" here to make it more obvious that the value is in the goal of the loop.
I think you can add some "while" here to make it more obvious that the value is true if it is equal to false.
Is this supposed to be name-formatting?
Is this supposed to be name-format?
Is this supposed to be nameForParams()?
Consider using AnnotationUtil.getAnnotation(...)
Consider using AnnotationUtil.findAnnotation(...)
Why this change?
Maybe we should rename this to 'proactive_user_id' or something like that, not the others?
Maybe we should rename this to userOrDirList
Maybe we should rename this to userOrDirList?
This isn't necessary as the assert is above the test.
This isn't necessary as the assert is already asserted in the method above.
This isn't necessary as the assert is already asserted in the function.
use style provided with callback instead
Please use style provided with callback instead
Add style as parameter to this method
database.getDefaultNamespace() could be a single call, so it should be better to use an IndexSpec directly.
database.getDefaultNamespace() should be a singleton, so you don't have to worry about the order.
database.getDefaultNamespace() should be a singleton, so you don't have to worry about the order of the values.
you may be able to factor this out into a separate test method.
I would suggest to factor this out into a separate test method.
you may be able to use this semaphore.
Nit: are we missing Platform tests?
Nit: are we missing braces?
Nit: don't need this assertion
nit: This could be a static method.
nit: this could be a static method.
This will invoke the service if we don't have the object, (Or does it matter)?
I wouldn't get this logic nicely. The constructor should be private and it should be package-private.
The case of nulls here is not enough.
The case of nulls here is not enough. You should check if the field is null first and then rhs is null.
I think this kind of breaks the current API contract in a subtle way: while this is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages.
I think this kind of breaks the current API contract in a subtle way: the base class collection of in-app packages is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages.
I think this kind of breaks the current API contract in a subtle way: the abstract base class collection of in-app packages is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages.
I think it might be better to use logger.error("Failed to refresh storage usage from update: {}", path, e);
I think it might be better to use logger.debug("Getting this from update: {}", path, e);
I think it might be better to use logger.debug("Getting this from update: {}", path, e.getMessage());
Does this need to be public? If so, please make it package-private.
Does this need to be public? If so, please make it private.
Does this need to be public?
please wrap this long line
please wrap this block in a private method.
please wrap this bit in a private method.
ACCOUNT_REPORTS_TABLE
ACCOUNT_REPORTS_TABLE -> ACCOUNT_REPORTS_TABLE
ACCOUNT_REPORTS_TABLE should ignore the storage usage, not the other way around.
nit: we can use AssertJ
nit: we can use AssertJ to verify where this error is expected.
nit: we can use AssertJ to verify these
try to use BigDecimal.valueOf()
try to use BigDecimal.valueOf() for these
for boolean
Now that it is in a 'else' branch, the if statement should be executed with braces.
Now that it is in a 'else' branch you should check if the event is not a IStorage
this check should be done in the callers
The result of Paths.get(vcfList.toString()) should be replaced with Paths.get(vcfList.toString()) as it's already an array.
The result of Paths.get(vcfList.toString()) should be replaced with Paths.get(vcfList.toString()) as it's more efficient.
The result of this change is not used.
@vilchik-elena copy-paste bug?
@danielezonca @karreiro I think that this logic is not needed as the data model will be in the list of file systems.
@danielezonca @karreiro I think that this logic is not needed as the data generation is in load and not read.
username can be null. in such cases we shouldn't NPE somewhere in the db code but instead fail the rest API with a ResourceConflictException or similar.
username can be null. in such cases we shouldn't NPE somewhere in the db code but instead fail the rest API with a descriptive message.
username can be null. in such cases we shouldn't NPE somewhere in the db code but instead fail the rest API with a NullPointerException or similar.
How about if (StringUtils.isNotEmpty(ctx.lookupEntry(key)) { return unsureResponse.INSTANCE; } else { return null; }?
Should we log where the remote node could be null?
Should we add null check here?
suggestion ______TS("Instructor attempts to edit student's response, but invalid response.");
suggestion ______TS("Instructor attempts to edit student's response, but currently the student's response is accessible.");
suggestion ______TS("Instructor attempts to edit student's response, but currently the student's response is displayed as student.
center can be called in a finally block.
center the page listener is called, which is what is needed in GerritCallback. This will show the dialog to the user.
center the page listener is called, which is the last argument of this method. Is this intentional?
I'd add the list of policys in the exception message.
I'd add the list of policys in the message.
I'd add the list of policys in the exception message for consistency.
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Refactor this method to reduce its Cognitive Complexity from 17 to the 15 allowed. [![rule](<LINK_2>](<LINK_0>
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Refactor this method to reduce its Cognitive Complexity from 17 to the 15 allowed. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
you should use a different value for the message here, i.e. "'proxies.proxy.id'" is not the same as 'this' one.
you should use a different value for the message here, i.e. "'proxies.proxy.id' must be unique"
you should use a different value for the message here, i.e. _not_ equal to _not_ equal to _not_ equal to _code_ right?
This should be a DEBUG message
This should probably be a DEBUG message
This should probably be a DEBUG log message
It might be a whole lot easier to read if you extract this into a method for conciseness.
It might be a whole lot easier to debug if there was a problem with the string format.
Please save to three lines.
if it is EngineException, why do we need to set it to a exception message?
if it is EngineException, why do we need to set it to a exception?
change to warn or error.
I'd just use a Stream and a collect here, and then use a method reference rather than a List.
I'd just use a Stream and a collect here, and then use a lambda.
I'd just use a Stream and a collect here, and use Stream.of.
This should probably be a @Before
This should really throw Exception.
This should probably throw a Exception.
Is using mAdConfig here make sense? We should use banner size that returned in Vungle.
Is using mAdConfig here make sense? We should use dpAdSize that returned in Vungle.
Is using mAdConfig here make sense? We should use banner size that returned in VungleImpl.
findbugs will tell you there is a NPE here... as Jenkins.getInstace() is checkForNull
findbugs will tell you there is an NPE here... as Jenkins.getInstace() is checkForNull
@CheckForNull
Do you want to remove this generic exception?
why not just throw e1;?
Do you want to leave the log statement?
nit: I think this could be a Set
Would it be better to add a warn log here?
nit: I think it would be better to have this as a Set
The "/test.properties" should be replaced with "/test.properties", since this is the default file path.
The "/test.properties" should be replaced with "/test.properties", since this is not a path.
The "/test.properties" should be replaced with "/test.properties", since this is the prop file name.
Warn log level seems to high for a normal state transition.
Warn log level seems to high for an application with a normal state transition.
Unused variable.
I don't think this will ever be true. What was the behavior behind this ringWrite()? It looks like it will just append 1 element to the end of the ring.
I think HEADER_LENGTH should be used here.
I don't think this will ever be true. What was the behavior behind this ringWrite()? It looks like it will just append the header, append it to the end.
if (bean instanceof ClientResources) {
if (bean instanceof ClientResources) {... } else { throw new RuntimeException("Cannot mutate in this case") }
if (bean instanceof ClientResources) { I don't think we need to care about the null case.
Should not change this file
Should not change the file
Should be final
Should it be primitive?
Should it be node.isOfType?
Should it be node.getName()?
Why you need this?
Why you need this?
Why?
Putting the log inside the issueRequest() method here seems a bit scary. Perhaps there's a better way to handle this given we're creating a lot of these log messages?
Putting the log inside the issueRequest() method here seems a bit scary. Perhaps there's a better way to handle this given that we're creating a lot of these logs?
Putting the log inside the issueRequest() method here seems a bit unexpected. Perhaps there's a better way to handle this.
Isn't this always true at this point?
Isn't this always true at this point? Isn't this case skipped?
Isn't this always true at this point? When command a ref-ref is created, it always has the ref-refs sub-refs.
This method should not be public
It is the same, but can be protected
This method should not be public, because they are private
Can we use containsKey?
Can you use containsKey?
Can you please use containsKey?
close the reader
close the reader in finally block
try with resources would be better here
This loop is unnecessary, could be replaced by: for (int i = 0; i < layerParam.dimensions.length; i++)
This loop is unnecessary, could be replaced by: for (int i = 0; i < layerParam.dimensions.length; i++) {
This loop is unnecessary, could be replaced by: for (int i = 0; i < layerParam.dimensions.length(); i++) {
Could you maybe move the string "Vertx" to a constant?
Could use String.format()
Could you maybe move the string "Vertx" to a static constant?
I don't think these can be unsubscribed unless they are needed: if (unsubscribed) { return Subscriptions.unsubscribed(); }
I don't think RxJavaHooks handle this. There is a really a way to do it here.
I don't think these can be unsubscribed unless they are needed.
given that refactoring tool can be hard to understand how this method is supposed to work. I suggest to add a public void verifyRunWhenError() throws Exception { verifyRunWhenError(); } to this class as well.
given that refactoring tool can be hard to understand how this method is supposed to work. I suggest to add a public void verifyRunWhenError() throws Exception { if (shouldError()) { verifyRunWhenError(); } }
given that refactoring tool can be hard to understand how this method is supposed to work. I suggest to add a public void verifyRunWhenError() throws Exception { verifyRunWhenError(); }
suggestion throw new RuntimeException("No answer.");
suggestion throw new RuntimeException("No answer here.");
suggestion throw new RuntimeException("No answer on the form index.");
This is not right. Please move the importHandler to the new register method.
This is not right. Please move the private methods on the class.
This is not right. Please move the importHandler to the top of the class.
remove
remove toString
remove this
Did you mean to always wait for the second time?
move this to a private method
do we always want to throw an exception here?
You're not checking if Exception is thrown.
You're not supposed to catch the specific exception.
Use the IllegalArgumentException.
Does this have to be a parameter? It seems like it's unused.
Does this have to be a parameter? Seems like it should be passed through the configuration, not be checked twice.
Does this have to be a parameter? It seems like it should be passed through the config...
So returning here will force ValueMetaInterface.TYPE_INTEGER, but ValueMetaInterface.TYPE_DATE?
So returning here will force ValueMetaInterface.TYPE_INTEGER and ValueMetaInterface.TYPE_DATE, right? If so, it should still be a BigDecimal, what do you think?
So returning here will force ValueMetaInterface.TYPE_INTEGER and ValueMetaInterface.TYPE_DATE, right? If so, it should still be similar to getDecimal.
Not sure if this is a good idea.
Not sure if this is a good idea. Should we throw an exception here?
you could add the trace message.
@lorenzoPrimi remember to use [this](<LINK_0> instead.
@lorenzoPrimi remember to use getTitle() instead of hard coding the string.
@idelcano I think this is a RuntimeException, no?
Add a check here to verify that the broadcastSerialDataReceived method was not called.
Add a check here to ensure that the broadcastSerialDataReceived method was not called.
Add a check here to verify that the broadcastSerialDataReceived method was not called?
you could remove the extra parentheses
you could remove the extra brackets
you could remove the extra ;)
This should be if (s_logger.isDebugEnabled()) {... } block to avoid calling into a string concatenation when debug logging is off.
This should be if (s_logger.isDebugEnabled())
This should be if (s_logger.isDebugEnabled()) {... } block to avoid calling into a string concatenation when debug logging is disabled.
This is unnecessary, you can remove this check <LINK_0>
This is unnecessary, you could remove this check <LINK_0>
This is unnecessary, you should remove this check <LINK_0>
I think it would be better to show the input in the user's choice, something like "help-printing" or "g-line"
I think it would be better to show the input in the user's choice, something like "help-printing Saros server (type 'help')" so that the user can see what the choices are
I think it would be better to show the input in the user with #change.
Response is never closed
Response is never closed.
Resource leak.
This won't be necessary.
This is very bad to test that the PhysicsObject is stopping
This is very bad to have to be done against clean up resources.
SakadiTestUtils.commitCursors(
SakadiTestUtils
Gerr
nitpick: let's change this to outputName
nitpick: can you change this to distance variable
nitpick: can you change this to outputName()?
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean), no need to toString()
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean), no?
if the user does not set the current value to null you probably want to throw an Exception.
return false;?
return value.trim().isEmpty()?
This test will fail if it doesn't exist. Do we need a pull with a plugin?
Do we need a pull.json resource here?
This test will fail if it doesn't exist. Do we need to test it?
can't we move this to ApplicationServiceBeanException?
can't we move this to ApplicationServiceBeanException?
Code style: You should not execute the method in this class.
Hm, so when I originally wrote this, I intentionally ordered it to check for these 2 states (if the app resource state is corrupted, or the currently seated app is not usable), _before_ checking for session expiration, so that you couldn't end up on the login screen with a corrupted or unusable app as the seated app. I don't have hard evidence that this is necessary, but I think we probably want to still preserve that behavior.
Hm, so when I originally wrote this, I intentionally ordered it to check for these 2 states (if the app resource state is corrupted, or the currently seated app is not usable), _before_ checking for session expiration, so that you couldn't end up on the login screen with a corrupted or unusable app as the seated app. I don't have hard evidence that this is necessary, but I believe we probably want to still preserve that behavior.
Hm, so when I originally wrote this, I intentionally ordered it to check for these 2 states (if the app resource state is corrupted, or the currently seated app is not usable), _before_ checking for session expiration, so that you couldn't end up on the login screen with a corrupted or unusable app as the seated app. I don't have hard evidence that this is necessary, but I think we probably need to still preserve that behavior.
I think DtoFactory.getInstance() may return null
I think DtoFactory.getInstance() may be null
I think DtoFactory.getInstance() may return null, so it will throw NPE
Navigating again...
Navigate?
Revert?
Minor: assertTrue(consumerClient.getSentMessageCount()!= 0)
Minor: assertTrue(consumerClient.getSentMessageCount() == 0)
Minor typo in variable name.
Use Assert.assertEquals
Use AssertJ for assertions.
Use AssertJ.assertEquals
I think that we can remove this one as we have done in the setter so that we can be sure that savedReplyTo/workDir variables are not null.
I think that we can remove this one as we have done in the setter so that we can be sure that savedReplyTo/response properties are not null.
I think that we can remove this one as we have done in the setter so that we can avoid this logic.
I think this would be better. catch exception in a different way.
I think this would be better. catch Exception.
I think this would be better. catch Exception. Or rethrow with a different message.
we're cleaning this up again.. I think that the jobCurator.merge(status) method should be moved out of the if/else statement.
we're cleaning this up again.. I think that the jobCurator.merge(status) method should be moved out of the if statement and then throw the exception.
we're cleaning this up again.. I think that the jobCurator.merge(status) method should be moved out of the if and else statement should also be in a finally block.
I think this should be a 'false'
I think this should be a 'false', otherwise if the engine is running for some reason, the max value will not be updated.
I think this should be a 'false', otherwise otherwise it will not update the max value.
What is the purpose of this check?
What is the purpose of this check? Is it necessary to check if the status is exact?
What is the purpose of this check? Is it necessary to check if the result is not same?
Why the extra local variable?
Why the extra local variable? What's the extra local variable?
Why the extra local var?
Baking this logic into RollingUpdateOpFactory this way seems a bit out of place and conflated, but I see that you need to emit an event AND move to the next task. Looks like it's time for some refactoring of RollingUpdateOpFactory...
Baking this logic into RollingUpdateOpFactory this way seems a bit out of place and conflated, but I see that you need to emit an event AND move to the previous state. Looks like it's time for some refactoring of RollingUpdateOpFactory...
Baking this logic into RollingUpdateOpFactory this way seems a bit out of place and conflated, but I see that you need to emit an event AND move to the previous task. Looks like it's time for some refactoring of RollingUpdateOpFactory...
This is not always true. I think it should be stage!= null, right?
This is not required, right?
This is not always true. I think it should be stage!= null.
Below you defined openRepository() to be exactly this. Use that method here too?
This should be moved inside RevWalk.
Why this change?
Not a property that open source HBase or Phoenix recognizes.
Not sure if we need these, I think we also need to check the regular table exists.
Not sure if we need these, I think we also need to check the single target table.
Typo: Somehow an extra 'And' got introduced here
Typos: Somehow an extra 'And' got introduced here
Typo: Somehow an extra 'And' got introduced
suggestion if (doi == null) { throw new IllegalArgumentException("An asset node ({}) does not have DOI as expected", assetNode.getNodeName()); }
suggestion if (doi == null) { throw new IllegalArgumentException(" asset node ({}) does not have DOI as expected", assetNode.getNodeName()); }
suggestion if (doi == null) { doi = readString("object-id[@pub-id-type=\"doi\"]", assetNode.getNodeName()); return null; }
looks like move up, please
looks like move the else statement to the if below.
looks like move the else statement to the if.
this probably implies we'll get an error in case of an exception.
this should probably be done in the CaptureResult class, and only in case there is a timeout exception
this should probably be done in the CaptureResult class.
This test should have rung an alarm be added to the table.
This test should have rung an alarm be added to the list.
This test should have rung an alarm be added to the test itself.
Why not using autoConvert?
why not using SizeConverter.autoConvert
why not using SizeConverter?
text should be externalized
text should be included in GDKLabel.
text should be moved to per line
I know it's not part of your change, but can you add a new commit to your pull request? I think that you should send a new commit on this patch
I know it's not part of your change, but can you add a new commit to your pull request? I think that you should send a new commit on this patch.
I know it's not part of your change, but can you add a new commit to your patch?
maybe return EMPTY_LIST that way we can avoid even creating a soundIds list
maybe return EMPTY_LIST that way we can avoid even creating a soundId object.
maybe return null here?
Missing space after (
Missing space after try.
Missing space after try
looks like we don't need this assert.
wouldn't it be nice to test this with a different version?
needs to be fixed
Can it be replaced with String.valueOf?
Can replace by StringBuilder.append(message)
Can replace by StringBuilder(message)
Not sure, would it make sense to have a local variable for this?
Not sure, would it make sense to have a local variable for the key?
Not sure, would it make sense to have a local variable for the key too?
no I think. iccRecords is null always if uiccProfile is null.
no need I think. iccRecords is null always if uiccProfile is null
no IccRecords is null always if uiccProfile is null.
On line 226, there's another check for JDOHelper.isDeleted, is that relevant?
Do we need this check during creation, seems like it will be impossible for isDeleted to be true here?
Do we need this check during creation, seems like it will be impossible for isDeleted to be called here?
move the method
could use FTPSClient.DEFAULT
move the private method
please extract to a method and call it from RemoveSnapshotCommand
please extract to a method
please extract to a method and call it here
Can we please add a message to the exception?
Can we just return the bytes bytes?
Can we just use the java.util.Objects.write?
I know it's not part of your commit, but I would prefer to remove this method and use "this" whenplanIndexer is null.
I know it's not part of your commit, but I would prefer to remove this method and use DiskRebaseInteractiveLoader.removeRebaseInteractiveChangeListener() here.
I know it's not part of your commit, but I would prefer to remove this method and use "this" whenplanIndexer.dispose() here.
Please use a method that takes a ParameterClass instead of a list.
Please use a method that takes a ParameterClass and a ParameterClass.
Please use a method that takes a Config as parameter.
nit: for (;;) { rocksDBMetricsRecordingTrigger =... if (RecordingLevel.DEBUG) {... } } else {... }
nit: for (;;) { rocksDBMetricsRecordingTrigger thread =...; if (RecordingLevel.DEBUG) { thread.start(); } } else { Thread.currentThread().interrupt(); }
nit: for readability, prefer variable names
A more readable way of just doing this is: if ((menuProxy == null) && ((menuProxy == null) && SWT.getPlatform().equals("gtk")) {... }
A more readable way of just doing this is: if ((menuProxy == null) || ( SWT.getPlatform().equals("gtk")) {... }
A more readable way of just doing this is: if ((menuProxy == null) || ((menuProxy == null)) { openPreferencesItem = new ActionContributionItem(menu); }
Is it possible to move this line to the previous line?
Is it possible to move this code into TypedSet?
Is it possible to move this code to the previous line?
Don't call ts.getParameter(key, ERROR) twice. There's some redundancy between downloadBlob and downloadBlobStatus, so maybe some things could be factored?
Don't call ts.getParameter(key, ERROR) twice, put it in a variable. There's some redundancy between downloadBlob and downloadBlobStatus, so maybe some things could be factored?
Do we want to replace all variables with a single set?
Why not just use the TypeFilter here? flatMap(ApiTypeInfo::getRaw)
Why not just use flatMap?
Why not just use. flatMap()?
This isn't strictly true, because the doc says that we'll have to be sure which item is the same.
This isn't strictly true, because the doc says that we'll have to be sure which item it is.
Title-We should not be empty.
Should be exchanged.
Should be exchangeed.
Should be exchanged
Can't we make the test use multi-threaded environment?
Can't we make the test use some timeout?
Can't we make the test use multi-threaded environment?
Please use generics properly: Map<String, Object> nets = new HashMap<>();
Please use generics properly: List<> nets = new ArrayList<>();
Please use generics properly: Map<String, Object> nets = new ArrayList<>();
The method name is slightly misleading, since it has been called CacheStatsCallable() in this class.
The method name is slightly misleading, since it has to change.
The method name is slightly misleading, since it has to change to something.
Strange. Why not just deisable pre-dex. Your property will has a ComptiblePrebuilt and a InlineMarker?
Strange. Why not just deisable pre-dex. Your property will has a ComptiblePrebuilt and a DumpInLib so seems good, no?
Strange. Why not just deisable pre-dex. Your property will has a InlineEnittiblePrebuilt and a InlineMarker?
Can't that be shared and therefore constructed once in configure?
Can't that be shared and therefore constructed once in configure? It can only help.
Can't that be shared and therefore constructed once in configure? That can only help.
could you please use the [logging format](<LINK_0> instead of the try/catch?
could you please use mJobConfig.getFilePath() instead of mJobConfig.getFilePath()?
could you please use the [logging format](<LINK_0> instead of string concatenation
Is it possible to use a getActivity() method here?
Is it possible to use a Fragment.isView() instead?
Is it possible to use a Fragment.isFinishActivity() instead?
Same as above, but using Guava's util only.
Same as above, but using Guava's util as a dependency
Same as above, but using Guava only.
Maybe reformat SQL here
This should be reformated.
This should be reformative.
Not this pr s scope but this should use parent, false pattern.
Not necessary, this should only be called once per parent, false if there is a URL from broadcast.
Not necessary, this should only be called once per parent, false if there is a URL from parent.
if.newInt() is used in the provider, you will have to use Type = Integer and.unboxInt() here. In fact, since we control what is put into that attribute, you could skip the Integer and.unboxInt() here and in the other query method.
if.newInt() is used in the provider, you will have to use Type = Integer and.unboxInt() here. In fact, since we control what is put into that attribute, you could skip the Integer and.unboxInt() here and in the querySingleState.
if.newIntValue() is used in the provider, you will have to use Type = Integer and.unboxInt() here. In fact, since we control what is put into that attribute, you could skip the Integer and.unboxInt() here and in the other query method.
This reminds me that we should probably deprecate this method in favor of logError.
This reminds me that we should probably deprecate this method in favor of logError. ErrorDialog.
This should be a finally block.
this check could be in a simple if, since it is checked before the top of the method.
this check could be in the beginning of the method.
this check could be in a simple if, should not happen since it is checked before.
Verify and throw IOException
Verify and throw
Verify.verify
We don't want to create an exception object just for logging. Also, Timber supports format strings. So this could be: java Timber.e("Invalid address: %s", address);
We don't want to create an exception object just for logging. Also, Timber supports format strings. So this could be: Timber.e("Invalid address: %s", address);
We don't want to create an exception object just for logging. Also, Timber supports format strings. So this could be: java Timber.w("Invalid address: %s", address);
ooh, I would have probably missed this.
ooh, I might have probably missed this.
ooh many spaces
Would it be better to move it to DiagnosticUtil class?
Would it be better to move this to DiagnosticUtil class?
Would it be better to move it to DiagnosticProviderImpl at all?
As in DateWidget you don't need this variable just return binding.getRoot() at the bottom
As in DateWidget you don't need this variable just return binding.getRoot() at the bottom. You can also store it in a variable just to make it final.
As in UserPortal, I think given you have this variable just to make this method synchronized and return binding.getRoot() at the bottom.
Nit: I don't think we need the throws here.
Nit: I don't think we need the throws here since we're in the method signature
Can we add a message here?
This should be case insensitive.
This should be case insensitive
This should be null in this case.
This logic is too complicated and deeply nested. Can we please separate it out?
This logic is too complicated and deeply nested. Can you please rewrite it?
This logic is too complicated and deeply nested. Can we please reverse it?
I would log the remote peer address being set.
I would use try-with-resources.
I would log the remote peer address being set..
Can you use Retrieved for these assertions?
Can we use Retrieved for these?
Can we use Retrieved for these assertions?
You can use new Guid(String) - it's more readable.
You can use new Guid(String) - it's more readable
You can use new Guid(String) - it's a lot cleaner.
update the test to include the previous one, so there is no need to assert that the m.getPatientId().equals(7).
update the test to include the previous patient id :smile:
update the test to include the previous patient id, so they are more readable
I think it would be good to print the recipe ID instead of hardcoding the name. Maybe we can add a similar sentence to cheClientFactory?
I think it would be useful to print the recipe ID instead of hardcoding the credentials.
I think it would be good to print the recipe ID instead of hardcoding the classname. Otherwise you split the logs in several places.
Not sure this is as try finally block.
Not sure this is good, but can we just bubble up the lock and don't do it?
Not sure this is good, but can we change the try-catch block to throws Exception?
Can one of these constructors be private?
Instead of creating a FileInputStream, which has the constructor clean up the files, and is there any benefit to it using a try-with-resources pattern that throws IOException.
Instead of creating a FileInputStream, which has the constructor clean up itself.
Probably worth to log this exception in the new log, just in case
Probably worth to log this exception in the new exception :)
Probably should log this exception as well
Is it possible to use an else to set this to null? We would have that return an Optional<String> to avoid to return nulls.
Is it possible to use an else to pass to the two String values? We would have that return an Optional<String>
Is this else needed?
change to error
remove
change
this function is actually not used as the one in the file. Move it to the function?
this function looks like it may be repeated in multiple tests. Could you refactor it to a function?
this function looks like it may be repeated in multiple tests. Could you refactor it to a function and reuse?
Please extract this test to a function and reuse it.
Please extract this test to a function and reuse it in all tests.
Please extract this test to a function and reuse it in all cases.
Please use specific names for variables.
Please use specific names for local variables.
Please use other names in this class.
rename to droppedObject
rename to deleting obj
rename to p
This is not necessary and might break the test.
This is not necessary and might be reverted.
This might fail the test.
Is it possible to make this a list of objectNumbers, since the size is of the array?
Is it possible to make this a list of objectNumbersStr?
Is it possible to refactor this code since we are now comparing state types of objectNumbersStr?
Better to catch the SQLException (which is what it is about)
Better to declare result of type 'final'?
Better to catch the SQLException (which is caught by Exception)
UnchangedCommitMessageException
UnchangedCommitMessagesException
UnchangedCommitMessage
Please use an early return here instead of throwing the exception
Please use an early return here instead of throwing the null check
Please use an early return here.
I'm not sure why this sleep is needed here. Can you check the code that checks for equality?
I'm not sure why this sleep is needed here. Can you check the code that checks for the file contents, and make sure it is not there during the test?
I'm not sure why this sleep is needed here.
RelatedToViaCollectionFieldAccessorFactory is a parent class. I think adding a parent class to this class would eliminate the Traversal and ThreadLocal. Might be better to have a separate factory method in the base class.
RelatedToViaCollectionFieldAccessorFactory is a parent class. I would have moved the TraversalFieldAccessorFactory to a separate class. Then in the separate classes we can have a single factory factory method as well.
RelatedToViaCollectionFieldAccessorFactory is a parent class. I think adding a parent class to this class would be cleaner.
This is no longer needed.
This is not needed.
This is no longer used.
This method isn't called very often. I think it's better to have just one signature (the 3-arg signature) so call sites have to be explicit about their multiValueHandling. IMO this will make bugs less likely.
This method isn't called very often, so I think it's better to have just one signature (the 3-arg signature) so call sites have to be multiValueHandling. IMO this will make bugs less likely.
This method isn't called very often, so I think it's better to have just one method with the multiValueHandling
No need to cast to Ref[] here
Don't know if this is a RuntimeException. I would prefer Throwable.class.isAssignableFrom(ex) over just catch errors.
Unnecessary cast.
We should add brackets to this even if it's a single line.
We should add brackets to this even if it's hard to read.
We should add brackets to this even if it's more readable.
Use TextUtils.equals() instead of contains() ==
Use TextUtils.equals() instead of ==.
Use TextUtils.equals() instead of contains() ==.
Can you add "throws Exception" to the log message?
Can you add "throws IOException" to the log message?
StartProxy is Nullable. Please add a check here, and use getNonNullable.
It would be nice to specify the name of the event because it can help with debugging here.
It would be nice to specify the name of the event because it can help with debugging
It would be nice to specify the name of the event because it can be related to the recipient here
I prefer fail-fastso first == 1
I prefer fail-fastso first ==1
Use just count instead of ignored.
You can do a builder.Builder.addType(srcOrgMetadata.getLegalname().getValue()); to make it a bit easier to read.
You can do a builder.Builder.addType(srcOrgMetadata.getLegalname().getValue()); here. No need to set the type to void.
You can do a builder.Builder.addType(srcOrgMetadata.getLegalname().getValue()); here. No need to set the type to void
You're missing the new message type you've added.
You're missing the new message type you're not using.
You're missing the new message here.
1. OutOfBoundaries prone. 2. Why do you check the first comparator list instead of the second? What if multiple comparators are null?
1. OutOfBoundaries prone. 2. Why do you check the first comparator list instead of the second?
Exception?
Should we give a different message here, like fail-fast, not retrying?
Should we give a different message here?
This should be a warn.
Don't log and throw
Don't we need to log and throw
Don't we need to log this?
[Checkstyle] inputs for strings
[Checkstyle]
[Checkstyle] inputs for regex match.
Just curious, why did you move this into the.reconfigureWindowCache()?
Just curious, why did you move this into the.reconfigureTableRef()?
Just curious: why did you move this into the.reconfigureTableRef()?
Same as above. We should use Util.checkArg
Same as above. We should use Util.checkArg(args, "function '%s' needs 3 arguments");
Same as above.
This is very nitpicky, but would it make sense to wrap the conditional in an Handler in an Activity?
This is very dangerous, since it will lead to an activity for every time the app is loaded (i.e. when the view is attached/review, or the view is attached). You should just make sure the post is loaded in the background before calling the system.
This is very dangerous, since it will lead to an activity for every time the app is loaded (i.e. when the view is attached/review, but it's not), and would be better to just add a check for it.
Please combine lines 96 and 98 into one line.
It looks like what you did in the previous tests - the parameter name is BCF and not BCF.
It looks like what you did in the previous code was a typo.
Why is this list created by the consumer? If it's not, I think it's better to just return an empty list instead of null, no?
Why is this list created by the consumer? If it's not,, I think it's better to pre-create the list?
Why is this list initialized?
final
This will return an empty list which even with defaults below I believe.
final?
same here IMO
Same here IMO
same here IMO this can't
This is a bit misleading, since the tab view will be active, not the tab view.
I would add a log message here.
This is addressed by <LINK_0> which is now fully acked, but again here.
I don't think this is good, as you're not checking if the backup has a random blob. If there are any backups that are just a single backup, it might be a good idea to have just one checking at a time.
I don't think this is good, as you're not checking if the backup has a random blob. If there are any backups that are just a single backup, it might be a good idea to have just one checking.
I don't think this is good, as you're not checking if the backup has a random blob. If there are any backups that are just a single backup, it might be a good idea to have just one checking at a time. Also we should probably cover this case as well
@tobiasKaminsky any thoughts?
@tobiasKaminsky any thoughts, would it be better to store the result in a local variable and reuse it?
@tobiasKaminsky any thoughts on this?
Should this be LON_SIE?
Should this be LON_D?
Should this be LON_Y_ON_D?
A space between if and (
Please add braces around else statement bodies.
Please add braces around if/else statements
Add methods to api.getNetworkInterfaceCardApi(String)
Add methods to the api.
Add methods to api.getNetworkInterfaceCardApi(id)
nit: this can be private
nit: this can be a separate function
nit: this can be a single line
To save an RPC roundtrip, could you create a new suggestservice that does this and then returns the combined results instead? I think that it is important to ensure a single RPC for an oracle since it needs to respond quickly while users are typing. Additonnaly, such an oracle could perhaps already filter groups which are larger than maxAllowed? It could also filter out the Registered and Anonymous User groups?
To save an RPC roundtrip, could you create a new suggestservice that does both of these queries and returns the combined results instead?
Missing final
It would be better to check this in the private method, with UnixSHACryptPasswordSpec and the following two methods in this class.
It would be better to check this in the private method, with UnixSHACryptPasswordSpec and the following two lines in this method.
It would be better to check this in the private method, with UnixSHACryptPasswordSpec and the following two methods in this class instead.
I wonder if we need to explicitly create a default value for the metadata type of the JSON string. This way you won't have to set the default value to 0 in the JSON parser.
I wonder if we need to explicitly create a default value of false and then setting the default value in the JSON object. This way you won't have to explicitly set the value explicitly, it's a little hard to read.
I wonder if we need to explicitly create a default value of false and then setting the default value in the JSON object. This way you won't have to explicitly set the value explicitly, which should be what we want to consider.
companyRatingCodeType2
siiiick
si sin it
Can the response.body().contentLength() be replaced with Utils.checkResponse(stream, "UTF-8")?
Can the response.body().contentLength() be replaced with response.setHeader(Charset.SC_URI_LENGTH)?
Can the challenge be null?
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused private "set" method. [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AS1192)
Rename the variable gsUri to be more readable.
Rename the variable gsUri to be more readable. :)
crawl_generate as a constant - at least in the "id" parameter.
crawl_generate is stored as a constant because it's not ordered by the reader reader.
toString
I don't like this but it looks like it's really necessary and because you don't need a StringBuilder :)
I don't like this but it's really hard to see a result..toString() is not really descriptive.
This looks like it should be a String instead.
Won't this cause the user to have a non-empty dirs? What if the path does not exist?
Won't this cause the user to be deleting everything about a root directory?
Won't this cause the user to have a non-empty dir here?
If I'm reading this right, we probably shouldn't have it here. This should be set to "master".
If I'm reading this right, we probably shouldn't have it here. This is probably not the right place to do it in the UI.
If I'm reading this right, we probably shouldn't have it here. This is probably not the right place to do it.
int enbale = 1;
int enbale = 1
could we make this an int instead?
I think the message was not very useful
I think the message is slightly misleading
I think the message was slightly misleading; it doesn't specify the class loader.
I'd add the curly braces around the body of this method to be safe.
I'd add the curly braces
I'd add the curly braces around this statement
Might be a good idea to check the empty queue here as well
Might want to check the empty queue here as well
Might be a good idea to check the empty queue here as well.
can we use a constant like README.md?
can we make this a constant?
can we use a constant like README.md?
From what I can tell, this case is only used in the while loop. Why not just use combineSplits and combineSplits?
From what I can tell, this case is not included in the while loop. Can this be an if-then-else?
From what I can tell, this case is not included in the while loop. How about just while (currentSplit!= null && nextSplit.getLength() < maxSize)?
suggestion LOG.debug("region normalizer", tableName, e);
i think this is safe but the list will still be modified, since the migration code here will guarantee it's correct. If it's a "region normalizer" (the others do) then we will add a note to the docs.
suggestion LOG.debug("region normalizer");
can you append the sessionId here and for all the other fields?
can you append the sessionId here and below?
can you append the sessionId here and for all the other getters?
Can you change this method to return the survey instance and avoid a null check?
Can you change this method to return the survey instance and avoid a null check on it?
Maybe we should remove the null check from slDao.
A copy request is _not_ going to be converted to a _last_ space.
A copy request is _not_ going to be converted to a _last_ space. So this test would be useless
A copy request with no space will be printed
Can we refactor this so that we build with some interals of the Maven configuration?
Can we refactor this so that we build with some interals of the Maven API?
Can we refactor this so that we build with some function?
"'Endpoint' is required and cannot be null."
nit: can not -> cannot
null check. AddDatePolicy in UserAgentPolicy constructor
I think it is better to return an empty String instead of null. We do not need to check any nullity of the return value to decide if it's actually valid.
I think it is better to return an empty String instead of null. We do not need to check any nullity of the return value to decide whether to handle it.
I think this should be DEBUG instead of ERROR.
You could use StringUtils.toImmutable(example.value())
You could use StringUtils.toImmutable here
You could use StringUtils.toImmutable(example.name())
use break?
use break;
break?
whitespace
typo
formatting
Shouldn't we report only the first element in a list rather than the entire flow?
Shouldn't we report only the first child?
better to use ImmutableSet.of(loc.syntaxNode, loc.syntaxNode.is(Tree.Kind.NEW_CLASS)?
Is the check ever necessary? What does it catch the exception?
Is the isEnabled check necessary? What does it catch the RuntimeException?
Is the isEnabled check necessary? What does it catch the Exception?
This change can be moved to a separate commit, which makes it easier to read.
This change seems to be unrelated. If it is, we can move it to a separate commit.
This change seems to be unrelated. If it is, we should throw SemanticException.
Is there a reason we prefer to pass 1356L and 2356L?
is there a reason we prefer to pass 1356L and 2356L?
Is there a reason we prefer to pass 1356L and 2356?
SenseiPluginRegistry contains [Files.createBean](<LINK_0> which you can use instead.
SenseiPluginRegistry contains [Files.createBean](<LINK_0> you can use instead.
SenseiPluginRegistry contains [Files.createBean](<LINK_0> you can use it here
Why not just notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).size()?
Why not just notebook.getNotebookAuthorization().getOwners(cloneNote2.getId()).isTerminated();
Why not simply create notebook instance in constructor?
Can we move this to a field of this class?
Can we move this into a field of this class?
Can we move this to a constant class?
Do you want to convert toString to a string?
Do you need to convert toString to a string?
Do you need to convert toString to a string? The toString method does pretty much the same.
Can't we directly cast this into a map?
Can't we directly cast this into a Map?
Can't we simply cast this into a map?
Minor: can we make this method private since it will only be called by the new method?
Minor: can we make this method private?
Minor: can we make this method private since we only use it once?
why not use The vmValidator here?
please use here Guid.isNullOrEmpty
please use here Guid.isNullOrEmpty()
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it' own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
![MAJOR](<LINK_0> 'Severity: MAJOR') Method has 7 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
do we really really really really need this method?
do we really really really really need this?
This method is impossible to understand and review, full of casts and untyped methods.
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 22 to at most 20. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "protected" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 22 to at most 20. [![rule](<LINK_3>](<LINK_2>
style nit: no braces here
style nit: missing space after (
style nit: missing space after if
please extract these constants
please extract these constants and have them be constants
please extract constants
Instead of using a compareAndSet style, we should use simple while loop, and only do the update if the file is ready.
Instead of using a compareAndSet style, we should use simple while loop.
Why do we need this?
same here: could be decided outside of the factory
same here: can be decided outside of the factory
same here, can be decided outside of the factory
I think we probably should change the name of the file to something like "file:///hirt-engine". The user should be able to import common java file using java.io.File.separator.
I think we probably should change the name of the file to something like'my_engine_track_name'.
I think this line should be inside the try block, right?
Don't need a line break here.
Don't need line break here as well.
Don't need a line break here
Could you use simple for (final Headers o : allHeaders) { logger.debug("HTTP GET " + url); return o; }
Could you use simple for (final Headers o : allHeaders) { logger.debug("HTTP GET " + url); return o.headers; }
Could you use simple for loop, since we assign o to a variable or return?
You should use a constant here (and other places)
You should use a constant here (and other similar cases)
Assert.assertEquals
After more closer inspections I believe we have a race condition here. newValue and oldValue pair still races and the main reason we log the change is to know what's the current state is. Without the synchronization, the log messages are not guaranteed to reflect that since the order of log messages is not coupled with the order of the changes.
After more closer inspections I believe we have to synchronize the whole method. newValue and oldValue pair still races and the main reason we log the change is to know what's the current state is. Without the synchronization, the log messages are not guaranteed to reflect the order of log messages.
After more closer inspections I believe we have dedicated log messages, so it's not necessary to add them. The oldValue and oldValue pair still is not available.
Please consider making this "OR" as a constant.
Do you really need the "catch" here?
Please use try with resources.
rename to something like hasPostResponses?
Should be changed to for(int response : responseIndx)
Should not be == false?
It'd probably actually be okay to call getTypes() for all objects. I think for binaries it'd still work, and we want to be able to process AdminUnits and likely folders too.
It'd probably actually be okay to call getTypes() for all headers here, and then iterate over your string. I think for binaries it'd still work, and we want to be able to process AdminUnits and likely folders too.
It'd probably actually be okay to call getTypes() for all headers here, and then iterate over your string. I think for binaries it'd still work, and we want to be able to process them.
I wouldn't have a variable for it.
I wouldn't expect the variable to be inlined.
I wouldn't expect an exception to be thrown?
Can't you drop the "subAward" and "subAwardId"?
Can't you drop the iteration over values.containsKey("title") check and just do a null-check on values.contains("title") check?
Can't you drop the iteration over values.containsKey("title") check and just do a null-check for values == null?
Does this work if the type of plugin is Comparable? You may need to clarify.
Does it make sense to move the the incompatible plugin to the line above? You may need to clarify.
Does it make sense to move the the type of the plugin to the line 48? You may need to clarify.
Can you move this into a _periodicMetrics.recordCounter("job_executor_ticks", 1) so we don't have to expose all the metrics through the _periodicMetrics.recordCounter("job_executor_ticks", 1)? Or just remove the _periodicMetrics.recordCounter("job_executor_ticks", 1)
Can you move this into a _periodicMetrics.recordCounter("job_executor_ticks", 1) so we don't have to expose all the metrics through the _periodicMetrics.recordCounter("job_executor_ticks",2)?
Can you explain why this is failing?
Select target type to create
Use ld.setInput(commands);
Use ld.setInput(commands); to get the list
Pull this out to a variable?
Pull this out to a variable, and then reuse it in the else block?
reminder: add a channel id for the channel to checkpoint and not the channel.
we should have a break here to prevent that case.
we should have a break here to prevent that case of 3rdStatement.
we should probably use else instead of if
Consider using a for-each loop here instead.
Consider using a for-each loop here too.
Consider using a for-each loop here.
Would you extract other shared code into a method? I don't think it's a good idea to move this approach elsewhere.
Would you extract other shared code into a method? I don't think it's a good idea to move this approach into the base class.
Would you extract other shared code into a method? I don't think it's necessary, but that doesn't seem a good thing.
I'm not sure that we can have a problem here, but why is the added data.getSequence() == null?
I'm not sure that we can have a problem here, but why is the added data.getSequence() == null + move.getRoute()?
I'm not sure that we can have a problem here, but why is the added data.getSequence() == null? what's the user important?
Why are we incrementing the variable if it's empty?
Why are we incrementing this here?
I think it would be even better to log a warning, since the user might be logged in the console.
Opsu.close(e)
Remove (Exception)
Opsu, is this correct?
this can be private static
please add the the exception type: as well
please add the the exception message
I'm almost tending to use VanillaExceptions.
"Exception" -> "Exception"
"Exception" -> "Unknown exception"
We should add a check for "lower" and "second" rather than than choosing "second". For example, int1 = 0; int max = 0; int b = variantContext.getContig() - locus.getPosition(); if (b!= -1) { return b; } else { return b; }
We should add a check for null before calling it.
We should add a check for "lower" and "second" rather than than ==.
minor: put docModel.getId() before the if statement
minor: put docModel.getId() before the cast
minor: no need to cast to session
Assuming we have a minute?
Assuming we have a minute? A minute?
Assuming we have a minute, please use miliseconds.
This is a duplicate of log_android_title. Can we move this to a constant and reuse it?
If we're using this value, the code will become useless (and it's not necessary, right?).
This is a duplicate of log_android_title. Can we move this to a common method?
I would prefer constant there.
I would prefer constant there. ("java.util.ArrayList") would be better.
I would prefer constant there..
If we don't like the name of java.lang.Iterable<? extends T> elements it's better to replace java.lang.Iterable<? extends T> list = List.ofAll(elements); List<T> list = List.ofAll(elements); return newTrie = newTrie.put(newIndexShift, list.length());
If we don't like the name of java.lang.Iterable<? extends T> elements it's better to replace java.lang.Iterable<? extends T> list = List.ofAll(elements); List<T> list = List.ofAll(elements); return newTrie.put(newIndexShift, list.length());
If we don't like the name of java.lang.Iterable<? extends T> elements it's better to replace java.lang.Iterable<? extends T> list = List.ofAll(elements); with java.lang.Iterable<? extends T> list = List.ofAll(elements); return newTrie.put(newIndexShift, list.length());
think you should also set the address to null from yarnConfiguration.
all of this part should be in getConfigurationUrl() method.
all of this part should be in ConfigurationUrlBuilder
Looks like these tests are very dangerous by time... You should use.transform(h -> h.headerExpression(IpHeaders.CONNECTION_ID, "payload"))
Looks like these tests are very dangerous by time... So you should use.transform(h -> h.headerExpression(IpHeaders.CONNECTION_ID, "payload"))
Looks like these 3 lines are very similar....
How about final List<Long> fileIds = new ArrayList<>();?
Should we be returning partial list?
Should we be closing the queryResult here?
Something has to be wrong here. Initially you made this, 'connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState()!= EnumDockerConnectionState.ESTABLISHED'. Now it's just connection.getState()!= EnumDockerConnectionState.ESTABLISHED
Something has to be wrong here. Initially you made this, 'connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState().equals(DockerConnectionState.ESTABLISHED)'. Now it's just connection.getState()!= EnumDockerConnectionState.ESTABLISHED
Something has to be wrong here. Initially you made this, 'connection.getState()!= EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.getState()!= EnumDockerConnectionState.ESTABLISHED'. Now it's just connection.getState()!= EnumDockerConnectionState.ESTABLISHED.
Why we need this? Can't we just rely on the @Override annotation?
Why we need this? Can't we just rely on the @Override below?
Why we need this? Can't we just rely on the @Override below for consistency?
Did you mean to leave this in it?
Did you check this in it?
Did you check whether the config property can be set?
need to add <LINK_0> at the end of this method
need to add <LINK_0> at the end of the string
need else if <LINK_0>
Is this a problem. You should also rename v.getStorageDriverId() to something like 'null'.
Is this a problem. You should also rename v.getStorageDriverId() to StorageDriverDTO.
Is this a problem. You should also rename v.getStorageDriverId to something that actually returns the cluster.
Is it needed? The code seems to only use the old code.
Is it needed? The code seems to only check for the empty string
Why is this line needed?
Let's make this fix the alignment
Let's make this method final
Let's make this method final and remove the method.
Is it safe to not using epsilon value for comparing double type result?
Is it safe to not using epsilon value for comparing double type installation?
Is it safe to not using epsilon value for comparing double type?
Is this going to come up with a syntax error?
This statement is going to be converted to a conditional way.
This statement is going to be converted to a single call.
Can we use KotlinUtils.isKotlinClass(baseClassMethod) here?
Can't we use KotlinUtils.isKotlinClass(baseClassMethod) here?
Can we use KotlinUtils.isKotlinClass(baseClassMethod) instead of KotlinReflectionUtils?
Thanks for this. We should check that the future is 'not'.
Thanks for this. We should check that the future is 'not' >= 2 or so.
Thanks for this. We should check that the future is 'not' >= 2
This method is quite heavy. Maybe extract it to a method?
This method seems quite complicated to me. Can we abstract it out?
This method is quite heavy. Maybe extract the list of locales into a method?
Should this be closed or at the end?
Should this be tested in the test suite?
Should this be closed or should it be closed?
Maybe better to: if (dialog.open()!= Window.OK) { return; }
Maybe better to: if (dialog.isCancelled()) { return; }
Maybe better to return which cancels the child monitor
can't we just do elem.getClassName()?
Just do elem.getClassName() here.
Just do elem.getClassName().getSimpleName()?
No need for final variables.
No need for final when calling methods.
Not necessary.
Since we have a List, we should avoid the temporary array allocation by looping like so: for (int i = 0, size = this.dataChannel.getProto(); i!= null) { builder.setEnforcer(enforcer.getProto()); }
Since we have a List, we should avoid the temporary array entirely here.
The changes to this file are correct: <LINK_0>
The "f" field is probably not needed as this is likely to be initialized with the "default" field, I'm guessing the behavior of this method, but since up to you, it's maybe better to use the same approach as the "default" feature, and instead use the default rendering in the build() method, this would be much more stable, as it would be done once by declaring the parameter in the constructor, like private static final String LITERAL = "f"; private static final String LITERAL = "f"; Then, when calling trim, you can create a separate method, like private static final String LITERAL = "f"; Then, you can call here.
The "f" field is probably not needed as this is likely to be initialized with the "default" field, I'm guessing the behavior of this method, but since up to you, it's maybe better to use the same approach as the "default" behavior.
The "f" field is probably not needed as this is likely to be initialized with the "default" field, I'm guessing the behavior of this method, but since up to you, it's maybe better to use the same approach as the "default" method.
I would return "UNKNOWN" here and let the user know that it returns Version, right?
I would return "UNKNOWN" here and let the user know exactly what version exists in the file.
This Exception should be thrown.
also do schedulerState.removeTask(taskId)
still need to remove the task that is added to the offer.
also remove task.
Please don't assign null. I would prefer the idiom to be: ReviewDb db = schemaFactory.open(); try { } finally { db.close(); } As then the Java compiler can promise us the value cannot be null at use sites, and its clear what they expect.
Please don't assign null. I would prefer the idiom to be: ReviewDb db = schemaFactory.open();
Please don't use try-with-resources.
Why this change? It doesn't seem to be related to this PR.
Why this change? It doesn't seem to be related to the PR.
Why this change? It doesn't seem to be related to this issue.
You can just pass _raw_ plural to the method name. That way you don't have to use String.format() twice
You can just pass _raw_ plural to the method name, to avoid the need to use String.format() here as well.
You can just pass _raw_ plural to the method name. That way it's more concise.
You could reuse the method input[i].getFullName() here.
You could reuse the method input[i](<LINK_0>
You could reuse the method inputReader
I am sorry, I decided not to move this logic to [Event.currentStep](<LINK_0> 'Severity: MAJOR') Remove this call in a separate PR and try in the PR for flow control. [![rule](<LINK_1>](<LINK_2>
I am sorry, I decided not to move this logic to [Event.currentStep](<LINK_0> 'Severity: MAJOR') Remove this similar call from CreateLinkPanel.java and move the call to setProgress method
I am sorry, I decided not to move this logic to [Event.currentStep](<LINK_0> 'Severity: MAJOR') Remove this similar call from CreateSiteActionBuilder#run() method and move the call to setProgress method
I don't see the point of this change. Can it be done in the future?
I don't see the point of this change. Can it be done in a separate commit?
I don't see the point of this change. Can it be done in a different way than leaving it blank?
There does not need to have a separate method for this. You can just call it updateResponse( FeedbackResponseAttributes newResponse)
There does not have a space between the { and }.
There does not have a space between the { and }
This is just a nitpicky, but I'd prefer public static void throw(InvocationTargetException e) { if (runExperiment) { log.info("Experiment failed to the fallback service. We will allow trying to import the experimental service again in {} milliseconds.", REFRESH_INTERVAL.toMillis(), e.getTargetException()); } throw e; } }
This is just a nitpicky, but I'd prefer public static void throw(InvocationTargetException e) { if (runExperiment) { log.info("Experiment failed to the fallback service. We will allow trying to restart a experimental service again in {} milliseconds.", REFRESH_INTERVAL.toMillis(), e.getTargetException()); } throw e; } }
This is just a nitpicky, but I'd prefer public static void throw(InvocationTargetException e) { if (runExperiment) { log.info("Experiment failed to the fallback service. We will allow to use experimental service again in {} milliseconds.", REFRESH_INTERVAL.toMillis(), e.getTargetException()); } throw e; } }
Unnecessary (also below)
is this really necessary? (I prefer keeping it INITIALIED for each invocation)
Unnecessary (andand below)
Null check (otherStatus, null etc).
Null check (Whitespace).
Null check?
How about name it using camel-case? such as job?
How about name it using camel-case? e.g. 'Job name'
How about name it using camel-case?
Since it's just a copy and paste, why not make the remote cost smaller than 1?
Since it's just a copy and paste, why not make the default full cost smaller than 1?
Since it's just a copy and paste, why not make the remote cost smaller then?
Shouldn't this be a property?
Please think about making this a constant ("item.id") and using it here.
Please think about making this a constant ("item1", "item2",....
I think we should use assumeFalse(System.getProperty("os.name").startsWith( "Windows") ) instead of startsWith
We should use assumeFalse(System.getProperty("os.name").startsWith( "Windows") ) instead of startsWith
I think we should use assumeFalse(System.getProperty("os.name").startsWith( "Windows" ) to avoid the need for the test
Shouldn't this be in the try / catch block?
Shouldn't this be in the try block?
Shouldn't this be this.
Should this be above the for loop above?
Would accountToUse be null?
Should this be above the for loop?
style: no curly braces for single line statement
style: no curly braces for single line statements
Close the reader when you're done with it
This is nitpick, but why we still rewrite the normal argument with input[index].
This is nitpick, but why we still rewrite the normal argument (with ST_VALUE)?
Why this change?
same question as above.
would be nice to handle this with the try/catch above?
would be nice to handle this with the try/catch block.
inline this
unnecessary cast
incorrect usage name
Do we need to verify that message.getLockToken() returns null?
Do we need to verify that message.getLockToken() is called?
Do we need to verify that we set the correct value to null?
Should it rather filter out spatial join?
Shouldn't it rather filter out spatial join?
Shouldn't it rather filter out correlated queries?
I think this is wrong.
I think this should be done in the constructor.
I think this should be done in the following commit.
it's common to declare this method
please rename variable to something else what's wrong
it's common to declare this method private?
WSO2
WSO2 InternalServiceO2
WSO2 WSO2
Why is this not a BeanFactoryResolver? Although why don't you use a ChannelResolverUtils.getChannelResolver() instead any way?
Why is this not a ChannelResolverUtils.getChannelResolver()? Although why don't you use a ChannelResolverUtils.getChannelResolver() instead any way?
Why is this not a ChannelResolverUtils.getChannelResolver()? Although why don't you use a ChannelResolverUtils.getChannelResolver() instead any way?
We probably don't need to do it here, but we may want to read in all these parameters (username, password, etc) from a properties file (rather than hard-coding them in multiple places in the code).
We probably don't need to do it here, but we may want to read in all the code base with a config file (rather than hard-coding the file in multiple places in the code).
We probably don't need to do it here, but we may want to read in all these parameters (username, password, etc) from a properties file (rather than hard-coding them in multiple places in code).
I think we should use only FieldType.values() which is more appropriate.
I think we should use only FieldType.values() which is more efficient. It would be cleaner to use: FieldType fieldType = FieldType.values().stream().map(el -> FieldType.values()).filter(el -> FieldType.class.getName().equals(o)).collect(Collectors.toList());
I think we should fix the case sensitivity here.
is there any reason why only one return statement?
Curious why the declaration is final?
final
can we get rid of the double spacings between click listeners?
can we get rid of the double switchs between click listeners?
can we get the double spacings between click listeners?
We can remove this now useless try catch.
We can remove this now useless if keyStorePassword is true
We can remove this now useless try block
It looks like we can just create one string if it is not empty.
It looks like we can make this one-liner into one-liner with ternary operator
It looks like we can make this one-liner into one-liner
Maybe extract this into a DescribableList<ObjectComponent>. Then you don't need to create a new list that is passed to it.
Maybe extract it to a private method and call it from the Descriptor?
Maybe extract this into a DescribableList<ObjectComponent>. Then you don't need to create a new list here.
An alternative way to avoid this would be to use the objectConverter here and only use the provided value if the user specified value in the object.
An alternative way to avoid this would be to use the objectConverter here and only use the provided value if the user specified the value via.value()
An entity could be used here.
Couldn't we just do FILESYSTEM_PATH_TO_RESLOC since it could be frequently used in other places?
Couldn't we just do FILESYSTEM_PATH_TO_RESLOC since it could be/viewport for us?
forge:white -> tex
Why did you move this logic to OpenSAML2ComponentBuilder.getInstance().createIssuer(format, sIssuer);?
If you removed from from the upper side of if (StringUtils.isNotBlank(format) && checkDistinguishedNameidFormat(sIssuer)) is more readable than!StringUtils.isNotBlank(format) just above.
If you removed from from the upper side of if (StringUtils.isNotBlank(format) && checkDistinguishedNameidFormat(sIssuer)) is more readable than!StringUtils.isNotBlank(format) just used below
< measures.size()
Is the rationale for using reflection to do this? <LINK_0>
This does not have a reasonable way to handle measures with a count, which is not the case.
Can this go in RequestActionSupport
Can this go in ActionSupport
Can this go in ActionActionSupport
match -> countUpTo
one more too many attributes
one more
does it make sense to have a method that checks if the method is named as follows?
does it make sense to have a method that checks if the method exists?
does it make sense to have a method that checks if the method is named with @Nullable?
I'd also use the methods directly
I'd suggest using the methods getSuperInterfacesOfType(Rule) and remove the need for the null check
I'd suggest using the methods getSuperInterfacesOfType(Rule) and remove the need for the null check here
I don't think you need to add this, it's just an event.
I don't think you need this, it's already added in the test super class
I don't think you need this, it's likely that the folder isn't found, which is wrong with this change.
This is the type of object that is about to be replaced with the hash code I think.
This is the type of object that is about to be replaced with the hash code I think. :-) But maybe we should enforce it now that we remove the object.
This is the type of object that is about to be replaced with the hash code I think. :-) But maybe we should enforce it here, instead of allowing the user to remove the object.
checkState?
This looks out of place to me. We could use a iterator.seek(firstKey) and ByteComparator.compare that could be called on the key.
checkState
We probably should use false instead of 0 here.
We probably should use requestLayout() (this is actually the default behaviour).
We probably should use requestLayout() (this is actually the default behavior).
how about replacing it with String#join?
there is no need to init/save the vm, right?
there is no need to set it explicitly, you can remove it
Should we consider in PubSubProvider?
Shouldn't this be moved into the try block?
Should we consider in PubSubProvider or just use this instead?
Is this file really needed? Maybe we should add a servlet filter to the host.
Is this really needed? Maybe we should add a servlet filter to the host.
Is this really needed? Maybe we should add a servlet filter on the resource to initialize on the server.
I think that the bannedNode should be banned.
I think that the banned CoLISTedAgencies are already removed from the return list.
I think that the bannedNode should be banned?
Exception message should be more descriptive
Pls log the exception
Throw IllegalArgumentException?
This should actually be APIException, the + should be a, and the other part should be wrapped in new Object[] { } so this gets properly localised.
@vilchik-elena This can be simplified to java.map(this::getPrivileges).ifPresent(missing -> { throw new APIAuthenticationException("privileges required: " + missing.stream().map(Privilege::getPrivilege).collect(Collectors.joining(", "))); }
@vilchik-elena This can be simplified to java.map(this::getPrivileges).ifPresent(missing -> { throw new APIAuthenticationException("privileges required: " + missing.stream().map(Privilege::getPrivilege).collect(Collectors.joining(", "))); }
Why do we have to call this method again? IMO, it should be a parameter from the method.
Why do we have to write this exception? IMO, it should be a fatal error.
on journal
I'm wondering if we have to continue using NIO buffers? @saudet Was there a reason for this?
I'm wondering if we have to continue using NIO buffers? @saudet Was there a reason for doing this?
I'm wondering if there is a reason for this?
I should be sure this is correct. It should be removed entirely.
I should be sure this is correct. It should be removed from the tests
I should be removed this
There is a stream.isEmpty() check inside the lambda.
Should be Stream::concat
There is a stream.isEmpty() check which I guess
Does this mean that if a node is above the quota and for some reason restarts, it will not come up? Does the condition solve the problem?
Does this mean that if a node is above the quota and for some reason restarts, it will not come up? Does this mean a cluster restart could get blocked?
Does this mean that if a node is above the quota and for some reason restarts, it will not come up? Does the condition solve the issue?
Line length
AIRMASS will be null, so you could get an exception if it's not a valid input
AIRMASS will be null and this is a bad idea. Is that the case? If so, please put the code in a separate method.
Is it possible for accumulator to be empty? There is code below (lines 145 and 148) where accumulator.get() is called without checking isEmpty().
Is it possible for accumulator to be empty? There is code below (lines 145 and 148) where accumulator.get() is called without checking.isEmpty().
Is it possible for accumulator to be empty? There is code below (lines 145 and 148) where accumulator.get() will return null.
why call getMessage() twice?
why call getMessage() that is not valid anymore?
why call getMessage() that is not a valid name?
It would be nice if we add a severe log message to this case.
It will be nice when we add explicit handling for this case.
It will be nice when these kinds of enum values are expected to be used in the future.
please move this check to the validator
please move this logic to the validator
please move this check to the DAO itself.
Is this a good idea to throw an exception here? In the end we should figure out what is the right thing to do here.
Is there any reason this is readRecord() is called on a both read and read?
Is there any reason this is readRecord() is called on a both read and read buffer methods?
We actually set locale in Main class. I guess it's not set for unit tests.
We actually set locale in Main class. I guess we'd prefer it to set locale.
We probably should change this to set locale.
It is a bad practice to not propagate NullPointerExceptions to client code. Use IllegalArgumentException or IllegalArgumentException.
It is better to remove the null check and return if the templateConfig is not null.
It is a bad practice to not propagate NullPointerExceptions to client code. Use IllegalArgumentException.
It would be better to use a static final field for this.
It would probably be better to use a static field for this.
It would probably be better to move this.
If you want to distinguish the error message from DISTRIBUTED_REPLICATE -> DISTRIBUTED_REPLICATE
If you want to distinguish the error message from DISTRIBUTED_REPLICATE (e.g..stream().map(field -> brickDao.getById(b)), don't you want to throw exception?
I think we can just use allMatch here, no?
Please use the formatter. The line is too long and should be broken to two
Shouldn't this be inside NfsMountPointConstraint's logic?
Shouldn't the second condition be inside NfsMountPointConstraint's logic?
I would prefer to not expose this map directly to KItem
I would prefer to have this map directly to KItem
I would prefer to have this code after the synchronized block.
should we also check if the metric is not null before doing this?
should we also check if the metric is not null before creating the Config?
should we also check if the metric is not null before creating the Range?
What do you think about moving this validation to the model? Maybe validateParameters()?
What do you think about making this method private? That way we'll have the same code in two places.
What do you think about making this method private?
This is on the previous line
This is on the previous line.
This is on the previous test.
maybe clientCaps or something.
Shouldn't this be clientCaps or something?
Didn't we need the client capabilities here?
Calling the default case HIGH: normalPriorityPlugins.add(plugin); is a no-op.
Calling the default case HIGH: normalPriorityPlugins.add(plugin); is a really bad idea.
Calling the default case here doesn't make sense.
Returning null here will hide the.close() call and do not use System.out.println().
I would prefer to remove this System.out.println()
I would prefer to remove this printlns!
I'm not sure we want to mark the localWritesInRange.size() - localWritesInRange.size() - localWritesInRange.size() - localWritesInRange.size() - result.size());
I'm not sure we want to mark the localWritesInRange.size() - localWritesInRange.size() - localWritesInRange.size() - result.size());
I'm not sure we want to mark the localWritesInRange.size() - localWritesInRange.size() - localWritesInRange.size() - localWritesInRange.size() - result.size();
These two conditions don't seem to be necessary?
These two throw exceptions can be combined into one.
These two things seem to be ok. :-(
suggestion return tx.run("CREATE (v:VersionedThingWithAssignedId {id:1})").consume();
suggestion return tx.run("CREATE (v:VersionedThingWithAssigned id {id:1})").consume();
suggestion return tx.run("CREATE (v:VersionedThingWithAssigned ID {id:1})").consume();
It might be more readable to keep first argument on a new line.
It might be more readable to first create a new method on BKHttpServiceProvider that re-use the method name.
I would change log message to "Loading component." or something similar.
Should we also check for 'no selection' items are added?
Should we be in a finally block?
Should we also check for 'no selection' items at all?
How about the user trying to enable a hook which is already enabled? Also if there are up servers, command should fail
How about the user trying to enable a hook which is already enabled? Also if there are no up servers, command should fail
How about the user selected a hook which is already enabled? Also if there are no up servers, command should fail
I would recommend using [StringBuilder](<LINK_0> to make code more readable.
I would recommend calling.getStartOffsetInParent() + dot.getTextLength() in the TextRange constructor, that way it can be converted.
I would recommend calling.getStartOffsetInParent() + dot.getTextLength()
consider to use "-TMPDR" as a constant
Can you use "-TMPDR" as a constant and use it here?
Can you use "-TMPDR" as a constant and reuse it?
It seems that they should be removed and the blocks should be removed.
It seems like they should be removed and the blocks should be removed.
It seems that they should be removed and the test should now be ignored.
Since there's no information to provide the table name, I think it's fine to add a list or something like that.
Since there's now a method, how about a java.util.Optional?
The upload and response can be made private?
Since we're only using "http", don't we also need to check the primary key of the clipboard in this case?
Since we're only using java.util.Optional, feel free to use.
Since we're only using java.util.Optional, feel free to use, just like I've seen in the code (line 336 and 438).
Can we do this or the following? java if ( flush ) { if ( flush ) { return channel.write( msg ); } else { return channel.write( msg ); } promise = channel.write( msg ); return channel.write( msg );
Can we do this or the following? java if ( flush ) { if ( flush ) { return channel.write( msg ); } else { return channel.write( msg ); } promise = channel.write( msg );
Can we protect this and the boolean return value from write(...) instead? This would protect us from an atomic operation.
please add braces
please rename all local variables.
please rename to definition
We are doing a chain of calls to.collect(toList()) and we could reuse these.
We are doing a chain of operations to get groups, so maybe this should be a single method
We are doing a chain of operations to get groups, so maybe this should be a single method.
can be just ASTInfo ruleInfo = ruleInfo.getTransformationRule(); if (ruleInfo.isEnabled()) { for (RuleInfo ruleInfo : ruleInfo) { if (ruleInfo.getTransformationRule()!= null) { return EvaluationResult.NONE; } } }
I would just call ruleInfo.getTransformationRule() here and let it be clear that we don't have to check for null or empty context.
can be just ASTInfo ruleInfo = ruleInfos.get(ruleNode.getTransformationRule())
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it' own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local var / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
How about a simple: if (path!= null && sqlType!= null) { stmt.setNull(i, sqlType); else { stmt.setNull(i, sqlType); } } else { stmt.setNull(i, sqlType); }
How about we use the constructor: java private Integer sqlType;
How about a case where path is null?
@subkrish This is your issue. Original code was directory, not file. @romani This is another common issue.
@subkrish, please rename to antTask.
rename to antTask
I don't think having a media type here will be useful.
I don't think having a put like this is necessary.
I don't think having a put like this will be preferrable.
Why not check if countLines(beforeCursor) >= 0?
Why not check if countLines(beforeCursor) == 0?
Why not check if countLines(afterCursor) == 0?
Still prefer returning early on error conditions. In this case it would be if (cursor.getCount() == 0) { cursor.close(); return null; }
Still prefer returning early on error conditions. In this case it would be if (cursor.getCount() == 0) { cursor.close(); }
Still prefer returning early on error conditions. In this case it would be if (cursor.getCount() == 0) { cursor.close(); return; }
please use System.lineSeparator() instead of \n to match the line end with System.lineSeparator()
please use System.lineSeparator() instead of \n in equals()
please use System.lineSeparator() instead of \n to match the line end with System.lineSeparator.
@raver119 I feel like this should be in a util class of some kind?
@raver119 I feel like this should be in a util class of a util class.
@raver119 I feel like this should be in a util class of a util class?
Maybe this check should be outside the synchronized block as it could be in a finally block
Maybe this check should be outside of the synchronized block as it could be in a finally block
Maybe this check should be outside of the synchronized block as it could be used only once.
I would prefer these local variables to be final.
Typo.
Missing final
I think you don't need the else here since it's redundant.
I think you don't need the else here since it's not needed.
I think you don't need the else here.
If I understand this right, this is a normal activity, as it's a normal activity. The line should be: if ((CustomApp)getApplication()).getUserList().addUser(BluetoothUtils.getLocalBluetoothName());
If I understand this right, this is a normal activity, as it's a normal activity. The line should be: if ((CustomApp)getApplication()).getUserList().addUser(BluetoothUtils.getLocalBluetoothName())); That's a future PR.
If I understand this right, this is a normal activity, as it's a normal activity. There should be a getID() method that you can use ((CustomApp)getApplication()).getName() to get the ID from the activity. If that's the case, you can keep it as is and add a getID() method that automatically adds the ID. That way, it's a normal activity.
Would it make sense to convert expression into a string and then filter out the exceptionHandling? This could be a security issue.
Would it make sense to convert expression into a string and then filter out the exceptionHandling? This could be a one-liner, but I could be wrong!
Would it make sense to convert expression into a string and then filter out the exceptionHandling? This could be a one-liner.
Formatting. remove.
Formatting. remove unnecessary tabs
Formatting
There is no need for checking from list. At this point you can use: java for (CommonCudgment ccJudgments : ccJudgments) {...
There is no need for checking from list. At this point you can use: java for (CommonCudgment ccJudgment : ccJudgments) {...
There is no need for checking from list. At least, you can use: java for (CommonCudgment ccJudgments : ccJudgments) {...
private looks like a good change.
above 2 lines as it does not need a return.
private looks like a good candidate for a method isNullOrEmpty
Why is this necessary? Wouldn't it be enough to just create a file here?
Why is this necessary? Wouldn't it be enough to just create a filename here?
This line looks like a copy-paste error.
Call this method again after adding it to the dependencies graph.
Call this method again? It's not clear what it means.
Call this method again after the other tests.
This variable is unused
Typo: should be Drug
This var is unused
I think this is more readable java descriptionList.stream().filter(x -> fieldApprover.approve(x.getDataInfo())).filter(x -> StringUtils.isNotBlank(x.getValue())).filter(x ->!NULL_STRING_VALUE.equals(x.getValue())).findFirst().map(String::getValue).ifPresent(metaBuilder::setAbstract);
I think this is more readable java descriptionList.stream().filter(x -> fieldApprover.approve(x.getDataInfo())).filter(x -> StringUtils.isNotBlank(x.getValue())).filter(x ->!NULL_STRING_VALUE.equals(x.getValue())).findFirst().map(Field::getValue).ifPresent(metaBuilder::setAbstract);
I think this is more readable java descriptionList.stream().filter(x -> fieldApprover.approve(x.getDataInfo())).filter(x -> StringUtils.isNotBlank(x.getValue())).filter(x -> StringUtils.isNotBlank(x.getValue())).filter(x ->!NULL_STRING_VALUE.equals(x.getValue())).findFirst().map(String::getValue).ifPresent(metaBuilder::setAbstract);
Maybe a better solution would be to define size as Integer? The size here is in GB so it might be confusing to allow such large values... As for block domains we limit disk size to 8TB by default any way (ConfigValues.MaxBlockDiskSizeInGibiBytes).
Maybe a better solution would be to define size as Integer? The size here is in GB so it might be confusing to allow such large values... As for block domains we limit disk size to 8TB by default any way (ConfigValues.MaxBlockDiskSizeInGibiBytes). For file domains, I don't understand how ConfigValues are used in ConfigValues
Maybe a better solution would be to define size as Integer? The size here is in GB so it might be confusing to allow such large values... As for block domains we limit disk size to 8TB by default any way (ConfigValues.MaxBlockDiskSizeInGibiBytes). For file domains, I don't understand how ConfigValues are used in ConfigValues...
This potentially looses the information from String message data when the result is not a String or an int. If the type of replaceKeysAsyncRequest is not String, the exception should be passed to the logger (there is no reason why the conversion is done to String).
This potentially looses the information from String message data when the result is not a String or an int. If the type of replaceKeysAsyncRequest is not String, the exception should be passed to the logger (there is no reason for this). the reason is that the %s has been replaced in a responseData object that was passed to the logger (which is what is returned as String).
This potentially looses the information from String message data when the result is not a String or an int. If the type of replaceKeysAsyncRequest is not String, the exception should be passed to the logger (there is no reason for this). the reason is that the %s has been replaced in a response data from String to String, was there in the original code where the responseData was declared as String.
For readability, use String.format() (like others)
For readability, use strings.format(...) instead of string concatenation.
format
StringUtils.commaDelimitedListToStringArray(profile) The reason is that StringUtils.commaDelimitedListToStringArray already returns a String[], not a String.
StringUtils.commaDelimitedListToStringArray(profile) The reason is that StringUtils.commaDelimitedListToStringArray doesn't accept String as a parameter. If the parameter is null, it should be "master".
StringUtils.commaDelimitedListToStringArray(profile) The reason is that StringUtils.commaDelimitedListToStringArray doesn't accept null values. As a result, you do not need to check the length of the array.
I think we need a method here instead of forEach: : elements.forEach((p) -> names.add(p.getName()));
I think we need a method for explicit shutdown of the Transcriber to avoid assuming that there are no elements in the queue. This would perhaps be cleaner if we use that method instead of the Transcriber one.
I think we need a method for explicit shutdown of the Transcriber to avoid assuming that there are no elements in the queue. This would perhaps be cleaner if we use that
isn't this already protected?
isn't this already on the other line?
isn't this already on line 63?
This should be LOG.info().
This should be LOG.info()...
this should be LOG.info()...
Shouldn't this be checked only in case cluster is secure?
Shouldn't the system property be checked to "localhost"?
Shouldn't this be checked only in case cluster is secure?
what if foundService is null?
why do you need to check the status?
why not null?
Please use ISO 8601 delimiters for the new parameter.
Please use ISO 8601 :)
Please use ISO 8601 delimiters for the new parameter
as above, need to enhanceRemotes
if you want to use the old executor, need to enhanceRemotes
as above, useWithDedicatedExecutor::service
testIsString and testIsString can be replaced with TEST_SUT_SIE_WINDOWS.
testIsString and testIsString can be replaced with TEST_SUT_SIE_STRING_LENGTH.
testIsString and testIsString can be replaced with TEST_SUT_SIE_STRING_LENGTH
I think there is a problem with IndexingService between the two?
I think there is a problem with IndexingService between the two locks
I think there is a problem with Indexing and -1.0 for the entire time. It seems to me that the correct precedence of equals on the order of the keys.
or just assertFalse("error")?
or just assertFalse("error")
or just assertFalse?
Why do we need this?
Why do we need to get it out?
Why do we need to get it?
I wonder if we should also remove the MERGE filter, given that you have used it also in the other saveFeaturesStream method.
I wonder if we should also remove the MERGE filter, given that you have used it also in the other saveFeaturesStream
I wonder if we should also remove the MERGE filter, given that you have used it also in the other saveFeaturesStream calls.
Again, I think this should use the external ID
Again, I think this should use an actual total too
Again, I think this should use an actual total value.
Use 'StandardCharsets.UTF_8.name()' instead of 'getBytes("UTF-8").
Use 'UTF-8" instead of 'getBytes("UTF-8").
Use 'StandardCharsets.UTF_8' for consistency.
We should use a WARN here.
You should use a WARN here.
We should use a WARN here
Why are these empty lines removed?
Why are these empty lines necessary?
Why are these changes necessary?
This whole block can be replaced with Config(MainApplication.instance()).isUsingVideoPipeline()
This whole block can be replaced with Config(MainApplication.instance()).isUsingVideoPipeline();
This whole block can be replaced by: VideoInfo preferredVideoInfo = video.onlyVideoInfoForDownloading();
I know this is [Never](<LINK_0>, but in this case I think this should be 'finally' block.
I know this is [Never](<LINK_0>, but use braces for simple single-line statements, more of these.
I know this is [Never](<LINK_0>, but in this case I think it's better to use '\\' and readLines...
please rewrite test with just this: assertThat(result.getArchitecture(), equalTo(expectedArch + "-" + expectedVersion));
please rewrite test with just this: assertThat(result.getArchitectureName(), equalTo(expectedArch + "-" + expectedVersion));
please use assertThat(...) here and everywhere else please. It's hard to read.
I would prefer if you could avoid the lock by calling newByteBuffer() here.
I would prefer if you could avoid the lock by calling newByteBuffer() here as it is really only going to be used in the file.
final
"read chunk"
"this"
" buffer"
same, extract
same, extract class
same
Formatting
Changed to type since we know the type of action
Split the if blocks into multiple lines
Same as above, I guess we should use [this](<LINK_0>
Do we need this?
Same here as before.
Maybe use System.currentTimeMillis() instead of System.currentTimeMillis()? It's a lot more readable.
Maybe use System.currentTimeMillis() instead of System.currentTimeMillis()? It's a lot more expensive and expensive.
Maybe use System.currentTimeMillis() instead of System.currentTimeMillis()? It's a lot more expensive and faster.
why not call this.createLabel directly?
Shouldn't this not be EEFFDescriptionDescription?
why not call the createLabel directly?
Maybe there should be a baz property here that isn't included?
Maybe there could be a baz property here that isn't included?
Maybe there should be baz property here that isn't included?
why not just use a do-while loop instead of assigning an AtomicBoolean? java for (Map<String, Integer> entry : referencedComponents.getItems())
why not just use a do-while loop instead of assigning an AtomicBoolean? java for (Map<String, Integer> key : referencedComponents.getItems())
why not just use a do-while loop instead of assigning an AtomicBoolean? java for (Map<String, Integer> key : referencedComponents.getItems()) {
There should be a java.util.Optional.
There should be a java.util.Arrays.toArray() for this.
There should be a java.util.Arrays.stream(groups).forEach(...)
It might be better to assert that we are not there at least 10 sessionVariables.
It might be better to assert the variable's name is not 0, because it's not equal to 1
It might be better to assert the variable's name is not 0, because it is just a random suffix.
A certificate Verifier == null means that we don't support X.509 right? If we don't support X.509, the certificate type/cipher suite negotiation should have failed before. So if we still receive a CertificateMessage with a CertificateChain, I don't know if we should log and raise bad certificate. I feel this is more an error from the foreign peer (or a bug at negotiation time). Maybe HANDSHAKE_FAILURE and the log about "invalid Certifcate message" would be more appropriate.
If we still want to log a CertificateMessage with a CertificateChain, I don't know if we should log and raise bad certificate. I feel this is more an error from the foreign peer (or a bug at negotiation time). Maybe HANDSHAKE_FAILURE and the log about "invalid Certifcate message" would be more appropriate.
A certificate Verifier == null means that we don't support X.509 right? If we don't support X.509, the certificate type/cipher suite negotiation should have failed before. So if we still receive a CertificateMessage with a CertificateChain, I don't know if we should log and raise bad certificate. I feel this is more an error from the foreign peer (or a bug at negotiation time). Maybe HANDSHAKE_FAILURE and the log about "invalid certificate" would be more appropriate.
AssetSourceCollection(idKey, originalSource) should be a deterministic name. It might be fair to assume that the list of assetSources is completely non-null?
AssetSourceCollection(idKey, originalSource) should be the only set to the type it represents. The only way to do it is to get the item from the source.
AssetSourceCollection(idKey, originalSource) should be a deterministic name.
FIELDS_KEY is not valid anymore.
FIELDS_KEY is not enough.
FIELDS_KEY is not enough
Suggestion: Would have a message like "invalid expression:..."
:smile:
Suggestion: Would have a message like: "Raw expression is invalid"
No need for null check
No need for null check, the constructor throws an exception if the value is null.
No need for all this, as the binderTypes are already initialized by the constructor.
Need to be version guarded by GTK 3.6 or newer.
Need to be version guarded with GTK 3.6 or newer.
Need to be version guarded in getMaskKeysym, as it is null.
this could be final
I think this can be final
I think this could be final
What is the purpose of this? The method is only called if there is a single course (the course is already in the list, right? ). Can't we do it here?
What is the purpose of this? The method is only called if there is a single course (the course is already in the list, right? ). Can't we do it here too?
What is the purpose of this? The method is only called if there is a single course (the course is already in the list, right?'result' is not null)
is this what you are looking for? Can you refactor it to something like: java if (ctb!= null) { changed |= co.onJobRenamed(oldName, newName); } else {... }
is this what you are looking for? Can you refactor it to something like: TriggerBuilder ctb = null; if(ctb!= null) { changed |= co.onJobRenamed(oldName, newName); } else {... }
is this what you are looking for? Can you refactor it to something like: TriggerBuilder ctb = null; if (ctb!= null) { changed |= co.onJobRenamed(oldName, newName); } else {... }
@vilchik-elena This line is unnecessary, but you will never set the fail count on the first line.
@vilchik-elena This line is unnecessary, but you will never set the fail count on the first element.
@vilchik-elena Why not just use a Builder for this?
Don't put.put(Constants.ID_KEY, id.toFullID());
Don't we need to wrap the parameters in DictionaryAsMap.wrap(properties)?
Don't we need to wrap the parameters in DictionaryAsMap.wrap?
nit: should be "a cache manager at address " + a
nit: This could be moved to a else block
nit: should be "a cache manager at address {0} to avoid log messages
this is a small change - you can fix this.
this is a place where we use Utils.create
this is a small change - you can fix this too.
This is not enough java try (final OutputStream output = getContentResolver().getWidth(); OutputStream output = null) { IOUtils.copy(input, output); }
This is not enough, I think.
This is not enough
pods should be created by a for-each loop
pods should be created by a for loop
pods should be created by a test pod.
This cast is redundant
Use srvcProc instanceof IgniteServiceProcessor.
This cast is unnecessary
Is the first check needed?
Is the first check necessary?
Is the "else" necessary?
This is a good candidate for a assertThat.
This is a good practice. Maybe we should use Assume.assumeTrue(Platform.isMac()); to create the directory.
This is a good candidate for a fail().
Could this not read if artifact.getArtifactId()!= null && artifact.getBaseVersion().contains(dependency)?
Could this not read if artifact.getArtifactId()!= null && artifact.getBaseVersion().contains(dependency))?
Could this not read if artifact.getArtifactId() is null?
You don't need to change this, just use the 'if' from 'if' to 'if'
You don't need to change this, just pass the 'object.getNfsServerProfileStats' to 'executeCommand'
Will this work if the user adds another profile without a name of the file? Should this be supported?
casting is redundant
should be java Assert.notNull(httpRequest, "application argument cannot be null.");
should we also cast to HttpRequest?
I added the line above, is that correct? Although, what is the point of creating a rectangle with 0 height here? It seems to be the same with and without it?
I added the line above, is that correct? Although, what is the point of creating a rectangle with 1 height here? It seems to be the same with and without it?
I added the line above, is that correct? Although, what is the reason for a dash? It seems to be the same with and without it?
- should be externalized - not a huge fan of the question form. How about "no icon for a category"
This should be externalized - not a huge fan of the question form. How about "no icon for a category"
This should be externalized
please use 'hostSupportedEmulatedMachines' instead of'requiredEmulatedMachines'
please use 'VdsGroup.getEmulatedMachines' instead of'requiredEmulatedMachines'
please use 'VdsGroup.getEmulatedMachines()' instead of'requiredEmulatedMachines'
Remove the'throws Exception'.
Remove the 'throws' clause.
Remove
Unnecessary when the string is the same.
"Change-Id: " + revision + " is the correct value when the 'n' is the same.
Unnecessary when the string was the same.
throws BindingConfigParseException
throw BindingConfigParseException
throws BindingException
Extract "createBranchCoverageTestFitness(b, true") to a variable.
Extract "createBranchCoverageTestFitness(b, true") to variable.
can be null now.
Doesn't this line cause you're checking for the same file?
Doesn't this line cause you're checking for the second line?
Doesn't this line cause you're checking for the same value?
@prahladyeri We can declare this "pom.xml" as a constant.
@mcivantos-tribalyte I'd suggest we do not need to 'pom.xml' prefix here. There is no need to fix it
@mcivantos-tribalyte I'd suggest we do not need to 'pom.xml' prefix here. There is no "pom.xml" defined in the module name.
Doesn't this really need to be a call to extendExprGraph?
Doesn't this really need to be a call to extendExprGraph? If that is the case, why not extendExprGraph and extendExprGraph?
Doesn't this really need to be a set?
Can you explain why this change is made in the PR?
Can you pass the string "redirect:/returnful" to paymentOverview.
Can you pass the string "redirect:/returnful" to the server.
The restart doesn't get happened at all.
The restart doesn't look right at all.
The restart restart should be done on all the buttons.
you shouldn't need to do this if you have a @After
you shouldn't need to do this if you have a @Before method or method with a @After
you shouldn't need to do this if you have a @Before method or method with a resource leak
setOffscreenPageLimit?
Give self-explanatory name here.
Make this "setupChildren" or similar
Can we add some logging here to make it easier to debug?
Can we add some logging here to make it easier to identify the important docIDs in the method?
Can we add some logging here to make sure we're not running this on the the thread?
If you add an assertion for the name, you don't need to add it to the list with the table name.
If you add an assertion for the name, you don't need to add it to the list with the first element, since that's what the user is trying to do.
If you add an assertion for the name, you don't need to add it to the list when the table is already created.
This should be "toUpdate".
This is an "if (toUpdate.isEmpty()) {" block.
This is an "if (toUpdate.isEmpty()) {" style is the convention.
This could be a private function then in-line it rather than creating a local boolean variable e.g. return allHealthy( results.values().stream().allMatch(HealthCheck.Result::isHealthy)).build();
This could be a private function then in-line it rather than creating a local boolean variable e.g. return allHealthy? Response.ok() : Response.status(503)).entity(response).build();
This could be a constant then.
The stats are set in StatsStats, so this check is unnecessary.
The current implementation in DataTableStats is also the stats for the stats.
The stats are set in the stats below. Isn't it useful to set external flag to false?
Can we please mock NetworkValidator instead of doReturn(dbFacade).when(dbFacade).getDbFacade().get();
Can we please mock NetworkValidator instead of doReturn()?
Please use doReturn() instead of mocking...
Can we just call it taskDataManager?
Can we just call Objects.requireNonNull()?
Can we just call super.execute() so it doesn't get called unless the task is active?
This can be moved to the beginning of the method.
This can be moved to the readCompletedPart method.
This can be moved to a single method.
I'm not sure why we would want to use the ParserConfigurationException here.
I'm not sure why we should use the ParserConfigurationException here.
I'm not sure why we would want to use the ParserConfigurationException here
Can you work on this _if_ instead of _ else_? If null, it would be better to have _return Optional.empty();_
Can you work on the _collection_ instead of the above _? If this is the case, the value would be null.
Can you work on that _if_ instead of a Map?
Do we want to try to avoid scroll not using it?
Do we want to extract a variable for it? Like: public void scroll(boolean up) {...
Do we want to extract a variable for it?
should use int x = 0;
should be int y = 0;
should use int x;
No need for else
Test case is not covered by test
Test case is not covered by tests
This also doesn't work. The compiler doesn't auto-close the inner writer unless it's assigned to a variable.
This also doesn't work. The compiler doesn't auto-close a stream if it's assigned to a variable.
This also doesn't work. The compiler doesn't auto-close a stream if it's not a PrintStream.
Replace this by "new SolObjectEntityWrapper((Projectile) o).isMassless()".
Replace this by "new SolObjectEntityWrapper((Projectile) o).isMassless".
Replace this by "new SolObjectEntityWrapper((Projectile) o).isMassless()" :)
I think the static import of TransactionConfig is superfluous.
I think the static import of TransactionConfig is the better fit here.
I think the string contains can be %d as well.
Minor: you can use assertSame for the others.
You can use assertj here.
Minor: you can use assertSame for the parent resource to ensure it's the same.
So does this check need to be inside NameTokens.isEnglish? Is there any reason to have it private?
So does this check need to be inside NameTokens.isEnglish? Is there any reason to have this check?
So does this check need to be inside NameTokens.isEnglish(nameToken)?
path separator?
path separator? Will an empty directory work in Windows?
path separator
I would prefer to add defaultTarget attribute in the model, let it be default (for default)
I would prefer to add defaultTarget attribute in the [main](<LINK_0>
I would prefer to move this to the defaultTarget attribute in the model, let it be defaultTarget.
This is not needed.
This is not related to this PR
This is not needed. Remove it.
I think we should add a log statement here instead of just returning null
I would suggest logging the exception instead of returning null.
I would suggest logging the exception instead of returning null
You didn't execute this stmt.execute(tableDDLOptions);
You didn't execute this stmt.execute(tableDDLOptions)?
You didn't execute this test...
perhaps use StringUtils.isEmpty(userRolesCacheEnabledString)
is this correct? If so, remove it.
empty string
In this case you might want to move it into the menu menu menu.
In this case you might want to preserve the menu selection better?
In this case you might want to preserve the menu selection better
Nice!
Nice! Thanks for the fix!
Nice! (minor suggestion)
freeLock
freeLock()
freeLock();
As it stands, we don't need to know whether a connection is closed.
As it stands, there is no need to insert a ResultSet.
As it stands, there is no need to insert a connection after the statement.
no need, please put it in configuration file at /usr
no need, please put it in configuration file at 'Run'
please put it in configuration file at /usr
Any reason not to define the constants on the class: java private static final long 86400L =...;
Can the constants embedded in the class be reused here instead?
Any reason not to define the variable for the double?
why do we need it here?
why do we need this change?
why do we need it here? assuming the vm is about to be started unexpectedly?
this is wrong. You want to test that the DisksStores above is equals to 0. What you want is something like: if (hal.getDisksStores().length > 1) { assertNotNull(hal.getDisksStores[0].getName()); } assertNotNull(hal.getDisksStores()[0].getWrites());
this is wrong. You want to test that the DisksStores above is equals to 0. What you want is something like: if (hal.getDisksStores().length > 1) { assertNotNull(hal.getDisksStores[0].getName()); } assertNotNull(hal.getDisksStores[0].getWrites());
this is wrong. You want to test that the DisksStores above is equals to 0. What you want is something like: if (hal.getDisksStores().length > 1) { assertNotNull(hal.getDisksStores[0].getName()); } assertNotNull(hal.getDisksStores()[0].getWrites();
Can we have a test that the collections are not null?
Can we have a test that always does a duplicate or duplicate?
These duplicates the code above, it would be nice to have one method
we don't use braces around one line blocks
we don't use braces around both blocks
[minor] we are using braces around both blocks
Extract the building of ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make it a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
![MAJOR](<LINK_0> 'Severity: MAJOR') Method has 7 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
used callback style instead
used elsewhere too
used elsewhere
:+1:
You can simply call shouldBeFiltered() here and use the below method
:+1:.
this check should take precedence over the pageview check. That seems more natural for clients to understand, that this is always preview.
this check should take precedence over the pageview check. That seems more natural for clients to understand, that this is always an API call to a screenview, but that seems quite unlikely
this check should take precedence over the pageview check. That seems more natural for clients to understand, that this is always an API call to a method, so we should make it clear what is about.
I think you want to close the block builder when you're done with it.
I think you want to close the block builder when you're done with it
I think you want to close the block builder when the function is completed. In this case, the structure is the same.
Select target type to create
Avoid hardcoded strings.
Avoid using ld.getId()
Is it worth it to dispose realmIdentity here? Or is it because you just dispose them?
Is it worth it to dispose realmIdentity here? Or is it because you never dispose them?
Is it worth it to log something in case of error?
This and the corresponding overloaded get is not necessary. Will explain below.
This and the corresponding overloaded get is not necessary. Will explain below. Also, we are not able to hide at it.
This and the corresponding overloaded get will be called twice. Will explain below.
add a message to this exception.
add a message to this exception
add a message to the exception.
Do you want to throw the FedoraException here?
Do you want to throw the exception, instead of catching it?
Do you need the while loop here?
Here again I would not assert the result of the op, only that resilience strategy has been called.
Here again I would not assert on the result of the op, only on the resilience strategy being invoked.
Here it is going to depend on the resilience strategy... so hard to say. I would drop the operation result assertion
Params are not described.
1. why not just use entry.getName()? 2. Does this make sense for you?
Prefer getSingleFileReference().
I think it's the most important thing that you should check whether counterClockWise - or not, for example, you could just check that (geometry instanceof GeometryCollection) is always true.
I think it's the most important thing that you should check whether counterClockWise - or not, for example, you could just check that (geometry instanceof GeometryCollection) is the only supported geometry types.
I think it's the most important thing that you should check whether counterClockWise - or not, for example, you could just check that (geometry is instanceof GeometryCollection) here.
Can you see if thezos can be null?
I think it is probably better if you can do it in constructor and get rid of the code duplication.
I think it is probably better if you could pass an empty string instead of a String
in this case, why not just: template.getStoragePoolId().equals(datacenterId)?
I would replace this with: getModel().getAggregatedTemplate().getSelectedItem()
in this case, why not just: template.getStoragePoolId().equals(datacenterId)
These should be replaced by Strings.setDefault(PreferenceConstants.P_STANDARD, ""); store.setDefault(PreferenceConstants.P_REMARKS, "");
This should be replaced by Strings.setDefault(PreferenceConstants.P_STANDARD, ""); store.setDefault(PreferenceConstants.P_REMARKS, "");
These should be replaced by Strings.isNullOrEmpty()
I'm not sure the toString() format is correct. Something like this: String.format("=\"\s; ", '"');s);
I'm not sure the toString() format is correct. Something like this: String.format("%s; ", ", ", ", ", ", ", ")
This seems like a debug output that should be removed.
Is there a reason we are not using this method?
Is there a reason we are not using this?
Is there a reason we are not using this method here?
This will be better: artifact.getVersion()!= null? artifact.getScope() : unknownVersion;
This will be better: artifact.getVersion()!= null? artifact.getScope() : artifact.getBaseVersion();
This will be confusing. We should always return the version, not the internal toString. Could you please fix the functionality?
Please assign it to a variable to avoid repeated calls.
Please assign 1 to a variable to avoid repeated calls.
Please assign 1 to a constant
can be simplified to just org.apache.commons.lang3.StringUtils.isNotEmpty(exchangeName)
can be simplified to just org.apache.commons.collections.CollectionUtils.isNotEmpty(exchangeName)
can be simplified to just org.apache.commons.collections.CollectionUtils.isEmpty(exchangeName)
I don't see why we ignore the case - as this is the default behavior of the test
I don't see why we ignore the case - as this is an abstract class and not all the paths.
I don't see why we ignore the case - as this is an abstract class and not all the classes.
This line is redundant, the next line covers the case.
This line is not necessary.
This line is not needed.
Similar to the JDBC library, let's hide the entity column column names from the public API. EntityQueries.from(...) is a good example of external API.
Similar to the JDBC library, let's hide the entity column logic in the public API. EntityQueries.from(...) is a good example of external API.
Similar to the JDBC library, let's hide the entity column column column names from the public API. EntityQueries.from(...) is a good example of external API.
The old constructor is still there, why did this need to be changed?
Do we want to add a default constructor to DefaultTaskConfigurer for this use case (instead of passing null)?
The old constructor is still there, why did this need to be changed? Can this method be removed?
wrap this line
add a check if this can be null
wrap this line.
This is a good idea. We should be able to remove this stuff.
This is a good idea.
This is good.
Why do we need this? I'd prefer to default to false.
I'm not sure we need this.
Why do we need this?
Shouldn't this be in a finally block?
This will cause the test to fail. That is not what we want.
This will cause the test to fail. Should be asserted.
I would add a check that secondArgument.isStringLiteralExpr() is not null.
I would add a check that secondArgument.isObjectCreationExpr() is null
I would add a check that secondArgument.isStringLiteralExpr() is of type String
Usage of ternary operators here will make the code more reader friendly: throw new WebApplicationException(400); try { final SearchMissionsDTO searchMissions = new SearchMissionsDTO(); searchMissions.sortedSearch(); } catch (final Exception e) { throw new WebApplicationException(404); }
Usage of ternary operators here will make the code more reader friendly: throw new WebApplicationException(400);
Usage of exception and passing the original exception as a parameter
This is hard to understand. Why are you assigning the String value to a String?
This is hard to understand. Why are you assigning the String value to a constant?
This is hard to understand. Why are you assigning the String value to a variable here?
Can the nativ field be null? If there is no default case, please add a check
Can the nativ be null? If there is no default case, make it final.
Can the nativ field be null? If there is no default case, please add a null check
I think!status.isEmpty() is more fail safe.
I think!status.is().isEmpty() is more fail safe.
I think!status.is().isEmpty() is more fail safe. Or maybe use a guard clause.
I don't think this check is right, but why should we have a method that takes a boolean parameter? Is it right to call this method?
I don't think this check is right, but why should we have a method that takes a boolean parameter?
I don't think this check is right, but why is it a different method?
This blank line is unnecessary.
This variable name is a little confusing.
This variable name is a bit confused.
This doesn't seem to be part of the test.
This doesn't look like it was set before. If you are doing a prebase you can still create a project.
This doesn't look like it was set before.
Rethrow as a runtime exception
Re-close() should be a finally block
Re-close the inner method as well
this and the following lines are not needed since they are used in the benchmark code base
this and the following lines are not needed since they are used in the benchmark code.
this and the following lines are not needed since you have two use variables
I'm looking for an expert check on all these. The ones below are fine.
I'm looking for an expert check on all the. The ones below are fine.
I'm looking for an expert check on all these. The ones on all these  are fine.
What about the following: if (TaskType.FINISH_CREATE_VOLUME, 3000L) { }
What about the following: if (TaskType.FINISH_CREATE_VOLUME, spUUID, imageImgUUID) {... }
What about the following: if (TaskType.FINISH_CREATE_VOLUME, 3000l) { }
Nit: can be removed
can be removed?
Nit: can be removed?
When the onViewChanged() is called, the onViewChanged() call might not be necessary.
When the onViewChanged() is called, the onViewChanged() call shouldn't be necessary.
When the onViewChanged() is called, the onViewChanged() call shouldn't be necessary anymore.
Shall we rewrite this as: java if (sorting!= null) { Map<Path, HEvING > joinClauses = query.getValidSortingRules(tableCls.getAnnotation(FromTable.class).sql()).collect(Collectors.joining(" ")); return query.build(); }
Shall we rewrite this as: java if (sorting!= null) { Map<Path, HEvING > joinClauses = query.getValidSortingRules(tableCls.getAnnotation(FromTable.class).sql()).collect(Collectors.joining(" ")); }
Shall we rewrite this as: java if (sorting!= null) { Map<Path, Partitions> joinClause = query.getValidSortingRules(tableCls.getAnnotation(FromTable.class).sql()).collect(Collectors.joining(" ")); }
@adrielparedes this method could be private. No need to expose it?
@adrielparedes this method is not used at all but I think it's now that there is a kie project in the repository.
@adrielparedes this method could be extracted to another one with re-intentional duplication.
Typo. Should be cry
Typo? <LINK_0>
Typo. Should be c.
Can we please use Collections.empyList()
Do we want to use Collections.empyList()?
Do we really need this method? Why not simply use Collections.empyList()
Why do we need to log this?
Why do we need this method?
Why do we need to call printStackTrace?
state is started but not stopped. Nothing can stop it if lookupName is already present
state is started but not stopped. Nothing can stop it.
state is started but not stopped.
nit: You probably don't need to add this. here, since we are not using the getter outside of this.
nit: the equals should be on the previous line.
nit: You probably don't need to add this. here, since we're not using the getter outside of this.
Could probably take out this if; the null checks will take care of the case where these cases don't exist on Lollipop devices
Could probably take out this if; the null checks will take care of the case where these menu settings don't exist on Lollipop devices
Could probably take out this if; the null checks will take care of the case; the null checks will take care of the case; <LINK_0>
:bug: this is not reliable. I presume you are attempting to somehow detect the case that a user "did stuff" (meaning, created items) in Jenkins 1.x but somehow managed to avoid ever saving /configure-possible, if very unlikely. But this check will be false if the user created top-level _folders_ but no top-level _jobs_ (or subsequently moved all jobs into folders). getTopLevelItemNames would be more appropriate. Or more directly: java if (!Jenkins.getInstance().getItemMap().isEmpty()) { // some items configured (Note that using getAllItems() etc. is not only slightly slower, but vulnerable to inaccurate results in case the caller is running with non-ACL.SYSTEM authentication.)
:bug: this is not reliable. I presume you are attempting to somehow detect the case that a user "did stuff" (meaning, created items) in Jenkins 1.x but somehow managed to avoid ever saving /configure-possible, if very unlikely. But this check will be false if the user created top-level _folders_ but no top-level _jobs_ (or subsequently moved all jobs into folders). getTopLevelItemNames would be more appropriate. Or more directly: java if (!Jenkins.getInstance().getItemMap().isEmpty() ||!Jenkins.getInstance().getItemMap().isEmpty()) { // some items configured (Note that using getAllItems() etc. is not only slightly slower, but vulnerable to inaccurate results in case the caller is running with non-ACL.SYSTEM authentication.)
:bug: this is not reliable. I presume you are attempting to somehow detect the case that a user "did stuff" (meaning, created items) in Jenkins 2.x but somehow managed to avoid ever saving /configure-possible, if very unlikely. But this check will be false if the user created top-level _folders_ but no top-level _jobs_ (or subsequently moved all jobs into folders). getTopLevelItemNames would be more appropriate. Or more directly: java if (!Jenkins.getInstance().getItemMap().isEmpty()) { // some items configured (Note that using getAllItems() etc. is not only slightly slower, but vulnerable to inaccurate results in case the caller is running with non-ACL.SYSTEM authentication.)
I don't think you should be able to use the Status object as the condition is known by the infrastructure. You should be able to add the entry ID to the message, but you don't need to construct a new Status object
I'm not sure, but maybe we should have a custom exception message instead of 400? If the entry is not a workflow, the user should be deleted, e.g., "Unexpected entry type: XX".
I don't think you should be able to use the Status object as the condition is known by the infrastructure. You should be able to add the entry ID to the message, but you don't need to construct a new Status object.
This needs to be a log statement.
This needs to be a Log statement.
This needs to be a Log.
Maybe worth adding some log message here.
Maybe worth adding some logging here.
Maybe worth adding some logging here to inform the user that this failed?
Please use orElse(null) instead of orElse(null). It's easier to read.
Please use orElse(null) instead of orElse(null). If it's an error, just return false.
Please use orElse(null) instead of orElse(null). If it's an Optional, we can then return false.
Can we use to sleep here too?
Can we use a loop here?
3 seconds seems like a good test.
Ths should be in a miniAccumuloCluster() method.
Wondering if the test does not exist before deleteQuietly()?
Wondering if the test does not exist before deleteQuietly.
Why this change? It seems to be unrelated to this change.
Should this be logged as a warning? It looks like it will get logged twice
Should this be logged as a warning?
If you use lambda expression here, you won't have to create a new instance every time.
If you use lambda expression in here, you won't have to create a new instance every time.
If you use lambda expression in here, you won't have to create a new instance each time.
should this be 'getClass().getName()'?
should this be 'getClass().getSimpleName()'?
ClassDescriptors should be stored in ClassDescriptors in orderClasses.
This logic isn't required anymore, right? The check would be redundant if you change it.
This logic isn't required anymore, right? The check would be fine as well.
This logic isn't required anymore, right? The check would be redundant if you change the method above.
I would use a PersistableSerializer to register a class, similar to what Mappers are (but we may need to register the class in another PR)
I would use a PersistableSerializer to register a class, so that the registerClasses method would be easier to maintain.
I would use a PersistableSerializer to register a class, similar to what Mappers are (but we may need to look at
The line 108-110 are going to be a heavy processing. Could you use a cache mechanism on the jsonGenericRecordConverter?
The variable list is a bit misleading. Could you use jsonGenericRecordConverter.jsonSchema(jsonSchema) here?
The variable list is a bit misleading. Could you use jsonGenericRecordConverter?
we already have a 'else' statement here.
Potentially break context here.
Potentially break context here. a)
Why is it in the right place? Can't you just use date_first_launch and dateFirstLaunch and dateFirstLaunch?
Why is it in the right place? Can't you just use date_first_ launch and dateFirstLaunch, and then the second one?
Why is it in the right place? Can't you just use date_first_launch here?
invert this. java if (isSupportedCollection(target)) { return multiInstantiator.instantiate(target, parameters); } return conver....
invert this. java return multiInstantiator.instantiate(target, parameters);
invert this. otherwise it is difficult to understand the code.
Please change this to ICommand or moveArrowCommand = ((MoveArrowRequest) request).getArrowOrientation();
Please change this to use the new ICommand(EditArrowRequest, "MoveArrow", null);
Please change this to ICommand
Even better would probably to compare InputConfig with String.format()
Even better would probably to compare InputStyle and Text.separator with /somefile.
Even better would probably to compare InputStyle and see if it's still true?
I think this method should either: 1. start with if (r1.getInferredInsertSize() > maxInsertSize) or return (Math.abs(r1.getInferredInsertSize() > maxInsertSize) || (r2.getReferenceIndex().equals(r2.getReferenceIndex())) || r2.getAttribute("SA")!= null)) return false 2. public static boolean isChimeric(final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1 = (SAMRecord) r1.getInferredInsertSize(); return Math.abs(r1.getInferredInsertSize()) > maxInsertSize || r1.getAttribute("SA")!= null || r2.getAttribute("SA")!= null);
I think this method should either: 1. start with if (r1.getInferredInsertSize() > maxInsertSize) or return (Math.abs(r1.getInferredInsertSize() > maxInsertSize) || (r2.getReferenceIndex().equals(r2.getReferenceIndex())) || r2.getAttribute("SA")!= null)) return false 2. public static boolean isChimeric(final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1 = (SAMRecord) r1.getInferredInsertSize(); return Math.abs(r1.getInferredInsertSize() > maxInsertSize || r1.getAttribute("SA")!= null || r2.getAttribute("SA")!= null);
I think this method should either: 1. start with if (r1.getInferredInsertSize() > maxInsertSize) or return (Math.abs(r1.getInferredInsertSize() > maxInsertSize) || (r2.getReferenceIndex().equals(r2.getReferenceIndex())) || r2.getAttribute("SA")!= null)) return false 2. public static boolean isChimeric(final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1, final SAMRecord r1 = (SAMRecord) r1.getInferredInsertSize(); return Math.abs(r1.getInferredInsertSize() > maxInsertSize) || r1.getAttribute("SA")!= null || r2.getAttribute("SA")!= null);
Are you sure that updateApplicationKeyTypeMetaData is always called twice? Test case for all other methods as well?
Are you sure that updateApplicationKeyTypeMetaData is always called twice? Remove all places as well?
Are you sure that updateApplicationKeyTypeMetaData is always called twice? Test case for all other callback methods as well?
I think 'else if' is not needed here
I think 'else if' is better here?
I think 'else if' is not needed here.
It looks like this can be called concurrently. by multiple threads, each thread can create new threads. We should create the 2 threads for the same reason.
It looks like this can be called concurrently. by multiple threads, each thread can create new threads. We should create the 2 threads for each of them.
It looks like this can be called concurrently. by multiple threads, each may create new threads. We should create the 2 threads for the same goal.
It looks like this isn't an error. Wouldn't it be better to check that the descriptor types are valid?
It should be a switch statement
It should be a switch statement.
Is there any way to retrieve the VBox(description, label) instead of using it twice?
Is there any way to keep the VBox(description, label) constructor?
Is there any way to retrieve the VBox(description, label) instead of using it?
I think this could be replaced with java keyValue = keyValueResult.get().map(MetadataProperties::reconstructKeyFromType).collect(Collectors.toList());
I wonder if we should externalize this message into a constant.
I wonder if we should externalize the message into a constant.
What if devfile is null or devfile is not set? Would it be better to throw IllegalArgumentException?
What if devfile is null or devfile is not set? Would it be better to throw IllegalStateException?
What if devfile is null or devfile is not set? I'm not sure that we have a method for this. Will it be used?
You can use the version bytes in the method
You can use the version bytes in the method body
You can use the version field here
this branch can be simplified as: if (rexUtil.isIdentity(query.rowType, targetProjs)) {... } else {... }
this branch can be simplified as: java if (rexUtil.isIdentity(query.rowType, targetProjs)) { return call.result(null); } else {... }
this branch can be simplified as: java if (rexUtil.isIdentity(sourceInput, targetProjs)) { return call.result(target); } else {... }
@Serranya same here. See above.
@Serranya same here as above. See above.
@Serranya same here as above.
1. You can remove the catch clause at the end of this if statement
would you mind adding a log.info(..) to this?
should be removed
This should only be deleted.
This should be deleted.
I'd rather throw exception, either via assertions or at least log.
ColorItem is a boolean. Better to use equals here.
ColorItem is a boolean, so we can use that.
ColorItem is a singleton.
Why do you need this line? I don't think there should be a line break in this catch.
This line is duplicated in all tests. I think it would be better to move it to a separate method
Why do you need this line? I don't think this information is being propagated.
Why don't we use sinkMap here?
Why don't we use Objects.nonNull?
I think this is a standard way to do the null check.
log
log on error level
log on debug level
nitpick: if you have to go through all the segment model things, it would be interesting to see here that there is no difference if this doesn't fit.
nitpick: if you extract this to a local var then you could then use it in the test method.
nitpick: if you have to go through all the segment model things, it would be interesting to see here that there is no difference if this doesn't get the proper results.
this method should be private
this method should be private.
this method is private. please access the DAO interface.
I think these two variables are not used?
You need to start the setting of the params in order to make it easier to read.
You need to start the setting of the params in order to make it work.
I think it may be useful to keep this log.
I think it may be useful to add a logger.error statement here.
I think it may be useful to add a logger.error here as well.
Maybe we can reuse the words variable instead of calling " ", transform" again
Maybe we can reuse the words variable instead of calling toLowerCase() here.
Maybe we can reuse the words variable instead of calling " ", transform" again?
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I think the reduced code duplication would be an overall win. } catch (IOException e) { handlePackError(e, p); }
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I think the reduced code duplication would be an overall win. } catch (IOException e) { handlePackError(e, p); } };
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I think the reduced code duplication would be an overall win.
I'm not sure if this check is needed. If the platform spec is not there, it could fail with an exception (if it is a valid url) and then throw an exception with a clear message.
I'm not sure if this check is needed. If the platform spec is not configured, this code will fail with an NPE.
I'm not sure if this check is needed. If the platform spec is not configured, this code will fail with an NPE. Is that what you want?
This API is part of the public API. what about fields.get(i) instead of fFields.get(i).getName()?
This API is part of the public API. what about fields.get(i)?
This API is part of the public api, which is stable, this should be put in a class field, to avoid re-computing the proper object field.
Style: We use braces even for one-liners.
Style: we use braces even for one-liners.
Formatting is off here
Shall we use auto-generated names here? <LINK_0>
Shall we use a StringBuilder here? <LINK_0>
Shall we use a StringBuilder here? <LINK_0> also <LINK_1>
Please change to: Assert.assertEquals("invalidPasswordMinLengthMessage", policyManager.validate("jdoe", "123").getMessage());
Please change to: Assert.assertEquals("invalidPasswordMinLengthMessage", policyManager.validate("jdoe", "999").getMessage());
Please use called the @Test(expected = IllegalStateException.class) instead of this.
I still think this back-to-left is better than 'if' statement.
I still think this back and forth bellow are better...
I still think this back-to-left is better than 'if'
I think this still might need to be set. In org.jboss.as.server.ServerEnvironment its still referenced, and if present used to set a deprecated variable. I haven't tested that though, thoughts?
I think this still might need to be set. In org.jboss.as.ServerEnvironment its still referenced, and if present used to set a deprecated variable. I haven't tested that though, thoughts?
I think this still might need to be set. In org.jboss.as.server.ServerEnvironment its still referenced, and if present used to set a deprecated variable.
Don't use braces.
unused
assertNotThrownBy
I think it's slightly better to split this test into multiple test cases: - OptingOrder.unifyWindingOrder(int) getExteriorRing() The test does not fail anyway. - OptingOrder.of((float) result).getExteriorRing()),...
I think it's slightly better to split this test into multiple test cases: - OptingOrder.unifyWindingOrder(int) getExteriorRing() The test does not fail anyway. - OptingOrder.unifyWindingOrder(int) already has a TOOK instance.
I think it's slightly better to split this test into multiple test cases: - OptingOrder.unifyWindingOrder(int) getExteriorRing() The test does not fail anyway. - OptingOrder.unifyWindingOrder(int) already has a TOO_MANY_TO_SPID - assertTrue(result instanceof InternalError).
This is hard to read. I'd suggest using the getter for the response (as in this case) and returning the old Message directly.
This is hard to read. I'd suggest using the getter for the response (as in this case) and returning the old value (which will be simpler and more efficient.
This is hard to read. I'd suggest using the getter for the response (which will be consistent) and based on the index of the current logic.
Same here - demotedContent.
Same remark as with the other argument regarding exception handling.
Same here - demotedContent
Can't you use the following instead? LOG.error(String.format("Noovirt-engine VM '%s'", vmName), ',');
Can't you use the following instead? LOG.error(String.format("Invalid custom properties: %s", vmName), e);
Can you please remove the "other" checks?
Do we really need this?
I think you can use this method on line 62 instead of line 62
I think you can use this method on line 62 and 68.
Why are you catching the exception in the test method?
Why are you catching this exception only for debugging?
Why are you catching the exception in the test?
So you are overwriting the value in the map, why not just initialize it to null? Or is there a reason for a value in the constructor?
So you are overwriting the value in the map, why not just initialize it to null? Or is there a reason for a value to overwrite that?
So you are overwriting the value in the map, why not just initialize it to null? Or is there a reason for a value to be immutable?
This should probably be moved to the pane.
This should probably be moved to the pane's setStyle() method.
This should probably be moved to the pane.setStyle() line above it.
Please add brackets to this line so it's clear what's happening
Please add brackets to this line.
Please add brackets to this particular line.
I'd mention this logic to be moved to library level.
I'd mention this logic to be moved to library level, because it would be useful for users to support workspace evolution.
I'd mention this.
Can't this be moved to the _protected_ method?
nit: Can we bail out this out?
nit: Add these parameters to the _input_ class.
It would be hard to troubleshoot the error especially when it throws in production env, when we just show a simple string "Could not read float.". I suggest to include the 'ex' itself and wrap it with ParquetDecodingException so that the exception can have more information. It is also recommended to print out more information of the data stream itself so that it is clear what is happening.
It would be hard to troubleshoot the error especially when it throws in production env, when we just show a simple string "Could not read float."
It would be confusing to include the 'ex' itself and provide a more descriptive message. 'Could not read float."
Remove findAny(). It doesn't look like this.
Remove findAny(). It doesn't look like this is the only usage of findAny().
Remove findAny(). It doesn't look like this is the only call that is required.
nit: use Assert.assertEquals() instead
nit: use Assert.assertEquals() like you have done in a few places
nit: use Assert.assertEquals() like you did in a few other places
nit: maybe make this method private?
nit: maybe we should add a log statement for this method
nit: maybe make this private.
suggestion if (!existingWorkflow.isPresent()) { workflow.setDescriptorType("cwl"); } else { updateEntryMetadata(workflow, AbstractEntryClient.Type.STUB); }
Personal think this could be as follows: if (!existingWorkflow.isPresent()) { workflow.setDescriptorType("cwl"); } else { updateEntryMetadata(workflow, AbstractEntryClient.Type.STUB); }
Personal think this could be as follows: if (!existingWorkflow.isPresent()) { workflow.setDescriptorType("cwl"); } else { updateEntryMetadata(workflow, AbstractEntryClient.Type.STUB()); }
Leftover the FIXME?
Leftover debug point?
Leftover from the start of the regex?
There is a file called "pom.xml" that contains the name of the file. We can replace it with "/pom.xml"
There is a file called "pom.xml" that contains the name of the file. We can replace it with something like "pom.xml"
There is a file called "pom.xml" as constants.
You need to protect against wsOutbound.getMaxTextMessageBufferSize
Would be great to have the buffer be created in a finally block.
Would be great to have the buffer be created in a finally block
nit: where is this used?
nit: we could use TableReference.create instead of TableReference.
nit: we could use TableReference.create instead of TableReference
I would try to re-throw the exception instead of ignoring it
I would try to re-throw the Exception instead of ignoring it
I would try to re-throw the exception instead of ignoring it.
resourceAccess is not used. If this is needed, it should be part of the save part.
resourceAccess is not used. If this is needed it would be good to use the constant
resourceAccess is not used. If this is needed, it should be part of the save clause.
Same as above, I'll check as you did in another pull request.
Same as above: I'll check whether the loading logic is working well at all.
Same here and a few lines down.
I think this should be null instead of "true".equalsIgnoreCase(options.get(NO_COLLECTION_OPT)).
I think this should be null instead of "true".equalsIgnoreCase(options.get(NO_COLLECTION_OPT))
You could use boolean value = locale.trim(); if (value!= null) { locale = h; }...
Should this be removed?
Should be removed.
debug statement?
We're not getting the timestamp for the provider, not the service, right? If so, I would move the logging to the service method
We're not getting the timestamp from the DB, I guess the "create_time timestamp NOT NULL DEFAULT_TIMESTAMP" should be removed.
That's not what I meant.
Is there a reason why this number of changes shouldn't be sent through the context streams?
Is there a reason why this number of changes shouldn't be sent through the context streams (e.g. new RuntimeException(e))?
Is there a reason why this number of changes shouldn't be sent through the context streams (e.g. new RuntimeException(e))?
Could you check if the metricRegistry.histogram("card-executor.delay") is null?
Could you check if it's null, just in case
Could you check if it's null, just in case?
isn't this redundant?
isn't this the same as above for external driver??
isn't this the same as above for schema param?
nit: remove "s.stream().flatMap(Set::stream)"
nit: s -> s.stream()
nit: s ->...
please add a null check for playerServerCache
I think we need to be logging the error.
I think we need to be logging the error here.
Can't we make the method-level as private?
What would happen if we're using a single vector here?
What would happen if we're using a single vector pattern?
I think this is good. We need to be careful about whether this can be null. It is not a case where the caller has set the error code.
I think this is good. We need to be careful about whether this can be null. It is not a case where the caller has set the error message.
I think this is good. We need to be careful about whether this can be null. It is not a case where the caller has set up a response.
Is it a good idea to check here that PeriodicReplicationService.COMMAND_START_REPLICATION is > -1?
Is it a good idea to check here that PeriodicReplicationService.COMMAND_START_REPLICATION is > 0?
Is it a good idea to check here that PeriodicReplicationService.COMMAND_START_REPLICATION is > -1? Although you could even simplify the code a bit, but maybe it could be a default value.
This should be part of the doSearchAutocomplete method.
This should be moved into the doSearchAutocomplete method.
This should be imported.
Is there a reason for this change?
Why do we need a method for this?
Is there a reason for setting the order of columns here?
I'd also check sendContext.message.getRepliedTo()!= null.
Lamda?
I'd also check the ack type and add a log message.
Why not using getStorageServerConnectionDao()?
Why not using runVdsCommand() here?
Why not just use runVdsCommand()?
I am not sure we need this. But right now we have the susceptible to parse the list of threads. That is a regex parsing problem.
I am not sure we need to give the user a name here. This is not what we are trying to do.
I am not sure we need this. But right now we have the susceptible to parse simpler.
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final.
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final..
As a small improvement you might want to use!memberClass.getPackage() here.
I would prefer public void updateExecCredsIfRequired() { this.needToRefreshCreds = false; }
I would prefer public void updateExecCredsIfRequired() { this.needToRefreshCreds = false; } Or first step would be needed.
I would first set the flag and then update the first credentials ignored.
This should just be an internal error
This should just be an internal error list as a RetryException
This should just be an internal error list
Shouldn't the other items be added as contains(item, dataProvider))?
Shouldn't the other items be added as contains()?
Shouldn't the other items be added as contains(item, dataProvider) calls the contains method?
This could be made private
This could probably be made private
This is a bad call. It should be made defensive.
we need a better term than "group" here - perhaps poset-indifferent?
we need a better term than "group" here - perhaps poset-in talks"?
Change this to getNonMonotoneMailboxes().remove()
Collection
You should add a 'add(0, null)' block to the ArrayList.
You should add a 'add(0, null)' method to the ArrayList
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
Consider adding an additional layer of abstraction for this block. This has very similar lines as I suggested in #140
Consider adding an additional layer of abstraction for this block. This has very similar code to the other two methods.
consider adding a log on failure
need to catch exception also here
use getVm()
Can you replace the criteria.add(Restrictions.eq("patient.voided", true)); with one log entry?
Can't you combine the criteria.add(Restrictions.eq("patient.voided", true)); and remove the above two lines?
Can't you just add the patient name as the identifier?
This could be extracted to a method, so it's more readable
This could be extracted to a method, so it's more readable.
This could be extracted to a method called getCheckPeriodMillis
s/containerProcessManagerFactory/clusterResourceManager/
s/containerProcessManagerFactory/containerProcessManagerMetrics
s/Container Allocator/Monitoring/
This log statement is wrapped by a s_logger.isDebugEnabled check, but logged at INFO. Should it be logged at DEBUG or should the warn log level be removed?
This log statement is wrapped by a s_logger.isDebugEnabled check, but logged at INFO. Should it be logged at DEBUG or should the s_logger level be removed?
This log statement is wrapped by a s_logger.isDebugEnabled check, but logged at INFO. I think it could be removed.
Exception#printStackTrace goes to stderr by default.
printStackTrace() output to stdout and stderr by default.
Exception#printStackTrace goes to stderr by default..
How do we ensure that the workflow is in progress at the time of deletion?
How do you ensure that the workflow is in progress at the time of deletion?
How do we ensure that the workflow is in progress at the time of deletion? For example, will this happen?
Please check if this is false as well
Please check if not empty
Please move this to final
This Link can be instantiated in a try-catch block.
IMO, you can do this using a try-catch, returning false.
IMO, you can do this using a try-catch with the response.
are you sure you need credentials temp variable?
should we change credentials to username and password?
are you sure credentials is always a string?
why do we check for both lastEntry and lastEntry? It should be either one, and not both.
why do we check for both lastEntry and lastEntry? It should be either one, right?
why do we check for both lastEntry and lastEntry? It should be either one, or another.
Is this meant to be a 'zk session state'?
Is it a case that user pass in a null pointer exception?
Is that right?
assertNotEquals?
assert assertSuccess case?
assert assertSuccess case.
The method will throw EntityAlreadyExistsException if the added exception is not thrown. The check can be changed in the method.
The method will throw EntityAlreadyExistsException if the added exception is not thrown. The check can be changed.
The method will throw EntityAlreadyExistsException if the added exception is not thrown. The check is missing.
I think this can be simplified by adding this into the try-catch block
I think this can be simplified into just this line.
I think this can be simplified by just calling loadTask here.
This should be more concise and easier to read.
This should be more concise and concise.
This should be immutable
some static imports for this and others are very similar
some static imports for this and others are very long if it's a failure
I'd rather see this test as a static method and write some static final instance as well.
I think this should be: java log.debug("Loading Table definitions from {}", schemaName, table.getTableName(), table);
I think this should be: java log.debug("Loading Table definitions from %s.%s", schemaName, table.getTableName());
I would add a message to the exception.
Can you make this a constant as it is used 3 times?
Can you make this a constant as it is used twice?
Can you make this a constant and put it there?
Should not be in the empty line of this method. suggestion connector.useGradleVersion(((RemoteGradleDistribution)this.gradleDistribution).getUrl());
Should not be in the empty line of this method. suggestion connector.useGradleVersion(((RemoteGradleDistribution)this.gradleDistribution).getVersion())
Should not be in the empty line?
I would prefer to pull this out into a constant. Also, is there a reason to use "hadoop-jwt" as it's more likely to use the word peer?
I would prefer to pull this out into a constant. Also, is there a way to read it?
I would prefer to pull this out into a constant. Also, is there a reason to use "hadoop-jwt" as it's sound consistent with the language?
This needs to be public.
This needs to be AmqpHeaders.class.
This logic has nothing to do with the eventHubProperties...
can be simplified as: if (max > 0 && methodStatus.active.incrementAndGet() <= max) { appStatus.active.decrementAndGet(); return false; }
can be simplified as: if (max > 0 && methodStatus.active.decrementAndGet() <= max) { appStatus.active.decrementAndGet(); return false; }
can be simplified as: if (max > 0 && methodStatus.active.incrementAndGet() > max) { return false; } what do you think?
equals()?
equals() is a short code, it probably makes sense to extract this into a method for example.
equals() is a bit clearer
@vilchik-elena It would be great if you can have tests for VERSION_5 and VERSION_4.
@vilchik-elena It would be great if you can have tests for VERSION_5 and TESTABLE_ANNOTATION_NAME
@vilchik-elena It would be great if you can have tests for VERSION_5 and TESTABLE_ANNOTATION_NAME for those two cases, instead of 1.
I think we should use MAJOR_TIMEOUT here instead of the default charset.
I think we should use MAJOR_TIMEOUT here instead of hardcoding the value.
I think we should use MAJOR_TIMEOUT here instead of hardcoding this, because the implementation of this method needs to change.
Use try-with-resources?
This should be closed in a finally block.
Use try-with-resources.
Missing final
Missing variable name?
Missing method name?
please use 'getStorageDomainDao()' instead of DbFacade.getInstance().getVdsSpmIdMapDao()'
please use 'getStorageDomainDao()' instead of DbFacade.getInstance().getVdsSpmIdMapDao()'.
please add a "protected" modifier to your patch..
Is path guaranteed not to be null?
Shouldn't content size be 0?
Shouldn't content length of 0 be allowed?
What is the purpose of this change?
Let's not register the failure to the transaction internal block as it is used for the ongoing transaction to start a transaction.
Let's not register stats in transaction code.
does this need to be it?
does this need to be at the end?
doesn't this have to be it?
Please remove ()
Please move to static variable
Please remove ():+1:
This should be UnityAds.load()
This if statement is needed, when the publisher doesn't set extras with a unique ID.
This if statement is needed since you are not using the banner size.
I am wondering if we shouldn't throw IOException or RuntimeException, since all other methods in the same class are not supported by this API.
I am wondering if we shouldn't throw IOException or RuntimeException, since all other methods in the same class are not supported by this method.
I am wondering if we shouldn't throw IOException or RuntimeException, since all other methods in the same class are interrupted.
do we need this synchronized?
do we need this synchronized block?
do we need this lock?
nit: newline
nit: newline before closing } lineMap variable.
nit: newline between methods?
Can you please add a TODO to link this to the 5 first line of code?
Can you please add a method named "networkaddress" and a parameter to the MigrationsBundle?
Can you please add a method named "networkaddress.cache.ttl" and a named variable?
Method should probably be protected, given writing this for sub-classing.
Not sure if this is really necessary, or is there a reason to just ignore the number, given this is likely to be an infinite loop? I worry about this aesthetics, but maybe it's likely to be more than one or two, to choose something to read, or is there another way to check? Or is there another way to check? I can see that you throw a lightblueException, but not sure if this is really a big deal...
Not sure if this is really necessary, or is there a reason to just ignore the number, given this is likely to be an infinite loop? I worry about this aesthetics, but maybe it's likely to be more than one or two, to choose something to read, or is there another way to check? Or is there another way to check? I can see that you throw a lightblueException, but not sure if this is really an infinite loop...
You can have a test that throws the exception.
You can have a test that test the number of tokens.
The following lines can be replaced with a method that checks the strings.
can't we use pushMessageInformation.getServedVariants() here?
can't we move this line to areAllBatchesLoaded?
can't we move this line to areAllBatchesLoaded?
The methods getValue() and getValue() are not thread-safe. If two threads call fetchTree() concurrently, you might get two ids for the same aspect. You could use a synchronized block around the two lines, synchronization on one of the maps (they are final).
The methods getValue() and getValue() are not thread-safe. If two threads call fetchTree() concurrently, you may get two ids for the same aspect. You could use a synchronized block around the two lines, synchronization on one of the maps (they are final).
The methods getValue() and getValue() are not thread-safe. If two threads call fetchTree() concurrently, you might get two ids for the same aspect. You could use a synchronized block around the two methods, synchronization on one of the maps (they are final).
I don't think we should do this at all. If it's recommending to throw an exception, so you can leave it as is.
I don't think we should do this at all. If it's recommending to throw an exception, so you can log what happens if no app call is made.
I don't think we should do this at all. If it's recommending to throw an exception, so you can log what happens if no app call is made to create a particular object
suggestion cacheManager::getCacheManagerConfiguration);
negotiatef I think it doesn't matter
negotiated I think it doesn't matter
shouldn't this be changed to call the buildBlobIdAndAssert below?
shouldn't this be changed to call buildBlobIdAndAssert in the first place?
can use call this buildBlobIdAndAssert
It's good practice to add a new RuntimeException(e) instead of suppressing it.
It's redundant and using.equals()
Nice catch
The name shoudl be FACILITYADMIN.
The name shoudl be FACILITYADMIN
Add problematic host to the exception and also add the name of the host
I think we should be catching RuntimeException here. An IOException thrown from this method will be logged or converted to RuntimeException.
I think we should be catching RuntimeException here. An exception only occurs if we construct the commit.
I think we should be catching RuntimeException here. An IOException thrown from this method will be logged or logged which would be unexpected.
if we throw the exception, better to let the exception propagate.
if we throw the exception, it should be handled by the caller of the method.
Should we throw the exception instead of just printing?
Single pass is needed here.
Single pass is needed here right?
Single pass is needed here
this doesn't actually throw an exception?
chain this with the other mappers?
this doesn't actually throw?
I guess you should return directly after the logging? And please log the error if the task fails.
I guess you should return directly after the logging? And please log the message.
Missing return after the logging? And please log the message.
![CRITICAL](<LINK_0> The Cyclomatic Complexity of this method "process" is 14 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "length" 3 times. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Define a constant instead of duplicating this literal "true" 3 times. [![rule](<LINK_1>](<LINK_2>
parquet -> http
Why are we catching generic Exceptions?
parquet -> http?
Can call editPart.refresh() instead of refreshBounds?
Can call editPart.refresh() instead?
Can't we move this to a determine refreshBounds method?
This is also suspicious, I guess we shouldn't check it now.
This is also suspicious, I guess we shouldn't need it now.
This is also suspicious, I guess we shouldn't check if discoveryConfig is null at this point.
How about doing the following instead? if (!isCoordinator(injector)) { return injector.getInstance(defaultClass); } return null;
How about doing the following instead? if (!isCoordinator(injector)) { return injector.getInstance(defaultClass); } else if (isCoordinator(injector)) { return defaultClass; } return null;
How about doing the following instead? if (!isCoordinator(injector)) { return injector.getInstance(defaultClass); } else if ( isCoordinator(injector)) { return defaultClass; } return null;
after a second look, I think we should do this only when getVm()==null (in the import from glance flow), otherwise when user will try to create a template from rest-api without specify custom-compatility version we'll use the incorrect version. bottom line, should be done this way only if getVm()==null
after a second look, I think we should do this only when getVm()==null (in the import from glance flow), otherwise when user will try to create a template from rest-api without specify custom-compatility version we'll use the incorrect version. bottom line, should be done this way only when getVm()==null
after a second look, I think we should do this only when getVm()==null (in the import from glance flow), otherwise when user will try to create a template from rest-api without specify custom-compatility version we'll use the incorrect version. bottom line, should be removed.
If you move this to a finally block in case of successful successful execution, the file may not be deleted.
If you move this to a finally block in case of successful write operation, wouldn't it make sense to let user know about this case?
If you move this to a finally block in case of successful successful execution, the file may not be deleted. Will try to close it on finally block
rename to "result"
rename to "power"
rename all variables to names
this check is redundant here.
this check is unnecessary here.
This is one of the reasons for this change: If for example, a handler of the bridge handler will only be set to OFFLINE, which is not correct.
just proposal: return currJMV.isLeader() && LIVENESS_DEBOUNCE_TIME_SEC * 1000
just proposal: return currJMV.isLeader() && LIVENESS_DEBOUNCE_TIME_SEC * 1000)
I think it'd be better to have this as info, no?
This may not actually solve the problem because if the original exception is thrown after columnWriters.forEach(ColumnWriter::close); in bufferStripeData and before this line, then during rollback, we will still try to close column writers before resetting them. By reading the code, the following part could potentially be the place in flushStripe throwing the error causing column writers to be closed. java // write all data orcDataSink.write(outputData); As a first step, could you write a unit test to verify the stacktrace can be reproduced if the caller calls orcWriter.write(page) followed by orcWriter.close()? It doesn't have to be the full stackstrace matching. To make sure we can get into closing the column writers twice would be good enough. OrcDataSink is an interface that can be mocked. In terms of the actual solution, I may need to think about it. But feel free to propose a good one.
This may not actually solve the problem because if the original exception is thrown after columnWriters.forEach(ColumnWriter::reset); in bufferStripeData and before this line, then during rollback, we will still try to close column writers before resetting them. By reading the code, the following part could potentially be the place in flushStripe throwing the error causing column writers to be closed. java // write all data orcDataSink.write(outputData); As a first step, could you write a unit test to verify the stacktrace can be reproduced if the caller calls orcWriter.write(page) followed by orcWriter.close()? It doesn't have to be the full stackstrace matching. To make sure we can get into closing the column writers twice would be good enough. OrcDataSink is an interface that can be mocked. In terms of the actual solution, I may need to think about it. But feel free to propose a good one.
This may not actually solve the problem because if the original exception is thrown after columnWriters.forEach(ColumnWriter::close); in bufferStripeData and before this line, then during rollback, we will still try to close column writers before resetting them. By reading the code, the following part could potentially be the place in flushStripe throwing the error causing column writers to be closed. java // write all data orcDataSink.write(outputData); As a first step, could you write a unit test to verify the stacktrace can be reproduced if the caller calls orcWriter.write(page) followed by orcWriter.close()? It doesn't have to be the full stackstrace matching. To make sure we can get into closing the column writers twice would be good enough. OrcDataSink is an interface that will be mocked. In terms of the actual solution, I may need to think about it. But feel free to propose a good one.
Let's move this to the block, since it will be closed in finally block anyway.
Let's move this to the constructor, since it will be closed in finally block anyway.
Let's move this to be before try-catch.
move this to a method in MetaDataUpdateImpl.
move this to a method in MetaDataUpdateFactory
move this to a method
Same as above, indentation seems off here.
If it is not possible to remove the questions themselves, right?
If it is not possible to remove the questions.
Why is this public and not private?
Why is this necessary and can be removed?
Why is this call necessary?
This is old code and the other tests use this function.
This is old code and the other tests.
This is old code that can be replaced by creating another one.
Please get the instance name from bigtableInstanceName.toGcbInstanceName(), if it exists.
It is not necessary to get the instance name from bigtableInstanceName.toGcbInstanceName(), if it exists.
It is not necessary to create a new bigtableInstanceName.toGcbInstanceName(), if it exists.
For performance reasons, use only one call.
So why did you change that?
So why did you change that? I am not sure if it is a wise thing...
nit: I was wondering if it would be easier to create a helper function for this logic: List<Type> argumentValues = tryHandleLike(node, argumentValues, argumentTypes); List<Type> argumentValues = new ArrayList<>(); for (int i = 0; i < argumentValues.size(); i++) { Object value = argumentValues.get(i); if (value == null || function.getArgumentProperty(i.getNullConvention())) { return result; } }
nit: I was wondering if it would be easier to create a helper function for this logic: List<Type> argumentValues = tryHandleLike(node, argumentValues, argumentTypes); List<Type> argumentValues = new ArrayList<>(); for (int i = 0; i < argumentValues.size(); i++) { Object value = argumentValues.get(i); if (value == null || function.getArgumentProperty(i).isHandled()) { return result.getValue(); } }
why are we looping twice?
Wondering if we should use the Util class to check if the plugin is in the classpath or not. Sometimes we have the Util class on the classpath. If we do not have a dependency on apache-commons, then we should just silently ignore.
Wondering if we should use the Util class to check if the plugin is in the classpath or not. Sometimes we have the Util class on the classpath. If we do not have a dependency on apache-commons, then we should just silently ignore the Exception.
Wondering if we should use the Util class to check if the plugin is in the classpath or not. Sometimes we have the Util class on the classpath. If we do not have a dependency on apache-commons, we should just silently ignore the Exception.
If you want to use a lambda expression, you can use observable.doOnNext() instead of a new method.
If you want to use observable, you need to update the logNext() to log the actual result.
If you want to use a lambda, you can use lambdas and log a proper string
Same note about missing curly braces and relying on a a default-constructed ReferenceSource applies here as well.
Same logic as above. Can it be extracted and reused?
Same note above about missing curly braces and relying on a a return statement.
Please add a check that the correct URL is returned and make sure all the parameters are called using the queryMap
Please add a check that the params are passed and make sure all parameters are called with the correct query string.
Please add a check that the params are passed and make sure all the params are called using the queryMap
Leftover debug statement?
Data should be created in a try with resource.
Data should be created on L163
You have this exact same logic a few lines above. I don't think it's a good idea to update it. I feel like it would be a separate util method with a different name for the tenant
You have this exact same logic a few lines above. I don't think it's a good idea to update it.
You have this exact same logic a few lines above. I don't think it's necessary to update the google-android library.
Nice catch!
Nice catch! Thank you for the fix!
Nice catch! Thank you!
style-nit: no braces here
style-nit: remove empty line
style nit: no braces here
Surprised that the admin has a form of "INSTRUCTOR_COURSE_DETAILS,". Any specific reason to use it?
Surprised that the admin has a form of "INSTRUCTOR_COURSE_DETAILS,". Any specific reason for that?
Surprised that the admin has a form of "INSTRUCTOR_COURSE_DETAILS", which is not used anymore. Could you please change it to use the other way? Thanks!
Don't forget to remove system.out.println or log it.
Do not stray system out please
Do not stray system out, or string concatenation
This is not the same as the previous two, can we please use ternary statements as much as possible?
This is not the same as previous one, can we please use while loop?
This is not the same as the previous two, can we please use one?
Activator.logError()
catch clause unnecessary?
catch
I prefer Options.builder().putAll(options).put(SetMemberSearchRequestEvaluator.OptionKey.AFTER, searchAfter()).build();
I prefer Options.builder().putAll(options()).put(SetMemberSearchRequestEvaluator.OptionKey.AFTER, searchAfter()).build();
I prefer Options.builder().putAll(options())
Do we want to remove the try/catch block here?
Do we want to keep this particular try/catch block for the tests?
Do we want to keep this particular try/catch block for the test?
For sake of consistency and readability of trace call, try to use trace instead of division here
For sake of consistency and readability of trace call, try to use trace instead of division
For sake of consistency and readability of trace call, try to use trace instead of division.
typo in method name
typo in log message
typo
Please use more specific exceptions here and distinguish between MalformedURLException and InvalidCredentialsException.
Should we use socket. User may be able to connect to signups?
Please use more specific exceptions here and distinguish between MalformedURLException and UnknownHostException.
monitor submonitor stuff.
monitor submonitor stuff. mods can access so they cannot be grouped.
monitor submonitor stuff. They cannot be null.
You should also assert that the ACL status is CUSTOM
This test should also verify that the ACL is not null.
This test should also verify that the ACL is not failed.
I think we should move the for loop into the unregister method
I think we should move the for loop into the ObservationProcessor.
I think we should move the for loop into the first one.
space between ) and {
space between } and {
space between field declaration and {
Why is that moved down?
What's the purpose of the 100_000_000?
What's the purpose of these 100_000_000?
The Bundle.contains() methods can be made into order.
The Bundle.contains() methods can be made into just two similar methods.
The Bundle.contains() methods can be made into just two branches.
This return should be moved to the new method so that the content of the method is handled in a single place.
This return should be moved to the new method so that the content of the method is correct in a way that for the category, not to be returned.
This return should be moved to the new method so that the content of the method is correct in a way that for the category, not from the receiving end.
I think this should be outside of the try/catch scope
you don't need this here
I think this should be outside of the if
I think you mean _superCategoryButtons.addAll(scButton.isSelected());
I think you mean _superCategoryButtons here.
I think you mean _superCategoryButtons.
testStateIsCleared() would be more interesting than testStateIsCleared(), because there are no regressions in this test.
testStateIsCleared() would be more interesting than testStateIsCleared(), because there are no regressions between this test and the previous state.
testStateIsCleared() would be more interesting than testStateIsCleared(), because there are no regressions between this test and the previous version.
what's the point of this?
what's the benefit of using this instead of a lambda?
what's wrong with this block?
you can move this to DomesticException class
you can move this above the call to getGetFields().wrap()
static import
you can simply return here.
you can directly return here.
you can directly return the loaded value
Why on earth do you use a LinkedList for this?
Why on earth do you use a double for this?
Why on earth do you use an array of double type?
@chaviw just removing this line break.
@chaviw just removing this line after the if statement
@chaviw just removing this line after the if statement.
:bug: this is not a valid URL.
:bug: this is not a valid URL. I think the relative URL should be "path:<key>".
:bug: this is not a valid URL. I think the relative URL should be "//ob-strip-project/" or "<token>".
Not to be a little female dog, but generally good style to include the else in the end of the method: if (Predicate!= null) { return Arrays.binarySearch(floatArray, input) >= 0; } else { return false; }
Not to be a little female dog, but generally good style to include the else in the for loop.
Not to be a little female dog, but generally good style to include the else in the same line.
I don't think this is really necessary. If other callers already have the directory, closeFailed won't be called.
I don't think this is really needed. If other callers already have the directory,.close() should fail.
I don't think this is really necessary. If other callers already have the directory, closeFailed won't be called, does that work?
Shoundn't this already happen inside
Extract it to a method?
Extract it to a method as mentioned above
What if memberPartitions.isEmpty()?
What if memberPartitions.length is!= -1?
What if memberPartitions.length is!= 1?
suggestion if (resultValue.isSatisfied()) { expectedResult.resetStatus(); } else { if (resultValue.getErrorMessage().isPresent()) { expectedResult.setExceptionMessage(resultValue.getErrorMessage().get()); } else { expectedResult.setErrorValue(expressionEvaluator.reverseFunction(resultValue.getResult())); } } } I know it looks a bit spaghetti like, but at least it is more readable
suggestion if (resultValue.isSatisfied()) { expectedResult.resetStatus(); } else { if (resultValue.getErrorMessage().isPresent()) { expectedResult.setExceptionMessage(resultValue.getErrorMessage().get()); } else { expectedResult.setErrorValue(expressionEvaluator.reverseFunction(resultValue.getResult())); } } I know it looks a bit spaghetti like, but at least it is more readable
suggestion if (resultValue.isSatisfied()) { expectedResult.resetStatus(); } else { if (resultValue.getErrorMessage().isPresent()) { expectedResult.setExceptionMessage(resultValue.getErrorMessage().get()); } else { if (resultValue.getErrorMessage().isPresent()) { expectedResult.setExceptionMessage(resultValue.getErrorMessage().get()); } else { expectedResult.setErrorValue(expressionEvaluator.reverseFunction(resultValue.getResult())); } } I know it looks a bit spaghetti like, but at least it is more readable
why did you change this to compile?
why did you move this to field tags?
why did you move this to field tags?
This again should be JOptionPane.NO_OPTION.
This will give a logged-in message to them (as well as via the previous method) which can be internationalized.
Can you give a test case where the file is not found and the file is not found?
exception, so STDERR
main(), so STDERR
exit(), so STDERR
For notNull asserts or something that can be run by anyone.
For notNull asserts or something that can be run by anyone. Change them for notNull asserts.
Values seem to be of a particular user. Change them for notNull assertion.
Consider making these 5 lines of code (allocating a byte buffer) a helper method in this file.
Consider making these 5 lines a helper method.
Consider renaming this variable to userMetadata since it is used for two different cases.
I am wondering if we should add a method such as: java public void processStats(OperatorRequest operatorRequest) { List<OperatorRequest> operatorRequests = new ArrayList<>(); operatorRequests.add(new InputNormalRequest()); } public void processStats(OperatorRequest operatorRequest) { Stream<OperatorRequest> operatorRequests = new ArrayList<>(); operatorRequests.add(new InputNormalRequest()); }
I am wondering if we should add a method such as: java public void processStats(OperatorRequest operatorRequest) { List<OperatorRequest> operatorRequests = new ArrayList<>(); operatorRequests.add(new InputNormalRequest()); } public void processStats(OperatorRequest operatorRequest) {... }
I am wondering if we should add some more information to this message, something like "Setting normalState = ((maxWindow - minWindow) > windowThreshold)" instead of "normalState"
Please have a look at the code generator as well, it hides the problem.
Please use a logger.
Please have a look at how it was implemented, I want to see a change to this PR
huh?
huh? :-)
sysout
This and below lines of if statements can be merged.
This and below lines of if statements can be replaced by a method call.
This and below lines of if statements can be replaced by a single liner.
Suggested to pull hasLowerFloatBound and hasUpperFloatBound = false
Suggested to pull hasLowerFloatBound and hasUpperFloatBound = 0L;
Suggested to pull hasLowerFloatBound and hasUpperFloatBound = 0L; to make more sense
If you need a barter with a login I think this will not work: <LINK_0>
Make this a dynamic S please
If you need a barter with a SecurityAction, you should not be processing this string in a convenience method.
why do we need this change?
why do we need this line?
why do we need this?
If you need to verify that c.getParameters().getVm().getVm().getVm().getVm().getVm().getcompatibility_version() is not null, you could remove the "equals"
this would match with the enum returned by setVmState?
this would match with the enum returned by setVmType?
return ancestorStatements.stream().filter(statement -> statement!= parentStatement).filter(statement ->!isSimpleReturn(statement)).count() == 0;
return ancestorStatements.stream().filter(Statement -> statement!= parentStatement).filter(statement ->!isSimpleReturn(statement)).count() == 0;
Can use a stack in the for-loop to avoid the not null check
This isn't going to work correctly with the registered _and_ other cache instances.
This isn't going to work correctly with the registered _and_ the entries are cached in the current thread.
This isn't going to work correctly with the registered _and_ the entries are cached.
einfacher: cm.isActiveNetworkMetered()
emm. you don't need this line
einfacher: cm.isActiveNetworkMetered() will always be true since you expect isConnected() to be false.
Consider using getClass().getSimpleName() here
Consider using plain Thread.sleep() here
Consider using getClass().getSimpleName() here too
Please log the exception so that when no action is provided.
Please log the exception so that when no action is provided, the test will miss this
Please no System.err in that method of logging.
You can also set the true as the second argument to false.
You can also set the true as the second argument to false here.
You should also check that the exception is not thrown.
This should be DateTime.valueOf(item.get("id").asText(), item.get("timestamp").asText());
This should be DateTime(item.get("id").asText(), item.get("timestamp").asText());
This should be DateTime.valueOf(item.get("id")
You can use.toString() instead of string concatenation.
usually we use.toString() instead of string concatenation.
usually we use.toString() instead of string concatenation
We should use a StringBuilder here, like this: java StringBuilder sb = new StringBuilder(); for (int i = 0; i < parameters.size(); i++) { if (valTypeSignature.get(i)) { sb.append(valTypeSignature.createType()); } } sb.append(baseTypeName); } return builder.build();
We should use i++ instead of += 1
What if the result is a T?
When we use a try-catch in the future, I believe the RuntimeException should be thrown and rethrown as a RuntimeException.
When we use a try-catch in the future, I believe the RuntimeException should be thrown and rethrown as a RuntimeException. I'm not sure what exactly this line is doing here.
When we use a try-catch in the future, I believe the RuntimeException should be thrown and rethrown as a RuntimeException. I'm not sure what exactly this line is doing.
This model is same for standalone as well as domain ;-)
This model is not a standalone as well as domain ;-)
This model is not a global variable
you could do here itself if (getWindow() == null) { return; }
you could do here itself if(getWindow() == null) { return; }
you could move the variable to the startProgress() method like this: boolean nfs = Boolean.parse(getWindow() -> {... }
Not sure if we need to check if mediationExtras is null here.
Not sure if we need to check if mediationExtras is present here.
Remove this.
1. compare both equals and hashCode? 2. if they are less than the size of the integer, maybe we should just return a -1, which is a more neccessary?
1. compare both equals and hashCode? 2. if they are less than the size of the integer, maybe we should just return a -1, which is a more neccessary operator?
1. compare both equals and hashCode? 2. If int
nit: would be good to have a test that verifies the size of the array, even if it's the same.
nit: would be nice to have a test that checks the size of the array, including known slots here.
nit: would be nice to have a test that checks the size of the array, including known slots here. This makes the test more concise.
logging and throwing an exception doesn't seem right. better to log the full stack trace
logging and throwing an exception is not much useful
e.getMessage()
In this case it is possible to add an assertion failure by group.getId().compareTo(actual.get(1), group1); which gives better error message. Also add assertNotEquals(group, expected, group)
In this case it is possible to add an assertion failure by group.getId().compareTo(actual.get(1), group1) to make sure its not null. Also add assert failure of the group.get(1), group1);
In this case it is possible to add an assertion failure by group.getId().
Would this be better as package private instead of protected to minimize scope? Since it's only used by the same class.
Would this be better as package private instead of protected.
Why segmentReplicatable() instead of serverSegmentMap?
We don't have to fully qualify the variable here, so let's make sure we are consistent.
We don't have to fully qualify the variable here, so let's make sure to rename it to something like isWriteThreaded
We don't have to fully qualify the variable here, so let's make sure to rename it to something like isWriteThreadRunning
nit: doesSucceed -> isSucceed
nit: doesSucceed -> isSet()
nit: doesSucceed -> isSet()?
again not: why is this called for every project?
again not something to do here, but will be confusing: if you are only trying to fix the problem while you are at it.
again not something to do here, but will be confusing: if you are using brackets here, then you should use brackets here.
Would be nice to wrap this on a class attribute since it's used a lot.
Would be nice to wrap this on a class attribute since it's used a lot in other classes.
Would be nice to wrap this on a class attribute since it's used a lot for a collection.
I think this should be simplified by using : if ((classMemberUsageState == null) || (classScope!= null && classScope!= null)) { createOrUseVariableIdentifierSymbol(tree); }
I think this should be simplified by using : if ((classMemberUsageState == null) || (classScope!= null && classScope!= null) { createOrUseVariableIdentifierSymbol(tree); }
I think this should be simplified by using: symbolTable.associateSymbol(Symbol.Kind.CLASS_NAME, Symbol.Kind.EXPECTED);
Should we catch the NPE?
Should be caught instead of caught.
Shouldn't we catch the NPE?
Please revert this change, too. e.printStackTrace() may help debugging, but I think we don't much need this.
Please revert this change, too. e.getMessage() may help debugging, but I think we don't much need this.
Please revert this change, too.
I changed this to: if (trace) log.tracef("Attempting to receive replicas from %s with topology %s from %s with topology %s from %s with '%s'", segmentId, entry);
I changed this to: if (trace) log.tracef("Attempting to receive replicas from %s with topology %s from %s with topology %s from %s with topology %s from %s with '%s'", segmentId, entry);
I changed this on purpose to make it simpler: if (trace) log.tracef(...) { log.tracef(...) }
Could this line also be called from the activity/ activities and sort of intuitively fits in with that method?
Could this line also be called from the activity/dialog which just has the same behavior?
Could this line also be called from the activity/ activities and sort of intuitively fits in the wizard?
I think we don't need these two log statements. They are associated with a single line.
I think we don't need these two log messages: date, time, and time.
I think we don't need these two log messages. They are pretty info messages.
Please use perun.getFacilitiesManagerBl() here instead of setUpResource().
Please use perun.getFacilitiesManagerBl() here.
Please use perun.getFacilitiesManagerBl() here instead of setUpResource.
This looks like it should be Message.release() (I think).
This looks wrong to me. You should use the logger instead.
This looks wrong to me. It should use the logger instead.
why public? This should be private.
why public? Please rename to something like supportsGradlePlugin
why public? This should be private. Also, why?
This variable could be inlined and reused.
This is a bit method-level, it could be static
This variable could be inlined and reused
synchronize this method with a lock on the file?
synchronize this method with a lock.
synchronize this method with a lock on the file
Please make the method private
It looks like you can just initialize the return value of the method and make the method private
As the implementation of the method, I think protected can be removed.
I think it would be better to use the builder pattern to construct the array.
I think it's better to use the builder pattern to construct the array.
we need {} elses here
Maybe we should be adding a check for null and empty check here?
Maybe we should be using singletonList
Maybe we should be adding such a check for the sanity check here?
Why is this hardcoded? can't be hardcoded? I know it's hardcoded but I'm curious...
Why is this hardcoded? can't be hardcoded?
Why is this hardcoded? can't be hardcoded? I know it's hardcoded but I'm fine with this.
remove.as()
remove.as("...")
remove unnecessary parenthesis
Why is this better than a switch statement?
Why is this switch case needed?
new String
Why did you move this and then why does it need to be done in restartMining()? (which is not what you want to do)
Why did you move this and then why does it need to be done in restartMining()? (which is not what it does)
Why did you move this and not under the "try" as well?
<LINK_0>
"...id" is better
"......"
_org.apache.maven.artifact.Channel.SCOPE_RUNTIME.equals(scope)_
"==" should be declared in constant as well
"==" should be modified to "="
That's a bit of a shame. Why not use something like:.map(clientWithSeq::value).forEach((clientWithSeq::add).collectToMap(() -> paxosValuesByRound.tailMap(clientWithSeq.seq()).values()).map(MutableEntry::toTreeMapBySeq).collectToMap(MoreCollectors.toTreeMapBySeq);
That's a bit of a shame. Why not use something like:.map(clientWithSeq::value).forEach((clientWithSeq::add).collectToMap(() -> paxosValuesByRound.tailMap(clientWithSeq.seq()).values()).map(MutableEntry::toTreeMapBySeq).collectToMap(MoreCollectors.toTreeMapBySeq));
That's a bit of a shame. Why not use something like:.map(clientWithSeq::value).collect(MoreCollectors.toTreeMapBySeq).map(values -> new PaxosUpdate(ImmutableList.copyOf(values))).collectToMap();
This check should not be required at all.
This check should not be required, when working with plugin plugin is on the workspace.
This check should not be required, when working with plugin type.
@ekondrashev Same for toString
@ekondrashev let's not use toString for this line
@ekondrashev let's not cast it on this line
could avoid some duplication by refactoring this method to something like StringUtils.isNotBlank(pluginComponentAliases)
This could be simplified to: java if (!isNullOrEmpty(pluginComponentAliases)) { aliases = new ArrayList<>(); }
Nit: could avoid this if else
can be replaced by return ch == A || ch == T || ch == n || ch == n
can be replaced by return ch == A || ch == T || ch == N
can be replaced by: return ch == A || ch == T || ch == N
I think this method needs to be cleaned up firstWeightDescriptor.setSecondWeight(SimpleScore.ERO); otherwise it is going to fail on this test.
I see you are using this method but not here. This is the same as the first weight weight.
I think this method needs to be cleaned up firstWeightDescriptor.setSecondWeight(SimpleScore.ERO); otherwise if the weight is not set, the firstWeight always ends up.
Why not use the setter directly?
Why not use the BitSet constructor here?
Why not just call set.size() here?
remove block as in: boolean nonMatch = stream(actual.spliterator(), false).noneMatch(e -> { try { op.accept(e); } catch (AssertionError ex) { return false; } return true; }).collect(Collectors.toList());
remove block as in: if (!nonMatch) throw failures.failure(info, noneElementsShouldSatisfy(actual));
remove block as in: boolean nonMatch = stream(actual.spliterator(), false).noneMatch(e -> { try { op.accept(e); return true; } catch (AssertionError ex) { return false; } return true; }
What's the reason for this change?
What's the reason for creating this map?
What about using the following code: ActionObserver.remove(Action, action)
If this fails to serialize, getContentValue could return null, we should check for it and handle the exception explicitly. If it's not a big deal, better to add a message to the exception.
If this fails to serialize, getContentValue could return null, we should check for it and handle the exception explicitly - <LINK_0>
If we want to avoid block (which is bad) then better to use e.getMetaData(key) instead of toString() on the getMetaData.
Can we guarantee that the plugin will be returned, if there are other reasons the handle will fail? Should we handle this case?
Can we move this to _DEFAULT_ RSS_BASE_URL_LENGTH?
Can we guarantee that the plugin will be returned, if there are other reasons the handle will fail? Should we always log the warning.
If it is during construction, you can call LogicalTypeUtils.toObjectArray(elementType) instead.
If it would be better to use LogicalTypeUtils.toObject(elementType) here
If it would be better to use LogicalTypeUtils.toObjectArray(elementType) here
OR(?0.bool1,?0.bool2,?0.bool4)
OR(?0.bool0,?0.bool4:0.bool4)
OR(?0.bool0,?0.bool2,?0.bool4)
Could we instead start at the beginning of the for loop: List<E> errors = new ArrayList<>(); for (Validation<E, T> value : values) { if (value.isInvalid()) { errors = value.getErrors().reverse(); } } else if (errors.isEmpty()) { list = errors.prependAll(otherErrors); } }
Could we instead start at the beginning of the for loop: List<E> errors = Arrays.stream(values).filter(e -> e.isInvalid()).collect(Collectors.toList());
Could we instead start at the beginning of the for loop: List<E> errors = Arrays.stream(values).filter(Validation::isInvalid).collect(Collectors.toList());
Should we change this to just endpoints.get(id, full?
Should we change this to just endpoints.getDebugState()? We already have one entry per endpoint.
I think this is not needed. We already check for null.
Do we really always to CRLF conversion - even on binary files? Wouldn't this corrupt all checked-in jpegs? Even if the file contains e.g. a null byte in the first X bytes - something we used before to check for binary/non-binary files? Or have I overlooked a check here? I always felt that the lack of git attributes which we could use to specify what is binary and what is binary.
Do we really always to CRLF conversion - even on binary files? Wouldn't this corrupt all checked-in jpegs? Even if the file contains e.g. a null byte in the first X bytes - something we were doing before?
Do we really always to CRLF conversion - even on binary files? Wouldn't this corrupt all files, or are you planning to use the same error message we could throw.
this is just a request, but I believe the code is the same in MetadataType.CONTAINER_LOOK and code is the same for all headers because it will be created in each request.
this is just a request, but I believe the code is the same in MetadataType.CONTAINER_LOOK and code is the same for all requests.
We can add this line if the tokenProvider is null
can we add e as the second argument to log message
can we add e as the second argument to this message
can we add e as the second argument?
Consider using Map<String, String> here.
Just readability : java final Long totalDataLoss = sampleCounts.getFailure();
Just pass here the task name
Can you break this line after passthroughOutboundPatientDiscoveryDeferredRequestAuditLogger is used in both methods.
Can we static import this method on PatientDiscoveryDeferredRequestAuditLogger?
Can you break this line after passthroughOutboundPatientDiscoveryDeferredRequestAuditLogger is used in both methods?
Call the acquireLock method first before releasing the lock.
Call the acquireLock method first before release it.
assertFalse?
rename to selection
rename to sSel also
inline
Need to be careful here. What will happen if we have a file tail but a directory that is a directory.
Need to be careful here. What will happen if we have a file tail but a directory that is files files? We should be able to delete a directory afterwards using a directory.
Need to be careful here. What will happen if we have a file tail but a directory that is empty? I think the log should be there too.
Not really related, but this reminds me that during a demo, it was a bit of a pain that we don't have the synonyms found and masterterm found column when not doing every "token" (I guess that word is actually wrong in some cases now). Would there be any drawbacks to always returning them?
Not really related, but this reminds me that during a demo, it was a bit of a pain that we don't have the synonyms found and masterterm found column when not doing every "token" (I guess that word is actually correct in some cases now). Would there be any drawbacks to always returning them?
Not really related, but this reminds me that during a demo, it was a bit of a pain that we don't have the synonyms found and masterterm found column when not doing every "token" (I guess that word was actually wrong in some cases now). Would there be any drawbacks to always returning them?
You can use.containsExactlyInAnyOrder here
Use a.contains(...) method to check for equality.
Use a.contains(...) method to do the contains.
Did you mean to use the / instead of a /?
Did you mean to use the / instead of a constant?
Did you mean to use the / instead of a string comparison?
Maybe I would like to have a dedicated log message, something like: LOG.info("Starting running flows", e);
Maybe I would like to have a dedicated log message, something like: LOG.info("Starting of flows", e);
Maybe I would like to have a dedicated log message, something like: LOG.info("Starting while start of file " + args[0]);
throw new AssertionError("Attempted to complete action with no result!\n%s", this);
throw new AssertionError( String.format("Attempted to complete action with no result!", this));
throw new AssertionError
Also handle the case where the parameter is null?
Also handle the case where!stateData.isEmpty()?
This check could be merged with the one above it.
If we haven't read this code, we should use "java.util.concurrent.ConcurrentHashMap.Builder"
If we haven't read this code, we should use "java.util.concurrent.ConcurrentHashMap.computeIfAbsent()"
If we haven't read this code, we should use "java.util.concurrent.Futures.Future" instead of new Semaphore().
Can you make this method non-private since it is only used by the same class?
Can you make this method non-private and just call it from here?
Can you make this method non-private since it is only used by tests?
I would just use forEach and avoid the stream and can be replaced by:.forEach(tlvs::forEach)
I would just use forEach and avoid the stream and can be replaced by forEach
I would simply use forEach and then use forEach
Formatting issue
Prefer preconditions to check access modifier to prevent NPEs.
Prefer preconditions to check access modifier.
you should check if the feature is active before the drag action is successful
you should check if the master is the same as the ones below
you should check if the feature is active before the drag action is successful.
Is there any reason to avoid all those strings in the test output? In general, all of them probably have defaults with those, only those test strings. If we use those, I suggest to avoid cluttering the tests. If not, consider fixing.
Is there any reason to avoid all those strings in the test output? In general, all of them probably have defaults with those, only those test strings. If not, consider fixing.
Is there any reason to avoid all those strings in the test output? In general, all of them probably have defaults with those, only those test strings. If we use those, I wouldn't have them in the test below.
You should freeLock() before the transaction is committed.
You should freeLock() after the transaction is committed.
You should freeLock() within the transaction to ensure the removal of the resources.
1. Do we need to add the 'final' to the menu, or should we just add the menu inline here? 2. Do we need all the menu related changes?
1. Do we need to add the 'final' to the menu, or should we just add the menu inline here? 2. Do we need all the menu related methods?
1. Do we need to add the 'final' to the menu, too? 2. Do we need all the menu related methods?
Why do you need to change the length of the String?
Why do you need to change the length() + 2 + parameterTypes.length * 25?
Why do you need to change the length of 25?
Is this still required?
:bug: this is not a valid state.
is this valid?
more efficient. There's overhead to creating an array list.
more efficient: There's overhead to creating an array list.
more efficient. Perhaps also log the exception.
Keeping fields working not enough, you need to keep the format consistent. In order to handle this, you need to keep the format consistent.
Keeping fields working not enough, you need to keep the format consistent. In order to handle the simple data format (first bound to the standard format)
Keeping fields working not enough, you need to keep the format consistent. In order to handle this, you need to keep the original format (first apply the "connector" format)
Replace this with: java StartIdentifiedAtlasDbTransactionResponse transactionResponse = transactionResponse.immutableTimestamp().getImmutableTimestamp(); recordImmutableTimestamp(immutableTs);
Replace with.punch(transactionResponse.immutableTimestamp().getImmutableTimestamp())
Replace with: java StartIdentifiedAtlasDbTransactionResponse transactionResponse = transactionResponse.immutableTimestamp().getImmutableTimestamp(); recordImmutableTimestamp(immutableTs);
Would it be better to not repeat this code in testQueueConsumerPriority test?
Would it be better to not remove this?
Would it be better to not repeat this check in testQueueConsumerPriority()?
Can we remove Paths.statusDeploymentGroupHosts?
Can we remove Paths.statusDeploymentGroupHosts() all together?
This should be a precondition.
Let's continue to use the old "if" condition. It should be a completely different behaviour.
Let's continue to use the old "if" condition. It should be a tad cleaner.
Let's continue to use the old "if" condition.
I believe that this is unused.
I believe that this is unnecessary instead of / after the proxy shutdown.
I believe that this is not properly indented - this should be 4 spaces
I miss something, but it should be return 1;
I miss something, you should be able to directly write to plain SQL, so that there's a major issue (not great)
I miss something, you should be able to directly write to plain SQL, so that there's a major issue (not great).
what if bstring is false?
what if start is false?
what if you have boolean fstring?
This should be: return result.isEmpty()? "defaults" : result;
This should be: return result.isEmpty()? "defaults" : result; Or maybe better, extract the default value into a constant variable.
Shouldn't this be an enum?
please use the try-with-resources for this.
please use the try-with-resources for this.. :)
please use the try-with-resources for this..
Given the verifyeroInteractions that you inserted aren't these individual verifications redundant?
I'm not a fan of the verifyeroInteractions that you are verifying. If that makes the test a bit more confusing, I'd prefer to have a different verifyeroInteractions that a CacheAccessException would be thrown.
I'm not a fan of the verifyeroInteractions that you are verifying. If that makes the test a bit more confusing, I'd prefer to have a different verifyeroInteractions that a CacheOperationOutcome was created to avoid these individual verifications.
Just use!index.isEmpty()?
Just use!indexSpec.isEmpty()
Just use!index.isEmpty()
Can we not call circuitBreaker.getMetrics()?
Can we not add another circuitBreaker for the metric registry?
Can we not call circuitBreaker.getMetrics()? If anything it should be just a local variable.
s/unavailableMDevs/unavailable
how does it work for this feature?
how does it work for this volume?
style nit: no braces here
style nit: no braces around single line block
style nit: no braces around single line blocks
This looks a logic change? Is this correct? If this is a bug fix send it in another PR and update <LINK_0>
This looks a logic change? Is this correct? If this looks a bug fix send it in another PR and update <LINK_0>
This looks a logic change? Is this correct? If this is a bug fix send it in another PR and change <LINK_0>
nit: assertThat(rs.next()).isEqualTo(2)); would be nicer.
nit: assertThat(rs.next()).isEqualTo(2)); is nicer.
nit: assertThat(rs.next()).isEqualTo(2)); is much more readable
No need to add thePermittedFields anymore.
I think this should be removed (the access modifier is not public)
I think this should be removed (the access modifier is not updated)
Should this be NOT_SET?
"this" should be part of the config instead of the constructor, in other classes.
"this" should be part of the config instead of the constructor.
Why take the exception as the second argument? And let the logger.error crash?
Why take the exception as the second argument? And let the logger framework handle the exception.
Why take the exception as the second parameter? And let the logger framework handle the exception?
why don't you just use the existing zks that you create in setUp?
why don't you just use the config with cli port?
why can't you just use the existing zks that you create in setUp?
This is incorrect, you can't do it. Instead use forEach directly on the instructors map at the top of the list. java if (instructors!= null) { if (list == null) { return new JsonResult(String.format("Team for the student with id (%s) cannot be found.", courseId), HttpStatus.SC_NOT_FOUND)); }
This is incorrect, you can't do it. Instead use forEach directly on the instructors map at the top of the list. java if (instructors!= null) { if (list == null) { return new JsonResult(String.format("Team for the student with id (%s) cannot be found.", courseId), HttpStatus.SC_NOT_FOUND); }
This is incorrect, you can just use <code>this::displayInstructors</code> here
set the speeage stats to null here
set the total row count to 100 here
set the total row count to be 102
This can be replaced with: java delegateShapeFactory.delegate(ExclusiveDatabasedGateway.class, new NullShapeDef(), () -> caseManagementShapeDefFactory).delegate(BusinessDatabasedGateway.class, new NullShapeDef());
This can be replaced with: java delegateShapeFactory.delegate(ExclusiveDatabasedGateway.class, new NullShapeDef());
In this case, it's better to delegate to the factory, rather than duplicating the code here.
I think this test can be simplified to testIfVerifyOptionIsPassedToTool()
I think this test can be simplified to assertThat(Arrays.asList(values).contains("-v"))
I think this test can be simplified to assertThat(Arrays.asList(values).contains("-v"))?
Please use log instead of e.printStackTrace()
I see that you have used KubernetesClient.java in the same module, but still, it would be better to use it.
I'm not sure it is needed, in this case you have a try-catch block that catches the exception and asserts simple.
"this" is not correct.
"this" is redundant.
I don't understand this change. poss you are modifying the positions of lastFieldOffset in the scan. Wouldn't it be better to make the reset() method in the beginning of this method?
message is kinda nice. :smile:
formatting
msg
Why not assertAccessibility here?
Shouldn't this test "protectedMemberVariable"?
Add an assertion for theMemberVariable in this case.
this logic should be in place, and not in updateTrackingInformation
I would rather use warn here.
this logic should be in place, and not in updateWorked() method
nit: this should be public, no?
nit: this should be o, not object, right?
nit: this should be primitive, not object, right?
Multiple getIndicatedServerNames() maybe clearer, if get once and stored in a local variable.
Multiple getIndicatedServerNames() maybe clearer, if there is a getIndicatedServerNames() maybe more accurate like in the else block
Multiple getIndicatedServerNames() maybe clearer, if get once and stored in a local var.
this can be moved to a constructor
this can be moved to a new method
this can be moved to a constructor as well
It would be better to log the exception before throwing it.
It would be better to pass replicaId
It would be better to pass replicaId.
Is there a particular reason to resolve this?
Can you fix this?
Is there a particular reason for this change?
suggestion if (StringUtils.isNotBlank(currentPid.getQualifier().getClassid()) && StringUtils.isNotBlank(currentPid.getPid.getValue())) {
suggestion if (StringUtils.isNotBlank(currentPid.getQualifier().getClassid())) {
You don't need to do this here because StringUtils.isNotBlank will accept a null pointer
I think this should be a Expressionconverter to handle the nullable fields.
I think this should be a Expressionconverter method instead. Also, what if a schema contains a field that is not a long converter?
I think this should be a Expressionconverter method instead. Also, what if it does?
remove method name
remove this line
remove method login
Is this actually needed? There is also a few more places where it's needed.
Is this actually needed? Maybe consolidate it into a single line.
Is this actually needed? There is also a few more places where it should be done.
The field_name should be integer/number here, because the nightly job will be doing a math calculation on it while purging stale tags.
The field should be integer/number here, because the nightly job will be doing a math calculation on it while purging stale tags.
Since we're not actually doing a fresh new index, we might as well add the "cts" field, so then later on we don't have to worry about updating the mappings via rest call.
IMO it's better to extract a method with shorter and more specific name.
IMO it's better to extract a method with shorter and more specific name than eClasses.
IMO it's better to extract a method with shorter and more specific name than e or eClasses.
check for null too
check for null and make exception (Optional)
check for null and make exception (it's not thrown)
this oneId courseone should be renamed to indicate that it is not implementing
this oneId courseone should be a DateTimeException?
this oneId courseone should be renamed to indicate that it is not the UTC
Why not just have it hardcoded?
Why not just have it hardcoded as the default?
Why not just have it hardcoded as an extension?
You don't need to fullybox the fixtureUtil at all, as you are done with this line.
You don't need to fullybox the fixtureUtil at all, as you are done with the same offset.
You don't need to fullybox the fixtureUtil at all, as you are done with the same PR.
Move the close to the finally block?
Move the shutdown up above the persistor.write(). Since persistor.write() is synchronized, this can be a background operation.
Move the close up above the persistor.write().
You can use a constant.
You can use a constant (like EMPTY_STATE)
You can use a constant 00000000_0000-0000-0000 instead of duplicating it?
I thought java had automatic content type detection. If so, can you not pass the content type since that's what most users will be doing
since you're changing the name of the variable, can you change it to something like: java return recognizeLayoutPoller.client.beginRecognizeContentFromUrl("file_source_url");
since you're changing the name of the variable, can you change it to something like: java imagePageResults = recognizeLayoutPoller.build();
This will fail if there is no defined value.
This is a debug message.
This will fail if there is no defined or undefined.
add value of out to the error message
add value of.typeText
add value of value
Can you make the string a constant? Or use a constant.
Can you make the string a constant?
Can you make the number of available slots instead of just the identifier?
Add a description, like pipelines.map(pipeline -> pipeline.getPipelines().stream()).collect(Collectors.toList());
rename to pipelineConfigWithMinimalAttributes API.
Add a description, like pipelines.map(pipeline -> pipeline.getPipelines().stream()).collect(Collectors.toList())
please looks like it's a Value of nullValue, but I believe you do not need to use nullValue here (it's for symmetry)
please looks like it's a Value of nullValue, but I believe you do not need to assert it here.
please looks like it's a Value from the JSON.
Why are we closing the transaction here?
Why are we closing the transaction?
Why are we opening a new transaction?
pls. add a log line in the exception
pls. add a log line in this exception
pls. add a log line
rename'resource'
rename to resource
element
I'm wondering if logging and continuing is the right fallback here? Ideally we'd probably want to leave the event unprocessed rather than ignore it, but as echo doesn't really have a queuing mechanism, I suppose that failing is probably the only option.
I'm wondering if logging and continuing is the right fallback here? Ideally we wouldn't want to leave the event unprocessed rather than ignore it, but as echo doesn't really have a queuing mechanism, I suppose that failing is probably the only option.
I'm wondering if logging and continuing is the right fallback here? Ideally we'd maybe want to leave the event unprocessed rather than ignore it, but as echo doesn't really have a queuing mechanism, I suppose that failing is probably the only option.
Can this be moved outside the SyncAccountBuilder?
Can we call this something other than AccountAttributes?
Can this be private?
We don't need to log this message
We don't need to log this error message
lets use {} placeholders to log error
assertThat(links.size(), is(1));
assertThat(links.size(), is(1))
assertThat(links.size(), is(1)).hasNext();
Typo in AbstractQueryOperator
Typo in excludeSpecialChildren
Typo
redisConnection should be accessed as static method.
redis URIs should be accessed as static method.
redis() should be accessed as static method.
I think this could be moved to a parent class of ooKeeperClient to avoid having to create a new object.
I think this code can be moved to a parent class of ooKeeperClient to avoid duplicating most of the code there.
I think this could be moved to a parent class of ooKeeperClient to avoid having to create multiple services
This also needs to be reworked once #6327 is merged.
Change this to a final block to make this code more readable: try { channelGroupOptional.map(id -> { if (id.isPresent()) { throw new RuntimeException(new NotFoundException(id)); } else { throw new RuntimeException(new NotFoundException(id)); } }
This also needs to be updated to make this method synchronized
suggestion + "All ledger directories are re- writable and force GC is enabled.");
Should be "all ledger directories are available"
space after comma
nit: I'd suggest debug, but if you change the log level to debug, you won't need this if the task id is not set.
nit: I'd suggest debug, but if you change the logging level to debug, you won't need this if the task id is not set.
nit: I'd suggest debug, but if you change the log level to debug, you don't need this log.
@vilchik-elena Why not use null?
@vilchik-elena what if there is no member-point?
@vilchik-elena what if there is no member definition?
Someone of us miss L here (probably me when I wrote this).
Someone of us miss L here (probably me when I wrote this method).
Someone of us miss L here (probably me when I wrote this). Please change this method to verify if clicking on OK.
I would change it to: if (length > max) { addIssue(node, "Value of " + length + " is not referenced in the public class."); }
Shouldn't we externalize it in the public class?
I would change it to: if (length > max) {... }
Could we split this logic into Charge not available in ledger <LINK_0>
Could we split this logic into ChargeCharge?
Could we split this into Charge not available in ledger <LINK_0>
Can you use check if task is offline?
Can you move this check to superclass?
Can you move this check to superclass? You can reuse it in setup method
Where do you come up with this?
Where do you come up with the above?
here you can reuse the AuthenticatorActivity you are targeting
Not sure I agree with removing this line, but I think the sanitizer already calls unsanitizeConnectionParameters and conn.setPassword() is only called when the pool is being consolidated into a single call to ConnectionServiceException.
Not sure I agree with removing this line, but I think the sanitizer already calls unsanitizeConnectionParameters and conn.setPassword() is only called once per connectionList. Is this intentional?
Not sure I agree with removing this line, but I think the sanitizer already calls unsanitizeConnectionParameters and conn.setPassword() is only called when the pool is being consolidated into a single call to getCryptoS().
This can be static, no need to add it here.
This shouldn't be necessary.
This may not be necessary.
We probably don't need to log this here. It's a good practice to only log the exception that is passed to this method.
We probably don't need to log this here. It's a good practice to only log the event collection name, but the exception message seems odd.
We probably don't need to log this here.
if (jsonNode.isArray()) { ArrayNode arrayNode = (ArrayNode) jsonNode; } else { ArrayNode arrayNode = (ArrayNode) jsonNode; }
if (jsonNode.isArray()) {... } else {... }
if (jsonNode.isArray()) { ArrayNode arrayNode = (ArrayNode) jsonNode; } else { ArrayNode arrayNode = (ArrayNode) jsonNode;
store the span name in the ss, I would imagine this
store the span name in the ss, it will be more informative for other languages
store the span type in the o
Does this need to be done if leaderElector.hasLeadership?
Does this handle a case where we miss a leader election?
Does this need to be done at the end of the same time?
Makes sense to use the toString for the system name.
Makes sense to use the VariantType for the String and use that here.
Makes sense to use the VariantType for the return value of String.
rename to p
rename to pEntry
rename to pckg
Can you explain why this is needed? I would expect it to be in the above clause of the if below.
Can you explain me why this is needed? I would expect it to be in the above clause of the if below.
Can you explain me why this is needed? I would expect it to be in the next PR: <LINK_0>
Shouldn't it be "else if"? I guess that's what the user is doing here.
Shouldn't it be "else if"?
Shouldn't you set it to "true"?
Instead of "identity", use the constant AccountConstants.RANCHER_ID.
It's a good idea to move this to the IdentityGenerator, less code, and better to use IdentityGenerator.
It's a good idea to move this to the IdentityGenerator, such as both the project and the project are not cacheable
Shouldn't this be: if (!autoAck) { Thread.sleep(); }
Shouldn't this be: if (!autoAck) { Thread.sleep(100); }
Shouldn't this be: if (autoAck &&!ackState.isEmpty()) {
The indentation here is incorrect, it should be changed to something like:.filter(StringUtils.isNotEmpty(factor) && isNullOrEmpty(state) || isEmpty(state))
The indentation here is incorrect, the method should be changed to return an Optional<String> instead.
The indentation here is incorrect, the method should be changed to use tabs.
Why not using here: Map<storage_domains, Integer> map = new HashMap<>();
Why not using the [storage_domains](<LINK_0>?
Why?
I don't think it's a good idea to have a message for the handler in a message, because it may be too big. When you have a message, it would be better to have the exception message in the BroadcastingTaskExecutor implementation.
I don't think it's a good idea to have a message for the handler in a message, because it may be too big. When you have a message, it would be better to have the exception message in the log.
I don't think it's a good idea to have a message for the handler in a message, because it may be too big. When you have a message, it would be better to have the exception message as a bit more specific.
What do you think about making this private?
What do you think about making this package-private?
It's actually quite unlikely that GranularityType.NONE is not used in the connector.
Is this line necessary?
Is this really needed?
We can use TextUtils.isEmpty here to reduce null safety.
Isn't this try/finally block necessary?
This is inconsistent with the existing methods: null, and an empty method call. Why is this called null?
This is inconsistent with the existing methods: null (empty and non-empty) - Exception message should also be thrown.
It'd be nice to add a method'setDurable(event)' that this method can be used in the builder too.
It'd be nice to add a method'setDurable(event)' that this method can be used in the builder like the rest of it. The builder pattern is top-level.
Looks like this line was removed.
objects cannot be null after the constructor. (write if (fTrace == null), you will get a compiler error)
objects cannot be null after the injection. (write if (fTrace == null), you will get a compiler error)
is this check enough?
please use Cluster#hasGateway
is this necessary?
why?
why is this a final var?
why is this a final String?
why is this a String version?
suggestion logger.debug("Searching to container id {} and is {}", caseId, containerId);
suggestion logger.debug("Searching for container id {} and is {}", caseId, containerId);
suggestion logger.debug("Searching/ container id {} and is {}", caseId, containerId);
Couldn't you check against the exact same message in both the call to this method?
Couldn't you check against the exact same message in both the call and the callback?
Extra whitespace.
You can make this a BatteryObject and then use getMjBattery(o) and get rid of this.
You can make this a BatteryObject and then use getMjBattery(o) rather than new BatteryObject.
If you want, you can also use BatteryStatus.Value.
I usually Preconditions.assertThat(mergedConfig.getSteps()).isEqualTo(getBefore()).isEqualTo(primaryConfig.getBuildResources())
I usually Preconditions.assertThat(mergedConfig.getSteps()).hasSize(primaryConfig.getSteps())
This assertion should be deleted
Should use fromText instead of getName() for all of these.
Should use fromText instead of getName() for all of these. See the ones below
Should use fromText() instead of getName() for all of these.
Can you put the methods on equals and hashCode implementations so that they can be consistent?
Can you put the methods on equals and hashCode implementations so that they can be reused?
Can you put the methods on equals and hashCode implementations so that they can be reused like this?
TechnicalException
TechnicalException instead of IOException
TechnicalException instead of Exception
What is the purpose of "-ResourceState" in this context?
What is the purpose of "-ResourceState" in this context? Do we need to make sure that MetricRegistry does not have the same name?
What is the purpose of "-ResourceState" in this context? Do we need to make sure that MetricRegistry does not have a proper name?
Use Strings.isNullOrEmpty
Use TextUtils.isEmpty.
Use StringUtils.capitalize(.
mnt_options and vfs_type are relevant to posix too.
This is not consistent with other argument names. Please use!StringUtils.isEmpty(value.toString()).
This is not consistent with other argument names. Please use!StringUtils.isEmpty(value)
I would prefer to move this to a warn level, since it will most likely pop up depending on the log level.
I would prefer to move this to a warn level, since it will most likely pop up when this happens.
I would prefer to move this to a warn level, since it will most likely pop up depending on the level of the log.
[minor] Space before Object
minor, i.e. to go to the domain representation more directly?
[minor] Space before Object, please!
If user has accepted selection of let's say 30 elements (without the 'd') and after the popup shows the dialog to be shown. The user should be able to cancel the dialog. We should find a way to prompt the user before showing the warning dialog.
If user has accepted selection of let's say 30 elements (without the 'd') and after the popup shows the dialog to be shown. The user should be able to cancel the selection.
If user has accepted selection of let's say 30 elements (without the 'd') and after the dialog seems to be shown. The user should be able to cancel the dialog. We should find a way to prompt the user before selecting the selection and show it.
If description is "just a request, write this request" instead of "Request", use the return type of SnomedConceptCreateRequest.
If description is "just information", please check if it's a SnomedCONCEPT.
If description is "just information", please check if it's a SnomedConceptCreateRequest is status, not DESCRIPTION.
Suggestion: Can unrelated changes be pushed as separate iteration?
Suggestion: Can unrelated changes be pushed as separate operation?
Can we rename this to make it more readable?
Unnecessary semicolon.
Adapters should be used here
Extra line
Why do we call it again? As you use it, it should be a large number of lines.
Why do we call it again? As you use it, it will be a lot easier to maintain if it is checking if the original ldapApiEnumerationBugEncountered is false.
Why do we call it again? As you use it, it will be a lot easier to maintain if it was a Set...
Just return the semi-colon block?
Use a constant in the MesXPanel.
Use a constant
It would be good to store the template key as a private final constant and use it here and in the other classes too.
It would be good to store the template key as a private final constant and use it here and on line 89
It would be good to store the template key as a constant somewhere, so we don't have to duplicate it
This can be moved into the if (isHtmlBody()) clause.
This can be moved into the if (isManaged()) clause.
This can be moved into the if (isDeleteed()) branch.
I think we should use an 'getExecutor()' method here.
I think we should use map.isEmpty() here.
I think we should use map.isEmpty()
It should close the histogramLogWriter before closing it
It seems that we should close the histogramLogWriter before it is called.
It seems that we should close the histogram logWriter before it is called.
minor: probably better to put the try-catch inside the catch block
minor: probably better to put the try-catch inside the new function
minor typo
potential NPE: db.getObjectDatabase().close()
potential NPE: db.getObjectDatabase().checkoutEntry
potential NPE: db.getObjectDatabase(). checkout()
I think this change is not correct. The perun could be logged outside of the loop.
I think this change is not correct. The perun could be logged outside of this loop.
I think log.error is enough.
Why not Collections.singletonList()?
Why not Collections.singletonList(
Why not Collections.singletonList()?
Shouldn't we use.show() instead of.get()?
Shouldn't we use.show() instead of.setText()?
Shouldn't we use.setText() instead?
The same here. No need to acquire locks
The same here. No need to acquire locks.
It looks like it makes sense to lock whole machine in lock of unknown machine?
this should come after the volume==null check
this should come after the volume==null checks
this should go to the audit log
split the both (i.e. the "exports" and "exports" into separate variables.
split the both (i.e. the "exports" and "exports" into different variables.
split the both a 'exports' and "exports" into separate variables.
This method is used in a few places.
This method is used a lot. A private method for a class-method with the template parameters should be private.
This method is used a lot. A private method for a class-method with a template parameter would be better.
Is this property really needed?
Is this property really required?
Is this value really needed?
again, please print the error stack trace in case of failure
again, please print the error stack trace in addition to the logging.
again, please print the error stack trace in addition to the logging
You need to verify isToBeRemoved in the if-else block
You need to verify if isToBeRemoved is true.
You need to verify if isToBeRemoved is true. Same for other places
Do we need to make this method public?
Do we need this change?
Do we need to make this public?
Same as above, JDK won't work properly if you don't want to leave a click.
Same as above, JDK won't work the same way
help to pull out to a logger.
What about the following: if(imgUUID == null) { return null; } volume.setImgUUID(srcVolUUID);
What about the following: if (imgUUID == null) { return null; } volume.setImgUUID(imgUUID);
What about the following: if (TaskType.FINISH_CREATE_VOLUME, 3000L) { }
Could you elaborate on the purpose of this change? In the case the input file cannot be a directory (or is it handled in the process or not)?
Could you elaborate on the purpose of this change? In the case the input file cannot be a directory (or is it handled in the process or is it handled here)?
Could you elaborate on the purpose of this change? In the case the input file cannot be a directory (or is it handled in the request dispatcher). So, the design is kinda nice, but it makes sense to ensure the page is " files".
Same thing as before.
Same here, add new...
Same here, add new...
It's a little weird that you're putting the value here.
It's a little weird that you're not putting the value here.
It's a little weird that you're putting the value of the Script(CUSTOMIING) inside the if body, and so on.
Consider creating a private method that checks if config instanceof RefreshableInstanceConfig and then calls that method here.
Consider creating a method that checks if config instanceof RefreshableInstanceConfig and then calls that method here.
What would happen if we have a default address?
If we keep the stream, can we make the assertion stronger?
If we keep the stream, can we make this this line shorter?
If we want to keep this, can we make the stream file be expanded?
Change this test to just the one that creates the account, and then use ah.addAssignRole(CA.getAccountList().get(0).getId()) for the test below.
Change this test to just the one that creates the account, and then use ah.addAssignRole(CA.getAccountList().get(0).getId()) for the test below
Change this test to just the one that creates the account, and then use ah.addAssignRole(CA.getAccountList().get(0)
forgot to commit the printStackTrace()
forgot to commit the printStackTrace();
forgot to commit it
instead of Boolean.valueOf() can you use TextUtils.join()?
what about Boolean.valueOf()?
instead of Boolean.valueOf() you can use Boolean.parseBoolean() which gives a regex query. This is what you meant.
nit: This check is redundant, the iteration below would guarantee that the string is the same.
nit: This check is redundant, the point would be to return the intervalExpression itself.
nit: This check is rather unnecessary.
The only method that calls this method is HiveS3Optimizer::isCompressionCodecSupported and that method is unused, so both can be removed.
The only method that calls this method is HiveS3Optimizer::isCompressionCodecSupported and that method is unused, so both could be removed.
The only method that calls this method is HiveS3Optimizer::isCompressionCodecSupported which is unused, so both can be removed.
we also need to check if it is enabled otherwise we should load the native prepush hook if existing. Otherwise you effectively disallow using native prepush hook with jgit pgm since it always registers BuiltinLfsImpl.
we also need to check if it is enabled otherwise we should load the native prepush hook if existing. Otherwise you effectively disallow using native prepush hook with jgit pgm since it always registers BuiltinLfsFactory.getInstance().getCloudObjectMetastore()
we also need to check if it is enabled otherwise we should load the native prepush hook if existing. Otherwise you effectively disallow using native prepush hook with jgit pgm since it always registers BuiltinLfsFactory.getInstance().getCloudObjectMetat()
- [x] Not required to check isDebugEnabled, because no heavy function on logging.
- [x] Not necessary to check isDebugEnabled, because no heavy function on logging.
- [x] Not required to check isDebugEnabled, because no heavy function on logging..
Can't break early here. Wrap the next loop in a null check instead.
java for (Action join : hunter.getLoadedFrom()) { Action join = joined.get(i); if (action!= null) { deliverAction(result, from, join); } }
can't break early here. Wrap the next loop in a null check instead.
nit: variable name should be just topicName.
nit: variable name should be just topicName?
nit: variable name should be just topicName
Using Long instead of long could open the door for returning a null object.
Using Long instead of long could open the door for returning a long instead of returning void.
Using parenthesis instead of a ternary operator?
Can this be replaced with putAll?
Can this be replaced with computeIfAbsent?
Duplicate code.
There shouldn't be logic in the Bean-classes, please extract it to the TaskService. Furthermore this code is duplicated in the "GeneratorSwitch" class. Please consider, what the code does and where it should go.
There shouldn't be logic in the  generatableFolders. Furthermore this code is duplicated in the "GeneratorSwitch" class. Please consider, what the code does and where it should go.
There shouldn't be logic in the  generatableFolders. Furthermore this code doesn't need to be duplicated in the "GeneratorSwitch" class. Please consider, what the code does and where it should go.
I doubt this is related to the issue you're trying to solve actually. But _if_ you want to make a fix also for this here, then synchronized is not the right way. The potential issue you're facing is that a non-AWT thread is invoking this method (since it's a listener method - invoked by the descriptor thread). And all changes to AWT (and thereby Swing) must happen in the AWT dispatcher thread. So instead use WidgetUtils.invokeSwingAction(...).
I doubt this is related to the issue you're trying to solve actually. But _if_ you want to make a fix also for this here, then synchronized is not the right way. The potential issue you're facing is that a non-AWT thread is invoking this method (since it's a separate thread). And all changes to AWT (and thereby Swing) must happen in the AWT dispatcher thread. So instead use WidgetUtils.invokeSwingAction(...).
I doubt this is related to the issue you're trying to solve actually. But _if_ you want to make a fix also for this here, then synchronized is not the right way. The potential issue you're facing is that a non-AWT thread is invoking this method (since it's a listener method - invoked by the descriptor thread). And all changes to AWT (and thereby Swing) must happen in the AWT dispatcher thread. So instead use _this.filePredicate = filePredicate.getAllFiles().stream().noneMatch(f ->!map.containsKey(f)).forEach(this::removeFile);
Using Optional.empty() makes it more easy to understand what's going on here.
Using Optional.empty() makes it more easy to understand what's going on. rather than just leftMinPosition.isPresent(), don't you?
Using Optional.empty() makes this condition easier to read.
I think we should close the personnelFile here. It sounds like the personnel could be closed already.
I think we should close the personnelFile here. It is unnecessary to check for null personnelFile.
I think we should close the personnelFile here. It is unnecessary to check for a personnelFile if necessary.
If we read the file without a log, then we could not read it into the log file.
If we read the file without a log, then we could not read it into the log.
If we read this and the line 390 should be removed and the CLI script could use the same Context.
'org.apache.commons.lang.StringUtils#isBlank' for null check
'org.apache.commons.lang.StringUtils.isNotEmpty()' is redundant here, you do not need to declare it explicitly
'org.apache.commons.lang.StringUtils.isNotBlank' for null check as well
The MODULE identifier is already defined as a base class attribute, so all references to it are constant.
The MODULE identifier is already defined as a base class attribute, so all the methods to use it are defined as lamdas.
Use new HashMap<>()
This will not be useful in the default configuration where metrics are not throttled. A better "possibly throttled" detection would need to check if a persist is running, or not.
This will not be useful in the default configuration where metrics are being processed.
This will not be useful in the default configuration where metrics are not actually being used.
please replace with IReleaseUtil.getExistingPath(executionEnvironment)
please replace with JavaCore.Adapters.adapt
please replace with JavaCore.Adapters.adapt(executionEnvironment)
Why divert and retroactiveResourceName? Why not have the retroactiveResourceName be added to the message message?
Why divert and separate address is needed. Why not have the retroactiveResourceName take the message from the original cluster? With having separate addressInfo and the retroactiveResourceName take the message from the original cluster?
Why divert and retroactiveResourceName? Why not have the retroactiveResourceName be added to the message message? With a message, you've got to add the addressInfo and the retroactiveResourceName should not be changed.
Please change this to debug line.
Please change this to debug message
Please change this to debug line
Please use new ArrayList<>() with its default size.
Please use new ArrayList<>() with size 1.
Please use 1 final size.
Other implementations of Comparable in Java don't even check for null, do we have to?
Other implementations of Comparable in Java don't even check for null, do we have to use compareTo() here?
Other implementations of Comparable in Java don't even check for default value.
I suggest to use a doReturn(indexResponse).when(multiGetItemResponse).hasField(key, size).
I suggest to use a doReturn(indexResponse).when(multiGetItemResponse).hasField(key); after this.
I suggest to use a doReturn(indexResponse).when(multiGetItemResponse).hasField(key, new MultiChunkHeader.class)
could you use put(1, PUT_RECORD_SIE, Utils.Infinite_Time).
can we add an assertion for null?
could you add an overload to assertAuthorization() please?
There's no need for warn.
There's no need for ;
There's no need for warn, just replace.
Should this be using [ResponseBuilder](<LINK_0> instead?
Should this be using [ResponseBuilder](<LINK_0> so that the builder.withResponse() methods are not required?
Should this be an actual DataResponse?
This test is missing a check on the FileReader.
Probably consoles should be logged in a proper log.
Probably consoles should be logged in a proper log file.
Why not use model?
Why not use streams?
Why not use model? (Index++)
Same as above, would prefer that we assert on the invalid list size (obtained from txClient) instead of on printed output.
Same as above, would prefer us to assert on the invalid list size (obtained from txClient) instead of on printed output.
Same as above, would prefer instead of asserting on the invalid list size (obtained from txClient)
Style nit: checkNotNull() isn't needed here, checkNotNull() isn't needed
Style nit: checkNotNull() isn't needed anymore
It's possible to event things in event that there's something that's valid in event.
We need a mechanism to specify that certain microservices get exposed only on certain ports. According to this implementation, all services will always get exposed on all ports. It is ok for now but create an Issue so that we can address that in the future.
we need a mechanism to specify that certain microservices get exposed only on certain ports. According to this implementation, all services will always get exposed on all ports. It is ok for now but create an Issue so that we can address that in the future.
We need a mechanism to specify that certain microservices get exposed only on certain ports. According to this implementation, all services will always get exposed on all ports. It is ok for now but create an Issue so that we can address that in a future.
It is prettier to do a String comparison here.
It would be better to use a boolean expression on the parent class, to be processing the case.
It would be better to use a boolean expression on the parent class, to be sufficient here.
this is a non-private method, no need to be protected
I would retain a second if statement here.
this is a non-private method, no?
May be add it to the pipeline policy when it is created.
May be just retry policy in this case?
May be add it to the pipeline policy when it is created?
Instead of logging the error here, we should log the exception as well as the method parameter.
Maybe I missed something but could you implement this as a method parameter since it is already logged?
Instead of logging the error here, we should log the exception as a parameter
why not just do it where it is being used?
why not just do it where it is used?
why not just do it that way?
I think this could be changed to "The text index %s already exists."
I think this could be changed to a switch statement with an enum for the text type.
I think this could be changed to a single test case, which is more robust.
nit - please decrease log level to trace
nit - please decrease log level to trace or better remove
nit - please decrease log level to trace and also avoid doing this
use a variable x to avoid calling read
this should be done in debug log
this should be done in debug
Can you make "now" twice?
Can you make this "timezone" string more clear?
Can you make "timezone" a constant for the second argument?
Is this needed?
Is this needed? What if you use a ChannelFuture
Is this done elsewhere?
Please use Optional.fromNullable(value)
Please use Optional.of(FatalProtocolError)
Please use Optional.of(FatalProtocolError).
I think this needs to be done in the TableInfo object, otherwise the parameters are confusing to me.
I think this needs to be done in MetadataTableUtil.setupTask, which hides the problem's.
I think this needs to be done in MetadataTableUtil.setupTask, which hides the problem's code.
'null' should be added to ifaceNetworkImpDetails.isInSync()
'null' should be added to ifaceNetworkImpDetails.InSync()
Shall we please add final to the variable?
checkState
checkState?
checkArgument
I find the test easier to read like this: resolve("refs/heads/foobar").canSubmit(); or the ProjectControl u = user(); statement.
I find the test easier to read like this: part of the test.
I find the test easier to read like this: resolve("refs/heads/foobar").canSubmit();
I think the hashed custom API should be prefixed here by the R.string.analytics_label_custom_url? This would allow us to return a list (or count) of all custom APIs that we've seen. So, it would look like CUSTOM_URL=8nh2j02f.... Otherwise, if we have only the SHA-1 hash, we'd need to filter for all custom API URLs that aren't region names, which would be much harder to implement/maintain.
I think the hashed custom api should be prefixed here by the R.string.analytics_label_custom_url? This would allow us to return a list (or count) of all custom APIs that we've seen. So, it would look like CUSTOM_URL=8nh2j02f.... Otherwise, if we have only the SHA-1 hash, we'd need to filter for all custom API URLs that aren't region names, which would be much harder to implement/maintain.
I think the hashed custom API should be prefixed here by the R.string.analytics_label_custom_url? This would allow us to return a list (or count) of all custom APIs that we've seen. So, it would look like CUSTOM_URL=8nh2j02f.... Otherwise, if we have only the SHA-1 hash, we'd need to filter for all custom APIs that aren't region names, which would be much harder to implement/maintain.
Please remove this line
Please add a method to createMeasurementRowsFromEnvironments() which returns a ExpDesignParameterUi
Please create method to create the MeasurementVariable class
Please replace with DruidFloatPredicate.ALWAYS_FALSE.
Please replace with DruidFloatPredicate.ALWAYS_FALSE please
Please replace with 'else if' for readability
just create a variable and check if m_useCQL.
just use m_useCQL.
just create a variable instead?
This is too complicated. I think it would be best to break it up into multiple lines.
This is too complicated. I think it would be better to break this up into multiple lines and add formatting.
This is too complicated. I think it would be best to break it up into multiple lines and give the user a meaningful description.
Please move the instanceName to the end of the test method.
It looks like you don't have to wait for it to be true?
It looks like you don't need to be here.
Is it possible to just delete this form entirely?
I think we need to return here. It's not needed to indicate the login.
I think we need to return here. It's not needed to have the return below.
It's better to handle this exceptional case as we have a method with no args, then we should not log anything.
It's better to handle this exceptional case as we have a method with no params, then we should not log anything.
It's better to handle this exceptional case as we are logging stacktrace anyway.
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate column number
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter.
any specific reason we have a separate function that takes in the column number as a parameter? I would suggest creating a generic function that takes in the column number as a parameter.
Please use parameterized logging instead of string concatenation.
Please use substitution instead of e.g.: logger.debug("{}", substitution, e);
Please use substitution instead of substitution
add 'user' member instead of 'user'
User can be null
add link
I think you should use S3_CLIENT_FACTORY_IMPLE instead of assuming it's deprecated. That makes this test easier to understand.
I think you should use S3_CLIENT_FACTORY_IMPLE instead of assuming it's deprecated.
I think you should use S3Client.toUsingTransaction instead of commit committers. That will also ensure that any associated test bucket creation failed.
Is this logic necessary? Why don't you just return?
You should simplify this if-then-else, just return?
Is this logic necessary?
nit: "hadoop token file doesn't exist"
nit: "hadoop token file does not exist"
nit: "hadoop token information" -> "current user is not set"
I'd use : if (processList.getItems().size() <= procs.size()) {
I'd use : if (processList.getItems().size() <= procs.size()) { bean.setProcessID(process.getProcessID()); }
I'd use.toString() instead of relying on string format
This complicates code quite significantly. Can you move it to a separate method?
This complicates code quite significantly. Can we move it to a separate method?
This complicates code quite significantly. Can you move it to a method?
use rows.isEmpty
use rows.size
use rows
if we fail here we have a stale VM version in hand. we should roleback
if we fail here we have a stale VM version in hand, we should roleback
if we fail here we have stale VM version in hand. we should roleback
Similarly here, we should also check that the substudy is not null.
Would it be better if we move this check into the for loop?
Would it be better if we move this check into the for loop above?
May be worth providing the bucket ID of the tx id to help with debugging from the logs?
May be worth providing the bucket ID of the tx cursor to help with debugging from the logs?
May be worth providing the primitive fetch offset of the txstore?
can make this a constant
can make this a final static variable
can make this if statement final
We're not creating the eventProcessorRegistry here right? Can we pass the sagaManager to the EventProcessorRegistry? That will allow us to remove the eventProcessorRegistry altogether.
We're not creating the eventProcessorRegistry here right? Can we pass the sagaManager to the EventProcessorRegistry? That will allow us to create the event processor from multiple containers.
We're not creating the eventProcessorRegistry here right? Can we pass the sagaManager.get() the first thing through?
Instead of these setters, did you try doing this instead? configurationBuilderHolder.getGlobalConfigurationBuilder().read(gcb.build()) What  does is take the base configuration objects that you read from XML and override them with whatever gcb contains. Is that what you're trying to achieve?
Instead of these setters, did you try doing this instead? configurationBuilderHolder.getGlobalConfigurationBuilder.read(gcb.build()) What  does is take the base configuration objects that you read from XML and override them with whatever gcb contains. Is that what you're trying to achieve?
Instead of these setters, did you try doing this instead? configurationBuilderHolder.getGlobalConfigurationBuilder().read(gcb.build());
Just a small suggestion: Should we add the column name?
Just a small nit: it might be more readable to use getOrDefault(form, UI::buildDetailButton) here.
Just a small nit, could you add the column name?
Hmm, can we really get rid of the two static methods? Here and below: java public Timestamp getCurrentTimeOnDB(Connection conn, Calendar cal) throws SQLException { return rs.getTimestamp(1, cal); } public Timestamp get time(1, dbProduct);
Hmm, can we really get rid of the two static strings?
Hmm, can we really get rid of the two static strings CURRENT_TIMESTAMP objects?
i dont think clear is needed, it looks to me its called only once per run
Can't you replace clear with getVmDao()?
Can you please remove clear() and just set the object?
If you move the name of the extension to a common place, then you could play well with the extension point, so the extension point could be changed.
If you move the name of the extension to a separate file, then you could use it from the core. The extension point of the plugin could be changed or removed.
Why not use java.util.Objects.equalsIgnoreCase()?
consider using a mixpanelPushNotification.getData().getTag() that's a used constant
consider using a mixpanelPushNotification.getData().getTag() that checks for null and then comparing to the same value in calculatePushNotification.
consider using a mixpanelPushNotification.getData().getTag() that is used everywhere to get a random id from the notification.
The if block is empty, no need to check for null.
Can you use a aListList instead?
Arrays.asList
This change will break if the metadataString contains a comma.
This change will break if the metadataString contains null.
Text should be a constant.
nit: unused
unused
unused?
Resource leak? If rss.close throws.
Resource leak? If rss.close throws. will it fail the process?
Resource leak? If result set is never closed using try-with-resources.
Use namedConfigurationBuilder.rawContent().
This is going to return a paged CompletionStage. However, this method isn't really intended to read the contents.
This is going to return just the namedConfigurationBuilder.rawContent(). Is it supposed to be read-only?
Why do you need to increment counter?
Why do you need to wait here?
Why do you need to increment counter here?
I'm not sure this is the right place to make it because it's being done through the _nonOperationalPools. If you look at the callers of _nonOperationalPoolsTest (line 82), you can use.isEmpty() instead of size() > 0
I'm not sure this is the right place to make it because it's being done through the _nonOperationalPools. If you look at the callers of _nonOperationalPoolsResource, you won't have to check if the collection is empty or not.
I'm not sure this is the right place to log the status of the pool. I think you already have it in the line 133, but the log is still misleading.
This looks like it might be a problem, but the logger still isn't set to this.
This looks like it might be a LOT, but the test case might be too late.
This println is probably not necessary
Move this ((RunT)this).getDisplayName() to the log message
Move this to the log line?
Move this to be a helper?
Is this really needed?
Is this done by both settings?
Is this done in the negative case?
Why is this necessary?
Why do you want to log the returnedPositions?
Why do you want to log this?
current version of this code is a bit fragile. I think the usage of boolean flag is by default, some tests might be better (maybe even using else if not true) then to make it easier to read.
current version of this code is a bit fragile. I think the usage of boolean flag is by default, some tests might be better (maybe even using else if not true) else.
current version requires some tests
!(mpart instanceof MPartStack)
!(mpart instanceof MPartStack) ||
unused
same. Replace "maxDeliveryCount:1" with "MaxDeliveryCount:"
Why is this needed?
Why is this hardcoded?
This will be hard to understand. I'd just set a local variable for the link.setValue(null);
why do you need to set it to null?
This will be hard to understand. I'd just set a local variable for the link and extract the value.
Can we remove _logger.info("Running job {}: {}", jobName)?
Can we do that only if HADOOP_TOKEN_FILE_LOCATION is set?
Can we do that only if HADOOP_TOKEN_FILE_LOCATION is defined?
why was this removed?
Why was this removed?
why remove this?
dont use braces around single line blocks
Extract smaller methods.
Extract all of these to constants
Leftover debug statement?
The printStackTrace is not needed.
The printStackTrace is not needed here.
Minor: I don't think this would ever be true.
also could be removed I guess.
also could be removed
java if (extensionFeature instanceof EReference) {
java if (extensionFeature!= null && description.isMany()) {
java not null
Can you import java.nio.file.Paths.get(config.getDockerHost().dockerCertPath())
Can't we just import java.nio.file.Paths?
Can't we just use a class-level constant?
use the constructor - and provide an entry-set in the constructor - and you could use the error for different states - and provide an entry with the old parameters - and you could update them with different defaults
use the constructor - and provide an entry-set in the constructor - and you could use the error for different states - and provide an entry with the old parameters
use the constructor - and provide an entry-set in the constructor - and you could update the parameters as well
@barbeau I would expect a leak of this method: private @CheckForNull private Object getElementToHighlightAtPosition(View element, int x, int y, Rect bounds) { if (element instanceof ViewGroup) { final ViewGroup vg = (ViewGroup) element; return vg.getChildCount(); } }
@barbeau I would expect a leak of this method: private @CheckForNull private Object getElementToHighlightAtPosition(View element, int x, int y, Rect bounds) { if (element instanceof ViewGroup) { final ViewGroup vg = (ViewGroup) element;... } }
@barbeau I would expect a leak of this method: public Object getElementToHighlightAtPosition(View element, int x, int y, Rect bounds) { if (element instanceof ViewGroup) { final ViewGroup vg = (ViewGroup) element;... } }
This is a problem, but please call value.trim() instead of doing String.split(;). We can prevent concurrent calls to String.split() on the same object.
This is a problem, but please call value.trim() instead of doing String.split(;). We can prevent concurrent calls to String.split() on the same value.
This is a problem, but please call value.trim() instead of doing String.split(;). We can prevent concurrent calls to String.split() on the same object. (The same for the other method)
Should we still keep this project (the abstract projecT) query here? Or should we look for all modules?
Should we still keep this project (the abstract projecT) query here? Or should we look for all repositorys still here?
@mcivantos-tribalyte _if_ we should still keep this project (the abstract projecT) to AbstractTsResponse.
Static import?
Static import
Static import.
shouldn't we be using deleteOnExit() here?
shouldn't we have a deleteOnExit() here?
shouldn't we have a deleteOnExit() here to ensure it works?
Should this be debug level?
This should be debug level.
Maybe ContainerHeader should be renamed.
Shouldn't we remove the Realm and its management files?
Shouldn't we remove the Realm and its management files from the sharedRealm?
Shouldn't we remove the Realm and its management file?
Why remove the Scattered stuff from addClusterEnabledCacheManager?
I think you no longer need to execute addClusterEnabledCacheManager(gcb, cb) now.
I think you no longer need to execute addClusterEnabledCacheManager(gcb, cb) here.
Store concept in var outside of loop
Store this in a variable instead of calling it multiple times
Store this in local variable outside the loop
Please add to the storage domain so the user easily what the storage was from. You could use an other way around to checking whether the entity was correctly loaded. Please add a check here as well.
Please add to the storage domain so the user easily what the storage was from. You could use a generic form of Renderer<StorageQos>. Please add it here.
Please add to the storage domain so the user easily what the storage was from. You could use an other way around to checking whether the entity was correctly loaded. Please add a check here as for if false
Could be static
Could it be cached?
Could be static?
Does it log the correct data, let's only log this when we can have a logging level => trace? If not log level should be important.
Does it log the correct data, let's only log this when we can have a logging level => trace?
Does it log the correct data, let's only log this when we can have a log (if it is common)
Minor: there is a static import for fail() method.
Minor: you could use AsyncUtil.closeAll instead of multiple flakiness.
Minor: you could use FunctionalUtils.blockFutures.makeFuture(Future) for this
If this array isn't meant to be modified afRequirements instance will be modified aftewards, which will have better read performance (and no potential synchronization issues).
If this array isn't meant to be modified afRequirements instance will be modified aftewards, which will have better read performance (and no potential race conditions).
If this array isn't meant to be modified afRequirements instance would be better put the checks inside the if block
Save as... --> Saved in AbstractBoardSaveAs
Save as... "Save as..."
Save as... --> Saved? Seems like there's a better way to do this, and we shouldn't have to iterate over the panels and triggerEvent.
This test and the test before would be more interesting if just the "id" parameter were changed.
This is also used in VariantMongoWriter, is that intentional?
This should also use JobParametersNames.
As far as I understand, but is there any way to check for wpsgluster ranges? You don't need to add any setting here.
As far as I understand, but is there any way to check for wpsgluster ranges? You don't need to add any additional setting here.
As far as I understand, but is there any way to check for wpsgluster ranges (like Strings)? You don't need to add any additional setting here.
There should be a test for elemMatch.get()
There should be a test for elemMatch.getHostId().
insert a dataset field in DB and call this method from here.
I think it would be simpler to maintain this loop: for (int i = 1; i < expression.getExpressions().size(); i++) { expression.append(","); expression.getExpressions().get(i).accept(this); }
I think it would be simpler to maintain this loop: for (int i = 1; i < expression.getExpressions().size(); i++) { expression.append(","); expression.getExpressions().get(i).accept(this); } }
I think it would be simpler to maintain this loop: for (int i = 1; i < expression.getExpressions().size(); i++) { expression.append(","); expression.getExpressions().get(i).accept(this); } } if (!hasExpressions) { // No special case }
why is shutdownNow necessary?
why is isOpen not volatile?
Why is shutdownNow necessary?
Shouldn't we have a timeout here?
Shouldn't we have a static variable for this?
Shouldn't we have a static method with the lock, and remove this?
As mentioned in PR 1841 I'm not a fan of this code duplication, I think it would be more readable to extract it to a common method.
As mentioned in PR 1841 I'm not a fan of this code duplication, I think it would be more straightforward to add it in this patch.
As mentioned in PR 1841 I'm not a fan of this code duplication.
I think you should use something like this as well: java users.entrySet().stream().filter(entry -> entry.getValue().getRoundedOneMinuteRate() >= mean).forEach(entry -> entry.getValue().max( desiredMean));
I think you should use something like below: java List<String> users = users.entrySet().stream().filter(entry -> entry.getValue().getRoundedOneMinuteRate() >= mean).forEach(entry -> entry.getValue().max( desiredMean));
I think you should use something like this as well: java users.entrySet().stream().filter(entry -> entry.getValue().getRoundedOneMinuteRate() >= mean).forEach(entry -> entry.getValue().max( desiredMean, 0);
Should the test be!isMax?? In general, you should always take null if the validation is true. In fact, no need to fix the test if (isMax )
Should the test be!isMax?? In general, you should always take null if the validation is true. In fact, no need to fix the test if (boolean isMax )
Should the test be!isMax?? In general, you should always take null if the validation is enabled :(
Why not to get it once?
Why not to get it once? Besides, if we don't need to get it once..
Why not to get it once? Besides, if we don't need to get it once.
Unnecessary empty line.
no need to delete these
no need to delete these.
use {} syntax for LOG statements
use {} syntax for logging
use {}
This is practically identical to the implementation. How about abstracting it out?
Is this really necessary?
Would this be clearer as the expect of the two lines below instead of the declaration.
I'd like to avoid batch += here instead of +
I'd prefer batch +=
I'd rename batch to something more generic
It is easy to think that the rest of the method is part of this class. Try to always use braces, even if the body is empty: if (this) { // Empty on purpose. }
It is easy to think that the rest of the method is part of this class. Try to always use braces, even if the body is empty: if (true) { // Empty on purpose. }
It is easy to think that the rest of the method is part of this class. Try to always use 'this' instead, though.
you should use <kMeansFile> [kmeansFile] <kApplyFile> <kApplyFile>
you should use <kMeansFile> here
you should use <kMeansFile> </kMeansFile>
log.tracef
logging.tracef
log.debugf
I'm not sure whether there's implications at run time if returnExpression is not exactly the same as the given returnExpression. Is there valid reasons that we don't want to handle multiple return types?
I'm not sure whether there's implications at run time if returnExpression is not exactly the same as the return type. Is there valid reasons that we don't want to handle the return type of body?
I'm not sure whether there's implications at run time if returnExpression is not exactly the same as the given returnExpression. Is there valid reasons that we don't want to handle the return type of body?
There's a method you can use for this.
There's a method you can use for this..
There's a method you can use instead of argThat()
Please use config.getProxyPort().toCharArray()
Please use config.getProxyPort() which returns the default value
Please use config.getProxyPort() which introduces the default value
We should probably just return a more meaningful message here. We may want to change the message to "Could not create cookie".
We should probably just return a Set<Cookie>, no?
We should probably just return a new set.
Does it make sense to track tokens in a header?
Does it work if csrfTokenFromCookie is null?
Does it work if csrfTokenFromCookie is null before using it?
UndefinedDatabaseException should be handled.
UndefinedDatabaseException should be handled. In addition, DuplicateTableException is already handled.
UndefinedDatabaseException should be handled. In addition, DuplicateTableException is never thrown.
I don't think this is valid anymore (along with an IndexOutOfBoundException). No need to check for nulls, they can't be null.
I don't think this is valid anymore (along with an IndexOutOfBoundException). No need to check for null here.
I don't think this is valid anymore (along with an IndexOutOfBoundException) check. Does it?
Why not only instance = generic == null? DiamondOperatorCheck.TYPE_ARGUMENTS : DiamondOperatorCheck.getLastChild().getString();
Why not only instance = generic == null? DiamondOperatorCheck.TYPE_ARGUMENTS : DiamondOperatorCheck.getLastChild().getType();
+1 violation message, not only error message
instead of adding a map to the map, would it be better to use get instead?
instead of adding a map to the map, would it be better to use get instead of the whole if?
instead of adding a map to the map, would it be better to do the check here?
can't you reuse the ILaunchConfigConfigurator instance in the test?
you can't ignore a 'e'
can't you reuse the ILaunchConfigConfigurator instance in the plugin itself?
This test is not executed because USER_AGENT_INTERCEPTOR is an internal detail of the User-Agent header. Instead it would be be completely safe to do: java Field uaField = uaField.getDeclaredField("userAgent"); uaField.thenReturn(userAgentHeader); uaField.set(userAgentHeader);
This test is not executed because USER_AGENT_INTERCEPTOR is an internal detail of the User-Agent header. Instead it would be be completely safe to do: java Field uaField = uaField.getDeclaredField("userAgent"); uaField.thenReturn(userAgentHeader);... uaField.get(userAgentHeader);
This test is not executed because USER_AGENT_INTERCEPTOR is an internal detail of the User-Agent header. Instead it would be be completely safe to do: java Field uaField = uaField.getDeclaredField("userAgent"); uaField.assertTrue("The value of User-Agent header: " + userAgentHeader);
If you want to log this message, move the request to the throttle timed out message.
If you are using.toString() on the log level, this is probably not the right log level.
If you are using.toString() on the log level, this is probably not the right term.
suggestion var value = new ArrayList<>();
suggestion var value = new ArrayList<String>();
suggestion var value = new ArrayList<>(); (If we are not needed :-)
Isn't this & logic is correct? and and where is the flag should be unset?
Isn't this guaranteed to be the same and has the same ByteBuf everything the way you use?
Isn't this & logic is correct? and and where is the &?
Use getPath() to make it more clean
Use getPath() to make it more readable.
Use getPath() to make it a bit more clean
Unhandled
nit - I think throwing an AssertionError is more appropriate.
nit - I think throwing an exception is more appropriate.
Can we please have a unit test for this?
Can we please have a unit test to cover this?
Why public? Please refer to this internal method only.
I don't see the need for this 3 lines as well.
I don't see the need for the 3rd argument
I don't see the need for the 3rd argument here.
Are we sure we don't need to use Type.cast() here?
Are we sure we don't need to use Type.cast when creating the patient?
Are we sure we don't need to use Type when creating the patient?
This may be move to another method because we can't return anything in this case, which is not how we want.
This may be move to another method because we can't return anything in this case, which is not in this test.
This may be move to another method because we can't return anything in this case, which is not required.
Change this to private.
Why is this necessary?
Change this to enum.
Don't need a line break here as well.
If we throw an exception, why not return "";?
Do we need a function to check this?
printing stack trace is not necessary
printing stack trace seems not necessary
printing stack trace is not needed
Should be x1 and y2 as variables.
Should be x1 and y2 as variables to make it clearer
Yup
Can you put a util method for this?
In this case, don't we have a toString() method?
In this case you don't need to change the Configuration in the client.
Can you rename these to function names?
Can you rename these to function?
Can you rename this function to listObjects?
Would a List now be enough?
Would a List<String> be sufficient?
Would a List<String> be enough?
Please add a note about why MySQL, Oracle and Hibernate 4.2 and 4.3 aren't supported.
Please add a note about why MySQL, Oracle and Hibernate 4.2 and 4.3 aren't allowed.
Please add a note about why MySQL, Oracle and Hibernate 4.2 and 4.3 aren't supported. This is the most common test
I would add the realm name to the add operation, since it launches the operation.
I would add it as an element of the addOperation and do something if there are no realms.
I would add it as an element of the addOperation and do something if there was a problem with this check.
Missing final
You should use the equals method, no?
You should use the Guard class.
You could use constants here, like SERVICES_DIRECTORY, org.apache.libaba.io.Filesystem.java
You could use the constant here, like SERVICES_DIRECTORY with the name you use in the.java file.
You could use constants here, like SERVICES_DIRECTORY, org.apache.libaba.io.Filesystem.api.namespace.java
awaitRetentionExpiration(500L); -> awaitRetentionExpiration(500L);
awaitRetentionExpiration(500L); -> awaitRetentionExpiration(1_000);
awaitRetentionExpiration(500L); and awaitRetentionExpiration(500L); to work the same.
There is a null check for context in the constructor.
There is a null check on parentActivity here.
There is a null check on context() inside this method.
Is this dependent on the computer's time zone?
Is this dependent on your computer's time zone?
Is this dependent of the computer's time zone?
This should use Locale.ROOT in most cases.
if you use String.format(String, String)
if you use String.format()
I think cheProjects.add(project.getMetadata().getName()) is better here.
I think cheProjects.add(project.getMetadata().getName()) should be replaced with project.addAll(project.getName())
I think cheProjects.add(project.getMetadata().getName()) should work better here.
can you add a constant to include tagsToSkip as constants?
Can you make this a bit more readable?
can you add a constant to include tagsToSkip as a static final variable
Remove this loop
Should use T[]
this list can be cached
Remove this
Remove empty line
Remove
Why only the first field? One could just use md.getCaseInsensitiveIndexes(md.getEntityInfo().getIndexes())
Why only the first field? All things need to be done in populateHiddenFields()-method.
Why only the first field? All things need to be done on the fly.
This will break logging again: LeasedLockToken is not loggable by our logging infra. So either get rid of the args in this logline or figure out how to collect the stuff you need in a way that's loggable.
This will break logging again: LeasedLockToken is not loggable by our logging infra. So either get rid of the LeasedLockToken variable or figure out how to collect it in a logline that is loggable.
This will break logging again: LeasedLockToken is not loggable by our logging infra. So either get rid of the LeasedLockToken variable or use something similar.
null check
extraneous super call, can be removed
extraneous super-line
Missing final
Not a biggie but, even better to use "BeanInfo".
Not a biggie but, even better to use a constant?
IdeaPatcher is now generic. Can you rename to log4j?
IdeaPatcher is now generic. Can you rename it to log?
IdeaPatcher is now generic. Can you rename it to fixResolve?
multiple occurrences of "response"
Same here, why not boolean?
Same as above, this should be Boolean
This solution still does this lookup and these tests potentially many times for the same parent project. And although you know will limit the returned values, you are still incurring the cost of iterating over every project here!
This solution still does this lookup and these tests potentially many times for the same parent task. And although you know will limit the returned values, you are still incurring the cost of iterating over every project here!
This solution still does this lookup and these tests potentially many times for the same parent project. And although you know will limit the returned values, you are still incurring the cost of iterating over all projects.
if ttl is specified, then log a warning rather than siliently ignore? Could even throw invalid exception given that only either delete or ttl should mutate in a request? Should MessageInfo offer a constructor that does not require TTL so that 'unset' TTL is hidden behind its interface? 0 or -ive TTL seems like implementation details that should not be required in the interface.
if ttl is specified, then log a warning rather than siliently ignore? Could even throw invalid exception given that only either all retries are covered? Should MessageInfo offer a constructor that does not require TTL so that 'unset' TTL is hidden behind its interface? 0 or -ive TTL seems like implementation details that should not be required in the interface.
if ttl is specified, then log a warning rather than siliently ignore? Could even throw invalid exception given that only either all path entries get stored in the request? Should MessageInfo offer a constructor that does not require TTL so that 'unset' TTL is hidden behind its interface? 0 or -ive TTL seems like implementation details that should not be required in the interface.
Here you could just do: if (type == 4000) { return; }
There is no need to have an empty line here.
Here you could just do.checkImportedModel().
Can you collapse this if statement into a method call? (if it's used only here, ;)
Can you collapse this if statement into a method call? (if it's used only here, )
Can you collapse this if statement into a method call? (if it's used only here, ;))
It is getId() of the pool -- see the other Tracer invocations
It is getId() twice, Tracer.loadConnection() can be called twice.
It is getId() twice, Tracer.getManagedConnection() can be null.
Do we really need to modify the topologyDescriptor? I mean, the topologyDescriptor only is populated with the activebys map.
Since the topologyDescriptor contains standbys, I guess we can change the topologyDescriptor to have a new topologyConfigId?
Do we really need to modify the topologyDescriptor? I mean, the topologyDescriptor only is populated with the activebys map..
What about calling MockMemoryStore.class.getName()?
Any reason we can't use an ArgumentCaptor here?
Any reason we can't use an instance of ITreeViewer?
it seems like we should be throwing this exception
it seems like we should be throwing this MotechSchedulerException only if there is an error.
it seems like we should be able to obtain this from the scheduler without a job.
I think it would be better to have a matches method of the Groups here, in order to override the Group.
I think it would be better to have a matches method of the Groups here, in order to override the Group. This can be done by calling ReferenceCountUtil.findGroups().
I think it would be better to have a matches method of the Groups here, which returns a list of Groups.
Use a constant for the "magic number" value.
Use a constant for 99.0 seems so high.
Use a static constant for the "magic number".
minor: change expense of arg list to exc, since exploration an argument
minor: change expense of arg list to exc, since exploration an identifier on a different server is the case.
minor: change expense of arg list to exc, since exploration an identifier on a different server
How does this now compare to Dockstore-CLI? I'm surprised that this does not compare to Dockstore-CLI. If so, this should be com.github.zafarkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkh
How does this now compare to Dockstore-CLI? I'm surprised that this does not compare to Dockstore-CLI. The proper way to do this would be to use the com.github.zafarkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkh
How does this now compare to Dockstore-CLI? I'm surprised that this does not compare to Dockstore-CLI. The proper way to do this would be to use the com.github.za18khkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkhkh
remove
Why do we need to wait for the thread to complete?
Why do we need to wait for the thread while running on the machine?
I feel like you should inject this threadpool, when an internal product instantiates a lot of these it will probably want to reuse the threadpool
I feel like you should inject this threadpool, when an internal product instantiates a lot of these it will probably want to use the threadpool
I think you should inject this threadpool, when an internal product instantiates a lot of these it will probably want to reuse the threadpool
(votes.get() < 0) -> isEmpty()
(votes.get() < 0) -> that is more readable
(votes.get() < 0) -> that is more clear
I have question about this config. Will this determine the serverfactory for ambry-frontend and ambry-server?
I have question about this config. Will this determine the serverfactory for ambry-frontend and ambry-client?
I have question about this config. Will this determine the serverfactory for ambry-frontend and ambry-frontend?
Change this to check input!= null
Is it possible to change this method to private?
Change this to check input!= null.
Shouldn't we check if (e!= null && (e.getCause()!= null && e.getCause() instanceof CancellationException))?
Shouldn't we check if (e!= null && (e instanceof CancellationException || (e.getCause()!= null && e.getCause() instanceof CancellationException))?
Shouldn't we check if (e!= null && (e instanceof CancellationException || (e.getCause()!= null && e.getCause() instanceof CancellationException))) {?
why processProxyReturnValue returns a list? if you can handle the returned returned entity, they will be an empty list
why processProxyReturnValue returns a list? if you can handle the returned returned entity, they will be not populated.
why processProxyReturnValue returns a list? if you can handle the returned returned entity, they will be not being returned.
This error text has no meaning to me, maybe just say "The bank has a country code of Canada. We can't verify that this is the right thing to do."
This error message has no meaning to me, maybe just say "The bank has a country code of Canada. We can't verify that this is the right term?
This error text has no meaning to me, maybe just say "The bank has a country code of Canada. We can't verify that this is the right thing to do?
Use static constant for "ts" in BaseTest.
Use static constant for "ts" in the code.
Use static constant for readability.
"o1" should be the first parameter in the method parameter, not the last
"o1" should be equal, not equals
"o1" should be the first parameter in the method.
I think we can actually simplify this code further. It should be: java if (insidews) { //... } else { //... }
I think we can actually simplify this code further. It should be: java if (insidews) { // skip the current dir dir }
I think we can actually simplify this code further. It should be: java if (insidews) { // skip the current dir }
Same nit: don't need to add a throws here since you catch the IOException anyway.
Same nit: don't need to add a throws here since you catch the IOException
What kind of exceptions are expected in the new DownloadResponse?
Do we need to wait for the event here?
Do we need to close the processor thread here?
Do we need to wait for the thread to complete?
nit: the if statement is good, since the iterator initialization is in an atomic operation.
nit: the if statement is good, but please use 'this.' to keep the style consistent
nit: the if statement is good, but please use 'this.'
Did you mean to use the following? java ClientRegistration.Builder builder = suppliers.stream().map(ClientRegistration::build).collect(Collectors.toList());
suggestion throw new IllegalArgumentException(errorMessage, e);
Did you mean to use the following? java ClientRegistration.Builder builder = supplier.get(); return builder.get();
I think the logic here is the same as ongoingSyncs.remove. We should wait for the routingTableUpdate.
I think the logic here is the same as ongoingSyncs.remove. We should wait for the routingTableUpdate parameter as well.
I think the current behavior is to check whether the map exists and if it does not contain the old owner, we should throw a RuntimeException here.
Minor: TIMEOUT too may be a better fit for timeout
Minor: TIMEOUT too may be a better fit for timeout here
Minor: TIMEOUT too may be a better fit for the timeout
if dataCenterTokAddress is null, we don't need to handle it.
if dataCenterTokAddress is null, the conversion to a Map<String, String> would be sufficient.
if dataCenterTokAddress is null, the conversion to a Map<String, String> would be unnecessary.
Magic number
It would be nice to have a test with a number of the same size that can be set by test.
It would be nice to have a test with a number of the same size that can be set via assertion method.
why is this check necessary?
why this check?
why is this check here?
Please use org.eclipse.swt.events.SelectionUtil.widgetSelectedAdapter(Consumer) and simply set selection to null. This is needed here.
Please use org.eclipse.swt.events.SelectionUtil.widgetSelectedAdapter(Consumer) and simply set selection to null when element is nonnull. This is not what we want.
Please use org.eclipse.swt.events.SelectionUtil.widgetSelectedAdapter(Consumer) and simply set selection to null when element is nonnull. This is not what we do in the consumer implementation.
Is it possible to remove this? In the future couldn't _read_ the name of the field "id" is longer than the name of the field "id"?
Is it possible to remove this? In the future couldn't _read_ the name of the field "id"?
Is it possible to remove this? In the future couldn't collapse it?
typo: you have two "DEFAULT" and " 60" in them
typo
typo on these 2
Nit: space before )
Use assertEquals instead of == operator combined with assertFalse
Nit: space before ) {
Should be NonNull at the beginning of the method.
NPE?
Should be the last param in the method signature.
you can keep this code after you are closing the 429 code block
you can keep this code after you are handling the 429 code block
you can remove this line.
Break into two lines.
Break into 2 lines.
Redundant parentheses
I think this will do more gracefully than throw an exception. Can you guard this with a check?
I think this will do more gracefully than throw an exception. Can you check if this is in finally?
I think this is just missing a retry.
we just call this "addImportsTab" on oracleFactory.makeAsyncPackageDataModelOracle()
we just call this "addImportsTab" on oracleFactory.makeAsyncPackageDataModelOracle"
we should also init the ross
autoClose means that invoking SshAgentTlsClient should be closed. Do we need to close the created object?
autoClose means that invoking SshAgentTlsClient should be created with an empty list. Do we need to close the created object?
autoClose means that invoking SshAgentTlsClient should be created with an empty list. Do we need to close all of the created objects?
Please use ellipsis.newSize() instead of these two lines
Please use ellipsis.newSize() instead of these three lines
Please inline this such as two-liners.
This can be removed
This is not necessary
This is not necessary.
Should we check for null here?
Should we check for null anywhere?
Should we check for null somewhere?
we can avoid this String concatenation
We can in theory do we want to log this as error?
we can avoid this final
Is it necessary to just put if (project == null ||!project.hasPermission(Item.CONFIGURE)) { return null; }
Is it possible to just put if (project == null ||!project.hasPermission(Item.CONFIGURE)) { return null; }
Can you put if (jenkins == null ||!project.hasPermission(Item.CONFIGURE)) { return null; }
I think this is a bug, it should be able to set the JVMOption to false in the constructor.
I think this is a bug, it should be able to set the JVMOption to false in the constructor rather than the default constructor.
I think this is a bug, it should be able to set the JVMOption to false in the constructor rather than here.
Does this need to be public?
I think we need to close the query too here.
This needs to be static final
Should we just always use a boolean to indicate whether it's a valid peer?
Should we just set a boolean (e.g. true, false)?
Should we just always use a boolean here?
do we really need to wait for it?
do we need a timeout to wait for it?
do we really need a timeout? we should test the case that it is not.
Should it be removed if you're not adding this local variable?
Should it be removed if you're not adding this DC as the master?
what's the purpose of this if?
This seems like a hack to refactor the kerberosRealm.getRedirectParam() logic into a separate class. It would be nice if it is also used in 3 places where we would be handling the redirect.
This seems like a hack to refactor the kerberosRealm.getRedirectParam() implementation into a separate class. It would be better to just have the URL as a parameter.
This seems like a hack to refactor the kerberosRealm.getRedirectParam() logic into a separate class. It would be nice if it is also used in 3 places.
Why do you wrap it with an ArrayList and not just return the result?
Why do you wrap it with an ArrayList and not just return the result directly?
Why do you wrap it with an if-statement?
Why is this needed? I think you can leave it to the system time thing.
Why is this needed? I'd rather remove the if-else statement
Two minutes.
Prefer DirDir = "target/ + desc.getClassName() + "/" + filename.
Prefer getClass().getSimpleName() instead of hard-coding the class name.
Prefer DirDir.ROOT_PATH instead of "/" + desc.getClassName()
I think this could be more UItests than the integration tests.
I'm not sure this is the correct approach. Open trace, open the view, make sure that file is deleted.
I think this could be more readeable. this should test only if trace is not deleted.
We should probably use the separator for the slashes in the /stor/multipart string as well.
We should probably use the separator for the slashes in the./stor/multipart string as well.
We should probably use the separator for slashes in the /stor/multipart string as well.
This is actually a suggestion for (lockRequest -> await(lock.unlock())):.thenApply(tryLockRequest -> await(lock.unlock());
This is actually a suggestion for (lockRequest -> await(lock.unlock())):.thenApply(tryLockRequest -> await(lock.unlock()))
This is actually a suggestion for (lockRequest -> await(lock.unlock())):.thenApply(tryLockRequest -> await(lock.unlock()));
Move this condition higher
Move this condition higher in the code
Move this condition higher.
this is already a string, no need to initialize it again
this is already a string, no need to initialize it first.
this is already a string, no need to initialize it twice
can we avoid this listener and just call cancelDeferred(new IEventListener() {... }?
can we avoid this listener and just call cancelDeferred(new IEventListener() {... }?
can we avoid this listener?
This could throw an exception?
This is an internal issue.
This is an internal bug.
This seems to be failing compilation.
This seems to have been failing compilation.
Same nit about this check.
This two lines of code can be combined into one.
This two lines can be combined into one.
This two lines of code is repeated several times. Can we create helper methods?
can we rename the string -> docId for more clarity
can we rename the string -> docId for better readability
can we rename the string -> docIds for more clarity
this should be log.trace("Delete successful. Transaction url: {}.", elementId, e);
this is not a debug message
this should be log.trace(
What is the purpose of this line?
What about adding a new view on the line above and not taking into account the extra space?
What about adding a new view on the line above and not taking into account the space?
I'm confused by the error message. Does it make sense to have a function namespace manager for which the function namespace manager is registered?
I'm confused by the error message. Does it make sense to have a function namespace manager for which this catalog catalog is registered?
I'm confused by the error message. Does it make sense to have a function namespace manager for which this catalog is registered?
Can we rename exception to KafkaConnectionException or KafkaConnectionException?
Can we rename exception to KafkaConnectionException or something more meaningful?
Can we rename it to INVALID_PARTITION_FAILED
name1 and name2 are unused now.
name1 and name2 should be final.
name1 and name2 are unused
Should this be closed?
Should this be closed above the closer?
Should this be closed *after* the closer.
Why does this need to be public?
Why is this an IllegalStateException?
Why this statement?
Can you update the name of the variable to indicate what it is going to be?
Can you update the name of the variable to indicate what it is going to be used?
Can you update the name of the test class, to make it a bit more descriptive?
This text should not be externalized
This text should be externalized
this text should not be externalized
Response is never closed
Resource leak.
Response is not closed
This should be my PR too.
This should be removed
Should be removed
This probably isn't needed, unless we click on it?
This probably isn't necessary, unless we click on it?
This probably isn't needed at all.
It seems like this validation code is duplication of the existing check. Is it?
It seems like this should be: fqdn.
It seems like this validation code is duplication of the existing check above. Is it?
This looks like it should just be an "else if" since it's only a single item.
This looks like it should just be an "else if" since it is only ever a "else".
This looks like it should just be an "else if"?
Please don't change this line
Please don't change this for loop. We always use totalRuntime as a default.
Please don't change this method.
c instead of.next() for Connection?
c instead of s here for Connection?
c?
You might want to change that 3 to a constant and a proper value. The logic is duplicated 3 times.
You might want to change that 3 to a constant and a proper value. If not, then perhaps a good idea to change it.
You might want to change that 3 to a constant and a proper value. If not, then any reason not to use constants with them.
I would add this line before line 134, so we first fetch the LunDisk and from it we will fetch the lun.
cleaner way: return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_INVALID_CONNECTION_PARAMS);
cleaner way: return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_INVALID_REFRESH_STORAGE);
I'm not sure why you're not using the same message here..
I'm not sure why you're not using the same message..
I'd move the condition to the beginning of the method.
I think it would be better to have a lambda here: java public void runKerberosLogin() { scheduledExecutorService.schedule(this, getTimeAsMs(getKerberosRefreshInterval()), TimeUnit.MILLISECONDS); }
I think it would be better to have a lambda here: java private CompletableFuture<Void> runKerberosLogin() { scheduledExecutorService.schedule(this, getTimeAsMs(getKerberosRefreshInterval()), TimeUnit.MILLISECONDS); } I'm not sure why a lambda is needed here.
is it necessary to have the runnable to runKerberosLogin()?
Consider using parameterized logging instead of string concatenation.
debug/trace/remove?
Consider using parameterized logging instead of string concatenation
the switch case should be moved to TypeResolver.get().detectBrowserPlugin()
the switch statement is not needed.
the switch case should not be needed.
You can also use TextUtils.isEmpty(mSitePickerMode) here.
Hmm, is there any way to make the mHashSelectedPositions final or maybe we can also try to insert the items directly from the database? I think we need to consider a new option to show the items.
You can also use TextUtils.isEmpty(getIntent()) here.
while you're at it, could you please move the above Window.open into the else branch?
while you're at it, why the above code?
while you're at it, please introduce a timeout to receive the Status message in the else branch.
Same question as above. Will this make your use case for multiple transitions?
Same question as above. Will this make your use case for multiple threads?
Same question as above. Will it make sense to use an empty exit point here?
Doesn't look like this is used
L10651067 can be removed.
Doesn't look like this is meant
nit: can you make this one line?
It will be obvious if totalDuplicatePutRecords is null or totalDuplicatePutRecords.
nit: can you make this one line
maybe better to keep this as info level since we are not interested in the thread
maybe better to keep this as info level as we are not interested in the future
can we keep this log?
This is essentially the same as the base class. It would be cleaner to introduce a new JobDetails(Action.Status, ExecutionState) which also returns the interval.
This is essentially the same as the base class. It would be cleaner to introduce a new JobDetails(Action.Status, ExecutionState.Status, status) which also returns the interval.
This is kind of confusing. Let's discuss it.
Is there a reason why this method is removed?
Is there a reason why this is removed?
WeightProvider.Descriptor descriptor = element.getAttribute(ATT_CLASS);
The resource folder could be found in the XML file://. I would a log warning.
The resource folder could be found in the XML file://. I would a log.warn.
The resource folder could be found in the XML file system
I thought our talk offline approach to avoid using the "service reference" logic [here](<LINK_0>
I thought our talk offline approach to avoid using the "service-" template that's not something I care about.
I thought our talk offline approach to avoid using the "service-" template that's not something I've seen.
Why is this change needed?
Why not use Collections.emptySet() here?
Why not public?
I think it would be nicer if we had a method like: java /** * Returns the input stream * @param retryAfter <code>@CheckForNull</code> or public HttpConnectionInterceptorContext createAuthenticationRequest(HttpConnectionInterceptorContext context) { try { return context.getState(this, "attempt", Integer.MAX_VALUE); } catch (InterruptedException e) { LOG.log(e.getMessage(), e); } } }
I think it would be nicer if we had a method like: java /** * Returns the input stream * @param retryAfter <code>@CheckForNull</code> or public HttpConnectionInterceptorContext createAuthenticationRequest(HttpConnectionInterceptorContext context) { try { return context.getState(this, "attempt", Integer.MAX_VALUE); } catch (InterruptedException e) { LOG.log(e.getMessage(), e); } }
I think it would be nicer if we had a method like: java /** * Returns the input stream * @param retryAfter <code>@CheckForNull</code> or public HttpConnectionInterceptorContext createAuthenticationRequest(HttpConnectionInterceptorContext context) { try { return context.getState(this, "attempt", Integer.MAX_VALUE); } catch (InterruptedException e) { LOG.log(e.getMessage(), e); } }, ); }
Use fail again.
fail again.
use fail again.
This line can do with : if (protection!= null) {
This line could do with : if (protection!= null) {
Any reason why you are getting this inside of the if statement?
not sure if this should be a DatagramWriter
not sure if this should be public or not, if it should be protected.
not sure if this should be a DatagramWriter.
I don't see any waits to be woken up by this notify?
I don't see any waits to be woken up by this notify? Is it possible to get an empty list like this?
I don't see any waits to be woken up by this notify!
I think that you need to check that the attribute is not mapped by this point. It is the responsibility of the entity to get the value if the attribute is not mapped using a value. If the attribute is not mapped by this point, it always returns the value.
I think that you need to check that the attribute is not mapped by this point. It is the responsibility of the entity to get the value if the attribute is not mapped using a value. If the attribute is not mapped by this point, it always returns the value which is not mapped.
I think that you need to check that the attribute is not mapped by this point. It is the responsibility of the entity to get the value if the attribute is not mapped using a value. If the attribute is not mapped by this point, it always returns the value, but it contains the value which is not mapped.
You're checking for tuple == null - you should, too, use!symbol.isEmpty(). Also, you're checking for null on the left side of the expression.size() > position - you should use!expression.isEmpty().
You're checking for tuple == null - you should, too, use!symbol.isEmpty(). Also, you're checking for null on the expressionList.size - position.equals(expression)
You're checking for tuple == null - you should, too, avoid checking! tuple.isEmpty(). Also, you can use ContainerUtil.isEmpty()
It's confusing to have the config file in a different way. How about "Config file does not exist:..."?
It feels like you're setting the same property here... is there a reason to have it initialized here?
It feels like you're setting the same property here...
Looks like you're missing a return in this case.
Looks like you are missing a return in this case.
Looks like you're missing a return in here.
Minor: I'd personally prefer moving this inside the switch block.
Minor: Is it correct that "result" is not DISTINCT?
Couldn't you personally set it to true only, then?
This is very fragile. If you find the metric by MetricDefinition then they are going to be equal.
This can be moved outside the if
This can be moved outside the if statement
ugh, blocking ALL insertions while you're iterating on the whole thing to do a query would be a huge slowdown. There needs to be locking in here, but it's really something that would be abstracted nicely in a "BufferedBlockingQueue" class.
ugh, blocking ALL insertions while you're iterating on the whole thing to do a query would be a huge slowdown. There needs to be locking in here, but it's really something that would be abstracted nicely in a simple loop.
ugh, blocking ALL insertions while you're iterating on it, but it's really something that would be a better approach
Will this result in any case?
final
final?
remove useless blank line
remove useless blank lines
remove blank line
Use %s rather than %s unless you need specific formatting like %02d. It's safer since it works for any type.
Use %s rather than %d unless you need specific formatting like %02d. It's safer since it works for any type.
Use %s rather than %s
This could be factored out to a function as well.
This could be factored out into a method as well.
This could be factored out into a function as well.
It seems that the toString() is not necessary anymore.
It seems like the toString is not necessary anymore.
It seems that the toString() is not necessary anymore?
Shall we move this to a private method and make this method private?
Shall we move this to a private method and make this code more readable?
Shall we move this to a private method and make this code more readable?
Might want to check if the new bitmap is being added here, since its always creating a new bitmap when Fedora is not being used.
Might want to check if the new bitmap is being added here, since its always creating a new bitmap on the deposit record
Might want to check if the new bitmap is being added here, since its always creating a new bitmap when Fedora is not being created.
What's the use of this empty line?
You should compare the whole model instance directly, no need to go through the code.
You should use ModelConverterContextImpl(Model)
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
Instead of using String.valueOf(boolean).toString(), just use String.valueOf(boolean)
Instead of using Boolean.valueOf(boolean).toString(), just pass String.valueOf(boolean)
Calling getConfirmStatus() here will throw a NullPointerException.
Calling getDoneStatus() here will remove the finally clause.
Check for null.
This should be a test error.
60000 should be a constant.
60000 should be a constant (also in the test)
I think we should also verify the error message
I think we should also verify the error message.
I'd use equalTo()
The null check can be removed (same for password)
The null check can be removed (same for dictionary), it can be removed (no longer needed).
The content can be replaced with a guard.
this should probably be an error?
this should probably be restricted to an error?
this should probably be an error, right?
Please change this to: if (response.getStatus() == ConfigurationUpdateStatus.SUCCESS) { entityManager.merge(update); }
Please change this to handlePluginConfiguratonUpdateRemoteException(resource, response.getStatus().toString(), response.getErrorMessage()); instead.
Please change this to handlePluginConfiguratonUpdateRemoteException
Any reason to just don't use color color instead of color color?
Any reason to just don't use color color instead of swatchSize?
Any reason to just use color instead of swatchSize?
Why this change?
Why change this?
consider using RLEG
externalize strings
Indeed, it doesn't seem like there is much way to do this, but it doesn't seem like there is much way to do it. Just declare the method in the parent class?
Indeed, it doesn't seem like there is much way to do this, but it doesn't seem like there is much way to do it. Just use a one-arg constructor (maybe in the base class).
You want deadline instead of deadlineName
You're not checking whether this is the deadline instead of the deadline.
You're not checking whether this is the deadline instead of the deadlineName.
@omkreddy can you make similar changes here as well?. I had missed this in <LINK_0>
@omkreddy can you describe the connection here?. I had missed this in the previous review.
@omkreddy can you make similar changes here as well?.
The boolean debug log is not necessary here.
java boolean debug = false;
The boolean debug log is not necessary.
I think the first letter of the test should be Bytes.
I think the first letter of the test is redundant.
use assertFalse
Why do we no longer log it and throw?
Why do we no longer have the authentication extension?
Why is the authentication extension "?
acquireLockInternal() is already called before the if statement, so this message is useless.
acquireLockInternal() is already called before the if statement, so it can be removed.
acquireLockInternal() should be here, before a check
this is because there is no function with a parameter that can be used for this test, i.e., instead of a lambda or something, you can use something like: java.map(p -> p.lateral(p.symbol("1 = a"), p.values(p.symbol("a")))))).matches( project).map(p -> p.symbol("a"))).collect(Collectors.toList());
this is because there is no function with a parameter that can be used for this test, i.e., testing that the error message is what a special case is.
this is because there is no function with a parameter that can be used for the error message instead of a loop.
With this logic, there is no need to fetch the full table first and then check if it is empty. Installation should be the correct approach. Please adjust the above condition. (This must be a workaround.)
With this logic, there is no need to fetch the full table first and then check if it is empty. Installation should be the correct approach. Please adjust the above condition. (This must be a workaround)
With this logic, there is no need to fetch the full table first and then check if it is empty. Installation should be the correct approach. Please adjust the above condition. (This must be a workaround): <LINK_0>
fail
Assert this is redundant, it will already fail the test
Remove this empty line.
This one and the one above could be merged into one catch blocker.
This one and the one below could be merged into one catch blocker.
This one and the one below could be pulled into a method
Minor: Do we need a logger?
Minor: is it worth logging once?
Minor: is it necessary to use System.out?
Let's make it a warn instead of a debug.
1. Let's make it a warn instead of a debug. 2. The error message can be more meaningful here.
1. Let's make it a warn instead of a debug. 2. The error message can be more specific here.
Shouldn't this be specify?
Shouldn't this be specify->user?
Shouldn't this be specify->config?
This is entirely pointless, mDevice is null anyway (not initialized).
This is entirely pointless, mDevice is not initialized.
This is entirely pointless, mDevice is null anyway (not initialized)
The judgmentConfiguration.get(NAME) can return null. We don't have to check it.
The judgmentConfiguration.get(NAME) can return null. We should cover it.
The value of the variable is not used
Random again, I dont think you need to create a new ticket for this.
Random again, I dont think you need to create a new variable for this.
Random again, I know
I think this should be somehow putIfAbsent?
I think we should have an overloaded method that takes the fact.
I think we should have an overloaded method here.
Instead of an explicit if clause could you make it an else if? if (set!= null) { recentSearches.addAll(set); } else { recentSearches.addAll(set); }
Instead of an explicit if clause could you make it an else if? if (set!= null) { recentSearches.addAll(set); }
Instead of an explicit if clause could you make it easier to just create MITAPIClient(getActivity())?
I don't think we should be doing this. In fact, since this is what the Tracer implementation is doing: java public Tracer createTracer(String serviceName) { if ( senderConfiguration == null) { senderConfiguration.withSampler(samplerConfig).getSenderConfiguration(); } else { senderConfiguration.withTraceId128Bit(traceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).with
I don't think we should be doing this. In fact, since this is what the Tracer implementation is doing: java public Tracer createTracer(String serviceName) { if ( senderConfiguration == null) { senderConfiguration.withSampler(samplerConfig).getSenderConfiguration(); } else { senderConfiguration.withTraceId128Bit(traceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit(traceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporter
I don't think we should be doing this. In fact, since this is what the Tracer implementation is doing: java public Tracer createTracer(String serviceName) { if ( senderConfiguration == null) { senderConfiguration.withSampler(samplerConfig.getSenderConfiguration()).withTraceId128Bit(traceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig).withTraceId128Bit).withTracer(reporterConfig).withSampler(samplerConfig
The caller has a higher cost than this else if block. I think this would be better if you sort the list of rows in order to have the same sort sort result. You can keep the range sort as its default order.
The caller has a higher cost than this else if block. I think this would be better off being consistent with the range of rest.
The caller has a higher cost than this else if block. I think this would be better if you sort the list of rows in order to have the same sort sort result. You can have a look at the ShortInstance's fill() method.
Can't we use the getClass().getClassLoader() here?
I'm not sure how to get the URL here. It's used in many places and there's only one.
I'm not sure how to get the URL here. It's used to query the host of the sprite in every request.
Same here. We should make the error message more explicit about what happened.
Same here. We should make the error message more explicit.
Same here. We should make the error message more explicit about what happened, for example, at a later date.
Cache this field.
Cache this.
Cache this value.
modelLine(..) should not return values below -1. This change should not be necessary.
modelLine(..) should not return void. This change causes a null pointer exception.
modelLine(..) should not return values below -1. This change should not be necessary!
just a nit: this should probably make it a helper method like: private static final Set<DataSegment> ACTION_FILE_NAME = "descriptor.json";
just a nit: this should probably make it a helper method like: private static final String EXTENSION_FILE_NAME = "descriptor.json"; and then use it in these 4 places.
just a nit: this should probably make it a helper method like: private static final String EXTENSION_FILE_NAME = "descriptor.json";
Is this the correct way to work on a persisted user? This would be nice to have a backward compatibility check.
Is this the correct way to work on a persisted user? This is correct that the work item is mapped to a blob.
Is this the correct way to work on a persisted user? This is correct that the work item is mapped to a blob, not the model.
using "byte[]" here is unnecessary, because "can getKey()" will return null.
using "byte[]" here is unnecessary because "can getKey()" will return null.
using "byte[]" here is unnecessary, because "can getKey()" returns "null.
Same here. Please take care of adding just ac.
You should use new method please
You should use new method please and it will stay consistent with other methods
It would be nice to remove the.or(String) from here as well
Same issue here (it would be useful to track the upstream history for instance).
It would be nice to remove the.or(String) from the log message
Easier to read if you set the quota time before using it.
Easier to understand if you change the error message to warn?
String.valueOf()
Sorry I didn't realize this part, but I think that it would be more readable to have a variable here.
Sorry I didn't realize this part, but I think that it would be better to have a test that checks firstValue is not null and second is null
unrelated change?
Does this mean that we never add severe policy for mapred implementations?
Does this mean that we never add _load_ feature to _cache_, i.e. if that's false?
Does this mean that we never add _load_ feature to _cache_, i.e. in case of invalid configuration?
Maybe this should be outside the if/else, so that we don't have to do the same if.
Maybe this should be outside the if/else block so that we don't have to do the same things in the request.
Maybe this should be outside the if/else block so that it can be reused for both
nit: Can we assert the number of events, something along the lines of "generated_fetched_Records"
nit: Can we assert the number of events, something along the lines of "generated_fetched_Records" instead?
nit: Can we assert the number of events, something along the lines of: --time.timeout(time.milliseconds()).is(0).get();
Minor: can we pass in ledgerId and use it in argument instead of toString() to avoid unnecessary string creation?
Minor: can we pass in ledgerId and use it in argument instead of toString() to avoid toString()?
Minor: can we pass in ledgerId and use it here as well?
warn. No need for e.printStackTrace()
Excuse me, I'm not sure if it is helpful for us to debug anything at this point...
warn.
please add default to true.
please add some spaces after the =
please add to logger.info.
An alternative is to check null for raisedExpression.is(Tree.Kind.CALL_EXPR) and return.
An alternative would be to check that the raised expression is an instance of HasSymbol.
An alternative would be to check that the raisedExpression is an Expression.
Thoughts on putting this inside of the if block do we want to remove it?
Thoughts on putting this inside of the if (unpairOnDeletion) statement would also make sense. Therefore I think we should remove this block.
Thoughts on putting this inside of the if (unpairOnDeletion) statement would also make sense. Therefore I think we should remove this line.
I think this should be "fail" instead of "error".
I think this should be "fail" instead of "fail".
I think you can have raw string instead of %s and avoid the concatenation
Can this be: java if (unsafeParamNames.isEmpty()) {...
Can this be: java if (unsafeParamNames.isEmpty()) {... }
Can this be: java if (unsafeParamNames.isEmpty()) {
I think this does not handle the case of the deep nesting and very hard to understand. Potentially, this method should be called on the parent class.
I think this does not handle the case of the deep subTypes. Or, we need to do it here.
I think this does not handle the case of the deep nesting and the current sub-types?
there are a few issues with the else clause here: <LINK_0>
there is a temp file in the if statement, and then in the else clause.
there is a temp file in the if statement, and then at the end of that else
Do we need this SystemProperties.set("selinux.reload_policy", "1");?
Do we need this SystemProperties.set("selinux.reload_policy", "1");?
Do we need this SystemProperties.set("selinux.reload_policy", "1");
Remove this System.out.println or replace with log.debug.
Remove this System.out.println, it should be handled using a logger.
Remove this System.out.println, it should be done via a logger.
This probably should be done in the loop as well, or the list of game thread safety issues.
This probably should be done in the loop as well, or at least done a 'while' loop.
This probably should be done in the loop as well, or the list of game thread safety issues with the PRs.
This is confusing. Would it be safe to lock the inputTransformers before running the CDM configuration or CDM configuration?
This is confusing. Would it be safe to lock the inputTransformers before CDM configuration or CDM configuration?
This is confusing. Would it be safe to lock the inputTransformers before running the CDM configuration or CDM-INFO?
Should be "if (!p.isOpen() || projectLocation == null")"
Should be "if (p.isOpen() || projectLocation == null)"
Should be "if (!p.isOpen() || projectLocation == null)"
implement these as follow: this(client.getProfile()).setFirstName("")
implement these kind of operations in RedisTestBase class
implement these as follow: this(client.getProfile())
It should be highestPriorityServers.size() + 1
It should be highestPriorityServers.size() == 0
It should be highestPriorityServers.size()
This should probably be factory.generatePassword instead of factory.generatePassword.
This should probably be factory.generatePassword(clearPassword).
This should throw NullPointerException.
The exception should be logged at WARN level, not info.
The exception should be sent to the log.
The exception should be logged at the end of the application/json.
Should this be initialized when the Kafka transport provider is not set? Or should we initialize it when it is creation?
Should this be initialized when the Kafka transport provider is not set? Or is there a need for this?
Should this be initialized when the Kafka transport provider is not set? Or is it just an artifact of when you create it?
This is definitely not thread safe. There should be a lock here.
This is definitely not thread safe. There are multiple threads running in the same RealmCache, and the synchronization is not atomic because they will make this thread safe.
This is definitely not thread safe. There should be a lock here?
If you use a stream here, you can do: List<BookPage> pages = Arrays.stream(getEntries()).map(entry -> Arrays.stream(getEntries()).collect(Collectors.toList()));
If you use a stream here, better to use forEach
MoreCollectors.toList()
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused private "collectAdminRolesIfAny" method. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this unused private " collectAdminRolesIfAny" method. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this useless assignment to local variable "peerDataException". [![rule](<LINK_1>](<LINK_2>
Thinking out loud, wouldn't it make more sense to use the file creation time, or the last modified file time?
Thinking out loud, wouldn't it make more sense to use a file creation time, or the last modified file time?
Thinking out loud, wouldn't we use the file creation time, or the last modified file time?
this whole block is repeated several times in this class, maybe we can extract it?
Does this need to be Assert.fail()?
this whole block is repeated several times in this file, maybe we can extract it?
It looks like this could be a bit simplified to make it clearer that the DONT_LOAD flag is always passed to the super constructor.
It looks like this could be a bit simplified to make it clearer that the DONT_LOAD flag is always passed to the constructor of SortMergeCommand.
suggestion return false;
can it be null?
Why isn't this if it's empty?
Why isn't this added as a constructor parameter?
Ti nicht?
this whole block
Tiy
This is confusing. Should this be made consistent?
This is confusing. Should it be made lowercase?
This is confusing. Should it be made consistent?
you might want to move this line into the if(url == null) { return new StandardUsernamePasswordCredentialsBuilder().includeMatchingAs(ACL.SYSTEM, Jenkins.getInstance(), StandardUsernamePasswordCredentials.class, URLMatchers.instanceOf(StandardUsernamePasswordCredentials.class)); }
you might want to move this line into the if(url == null) { return new StandardUsernamePasswordCredentialsBuilder().includeMatchingAs(ACL.SYSTEM, Jenkins.getInstance(), StandardUsernamePasswordCredentials.class, url.getUrl()); }
you might want to move this line into the if(url == null) { return new StandardUsernamePasswordCredentialsBuilder().includeMatchingAs(ACL.SYSTEM, site.getUrl(), url.toString()).build(); }
I don't think we need to check for transactional methods here as well.
I don't think we need to check for transactional methods here. We can simply check whether the annotation is present, and the method has to be annotated with @Transactional. If that's the case, then we don't need to check the annotation for transactional methods.
I don't think we need to check for transactional methods here. We can simply check whether the annotation is present, and set it to true.
Do we need the checks both here and in the WindowAgg operator? If this code could handle other definitions already as well I think we could keep with one limitation that is closer to the components that cannot handle other definitions.
Do we need the checks both here and in the WindowAgg operator? If this code could handle other definitions already as well I think we could keep with one limitation that is closer to the components that would have the effect.
Do we need the checks both here and in the WindowAgg operator? If this code could handle other definitions already as well I think we could keep with one limitation that is closer to the components that would handle the 2 expected conditions.
Can we use a lambda here?
Can we use a lambda here? () -> {}
Can be simplified with lambda.
![MINOR](<LINK_2> 'Severity: MINOR') Remove the declaration of thrown exception 'org.hibernate.exception.DotDataException' which is a runtime exception. [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Remove the declaration of thrown exception 'org.jetbrains.annotations.exception.Exception' which is a runtime exception. [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Remove the declaration of thrown exception 'org.hibernate.exception.Util.exception.ProtocolException' which is a runtime exception. [![rule](<LINK_1>](<LINK_0>
It is better to avoid hard-coding the workspace name as it is done in the constructor rather than hard-coding it here
It is better to avoid hard-coding the workspace into the log which is not the same as original recipe.
It is better to avoid hard-coding the workspace name as it is done in the constructor rather than hard-coding it
Don't log exception
Don't log this exception
Remove message
I'd also add the getAdapter method to the WebArtifactUtils for this.
I'd also rename this method to something like isBlobTarget() or isBlobTarget().
I'd also add a new error message to WebResourceNotFoundException for this kind of check.
Could be extracted to a method.
You should be able to just catch NoSuchFieldException here and inside the test method.
You should be able to just catch NoSuchFieldException here.
You can just use a straight-forward 'buffer.remaining()' call (that's more readable)
You can just use a straight-forward 'buffer.remaining()' call (that's more efficient)
You can just use a straight-forward'stream' to shorten the code
i would prefer if (searchPrefix == null) { return; }
i would change historyToken to isMainTab
i would prefer if (searchPrefix == null) { return }
In my opinion, there is a problem with concurrency. It seems that most of the data providers (including the current thread) will be run in parallel with different threads.
In my opinion, there is a problem with concurrency. It seems that most of the data providers (including the current) will be run in parallel with different threads.
In my opinion, there is a problem with concurrency. It seems that most of the data providers (including the current) will be run in parallel with different partitions.
Please use try-with-resources to avoid explicit close()
Please use try-with-resources to avoid explicit close() method.
Please use try-with-resources.
if (count == 0) { return... }
if (count == 0) is more readable in this case
if (count == 0) { return... }?
This footerBuffer could be replaced with a boolean type.
This footerBuffer could be replaced with a boolean argument.
This footerBuffer could be replaced with a boolean type returned. Like, the footerBuffer.initializeBuffer() method, like in the other class.
This should be get(PathAddress address, context.getCurrentRootResource())
This should be get().
This should be getRun on the Resource.
Typo: "Feeds" should be "StateThreadpoolChecked"
Typo: "Rflight"
Line too long.
I think the new approach was fine, but why don't you follow the pattern used in the "ValueExtractorPrism" (here and in the ValueExtractorDescriptor)?
I think the new approach was fine, but why don't you follow the pattern used in the "ValueExtractors" method?
I think the new approach was fine, but why don't you follow the existing pattern and the ValueExtractorDescriptor?
Isn't this already a result?
Nit: looks like we're using this constant and just line 204?
Nit: looks like we're changing the semantics of this method, could you change the following to use proper formatting?
redundant parentheses
suggestion logger.trace("getScenes() called.");
suggestion logger.debug("getScenes() called.");
Why do we set this to final then?
Why do we set this to localhost and not a text?
Why add this?
no need for the exception
catch (Exception e) {... }
no need to log and return null.
I am reading the class again again and I think we do not need sourceIndex anymore
I think we do not need sourceIndex anymore
I think we do not need sourceIndex anymore?
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "indexer1". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "indexer". [![rule](<LINK_2>](<LINK_0>
The second argument of the method just above (indexer2) is not needed here.
Can we have a helper method for this?
Instead of appending row, can we get the ID from the query?
Can we have a helper method for this? _(String)_
suggestion if (status == null || status.startsWith("Pulling from") || status.contains("complete")) {
suggestion if (status == null || status.startsWith("Pulling from") && status.contains("complete")) {
suggestion if (status!= null && status.startsWith("Pulling from") || status.contains("complete")) {
You can use a [ScheduledTask](<LINK_0> instead.
You can use a [ScheduledPipelinePipeline](<LINK_0> to simplify this code.
There is a tab character here.
suggestion List<Object> sourceModels = new ModelDescription(modelType, "3.0.0.SNAPSHOT);
suggestion List<Object> sourceModels = new ModelDescription(modelType, "3.0.0.SNAPSHOT");
Dont sense to call this 'commit' with lastCommit option?
Looks like we no longer need to include the query or the size of the items.
Looks like we always use StringUtils.isEmpty, no?
Looks like we always use StringUtils.isEmpty, no need to use ArrayUtils.reverse
I think the exception should be more like a DotDataException
I think we should log the Identifier or name of the Content Type
I think the exception should be more of a DotDataException
Not worth changing the commit for, but this could also be replay(command, response, cache);
Not worth changing the commit for, but this could also be replay(command, response, cache)
What does this need to be done?
BIGINT -> BIGINT '44'
I don't think we need the filter twice.
I don't think we need the.on(this) here.
Casting is not required here
Casting is not required.
variable not used
This will cause a NullPointerException when entry is null. Better use Indexed<E> Indexed<E>>.
This will cause a NullPointerException when entry is null. Better use Indexed<E>.
This will cause a NullPointerException when entry is null. Better to use Indexed<E>.
This is probably better done in the request method: <LINK_0>
This is probably better done using GateKeeper to create UserType.
This is probably better done using GateKeeper.setBlobstoreService
Use the batch here instead of the batch.
The batch is a no-op. Please use a batch to update the batch.
The batch is a no-op. Please use a try-finally block here.
I think it's cheaper to do the container check only if persistentCaches is enabled, and hopefully it won't complicate the code even more.
I think it's cheaper to do the container check only if persistentCaches is enabled, and hopefully it is not DefaultInterceptorManager
I think it's cheaper to do the container check only if persistentCaches is enabled, and hopefully it is not DefaultInterceptorManager.
this should probably return CreateDirectDebitConnectorCreatePaymentResponse
this should probably return CreateDirectDebitConnectorBuilder
this should be set to true explicitly
What about reading all of them at once and just the one we actually need?
This isn't really all of the affected code systems?
This isn't really all of the affectedCodeSystems, what is the difference?
Nit: I'd have inverted the same here, have the nested instanceof check.
Nit: I'd have inverted the nested ifs here :)
Nit: I'd have inverted the same here, have the complexity of casting.
since we already have the project, shouldn't it be NOT_CONSTANT?
since we already have the project, shouldn't it be NOT_Private?
since we already have the project, shouldn't it be NOT_CONSTANT?
Use the formatter 'if' instead of 'if'
You should be able to use equality checks for node name (and equals instead of length)
You should be able to use equality checks for node name (and cache name).
You could extract this even more info to a constant
does this need to be logged as well?
You could extract this even more info to a constant as you do in the EventBundle
To keep the readability of this method, should the nested if (firstRecordExpression!= null) { firstRecordExpression = firstRecordExpression.getValue(evaluationContext, requestMessage); } if (firstRecordExpression!= null) { firstRecordExpression.intValue(); } else { throw new IllegalArgumentException( String.format("GatewayType '%s' is not supported.", this.gatewayType)); }
I think this can be int firstRecordExpression = 0; and then the else block is redundant.
I think this can be int firstRecordExpression = 0; and then do the instanceof check.
can you please extract this to a constant
can you please extract this to a constant?
can be removed
it's a good idea to have this as a delay so we can be sure the state might be retained.
it's a good idea to have this as a delay so we can be sure the state might be properly created.
it's a good idea to have this as a delay so we can directly use this without blocking
you can use lamdas here too.
you can use lintsIncrementally here too.
you can use lintUtils.k here too.
Please avoid one letter variable, and rename it to something like 'item'
Please avoid one letter variable, and rename it to something like originalMap
Please avoid one letter variable
I'd rename this to - that would be cleaner.
I'd prefer to remove this line, so this is fine.
I'd rename this to - that would be faster :)
Minor nitpicking about size in both cases.
Minor nitpick: byte size is not a valid length for the hash function?
Minor nitpick: byte size is not a valid length for the hash.
Too long
Use android.R.string.ok
Inline
I'm surprised you didn't use a lambda... :p
You're not using a lambda... 'filter.getSelectedItems().isEmpty()' will be more robust (and probably more efficient).
You're not using a lambda... 'filter.getSelectedItems().isEmpty()' will be more robust (and probably more efficient)
This method can be written as: <LINK_0>
This can be done in a single forEach call.
This can be done simpler.
Is there a particular reason for the method to be public if the constructor is only used in this class?
Is there a reason for the change?
Is there a particular reason for calling this method on a separate object? It would be preferable to make a method on vector layer only if all of them are available.
why not just LOG.error()?
why will you ignore the output?
why will you ignore the warning?
This should also not be an error.
This should also be an error.
This does not handle the case when someone replaces the result.
This needs to be a fixed constant.
You can use the new method of adding the target entity here.
You can use the new method of adding the rule to the card.
please replace with: VmDeviceDAO dao = getDbFacade().getVmDeviceDAO(); it will ease mocking when writing tests.
Please replace with: VmDeviceDAO dao = getDbFacade().getVmDeviceDAO(); it will ease mocking when writing tests.
please replace with: VmDeviceDAO dao = dao.getVmDeviceDAO(); it will ease mocking when writing tests.
this could be replaced with: java if (parent.isPresent()) { firstParent = parent.get(); }
this could be replaced with: parent.isPresent() || parent.getRoot()
this could be replaced with: java if (parent.isPresent() && parent.get()) {
I think it will be more robust to useconvertedState.equals(original.getStates())
I think it will be more robust to useconvertedState.equals(original.getStates()) as a default value?
I think the first condition is more explicit.
These are not correct, INSERT is not schema compatible.
These are not correct, INSERT is not schema compatible with equals.
These are not correct, INSERT is not schema compatible with equals to support both.
Change first occurrence to Set
Change first occurrence to 'flatten'.
similar
Please use meaningful variable names.
Please use meaningful variable names. If you want to be more meaningful, better to be able to understand the problem.
Please use meaningful variable names. If you want to be more meaningful, better to be 'error: '
Are we sure we want to un-static-ize this? Can't we get the trace from the EventDefinition?
Are we sure we need to un-static-ize this? Can't we get the trace from the EventDefinition?
Are we sure we want to un-static-ize this? Can't we get the trace from the event definition?
If we can be more specific here, we should find a way to find out why the invalid data is INVALID?
If we can be more specific here, we should find a way to find out why the trailing slash is used.
If we can be more specific here, we should find a way to find out why we are going to find the column.
This test is ok with json assertThat(list).contains("x", Integer.MAX_VALUE).
This test is ok with json assertThat(collection).containsExactly(object2) and other tests are comparing with equals().
This test is ok with FP.
Why not change the message from "Error while loading schema versions for topic {}", topic.getQualifiedName(), e);
Why not change the message from "Error while loading schema versions for topic {}", topic.getQualifiedName(), e.g. SchemaVersionsResponse.failed();
This implies that the topic is loaded, but it's not. This may be the case.
Please use a space before (
Please use a space before (.
Please use a space before ( before )
Does it make sense to also add the value of queryType to the error message (e.g. it's also used with a filter)
Does it make sense to also add the value of queryType in the event that it's a sql query?
Does it make sense to also add the value of queryType in the event that it's a sql query? Are there any other options?
please add the decodedBlocks.length to the end of the method.
please add the decodedBlocks.length to the end of line.
please add the decodedBlocks.length
Consider refactoring this into a function called addBuyOrderToOrderBook or simply addBuyOrder.
Consider extracting this into its own method called addBuyOrderToOrderBook or simply addBuyOrder.
Consider extracting this into its own function called addBuyOrderToOrderBook or simply addBuyOrder.
Can we avoid using kLayoutManager directly?
Can you get the layout manager from Helix?
I think we can avoid using kLayoutManager directly.
is this expected to be a pass?
is this expected to be read from a file?
is this expected to be read from a function?
Is there a way to stop fetching the volume from the entity?
Is there any way to get the host and have the extension point provided by the volume?
Is there a way to stop fetching the volume from the db?
Would you add the organization to the log message?
Would you add the organization to the log?
Would you add the organization to the log message here?
rather than needing an ArgumentCaptor here, you should just be able to do any(onedDateTime.class)
rather than needing an ArgumentCaptor here, you should just be able to do any(onedDateTime.class) with ArgumentCaptor.forClass(onedDateTime.class)
rather than needing an ArgumentCaptor here, you should just be able to do any(onedDateTime.class) with ArgumentCaptor.forClass(onedDateTime.class).
prop.getValue() returns a Map<String, String>. It's not needed here, but if you write the value, you'll be making these methods @Nonnull.
prop.getValue() is not needed here.
prop.getValue() returns a Map<String, String>. Is this OK?
nit: line break between ) and {
Nit: line breaks here
Nit: line wrapping is awkward, could we make it consistent (faster and bad style)
This is not a public API, so no reason to override it.
This is not a public API, so no reason to change it.
This is not a public API, so no reason to worry about it.
Please remove this one
please remove this one
Please remove this one.
I think it is better to do nCopies(int, int) in the loop here
I think it is better to do nCopies(int, int) in the loop instead of creating an extra list
I think it is better to use ByteStringBuilder instead of iterating over all elements.
suggestion if (!(Arrays.asList(criteria.getStrictFilters()) && Arrays.asList(criteria.getStrictFilters()).contains(filter)))) { value = value.toLowerCase(); }
suggestion if (!(Arrays.asList(criteria.getStrictFilters()) && Arrays.stream(criteria.getStrictFilters()).contains(filter)))) { value = value.toLowerCase(); }
suggestion if (!(Arrays.asList(criteria.getStrictFilters()).contains(filter)))) {
schema can be null
Schema can be created with a single constructor that only takes the Stream of fields and returns the final list.
schema can't be null
No need for typeTextArea. If you don't don don't remove the variable 'book'
No need for typeTextArea
Remove
Any reason why there's the classname? Wouldn't it be better to just use the class name so that there isn't a collision between the LHS and RHS?
Any reason why there's the classname? Wouldn't it be better to just use the class name so that there isn't a plugin on the classpath?
Any reason why there's the classname? Wouldn't it be better to just use the class name so that there isn't a osee extension?
still don't like this - so move this outside of the try block
still need to move here, with the block below.
still don't like this - so move this outside the try block
Would be better to have this as an else block?
Would that be better to have a continue?
Would be better to have a WARN log message after constructing it.
There is an extra space between the { and brackets.
There is an extra space between the { and {
Should be put in the try-catch block to make sure the exception is thrown from the test.
I'm a bit confused by the name of the variable. Why not just do source.getCoverage().getName() and line.getNr()?
I'm a bit confused by the name of the variable. Why not just call the asserting the status of the line?
I'm a bit confused by the name of the variable. Why not just do source.getCoverage().getName()?
You can replace all the try/catch with Assert.fail();
You can replace all the try/catch with Assert.fail().
You can replace all the catch clauses with assertThrows
We also need to check if the member type is a Java constant, e.g. INVALID_CLASS.
We also need to check if the member type is a constant, e.g. INVALID_CLASS.
Should this be a constant?
A lot of code for a simple thing: suggestion assertThat(project.getKey()).overridingErrorMessage("name");
A lot of code for a simple thing: suggestion assertThat(project.getKey()).overridingErrorMessage("jans").isNotEmpty();
A lot of code for a simple thing: suggestion assertThat(project.getKey()).overridingErrorMessage("jans").isNotBlank(project.getSphereClientConfig().getProjectKey());
Actually, we can remove this line. Yes, I know you did not add this, you just copied it from the existing source - but I looked into the details, and it only caches textures, which are not being queried here.
Actually, we can remove this line. Yes, I know you did not add this, you just copied it from the existing source - but I looked into the details, you can remove this line.
Actually we can remove this line. Yes, I know you did not add this, you just copied it from the existing source - but I looked into the details, and it only caches textures, which are not being queried here.
Is this method used to be called from anywhere else?
Is this needed?
Is this method used to create an object that has no superclass?
Why not use an enhanced for loop?
For each refactor
For each refactor?
no need to call CoreMatchers.containsString here
no need to call CoreMatchers.containsString since you are already in the assert method above
no need to call CoreMatchers.containsString
why did you change to final here? should be outside of the scope of the patch.
why did you change to static? should be outside of the scope of the patch.
why did you change to non-final here? should be outside of the scope of this patch
Do we need to change this to trace level?
Do we need to change this to throw an exception?
Do we need to change this to trace?
Use Collections.emptyList() to avoid unnecessary object creation
Use Collections.emptyList() rather than new ArrayList<>()
Use Collections.emptyList() rather than materializing a list.
Use a variable for playerCubeMap
Could you make sure this is the cube there?
Use a variable for the game and return it if it does
I think this would be better done as two cases, 1) if profile, add it to both registries and 2) if package, add it to just the package registry.
I think this would be better done as two cases, 1) if package, add it to both registries and 2) if package, add it to just the package registry.
I think this would be better done as two-liners, but up to you
to go again, here it will not work. We need to configure this predicate to filter out nulls.
Should we print something about none here, for example, if memberAccessor.getDeclaringClass().getName() is empty?
to go again, here it will not work.
Can you move this check into the Allele scope? Also, according to the spec, this should probably be an else-clause of the constructor.
Can you move this check into the Allele scope? Also, according to the spec, this should probably be changed from @NonNull to Allele.
Should be moved to liftSimpleVariant()
Can't you just use the one in #facultyMemberEditor.setFirstName(_firstName.getText(), _firstName.getText()+" "+_lastName.getText());
Can't you just use _firstName.getText()!= null?
should be removed.
Lines 86-88 and 103-105 should be replaced with: if (!localElement.getParentDRGElement()) { return null; }
Lines 86-88 and 103-105 should be replaced with: if ( localElement.getParentDRGElement()!= null &&!localElement.getMessage().isEmpty()) { continue; }
Lines 86-88 and 103-105 should probably be extracted to a separate function.
Pretty sure I'm correct. Can't you just do java return list.stream().map(pair -> Pair.getFirst(pair.getFirst()).collect(Collectors.toList());
the type looks good, but I'd suggest to change it to <>
the type looks good, but please change to hostNameList instead of hostNameList
I like string literal, but I don't believe that's how it's used here.
I like string literal, but I don't think that is necessary.
I like string literal, but I don't believe that's how it's used.
This should be done in the setup method
This should be done in the setup method.
Why change this?
Also the ID is not really high enough, I think it's worth doing something similar to what is done in Updater. Also the entity could be passed to the Updater and not as part of the response.
Also the ID is not really high enough, I think it's worth doing something similar to what is done in the Updater class.
Also the ID is not really high enough, I think it's worth doing something similar to what is complaining about.
Removed it
Removed this.
doc
how about having this be an immutable?
Missing setLock() qualifier
how about having this be a private method?
The field name should be readDepgraphs.
The field name should be read depgraphs.
The field name should be readArtifact, not readArtifact.
Should we use if (trackMetrics) { queueTimer.update(...) } instead of appending the transaction commit time?
Should we use if (trackMetrics) { queueTimer.update(System.currentTimeMillis() - eventSeenAt); } too?
Should we use if (trackMetrics) { queueTimer.update(...) }
This is nitpicky but if fixing an issue in the future, could you please reformat the code to match the commit message?
This is nitpicky but if fixing an issue in the future, could you see a test for this?
This is nitpicky but if fixing an issue in the future, could you please reformat the code to have a space before the curly braces?
please change this exception text to "Could not load resource from file name:" + fileName
please change this exception text to "Error loading resource from file name:" + fileName
please change to "Info: Using relex algorithms file:"
Let's change this to debug()
Let's change this to "Cannot map Fedora".
Let's change this to "Cannot map Fedora"
whitespace is a bit off here
whitespace is a little off here
can remove the else
You could move this to a separate method and use it here (and in the one below) to separate methods.
You could maybe use a for-each loop here (and in the next method)
You could move this to a separate method and use it here (and in the next method): java private void compute() {... }
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
There is an isNotEmpty method
Could we verify that the rescheduled is actually executed?
Could you verify that the rescheduled is actually executed?
Could use Predicates.expectAssertionError as it is the same thing
s/ Try setting TMP_DIR/Functions
s/f.toUri().toString()/
s/ Try setting TMP_DIR/tmp
This doesn't seem to be a safe test. There is a way to test that the order ref is equal.
This doesn't seem to be a correct test. There is a org.infinispan.commons.test.pack.test.PersonTestUtils#readContents in JUnit.
This doesn't seem to be a correct test. There is a org.infinispan.util.logging.Log for this.
This method can be simplified by using a single constructor call.
This method can be simplified by using StringUtils.split(String, String) for this.
This method can be simplified by using StringUtils.split(String, String) for the regex
Please use the format: LOG.error("{} DevMachine Id: {}, DevMachine Id: {}, found servers: {}", WS_AGENT_SERVER_NOT_FOUND_ERROR, machine.getWorkspaceId(), machine.getId());
Please use the format: LOG.error("{} DevMachine Id: {}, DevMachine Id: {}, found servers: {}", WS_AGENT_SERVER_NOT_FOUND_ERROR, machine.getWorkspaceId(), machine.getId(), client.getId());
Please use the format: LOG.error("{} DevMachine Id: {}, DevMachine Id: {}, found servers: {}", WS_AGENT_SERVER_NOT_FOUND_ERROR, machine.getWorkspaceId(), servers.getId(), client.getId());
We can use assertThat(metadataService.setUpAttributes(path, metadata)).hasValue(options);
We can use assertThat(metadataService.setUpAttributes(path, metadata)).thenReturn(options);
We can use assertThat(metadataService.setUpAttributes(path, metadata)).hasValue(options));
Same here, updateGroup() should be called only if the groupId is set to true.
Same here, updateGroup() should call updateGroup()
Same here, you should update the group when the groupId is null
shouldn't this be an error?
shouldn't this be on the line above this?
shouldn't this be something like'by service'?
else if is redundant
final
public?
There is a few more places where we're using try-catch for the generic type here.
There is a few more places where we're using try-with-resources.
There is a few of these try/catch blocks in this file.
I think you meant storageDomains.stream().filter(storageDomain -> storageDomain.getStorageType().isBlockDomain())
I think you meant storageDomains.stream().map(storageDomain -> storageDomain.getStorageType().isBlockDomain())
Please optimize
Change this to : int red = color & 0xFF;
Change this to : int Vec3d = getFluid()!= null? 0xFF : color >> 8 & 0xFF;
Use CodePointIterator here?
Are we guaranteed to have just one? Are we guaranteed this always be called on every call?
Are we guaranteed to have just one? Are we guaranteed to have just one?
Are we guaranteed to have just one? Are we guaranteed this always be called on the main?
Missing braces
Missing curly braces
Out of curiosity, since it's not the same as the full stopable?
You could add an assertFalse() here.
why this and not use the ArgumentHandler?
You could add an assertFalse here.
I don't know the rest of the test class. I can see this one...
I don't know the rest of the test class, but probably this test could be simplified to test on Version(1, 2, 3?
I don't know the rest of the test class, but probably this test could be simplified to assertSame()?
please extract this into a method, e.g. getModel().getLease().setIsChangeable(boolean 'ha')
this boolean can be removed.
line 138 and 118 should be removed.
You can use FileOutputStreamConstraint.class.equals() here.
You can use FileOutputStreamConstraint.is(FileConstraint.class) here.
You can use FileOutputStreamConstraint.class.equals() here and the comparison.
is there a reason to offer this as a log? or is it just a debug level log?
is there a reason to offer this as a log if it does not happen? or is it ok to throw exception?
is there a reason to offer this as a log? or is it just a debug level?
Minor thing, but argValue > Threshold.getThreshold(name) seems to be the same as arg.value()
Minor thing, but argValue > Threshold.getThreshold(name) seems to be the same as argType.
Minor thing, but argValue > Threshold.getThreshold(name) seems to be the same as arg.value().
Maybe we should use ctx.writeAndFlush(...)
Maybe we should use ctx.writeAndFlush(outBuf)
Maybe we should use ctx.writeAndFlush(...)?
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
We should log this properly too, I think. Errors in this class don't always bubble up where they could be inspected easily.
It seems that the other variables could be collapsed as well.
<LINK_0>
@vilchik-elena Could you please explain why this is changed from 1 to 1?
@vilchik-elena Could you please explain why this change?
This can return null if the getMarker() is null.
This can return null if the getMarker()!= null && bp.getMarker().getResource()!= IResource.FILE
The logic is already parsell. You can remove the if(bp.getMarker().getResource()!= null) part.
@apearc03 ASL header may be missing causing the build to fail
@apearc03 ASL header may be null
@apearc03 ASL header may be slow here for much reason.
Use fieldType.asPrimitiveType() instead of clazz.
Use fieldType.asPrimitiveType() instead of 'Array'.
Use fieldType.asPrimitiveType() instead of 'String'.
sounds fine to me.
sounds fine to me. suggestion Fields post = new Fields();
sounds fine.
Can you rename start_ts or end_ts?
Can you rename start_ts or something more meaningful?
Can you use.isLength() here and.entity("...")?
<LINK_0>
<field name>_COLUMN
<field name>RefreshRefresh
you need to call finishAndRelease() on both channels in a finally block to fix LEAKs.
call encoderChannel.finishAndReleaseAll() to fix LEAKs.
you need to call finishAndRelease() on both channels in a finally block to fix LEAK
Shouldn't we verify that this method is called only once, regardless of if the file was created? Or is it possible to create a new method with different name than "true".
Shouldn't we verify that this method is called only once, regardless of if the file was created? Or is it possible to create a new method with different name than "test".
Shouldn't we verify that this method is called only once, regardless of if the file was created? Or is it to be created with different sensors from another one?
Should we do this only if!clean?
Should we do this only if!clean? What happens if there is no task available?
Why do we need this change?
Please catch and log the exception as well
Please catch specific exception and rethrow as such.
Please try-with-resources as well
fBot can be null
maybe we should check the trace is not null
better to check the trace is not null
You can do int codePoints.copy(codePoints).append(':').append('\n');
You can do int codePoints.EndOfStream(int codePoint)
You can do int codePoints.EndOfStream(int codePoint) method
It isn't clear to me that Endpoint.create is a fast operation. Is it worth making this a simple class that manages values that are on the travis?
It seems like standard practice to add methods on Endpoint without including final variables.
It seems this is a pattern we normally do
Use.equals() instead of!=
Use.equals() instead of ==
Use.equals()
The "DISTINCT_VALUES_COUNT" method should return an optional, not an optional.
The "DISTINCT_VALUES_COUNT" method should return an optional, not just the minimum.
The "DISTINCT_VALUES_COUNT" method should return an optional, not just the size.
@vilchik-elena Why not keep assertions? Is there a specific reason you can't use?
@vilchik-elena Why not keep assertions? Is there a specific reason you can't do it here?
@vilchik-elena Why not keep assertions? Is there a specific reason?
move this to the end of the class
move this to a private method
move this to a private method maybe?
constant?
constant, please move to constants
constant
Is it possible that this returns null (or in other words, a selector fails to create a connection to the desired host,port).
Is it possible that this returns null (or in other words, a selector fails to create a connection to the specified host,port).
Is it possible that this returns null (or in another words, a selector fails to create a connection to the desired host,port).
Couldn't Granularities.ALL be used here?
Couldn't Granularities.of(...) be used here?
Sad times.
I think exception should be a RuntimeException, no?
I think timeout should be a sirius preference.
I'm not sure if this is good idea, but technically we should expect a Exception
why the double lock is needed?
why the double lock is needed here?
why the two cases are the same?
This whole method is a bit hard to read. Could be replaced with: Iterables.asList(buildSpec)
This whole method is a bit hard to read. Could be replaced with: Iterables.singletonList(buildSpec)
"Simple Builder"
boolean namedParameters = namedParameters.size(); if (namedParameters!= null) { output.writeInt(namedParameters.size()); } else { output.writeInt( namedParameters.getValue()); }
code duplication
code duplication. Can we remove this?
free the lock in a finally block
free the lock after the for loop
free.
We could add log to exception or re-throw it?
We should probably log this as well.
We could add logging in this method
Is this debug output necessary?
Is this debug statement still necessary?
Is this debug or just remove?
please declare variable in first usage
you could declare variable in first usage
please declare variable in single line
This one could be also part of the @Test annotation
This one could be also part of the @Test annotation as well.
This one could be also extracted to a @Before method
You should never set the type to _index, as it should never matter.
You should never set the index to _index in a loop. Probably, set it to true here.
You should never set the type to _index, as it should never change anything.
Add final keyword.
Add method to TestDolphinContext and call it the second time?
Add methods to TestDolphinContext and TestDolphinContext.
Map<Object, Object> toKeep = new IdentityHashMap<>();
Map.Entry?
Map.computeIfAbsent?
why?
should this be "5000"?
could we just use TableName?
@maria-farooq What is the purpose of making the statement synchronized?
@maria-farooq What is the purpose of making the assignment here?
@maria-farooq What does it mean to keep those variables in the loop here?
This should be replaced with Class<?>[]
This should be declared in ApplicationConstants instead of Class<?>[]
This should be declared in ApplicationConstants instead of public.
Shall we use StringUtils.isEmpty() here instead of "".equals("")?
This looks like a good candidate for a builder.path(String)
Shall we use StringUtils.isEmpty() here instead of the null check?
In this case each test item is expected to be the same. I don't think the real failure is thrown.
In this case each test item is expected to be the same?
In this case each test item is expected to be the same. I don't think it's right to use hamcrest matchers.
Because destroy is now async, there is a high chance that you will start initializing before it has completed its removal. You probably need to get a hold of the CompletableFuture from the runAsync() in destroy and wait for it before initiating init()
Because destroy() is now async, there is a high chance that you will start initializing again and again. You probably need to get a hold of the CompletableFuture from the runAsync() in destroy and wait for it before initiating init()
Because destroy is now async, there is a high chance that you will start initializing before it has completed its removal. You probably need to get a hold of the CompletableFuture from the runAsync() in destroy and wait for it before initiating init
Use CollectionUtil.isnotempty instead
Use CollectionUtil.isIgnored()
Use CollectionUtil.isEmpty
We should log the exception too
We should not catch generic Exceptions
We should log this error or warn
Can you change this method to call timeone.convertLocalToUTC(localSec*1000, false) instead of default timeone?
Can you pull this logic into a method? It is repeated in all places.
Can you pull this logic out into a method? It is repeated in all places.
You could move this to an internal command, as it is called from 3 places.
You could move this to the top of the method as it is called from 3 places.
You could move this to an internal command, as it is called from 2 places.
return new double[] { 0}, "1.1" };
No need to create a variable for it.
No need to accept values
<code>@CheckForNull</code>
Suggest to check if element is null and return false if it is not null.
Suggest to check if element is null and return false.
Is this possible? calling getOrCreateComponent() may return null, so it would fail on null?
Is this possible? calling getOrCreateComponent() may do something on a TxClusterExpirationManager.class.
Is this possible? calling getOrCreateComponent() may return null, so it would crash.
For all the metrics in this file, you may need to clean them up in a finally block.
For all the metrics in this file, you may need to clean them up in finally.
For all the metrics in this file, also the total size of the expected size in getBulk is not incremented with the size of the original array. Is it possible to move these two lines into the original loop?
Can we use == for symmetry with ItemRepository casting?
Can be removed
Can we use == here?
You don't want to display the information to the end-user!
You don't want to display the information to the user. I think it would be useful to display the information to the end-user!
If we don't display the information to the end-user!
@CarlosGines let's inline bout here as well
@CarlosGines we should try inlining here as much as possible
@CarlosGines bout could be inlined
i think it is better to replace the method with 'InternalLockInfo' and remove the prefix from the lock view.
i think it is better to replace the method with 'InternalLockView' and remove the prefix from the lock view.
i think it is better to remove the field and not create the instance with null
you should check for null template
you should use constants for the messages
you should use constants for the messages.
I'd put {} around this even if it's a single line.
I'd put {} around this even if it's a one-liner.
I'd put {} around this.
You could put the prefix in the ImmutableMap.of() to avoid the need for the cast.
Simplify ImmutableMap.of()
You can use ImmutableList.of() directly here.
What about.equals(d)?
It's better to mention the case where we cast to a null value.
What about.equals(x)?
There is already a setNegativeButton method which takes a message and the DialogButtonActionPerformer. Can we just use that here?
There is already a setNegativeButton(buttonLabel, new DialogButtonActionPerformer(action)) method that was used here.
Is this actually necessary?
This is an error for me now, and I don't see why it's needed.
This is an error for missingTxn which should be NOT an error for missingTxn parameter.
This is an error for me now, and I don't see why it's necessary.
you can use JsonObjectBuilder for this
you can use JsonObjectBuilder for this class
you can use JsonObjectBuilder
If only the filter is created, we should stop the first one here too
Should we create a test for this case?
If only the filter is created, we should stop the original one here too
Probably worth to log this exception in the new log, just in case
Probably worth to log this exception in the new exception :)
Probably should log this exception as well
Here, you can just check for the invalidityInfo before adding it. Overall, there is a validate method that returns a boolean.
Here, you can just check for the invalidityInfo before adding it. Assumption.assertNotNull(result, validator.getInvalidityInfo());
Here, you can just check for the invalidityInfo before adding it.
By this point, you're iterating over all enumeratedValues. I think this is a good idea.
By this point, you're iterating over all enumeratedValues. I think this is a need to track this first.
By this point, you're right. Suggest to use addItems() as this is called above.
requireNonNull
requireNonNull(line);
Create a new constructor that does exactly that.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
I don't know this part of the code in this block but the fragCont.discard() should be used here.
I don't know this part of the code in this block but the fragCont.discard() should be called outside the while loop.
I think this is unnecessary here. Instead of adding app to the app, you can just use app.getAppId()
I don't think this is necessary here. If the app you get the app you can get its app and set it to null, then you can remove it. Just add the app into the log message
I don't think this is necessary here. If the app you get the app you can get its app and set it to null, then you can remove this line
Our style is to have braces around multi-line statements
May be worth providing a metric to get the gateway account id and the gateway account id?
Our style is to have braces around multi-line statements.
@cvrebert let's inline it
@cvrebert let's inline this variable
@cvrebert let's inline this variable.
lambda?
if you have a lambda expression, do you need this?
if you have a lambda expression?
Similarly, Tasks.forException(new FirebaseAuthUserCollisionException(...)) can be used instead of the mock.
Similarly, Tasks.forException(new FirebaseAuthUserCollisionException(...)) can be used instead of per line.
Similarly, Tasks.forException(...) should be used instead of the mock.
java logger.error("Failed to use repository cache for {}", getSource(env));
java logger.error("Failed to use repository cache for {}", getSource(env)); I think it's a bit more clear as it's rather hard to see which line break.
java logger.error("Failed to use repository cache for {}", getSource(env)); I think it's a bit more clear as it's rather hard to see the actual side effects.
rename to key
rename to pInputToData
rename to memInputToData
Can you remove this?
This should not happen, since it is just a test class.
Why are you throwing Exception here?
/hashtags/?
PushOneCommit.Result r
/hashtags/
Yes. You are populating the map concurrently as the result of each render future is executed. Nothing guarantees synchronous access to the map.
Yes. You are populating the map concurrently as the result of the future is executed. Nothing guarantees synchronous access to the map.
Yes. You are populating the map concurrently as the result of the map is backed by the cached copy. Nothing guarantees synchronous access to the map.
Move it outside the loop. This is most simple.
Move it outside of the loop.
Move it outside the loop.
Rather than use the static value directly, something like: boolean forceScroll = false; if (SWT.getPlatform().equals("My Collection")) { //... }
Rather than use the static value directly, something like: boolean forceScroll = false; if (SWT.getPlatform().equals("SWT.getPlatform())) { //... }
Rather than use the static value directly, something like: boolean forceScroll = false; if (true) { display = true; } else { display = false; }
If inputStream would be declared as class variable, then it could be closed in @After section of junit test. Then we could omit try/finally block in test methods
If inputStream would be declared as class variable, then it could be closed in @Before section of junit test. Then we could omit try/finally block in test methods
If inputStream would be declared as class variable, then it could be closed in @After section of junit test. Then we could omit try/finally block in test method
make this method synchronized
make this method final
externalize
if isTraceFileRotationSupported else not required
&& isTraceFileRotationSupported()
&& isTraceFileRotationSupported()?
Why not put this above the try block?
Why not initialize the class directly? This allows the method to initialize the value directly.
Why not put this above the loop?
Please remove the change to the error message from the error message if the exit condition is not met.
Please remove the change to the error message from the error message if the exit code is not met.
Please remove the change to the error message from the error message if the statement is not met.
why BodyInternalTypes.AGENT_ENTITY and not AGENT?
It should be equals, sorry if I am missing something
why is this test required?
the interface should specify the pin be attachable method of ServoControl.. better yet, we need to attach the ServoControl object.
the interface should specify the pin be attachable method of ServoControl.. better yet, we could call attachServoControl() and then invoke it.
the interface should specify the pin be attach and use the method directly here. no need to duplicate the adapter
maybe should be a switch?
maybe should have a switch?
maybe should have a case that the invalid syntax was retrieved?
This looks like a leftover from debugging.
this looks like a leftover from debugging?
This seems to be seeking pas the user of the query.
Can you also use Objects.hash() here and below?
Can you also use Objects.hash() here and below.
Can you also use Objects.hash(...)?
After the change this assignments to delimiter is ignored, so it is not please change it to delimiter. To be consistent with the rest of the tokenized path.
After the change this assignments to delimiter is ignored, so it is not please change it to delimiter. To maintain backward compatibility, the tokenized path is within the body.
After the change this assignments to delimiter is ignored, so it is not please change it to delimiter. To maintain backward compatibility, the tokenized path is correct, please change this asset path to contain just the body.
Is it really needed to fix the typo in APITrace?
Is it really needed to fix this?
Is it really needed to fix the typo in APITrace.begin?
not thread safe
pls create a new instance all the time
pls make this a final static
Please fix the typo in the exception message.
Please fix the typo in the message.
Please use Verbs.*
any reason to not implement this as FEATURE_CUSTOM_TITLE?
any reason to not override the custom type here?
any reason to not use the defined "ass" instead of "ass"?
why a file here instead of BAOS like others and before?
why a file here instead of BAIS like others and before?
why a file here instead of BAOS like other tests
this should be verifying the line number, no?
this should be verifying the lines of code equals, no?
this should be verifying the lines of code equals and hashcode, not the same with the project name
s/has/has/
Value is internal, so, we could do valueOf(value)
Value of key is internal, we could do valueOf(value)
consider making this a Set instead of a set?
consider a Set
consider making this a Set instead of a set.
if it is a Disposable, you would think that can only be set once by the if statement
if it is a Disposable, you should call it from the if instead of just directly accessing / dispose of the dialog.
if it is a Disposable, you would think that can only be set once by the if statement.
I'm not sure if this is the right place for this.pos = pos; and below.
I'm not sure if this is the right place for this.pos = pos; and in the next method, it's not a void method.
I'm not sure if this is the right place for this.pos = pos; and in the next method, it's not clear if it is.
You don't need to add the element to the model - just the widget.
You don't need to add the element to the model; you can just call the method directly
You don't need to add the element to the model; you can use it for all places
This is unused.
Nice touch!
The first half of this method is duplicated.
I would prefer to avoid throwing an exception if they can't be set.
I would prefer to avoid throwing an exception if they can't be thrown.
pointless
Would be a good idea to use both of these? It looks like you could have a single method, but it would be a lot more readable.
Would be a good idea to use both of these? It looks like you could have a single method, but it would be a lot easier to read.
Why name it property? It is a bit hard to find the method.
I don't think this is necessary, it should be done in a try-with-resource block.
I don't think this is necessary, it should be done in a try-with-resource block. My hunch is that would mean two new operations, even though the default transaction is removed.
I don't think this is necessary, it should be done in a finally block.
Should we log the exception here?
Should we log also the failure to terminate first?
Should we log also the failure to terminate?
is there a difference between this and the other tests?
Why did you move the test here?
Why did you move the test?
What if the notebook instance is created in the scheduler (e.g. by the scheduler)?
What if the notebook instance is created and the note is not loaded?
What if the notebook instance is created and the note is not reset?
Just an idea: can we remove this trackAndPost method and just push it to the AnalyticsUtils class? Then this class won't need to know about this.
Just an idea: can we remove this trackWithReaderPostDetails since we're already pulling it for deletion in ReaderPostTable.java?
Just an idea: can we remove this trackAndPost method and just push it to the AnalyticsUtils class?
Minor: is it possible to add some message about the failure cause here? Maybe something on lines - Failed to add or updateCompactionConfig
minor nit: is it possible to add some message about the failure cause here? Maybe something on lines - Failed to add index {}
is it possible to add some message about the failure cause here? Maybe something on lines - Failed to add index {}
please set it to true only if host is set (not null)
please set it to true only if host is set (i.e. no log)
please set it to true only if host is set (i.e. without log in the call)
Is there a reason to use the entrySet() instead of res.getRules().
Is there a reason to use the entrySet() instead of res.getRules()?
Is there a reason you want the list of modules to be emptySet()?
This should be done in the updateContent() method above, for consistency with the rest of the class.
This should be done in the updateContent() method above, right?
This should be done in a separate thread, right?
Not sure if I like the idea of having a special treatment for 404. I think it might be good to have a default case for 2.
Not sure if I like the idea of having a special treatment for 404. I think it might be good to have a default case for CON_NAME_PATTERN.
This doesn't seem to make sense.
I appreciate the centralized code of this approach, but i think it is going to result in all the preparation of the centralized code. It may be hard to go with this approach without a larger code change
I appreciate the centralized code of this approach, but i think it is going to result in all the preparation of the centralized code. It may be hard to go with this approach with this approach without a larger code change
I appreciate the centralized code of this approach, but i think it is going to result in all the preparation of the centralized code. It may look like this approach has a few examples of how to do it. You can go with this approach without a larger code change
1. Why not throw exception here? 2. Please consider the exception with CloudRuntimeException to be thrown from copyCmdAnswer.getResult()
1. Why not throw exception here? 2. Please consider throwing cloud exception to improve the error message.
Please consider adding some message to the exception.
The DISTINCTCOUNTHLLMV is an enum, which says the same as 1.
The DISTINCTCOUNTHLLMV is an enum, so you should default to 1.
The DISTINCTCOUNTHLLMV is an enum, which says the same as one of the two column values. If you want to round-trip to DISTINCTCOUNTHLL, then this switch should be DISTINCTCOUNTHLL while it is in aggreations.
![MAJOR](<LINK_1> 'Severity: MAJOR') Introduce a new variable instead of reusing the parameter "unused". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Introduce a new variable instead of reusing the parameter "true". [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Introduce a new variable instead of reusing the parameter "unused". [![rule](<LINK_1>](<LINK_2>
Could this be switched to something like : catch (Throwable t) { log.error("Failed to edit label for {} due to {}", pid, e); }
Could this be switched to something like Failed to edit label, created by the edit label? Also, the exception doesn't need to be formatted into the message.
Could this be switched to something like Failed to edit label?
@ikhvostenkov please name it json
@ikhvostenkov again json, please name it json
@ikhvostenkov again json, can you name it json?
Should not you use anyMatch here?
Should not you use 'focusedInfrastructurePlugin' instead of 'infra'?
Should not you use 'focusedInfrastructurePlugin' instead of 'focusedPolicyPlugin'?
Maybe we could rewrite the conditions to something like: if (catalog == null) { catalogByName.getCatalog(catalogName); if (catalog == null) { catalogByName.put(catalogName, catalog); } if (catalog == null) { catalogByName.put(catalogName, catalog); } return catalogByName.get(catalogName);
Maybe we could rewrite the conditions to something like: if (catalog == null) { catalog = catalogByName.getCatalog(catalogName); if (catalog == null) { catalog = catalogByName.get(catalogName); } if (catalog == null) { catalog = catalogByName.getCatalog(catalogName); } catalogByName.put(catalogName, catalog); }
Maybe we could rewrite the conditions to something like: if (catalog == null) { catalogByName.getCatalog(catalogName); if (catalog == null) { catalogByName.put(catalogName, catalog); } if (!catalog.isPresent()) { registerCatalog(catalogName); return catalogByName.get(catalogName); } return catalogByName.get(catalogName);
@fanifieiev the same above.
static import
static import?
move error log to condition body
move error logging to condition body
move error log to condition body?
I'm not a big fan of "left" and "right" switch statements, and it's really hard to reason about "right" switch statements.
I'm not a big fan of "left" and "right" switch statements, and we should be consistent everywhere in the code.
I'm not a big fan of "left" and "right" switch statements, and it's really hard to reason about in the code.
put final on the class
put final on purpose
put final on purpose?
this if statement is not needed
this if statement is no longer needed
we don't need to setPaused = true here
You need to check item.getLikes()!= null
You don't need to check for null here, as it could just be null.
You don't need to check for null here, since you already set it later on.
How about checking if the storage domain was ISO/Importable and throwing an exception if it is not?
How about checking if the storage domain was ISO/Import-Export in the log message and returning true if it was not?
This doesn't seem like the right log message.
I don't know the code. Is that ok?
I don't know the code. Is it the responsibility of the objectLinks to be null?
I understand that the code is changed here but is the code that is supposed to be overloaded?
Nit: this check could be made static
Nit: this check could be removed as the same as below.
Nit: this check could be removed as the same as above.
What if the rowId is null?
Shouldn't this just be insertedRowsCount > 0?
Shouldn't this just be insertedRowsCount < rowCount rowCount?
I think this can just be an else if
Doesn't this need to be null?
Do not use this if the getUriMaker() == null
I'd like to avoid calling nullSafeToString multiple times since it may be costly to compute the array.
I'd like to avoid calling String.format() multiple times since it may be costly to compute the array.
I'd like to avoid calling nullSafeToString multiple times since it may be possible to just have a single array.
It might be better to use.trim() here to avoid.trim()
It might be better to use.trim() here to avoid printfing on the version but empty string.
It might be better to use.trim() here to avoid printfing on the version but not the version.
Prefer assertThat(guidePostsInfo.getMaxLength(), greaterThan(0));
Prefer assertThat(guidePostsInfo.getMaxLength(), greaterThan(0L))
Prefer assertThat(guidePostsInfo.getMaxLength(), greaterThan(0L)) as that's more concise.
This line needs a colon, to make it "getVElement().setCollapsed(true)" I would also like to make it "null" a constant.
This line needs a colon, to make it "getVElement().setCollapsed(true)" I would also like to make it "null" rather than "getVElement().getName()" I would also like to note that it should have been down lower, with the smooth transition.
This line needs a VariantGroup.
Just an idea: What about wrapping record.getData() in a static field?
Just do: EnumSet<Record.Flag> flags = EnumSet.copyOf(record.getData());
Just an idea: What about wrapping record.getData() in a static block?
Shouldn't this be in the commit message?
Would be simpler to always use Job.OK_ID
What is the reason for this test?
StandardCharsets.UTF_8
Do we need to close in? If in.read() returns a byte array, shouldn't we use java.nio.charset.StandardCharsets.UTF_8?
Do we need to close in? If in.read() returns a byte array, shouldn't we close it in finally block?
I believe lastSegment can be an empty string which will cause lastSegment to be null, which then will cause an NPE. You can try this by leaving the program text box empty.
I believe lastSegment.trim() can be replaced with append(lastSegment.trim()) which then will trim the file path also
I believe lastSegment.trim() can be replaced with append(lastSegment.trim()) which then will trim the file path also.
append(object).append(object).append(object).toString()
append(object).append(object).append(object).build();
append(object).append(object).toString()
if (SupportNullKey == null) { return new StateMapView.KeyedStateMapViewWithKeysNotNull<>(stateTtlConfig); }
if (SupportNullKey.isEnabled()) {
if (SupportNullKey == null) { return null; }
Why assume this?
Why HdfsSinkConnectorConfig?
Why do we need this?
add whitespace to if statement
add whitespace, or make it consistent
add whitespace
suggestion log.error("Couldn't start JdbcSourceConnectorConfig.QUERY_BLACKLIST_CONFIG", e);
suggestion log.error("Couldn't start JdbcSourceConnectorConfig.TABLE_BLACKLIST_CONFIG", e);
suggestion log.error("Couldn't start JdbcSourceConnectorConfig.QUERY_BLACKLIST_CONFIG, tablePollMs);
final?
final??
final.
@vilchik-elena Why not using snap.lastModified() / 1000?
@ivandalbosco Why not use [dynamic width](<LINK_0>?
@ivandalbosco Why not use Util.getipEntry_TO_EINES = 0?
Can the return statement be dropped?
Can the return statement be removed?
why rename?
Wouldn't it be better if we could check if sharedShares are also an int?
Wouldn't it be better if we could have an internal representation of this structure within the storage manager?
Wouldn't it be better if we could check if sharedShares are also removed from this one, which is not what we are removing.
there's an issue here - when running the vm as stateful, we'll get to this else block (as there's no stateless snapshot) and will detach the user although everything went fine. generally speaking, i think that in this flow we can inspect the result of RunVm instead of running the endAction() from here (Example - <LINK_0>
there's an issue here - when running the vm as stateful, it'll get to this else block (as there's no stateless snapshot) and will detach the user although everything went fine. generally speaking, i think that in this flow we can inspect the result of RunVm instead of running the endAction() from here (Example - <LINK_0>
there's an extra space in between the if and the else clauses (here and elsewhere)
Please use parameterized logging.
Please use parameterized logging instead of string concatenation.
Please use parameterized logging of string concatenation.
I would use semaphore instead of semaphore.
I would use semaphore.of(Integer.., Integer::intValue) or Math.toIntExact(Integer.class).
I would use semaphore.of(Integer.., Integer::intValue) or Math.toIntExact(Integer..)
@manuelplazaspalacio this class is only used when we have getStoreKeysInByteRange, it's more efficient to check if it is already a valid state. And it would be better to add a getStoreKeysInByteRange(long start, long end) method to the list.
@manuelplazaspalacio this class is only used when we have getStoreKeysInByteRange, it's more efficient to check if it is already a valid state. And it would be better to add a getStoreKeysInByteRange(long start, long end) method to the list of store keys.
@manuelplazaspalacio this class is only used when we have getStoreKeysInByteRange, it's more efficient to check if it is already a valid state. And getStoreKeysInByteRange is also called when the getStoreKeysInByteRange is changed. I would prefer to test it.
So I really don't like this method. If the files were stored in the files, it would be much better to throw an exception (and log a warning).
So I really don't like this method. If the files were stored in the files, it would be much better to throw an exception (and log a warning) instead of returning false. Also, a test might be useful for the two files files.
So I really don't like this method. If the files were stored in the files, it would be much better to throw an exception (and log a warning) instead of returning false. Also, a test might be useful to make sure that the repository exists.
Would it make sense to update this as well?
Would it make sense to create a constructor with an overload of accountConsumer that takes a RequestOptions parameter and then call that constructor in the rest of the test?
Would it make sense to create a constructor with an overload of accountConsumer that takes a RequestOptions parameter and then call that one instead of the other constructor?
Left over?
Left over?
> Checks
Nice! It's a robust approach to adding a second param in the constructor. While you're using it, it's generally safer to call this method in a way that it's not called directly.
Nice! It's a robust approach to include this in the logs
Nice! It's a robust approach to adding a second param in the constructor.
a typo (governance)
governance => governance
a space required. (Can)
Change this to a single line like the if statement above.
Change this to a single line like the if statement above?
Change this to a single line like the rest of the code.
I would change this to: java final GridColumn.HeaderMetaData headerMetaData = mock(GridColumn.HeaderMetaData.class); final GridColumn<?> gridColumn = mock(GridColumn.HeaderMetaData.class); doReturn(ci).getColumnInformation(50.0);
I would change this to: suggestion final GridColumn.HeaderMetaData headerMetaData = mock(GridColumn.HeaderMetaData.class);
I'm wondering to be more clear, perhaps this verification should be moved to after line 25?
This would be better to use injectionTargetFactory.createBeanAttributes, e.g. something like: @Override public <T> Object create(Class<T> attribute) { final AnnotatedType<T> annotatedType = beanManager.createBeanAttributes(annotatedType); return annotatedType!= null? beanManager.createBeanAttributes(annotatedType) : null; }
This would be better to use injectionTargetFactory.createBeanAttributes, e.g. something like: @Override public <T> Object create(Class<T> ctx, final AnnotatedType<T> annotatedType) {... }
This would be better to use injectionTypeFactory instead of attributeManager.createBeanAttributes.
the name isn't intuitive, IMHO. perhaps copyUnchangedStoragePoolProperties()
why do you update the format type again?
the name isn't needed here.
constructFacet might return a Facet for the different use cases, right?
transformation.
ternary operator?
@cvrebert let's name it as a variable.
@cvrebert let's avoid complex variable names, let's name it as a variable.
@cvrebert let's avoid complex variable names by using method references.
In terms of naming things, I would prefer to rename it as 'variantEntityList.size()' to 'findFilter'.
In terms of naming things, I would prefer to use variantRepository.findByIdsAndComplexFilters() as it's a little clearer name.
In terms of naming things, I would prefer to use variantRepository.findByIdsAndComplexFilters() as it's clearer as possible.
This could be a mistake.
Your mistake. It's a mistake.
You can have a mistake with using a scriptDefinitionValid plugin.
Should be 60000000.
Should be a test error.
Should be the test error.
Test should already fail if we're running in the forkedProcess. There's no guarantee that candidate will be added to the stack trace.
Test should already fail if we're running in the forkedProcess. There's no guarantee that candidate will be added to the nanoTime associated with the previous processor.
Test should already fail if we're running in the forkedProcess. There's no guarantee that candidate will be added to the nanoTime associated with the candidate.
I think we should have some kind of test here to cover motivated files (or may contain some reason) that we want to use something like hdfs://localhost:sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/s
I think we should have some kind of test here to cover motivated files (or may contain some reason) that we want to use something like hdfs://localhost:sash/sash/sash/sash/sash/sash/sash/sash/sashash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/
I think we should have some kind of test here to cover motivated files (or may contain some reason) that we want to use something like hdfs://localhost:sash/sash/sash/sash/sash/sashash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/sash/
I'm okay with this second time, but it may be slightly more readable to combine these assertions with assertTrue(event.getResource().hasProperty(RDF.type, Cdr.Tombstone));
I'm okay with this second time, but it may be slightly more readable to combine these assertions, e.g.: assertTrue(folderObj.getResource().hasProperty(RDF.type, Cdr.Tombstone));
I'm okay with this second time, but it may be slightly more readable to combine these assertions in a single assertion using assertFalse(event.getResource().hasProperty(RDF.type, Cdr.Tombstone));
Why uppercase? Please look at the other classes.
Why uppercase? Please look at the other classes
Why uppercase? Please look at the other methods.
please remove this.
please remove the sysout.
can you use the logger instead?
the log.error below this is going to go totally bonkers if the queue ever fills up; it'd be better to only print a log message every X events (similar to HttpPostEmitter)
the log.error below this is going to go totally bonkers if the queue ever fills up; it'd be nice to not print a log message every X events (similar to HttpPostEmitter)
the log.error below this is going to go totally bonkers if the queue ever fills up; it'd be better to not print a log message every X events (similar to HttpPostEmitter)
Is this change needed to make the method protected?
Instead of creating this new method, can we create the common part of the method?
Is this method synchronized?
Let's take a look at the @sam file.
Let's take a look at how the other fields are set. If not, it should be part of the constructor.
Let's take a look at how the other fields are written. If not, it should be the same.
if you haven't received a value, you should also send the db/table id to the logs
if you haven't received a value, you should also send the db/table id to the logs.
if you haven't received a value, you should also use StringUtils.isBlank() instead
Missing that
Missing cleanup
Missing your
If it's not the case, then please add a null check.
If it's not the case, please use java.util.Optional.
If it's not the case, then please add a null check here.
nit: should be called "BatchInputFileType.getFileTypeIdentifer()"
nit: should be called "BatchInputFileType.getFileTypeIdentifer() + "
nit: should be called "BatchInputFileType.getFileTypeIdentifer() +"
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Remove this unused method parameter(s) "testBasePathForStartWithFilter". [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AS1166)
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Remove this unused method parameter(s) "testBasePathForStartWithFilter". [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AS1192)
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
static import parseClass
static import parseClass.
final
can we keep the reference equality check as well?
Can we keep the reference equality check as well, and remove the import from the static method?
can we keep the reference equality check as well, and remove the if on the static lookup?
Same deal here. Product.hashCode has a special meaning for this.
Same deal here. Product.equals() is a bit hard to read.
Same deal here. Product.hashCode has a special meaning for the objects you are comparing.
Won't this lead to a lot of spammy? Is this something we want to know?
Won't this lead to a lot of spammy on the logs? If yes, I think this should be fine.
Failed to refresh locks?
should we log this?
I think we should have a check for isDebugEnabled since we don't want to debug the thread
I think we should have a check for isDebugEnabled since we don't want to debug the thread.
Could we rename that method to use try-with-resources? I think it's better to have one usage
Could we rename that method to use checkpointData?
Could we rename that method to use try-with-resources?
If we throw an exception, do we need to continue to set bActionsSet to true?
If we throw an exception, do we need to continue to set bActionsSet?
If we throw an exception, do we need to continue to do this? I thought it was done in other places.
This should be a localization issue.
The error message here should be updated to something like "An error occured."
This should be a localization error.
You don't need concreteStores as the type. The concreteStoreType is an enum.
You don't need concreteStores as the type. The concreteStoreType already does this.
You don't want concreteStores to be a set. Changing the order of the log statements to use the iterator.
Remove this line and use the FormulaEditor class directly on the row above
Remove this line and use the FormulaEditor class directly on the row above.
Remove this line
this method can be private
this method can be private.
final
Same question about the rule "addTypeRefToList"
This should be moved to the end of addRule()..withText() branch.
This should be moved to the end of addRule()..withText() should be invoked in a static block
s/nexmo/setDefault_source/
s/no NEXMO private key found/similar
warn
For consistency, use ThreadLocalRandom.current()
For consistency, use StringBuilder
For consistency, use %n
I think it would be nice to make the conditional for WELD_CAPABILITY_NAME a constant?
I think it would be nice to make the conditional for WELD_CAPABILITY_NAME here just to keep it consistent with the rest of the code.
I think it would be nice to make the conditional for WELD_CAPABILITY_NAME here just to make the conditional more explicit.
same here, should not be better to compare by id using TermId? @cuenyad
same, should not be better to compare by id using TermId? @cuenyad
same should be better to compare by id using TermId?
Seems like you should be able to just return student here as well?
Seems like you should be able to just return student.googleId!= null
Seems like you should be able to just return student.googleId!= null?
I don't think it makes sense to put this line in the if (wsWorkunitsServiceSoapProxy == null) check. After wsWorkunitsServiceSoapProxy is null, if it is null, we'll get an NPE inside this if statement.
I believe it makes sense to put this line inside the if (wsWorkunitsServiceSoapProxy == null) statement. That way we don't have to do the same check in other classes.
I don't think it makes sense to put this line in the if (wsWorkunitsServiceSoapProxy == null) statement. That way, if it is null, we'll have an NPE in the call.
Why do we need to change this?
Why do we need to check for null?
Why removing the double comma?
so, you can remove the if checking: if (!payload.getJSONObject("cookie").has("expiry")) { The [x] can be null if the parse is not valid, otherwise the supplied value will be null.
so, you can remove the if checking: if (!payload.getJSONObject("cookie").has("expiry")) { The [x] can be null if the parse is not valid, otherwise the caller will get a NPE.
so, you can remove the if checking: if (!payload.getJSONObject("cookie").has("expiry")) { The [x] can be null if the parse already returns a valid value.
can the catch be around the connectorResponse.readEntity(...) method.
can the catch be around the connectorResponse.readEntity(...) method?
can the catch be around the connectorResponse.class?
I'm not sure about this (or pedantic)... As I know it's not a big deal, but I think using an (or) strategy to decide if to submit or not.
I'm not sure about this (or pedantic)... As I know it's not a big deal, but I think using an (or) strategy to decide if to submit or not. So if someChangesUnsubmittable is used for iterating over the groupChanges, then the list will be modified, and you will not need to edit the aggregate state. I feel like this might be a bug.
I'm not sure about this (or pedantic)... As I know it's not a big deal, but I think using an (or) strategy to decide if to submit or not. So if someChangesUnsubmittable is used for iterating over the groupChanges, then the list will be modified, and you will not need to edit the aggregate state at all.
In the case of the file is not properly closed. Better to use try-with-resources.
This will also work for the case where the connection is not properly closed.
In the case of the file is not properly closed.
Could use getImageChainFromDb().removeAll(chainFromStorage) instead of having CollectionUtils.subtract force conversion of imagesToRemove to a Collection, since a Set more accurately portrays the intent of the, well.
Could use getImageChainFromDb().removeAll(chainFromStorage) instead.
Could use getImageChainFromDb().removeAll(chainFromStorage).
We should already fix the exception.
We should only deal with the sitemaps if we are expecting only the sitemaps? Or is it OK to assume that it is StrictNamespace?
We should only deal with the sitemaps if we are expecting only the sitemaps? Or is it OK to assume that it is empty?
I don't think this is necessary. The testUsedPropertiesWithFailure() is supposed to fail in the case of a failure.
I don't think this is good. There is a method called validateRegisteredProperties() which returns a Set, so you can use that instead.
I don't think this is necessary. The testUsedPropertiesWithFailure() is supposed to fail in the case of a valid value.
Since the logic is duplicated in the "else" block, it would be good to encapsulate it inside a method. Maybe like this: java private String searchTrace(String parentId, String traceId, String parentId, String traceId) { if (logic!= null) { return "SELECT * FROM " + TRACING_TABLE + " WHERE parent_id=" + parentId; } else if ( traceId!= null) { return "SELECT * FROM " + TRACING_TABLE + " WHERE parent_id=" + traceId; } else { return "SELECT * FROM " + TRACING_TABLE + " WHERE parent_id=" + traceId; } }
Since the logic is duplicated in the "else" block, it would be good to encapsulate it inside a method. Maybe like this: java private String searchTrace(String parentId, String traceId, String parentId, String traceId) { if (logic!= null) { return "SELECT * FROM " + TRACING_TABLE + " WHERE parent_id=" + parentId; } else if ( traceId == null) { return "SELECT * FROM " + TRACING_TABLE + " WHERE parent_id=" + traceId; } else { return "SELECT * FROM " + TRACING_TABLE + " WHERE parent_id=" + traceId; } }
Since the logic is duplicated in the "else" block, it would be good to encapsulate it inside a method. Maybe like this: java private String searchTrace(String parentId, String traceId, String parentId, String traceId) { if (logic!= null) { return "SELECT * FROM " + TRACING_TABLE + " WHERE parent_id=" + parentId; } else if ( traceId == null) { return "SELECT * FROM " + TRACING_TABLE + " WHERE parent_id=" + traceId; } else { return null; } }
don't use PROPERTY_TIMEOUT as a integer, do we want to move this in JBoss7Tools?
don't need null check here
don't use PROPERTY_TIMEOUT as a integer, do we want to move this value to a constant?
Can you use CollectionUtils.isEmpty(snapshotList) here?
can you use CollectionUtils.isEmpty(snapshotList) here?
Can you use CollectionUtils.isEmpty()?
suggestion.collect(Collectors.joining("mismatched input '%s'. ));
suggestion.collect(Collectors.joining("mismatched input '%s'", ((Token) recognizer,...);
suggestion.collect(Collectors.joining("mismatched input '%s'", ((Token) recognizer,...));
add break
add break here
add break statement
Add space after!
Add space after if.
Add space after if
2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting exception object to string message?
2 things: 1) If a data exception is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting exception object to string message?
2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of exception logging work with casting exception object to string message?
Can be logged at warn level.
Can be removed and logged in warn level
Can be removed and logged in warn level.
If these are called more times, shall we add a try-with-resources block?
If these are called more times, shall we add a TemporaryFolder rule for this?
If these are called more times than once, is it reasonable to call it at the end of the method?
@adrielparedes here the call for metadatastore
@adrielparedes here the call for metadataStore.delete(alias) seems redundant now.
@adrielparedes here the call for metadata store
Shall we add the exception message to log?
Shall we add the log message as well?
Shall we add the logging level at DEBUG?
Maybe I'm not familiar with this test. It seems that I would able to ensure that the task is deleted in the db, when we test it.
Maybe I'm not familiar with this test. It seems that I would able to ensure that the task is deleted in the table (can't we just delete the artifact?)
Maybe I'm not familiar with this test. It seems that I would able to ensure that the task is deleted in the db, when we check the number of rows sent out of the app.
shouldn't this be just return sr.isGuest()?
shouldn't this be just return sr.isAdmin();
shouldn't this be just return sr.isGuest()?
Hmm.. Can we have an explicit commit message for this? It's not clear from the commit message.
Hmm.. can we have an explicit commit message for this? It's not clear from the commit message.
Hmm.. Can we have an explicit commit message for this? It's very annoying that we have the consumer ID in the log.
It appears that the logic of this file is duplicated in a few places. Can you extract it to a common method?
It appears that the logic of this line is duplicated in a few places. Can you extract it to a common method?
It appears that the logic of this line is duplicated in a few places. Can you extract it to a method?
Not sure what this code is for - it could be refactored into a method and reused in the PartitionDefinition class. Or even better, can we pass the idealStateModelDef to the constructor and use it here?
Not sure what this code is for - it could be refactored into a method and reused in the PartitionDefinition class.
Not sure what this code is for, but it could be made in a function which takes idealState as a parameter and returns a Partition.
Hey @oguzkocer, I think the log of the AuthenticatorException isn't necessary.
Hey @oguzkocer, I think the log of the AuthenticatorException isn't necessary here. AuthenticatorException is a wrapper for the access token response, not the access token
Hey @oguzkocer, I think the log of the AuthenticatorException isn't necessary here. AuthenticatorException is a wrapper for the access token response, not the access token.
return Optional.empty()
return Optional.empty()?
Class name?
Please remove the empty lines.
Please changes the assertions inside the tests.
Please changes the assertions inside the assertEquals() method.
Could be replaced with mTestDevice.reboot() now
Could be replaced with mTestDevice.reboot()
Could you do this in startDeviceOff instead?
This looks a bit reformatting and reformatting. Can we squash it into one?
This looks a bit reformatting and reformatting. Can we name it something like "timetime.b.c.d" to make it a readable one?
This looks a bit reformatting and reformatting. Can we squash this into one?
Be more explicit than concatenation. Also, instead of concatenation, you can use append.
Be more explicit than concatenation. Also, instead of concating it each time.
Be more explicit than concatenation. Also, instead of concatenation, you can use () -> {...}
It seems that in the "else" block, the "if" is redundant.
It seems that "outQueues.get(0).put(true)" is not needed anymore, because we're computing a single value.
It seems that "outQueues.get(0).put(true)" is not a great name to me. Perhaps something like "bufList" or something?
first it's the explain why we're validating that the exchange must not have partition channels, but also the FIXED_HASH_DISTRIBUTION
first it's the explain why we're validating that the exchange must not have partition channels
constants
shouldn't this be taken out?
shouldnt this be taken out?
shouldn't we remove this debug output?
This should be a warn.
This should be a ERROR.
This message may be a little better to print the exception.
can we move this to io.realm.internal.util.FileUtils?
can we move this to io.realm.xml so that way the file system is easier?
can we move this to 'else' block?
Please add here more than one value so we can get rid of the map.
Please add here more keys instead of just map values
Please add here more than one value so we can store it in a map.
It seems to me that we removed the getHostAndPortToUse method from the other services too, not sure if they really need it.
It seems to me that we removed the getHostAndPortToUse method from the other services too, not sure if it's worth having this as a static method.
it seems to me that we removed the getHostAndPortToUse method from the other services too, not sure if it's worth having this as a static method.
Same thing with mutation
if you don't have headerButton and footerButton you don't have to move + copy the elements
if you don't have headerButton.getParent()
This change is likely to cause issues. Could you please fix it?
This change is likely to cause issues. Could you please investigate more?
This change is likely to cause issues.
If you're doing this twice, maybe extract to a private method?
If you're doing this twice, maybe extract to a method?
If you're doing this twice, maybe you can extract to a method?
Please check if this should be handled differently. What do you think?
Please check if this should be handled differently as well.
Please check if this should be handled differently.
It is better to have these empty lines within the try block.
It is better to have a test that fails with an exception, rather than just an assert. If exception is not expected, then drop the exception.
It is better to have a test that fails with an IllegalStateException than just an IllegalStateException.
Boolean.parseBoolean(String) is a bit easier to read.
Boolean.parseBoolean(String) is a bit simpler
I think the string comparison should be done on the Spark component instead of its string.
Create a constant
Create a new method
Create a constant for this?
getRawContent() can return null, what's the point of this check?
getRawContent() can return null, what's the reasoning for this?
getRawContent() can return null. Is that ok for this to be calling getSlice()?
nit: space
nit: I think it's better to have an explicit factory for the dao
nit: I think it's better to have an explicit factory for the dao.
Why is this needed? I don't think we can just use PreferenceArray directly.
Why is this needed? I don't think we can just use import java.util.PreferenceArray for this.
Please add braces.
is this needed?
is it a good idea to not use this.registrationClient.watchWritableBookiesFuture here? you are using this.registrationClient.watchWritableBookiesFuture
is it a good idea to not use this.registrationClient.watchWritableBookiesFuture here? you are using this.registrationClient.watchReadOnlyBookiesFuture
Style nit: we don't use braces around single line blocks
Style nit: I'd use [If... } else if... {... } block of code is pretty long.
Style nit: I'd use [If... } else if...
Did you take a look at this? <LINK_0>
Same here, you should be able to check for NONE first
Same here, take out a test
Can you make this a constant like the others at the top?
Can you make this a constant like the rest of the class?
Can you make this a constant like the other classes?
Is the indentation off here for the method parameters? Shouldn't it be: private static void writeTilesToBlockBuilder( Geometry geometry, int zoomLevel, BingTile tile, BlockBuilder blockBuilder)
Is the indentation off here for indentation? Shouldn't it be: private static void writeTilesToBlockBuilder( Geometry geometry, int zoomLevel, BingTile tile, BlockBuilder blockBuilder)
Is the indentation off here for the method parameters? Shouldn't it be: private static void writeTilesToBlockBuilder(Collection geometry, int zoomLevel, BingTile tile, BlockBuilder blockBuilder)
you can run this once and cache the result, no?
please do not check the return code implicitly, I see there is getSucceeded() that can be used to raise an exception.
please do not check the return code implicitly, I see there is getSucceeded() that can be used to check it.
Same thing by current method or class.
Same question here, as this method is not thread safe.
Same question here, as this method is not required.
Shall we throw a specific exception here?
- We need to make sure that mPair.first is an empty string and not null, so we need to explicitly throw the exception here. - There's no need to catch and throw a runtime exception when it happens.
- We need to make sure that mPair.first is an empty string and not null, so we need to explicitly throw the exception here. - There's no need to catch and throw a runtime exception if this happens.
This won't increase the readability of the code. It will be nice to have the system property "true".
This won't increase the readability of the code. It will be nice to have a method for that.
This won't increase the readability of the code.
It may be better to use Object.equals for this instead of using getClass().equals.
It may be better to use Object.equals for this instead of using getClass()
It may be better to use Object.equals for this instead of using getClass().equals()
Does it make sense to have it private?
This should be removed, please move it to it.
This should be removed, please move it to lz
Why you use doc.put(OBJECT_HASH, 1);?
I think you can use doc.put(doc, 1);.
Why you use doc.put()?
This is unnecessary, because it's already done below.
This is unnecessary, because it's already in a constructor
This is unnecessary.
this can be a static method: RevisionResource getDescription() { if (!rsrc.getControl().getCurrentUser().isIdentifiedUser()) { return out; }... }
this can be a static method: RevisionResource getDescription() is the user id and not a description.
This can be a static constant.
file.getName().endsWith(".log")
file.listFiles() would be even better, especially if it is a directory?
file.listFiles() would be even better, since it does not return null.
this check should be inside the if/else clause
this check should be in the canDoAction() method to make sure the vm has to be created with no vms
this check should be in the canDoAction() method to make it accessible for all the daos
can you add some more unit tests for this class?
can you add some more unit tests that test this?
can you add some log.append() to separate line?
synchronized (LongJVMPauseDetector.this) looks like a bug
synchronized (LongJVMPauseDetector.this) seems like a bug
synchronized
You could say SSE_KMS operations must performed over a secure connection.
You could say SSE_C operations must performed over a secure connection.
You could use SSE_KMS as the write option to this file.
Why do we have to use StringBuilder here?
You should do better with spaces here, or use +
Why do we have to use random prefix for this?
+1 for the condition.
commonColumns can be Set<T> commonColumns = new LinkedHashMap<>()
+1 for this condition.
This fails to show the user on a large number of projects. So you probably want something like java while (scanner.getProjects().size() > projects.size()) { projects.addAll(projectInfo.getProjects()); }
This fails to show the user on a large number of projects. So you probably want something like: java File count = projects.stream().map(projectInfo -> { if (projectInfo.getPomFile().size() > 0) { projects.addAll(projectInfo.getProjects()); } } return count;
This fails to show the user on a large number of projects. So you probably want something like: java File count = projects.stream().map(projectInfo -> projectInfo.getPomFile().toPath().toString()).collect(Collectors.toSet()); assertEquals(count, projects.size());
Should the strings be moved to constants?
Why is this change necessary?
Should the strings be moved to Constants?
isn't this redundant?
isn't this redundant? call it from line185
isnt this redundant?
Why not to use Collections.singletonList()?
Why not to use Collections.singletonList()?
Why not using Collections.singletonList()?
Could you remove this line?
Could you remove shuffleKeys by only using shuffleKey? You could just use shuffleKeys
Could you remove shuffleKeys by channel?
Can you also use getAbsolutePath() here? I know the name was also used here when trying to copy the file.
Can you also remove this? I know the variable is already initialized in the constructor, but it's up to you?
Can you also use getAbsolutePath() here?
How is it reset if the test failed before?
How is it reset if the test failed before?
How is it reset if The test failed before?
The [Java naming convention](<LINK_0> encourage naming variables with a first letter as a word.
The [Java naming convention](<LINK_0> encourage naming variables with a first letter as a reserved word.
The [String] annotation annotation is missing.
Since you have to pass username and password into the function, do we really need this?
Since you have to pass username and password as arguments, I think it would make sense to make them configurable.
Since you have to pass username and password as arguments, I think it would make sense to remove it just in case the database is not loaded.
you are reading only a state, you should be saving the value to a local variable before the loop.
you are reading the json twice in the test
you are reading the json twice in the PR
nit: final
nitpick: final
final
I think we could use new ArrayList<Parameter>( sourceParamSafeName, param ) and move this line into forgedMethod
I think we should use new ArrayList<Parameter>( sourceParamSafeName, param )
I think we could use new ArrayList<> here
Agreed. Maybe we should add a server error message as a default.
Agreed. Maybe we should add a server error message as a cause and use it in the catch block.
Agreed. Maybe we should add a Log statement here as well.
Kind of weird to see the extra parentheses in this method.
Needs to be rebased on the previous change.
Kind of weird to see the same code anywhere.
Please use isEmpty()
Please use StringUtils.isEmpty()
Please use StringUtils.isEmpty, with a null check.
you could here return the oldLabelProvider
you could here return the oldLabelProvider?
you could here return the old one
Can you replace the two loops with a call to mCheckedCardPositions.get(NOTE).equals(checkedPositions) instead?
Can you use TextUtils.equals(checkedCardCount, i.e. length)? It's a bit confused about which variable's name.
Can you use TextUtils.equals(checkedCardCount, i.e. length)? It's a bit clearer (and we can select the note for note).
Could we use GIP_ENCODING.equals(info.getContentEncoding()) instead of ||?
Could we use GIP_ENCODING.equals(info.getContentEncoding()) instead?
Is it possible to use GIP_ENCODING.equals(info.getContentEncoding()) instead of GIP_TYPE comparison?
Please change the logging level to trace or remove it.
please use {}.
please use {}
Maybe its better to use interval terminology here, perhaps LeftEndpoint and RightEndpoint?
Maybe its better to use interval terminology here, perhaps LeftAddress and RightEndpoint?
Maybe its better to use interval here, perhaps LeftEndpoint and RightEndpoint?
have we seen this error before?
have we seen this error before? Seems like it could be useful
have we seen this error before? Seems like it could be useful for debugging
I am wondering if setting the id to the Singleton should avoid creating the object on every iteration. What do you think?
I am wondering if setting the id to the Singleton would be better (using an Id) to avoid creating the object with a null id
I am wondering if setting the id to the SingletonList or using the createResourceGroupSelectionContext?
You are using this sleep more than once. In this case, the listener is not used.
You are using this sleep more than once. Is there a way to avoid this?
You should be able to use the DescriptorImpl instead of the static import
Code style: Unnecessary curly braces.
Code style: Space after if
Code style: Space after if.
Probably worth caching the NeededData in a field for readability with getMaxNeededData()?
Probably worth caching the NeededData in a field for readability?
Probably worth caching the NeededData here?
Shouldn't this be idempotent?
Cosmetic: Braces on new lines please. :)
Shouldn't this be 404 instead?
try-with-resources
Same here, try-with-resources
try-with-resources?
Static import
Static import the assertion methods
Static import the constants
The logic here is completely different from the check for the full driver. markForAutoClose(currentThread()); should be moved outside of the if.
The logic here is completely different from the check for the full driver. markForAutoClose(currentThread()); should be moved into the method.
The logic here is completely different from the check for the full driver. markForAutoClose(currentThread()); should be moved outside of the method.
LOG.info("Getting jar file from {}", tarFile);
LOG.info "Getting jar file from {}", tarFile);
LOG.info("Getting jar file from {}", tarFile);?
please merge with setUriInfo()
please verify response here with in call
please merge with setUriInfo() call
Same answer. Note the java doc explanation of the test. Basically if someone presses escape somehow it causes an http status code of 0 which in the Frontend code is an ignored failure, so we want to ignore the result.
Same answer. Note the java doc explanation of the test. Basically if someone presses escape somehow it causes an http status code of 0 which in the Frontend code is an ignored failure, so it causes an http status code of 0 which in the error message.
Same answer. Note the java doc explanation of the test. Basically if someone presses escape somehow it causes an http status code of 0 which in the Frontend code is an ignored failure.
I think we should log a warning here too, to debug the issue
Won't this go to stderr?
Log here too, also
ComplianceStatus....
Minor thing, but it would be nice to change this to!consumer.hasFact("virt.uuid") &&!consumer.getFact("virt.is_guest"))
ComplianceStatus. Is it possible to change this around?
I think it's better to only check if the transaction is present, rather than catching the exception (but I could be wrong).
I think it's better to only check if the transaction is present, rather than catching an exception (or at least log the exception you got).
I think it's better to only check if the transaction is present, rather than catching an exception.
Shouldn't this be in the if clause?
Shouldn't this be in the reverse way?
Should be done in the constructor
This method is getting called at two holidays at once
This method is getting called multiple holidays at once
Was this a holiday?
Unclosed stream?
Unqualified access to the system property.
Unqualified access to private static final ByteArrayOutputStream
This equals implementation should include attributes from the Command super class.
Please implement equals() to provide debugging state information for debugging purposes.
This equals implementation should include attributes from the equals method.
if (w2 == null || w2 == null) { return -1; } else if (!w1.equals(o2); return w1 - w2);
can we use w1 == o2.getClass().Weight(o2)?
can we use w1 == o2.getClass().getName()?
@dmzaytsev let's also assert that the attributes are different.
@dmzaytsev let's also assert that the list matches thekat
You don't need to test for the full list of the parts.
What do you think about the following codes: assertTrue( conn.close().getPreparedStatement().close().commit(); assertFalse(conn.close();
What do you think about using the salt byte and the password here?
What do you think about using the salt byte and read from the conn?
Are there no other standard utilities or libraries that can get this information?
Are there no other standard utilities or libraries that can be used?
Remove this?
Minor nit: Why thenReturn 3? Just for debugging purposes?
Minor nit: Why thenReturn 3 times?
Was this change intentional?
You should test whether the matches.get(0) and then a non-empty list.
You should test whether the matches.get(0) and then a non-zero one.
If getMatches() returns an empty list, the test will fail.
nit: This assertion is redundant.
nit: redundant.isEqualTo(EXPECTED_ROUNDS.stream() % 2!= 0)
nit: EXPECTED_ROUNDS.stream() * 2!= 0
magic? extract inc to a variable
magic? extract to constant
magic? extract inc to a constant
This means that exception during xml parsing will be logged, and the map containing a single element (for the current server) will be returned. This is wrong. I think you should throw an exception in all error conditions, except the ones while fetching fingerprints.
This means that exception during xml parsing will be logged, and the map containing a single element (for the current server) will be returned. This is wrong. I think you should throw an exception in all exception conditions, except the ones while fetching fingerprints.
This means that exception during xml parsing will be logged, and the map containing a single element (for the current server) will be returned. This is wrong. I think you should throw an exception.
This part of the PR looks like it can be removed.
This part of the PR looks like it can be removed. If we have a util method for this then we can call it from AddCallback.
There are some "isNotEmpty" check here.
else is not needed
else if
else if?
Are consecutive reloads necessary or will be one reload at the end sufficient?
I prefer to not use static imports in tests.
Please remove unnecessary blank line
seems like it's better to avoid null and empty map. This can be done in a more simple way: assertEquals(new HashMap<>(null, null, null, null, 0));
seems like it's better to avoid null and empty map.
assertNull
log.warn in default block is a good idea, but we should have case FAST_FORWARD: no?
log.warn in default block is a good idea, but we should have case FAST_FORWARD.
Micronit: could decrease indentation by handling this case up front.
I would put this in another test to follow the same if/when/then/else to make it easier to read. Something like: Java return Optional.of(lineItemStateTransitionMessage.getTransitionDate(), order -> { return Optional.of(lineItemStateTransitionMessage.getTransitionDate(), order.getMessage()); }).hasValue(number -> { return lineItemStateTransitionMessage.getQuantity(); }
I would put this in another test to follow the same if/when/then/else to make it easier to read. Something like: Java return Optional.of(lineItemStateTransitionMessage.getTransitionDate(), order -> { return Optional.of(lineItemStateTransitionMessage.getTransitionDate(), order.getTransitionDate()); }
I would put this in another test to follow the same if/when/then/else to make it easier to read. Something like: Java return Optional.of(lineItemStateTransitionMessage.getTransitionDate(), order -> { return Optional.of(lineItemStateTransitionMessage.getTransitionDate(), order.getTransitionDate()); } to save indentation of the test.
These can be replaced with simplier: java try ( Long address = createAttachedChain(readKeyBuffer, hash, iterator.next().getPayload()) { return null; }
These can be replaced with simplier: java while (iterator.hasNext()) { try (AttachedInternalChain chain = new AttachedInternalChain(readKeyBuffer, hash, iterator.next().getPayload())) { return null; } } return null;
These can be replaced with forEach
We could use I_PP_ComponentGenerator_Param.forValue( I_PP_ComponentGenerator_Param.class) here.
We could use I_PP_ComponentGenerator_Param.forValue(I_PP_ComponentGenerator_Param.class) here.
We could use I_PP_ComponentGenerator_Param.forValue( I_PP_ComponentGenerator_Param) here.
respones -> responses
Instead of using.reduce(false), you can use assertEquals(Arrays.asList(1, allTagsReduced)).
Instead of using.reduce(false), you can use assertEquals(Arrays.asList(1, allTagsReduced))
I know it's not your patch but those 5 lines should be replaced by: grouped.keySet().removeAll(collection);
I know it's not your patch but those 5 lines should be replaced by: grouped.values().removeAll(collection);
I know it's not your patch but those 5 lines should be replaced by: grouped.values().forEach(p -> p.add(p));
i wonder if getQueryData should be a method on the baseQuery object. Then there is no need for query data.
i wonder if getQuery data should be a method on the baseQuery object. Then there is no need for query data.
i wonder if getQuery.getDataSource() should be a method on the baseQuery object. Then there is no need for query object.
assignment is missing
assignment is redundant
naming
I would recommend versionId = "" can be allowed i.e. if (queryParamMap.length()!= 0)
I would recommend versionId = "" can be allowed i.e. if (queryParamMap.isEmpty())
I would recommend versionId = "" can be allowed i.e. if (queryParamMap.containsKey(key))
please just keep the method name as a final static member variable
please just use StringUtils.equals() for both conditions
please just keep this method private.
why debug level and not error?
pass the error stack trace to debug method and use the trace level
pass the error stack trace to debug and not use e.getMessage()
Would it make sense to return volumes with size -1?
Would it make sense to return volumes with size 0?
Would it make sense to return volumes with size 1?
I don't think this will work well if file is in the.txt resource. We need to replace it with a null pointer exception.
I don't think this will work well if file is in the repo before we can have a symlink to a directory. It would be a good idea to throw an exception during the call.
I don't think this will work well if file is in the.txt resource. We need to replace it with a null pointer exception. It should be added in the callers of the method so we don't have to throw an exception.
Might be better to just check that the configuration file is the same as jut the one configured in the ConfigurationSource
Might be better to just check that the configuration file is the same as jut the one configured in the ConfigurationSource - not the other.
Might be better to just check that the configuration file is valid and print that it is.
Do we need a separate function for this? Can we have just a single addAndDismiss function and have it return a boolean as isOnboarding?
Do we need a separate function for this? Can we have just a single addAndDismiss function and have it return a boolean as well?
Do we need a separate function for this? Can we have just a single addAndDismiss function and have it return a Notification?
shouldn't it be rather: if (buf.write(req.getParameter("service"))) {?
shouldn't it be handled by server stuff like this? java try { // init resource } finally { try { // release resource } }
shouldn't it be handled by server stuff?
It shall be StringUtils.isBlank( )
It is good practice to flip the toString
It is good practice to flip the toString equals
Maybe putting the Comparator.comparingInt( ) as a static constant?
Does this have to be public? This should be made private.
Does this have to be public? This should be enough: <LINK_0>
This isn't actually the behavior we want. Until now, the cache instance will be shared with the DefaultSession instance itself, which isn't the case if there was a request with the same session id. So this line here should be: try { return cache.get( request, () -> new CqlPrepareHandler(request, session, context, sessionLogPrefix)); } catch (ExecutionException e) { return CompletableFutures.failedFuture(e.getCause()); }
This isn't actually the behavior we want. Until now, the cache instance will be shared with the DefaultSession instance itself, which isn't the case if there was a request with the same session id. So this line should be: try { return cache.get( request, () -> new CqlPrepareHandler(request, session, context, sessionLogPrefix)); } catch (ExecutionException e) { return CompletableFutures.failedFuture(e.getCause()); }
This isn't actually a racy implementation, as the cache instance could be shared by multiple threads.
you aren't removing duplicated entries...
you're missing braces around multi-line blocks
you're missing braces here.
no need to undo this?
no need to work 0 here, 1 byte byte is enough.
no need to work 0 here, 1L
instance variable future.get() could be replaced with future.get()
instance variable future.get() can be replaced with future.get()
instance variable future.get() can be removed
There's a typo in redisTokenEntry.
There's a typo in redisTokenEntry
There's a typo here.
This is thinking about how we can add something like [] attrs.putAll(Files.readAttributes(path, "posix:permissions") above this line wouldn't be necessary.
This is thinking we need to materialize the map entries in the metadata.
This is thinking about missing docs
is this required?
java return String.format(Locale.ROOT, "jdbc:hive2://%s:%d/");
java if (context.indexOf("HIVE") > -1) { //... }
This is not optimal for localization (for languages that don't use arabic numerals). Consider using something like NumberFormat.getInstance().format(count)
This is not optimal for localization (for languages that don't use arabic numerals). Consider using something like NumberFormat.getInstance().format(count);
This is not optimal for localization (for languages that don't use arabic numerals). Consider using something like NumberFormat.getInstance().format(count).
Why we want to fail such queries? Presto can still query from such table if we disable bucket-by-bucket right -- Also it depends on our configuration on hive.max-outstanding-splits-size right?
Why we need to fail such queries? Presto can still query from such table if we disable bucket-by-bucket right -- Also it depends on our configuration on hive.max-outstanding-splits-size right?
Why we want to fail such queries? Presto can still query from such table if we disable bucket-by-bucket?
Maybe it's better to use IntNode for zero value in this method.
Maybe it would be better to use IntNode for zero value in this method.
Maybe it's better to use IntNode for zero value in the error message to be consistent with the original message.
Add context specific message without using e.getMessage().
Add context specific message without using e.getMessage()
Add context specific exception without using e.getMessage().
Why not use isEqualTo(elements.get(0)) and then isEqualTo(elements.get(1))?
Why not use isEqualTo(elements.get(0)) and then isEqualTo(elements.get(0))?
Why not use.hasSize(elements.size())?
As discussed, lets make sure the validation of the value is valid by the way, e.g., assert that the contents are missing.
As discussed, lets make sure the validation of the value is valid.
As above, would probably be good to assert that the contents of the map are different by the expected value
This unload should be called before NLgmer.run() because the file is not necessarily a NuxeoException.
This unload should be called before NLgmer.run() because the file is not really mutable.
This unload should be called before NLgmer.run() because the file is final and not leaked for other changes.
why are we adding the Replica_Unavailable here?
Why are we adding the Replica_Unavailable here?
why are we adding the exception here?
This should be checked in the testAfterPropertiesSet_codeListIdPattern_is_notnull.
This should be checked in the testAfterPropertiesSet_codeListIdPattern_is_notnull().
This code pattern should be extracted to a constant because it's used multiple times in the test.
onErrorMap?
onErrorMap()?
onErrorMap
I think it would be better to wrap this block in a try-with-resources block, e.g.: try (LedgerManagerFactory storage = new LedgerManagerFactory(conf, conf.getDiskUsageThreshold(), new kLayoutManager()) {
I think it would be better to wrap this block in a try-with-resources block, e.g.: try (LedgerManagerFactory storage = new kLayoutManager()) { Bookie.checkDirectoryStructure(dir); storage.close(); }
I think it would be better to wrap this block in a try-with-resources block so it can be closed by try(closeable) { }
getFeedTitle() should still be called even if the media info is not available. Please only remove the method.
getFeedTitle() should still be called even if the media info is not available. Please only remove the extra space here.
no need for this var to be private
@yesamer Please replace this whole loop with a single call to addFactMapping(i, clonedFactIdentifier, clonedExpressionIdentifier).
@yesamer Please replace this whole loop with a single call to setFactMapping(i, clonedFactIdentifier, clonedExpressionIdentifier).
@yesamer Please replace this whole method with a one argument.
I'm not sure whether this is the right exception to TskCoreException. What do you think about a TskCoreException here?
I'm not sure whether this is the right exception to TskCoreException. What do you think about a TskCoreException here, or throw one?
Does this mean the file is already EXISTS? What if SHA-256 is EXISTS?
You don't need to add the.format here to put the lines there's no need to modify the toString to put the information to the toString.
You don't need to add the.format here to put the lines there's no need to modify the toString to put the information into the NLS tag.
You don't need to add the.format here to put the lines there's no need to modify the toString to put the information to put in the NLS.
Since this is important then we should have the same log message as the exception.
Since this is important then we should have the test that validates that we never lose the exception.
Since this is important then we should have the same log message as the other one.
.option(ChannelOption.SO_BACKLOG, 1024).handler(new LoggingHandler(LogLevel.INFO))?
.option(ChannelOption.SO_BACKLOG, 1024).handler(new LoggingHandler(LogLevel.INFO));?
.option(ChannelOption.SO_BACKLOG, 1024).childHandler(new HttpNativeServerInitializer());
nit: This is really just a plain old function object rather than a functor.
nit: This is really just a plain return, rather than a functor.
nit: This is really just a plain old Proxy, rather than a functor.
I would factor the opening curly bracket to the previous line
I would factor the opening curly bracket to the next line.
I would factor the opening curly bracket to the previous line.
rename to ignoredESet
rename to target
rename to 'child'
this 3 lines of code is repeated several times. Did you mean to have a common test in it?
this 3 lines of code is repeated several times. Did you mean to have a common test for this?
this again could use the constant in ClockModel to avoid copy-paste completion
My main concern with this is that if there is a ping to another channel, it should still be considered a PingError and in that case the ping failed. (As we were testing this issue since it is handled internally by the PingRunHandler.setUpEvent() callback). We could consider adding a info log that says "Ping failed to terminate the channel".
'in'?
'null'?
systemName + " nominal speed..."
systemName, etc
systemName, systemName are not used
Perhaps you need to apply the context class to a context?
Perhaps you need to apply the context class to the filters using the context class from the context? This will allow the context to be passed to a Context.
Perhaps you need to apply the context class to the filters using the context class from the context?
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why ConfigContext needs to explicitly be referenced? We allow config contexts that don't start with the defaults?
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why ConfigContext needs to explicitly be referenced? We allow config.disableNativeSignatures() to switch to XD
Is it necessary to cast to project here?
Is this really necessary? Because of how you do it?
Is this really necessary? Because you check should not delete the project in the current folder by editing the project.
Do we expect this to throw an exception here? If we have to do this, we should either log or throw an exception.
Do we expect this to throw an exception? Throwing an exception is more appropriate here.
Do we expect this to throw an exception? Throwing an exception is a bad practice.
Was this logic redundant?
java public static Set<String> getAggregatorSpecs() {
Was this logic to be in the constructor?
I must be missing something, but it looks like less code
Please remove this empty line.
Please remove this empty line
Please put back the parentheses around (getIndexForKey(previousChildKey) + 1). The behavior is the same, but it makes the intent more explicit.
Please put back the parentheses around (getIndexForKey(previousChildKey) + 1);. The behavior is the same, but it makes the intent more explicit.
Please put back the parentheses around (getIndexForKey(previousChildKey) + 1);
Use isEmpty() instead of size
Use isEmpty() instead of size > 0.
You need to use the diamond operator here.
Here you assign the return value of FeedbackMcqResponseDetails to a variable and then you call the method as before.
Here you assign the return value of FeedbackMcqResponseDetails to a variable called Slots.FRAGMENTS, since the method is only called from line 189.
Here you assign the return value of FeedbackMcqResponseDetails to a variable called Slots.FRAGMENTS, since the method is only called from line 168 and the line 390 is not needed.
The log message is about to be interpreted as a debug message. Should we reword the message to make it consistent?
The log message is about to be re-used, we should probably change "exception" to be more useful.
Should we log the exception here?
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this line start at column 9. [![rule](<LINK_2>](<LINK_1>
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this line start at column 9. [![rule](<LINK_1>](<LINK_2>
Minor: How about using a logger for this instead of System.out?
You should be using a private method here.
You can use a static variable here.
You can use a static variable here to avoid duplication.
Is this the right log level?
Is this the right log level? I think it should have the publisher level notification?
Is this the right log level? I think it should have the publisher log: // warn.
Have you tried to fix this? I'm not sure if there is any issue with this.
Have you tried to fix this? I think there are some failures that would cause this method to throw IndexOutOfBoundsException.
Have you tried to fix this? I think there are some failures that would cause the creation of the exchange to fail.
If there's no other iteration, then BEFORE_BARRIER_MSG should be removed?
If there's no other iteration, then BEFORE_BARRIER_MSG should be removed.
If there's no key for which the value is 0?
Are you doing an explicit flush, better to ClientResponseImpl.setUpValue(e);
Are you doing an explicit flush, better to move to a finally block?
Are you doing an explicit flush, better to ClientResponseImpl.setUpValue(true);
This should be final. The variable msgbuf will be assigned to a new ArrayList every time it has been created.
This should be final. The variable msgbuf will be assigned to a new ArrayList below.
This should be final. The variable msgbuf will be assigned to a new ArrayList every time it has been added.
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
While we're in here, could you replace that with this: for (Object selectedObj : structured.iterator()) {
While we're in here, could you replace that with this: for (Object selectedObj : structured) {
Use UUID.randomUUID().toString()
String.fromString can be used instead of the hard-coded UUID.
String.fromString can be used instead of the hard-coded UUID
Should be fixed.
Why are we force to wrap this whole thing inside a function?
Why are we allowed to use Duration here?
or just use this... throw new IllegalArgumentException(String.format("classpath: %s not found for MicroProfile Rest SSL configuration"));
Can you use try-with-resources?
Either this is needed or it should be moved into a finally block.
I suggest the check to make sure the variable is not null and the value is populated.
I suggest the check to make sure the variable is not null and the value is populated. Since the JVM will handle this automatically, we have a constraint for the existence of the lazyload.
I suggest the check to make sure the value is fully initialized before the for loop.
use createSafeXmlSource here too
use createSafeXmlSource
use createSafeXmlUtil here too
Unchecked cast
UncheckedIOException
Unchecked assignment
what do you think about the following? final IFile file; final Repository repository2 = repository; if (repository2!= null) { file = ResourceUtil.getFileForLocation(repository2, path, false); resources.addAll(Arrays.asList(ProjectUtil.getProjects(repository2))); } else if (file!= null) { resources.addAll(Arrays.asList(ProjectUtil.getProjects(repository2))); } else { resources.addAll(new IResource[0]); }
what do you think about the following? final IFile file; final Repository repository2 = repository; if (repository2!= null) { file = ResourceUtil.getFileForLocation(repository2, path, false); } else if (file!= null) { files.addAll(Arrays.asList(ProjectUtil.getProjects(repository2))); } else { //.... }
what do you think about the following? final IFile file; final Repository repository2 = repository; if (repository2!= null && repository2!= null) { file = ResourceUtil.getFileForLocation(repository2, path, false); } else if (file!= null) { files = ResourceUtil.getFileForLocation(repository2, path, false); } else { files = ResourceUtil.getProjects(repository2))); }
Should be setId(lookupKey)
Redundant else
Weird..
Again, please don't make recursive RPCs, use data from the ProjectDetail object.
Again, please don't make recursive RPCs, but instead add the necessary data to the ProjectDetail object.
Again, please don't make recursive RPCs, but instead addPanel and addPanel directly.
I think it should be a pre-existing PR.
I think it should be safe to use.iterator().next() here instead of multiple calls to.next().
I think it should be a pre-existing check. If files are not there, it should be a check and log a warning.
Accidental white spaces?
Maybe we could use StringBuilder here?
GAVCE should be a constant
missing spaces around =
missing @Override declaration and initialization of the result
missing newline at the end of the string?
Please write a try-finally block here, and the unlock is in the finally block.
Please write a space between if and (
Please write to the variable here, and in the other files.
Same here. Let's remove this line
We can remove this line right? Since we are returning products at the end of this method anyway.
We can remove this line right? Since we have products at the end of this method anyway.
I'm not sure this is correct. The template is "Branch %s[%s] is an undeleted branch and that option was not specified!" I will not be purged! I'd suggest changing it to "Branch %s\" is not specified!".
I'm not sure this is correct. The template is "Branch %s" not BranchArchivedState.ARCHIVED
I'm not sure this is correct. The template is "Branch %s" not BranchArchivedState.UNARCHIVED
Share the 'validateArchivePath' method.
No need for the 'validateArchivePath' method.
No need for a first line here.
I think this is not enough. In case of an exception, maybe it would be good to not wait for the state to finish (multi-process enabled), and then wait for the time left.
I think this is not enough. Otherwise, as the user will see the idle state, even if it is not actually started.
I think this is not enough. In case of an exception, maybe it would be good to not wait for the state to finish (multi-process enabled), but then wait for the time left.
The test class doesn't specify the @Test public void testConfigureParquetAppender() throws IOException, so better to remove the throws clause.
The test class doesn't specify the @Test public void testConfigureParquetAppender() throws IOException, which is why the test harness is not generated.
The test class doesn't specify the 'Schema' type.
I think a JTS Order is not guaranteed here? Wondering if we can use CRSDefinition.getCRSDefinition().getCRSDefinition().getCRS() instead, or at least use the JTS Order class
I think a JTS Order is not guaranteed here? Wondering if we can use CRSDefinition.getCRSDefinition().getCRSDefinition().getCRS() instead, or at least use the JTSOrder constant?
I think a JTS Order is not guaranteed here? Wondering if we can use CRSDefinition.getCRSDefinition().getCRSDefinition().getCRS() instead, or at least use the JTSOrder constant
This assertion is repeated multiple times - please rename to assertion...
This assertion is not required any more.
This assertion is not necessary... I would rename the method and the line below
Can't we use SecurityManagement.isSecurityManagement instead of this code?
Can't we use keyStore instead of '!= null'?
Can't we use keyStore instead of 'String'?
Why don't you use String.format?
Why don't you use the "current_points_text" instead of hardcoding?
Why don't you use the "current_points_points_text" instead of hardcoding?
This code seems to be the same as the code in List<Entity>. Instead of adding a switch statement here, how about the following: if (selectorType == SelectorTypes.RANDOM) { return Math.abs(maxToSelect); } // We should use the normal if (isReversed) {... }
This code seems to be the same as the code in List<Entity>. Instead of adding a switch statement here, how about the following: if (selectorType == SelectorTypes.RANDOM) { return Math.abs(maxToSelect); } // We should use the normal if (isReversed) { return (hasWrapSize(distanceSort(isReversed)) }
This code seems to be the same as the code in List<Entity>. Can we reuse it?
I think the return value of getImageInfo() should be null.
I think the return value of getImageInfo() should be return null.
I think the return value for getImageInfo() should be null.
This should be moved to load loadSourceMap, no?
Use getServerManager().getLoadSourceMap(peerList, SSLPeerName) to get the sorting.
Use getServerManager().getLoadSourceMap(peerList, SSLPeerName) and remove StoreClient.load()
This is wrong. The test is supposed to be showing up unconditionally, not just the build folder. How about java return Lists.transform(review.getFiles(), new Function<ReviewFile, String>() { @Override public String apply(ReviewFile review) { return file.getReviewFilename().SRC_MAIN).substring(0, file.getReviewFilename(), SRC_TEST).concat(getTestBuildDir()); } });
This is wrong. The test is supposed to be showing up unconditionally, not just the build folder. How about java return Lists.transform(review.getFiles(), new Function<ReviewFile, String>() { @Override public String apply(ReviewFile review) { return file.getReviewFilename().SRC_MAIN).substring(0, file.getReviewFilename(), SRC_TEST).parse(getTestBuildDir()); } });
This is wrong. The test is supposed to be showing up unconditionally, not just the build folder.
Better to use setUsePlaintext(true) here.
Better to use setUsePlaintext(true) here, instead of 400
Better to have this as a constant
I think it would be more clear to return a void instead of void.
I think it would be more clear to have if(!plugin.isNotAvailable()) return 0; in a try-with-resources block
I think it would be more clear to have if(!plugin.isNotAvailable()) return 0; in a try/catch block and return 0; to have the same effect
Change to deactivatedBeneficiciary.
Change the logging to a logger.
Change to.isEmpty() instead.
I think you should move all the 'if' outside of the loop
I think you should reset all the 'leftRelationships' into a separate loop
I think you should reset all the 'leftRelationships' into a separate try catch
HasPlainJavaAnnotationsOnly already returns true, so why not just return false here?
HasPlainJavaAnnotationsOnly already returns true, so you can remove the check here.
HasPlainJavaAnnotationsOnly already returns true, so why not just return the result?
If this is an error, should we return a null?
If this is an error, please log a warning.
If this is an error, should we throw an exception?
This isn't necessary, because of the previous if (result.monitoring == null) {... } block?
This isn't necessary, because of the previous if (result.monitoring == null) { return; }...
This isn't necessary, because you just don't include the log message below.
I think this could be moved to a private method
I think this could be moved to a private method.
I think this could be private.
Please add a finally block to these two methods.
Why are we sleeping here?
use FileOutputStream.Compare() instead of this
suggestion Optional<Long> firstVersion = timestampMapping().values().stream().map(LockWatchVersion::version).min(Long::compareTo);
suggestion Optional<Long> firstVersion = timestampMapping().values().stream().map(LockWatchVersion::version).max(Long::compareTo);
suggestion Preconditions.checkState(firstVersion.isPresent(), "Cannot compute timestamp mapping for empty map of timestamps", firstVersion.get(), lastVersion.get());
Not sure this is a good work. On the other hand, if we _doAdd_ is not null, we will have a NPE here.
Not sure this is a good work. On the other hand, if we _doAdd == true_ we have to declare a new Boolean object, which is work and pass it to loadNotifications. But why?
Code style: space after if
Forge compat will be possible to get the weight from the EntityTypeRegistryModule.
This line should come [line 247](<LINK_0> to avoid code duplication.
This line should come [line 247](<LINK_0>
Is this code duplication between removeLink and removeLinkIfAbsent?
Is this code duplication?
Is this code duplication? Looks like it was reverted from public.
This should be replaced by List.comparing(BootLogic::isBootLogic).
The same for the non-BootLogic class.
This should be replaced by System.err.println(rs);
Shouldn't need to unsubscribeNoticeAfter and defaultEnd, since it's a property that is already empty.
Shouldn't need to unsubscribeNoticeAfter and defaultEnd, since it's a property that is already there.
You should add a space ", " (String[]) textParameters) before the if body.
Please move to to the beginning of the next line.
Please make a separate old action, if it's really necessary?
This looks weird?
Why do we add the same kind of issues as well? If we are to keep them in a single line, it doesn't matter that much.
Why do we add the same kind of issues as well? If we are to keep them in a single collection, and then we can safely use SortedSet. It will also take care of that.
Question: Why do we want a Set here? If yes, then why not, then all the other issues.
<LINK_0> Do we need the default state?
<LINK_0> Do we need the default state for INIT?
Context leak
Should we have a check for this?
Should we log this error?
Should we have a check for this before the loop?
@spyrkob it looks like this class does not do anything with ADAL Product.
I believe Travis will fail with the same failure. This needs to be fixed.
@spyrkob it looks like this class does not do anything with the same permissions for 15 seconds?
Is there a reason not to use iterator?
Is this really necessary?
Is this really necessary? We could have a batch here?
s/heads/master/origin/?
s/heads/master/name/
s/heads/master/name/?
Other places we use getNullable to simplify this. It's not clear.
Other places we use getNullable to simplify this message. It's not clear.
Other places we use getNullable to simplify this.
This change is not needed.
This change is not really needed.
This change is incorrect.
we can combine this check with the if above and skip validation if it's not present.
we need to validate whether the variable is present and skip this validation if it's not present
we can combine this logic to one method validateTrialInstanceValue.
new Date()
new line
new Date()?
I hope the event producers are not shared across the connectors?
I hope the event producers are not shared across the connectors? We don't need to make this change if it is needed.
I hope the event producers are not shared across the connectors? We don't need to make this change if it is harder.
Is this change required?
If you use the short buffer, don't use the byte buffer.
Is this the right way to go if you use the short buffer? Can you use the short buffer for it?
@ktoso What was the reason for this not getting caught by the implementations?
@ktoso What was the reason for this not getting replaced by the implementations?
Get rid of this duplication please :)
i think that code should be like this: if (getVm()!= null) { return; }
i think that code should be like this: if (getVm() == null) { return; }
i think that code should be like this: if (getVm()!= null && getVm()!= null) {
need to be BIG_LONG_MAX_VALUEONE instead of ONE
need to be synchronized too?
need to be BIG_LONG_MAX_VALUEONE instead of ONE_THING
This is kinda a duplicate, it should be in a utility method or a utility method (i.e. is not waited here).
This is kinda a duplicate, it should be in a utility method or a utility method (i.e. is not waited in case of element not found).
This is kinda a duplicate, it should be in a utility method or a utility method (i.e. is not waited in case of exception).
Maybe we should have a default value of DEFAULT_COMMIT_LOG_COUNT?
Maybe we should use warn, not error.
Maybe we should use warn, not error?
@garg-anuj Yeah, I'm not sure what the intention is here, but we can save a lot of code.
@garg-anuj Yeah, I'm not sure what the intention is here, but we can save a lot of code and the boolean return value.
@Nullable
I think the testRealmResource().groups("otp_group",0,0,1).get(); is better.
I think the testRealmResource().groups("otp_group",0,0,1) get(); should do the same thing.
I think the testRealmResource().groups("otp_group",0,0,1) and this testRealmResource() should do the job.
Do we need to check if it's null?
Do we need to check if it is null?
Do we need to check getMaxWaitDuration()!= null
modelFile can be extracted to a method called performFinish so that we don't have to create the resource
modelFile can be extracted to a method called performFinish so that this method can be reused
modelFile can be extracted to a method called performFinish so that this method can be reused.
This assertion is redundant since you are already doing this assertion.
This should be changed to debug.
This assertion is redundant since you are already doing this assertion right?
Simply printing an error will cause it to be overlooked, and users may be confused by the result. I think this should throw an exception instead.
Simply printing an error will cause it to be overlooked, and users may be confused by the result. I think this should throw an exception.
Why is this change necessary? The printed arguments list should be get filled with the expected values. I think this should throw an exception instead.
I don't think this is needed since UnsupportedEncodingException is already caught by the catalog service implementation.
I don't think "inline" is necessary here since UnsupportedEncodingException is already caught by the catalog service implementation.
I don't think this header should be used at all. This is already handled by the catalog service implementation.
Does this need to be public?
Does this need to be a separate test?
Does this not help us identify where both cells are paletteed?
The check if null
The check if null?
rename to sort
This shouldn't be here.
This shouldn't be these last 3 lines.
The settings?
Shouldn't this be config.nettyMetricsRefreshIntervalSeconds?
Shouldn't this be config.nettyMetricsRefreshIntervalSeconds?
Shouldn't this be config.nettyMetricsRefreshIntervalSeconds * 1000?
Please use if-else
Please use ERO_DAY constant
Please use ERO_FLOAT
Can we add a message saying what was the mounts to be?
Can we add a message saying what's wrong?
Can we add a message saying what was the mounts expected to be?
It's preferable to change the existing method (to pass the currURL) to avoid code duplication.
It's preferable to change the existing method (of pass the currURL) to avoid code duplication.
It's preferable to change the existing method (to pass the currURL) to avoid method calls.
this should probably be initialized on constructor?
These should probably be initialized on constructor?
These should probably be initialized on constructor.
remove, dead code.
remove.
remove
rename to launch or launch
rename to launch or component
rename to launch or config
how about replacing those with: getVm().setUseHostCpuFlags(false);
note that the VM compatibility version may be different than the cluster configuration?
note that vm can be null here, right?
this method should be private
this method is static
this method is not thread safe.
I know this is not part of the change, but we don't need to change this code: "if (hasForwardedHeaders(request)) {" which calls remoteAddressO.map(InetSocketAddress::getHostName).orElse(-1)"
I know this is not part of the change, but we don't need to change this code: "if (hasForwardedHeaders(request)) {" which can be passed to the UriComponentsBuilder.fromHttpRequest(). This is what we need. The remoteAddressO.map() method does the same thing as called from removeOnly.
I know this is not part of the change, but we don't need to change this code: "if (hasForwardedHeaders(request)) {" which calls remoteAddressO.map(InetSocketAddress::getHostName).orElse(-1)".
Using this instead of false should be removed, the requirement is now that the Files.import() method throws an exception if the file does not exists.
Using this instead of false should be removed, the requirement is now that the Files.importFromLDIF(false) throws an exception.
Using this instead of false should be removed, the requirement is now that the Files.import() method throws an exception if the file does not exist.
suggestion throw new Exception("Invalid line number of events.");
suggestion throw new InterruptedException("Invalid line number of events.");
suggestion
Is this supposed to be 'null'?
Is this supposed to be '!='?
Is this supposed to be 'not found'?
@prasa7, let's use commitTimeout instead of commitTimeout.
Missing @Override annotation.
Missing @Override
what happens if the above condition was non coded?
What happens if the above condition was non coded?
Aren't you trying to remove the above line?
Could also use EnumSet.complementOf(EnumSet.of(Blob_Expired, No_Error,...))
Could also use EnumSet.complementOf(EnumSet.of(Blob_Expired, No_Error,...));
Could also do ImmutableList.copyOf(Arrays.asList(ServerErrorCode.Blob_Expired, No_Error));
I don't think we should throw this exception. I feel like we should just throw something that isn't very useful.
I don't think we should throw this exception. I feel like for example we should never have a log message very useful.
I don't think we should throw this exception. I feel like we should just throw something that isn't very descriptive.
Embed the caught exception in the newly thrown exception
Embed the caught error in the newly thrown exception
Embed the caught exception in the newly thrown ex
I don't think we need to wrap the exception since all possible exceptions are a subclass of RuntimeException. I prefer catching RuntimeException instead of Exception. If some methods throws non-RuntimeException, I think we should catch separately and wrap only non-RuntimeExceptions.
I don't think we need to wrap the exception since all possible exceptions are a subclass of Exception. I prefer catching RuntimeException instead of Exception. If some methods throws non-RuntimeException, I think we should catch separately and wrap only non-RuntimeExceptions.
I don't think we need to wrap the exception since all possible exceptions are a subclass of RuntimeException. I prefer catching RuntimeException instead of Exception. If some methods throws non-RuntimeException, I think we should catch separately and wrap only non-IOException.
This should be updated to make the code more readable.
This should be GTK_*
This should be GTK_*.
suggestion LOG.debug("run: Aborting because processUpdates returned ABORT_COLLECTION (probably also guards deletion) for {}", this);
suggestion LOG.debug("run: Aborting because processUpdates returned ABORT_COLLECTION (probably also guards the use of the Boolean object)
suggestion LOG.debug("run: Aborting because processUpdates returned ABORT_COLLECTION (probably also guards the use of the Boolean object, which is disabled)
If the caller is going to use the old constructor, we need to change the fields of the class, to overwrite them. Can you create a new method in File(final File file) that calls this method with the new parameter?
If the caller is going to use the old constructor, we need to change the fields of the class, to overwrite them. Can you create a new method in File(final File file) that calls this method with the same name?
If the caller is going to use the old constructor, we need to change the fields of the class. Not sure if this is sufficient.
Use filter(x -> p.toString().toLowerCase().endsWith(DASHBOARD_EXTENSION)) so that it can be reused.
Use filter(x -> p.toString().toLowerCase().endsWith(DASHBOARD_EXTENSION)) so we don't duplicate the string.
Use filter(String) so we don't duplicate the filter.
this is confusing because we are not validating if the encryption properties are the same. What is the source of the data?
this is confusing because we are not validating if the encryption properties are the same. What's the intention behind this?
this is confusing because we are not doing single instance of the properties. Consider to make the method private
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
I think you can use.filter(forceRegeneration).map(e ->!ArtifactUtils.isChecksum(repository, e.getPath())).forEach(e -> {
I think you can use.filter(forceRegeneration).map(e ->!ArtifactUtils.isChecksum(repository, e.getPath())).collect(Collectors.toList());
seems like there's a code duplication between this and the previous method. Maybe we could reuse the code to avoid duplication?
seems like there's a code duplication between this and the previous method. Can't it be factored out the common part?
seems like this will always return a Stage, I think we should just leave it as is.
Use String.valueOf
Use Long.valueOf
Use String.valueOf(long)
this is redundant. I wonder if it's important to keep it.
this is redundant. I wonder if it's important to keep that this is for HE VM.
this is redundant.
Could we reduce the nesting level to a single method?
Could we lift this code into a method?
Could we reduce the nesting level to debug?
this should be in the loop.
continue?
this should be in the loop
Extra ()
don't think we need this condition
don't think we need this condition.
Change to GraphDatabaseAPI.class
rename to pckg.
rename to pckg
this can be collapsed to if (tags.size() == 1) { tags.add(tag); }
this can be moved to getTopicRefFromTags
this can be private
Do we need this. here? Can we just inline this.index?
Do we need this. here? Can we just inline this?
Do we need this. in SpatialIndexBuilderOperator?
Is redundant?
Is redundant 3 times?
Can you add 3 params?
should we remove this?
remove System.out
remove system.out
Yeah, I think we're right. ShutDown is unintentionally removed this check. It looks like we're expecting a deadline in this case.
Yeah, I think we're right. ShutDown is a deadline too long as lease(int) is short enough. It's only used to acquire a lock in this case.
Yeah, I think we're right. ShutDown is a deadline too long as lease(int) is short enough.
This is hard to reason about
This is hard to reason about. I think we should log this as a debug log as well, saying it's easy to debug if something is wrong.
This is hard to reason about. I think we should log this as a debug log.
Why not (end<>>)?
Why not introduce a method like: private boolean annotate(Object context, MarkupText text) { return ((charPos,end) == null; } Also not that more lists...
Why not (end<>)?
This is a java.util.Objects.equals, it's java.util.Objects.equals(s, java.lang.Object)
This is a java.util.Objects.equals, it's java.util.Objects.equals(Object, Object)
This is a java.util.Objects.equals, it's java.util.Objects.equals(s, java.lang.String)
You should use MyObject is not null
You should use  issued if then no item is issued
You should use  issued
Possible NPE in next line when command.call() is null. When cloning into a bare repo it is possible to only specify gitDir.
Possible NPE in next line when command.call() returns null. When cloning into a bare repo it is possible to only specify gitDir.
Possible NPE in next line when command.call().
Add a space after the comma.
Add a space after the.
I think we should move the subscribe to the AbstractApplication.
Could you create a method to be sure that this is a pattern for the dates? The list list pattern is essential but not others.
Could you create a method to be sure that this is an error. Same for the other.
Could you create a method to be implemented as this instead?
Can you update this to use the system default?
Can you make this method private?
Can we use the system default here?
See if you can get rid of this, but it's much cleaner: public void JTable() { table.getRowSorter().getColumn(uiIndex).getModelIndex(); }
See if you can get rid of this, but it's much cleaner: public void JTable(final RowSorter table) { this.sortOrder = table.getRowSorter().getModelIndex(); }
See if you can get rid of this, but it's much cleaner: public void JTable(final RowSorter table) { this.sortOrder = table.getRowSorter().getColumn(uiIndex); }
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it' own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local var / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
This is more common as a try-with-resources block.
Prefer a try-with-resources block.
This is more common as a try-with-resources.
Maybe we should add an internal utility for CacheConfigurationException here if it is a OBJECT?
Maybe we should add an internal utility for 'findRequiredMemoryAddress'?
Maybe we should add an explicit message here?
I think it's safe to fetch the application context here (since it's only assigned once in the adapter)
I think it's safe to fetch the application context here (since it's only assigned once in the callback)
I think it's safe to fetch the application context in the banner.
wanna remove this line?
wanna remove system out from test output
wanna remove this System.out
I know that onError(throwable) doesn't have a value in the codebase, but I'm not sure what is the convention for this.
I'm not sure what is the purpose of this change.
I know that onError(throwable) doesn't have a value in the codebase, but I'm not sure if we should pass this callback.
Can we be testing the values like this? I don't think so.
Can be moved to AbstractTestUtils.createTest()
Can be moved to AbstractExecutor as a base class.
else { is redundant
else statement is redundant
else {
Maybe switch to findFirst() here, and use node.orElse(null) instead of findFirst().
Maybe switch to findFirst() here, and use node.orElse(null) instead of findFirst()?
Maybe switch to findFirst() here, and use it, I prefer it.
Since we're already using this variable, could we avoid the need for the else?
Since we're already using this variable, could we avoid the need for the else statement?
Since we're already using this variable, could we avoid the cast?
else { is redundant
static import format
else { is needed
instead of a new TreeMap, you could just set the HIVE_IN_TEST to HIVE_IN_TEST.
instead of a new TreeMap, you could just set the HIVE_IN_TEST to HIVE_IN_TEST and have it use a static final field.
instead of a new TreeMap, you could just set the HIVE_IN_TEST to HIVE_IN_TEST and have it use a static final field. (also below)
Use if (type instanceof VirtualBiomeType) {
Nit: It would be better to use computeIfAbsent
Use computeIfAbsent
why do you need this?
why do you need to create this TrackedEvent twice?
why do you need to create this event?
> 0?
> 0?
> 0? #Closed
this should be a try-with-resources block.
this should be a try-with-resources block. I'm not sure whether it's an important thing.
this might cause problems on Windows
I think this is not necessary because we do not want to set the exception for this case.
I think this is not necessary because we do not want to do this.
I think this is not necessary because we do not want to set the exception for this.
We should probably skip it, but fail if gran instanceof AllGranularity?
We should probably keep it compatible with our own PR, but maybe we should wait for the coverage of all these changes.
We should probably keep it compatible with our own SearchResultValue implementation.
BUG? Should we log the offsets?
BUG? Should we skip filling the offsets?
BUG? Should we skip the thrown exception?
It's not a big deal, but I think that it would be better to use anyMatch instead of stream.
It's not a big deal, but I think that this boolean is redundant. For example, JwtConsumerBuilder#processToClaims will always return true for null if it was present.
It's not a big deal, but I think that it would be better to use boolean value instead of stream.
(nit) suggestion if (optHttpsPort.isPresent()) {
(nit) suggestion String port = testServer.getRunningHttpPort();
(nit) suggestion String port = testServer.getRunningHttpsPort();
Use try-with-resources.
Use try-with-resources?
Inline the output
You could write these lines in the above if.
You could write these lines in the same commit.
You could write these lines in the above if
Please merge all this for and the if () { } else { }
I think we should be bailing out here, just in case.
Please combine all your if () clauses into one.
nit: redundant else.
nit: redundant elses
nit: redundant else
IINW, this call has the potential to produce NPE, since we don't check for the existence of the host.
what should populate the host? I haven't seen anything in the command that might set a value to it. The other commands perform: Guid vdsId = getParameters().getVdsId(); if (vds == null) { return failValidation(EngineMessage.VDS_REMOVE_LAST_FENCE_AGENT_ID_REQUIRED); } return null;
what should populate the host? I haven't seen anything in the command that might set a value to it. The other commands perform: Guid vdsId = getParameters().getVdsId(); if (vds!= null) { return failValidation(EngineMessage.VDS_REMOVE_LAST_FENCE_AGENT_ID_REQUIRED); } return null;
I think you can use filter() here instead of nested for loop.
I think you can use filter() here instead of nested if-statement.
I think you can use filter() here
Since processWorker is assigned to a final field, there is no need to have a local variable to hold it as an instance variable.
Since processWorker is assigned to a final field, there is no need to declare it as final.
Since processWorker is assigned to a final field, there is no need to have a local variable to store it as an instance variable.
See above, but timeTakenNanos should take a long or this will be broken for times over 3 seconds (Integer.MAX_VALUE nanoseconds)
See above, but timeTakenNanos should take a long or this will be broken for times over 1 seconds (Integer.MAX_VALUE nanoseconds)
See above, but timeTakenNanos should take a long or this will be broken for times over / over-memory.
If we use try-with-resources, this will close the stream even if the file is not closed.
If we use try-with-resources, this will close the stream even if the stream is closed.
If we use try-with-resources, this will close the stream even if the file does not exist.
We need to add a null check on Iterable here.
We need to add an info log here for us who is null.
We need to add an info log with the name
This code can be improved, with a single check of maxConnections and keep the current code. With the current code you're checking this twice, in this lines and below, making it more confusing to read.
This code can be improved, with a single check of maxConnections and do all DNS lookups inside there. With the current code you're checking this twice, in this lines and below, making it more confusing to read.
This code can be improved, with a single check of maxConnections and do all DNS lookups inside of ChannelInitializer.
I don't think you need the cast. You could just use "new Foo("java.lang.String"), and then check if it's null. But I don't think it hurts.
I don't think you need the cast. You could just use "new Foo("java.util.List<TurboMilestone>")". But I don't think it hurts.
I don't think you need the cast. You could just use "new Foo("java.util.List<TurboMilestone>")
Minor - Do we need to check for null, or should we have the corresponding tests for the lock cases?
Minor - Do we need to check for null, or should we have the corresponding tests for the email service?
Minor - Do we need to check for null, or should we have the corresponding check for the supplied study?
This would only happen if the service returned an invalid Sentiment type correct? Is this a good spot to throw a Runtime exception if the service failed? Maybe skip the result, log a warning, and continue processing the other responses.
This would only happen if the service returned an invalid Sentiment type correct? Is this a good spot to throw a Runtime exception if the service returned an invalid Sentiment type? Maybe skip the result, log a warning, and continue processing the other responses.
This would only happen if the service returned an invalid Sentiment type correct? Is this a good spot to throw a Runtime exception if the service returned an invalid Sentiment type correct? Maybe skip the result, log a warning, and continue processing the other responses.
There is a join method that accepts Collection that would make this code much simpler..
There is a join method for nics.stream().filter(x ->!x.equals(y)).forEach(assignedNetworks -> {... });
There is a join method for nics.stream().map(VdsNetworkInterface::getName).forEach(slavesCount -> {... });
should we log this?
remove empty line
remove sysout?
are we guaranteed the test won't get stuck if something fails the test?
are we guaranteed the test won't 2011-04-04/2011-04-05 if something fails the test?
are we guaranteed the test won't fail if something fails the test?
what if the user has done this column and the password?
what if this table remains?
what if this table remains?
Isnt it already done above, in line 62?
Isn't it already done above, in line 62?
Isnt it already done above?
Do you think it makes sense to check for username if it's not a secret? My IDE analyser reports that the username could be null, but it's also not being installed.
Do you think it makes sense to check for username if it's not a secret? My IDE analyser reports that the username could be null, but it's not them in the constructor and the config file could be null.
Do you think it makes sense to check for username if it's not a secret? My IDE analyser reports that the username could be null, but it's not them in the constructor and it might be useful to check.
The only thing I can see here is the command name. This should be a command name (just i.e. the command name).
The only thing I can see here is the command name. This should be a command name (just i.e. the command string)
The only thing I can see here is the command name. This should be a command import.
Why this line is not needed?
Why this line is not met?
Why this line?
Please use the JsonUtil.JSON_MAPPER instead.
Please use the JsonToStringHelper instead
Please use the JsonToStringHelper instead.
No need to set the value from the block.
No need to set the value here.
No need to set the message here.
not sure why we need this.
not sure why we need to have this list here.
not sure why we need to have this.
ICS=false. Please remove it from the upload file and add a new test tool if it is null
ICS=false. Please remove it from the upload file and add a new test tool
ICS=false. Please remove it from the upload file and add a new test tool if needed. ICS=false is the default
Can we make this an else if? I think it is redundant
Can we make this an else if?
Can we inline this?
I think we don't want to support Iterable and Iterable in the PropertyMapping (an enum)
I think we don't want to use this per-device. What about java "Type" type?
I think we don't want to support Iterable and Iterable (an input type) and always use it to thing about it. So this needs to be an interface SingleNode, or a StreamNode.
Why are you printing to sysout? :)
Why are you printing this? :)
Why are you printing to sysout? :-)
minor: spaces
Remember to add the table name.
Remember to add the table name, it doesn't seem to be.
minor: rename this to STDOUT
minor: rename this to formatStr
minor: rename this to STDOUT instead
This is guaranteed that we will always return non-null value. I think it would be better to return Optional.empty() instead.
This is guaranteed that we will always return non-null value. I think that we we need to check for null to be safe.
This is guaranteed that we will always return non-null value. I think it's OK to return null.
Why don't we use the default constructor?
In the above, we should avoid using the "synchronized" keyword with the default case.
In the above, we should avoid using the "final" keyword.
if it is used then why is it needed?
is it not used?
if you don't provide the default value for other props it would be better to use an empty string.
Refactor into constant. SimpleDateFormat dateFormat = new SimpleDateFormat(Locale.getDefault(), Locale.getDefault()); and use it in the test, as it shouldn't be SimpleDateFormat, instead.
Refactor into constant. SimpleDateFormat dateFormat = new SimpleDateFormat(Locale.getDefault(), Locale.getDefault()); and use it in the catch block.
Refactor into constant. SimpleDateFormat dateFormat = new SimpleDateFormat(Locale.getDefault(), Locale.getDefault()); and use it in the date format
why do you need to split the platform?
why do we need to split the platform?
why do you need to split this into two lines?
Why should nodes necessarily have an ssl enabled port?
why should nodes necessarily have an ssl enabled port?
Why should nodes necessarily have an ssl enabled port? This is out of scope here, but why should we do this?
I'd change the message to "Invalid page offset %s, but buffer offset %s"
I'd change the message to "Invalid page offset %s, or the buffer offset %s"
I understand this is old code and this change is not correct. "read" is a legacy method defined in PageId class, which you're returning a new RandomAccessFile instance each time. Therefore, you can call skip on that.
can we do this in the while condition instead of if?
can we do this in the while condition instead?
can we do this in the while condition?
<LINK_0>
Can remove this if statement.
Can remove this if statement?
We do we need to be able to call.collect() here?
We do not need to be public.
We do we need to be careful about select/join?
I remember some discussion for coming up with this logic of selecting cards randomly. Have you decided to remove that?
I remember some discussion for coming up with this logic of selecting cards randomly. Have you decided to remove that for now?
I remember some discussion for coming up with this logic of selecting cards randomly. Have you decided to remove that in PR?
java private static boolean checkEither(Column column, Filter filter, EntityRecordWithColumns record) { @Nullable Object columnValue = columnValue(record, column); if (matches) { return true; } else { return filters.isEmpty(); } }
java private static boolean checkEither(Column column, Filter column, EntityRecordWithColumns record) { @Nullable Object columnValue = columnValue(record, column); if (matches) { return true; } else { return filters.isEmpty(); } }
java public static boolean checkEither(Column column, Filter column, EntityRecordWithColumns record) { @Nullable Object columnValue = columnValue(record, column); if (matches) { return true; } else { return filters.isEmpty(); } }
makeTableRunner already has a method called isQuery() which is doing the same thing
You can check if analysis is null before trying to merge them.
this is already done in line 231. Why?
Isn't it possible to get multiple appliances under a single appliance?
interesting way of handling this. I mean, it looks like we are specifically trying to get a list of machines, not just the first one (without any user). Then the appliance should be logged. What do you think?
interesting way of handling this. I mean, it looks like we are specifically trying to get a list of machines, not just the first one (without any user). Then the appliance should be passed to this method.
This could be simplified, so it would only get rid of the extra indentation.
This should be represented as an ArrayList, so that when you get here, it will not be needed.
This should be represented as an ArrayList, so that when you read it, it will not be needed.
Why don't you use any(Class) here as well?
Why don't you use any(Class) and not any(Class)?
Since this is..nitpicky, just use Mockito.any() rather than mock the class.
I think that there is a better way to do this would be to use constants instead of hard coded strings
I think that there is a better way to check these properties
I think that there is a better way to do this would be to use constants instead of fields
this could be simplified as java if (targetDir == null) { return null; }
this could be simplified as java if (!targetDir.exists() || targetDir.listFiles().length == 0) {
Who else is doing the same thing?
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclaration.
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclaration
Since getParent() is defined on IASTNode, there is no need to actually check it here.
The [reportCodeTextViews[0]](<LINK_0> is a duplicate of the message from before.
This message is a duplicate
This could be private
I'm thinking of this message, it would be better to have a more helpful message in the log, like "Code '{}' could not be loaded: {}", messageSource, e.toString(), e.getMessage());
I'm thinking of this message, it would be much cleaner if you just used messageSource.toString() instead of toString() on messages.
I'm thinking of this message, it would be better to have a more helpful message in the log, like "Code '{}' could not be loaded: {}", messageSource, e.toString() + ".");
nit: I think we can make this more readable by using unmodifiableMap: java this.tags = Collections.unmodifiableMap(tags);
nit: Format the code
nit: I think we can make this more readable by using unmodifiableMap
This should be a switch statement.
The replacement should be a parameter for decl.getStartPosition()
This should actually be a switch statement.
It would be nice to add the interface NODE_STATE_CHANGED message here.
It would be nice to add the interface NODE_STATE_CHANGED message here, in order to keep the insight of having this message.
It would be nice to add the interface NODE_STATE_CHANGED message here, in order to keep it consistent with the other listeners.
call it folder
call it scanner
call it createFile
why here and not in addVmCommand?
why not to add this to the tasks list?
why is this needed?
I think you should have this exception only in case projectBuildingResult and projectBuildingResult are null.
I think you should have this exception only in one catch block.
I think you should have this exception only in case projectBuildingResult and projectBuildingResult have been read fails
In this case, BithumbException is not a BithumbException, so we don't want to throw it.
In this case, BithumbException is not a BithumbException, so we can be sure about it.
Utils.stream(map)
better to use the official way here true instead than "true"
better to use the official way here true instead than "false"
better to use an official way here true instead than "true"
Should be a try-with-resources block.
Believe it or not you actually need 4 assignments here, one for each.
Should be an IOException.
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this function. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the db connection.
Either a generic method is better, or have a "protected void updateProvidedObjectsHolder" method is named something like updateProvidedObjectHolder?
Either a generic method is better, or have a "protected void updateProvidedObjectsHolder" method is named something like updateProvidedObjectHolder() so it could be a lot clearer.
Either a generic method is better, or have a "protected void updateProvidedObjectsHolder" method, in the the "updateProvidedObject" class.
It would be better to use new StyleRange(String.format("line offset %d", event.lineOffset), e.g. new StyleRange(styles.size()-1)).fontStyle(style);
It would be better to use new StyleRange(String.format("line offset %d", event.lineOffset), e.g. new StyleRange(styles.size()-1)).fontStyle(style)
It would be better to use new StyleRange(String.format("line offset %d", event.lineOffset), e.g. new StyleRange(styles.size()-1)).fontStyle(style))
This should be done through try-with-resources, the stream is closed even if an exception is thrown.
This should be done in a try-with-resources block.
This should be done through try-with-resources, the stream is closed even if an exception occurs.
If you make this line more readable, please split it into two lines.
If you make this line more readable, please split it into separate method and update it.
Should be declared as private.
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModel however isNew property is initialized after the constructor is finished. See VmSnapshotListModel#cloneTemplate.
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModel however isNew property is initialized after the constructor is finished. See VmSnapshotListModel#cloneTemplate().
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModelBehavior. This is a bit confusing, I'd say that it is redundant.
Same here: what's the purpose of this change?
Same here, but what's the benefit of using this instead of entry.getValue()?
Same here, but what's the benefit of this change?
Please move the above log entry to info level. In normal mode it's enough to say cache updated (and it took xxx second).
Please move the above log entry to info level. In normal mode it is enough to say cache updated (and it took xxx second).
Please move the above log entry to info level. In normal mode it would be enough to say cache updated (and it took xxx second).
Why not putting ("if (dependantPlugin.isEnabled()) as a constant?
Why not putting equals around the constant?
Why not putting ("if (dependantPlugin.isEnabled()) here to avoid checking for NONE?
There should be some more spaces around operators. Like for example: "It is saved on the name...."
There should be some more spaces around operators.
There should be some methods in this class.
Wouldn't it be better to log this as a warning?
Wouldn't it be better to catch ConfigurationException here?
Wouldn't it be better to check it in the RepositoryException constructor?
suggestion LOG.warn("Timeout occured while sending message to topic {}", topic, e);
suggestion LOG.warn("Timeout occured while sending message to topic {}.", topic, e);
suggestion LOG.warn("Error occured while sending message to topic {}", topic, e);
Why not use model.getSelectedItemsChangedEvent()?
Why not use model.getSelectedItemsChangedEvent().addListener(...);?
Why not using model.getSelectedItemsChangedEvent()?
Do we really want to log this? I'm leaning toward debug, right?
Do we really want to log this? I'm leaning toward debug.
Do we really want to log this? I'm leaning toward debug, in my opinion.
String.format() for better readability
Use String.format() for better readability.
Use String.format() for better readability
Should be done vs. the DC compatibility level.
Would be better to rename this to domainFromIrs (ISMGetStorageDomainInfo, Guid> domainFromIrs) or something similar.
Should be done vs. the DC compatibility concern.
is it normal for Java to pass in the response?
is it normal for Java to pass in the response to the request if the user doesn't specify a param?
is it normal for Java to pass in the response to the request if the client doesn't specify a param?
streaming an empty list
streaming an empty collection
streaming an empty list here
It's better to use getCommand(outputFile, statusConsumer).
Move this to the private method?
It's okay to use Impl#getExternalResourceInfo() for better readability.
We should probably remove this log line
We should probably remove this log line, and just let the codec handle it.
We probably want to remove this log line
Maybe check the file's existence just in case? otherwise the watcher will give up immediately (IOException ). But IIUC the code it may want to wait to avoid race conditions. Or not?
Maybe check the file's existence just in case? otherwise the watcher will give up immediately (IOException ). But maybe it may be better to wait to avoid race conditions. Or not?
Maybe check the file's existence just in case? otherwise the watcher will give up immediately (IOException ). But maybe it may be better to avoid race conditions. Or not?
@idelcano I think here you just call savedInstanceState.getFloat() if it does not match the other code
@idelcano I think here you just call savedInstanceState.getFloat() which will create a nullpointer exception.
@idelcano I think here you just call savedInstanceState.getFloat() if it does not match the other thing that it called
You can check this in the correct way: assertThat(ProgramEnrollment.class.isEnrolled())
You can check this in the correct way: assertThat(ProgramEnrollment.class.isInstance(object)).isEnrolled())
You can check this in the correct way: assertThat(ProgramEnrollment.class.equals(object)).isEnrolled())
Again different type of attribute.
Again different order of attributes.
Again different order of attributes
What if this.logger.isDebugEnabled()?
What do you think about having this. inside a method? You could have a single place where it's used.
What do you think about having this. inside a method?
please add <?>
please add this assertion in the next line
please add this assertion before casting
If I am not mistaken this will do the same thing as the parameter for removeTriggerFromProjectList
If I am not mistaken this will do the same thing as the parameter value of addThisTriggerAsListener()
possible NPE
Do we need this catch block as well?
Should we throw this exception here instead of catching it and throwing it?
Should we throw this exception here instead of catching?
nit: it doesn't look like it matters much, but I'd suggest to inline the method body: java if (rewrittenSource.isPresent()) { return rewrittenSource.get(); } else { source = exchangeNode.partitionedExchange(idAllocator.getNextId(), lookup, idAllocator); }
nit: it doesn't look like it matters much, but I'd suggest to inline the method body: java if (rewrittenSource.isPresent()) { return rewrittenSource.get(); } else { source = exchangeNode.partitionedExchange(idAllocator.getNextId(), lookup, idAllocator()); }
nit: it doesn't look like it's necessary to recurseToPartial()?
I don't think there is a selectFirst method.
I don't think there is a selectFirst method. I think there is a selectFirst method.
I think there is a selectFirst method.
does this do anything?
does this do anything? maybe I don't see it in this PR.
no need for continue; nothing will be done in this stage
can't we combine this and the above if/else?
can't we combine this and the above if/else ifs?
can't we combine this and the above if/else if into one?
it's better to use (interpret_args(..., ) (new String(interpret_args(..., ) (new String(this.noteId, "noteId:") )
it's better to use (interpret_args(..., ) (new String("interpret_args(..., ) (new String[]{interpret_args}" like this)?
it's better to use (interpret_args(..., ) (new String("interpret_args(..., ) (new String[]{interpret_args}" like this)
Why are we adding an EnumMap<> for this?
Why are we adding an EnumMap<> here? Just think that it's cleaner.
Why are we adding an EnumMap<> here? Just use a if.
Could you use an array list instead of a list? Just call Arrays.asList?
Could you use an array list instead of a list?
Could you use an array list instead of a list? Just call Arrays.stream(str)?
we are supposing that this is a Talk, but I think it would be better to rename this to something that actually checks the content of the issue.
we are supposing that this is a Talk, but I think it would be better to rename this to something that actually checks the contents of the Talk.
we know that this is /talk/tree
This has already been committed, this should be not an error.
This has already been committed, this should not be needed.
This has already been committed, this should be not an error?
You should be able to return true here, as FileHelper.expandFilename( stateManager.getActiveDatabase().isPresent(), stateManager.getSelectedEntries().get(0).getLink(), preferencesService.getFilePreferences()).ifPresent(selectedEntries -> { return false; });
You should be able to return true here.
You should be able to return true here, as FileHelper.expandFilename(...
This -1 smells a little. I wonder if a constant may speak more about the fact that it is a non value
An -1 smells a little. I wonder if a constant may speak more about the fact that it is a non value
This -1 smells a little. I wonder if a constant may speak more about what it is.
assertNotNull(null);
assertNotNull(collection)
please use assertEquals
Same applies here; could we move the if statement in [L251](<LINK_0> down here?
Same applies here; could we rename 'numBlockByEvalIdForWorker' to 'numBlockByEvalIdForWorker'?
Same applies here; could we rename 'numBlockByEvalIdForWorker' to'numBlockByEvalIdForWorker'?
it would be better to add a private constructor here
it would be better to use a private constructor here
it would be better to extract a private method addDefaults
This code is used when we are reading the bloom filter. I suggest adding a isSetIndex() method.
Where is this being used?
Where is this used?
this way you'll go in to the 'else' while intention was different (if you already have <paranet_step/> specified) 1. please remove new condition 2. add validateParameters(step, "Type", "step.parentStep.id"); in this if()
this way you'll go in to the 'else' while intention was different (if you already have <paranet_step/> specified) 1. please remove new condition 2. add validateParameters(step, "type", "step.parentStep.id"); in this if()
this way you'll go in to the 'else' while intention was different (if you already have <paranet_step/> specified) 1. please remove new condition 2. add validateParameters(step, "Type", "step", "description", "id"); in this if()
It looks like this method is not a thread safe, shouldn't we have synchronization here?
It looks like this method is used in a 2 places, shouldn't we have synchronization here?
It looks like this method is no longer relevant here (in a PR)
This will always be true right now, you'd have to setNofityRequest() here.
This will always be true right now, you'd have to setNofityRequest() to false.
This will always be true right now, you'd have to setNofityRequest() again to false.
Are you sure this is what was intended? I suggest to name it "jar" instead.
Are you sure this is what was intended? I suggest to remove it.
Will it work with files without /jar? I suggest to use the.jar pattern here.
No need for this. We can just use the Map interface.
No need for this. We can just use the interface (Map) as the return type.
No need for this.
why did you call that?
to remove
to remove?
Has to be removed.
Has to be tested.
Has to be checked.
Same here re:.findAny() returns an Optional.
Same here, it's not the fqdn since it will be created with the same value. You can just return true once and hold it in a field.
Same here, it's not the fqdn since it will be created with the same value. You can just return true once and hold it in a variable
how about putting the isUnauthorized method around the root account? I think that would be better than assuming we only need the users to work around it.
how about putting the isUnauthorized method around the root account? I think that would be better than assuming we only need the users to work around that.
how about putting the isUnauthorized method around the root account? I think that would be better than assuming we only have a user required API.
I wonder if  observations should be null at this point
I wonder if  observations should be added to the single line of parametrization
I wonder if  observations should be added to the single line of logic.
We need to remove the try-catch. We don't want to expose any exception and remove the try-catch. We can still add a fail-fast failure when we switch to using try-catch.
We need to remove the try-catch. We don't want to expose any exception and remove the try-catch. We can still add a fail-fast failure when we try to close the datasource. We can try to remove the try-catch and fail the test.
We need to remove the try-catch. We don't want to expose any exception and remove the try-catch. We can still add a fail-fast failure when we try to close the datasource. We need to remove the try-catch and fail the test.
This doesn't seem to catch runtime exceptions. Do we need to catch them here?
This doesn't seem to catch/log the exception.
This doesn't seem to catch theInterruptedException you could get.
You can use return result here instead of using the interface.
You can use return result of this method here.
You can use return result of result and remove the else clause.
Are you sure that the table object is always non-null?
java doc missing: Are we sure that tableObj.getTableType() is 'null'?
Consider making these changes only in debug mode.
Instead of going through this line, should the test do a java assertEquals(expected, actual)?
Instead of going through this code, should the test create a TestJobLogger class that implements JobLogger, initialize jobRunner with an instance of it?
Instead of going through this code, should the test create a TestJobLogger class that implements JobLogger?
why is this needed?
Why is this needed?
why doesn't this be the same as the top?
could you please revert these two lines into a separate method and have a different name for the method?
Some of these catch clauses could probably be combined into one.
could you please revert these two lines into a separate method and have a different name for the supplier?
This returns true if the code is running for a session?
This returns true if the code is not running. This is necessary.
Why not just catch this here?
Nit: maybe refactor this into a method like the following? suggestion if (UsageConsumableInArrearDetail.isEmpty()) {
Nit: maybe simplify this block to just: suggestion if (UsageConsumableInArrearDetail.isEmpty()) {
Nit: maybe refactor this into a method like the following? final String itemDetails = (UsageConsumableInArrearDetail).add(item);
why did you move this to separate method?
why did you move this to the previous line?
why did you move this and make the Result constructor private?
Compare name instead of virtualHost?
findBugs complaining about this.
Compare name instead of virtualHost
I guess we are still getting an array with this queryParameter() and getChangesQueryQuery() seem very similar to other changes, no?
I guess we are still getting an array with this queryParameter() and getChangesQueryQuery() seem very similar to above, no?
I guess we are still getting an array with this queryParameter() and getChangesQueryQueryQuery() that has the problem to test and the performance is different when the input has different data.
Nitpick: could you use cactoos closeQuietly here?
Nitpick: could you use Collections.singletonList() here?
Nitpick: could you use cactoos closeQuietly() here?
Remove it. It was used at some point but I forgot to remove it after code restructuring.
Redundant line. It was used at some point but I forgot to remove it after code restructuring.
Redundant. It was used at some point but I forgot to remove it after code restructuring.
I think this test should be done by a @Before method to avoid duplicated code.
I think this test is missing a call expression and a variable with "name" as a parameter.
I think this test should be done by a @Before method that returns a null expression.
You can use ids.iterator().next() instead of ids.iterator().next()
You can use ids.iterator().next() instead of ids.iterator()
You can use ids.iterator().next() instead of ids.iterator().next().
We should at least log the exception in this case.
We should at least log the exception in this case, and make it very explicit.
What's the 400 case?
instead, you can use the StringUtils.isEmpty method to make sure the string is not null, since it will also return true or false
instead, you can use the StringUtils.isEmpty method to make sure the variable is not null, since it will also return true or false
instead, you can use the StringUtils.isEmpty method to make the code a bit less verbose, since it will also return true or false
Confusing metric name?
You can just write _clock.instant().exists()
Confused by this change.
Do we need this logging?
Do we need this?
Do we need to remove append?
We can use Preconditions.checkNotNull() here.
We can use Collections.singletonList() here and remove the static import
We can use Preconditions.checkState here.
Strange that SubscriptionService.commitCursors() throws NOT_IMPLEMENTED rather than returning nothing. I'm not sure if this should be implemented.
Strange that SubscriptionService.commitCursors() throws NOT_IMPLEMENTED rather than returning nothing. I'm more confident that this logic should be in the wrong place.
Strange that SubscriptionService.commitCursors() throws NOT_IMPLEMENTED rather than returning nothing. I'm more confident that this logic should be separated to the user.
TB too?
TB too? We don't need to have these strings as strings.
TB too? We don't need to have this method public static.
![MAJOR](<LINK_1> 'Severity: MAJOR') Refactor this method to reduce its Cognitive Complexity from 18 to the 15 allowed. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Refactor this method to reduce its Cognitive Complexity from 17 to the 15 allowed. [![rule](<LINK_2>](<LINK_0>
io.druid.java.shared.Constants#asStringOrNull
You should use parameterized logging instead of string concatenation.
You should use parameterized tests instead of string concatenation.
You should use parameterized and [the expected value](<LINK_0>
use FileRepositoryBuilder.create
Use FileRepositoryBuilder.create
@carlosmiranda I would rename this to remoteBranches.
log.warn in default block is an error.
log.warn in default case
log.error
We should respect the InvalidProtocolBufferException, here <LINK_0>
We should respect the InvalidProtocolBufferException, here.
We should respect the InvalidProtocolBufferException, here (if it's not a valid URL)
Should we log this properly?
Should this be warn?
Should this have a config file?
why relaceFirst instead of replace
why relaceFirst instead of replace with File?
why relaceFirst instead of replace this pattern
You could extract projectBaseDir into a local variable and use it here.
How about using NFS instead of multiple files?
You could extract projectBaseDir into a local variable?
SCMController#getProps() is not needed.
Verify the generated code
Verify the expected value
setErrorMessage
setErrorMessage?
settingErrorMessage
The same as above, this method could be private.
The same as above, this method must be static
The same as above, this method must be static.
No need to use the content of the dialog, and its text can be removed.
Why this change? It would be nice to have this text as an actual text. Just add the content, and use it in the content.
Why this change? It would be nice to have this text as an actual text. Just add the content, and the text to the button.
We shouldn't need to copy string for each call to padRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadRpadFunction
We shouldn't need to copy string for args.length
We shouldn't need to copy args.
This logic seems twisted; making the logic unreadable, we check if there there is an active-action on a container-id, or if there is an active-action on its active/standby counterparts, after that we check if there is a standby-container-manager present? Would it be possible to a. first check if a standby-container-manager is present? Or b. can hasActiveOrStandbyContainerHasActivePlacementAction encapsulate the logic of checking a and checking with if there is an active-action on its active/standby counterparts of the given processor-id.
This logic seems twisted; making the check unreadable, we check if there there is an active-action on a container-id, or if there is an active-action on its active/standby counterparts, after that we check if there is a standby-container-manager present? Would it be possible to a. first check if a standby-container-manager is present? Or b. can hasActiveOrStandbyContainerHasActivePlacementAction encapsulate the logic of checking a and checking with if there is an active-action on its active/standby counterparts of the given processor-id.
This logic seems twisted; making the logic unreadable, we check if there there is an active-action on a container-id, or if there is an active-action on its active/standby counterparts, after that we check if there is a standby-container-manager present? Would it be possible to a. first check if a standby-container-manager is present? Or b. can hasActiveOrStandbyContainerHasActivePlacementAction encapsulate the logic of checking a and checking with if there is an active-action on its active/standBy counterparts of the given processor-id.
className can never be null.
className can't be null.
className can never be null.
returning null is not needed I think.
returning null is not necessary since we know it is empty ;)
returning null is not necessary since we know it is not a wait condition
The trade method is really long. Consider refactoring into multiple smaller and more concise methods.
The trade method is really long. Consider refactoring into multiple smaller and more concise method.
The trade method is really long. Consider refactoring into multiple smaller and less methods.
nit: doJoin(otherStream, (no new line)
nit: doJoin(otherStream, (false, false) -> doJoin(otherStream, (false, false)),
nit: doJoin(otherStream, (no call to the joined parameter)
why do you need this check? Can you move the logic of enablingServeFromBackup to the new AccountInfoMap?
why do you need this check? Can you move the logic of enablingServeFromBackup to the newAccountInfoMap?
why do you need this check? Can you move the 'if' to line 54?
The usage of toString() is depth and not the literal.
The usage of toString() is wrong.
The usage of toString() is sea_velocity() to split the test.
nit: Hashing.encodeUnsignedVarLong(MAX_VALUE, component2Bytes)
We can pre-compute this value by calling.toLong() on it.
nit: Hashing.encodeUnsignedVarLong(MAX_VALUE )
This logic looks very complicated. Why not use java if (!DoubleMath.fuzzyEquals(vector1.i], vector2.length)) { return false; } intersection = sensitivities.keySet().equals(vector2.length);
This logic looks very complicated. Why not use java if (!DoubleMath.fuzzyEquals(vector1, vector, tolerance)) { return false; } intersection = sensitivities.keySet().equals(vector2.length);
This logic looks very complicated. Why not use java if (!DoubleMath.fuzzyEquals(vector1.i], vector2.length)) { return false; } intersection = sensitivities.keySet().removeAll(values());
any reason for the 'else'?
any reason for the 'else'?
any reason for the '== 0'?
getCountOfEmptyLinesBetween( previousImportObjectFromCurrentGroup.getLineNumber(), importObject.getLineNumber())!= 1 is a bit easier to read. There are a number of elements in this method. If you change the name to currentGroup, you would be able to simplify this code.
getCountOfEmptyLinesBetween should be called 3 times in this method.
getCountOfEmptyLinesBetween
are you sure we want to keep this around?
are you sure we should keep this around?
are you sure this is necessary?
store title in a variable instead of passing it as an argument.
store title in FeedHolder class.
store the title in a local variable instead of passing it in.
My IDE complains about using.map(input1 -> new Certificate(input1.classification(), input1.country())) instead of the filter.
My IDE complains about using.map(input1 -> new Certificate(input1.classification(), input1.country())) instead of a stream.
My IDE complains about using.map(Path::new)
Move this back to where it's used.
Move this to a constant.
Use.map(OperatorStats::sum) instead of a lambda
you can use assertFalse instead of assertEquals
you can keep the.get() to make the test more explicit
you can keep the.get() into a constant
don't wrap at.get final
don't wrap at.
don't wrap
This one has two windows, is this intentional?
You can use 0 here instead of 1
I would add 1 to the lastPos, is this backwardly 0.
Minor: can use assertLogContains instead
Minor: can use assertLog method and don't have to have the same assertions for all the splits.
Minor: can use assertTrue and assertFalse
I'm not sure how the client uses the executorservice, but you might consider using shutdownNow instead, since shutdown will execute the entire queue of submitted tasks before shutting down. Also consider adding an awaitTermination here so close doesn't return until the service is properly closed.
I'm not sure how this client uses the executorservice, but you might consider using shutdownNow instead, since shutdown will execute the entire queue of submitted tasks before shutting down. Also consider adding an awaitTermination here so close doesn't return until the service is properly closed.
I'm not sure how this uses the executorservice, but you might consider using shutdownNow instead, since shutdown will execute the entire queue of submitted tasks before shutting down. Also consider adding an awaitTermination here so close doesn't return until the service is properly closed.
Could you please remove this cast to UnknownBlockTagTree?
Could you please add the type parameter to the toString method?
Could you please remove this cast to Element?
I'd prefer to not use the interface in the signature. All this class can be declared as private, and only used in the one can be used in the file.
I'd prefer to not use the interface in the signature. All this class can be declared as private, and only used in the one can be used from the IDE.
I'd prefer to not use the interface in the signature. As it's, we don't need to use interface.
The variable name "ePerson" should remain an accurate name.
The variable name "ePerson" should be changed as a local variable
The variable is initialising the value from a variable outside of the method.
Yes, this is safe. getFilename() does not work as expected if bai file has a.bai file. So why do we need to be careful about using.replace(".bai", "")?
Yes, this is safe. getFilename() does not work as expected if bai file has a.bai file. So why do we need to be careful about using.replace(".bai", "");?
Yes, this is safe. getFilename() does not work as expected if bai file has a.bai file. So why do we need to repeat this?
I think this should be metric.
I think this should be metric or something.
I think this should be metric
It would be useful to have this check on the latest version of the PR.
It would be useful to have this check on the latest version of the page view.
It would be useful to have this in the NavTabView class. Also, not sure if we want to log the page description.
Can this be moved up before the add() call?
Can this be moved up before the add call?
Can this be dropped?
You don't catch Exception
You don't have to catch Exception since it's not thrown here.
You don't have to catch Exception since it's not thrown anymore.
I think the framework should not check for service type info here. At least add a trace log about something like "Keep UID: {}"
I think the framework should not check for service type info here. At least this should be done through the ThingManager instead.
I think the framework should not check for service type info here. At least add a trace log before the UID.
I'm not sure about the check, but it would be better to use StringUtils.startsWith instead of indexOf. At least we should get rid of the '.' at the beginning of this method.
I'm not sure about the check, but it would be better to use StringUtils.startsWith instead of indexOf. At least we should get rid of the '.' at the beginning of the file.
I'm not sure about the check, but it would be better to use StringUtils.startsWith instead of startsWith
We should have a null check here.
We should have a finally block to ensure the reader is closed.
We should have a finally block to ensure that the reader is closed.
This should probably return an Optional<String>.
This will cause an exception. Throw an RuntimeException and bamh.
This will cause an exception. Throw an RuntimeException and then fail.
To keep the entire library, \" \"\" isn't a valid character in the attribute name.
To keep the entire library, \" \"\" isn't needed here.
To keep the entire library, \" \"\" isn't a character in the attribute name.
Let's remove ShardSyncStrategy and use it here.
Let's remove ShardSyncStrategy and use it here. It is an internal class.
Let's remove ShardSyncStrategy and use config instead.
what if the file is longer than 10?
what if the file is empty?
what if the file is longer than 10 seconds?
Could you add space after the cast?
Can you add space after the cast?
@nvazquez you have to throw an exception, so you can get rid of the {}.
We could also set the value at the end of the test.
We could set the value at the end of the test too (to make sure we have a missing value at all).
We could assert that hits has a metadata field.
typos: should be "inno"
1000000 vs STRING
typo
I think we need to lift this logic into the first place. For example at the moment: there is a boolean hidden = method.getAnnotation(Hidden.class); if (hidden!= null) { return false; } else { return false; }
I think we need to lift this logic into the first place. We don't have to check if the components are hidden.
I think we need to alway check on the attribute.
Where do you extract this into a constant?
Where do you extract this into a method that updates the healthValue?
Where do you define this int ID?
Yes, this is never true.
Yes, this is fine. But if we don't return the Ehcache<K, V> since there is a lock we should never get here?
Yes, this is fine. But if we don't return the Ehcache<K, V> since there is a lock we should never get here.
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup -> positionInRowGroup
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup -> positionInRowGroup.
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup -> positionInRowGroup. Fix naming
could you change this?
could you change this into try-catch? I don't think that is the way to do it.
could you change this into try-catch? I don't think that is the way to start system
Please move this protected modifier up to the public modifier.
Please move this protected modifier up into the public constructor.
Please move this protected modifier up to the public constructor.
possible NPE: sessionPrompts is null
will it be possible to directly compare the session state?
possible NPE: sessionPrompts is null..
It's simplification of CredentialItem.Username isn't guaranteed to be a string, so it should be possible to compile it using a regex here.
The regex here is compiled only once, so it needs to compile and compile the regex once.
The regex here is compiled only once, so it needs to compile and evaluate the string first.
Why the cast? It's not the right place to convert it to a byte array, but coerce it back to byte[].
Why the cast? It's not the right way to go.
Why the cast? It's not the right way to read the code.
Please move the line above to the end of line.
Please move line 47 to the end of line
Please split line 47 and 148 to 47..
for performance reason, only one test seems to be using the first (havingExpression) criteria, so we should be creating a new object for it
for performance reason, only one test seems to be using the first condition
for performance reason, only one test seems to be using the first condition and the other.
Nit: should we remove the spaces before the =?
Nit: should we keep the set of parentheses?
Should we throw Exception?
I'd rather we use 0L here.. and at the beginning of the method if possible. Consider renaming all of these methods to use that naming convention for the new code.
I'd rather we use 0L here.. and at the beginning of the method if possible.
I'd rather we use 0L instead of z here.
For readability, please assign the value to a local variable and use that instead of the for loop.
For readability, please assign the value to a local variable
For readability, please assign the value to a local variable and use that instead of the loop.
What is the use of this empty line?
What is the use of this line?
@slubwama add a constant that says the size of the collection
It would be better to use importPdfDialogFragment.TAG instead of TAG.
It would be better to use importPdfDialogFragment.TAG instead of importingPdfDialogFragment.
It would be better to use importPdfDialogFragment.TAG instead of TAG from here
should be deprecate to "getPrimeRefining"
should be de/duped by the main variable
should be deprecate
Can you make one more log.error() here?
Don't log and throw. If you don't have... you should just log instead.
Don't log and throw. If you don't want to throw an exception in the middle of the execution.
The buffer is only created once, and use file4.createNewFile() instead.
The buffer is only created once, and use file4.createNewFile() instead here and below.
The buffer size is only 16 chars long.
I'd remove zoneId and just store the customerGroup as a field, and remove this constructor. It's only used below on the setters, so there's no reason to remove zoneId and the default fields.
I'd remove zoneId and just store the customerGroup as a field, and remove this constructor. It's only used below on the setters, so there's no reason to sloning on the default value.
I'd remove zoneId and just store the customerGroup as a field, and remove this constructor. It's only used below on the setters, so no need to append it to the default constructor.
Why is this check necessary?
Why is this line duplicated?
Why is this check inside the if?
This should be private.
This could be private.
This could be made into a method, which calls groupJoinedStreams() and groupJoinedStreams().
why did you change to final here? should be outside of the scope of the patch.
why did you change to final here? should be outside of the scope of this patch.
why did you change to final here? should be outside of an anonymous class.
Use isEmpty()
Use isEmpty() instead of!= null.
Use.equals() instead of!=.
You should discuss with Nicolas, but this class is probably useless. you should use LabelInternationalizationUtils.getSetLabelCommand directly I think
You should discuss with Nicolas, but this class is probably useless. you should use LabelInternationalizationUtils.getInternationalizationPreference directly I think
You should discuss the label, but this class is probably useless.
Minor nit: I would add test for each header, no need for 2 lists.
Minor nit: I would add test for each header, no need for 2 lists, right?
Minor nit: I would add test for both Strings and Strings (they're not really needed)
Please also include the original exception name as well.
suggestion MegaMek.getLogger().error(e);
Please also include the original exception in the exception
this method can be private
log.info with id?
log.info with id + message
BUG? you log the error but continue processing the invalid sequence number... what will happen? See line 83.
Do we want to log messages that are visible to the customer?
BUG? you log the error but continue processing the invalid state?
This is a bit hard to read, maybe you can refactor to something like PROJECTS_VOLUME_NAME + "-" + PROJECTS_VOLUME_NAME.
This is a bit hard to read, maybe you can refactor to something like PROJECTS_VOLUME_NAME + "-" + PROJECTS_VOLUME_NAME + "-";
This is a bit hard to read, maybe you can refactor to something like PROJECTS_VOLUME_NAME + "-" + PROJECTS_VOLUME_NAME + "-" + PROJECTS_VOLUME_NAME
Do we have to handle the case where one of the expressions is a duplicate of the other? If it is, it should be renamed to indicate that the expression is a valid expression.
Do we have to handle the case where one of the expressions is a duplicate of the other log messages?
Do we have to handle the case where one of the expressions is a duplicate of the other? If it is, it should be done in one call to the other.
you might want to check if the signature is null or empty.
you might want to check whether the signature is null or not.
you might want to check if signature is null or empty.
Is "Resource not found" the correct response during a rebase? If so I am OK with these changes so long as they work and pass tests.
Is "Resource not found" the correct response during a rejoin? If so I am OK with these changes so long as they work and pass tests.
Is "Resource not found"?
Shouldn't this be done by the try-with-resources on line 261, null pointer?
Shouldn't the stream be closed by the finally block?
Shouldn't this be done by the try-with-resources on the stream? I hope that's done by the NPE
Ouch, it is not needed.
Ouch. toString() is not needed.
Ouch. toString() is not needed
ddfFilesPath -> ddfFilesPath
ddfFilesPath and ddfFilesPath
ddfFilesPath
check whether the key is in this.stateTypes or not? if (!this.stateTypes.has(alias)) { throw new UnregisteredAliasException(alias, alias); }
check whether the key is in this.stateTypes or not? if (!this.stateTypes.has(alias)) { throw new UnregisteredAliasException(alias, false); }
check whether the key is in this.stateTypes or not? if (!this.stateTypes.has(alias)) { throw new UnregisteredAliasException(alias, "key"); }
Should we move the assignment out of the if clause?
The variable should be assignExternalId = account.getExternalId();
Should we move the assignment of the externalId to the line above?
I think this should be edr.primaryObject.
I think this should have type Cdr.Work instead of FileObject.
I guess this should be edr.primaryObject.
Same here. I don't think we need to check. Just let it crash if something is not admin.
Same here. I don't think it's necessary.
Same here. I don't think we need to check.
I do not understand the need to catch and log the error. What is the intention behind this?
I do not understand the need to catch and log the error. What is the intention of returning a successful response?
I do not understand the need to catch ClassCastException. What is the intention of returning a generic error code here?
if error port is not connected, will your parsedOutput will be null?
if if error port is not connected, will your parsedOutput will be null?
if script is not connected, will your parsedOutput will be null?
Looks like this is missing some use of it?
Maybe it's advisable to use startsWith
Maybe it's advisable to use startsWith?
please use GuidUtils.isNullOrEmpty
please use GuidUtils.isNullOrEmpty()
please use null for the parameters.
You could just use [Boolean::parseBoolean](<LINK_0> to reduce indentation?
You can just use [Boolean::parseBoolean](<LINK_0>
You can just use [Boolean::parseBoolean](<LINK_0> to avoid having to convert a string to a boolean
Does it work to set this to false instead of the previous value?
Does it work to set this to false, or is it what you did before?
Does it work to set the value to 1E-16_ON_DD?
Typo, UNIQUE constraint failed -> Committed
Typo, UNIQUE constraint failed -> Committed"
Typo: UNIQUE constraint failed -> Committed"
Why are the log statements removed?
Why are the log-out here?
Why is the log entry removed?
How about the case of a fitness function?
What is the reasoning behind this?
What if the Admins are normal?
I think this should be...EnsuresInitializedFields.
I think this should be...EnsuresInitializedFields.class.getCanonicalName().contains("this")
I think this should be...EnsuresInitializedFields.class.getCanonicalName().contentEquals("this")
Shouldn't this be stream.destroy()?
Shouldn't this be stream.close()?
Shouldn't this be the same as the test?
missing unit tests for this in HashJoinSegmentStorageAdapterTest
missing unit test for this in HashJoinSegmentStorageAdapterTest
missing unit tests for this in HashJoinStorageAdapterTest
You don't need to print the stack trace..
You don't need to close the executor. You should use a try-with-resources.
You don't need to print the stack trace.
I think this assignment and null check is on the same object. If JIT leaves double de-reference inside the if block, then it is not 'equals'.
I think this assignment and null check is on the same object. If JIT leaves double de-reference inside the if block, then it is an NPE.
should be equals
I don't see any literal numbers in this method. Why is it needed?
I don't see any literal numbers in this method. How is it needed?
I don't see any literal numbers in this method. How is it necessary to represent the number of times?
Can you make this class package-private?
Can you make this static?
Can you make this class package private?
System.out.println
System.out.println()?
System.out.println() calls.
same question
same question. The above uses monoError.
same question :)
how about using an IllegalArgumentException here instead? > "Not true" -> "Null pointer exception" > "Not a file uri"
how about using an IllegalArgumentException here instead? > "Not a file uri" --> "Not a file uri" or something similar.
how about using an IllegalArgumentException here instead? > "Not a file uri" --> "Not a file uri"
Could you please check if this is correct? If yes, it's better to fail fast.
Could you please check if this is correct?
potential NPE
This one too.
Consider using 'final' for local variables.
Consider using 'final' here.
Couldn't you just move the boolean overrideAnalyzer to the SimpleQueryParser? This would more user-friendly.
Couldn't you just move the boolean overrideAnalyzer to the SimpleQueryParser? This would avoid the need for the test being more complex.
Couldn't you just move the boolean overrideAnalyzer to the SimpleQueryParser? This would more detract the opt-out of the backend.
Minor: we should be using String.format here, same below.
Minor: we might want to move it to the KIP-specific format, so it might be more readable.
Minor: we should be using String.format() here, same below.
This else block can be replaced by: if (!want.isEmpty()) { continue; }
This else block can be replaced with: if (!want.isEmpty()) { continue; }
This else block is unnecessary.
please use the PercentType.ERO constant instead
please add curly brackets to the if statement
please re-use the PercentType.ERO constant
Let's have at least one test with GENERIC_MAPPING. The reason we use DWORD is because we are not using GENERIC_MAPPING anymore.
Let's have at least one test with GENERIC_MAPPING. The reason we use DWORD is because we are not using GENERIC_MAPPING as it is.
Let's have at least one test with GENERIC_MAPPING instead.
Unit test for this. I think it would be good to have a simpler test: if (statisticsAggregationOperator.isBlocked().isDone()) { return null; } if (!statisticsAggregationOperator.isFinished()) {...
Unit test for this. I think it's enough to belong to the commit dialog not in statisticsAggregationOperator itself.
Unit test for this. I think it's enough to be inlined.
please log the exception at debug level
please log the exception and continue..
please log the exception at WARN
I think this should be at the end of the loop
I think this should be at the end of the loop as early as possible. At most one iteration is needed
I think this should be done at the end of the loop as early as possible. At most one iteration is needed
can the method be private?
Style-nit: space after ()
can return int
We can use a lambda here, which is used in a few places.
We can make a refactor of this method to a common utility method.
We can use a lambda here.
getMessage() is not used, and we don't need to check for this.
getMessage() is never null
getMessage() is not used, and we don't need to check for it
I don't think it's a good idea to just check that the array is not empty so we can just not get that in the loop
I don't think it's a good idea to just check that the array is not null so we can just check that it is actually a String
I don't think it's a good idea to just check that the array is not null so we can just check that it is not a String
This is not required and can be removed.
This is not required and you can call create() method without actually mocking one
This is not required and you can have a test with 2 entity.
very strange for the appendFragment, I would rather propose something where we have the SysMLResource.QUDV_LIBRARY_PATH and SysMLResource.LIBRARY_PATH
very strange for the appendFragment, I would rather propose something where we have the SysMLResource.QUDV_LIBRARY_ROOTPATH and SysMLResource.LIBRARY_PATH
very strange for the appendFragment, I would rather propose something where we have the SysMLResource.QUDV_LIBRARY_PATH and qudv.
I assume you mean /etc/hadoop?
I assume you mean System.getenv(Constants.ENV_HADOOP_HOME)
I assume you mean /etc/hadoop.toString()?
When meta == null, ColumnDescriptor col = new ColumnDescriptor(filterColumn.getColumnPath()) returns null. If it is, return BLOCK_CANNOT_MATCH; Then, you can remove this check.
When meta == null, ColumnDescriptor col = new ColumnDescriptor(filterColumn.getColumnPath()) returns null. If it is, return BLOCK_CANNOT_MATCH; Then, you can remove the null check.
When meta == null, ColumnDescriptor col = new ColumnDescriptor(filterColumn.getColumnPath(), Meta.getType(), -1, -1) would be good enough
I suggest to improve the debug message in this case, and mention in it also the returned value of "lookupSupportedLocale(locale, getLocaleKeys())", especially if it is!= locale.
I suggest to improve the debug message in this case, and mention in it also the returned value of lookupSupportedLocale(locale, getLocaleKeys()), especially if it is!= locale.
I suggest to improve the debug message in this case, and mention in it also the returned value of "lookupSupportedLocale(locale, getLocaleKeys())", especially if it is!= null.
You might want to rename those to videoSizes as well
You might want to rename those to videoSizes as well.
You might want to rename those methods to favor readable lifting of the method?
Should use the static isSupported() method. you have on TargetChosenReceiver to avoid propagating build versions everywhere
Should use the static isSupported() method, you have on TargetChosenReceiver to avoid propagating build versions everywhere
Should call the static method TargetChosenReceiver.getSharingSenderIntent(this.getIntent(), this.finish()); be a little clearer.
Do you need to check!StringUtils.hasText(className)? The expression is probably not covered by your test above.
Do you need to check!StringUtils.hasText(className)? The expression is probably not covered by your test
Do you need to check!StringUtils.hasText(className)?
Log.error(e.getMessage(), e); so that we don't need to handle the exception
Log.error(e.getMessage(), e) so that we don't need to handle the exception
Log.error(e.getMessage(), e) so that we don't have to handle the exception
This is a good place for a stack trace, but I don't think it's a good idea to include it in the try block.
This is a good place for a stack trace, but I don't think it's a good idea.
More a small typo here.
I believe we should also check the binary here: java final String executablePath = Paths.get(path).resolve("prefix", "");
I believe we should use getPath() instead of "/"
final
I would put this on the previous line, to make it write: List<Integer> tmp = this.digitsSize - num; List<Integer> result = new ArrayList<>(limit); You might know this already but to make sure formatting is correct you can use ctrl + alt + L if you're using intellij on Windows (it's cmd + alt + L on mac). On eclipse it's ctrl + shift + F (cmd + shift + F on mac). I've found that very useful :)
I would put this on the previous line, to make it so that it's: List<Integer> tmp = this.digitsSize - num + 1; List<Integer> result = new ArrayList<>(limit); You might know this already but to make sure formatting is correct you can use ctrl + alt + L if you're using intellij on Windows (it's cmd + alt + L on mac). On eclipse it's ctrl + shift + F (cmd + shift + F on mac). I've found that very useful :)
I would put this on the previous line, to make it check that it's not equal to the limit
Can you explain this please?
Can we do this without any synchronization?
Can you explain this?
Since the snapshot returned appendCheckpoints and appendCheckpoints are having the same snapshot, it would be cleaner to use a single snapshot that holds the first checkpoints, and then use appendCheckpoints.
Since the snapshot returned appendCheckpoints and appendCheckpoints are having the same snapshot, it would be cleaner to use a single snapshot that holds the first checkpoints, and then use the second checkpoint list.
Since the snapshot returned appendCheckpoint is a global snapshot that can be taken out of the loop, it would be cleaner to use a local variable from the CheckpointWriter constructor that takes a streamId and a Map<String, Checkpoint>. This way, it will be easier to understand.
There is a fair bit of conditional logic here. The ForeignKeyDescriptor constructor is a class, so it should be used here.
There is a fair bit of conditional logic here. The ForeignKeyDescriptor constructor is already available as a parameter. Maybe we can leave it as is?
There is a fair bit of conditional logic here. The ForeignKeyDescriptor constructor is already available as a parameter. Maybe we can leave it as is.
I'm not sure we should do the same in the MigrationResource.canExecuteCommand() method.
I'm not sure we should do the same in the MigrationResource.canExecute() method.
I'm not sure we should do the same in Collectservice here.
Why should't you just catch the OSException here?
Why should't you just log the exception in the catch block to throw the OSException?
Why should't you just log the exception in the catch block?
consider giving this boolean a name that describes its /meaining/, not what is it about
consider giving this boolean a name that describes its /meaining- right?
consider giving info for this event
This is potentially dangerous. From an API standpoint though, it's not an error. We usually don't use it either way, so it's better to keep it as it is. In other words, if the type is java.lang.Exception, then just use java.lang.Exception.
This is potentially dangerous. From an API standpoint though, it's not an error. We usually don't use it either way, so it's better to keep it as it is. In other words, if Type is an enum, then the error message is misleading and it's just a guess.
please don't change default behavior
I don't think this is supposed to be based on the bc's message length. The rationale is that lastIndexOf would be more useful than 1.
I don't think this is supposed to be based on the bc's message size put in the log
I don't think this is supposed to be based on the bc's message length. The rationale is that lastIndexOf would be more useful than 1. If you look at EntryLogBufferedReadChannel, you can use lameGenerator.decode(logId, ledgerId, entrySize)) in the code.
The names (__id, __cas) should come from TemplateUtils, although they seem to be hard-coded in several other places.
The names (__id) should come from TemplateUtils, although they seem to be hard-coded in several other places.
The names (__id, __cas) should come from TemplateUtils, although they seem to be hard-coded in several places.
The check should only be done in the UI plugin.xml, not here.
The check should only be done in the UI plugin.
The should probably use the trace object instead of the folder.
since we have this now, Line92 and Line 93 need to be adjusted LOG.debug("supervisorsWithFailures : {}", supervisorsWithFailures); reporter.reportBlacklist(supervisor, supervisorsWithFailures);
since we have this now, Line92 and Line 93 need to be adjusted LOG.debug("supervisorsWithFailures : {}", supervisorsWithFailures); reporter.reportBlacklist(supervisor, supervisorsWithFailures : {}", supervisorsWithFailures);
since we have this now, Line92 and Line 93 need to be adjusted LOG.debug("supervisorsWithFailures : {}", supervisorsWithFailures); reporter.reportBlacklist(supervisor, supervisorsWithFailures); log(supervisor, supervisorsWithFailures);
Same here. For "pom"
Same here, please create a method for "pom"
Same here, please create a method for this.
Usually we don't need to fetch data from the database.
Don't we need to fetch from the database?
Usually we use query parameters rather than query parameters
We need to remove this line.
we need to remove this line.
We need to remove this line in the tests.
Minor: TRACE.log(trace, "Reset to checkpoint: %s", checkpoint.getInputStream().readObject());
Minor: TRACE.log() calls should be at the end of the method, not the method name.
Minor: TRACE.log() calls seem to be redundant.
Is this correct? If so it should be sufficient to log a different message than the one that is actually logged and not an error.
Is this correct? If this is an unexpected error message you should at least raise the log level to DEBUG.
is this the same as the else?
redundant- done in the HostModel
Can be moved to a HostModel
redundant- done in HostModel
What is this variable for? Since you're returning null on line 110 and 110 chars, the next part just returns.
What is this variable for? Since you're returning null on line 110, you could just return the response immediately and avoid the null check.
What is this variable for? Since you're returning null on line 110, you could just create it immediately after the if statement.
You should use <LINK_0> and get rid of this test
You should use <LINK_0> and not <LINK_1>
You should use <LINK_0> and get rid of this assertion.
This could be simplified to if (!pageBuilder.isFull() && probe!= null) {... }
Maybe return pageBuilder.reset();?
Maybe return pageBuilder.reset();?
please move it to Constants.java
please move it to Constants.java instead.
please move it to Constants.java instead of hard coding it
I think we should store the Trace as a field and use it as a method reference instead. That way we don't have to handle exceptions.
I think we should have a test for this method.
I think we should store the Trace as a field, and use it as a method parameter?
I am not sure if I understood well, but if we set these variables to the same long list, there are executions for variables that have been added to the TID and CDerivedInfo. Could you explain?
I am not sure if I understood well, but if we set these variables to the same long list, there are executions for variables that have been created. Could you explain?
I am not sure if I understood well, but if we set these variables to the same long list, there are executions for variables that have been added to the TID and CDerivedInfo. Could we keep them in the same order as well?
This should come out of the try, and then close the tableWriter.
This should come out of the try block.
This should be moved to the top of the method.
Same here with not needing the local variable.
Same thing here with not needing the local variable.
Same here with not needing the variable.
Should this log the errors that are being returned?
Can this log be removed?
Can this test be moved to a test?
this
this.shooter!= null
this.shooter!= null ;)
I think we should remove the tabs here as they are deprecated, but let's remove the tabs from the code as well, which can be removed.
I think that this can be removed.
I think that the whitespace was deprecated, but not sure if we want to use that, since it's deprecated,
Minor: if (licenseText!= null &&!licenseText.exists()) { return licenseText; }
Minor: if (licenseText!= null &&!licenseText.exists()) {
Please remove the assertion.
We could just use Inlines.NO_VALUE to keep the Optional clean-up.
We could just use Inlines.NO_VALUE to avoid having a local variable.
We could just use a InlineHandler.
4 spaces
4 spaces leak.
4 spaces postformat
Maybe add a method in the Builder to create JavaFX nodes? A bit more SLAP.
Maybe add a method in the Builder to create JavaFX nodes? A very SLAP.
We could move this line into a method.
Many identifiers, I think we should be able to replace the InputStream with a try-with-resources block, and avoid the finally: try (FileOutputStream out = new FileOutputStream(file)) {... }
Many identifiers, I think we should be able to replace the InputStream with a try-with-resources block, and catch the exception there if we want to throw an exception
Many identifiers, I think we should be able to replace the names on the RSS feeds.
typo in unfinishedRequest -> unfinishedRequest
typo: unfinishedRequest -> unfinishedRequest
typo in unfinishedRequests -> unfinishedRequest
why is this removed?
Replace "builder" with a more readable name
Replace "builder" with a better name.
please remove
Please remove
please remove this
nit: can we use rowGroups instead of stripeStatisticsValidation?
nit: java rowGroups = stripe.getColumnEncodings();
nit: can we use rowGroups here?
Should this be warn?
Would it be better to add a timeout here.
Whats the point of this change?
should we remove this line?
should we remove the "user.timezone" property?
should we remove the "user.timezone" part?
the return value is not used.
we want to return here: the return value is Nullable, so if the method returns null, we don't need to check it for null.
we want to return here: the return value is not used.
null == adapter
how about adapter = null? adapter : new AdapterImpl()
if adapter is null, this can be null.
It's a little confusing to me that we requireNoContent to return the ContentTypeConfigurationBuilder, whereas that seems to be more flexible.
It's a little confusing to me that we requireNoContent to return the ContentTypeConfigurationBuilder, but that's why I think we should accept a 'final'.
It's a little confusing to me that we requireNoContent to return the ContentTypeConfigurationBuilder, but that's not an implementation detail.
Please change message to "Unknown Acctschema@" or similar
Please change **@NoAccrschema@** for **@C**
Please change StringBuilder to StringBuilder
SimpleDateFormat should be immutable.
Cache the StringBuilder in the line above.
Cache this string from line 66.
Nitpick, use braces
missing braces
Please use braces
Don't swallow exceptions
Don't swallow exception.
Use logger
please close this.
please create a method to access just the body and not this.
please create a method or method with an appropriate name.
Most of the setup in this test is superfluous as calling into the last line with nulls only will result in the same exception. However, doing it so would require to catch the exception and make sure we are getting the exact one we expect.
Most of the setup in this test is superfluous as calling into the constructor will result in the same exception. However, doing it so would require to catch the exception and make sure we are getting the exact one we expect.
Most of the setup in this test is superfluous as calling into the last line with nulls only will result in the same exception. However, doing it so would require to catch the exception and provide a message for the exception.
since we are before can do action, you should also check that getVdsGroup is not null
since we are before can do action, you should also check that getVdsGroup() is null
isn't it possible that getVdsGroup() is null? otherwise it is null
Can be replaced with lambda
Can be replaced with lambda.
Should be replaced with lambda
Can this be just for (TmfTraceEntry entry : entryList) {?
Can this be just for (TmfTraceEntry entry : entryList) {?
Can you rename this to fAggregateGroup?
We should also support order_by, not order_by
We should also check that the orderByVals is empty.
We should also check that the query is not empty before we have order_by
I don't think this does what you want. This can lead to flaky behavior.
I don't think this is necessary. This can result in some "untransmission of" message. It should be sufficient to have a Request for all Request checks.
I don't think this is sufficient.
final
final to as the rest of the code
final :)
Just noting that the inconsistent use of the _FIELD suffix annoys me.
Just noting that the Exception is thrown in this method.
Just noting that the Exception is thrown in the new method.
"page is required"
return pageSupplier.isFinished() && pageSupplier.isFinished()
"page is null"
Could you use Boolean instead of Boolean?
Could you please rename this method to isDeduplicateObjects? For example, without the class mappings.
Could you please use Boolean instead of Boolean?
If colorOutput() is empty, we'll get a null pointer exception here.
If colorOutput() returns true, the buffer will be empty. Is that intentional?
If colorOutput() returns true, the buffer will be empty.
I just realized that fTraces is the TmfExperiment. There will be only one iteration. So, the change of the name 'fTraces' is not accurate. Also, I noticed that the child monitor will not progress because the progress isd not update since there is no knowledge about the press and we can't call monitor.worked(). So, maybe it's better for the user to use a TmfTraceManager for the event.
no, you can use IProgressMonitor.false
remove
the change of of this file is the original implementation. When partition.getReplicas() returns null, it's not needed.
the name of the partitions is misleading.
the name of the partitions is misleading as it doesn't match.
Should IdentityClient follow the same builder pattern as all pipelines?
Should IdentityClient follow the same builder pattern as all other pipelines?
Should IdentityClient follow the same builder pattern as all pipelines above?
You can create a new StringBuilder using StringBuilder instead of +.
You can create a new StringBuilder using StringBuilder instead of concatenation.
You can create a new StringBuilder using StringBuilder instead of concatenation
Please handle InterruptedException and set interrupted flag. Why is this ignored?
Please handle InterruptedException and set interrupted flag. Why?
Please handle InterruptedException and set interrupted flag. Why is this ignored?
The above should be a constant on the UI e.g.snmp.getSchema. And use that here.
The above should be a constant on the UI as well.
The above should be a constant.
I would suggest to add a TODO here to show the contributions to the database
I would suggest to add a TODO here to show the contributions to the log
I would suggest to add a log here.
Missing final
final
final on variable names
Consider to rename to element or element.
nit: this wrapping is redundant.
nit: this wrapping is redundant..
We don't need the check here because we're just delegating to the other minify method anyways. All this method does is make sure that the file has a name before delegating
We don't need the check here because we're just delegating to the other minify method anyways. Only if the file has name equals, I don't think we can get it here.
We don't need the check here because we're just delegating to the other minify method anyways. All this method does is make sure that the file has the right name before delegating
can you add assert for hasPipelineNamed call as well?
can you add assert for hasPipelineNamed call?
verify that there are actually two pipelines
storage should be final according to the checkstyle guidelines (which are deactivated in this plug-in though). Anyways, I think we should stick to it as far as possible.
storage should be final according to the checkstyle guidelines (which are deactivated in this plug-in though). Anyways, we should stick to it as far as possible.
storage should be final according to the checkstyle guidelines (which are deactivated in this plug-in though).
Should this be the same Date instance as above? If midnight happens in between the creation of the two instances, this will fail.
Should this be the same Date instance as above? If midnight happens in between the two instances, this test will fail.
Should this be the same Date instance as above? If midnight happens in between, this will fail.
use the idiom StringUtil.notNull(project, "project")
Use the idiom StringUtil.notNull(project, "project")
use the idiom StringUtil.getString(project, "project")
creation of assertionTypeTest is duplicated in both testTransformXDRResponseToCheckPolicy and testTransformXDRResponseToCheckPolicy. Try to do that too.
creation of assertionType and moving the test to separate method
creation of assertion methods could be moved up.
This line can be removed.
This line can be removed
This line should be more readable
suggestion if (this.privateKeyHostsFile == null) { this.sshDirectory = new File(System.getProperty("user.home"), ".ssh"); } else { this.privateKeyHostsFile = "known_hosts"; }
suggestion if (this.privateKeyHostsFile == null) { this.variantHostsFile = "known_hosts"; }
suggestion if (this.privateKeyHostsFile == null) {
Isn't allocateLockTimer.time() executed before the lock is acquired?
Isn't allocateLockTimer.time() already called in the lock manager?
Isn't allocateLockTimer.time() already called in the lockManager?
Do you still need this if you've created the appender?
I think you meant LOGGER.log4j.Logger.getRootLogger()
Do you still need this if you've created the appender on class?
I think we should now use message rather than message
I think we should now use message rather than String.format to fail fast.
I think we should now use message too
The new Object[][]{test1_comp.interval_list", "test1.dict"}, {"test1cf", "test1.dict"}, {"Homo_sapiens_trimmed.dict"}, {"Homo_sapiens_trimmed.dict", "Homo_sapiens_interval_list"}, }; (same for the other test cases).
The new Object[][]{test1_comp.interval_list", "test1.dict"}, {"test1cf", "test1.dict"}, {"Homo_sapiens_trimmed.dict"}, {"Homo_sapiens_trimmed.dict"}, }; }
The new Object[][]{test1_comp.interval_list", "test1.dict"}, {
Couldn't this be moved into the startQuery method for consistency?
Couldn't this be moved into the startQuery method?
Couldn't close a QueryRepository be used by the start-for-each loop?
This is not used anywhere.
The method name is not used.
It is better to put this line before the method call, to keep it consistent with the pattern used elsewhere.
The PartitionedFile constructor already takes a PartitionedFile, so the flushIndex() call is unnecessary.
The PartitionedFile constructor already takes a PartitionedFile, so the flushIndex() method actually calls writeRegionIndex() on it. That was just a part of the public API, but it seems like we're doing that here.
The PartitionedFile constructor already takes a PartitionedFile, so the flushIndexBuffer is called after writeRegionIndex(), so the memory index could be written.
I don't like this solution. What about adding a pre-defined error message to the users?
I don't like this solution because it has repeated logic to get the batched statement. What about adding a helper method for subquery?
I don't like this solution because it has repeated logic to get the batched statement. What about adding a helper method for each statement that does the check?
Is there a reason why "java.util.Optional" is used here?
Is there a reason to use 'java.util.Optional' here?
Is there a reason why "java.util.Optional" is used here? I think it should be preferable to use it here.
@deepak1 A question, after looking at this code, it looks like asyncRefresh() is only called when the asyncRefresh() is invoked. Is it possible to return the future token instead of calling refreshCredentials()?
isDebugEnabled
I think refreshCredentials() is unnecessary here since it will return the future token.
what is this good for?
Can you overload this method by providing invalid values for password.
Can you overload this method by providing error message so we can have null?
Could we pull this out to a helper method and use it in both the future and future?
Could we pull this out to a helper method and use it?
Could we use guava preconditions.empty()?
This could be package-private for tests, right?
This could be package (private) instead of protected
This could be package-private for tests, since they are used only once
The same, use java.util.Optional.
The same, use java.util.Base64 for a test case.
The same, use java.util.JsonCodec#encodeCollectionToTimestamp / <LINK_0>
Here we have dim2 and dim2 in different queries. The same query could be generated as druid.foo
Here we have dim2 and dim2 in different queries. The same query is equivalent to druid.foo.sort.Compatible.
Here we have dim2 and dim2?
This feels like a very fragile way to fix it.
This feels like a very long line
This feels like a typo in the variable name for the local variables
It would be nice to use thenCompose for this.
It would be nice to use thenCompose for these.
lambda?
A null pointer exception is triggered here, fValues may not be added to fValues.
A null pointer exception is triggered here, fValues is not cleared.
A null pointer exception is triggered here, fValues is not cleared for a null value.
Can you move the assignment out of the for loop?
Can you make this method private?
Can you make this private?
shouldn't need the throws declaration?
shouldn't need to throws declaration?
This throws statement is redundant
I think this should be moved to the "protected" method.
I think this should be moved to the "protected" method above.
I think this should be public static void
Consider changing this to IContainer.INCLUDE_TEAM_PRIVATE_MEMBERS and throw an exception.
Consider changing this to IResourceProxyVisitor.convertImageElement()
Consider changing to IContainer.INCLUDE_TEAM_PRIVATE_MEMBERS to INCLUDE_TEAM_MEMBERS
This log message seems redundant, since it seems to be already logged with the exception message.
This log message seems redundant, please remove.
This log message seems redundant.
No, this method should not throw interrupted exceptions.
No, this method should not throw interrupted exceptions. Let's remove that.
No, this method should not throw interrupted exceptions..
Wouldn't Executors.newSingleThreadExecutor(factory) be better choice?
Instead of making this a daemon use of the executor and do something like: new Thread(() -> { @Override public void run() { } });
Wouldn't Executors.newSingleThreadExecutor(factory) be better choice?
s/becomes/loop</code>
Change this to a more generic Request body.
Change this to a ton of the other cases.
nit: extra space.
nit: extra space?
nit: extra ()
redundant else
redundant else clause
redundant else block
Suggestion: should it be > 0
please remove
Suggestion: Should it be > 0
Why is this error?
Why is this error being caught by the method?
Why is this error? Add an error message?
Can we add a log line here to indicate the application failed to generate JobConfig for StreamApplication?
Can we add a log line here to indicate the underlying cause?
Can we add another method prepareJobs() to ApplicationManager and set the currentAppId and appDesc in a separate method?
Very minor thing, that now is a little tricky, since it's not a system call and can be ignored. Can you add a log message to the log file and change it to trace?
Very minor thing, that now is a little tricky, since it's not a system call and can be ignored. Can you add a log message to the log file and change it to debug?
Very minor thing, that now is maybe missing spaces before and after the "+" operator.
either a for-each loop or the next block is more readable?
either a for-each loop or an iterator.
either use catch (Exception), or at least log a warning.
Maybe it's better that we put in the ES module the time format that ES uses. I guess the TimeUtil should be a bit more general purpose while I imagine (?) that ES is always using one specific date pattern.
Maybe it's better that we put in the ES module the time format that ES uses. I guess the TimeUtil should be a slightly more general purpose while I imagine (?) that ES is always using one specific date pattern.
Maybe it's better that we put in the ES module the time format that ES uses. I guess the TimeUtil should be a bit more general purpose while I imagine (?) that ES is always using one specific date pattern..
Minor typo: Should be "-Modified".
USERNAME_INPUT?
Minor typo: Should be "-Modified"
the query returns the configuration from vm_static when no snapshot of type next-run exists for the vm, so this command would always create next-run snapshot I think, right? it is generally not a good practice to call queries from within commands, can we replace it with direct query from the database? btw, this way we can ask to update the specific snapshot we queried - if it doesn't exists we will get an error (which we can ignore) and this command could be non-transactive again. sorry for the back-and-forth transaction scope changes - let's give it some more thinking before changing it again.
the query returns the configuration from vm_static when no snapshot of type next-run exists for the vm, so this command would always create next-run snapshot I think, right? It is generally not a good practice to call queries from within commands, can we replace it with direct query from the database? btw, this way we can ask to update the specific snapshot we queried - if it doesn't exists we will get an error (which we can ignore) and this command could be non-transactive again. sorry for the back-and-forth transaction scope changes - let's give it some more thinking before changing it again.
the query returns the configuration from vm_static when no snapshot of type next-run exists for the vm, so this command would always create next-run snapshot I think, right? it is generally not a good practice to call queries from within commands, can we replace it with direct query from the database? btw, this way we can ask to update the specific snapshot we queried - if it doesn't exists we will get an exception (which we can ignore) and this command could be non-transactive again. sorry for the back-and-forth transaction scope changes - let's give it some more thinking before changing it again.
I know about about the case of "teardown" and "stopping" of the execution of the test, but I'd prefer that we can have a test like: boolean testIsPowerManagementStarted = setup(); try { setup(); } finally { teardown(); }
I know about about the case of "teardown" and "stopping" of the test, but maybe it's worth having a setup method to get the lock.
I'd prefer that teardown does not call this method.
Change to debug
Change the parameter of this method to an empty map.
Change the parameter of this method to an early return
Put this assert onto one line
move this test to assertFalse
move this test to Encounter class
Why change this?
Why did you change this?
Why add this?
I think you should add the content-disposition and NODE_SOURCE_FILE_NAME_SUFFIX to avoid duplication.
I think that we could also make this message more explicit.
I think that we could also make it debug
Can you help me understand why this check was necessary before and after the for loop?
Can you help me understand why this has to be done and how it seems seems related to events?
Can you help me understand why this has to be done and how it seems related to events?
This is a performance optimization. It is best to avoid calling the extra method.
LGTM in general. A Ctrl+I will fix it and to fix it in the next commit.
LGTM in general. A Ctrl+I will fix it and to fix it too.
Missing space after if.
Missing space after if
Missing space after if?
The same normally applies to option groups: use different ids for different groups
The same normally applies to FETCH_TAGS and RefSpecPage_annotatedTagsNoTags. The same normally applies to createTagOptionButton suggestion
The same normally applies to option groups: use different ids for both FETCH_TAGS and RefSpecPage_annotatedTagsNoTags
I don't think this is necessary, it would be better to set the error string message to the error.
I don't think this is necessary. If errorJsonMessage is null, then it will be set to an empty string "" in the error string.
I don't think this is necessary. If errorJsonMessage is null, then it will be set to an empty string "" in the errorJsonMessage.valueOf method.
Strings.isNullOrEmpty
Strings.isNullOrEmpty()
Strings.isNullOrEmpty() :)
you are only setting flag to false, but still unnecessary loop operations are executed
you are only logging if getTagName() is null, but not getTagName()
you are only logging if getTagName() is null, but still unnecessary assertion.
use logger instead of String.format
use logger instead of string.
iteration = 1 should go after the loop
suggestion List<CompletedCheckpoint> lastTryRetrievedCheckpoints = new ArrayList<>(retrievedCheckpoints);
suggestion LOG.info("At boot {} checkpoints from storage.", numberOfInitialCheckpoints);
suggestion LOG.info("Setting {} checkpoints to {}, in storage.", numberOfInitialCheckpoints, 0);
It also doesn't allow me to change the destination branch if my change is in DRAFT state. I think for draft changes we should definitely allow to change the destination branch.
It also doesn't allow me to change the destination branch if my change is in DRAFT state, I think for draft changes we should definitely allow to change the destination branch.
It also doesn't allow me to change the destination branch if my change is in DRAFT state, but I think for draft changes we should definitely allow to change the destination branch.
reminder - please remove System.out.println
reminder - please remove System.out
reminder - please remove System.out.
This should be a check that the currentDisplay is not null.
This is not necessary since the workbenchWindow will be disposed.
This is not necessary since the workbenchWindow can be null
I think the transport should be immutable as well, perhaps deprecate it.
I think it's better to default to ImmutableSet.copyOf(scopes) here, or maybe make it a singleton?
I think it's better to default to ImmutableSet.copyOf(scopes) here, or maybe make it a copyOf?
Is this method used to check the memoryAlreadyBeingRevoked?
Is this method used?
Is this class necessary?
There seems to be a lot of duplication here. Could this be implemented as: java interface GrahpableList<String> { Map<String, Authorizations> configs = new HashMap<>(); props.put( tableName, Authorizations.values()); for (String tableName : configs) { options.put(name, Authorizations.name); } return createBatchScanner(String tableName, Authorizations authorizations, config); }
This seems to be unused.
There seems to be a lot of duplication in the code. It's not the same as the one in the method above. Do you think we could make this method private?
This validation block seems to be duplicated in a couple of places. Can you extract it to a method and reuse the method?
This validation block seems to be duplicated in a couple of places. Can you extract it to a private method and reuse it?
This validation block seems to be duplicated
This should be a switch, since the case is more than a known value.
This should not be possible, right?
This should be a switch, since the case is more specific than NAMESPACE
warn
ERROR level seems to be too low, log the entire stack trace.
ERROR seems like a generic info message. ERROR?
It was args, not argb, that was supposed to be checked for null.
It was args, not argb, that was supposed to been checked for null.
Did you consider to make this return Color instead of null?
rename to E
rename to e
final
No need to use an empty line before the builder.
No need to use an empty line before the if.
No need to use an else statement since the if block ends with a return
As we have the same error message as the other exception
As we have the same error message as the other exception.
As above.
Do we need to check key!= null
Do we need to check key == null
Do you need to check key!= null
why is this necessary?
Maybe you can have a?: here?
!bAdd
This is already done in the upper class.
This is already done by the driver. This is the only place where we need the listener
This is already done by the driver.
Please use Preconditions.checkArgument to check that diskChain is not null.
Please format this line
Please declare the short lived in this case
Please add the Identifier of the Contentlet, for troubleshooting purposes.
Please add the Identifier in the Contentlet, for troubleshooting purposes.
Please add curly braces
Why are these two interchangeable?
Why are these two lines conditionals needed?
Why are these two lines conditionals?
Same as above, the current representationsToDelete should never be null.
Same as above, the current representationsToDelete should never be used.
Same as above, there is no clear way to stop the current diagram without adding it.
Make the constants into constants?
Make the constants?
Should be an error?
Join this with the trace log below it.
Join this with the trace statement below it.
redundant parentheses
![MINOR](<LINK_1> 'Severity: MINOR') Remove this use of "currentIterator". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "currentIterator". [![rule](<LINK_1>](<LINK_0>
this doesn't seem to be used?
is Type chromosome?
is there a reason to change this?
is the chromosome?
any reason for saving spaces around ==?
any reason for saving spaces around +?
any reason for saving spaces around entry?
What happens if we use 4-space indent here, and it's inconsistent here?
Any reason why this change?
What happens if there is no fixture?
This is similar to Decryptor
this is similar to Decryptor
here outputField should be in the output field
new lines
new line
new method name
Would it be cleaner to just read the file contents and use a try-with-resources here?
Would it be cleaner to just read the file contents and use a temporary file here?
Would it be cleaner to just read the file contents and use a temporary file that is returned from above?
you should handle all exceptions that have a catch block which is never thrown.
you should possibly use static, because it is a constant.
test above?
A small thing, but maybe we can store destObj in a variable to avoid the duplicate calls
A small thing, but maybe we can store destObj around a variable to avoid the duplicate calls
A small thing, but maybe we can store destObj as a variable to avoid the duplicate calls
parameter exemption
exemption
exception prone
We dont need the 'label' object at all.
We can do this inside.initFontStyle() line, right?
We dont need the 'label' type since we dont need the name in the workbench.
Do you expect an answer to this? If you do, then you need to change this error message. If you don't, then you need to change the assertTrue to assertFalse.
Do you expect an answer to this? If you do, then you need to change this error message. If you don't, then you need to change assertTrue to assertFalse.
Do you expect an answer to this? If you do, then you need to change this error message. If you don't, then you need to change this error message.
If you are expecting a message in the assertion, it's probably not enough to be a failure.
If you are expecting a message in the assertion, perhaps it's better to use assertj and fail() here.
If you are expecting a message in the assertion, perhaps it's better to use assertj and fail("Expected exception", e);
We should use the same behavior as the other exceptions.
We should use the same approach as the other exceptions.
We should not use the getter, the content is the property set.
It seems like it might be clearer to extract EPSILON and Levels.
It seems to me that there's no other way to extract EPSILON and DOUBLE?
It seems to me that there's no other way to extract EPSILON and Levels.
let's verify the result
let's verify the error
let's verify the task is cancelled
to remove empty lines
to remove 'final' modifier
to remove empty lines?
I'm not sure how this is related to this PR. Will you check with it?
I'm not sure how this is related to this PR. Will you check with you?
I'm not sure how this is related to this PR. Will you check with you to have this variable?
This doesn't check that all traces.get(0) are non-null.
This doesn't check that all aspects have the same name (e.g. all or the others). If you want to keep the " common" name, you could do "traces with a different name".
This doesn't check that all aspects have the same name (e.g. all experiments). If that's not the case, then this should be "traces".
The system property names are used in all cases, this line does nothing
The system config here has "default" available.
The system config here has "default values", this would return null.
Left over from debugging?
Leftover from debugging?
Left over from jenkins
I think this is the wrong error message. You should say "Unknown key for host: '" + host + "' already exists." You can also consider adding a version which sets the key to the error message.
I think this is the wrong error message. You should say "Unknown key for host: '" + host + "' already exists." You should also have a method in the Enum class to add the keys.
I think this is the wrong error message. You should say "Unknown key for host: '" + host + "' already exists." You should also have a method in the Enum class that contains private static String addPrivateKey(String host, byte[] key)
ExtMadiaType?
Missing generics on ConcurrentLinkedQueue?
Missing generics on ConcurrentLinkedQueue.
We should be chaining the two arguments here instead of directly accessing the Intent.
We should be chaining the two calls here instead of directly accessing the Intent.
We should be chaining the parameters here?
why is this left over from the previous line?
Why is this left over from the previous line?
why is this left here?
minor: this could be private static final
minor: you can use this method reference instead of instance field
nit: you can use this method reference instead of instance members
we should add org.eclipse.uml2.uml.Package artifact.element.importMetamodel to remove dependency from org.eclipse.uml2.uml.Package.
we should add org.eclipse.uml2.uml.Package artifact.element.importMetamodel to remove dependency as we'll get it from the external contribution.
we should add org.eclipse.uml2.uml.Package artifact.element.importMetamodel to remove dependency from org.eclipse.uml2.uml.Package
I think we should use PDataType.TIMESTAMP_PRECISION instead of hard-coding precision and scale.
I think we should use PDataType.TIMESTAMP_PRECISION instead to make the precision/scale a constant.
I think we should use PDataType.TIMESTAMP_PRECISION instead to make the precision/scale a constant, right?
We should move these strings into constants.
We should not be converting from strings to strings. These changes should be part of the enum.
We should use switch for these cases where these values are different.
I don't think you need this line.
This line is unnecessary.
There are no need to add a new test data provider here.
See getAllLifelines remarks
See getAllExecutions()
See getAllExecutions
Can't we call Abstract ResultValidator expectEvents() here? The implementation of the ResultValidator expectEvents is very similar.
Can't we call Abstract ResultValidator expectEvents() here?
Can't we call Abstract ResultValidator expectEvents on a List<EventMessage>?
Change to: requireNonNull(sortChannels, "sortChannels is null");
Change to: requireNonNull(sortChannels, "outputChannels is null");
This is nullable.
Not sure the way you want to use getLineSeparator here, but not sure if that is consistent with the CharSourceExtensions?
Not sure the way you want to use getLineSeparator here, but not sure if that is consistent with the CharSourceExtensions...
Not sure the current logic in this case... the question is -- do we want to allow adding a single route in a browser? If so, this is probably better to use getLineSeparator() (as done in DefaultDockerAddressImpl)
This is unused, so why make it?
I don't think it's particularly safe to reuse the same instance repeatedly.
This is unused, so why do you make it?
same suggestion as above
same suggestion about renaming: suggestion assertTrue(mails.isEmpty());
same suggestion about renaming: suggestion assertTrue(mails.isEmpty())
Does this work if the path doesn't resolve allure.bat? Can we return -1 if this happens?
Does this work if the path doesn't resolve allure.bat? Can we return -1 if this happens? Or is that an existing code?
Does this work if the path doesn't exist? Do we want to return a null or throw an exception?
Can you move the declaration to a local variable at the top of the method?
Can you move the declaration to a local variable at the top of the method.
Can you move the "Visited:..." to a constant?
Can you use org.apache.commons.lang3.StringUtils.to cover the line of code?
Can you use org.apache.commons.lang3.StringUtils.toByte(byte[]) instead?
Can you make this debug output a bit more explicit?
no need to throw InterruptedException anymore.
no need to close here right?
A quick question: Will we have to close this stream right after each group in both parameters?
Do we really need all this logic?
Do we really need to check a isDebugEnabled here?
Do we really need to check this?
It seems like we need to set byte state to STARTED and call base64.close() when the lock is already in the finally block. The base64.close() call could be complete and the connection won't be released.
It seems like we need to set byte state to STARTED and call base64.close() when the lock is already in the finally block. The base64.close() call could be complete.
It seems like we need to set byte state to STARTED and call base64.close() when the lock is already in the finally block.
A lot of this logic seems to be reused for each container. Is there a way we can generify it to save some code duplication?
A lot of this logic seems to be reused for each handler. Is there a way we can generify it to save some code duplication?
A lot of this logic seems to be reused for each buffer logic seems to be reused for each container. Is there a way we can generify it to save some code duplication?
Why we need to create local variable for the liveInstances?
Why we need to create local variable for it? Since we already have it in the event processing logic.
Why we need to create local variable for it. Since we already have it in the event processing logic.
I think we should verify the length of the commit name.
I see that the method cannot be void
I see to rename
Should this result in all active connections being discarded? During runtime this may happen if the configuration is cleared by the config map. So this should be done in the managed pool.
Should this result in all active connections being discarded? During runtime this may happen if the configuration is cleared by the config map.
Should this result in all active connections being discarded? During runtime this may happen if the configuration is cleared by the config map. So this should result in all active connections being discarded.
Just to be sure, we don't need to check if the list is empty. This can happen if the topic does not exist yet.
Just to be sure, we don't need to check if the list is empty. This can happen if the topic does not exist.
Just to be sure, we don't need to check the list. This can happen atomically with partitionsFor(topic). We can avoid creating a new List.
Check without throwing Exception.
Check without at least one of the correct tests.
Check no error message.
Better use { } around if body.
Better use { } around the statement.
Better use { } around this statement.
I think this will only apply to files where they are not handled.
I think this will only apply to files where they are in the directory.
I think this will only apply to.json files in the root POM.
The return type for.getTrace() could be overriden in CtfKernelEvent too.
The return type for.toString() could be overriden in CtfKernelEvent too.
The return type for.getTrace() could be overriden in CtfKernelEvent too, so it's not actually called twice...
why not just throw exception, since the exception is not thrown
why not just throw exception, since the exception is not thrown, I thought that TestHelper.fail() method will go after the next line :)
why not just throw exception, since TestHelper.expectException() throws Exception
I'm wondering if we should use nanoTime() for getting the values. It may be reasonable to artificially make this log message more flexible.
Can we use [ResilientOperation](<LINK_0>
I'm wondering if we should use nanoTime() for this long timeout.
how do you feel about adding some spaces spaces between the String and the 'if'? You can move this to a separate commit.
how do you feel about adding some spaces spaces between the String and the 'if'? You can move this to another line.
how do you feel about adding some spaces spaces between the String and the spacing :)
Why not throw an exception if the keySerde is null?
Why do we need to check for null?
Why do we have to check for null?
suggestion sb.append("AccountNonExpired: ").append(isAccountNonExpired()).append("; ");
suggestion sb.append("AccountNonExpired: ").append(isAccountNonExpired()).append("; ")
suggestion sb.append(instance.getSecurityRealm());
Please remove the extra stuff here.
Please remove this stuff.
Please remove this extra stuff.
As before, I'd call pruneHeaders(k, v) multiple times.
As before, I'd call pruneHeaders(k, v) once and return new MutableMessage<>(message.getPayload(), k).
As before, I'd use mapLazy.
Use try with resources
Use try with resources? Or somebody will read it to the console
You should close the reader
I think this should use a synchronized (repository) block.
This seems kind of a weird behaviour. We may need to set the initial value to true in any case.
This seems kind of a weird behaviour. We may need to set the initial state to true in any case.
mobilePhone->mobile
Can be debug as well
Can be debug level
if (invalidSessionsEndpoint!= null) { LOGGER.warn("Session tracking endpoint has not been set. Session tracking is disabled."); } else { sessionEndpoint = sessions; }
if invalidSessionsEndpoint is true, then shouldn't this be set to null?
if (invalidSessionsEndpoint!= null) { LOGGER.warn("... cannot set sessions tracking endpoint has not been"); } else { LOGGER.warn("... is not instance of HttpDelivery, cannot set sessions"); }
why do we need this change?
Why do we need this change?
When we invoke MessageHistory in the setMessage(), it is better to use the generic MessageHistory.
why not List<T> list = this;?
why not List<T> list = this;?
why not List<T> list = this; if (!list.isEmpty()) { return list; } else { testFailed =!list.isEmpty(); }
Change log level to debug
Change log level to debug.
Change log message to debug
Instead of void, just call getVds().getStorageDomainId().
does it make sense to return void? What is the purpose of changing the method name?
Instead of void, just call getVds().getStorageDomainId().toString()
this can be presized
this can be simplified to java final Map<K, V> result = map.stream().map(k -> keyMapper.apply(k));
this is redundant
I think this would be better as move the _heuristic = TwoPhaseOutcome.FINISH_OK; to the same place as the local JTA one.
I think this would be better as move the _heuristic = TwoPhaseOutcome.FINISH_OK; to the previous line.
I think this would be better as if (_requestLayout == null) { jtaxLogger.logger.trace("{} ({})", xid); }
What is the purpose of this sleep?
What is the use of this sleep?
What is the purpose for this sleep?
The reason why the variable was changed to final?
This should be a private method.
The reason why the variable was changed to final
org.eclipse.sirius.diagram.description.DescriptionPackage.Literals.EDGE_MAPPING__STYLE
"this" is not too specific.
"this" too.
There is no mention in the DASH IOP that this value needs to be zero zero.
There is no mention in the DASH IOP that this value needs to be -1 specifically. It just says "yes". So can you check for < 0 instead?
There is no mention in the DASH IOP that this value needs to be -1 specifically. It just says "yes".
This should be... java this.queue.get(count);
This should be in the previous commit.
This should be... java this.queue.get(update);
I'm not sure if this works, but maybe I would move the above code into a smaller method?
I'm not sure if this works, but maybe we should move this code into a common method?
I'm not sure if this works, but maybe I would move the above code into a smaller method.
access modifiers?
call this?
you can make this protected?
This should be logger.error(message, ex)
This should be logger.error(message, ex) instead of string concatenation
This should be logger.error.
Is the first else possible?
Is the first else statement not needed?
Is the first else statement not necessary?
We _could_ set the condition to false, orchestrator.getServer().version().isGreaterThanOrEquals(6, 3)); WDYT?
We _could_ set the condition to false, orchestrator.getServer().version().isGreaterThanOrEquals(6, 3));... What do you think?
We _could_ set the condition to false, orchestrator.getServer().version().isGreaterThanOrEquals(6, 3));... What do you think?
I think InstanceGroup.is a boundary case will be clearer
I think InstanceGroup.is a boundary case would be clearer
I think InstanceGroup_GROUP is actually a constant
Could be simplified to: java String message = alert.getMessage();
Could be simplified to java org.apache.commons.lang3.StringUtils.isNotBlank
Could be static.
if metricNameDtoList is empty, we don't have to add a null check
if metricNameDtoList is empty, we don't have to check this
I think we should return a unit test for this
How about making the method private?
How about to move this method to the'setRawTargets' method?
How about making the method final?
We're using this method - CleanOperation should not be used.
We're logging the error.
We're logging this error.
Could we create a CountFilter(Statement) that takes the stateEncoding to be set in the constructor?
Could we create a CountFilter(Statement) that takes the stateEncoding to be set here?
Could we create a CountFilter(Statement) that takes the stateEncoding to be set in the constructor?
I would prefer this to be a boolean instead of a condition (false == handles(docTemplate)). Also, it doesn't look like the type of the property is any longer.
I would prefer this to be a boolean instead of a condition (false == handles(docTemplate)). Also, it doesn't look like the type of the expression is going to be a bit confusing to me. How about "the generation is not supported for %s" instead?
I would prefer this to be a boolean instead of a condition (false == handles(docTemplate)). Also, it doesn't look like the type of the expression is going to be a bit confusing to me. How about "the generation is not supported for the {}.", docTemplate,...
Ahh I understand now, this needs to be declared outside the try-catch, which will log these errors. I think it would be better to close the stream at the end of the method, which will log these errors.
Ahh I understand now, this needs to be declared outside the try-catch, which will log these errors. I think it would be better to close the stream at the end of the test.
Ahh I understand now, this needs to be declared outside the try-catch, which will log these errors.
@timur27 I think this should be paramIndexPtr = null; no need to wrap it into an array.
@timur27 I think this should be paramIndexPtr = < length 0 and not paramIndexPtr = -1.
@timur27 I think this should be paramIndexPtr = < length 0 and remove the default value from the method signature
static?
static import
static conversion
Unless you're using a StringBuilder here, it might be cleaner to use a StringBuilder instead.
Unless you're using a StringBuilder here, it's probably better to use a StringBuilder instead.
Unless you're going to add final to variables, it's unnecessary to create them unnecessarily.
Oh, I see, you're trying to use this pre-merge :)
# of(? extends #)
# of(?
Minor: it might be worth pulling this into a method?
Should this be private?
Minor: it might be safer to use.equals()
Instead of checking for empty string, couldn't we just have this constructor call that one with a default name?
Instead of checking for empty string, couldn't we just have this constructor call that one?
Instead of checking for empty string, lets move this line to the beginning of the method and make sure we have only default values
Alias again.
Alias two lines earlier :)
Alias two lines earlier?
We could bail out earlier by changing the check further up to java if (hasPhotoId) {... } Also we could bail out earlier by changing the check further up to java if (hasPhotoId) {... }
We could bail out earlier by changing the check further up to java if (hasPhotoId) {... } Also we could bail out earlier by changing the check further up to java if (contains)?
We could bail out earlier by changing the check further up to java if (hasPhotoId) {... } Also we could bail out a little more carefully to simplify this code a little bit.
it does not make sense to have both last repl id and chkpt for partition...table ckpt parameter can be used to filter out invalid loads
it does not make sense to have both last refetch and chkpt for partition...table ckpt parameter can be used to filter out invalid loads
it does not make sense to have both last repl id and chkpt for partition...table ckpt parameter can be used instead of filter out invalid loads
assertions will be relevant here
assertions will be relevant here.
static import assertTrue
I'm not too sure whether this makes sense. It seems like if we have a convention like this to be consistent with the rest of the class (e.g. in the 'createBranchPage' method).
I'm not too sure whether this makes sense. It seems like if we have a convention like this to be consistent with the rest of the class (e.g. in the 'createBranchPage' method). Have you considered adding the following rules: 1. Removed use of getDefaultUpstreamConfig here? 2. Removed @throws IllegalArgumentException when the value is not true, instead of throwing IllegalArgumentException. 3. Add a message to the end of the file, so the user knows what the value is.
I'm not too sure whether this makes sense. It seems like if we have a convention like this to be consistent with the rest of the class (e.g. in the 'createBranchPage' method). Have you considered adding the following rules: 1. Removed use of getDefaultUpstreamConfig here? 2. Removed @throws IllegalArgumentException when the value is not null, instead of throwing IllegalArgumentException. 3. Add a message to the end of the file, so the user knows what the value is.
What? Is there any reason for this if statement?
What? Is there a reason for this if statement?
Is there any reason for this if statement?
Is there a reason we don't pass the actual type into the constructor? It seems like it would be the case for the queue name to be the same.
can we add an error message to the log saying the channel name can not be found
can we add an error message to the log saying the channel name can not be found?
You can use experimentModelDAO.getExperimentModelDAO()
you can use experimentModelDAO.getExperimentModelDAO()
You can use experimentModelDAO.getExperimentModelDAO(), because you do that in multiple places
Authenticated doesn't exist in the request. Are you sure it's not working?
Authenticated doesn't exist in the request. Are you sure it doesn't exist?
[minor] Space before "Authenticated".
Might want to synchronize on "this" outside of the synchronized block.
Might want to synchronize on "this" outside the lock.
Might want to synchronize on "this" outside of the synchronization block.
This statement isn't needed, no?
This stream isn't closed, no need to close it.
can we use a try-with-resources statement here? It also accepts in the charset.
prefix get is more readable. What about the method names?
prefix get is more readable. What about the method name?
prefix get is more readable. What about the method names? This is used to decide how to deal with viewProjection.
Why are we returning a new List here instead of a List?
final
Why public?
I wonder if this should be private or at least package protected?
I wonder if this should be private or at least package private?
I wonder if this should be final too?
I'm wondering if we can use String.join instead of String.join?
I think it would be better to have a test for an empty String
return builder.build();
Is there a need for this method? It should be private.
Is this a part of code that should already exist in the parent class? How can you know why the unify method doesn't already exist?
Is there a need for this method?
please don't touch old formats, whatever they do let them do that
please don't touch old formats, whatever they do let them do that for them
please do not touch old formats, whatever they do let them do that
Same deal here. If you want the existing variants to be consistent, you can keep the existing variants as well.
Same deal here. If you want the existing variants to be consistent, you can keep the existing variants.
Same deal here. If you want the existing variants to be consistent, you can keep the existing variants as it is in the future.
Since this nature isn't only about ITranslationUnit, I don't think we should assume that.
Since this nature isn't only about ITranslationUnit, I would instead change the project creation to in the decorate method
Here we should check that project is null
i18n?
i18N?
i18n??
Should be removed.
Should be existing, otherwise the value that wasn't matched.
Should be existing, i.e. the finally here.
session -> userWorkspaceRoot
session -> swrPath
session::exists
Hmm, we don't have to set the order in this line since you're using the above line.
Hmm, we don't have to set the order in this line since you're using the above line?
This is a refactor error.
Can you move it into a private method?
Can you move it into a private method?
Please add a space before if
Add another error message, that will be resilient if the query is not found.
Add another error message, that should be sent in conf.get()
Add another error message, that is now a bit confusing.
It would be better to use try-with-resources or close it inside the finally block.
It would be better to use try-with-resources or close it in a finally block.
It would be better to use try-with-resources or close it inside a finally block.
isForceUseTag should be used here?
isForceUseTag should be used here instead
this can be improved by inverting the condition, if true, then throwing exception
Why isn't this public? At least at the unlikely even it's needed (at the moment the cache is null).
Why isn't this public? At least at the unlikely even it's needed.
Why isn't a RootReturn being used here and within the upsert()? It seems like the only thing we need is a model node for a single Entity.
won't this be null at this point?
won't this be null?
won't the test fail even if the test failed?
This is a bit hard to follow. Are we sure the code should be in a different form? Most of the code should be moved out of the while loop.
This is a bit hard to follow. Are we sure the code should be in a different form? Most of the code should be moved to right after it's called.
This is a bit hard to follow. Are we sure the code should be null?
What is the purpose of this check? I'm not sure how it's related to the PR.
What is the purpose of this check? I'm not sure how it's supposed to add anything to the range of columns.
What is the purpose of this check? I'm not sure how it's better to use the iterator.
it only sets the DOMAIN_1 to DOMAIN_3_0. parseNativeManagementInterface1_1 and parseManagementInterface1_1 go to parseManagementInterface1_1
it only sets the DOMAIN_1 to DOMAIN_3_0. parseNativeManagementInterface1_1 and parseManagementInterface1_1 do we need for those variable?
it only sets the DOMAIN_1 to DOMAIN_3_0. parseNativeManagementInterface1_1 and parseManagementInterface1_1 does nothing.
Replace with copy(byte[], int, int)
If the BitSet is not properly ordered, I'd suggest explicitly doing this.contents.length - 1 here.
If the BitSet is not properly GCable.
I'm not sure about this, but I forgot that it was done previously. If you set a default size of 16MB by default, then this will not work.
I'm not sure about this, but I forgot that it was done previously. If you set this, then the constructor of SourceWithKeys can be private
I'm not sure about this, but I forgot that you could just call'source' here directly.
If we are not using this deprecated pattern, then I would like to merge the changes to PR #793 to 92.
If we are not using this deprecated method, then I would like to merge the old implementation and use the new one with the new implementation.
If we are not using this deprecated method, then I would like to merge the old implementation and use the new one with the new method overload
I would prefer to see this call to the constructor of ObjList<CharSequence> so that you don't have to do the extra check
I would prefer to see this constructor call the other one with ImmutableList.copyOf().
I would prefer to see this constructor call the other one with ImmutableList.copyOf()
A method should be private, and you don't need to create a new PanelInfo, as it's only used by tests.
A method should be private, and you should put private methods in GlobalConfig.
A method to create PanelInfo would be great.
Change StringBuilder to StringBuilder
consider merging if conditions into one line
consider merging if and else into one line
nit: maybe TMP_DIR.toPath?
nit: maybe TMP_DIR.stream()
Empty line at beginning of method.
better to use the official way here true instead than "true"
better to use the official way here true instead than "false"
better to use an official way here true instead than "true"
This should be removed and the change should now be managed such that adding or removing the busy tag should re-style the folder tab.
This should be removed and the change should now be managed such that adding or removing the busy tag should re-duplicate the folder tab.
This should be removed and the change should now be managed such that adding or removing the busy tag should re-ised or deleting the busy tag.
This should be thread.interrupt()
This should be thread.interrupt().
I would reduce the synchronization to a single thread pool
always use "this." to avoid unnecessary local variable.
always access namesMap to private
always use "this." for consistency.
Please use lib.getSupportedTypes().forEach()
You can use early exit from method
You can use forEach
rename to member
rename 'child'
rename to member as well
Don't need to check for CEs, just like it's done elsewhere.
Don't need the type parameter here, just "networknetworknetwork", and we are not using the expected value.
Don't need the type parameter here, just "networknetworknetwork", and we can store the body as a variable to avoid adding two types of channels.
This seems like it could be simplified to just use PushOneCommit.Result r
PushOneCommit.Result r
When this test fails it should be push to the master branch.
More than 120 chars, please.
More than 1 thing, but I think an enum would be useful here.
is this necessary?
This should be a switch statement, e.g., energyCost?
This should be a switch statement, e.g., energyCost
This still appears to be an odd indent for a single line.
Seems like this is the only place where you do it it should be: java for (long seed = 0; seed < 15000; seed++) { tier.computeIfAbsent(key, factory.createKey(key)), tiers::noExpiration); }
Seems like this is the only place where you do it? This is a sandbox change and should not fail.
Seems like this one is missing some debug output.
can we print the message here?
Minor: can we print the message here?
Minor: can we print the message the Throwable?
isfilepathObj.getStringValue("filepath") necessary?
else overwrite it.
else {
Missing code.
Missing a parameter
Missing a space
I think you'll want to set max(DEFAULT_HTTP_TIMEOUT_SEC) to _DEFAULT_HTTP_TIMEOUT_SEC + "/createEntitlementWithAddOns".
I think you'll want to set max(DEFAULT_HTTP_TIMEOUT_SEC) to _multiple_ queries here.
I think you'll want to set max(DEFAULT_HTTP_TIMEOUT_SEC) to _DEFAULT_HTTP_TIMEOUT_SEC + "-" here.
This initialDelay is not required. You may have a race condition when multiple threads are running in the same JVM.
This initialDelay is not required. You may have a race condition when multiple threads are running in parallel, but the scheduler threads are blocked. It will not be a problem since the scheduler threads are always up to date.
This initialDelay is not required. You may have a race condition when multiple threads are running in parallel, but the scheduler threads are blocked. It will not be a problem because the scheduler threads are not blocked until the JVM exits.
Is this supposed to be empty?
Is this supposed to be used anywhere else?
Is this supposed to be used anywhere?
can we have this logic to show the user the upload failed?
If we have this logic, this can be moved to the caller.
can we have this logic to show the user the information from the sink?
Not sure if this is really necessary? Here's the previous statement. I wonder if it would be better to simply use questionId instead of questionId
Not sure if this is really necessary? Here's the active question about the question in question metadata.
Not sure if this is really necessary? Here's the active question on question.
Is it really necessary to remove this? The workerState.localExecutors.stream() will do it for you.
Is it really necessary to remove this? The workerState.localExecutors.stream() will do this for you.
Is it really necessary to remove this? The workerState.localExecutors field is created for each executor, not an executor.
would probably be a bit more efficient if we do a single partition on the data table.
would probably be a bit more clear if this method is called repeatedly in future.
would probably be a bit more efficient if we do a single partition on the data.
Since this is only used here, the assertTrue statement could be simplified to assertTrue("Create folder with name \"mydir\"?");
Since this is only used here, the assertTrue statements can be removed.
Since this is only used once, feel free to remove the assertTrue statements, just like AS suggests (ArrayUtils.isEmpty is better).
entry
entry is the proper name. entry
entry is the proper name
looks like Intellij recommends Short.parseShort(idKey) instead of Short.parse(idKey)
looks like Intellij recommends Short.parseShort(idKey) instead of Short.toBoolean
looks like Intellij recommends Short.parseShort(idKey) instead of Short.toBoolean()
View#refresh_error is unchecked and could be removed
View#refresh_error is unchecked and should be removed
Aren't we want an else here?
I believe we should not be catching ServiceException. An exception only here. If we are throwing an exception, the caller should be responsible for handling these exceptions.
I believe IOException is handled.
I believe we should not be catching ServiceException. An exception only here. If we are throwing an exception, the caller should know that we failed to close the file.
We should not use bitwise operators for logical operations. Please use ==.
We should not use bitwise operators for logical operations. Please use them. In this case it is better to not use &.
ditto about &?
I think this could be just be assertThat(consumer.partitionsFor(any())).thenReturn(1L, 2L, 4L); As a result, we also have a null check on the return value of the method.
I think this could be just be assertThat(consumer.partitionsFor(any())).thenReturn(1L, 2L, 4L); As a side note, we also have a test for the null check on the first reader.
I think this could be just be assertThat(consumer.partitionsFor(any())).thenReturn(1L, 2L, 4L);
Do we really need to check that MaintenanceVdsCommand would be called MaintenanceVdsCommand or MaintenanceVdsCommand? Can't we just pass the MaintenanceVdsCommand and have the logic in MaintenanceVdsCommand?
Do we really need to check that MaintenanceVdsCommand would be called MaintenanceVdsCommand or MaintenanceVdsCommand? Can't we just pass the MaintenanceVdsCommand to that command?
Do we really need to check that MaintenanceVdsCommand would be called MaintenanceVdsCommand or MaintenanceVdsCommand? Can't we just pass the MaintenanceVdsCommand and have the logic in MaintenanceVdsCommand?
suggestion if (targetEntity.getTypeInformation().isCollectionLike()) {
I think we shouldn't need to handle Map<String, Object>
I think we shouldn't need to handle Map<String, Object> here as it is a map type only.
Can we remove "filterFunctionName" and "get filterFunctionName"?
Can we remove "filterFunctionName" and "filtered expression"?
Can we remove "filterFunctionName"?
it is not thread safe to access the field in a simple way. Share the string in our API.
it is not thread safe to access the field in a simple way. Waiting for thread safety should be much safer.
it is not thread safe to access the field in a simple way. Waiting for thread safety should be much more reliable.
Style-nit: I am not a fan of the ternary operator here. I would leave it as is.
Style-nit: I am not sure the type of ternary is necessary.
Style-nit: I am not a fan of the ternary operator here.
Make a real test out of it :-)
Make a real test out of it :-) I think that the input and data are used in different tests.
Make a real test out of it :-) I think that the input and data are used in the same test.
Should be "incorrect" here, I think
Should be "incorrect" here.
Should be "incorrect" here, right?
Extract "_sync" to a constant?
Again, the type of the parameter can be removed
Again, the type of the parameter can be removed?
since you know how many times the method is called, you should just return null
this can be private
since you know how many times the method is called, can you use a lazy-test case?
"Only read-only" -> "Only read-only"
"Only read-only access supported" -> "Only read-only"
"Only read-only access supported" -> "Only read-only"?
shouldn't this be taken out?
shouldnt this be taken out?
shouldn't this be taken care of by the user?
Is this else needed? Could you please leave it as is?
Is this else needed? Could you please leave it as is.
Always braces
Something minor: You could use ConfigValues.class.getSimpleName() instead of hard-coded class name.
Something minor: You could use ConfigValues.class.getSimpleName() instead of ConfigValues.class.getSimpleName()
Something minor: You can use ConfigValues.class.getSimpleName() instead of hard-coded class name.
minor issue, but I don't think we need to call close() explicitly for the instance.
minor issue, but I don't think this can be removed
minor issue, but I don't think this can be removed.
squash this commit into the commit message
squash this commit into the commit message and change it to commit message
squash this commit into the next commit?
This looks a bit complicated: public void copyContents() { File baseDir = new File(baseDir.toPath().resolve(configDir.getPath()); doCopy(path.resolve(Locations.CONFIGURATION), baseFile.resolve(Locations.MODULES), baseFile.resolve(Locations.MODULES)); } private static String normalize(File baseDir) { File baseDir = new File(baseDir.toPath().resolve(configDir.getPath()); doCopy(path.resolve(Locations.CONFIGURATION), baseFile.resolve(Locations.MODULES), baseFile.resolve(Locations.MODULES)); }
This looks a bit complicated: public void copyContents() { File baseDir = project.getBasedir().toPath().resolve(configDir.getPath()); doCopy(path.resolve(Locations.CONFIGURATION), baseFile.resolve(Locations.MODULES), baseFile.resolve(Locations.MODULES)); } private static String resolve(File baseDir, File File baseDir) { File baseDir = new File(baseDir.getAbsolutePath()); return baseDir.toPath().resolve(configDir.getPath()); doCopy(path.resolve(Locations.CONFIGURATION), baseFile.resolve(Locations.MODULES), baseFile.resolve(Locations.MODULES)); }
This looks a bit complicated: public void copyContents() { File baseDir = new File(baseDir.toPath().resolve(configDir.getPath()); doCopy(path.resolve(Locations.CONFIGURATION), baseFile.resolve(Locations.MODULES), baseFile.resolve(Locations.MODULES)); } private static String normalize(File baseDir) { File baseDir = new File(baseDir.toPath().resolve(configDir.getPath()); doCopy(path.resolve(Locations.CONFIGURATION), baseFile.resolve(Locations.MODULES), baseFile.resolve(Locations.MODULES)); } and.read() }
nit: let's keep the layout list as final for consistency.
nit: let's keep the layout list as final
nit: let's keep the layout list as final and use DataSize.
shouldn't azureLeaderElector.tryBecomeLeader() always return false at this point?
shouldn't azureLeaderElector.tryBecomeLeader() already return false at this point?
doesn't azureLeaderElector.tryBecomeLeader() already have a azureLeaderElector?
if (LOG.isDebugEnabled()) {... }
This should not be static.
if (LOG.isDebugEnabled()) {
There are too many meterToJsonObject() calls in the meterToJsonObject() method. I think one of them should be extracted and the other.
There are too many meterToJsonObject() calls in the meterToJsonObject() method. I think one of them should be extracted and used
There are typos.
We should iterate over favAppsList instead of manually.
We should iterate over favAppsList and read the list.
We should iterate over favAppsList instead of manually.split()
This method should not be public.
This method should not be public
Let's not change the retained size for now.
This is better as a log.debug, otherwise we will see this message every time.
This is better as a log.debug, otherwise we will see it in the future
Is this a debug message?
Maybe this can be removed now, we don't need the queue at all?
Maybe this can be removed now, we don't need to add the channel info
Maybe this can be removed now, we don't need to add the channel info.
I think it should be "21840"
I think these values should be hardcoded to the.makeSizeString wrapper.
I think it should be "21840".
Why not use return Promises.resolved(null);?
Why not use Workbench.getDisplay() here?
Why not use Workbench.getDisplay() here instead?
We don't need any wrapper here. List could be converted to a map: java Map<String, String> eventTime = IntStream.range(0, eventTime).boxed().collect(Collectors.groupingBy(eventTime, 2, Collectors.mapping(eventTime, 2, Collectors.toList()))).values().stream().collect(Collectors.toMap(eventTime, e -> e.get(0), e -> e.get(1)));
We don't need any wrapper here. List could be converted to a map: java Map<String, String> eventTime = IntStream.range(0, eventTime).boxed().collect(Collectors.groupingBy(eventTime, 2, Collectors.mapping(eventTime, 2, Collectors.toList()))).values().stream().collect(Collectors.toList())))
We don't need any wrapper here. List could be converted to a map: java Map<String, String> eventTime = IntStream.range(0, eventTime).boxed().collect(Collectors.groupingBy(eventTime, 2, Collectors.mapping(eventTime, 2, Collectors.toList()))).values().contains(eventTime);
Change the bungee field to something like limit < 0
Change the bungee field to something more meaningful
Change the bungee field to something like limit?
Blank line before and after?
Blank line before }
Blank line before and after.
Need to put this back - cannot change the API
Need to put this back - cannot change the function
Need to put this back - cannot change the function name
Could really just use StringUtils.isNotBlank(dataHolder) here.
Could really just return Optional.empty() instead.
Could really just return Optional.empty() here.
You should add a warning log also here
You should add a warning log also here.
You should add a warning logging here
downloadsMenuItem.setProgress(progressprogress) can be null and should never be null.
downloadsMenuItem.setProgress(progressprogress) can be null and can be null.
downloadsMenuItem would b a better name.
nit: can you make a private instance of this class?
nit: return row.getTimestamp();
nit: can you make a private instance variable?
rather than hardcode the string, can use the class name
rather than hardcode the variable name, can use the class name
rather than hardcode the string, can use The class name
add braces around this too
add braces around this
add braces
I think this is a too-long line, it might fail checkstyle.
I don't think this is necessary. We can just use if (isVersionCompatible()) { //... } to make it more clear what we are doing here.
I think this is a too-long line, it would be better to have a builder, StatusCode.EOK.
nit: consider super.getEstimatedSizeBytes()
nit: consider safeguards against an IOException
nit: IllegalArgumentException
static import
static import of
static import?
This could be replaced with: Iterator<Object> it = list.iterator(); it.hasNext(); ) { Object o = it.next(); if (o instanceof String) { String mediaType = (String) o; return o; } } return false;
This could be replaced by: Iterator<Object> it = list.iterator(); it.hasNext(); ) { Object o = it.next(); if (o instanceof String) { String mediaType = (String) o; return o; } } return false;
This could be replaced with: Iterator<Object> it = list.iterator(); it.hasNext(); String mediaType = it.next();
Since this is not used e.printStackTrace() I think we can let the logger to be consistent.
let's log the exception.
Since this is not used e.printStackTrace() I think we can let the logger directly be used.
initializeStateValueType instead?
initializeStateValueType instead? Or get around with IWorkbenchType
initializeStateValue
I don't think we need to check data of the command history. What do you think?
And a small nit, I'd suggest moving the condition out of the if to where it is clearer that it's doing the same thing.
And a small nit, I'd suggest moving the condition out of the if to where it is clearer where it is.
This line is too long...
This line is too long... :P
This is error message
There's a bug here (alebit; a small potential one) where expandSection returns an empty collection.
There's not needed at all.
I still don't see how this can ever be null.
Shouldn't we use a final block to make this shorter?
Shouldn't we use a final block here?
Do we need to mock channels above?
While convenient, this has a massive performance impact unfortunately. Looking at the code, we know that T extends EventEntryModelDao. I think it's fine to change the interface EventEntryModelDao to expose the setters (make sure to also add the @Override annotations in BusEventModelDao). With these setters, you shouldn't need this anymore.
While convenient, this has a massive performance impact unfortunately. Looking at the code, we know that T extends EventEntryModelDao. I think it's reasonable to change the interface EventEntryModelDao to expose the setters (make sure to also add the @Override annotations in BusEventModelDao). With these setters, you shouldn't need this anymore.
While convenient, this has a massive performance impact unfortunately. Looking at the code, we know that T extends EventEntryModelDao. I think it's fine to change the interface EventEntryModelDao to expose the setters (make sure to also add the @Override annotations in BusEventModelDao). With these setters, you shouldn't need this anymore..
I think this method should be called sortByCreatedAt, and sortByCreatedAt should not be called from outside the execute() method.
I think this method should be called sortByCreatedAt, and sortByCreatedAt should not be called from within the execute() method.
I think this method should be called sortByCreatedAt, and sortByCreatedAt should not be called from outside the loop.
File.toPath() may throw InvalidPathException. Since it doesn't catch an IOException, there's no reason to catch it.
File.toPath() may throw InvalidPathException. Since it doesn't throw an IOException, there's no reason to catch it.
File.toPath() may throw InvalidPathException. Since it's a constructor method, there is no need to catch it.
why not have java docs to explain what this does? ( why it does it in that way etc)
why not have java docs to explain what this does? ( why it does it in that way etc)?
Why not have java docs to explain what this does? ( why it does it in that way etc)
remove extra line.
remove extra line
remove extra space.
delete this line
remove this line
remove this
you can remove the surrounding brackets
you can remove the surrounding code
you can remove that
AFAIR you can use getQueue(), not getQueue(), and only get a getQueue() once.
AFAIR this is not used anymore
AFAIR you can use getQueue(), not getQueue()
Why catch here and not throw it immediately?
Why catch here and not throwing it immediately?
Why catch here and not throw it directly?
try/catch
Same for this.
Same for this assertion
it's already fixed in line 189
it's duplicated code
it's duplicated
Maybe I missed something, but AppUtils.Duration.SHORT is the right choice for this.
Maybe I missed something, but AppUtils.Duration.SHORT is the right name ;)
Maybe I missed something, but AppUtils.Duration.SHORT is the right name for this.
nit: I think you can use [AssertJ](<LINK_0> here and below
nit: I think you can use [AssertJ](<LINK_0> here
nit: I think you can use STREAMS_CONFIG.
Can this not result in loosing data? If a job is already running, a change happens and the system want to save again, would that lock not loose the new data?
Can this not result in loosing data? If a job is already scheduled with the project already running, a change happens and the system want to save again, would that lock not loose the new data?
Can this not result in loosing data? If a job is already scheduled, a change happens and the system want to save again, would that lock not loose the new data?
suggestion if (isValidRefName(fullName)) {
suggestion if (isValidRefName(fullName) ||!Strings.isEmpty()) {
Should this also be changed in the null check below, now that the syntax is used?
Collections.emptySet()
Collections.emptySet() (to reduce nesting)
Collections.emptySet() (or similar)
the token will not always be " ", sometimes it depends on ldap.accountFullName
the token will not always contain ", sometimes it depends on ldap.accountFullName
the token will not always be " ", sometimes " ", sometimes " ", sometimes "
Duplicated code, we have _zkClient = zkClient.createPersistent(MetadataStoreRoutingConstants.HOSTNAME_SYSTEM_PROPERTY_KEY, zkAddress);
Duplicated code, we have _zkClient = _zkClient.createPersistent(MetadataStoreRoutingConstants.HOSTNAME_SYSTEM_PROPERTY_KEY, channelName);
Duplicated code, we have a class that does this.
you can use a logger here. it is not really needed
you can use a logger here. it is more efficient
you can use a logger here.
We should probably be using GenotypeConcordanceState.values() in this class.
We should probably be using GenotypeConcordanceState.values() to keep all of this loop's responsibility.
We should probably be using GenotypeConcordanceState.values() to keep the copy and copy.
Use getPermanentOrLKI if no longer exists.
Use getPermanentOrLKI if no longer exists
Use getPermanentOrLKI if simpler.
no need for withCardExpiry
Im not sure why for this change, you are not using the card _expiry_, it doesn't make sense to me?
Im not sure why for this new card, you are not using the card _expiry_, right?
Doesn't.get() also return null?
Doesn't.get() also return null.
Doesn't.get() also return null if for readability?
This isn't the wrong way to call this function. It's the only thing the fragment that we want to show in and the strings. I don't think this is relevant anymore.
This line isn't necessary since the onActivityCreated() method already checks for you.
This line isn't necessary since the onActivityCreated() method already checks it.
Log the object here.
Any reason we can't just use this interface?
Log the objectID here.
Maybe add a local variable and check if it's empty
Maybe you can rename this to something like 'findGroupsGroups'
Maybe you can rename it to something like 'findGroupsGroups'
I do not think this is correct or will be handled for api calls, make sure the method is called with a null result
I do not think this is correct or will be handled for api calls, make sure the method is called with a null argument
I do not think this is correct or will be handled for api calls, make sure the method is called with a getChangeSets()
lambda?
This listener is already called in the base class, so the extension can be removed.
This listener is already called in the base class.
I know this doesn't really matter, but if you throw an exception, then the code will never be executed. The method should throw an exception.
I know this doesn't really matter, but if you throw an exception, then the code will never be executed. The method should return void.
I know this doesn't get called in this PR, but if you catch an exception, then this will be handled.
Cache
Remove empty line
Indentation must be only 2 spaces
why we need http here doesn't make sense?
why we need http here doesn't make sense?
why we use http here doesn't make sense?
Not specific to this code change, but what if the server is unreachable? Say, it returns 500 (internal service error) or 503 (service unavailable)?
Not specific to this code change, but what if the server is unreachable? Say, it returns 500 (internal service error) or 500 (internal service error) or 503 (service unavailable)?
Not specific to this code change, but what if the server is unreachable? Say, it returns 500 (internal service error) or 500 (internal service error) or 500 (internal service error)
if there are no files that are the same, this test is not reachable, right?
Do you have a test for the folder creation?
if there are no files that are the same, this test is not sufficient?
Can we use LOG.error("Unable to read {} for NHIN service {}", nhinService.toString(), name);
Can we use LOG.error("Unable to read {} for NHIN service {}", nhinService.toString(), name);?
Can we use LOG.error("msg {}", name, e);
Is it simply new MapDetails(game.getDiceFirstValue(), game.getMaxPlayers());
Is it simply new MapDetails(game.getDiceFirstValue(), game.getHexDetails())?
Is it simply new MapDetails(game.getDiceFirstValue(), game.getHexDetails().getTime())?
Can use isEmpty()
Throw a RuntimeException.
Missing check.
I wonder if it is better to use.map(SiriusInitialOperationAdapter::getInitialOperationsURI).forEach((expression) -> { expression = expression.replace("'", "\\'"); });
I wonder if it is better to use.map(SiriusInitialOperationAdapter::getInitialOperationsURI).forEach((expression) -> { expression.replace("'", "\\'); });
I wonder if it is better to use.map(SiriusInitialOperationAdapter::getInitialOperationsURI).forEach((expression) -> { expression = expression.replace("'", "\\'); });
We should use braces around the blocks.
We should use braces around the braces!
We should use braces around the braces.
Is this param necessary?
Is this :thinking:
Is this'synchronized'?
This is a cast, not sure if it works just in case.
This is a cast, not sure if it's worth rename.
This is a cast, not sure if it's worth adding a custom listener
You could save some regex in a variable and use it later.
Please save a second string in the next line.
Please save that regex in a variable and use it later.
The life cycle should be taken out of the loop, right?
The life cycle should be done before the for loop, otherwise it will wait for the next life cycle to finish.
The life cycle should be done before the for loop, otherwise it will wait for the next life cycle.
Does it make sense to put this in a constant?
Does it make sense to duplicate the stacktrace if we use try-catch-log-debug?
Does it make sense to duplicate the stacktrace if we use try-catch-log-error?
Wondering if this is ok. We shouldn't be able to call the receiveMessage() method. This is something that should be done in the PollEventEvent.
Wondering if this is ok. We shouldn't be able to use the MessageBuilder here.
Extra space after (
This doesn't look like an easy way to do.
This doesn't look like the value is used in 173/242.1?
This doesn't look like the value is used in the previous test.
I would rather return another warning ("Blank project name in the list")
I would rather return another warning ("Blank job name in the list")
I would rather return another warning _warning_ here, in case the project no longer exists.
What would happen if the chunk is empty? Suggest doing that so.
What would happen if the chunk is empty?
What would happen if the chunk is called?
Is this function supposed to be defined at the top of the class? Seems like this should be defined at the top of the class.
Is this function for anything else? Seems like this should be defined in a method.
Is this function supposed to be defined at the top of the class? Seems like this should be defined at the top.
Use else if (commitCounter > 0 && connection!= null)
Use else if (commitCounter > 0) {
Use setAutoCommit(false) otherwise the statement will be closed
Why we need enterBusy() here?
Why we need a new future?
Why we need enterBusy here?
It would be better to also log the exception.
It would be nice to have this be a SEVERE error?
It would be nice to have this be a SEVERE error, not a WARNING.
"Access Denied" is also a constant in KeycloakDeploymentBuilder.
Replace "Access Denied" with a constant in the class
"Access Denied" is also a constant in KeycloakHttpConfiguration.
Use StandardCharsets.UTF_8
Use a package-private class.
Use a package-private class to access the method.
This doesn't seem to be strient to me. If I'm correct, I'd expect it to be a getRGB() call for any(ErrorCallback.class) in many places. Maybe we could have a method in LoadContentAnswer.
This doesn't seem to be strient to me. If I'm correct, I'd expect it to be a getRGB() call for any(ErrorCallback.class) in many places. Maybe we could have a method on the interface that contains the errorCallback.
This doesn't seem to be strient to me. If I'm correct, I'd expect it to be a getRGB() call for any(ErrorCallback.class) in many places. Maybe we could have a method on the interface that contains the error callback.
Could you please clarify why these are called 'copy.fail' and'return'?
Shouldn't you be using the static method in FileUtil?
Could you please clarify why these are called 'copy.fail'?
you could probably check for null and throw an IllegalArgumentException if the response is not a legal-hold
you could probably check for null and throw an IllegalArgumentException if the response doesn't contain a legal-hold
you could probably check for null and throw an IllegalArgumentException if the response is null
_could_ you put the assert in a single line?
_checkVisitedNode_?
_could_ you put the assert in a @Before method to ensure that the expressionCounter is set correctly?
Maybe consider moving this into a finally block.
Maybe consider moving this into a finally block where you call the method instead of inside it
Maybe consider moving this into a finally block?
This is not a good way to write toString() as.collect(Collectors.joining(COMMA))
These are correct e.g., you filter out / undefined values.
This is not a good way to write toString() as.collect(Collectors.joining(...))
Shouldn't this be a warn instead of a warning?
Shouldn't this be a warn instead of a error?
Shouldn't this be a warn instead?
What was wrong with getHover()? Why couldn't you put 'getHover()' into it?
What was wrong with getHover()? Why couldn't you put 'playListenerListener' into it?
What was wrong with getHover()? Why couldn't you put 'if' into it?
Do we need getDeclaredMethod("apply" methods here?
Do we need getDeclaredMethod("apply", t)?
Do we need getDeclaredMethod("apply" in this case?
I think we should use something that has the format of the string generated here and below.
I think we should use something that has the format of the IAM link.
I think we should use something that has the format of the string generated here and reporting it the same way.
assertEquals
assertEquals()
assertEquals()?
Illegal arguments?
Illegal argument to file or other method
Illegal argument to file or other method?
@marchof I'd suggest to move this code to constant InputFullOfBlockCommentsCheck.java and use it to have more sharing like lineSeparator, line lineSeparator, etc.
@marchof I'd suggest to move this code to constant InputFullOfBlockCommentsCheck.java and reuse it on line lineSeparator.
please move this to constant
Shall give detailed error message with source/destination Db/table names.
Shall give detailed exception message with source/destination Db/table names.
Shall give detailed error message with source/destination Db/table name.
This check should be inside the loop. Otherwise, base can be null here.
This check should be inside the loop. Otherwise, base can't be null.
This check should be inside the loop.
Please remove unnecessary space before and after =
Please remove unnecessary space before and after index.
Please remove unnecessary else clause
nit: we can drop the else clause here to make the code more readable.
nit: we can drop the else clause here.
nit: we can drop the else clause here to make the statement more readable.
This is redundant now since it is already a boolean
This is redundant. We already introduced  in the value.
This is redundant now since it is already a String
@miguelaferreira The following seems a bit strange to me. Details should be: java if (results!= null) { return autoCompleter.completeByPart(constraint.toString()); } else { return new FilterResults(); }
@miguelaferreira The following seems a bit strange to me. Details should be: java if (results!= null) { return autoCompleter.completeByPart(constraint.toString()); } else { return new Filter() { @Override protected FilterResults performFiltering(CharSequence constraint) { return autoCompleter.completeByPart(constraint.toString()); } };
@miguelaferreira The following seems a bit strange to me. Details should be: java if (results!= null && results.count > 0) { return filterResults; } else { return new FilterResults(results, results.count); }
Is the JUnit test actually testing the exceptions?
Is the JUnit test actually required?
change to Exception
setErrorMessage
setErrorMessage BTW.
setErrorMessage
don't construct an exception
don't throw an exception
don't create this exception
Use AbstractQC.UNSAVED_ID instead of hard-coding it here.
Use AbstractQC.UNSAVED_ID instead of hard-coding it here. Same thing.
Use AbstractQC.UNSAVED_ID instead of hard-coding it.
Is this change needed?
This is not correct. If the URL is relative to the initial host, then this URL must be rewritten with the initial host name.
This is not correct. If the URL is relative to the initial host, then this URL must be rewritten.
This is a bit complicated, let's not use streams for this code.
This is a bit complicated, let's discuss about how to extract this logic to a method
This is a bit complicated, let's discuss about how to extract this logic to a helper method
Should this be moved to some util class?
Should this be moved to the PosixParser?
Should this be moved to the PosixParser class?
here we should go to a single test, not sure why this would have to be static
here we should go to a single test, not sure why this would have failed...
here we should go to the bottom
All hard coded strings that used as a key to get data the bundle should be declare as constant in Router.java.
All hard coded strings that used as a key to get data the bundle should be declare as constants in Router.java.
All hard coded string constants that used as a key to get data the bundle should be declare as constant in Router.java.
It seems like this could be simplified to java return Objects.requireNonNull(o, "null timestamp");
It seems like this could be a static method in Function<Object, DateTime>, to avoid duplicating the code?
It seems like this could be a static method in Function<Object, DateTime>, which would be more explicit than casting.
it's better to use [try-finally](<LINK_0> here to stop container in finally
it's better to use [try-with-resources](<LINK_0> here
it's better to use some Unicode chars in it, for better testing. for example "UTF8 <LINK_0>
this does not look right? If the stack is equal to the slot, it's shadowed.
this?
this does not look right?
Could you extract the Data error as a separate method to avoid the repetition?
Could you extract the Data error as a separate method to avoid duplication?
Could you extract the Data error as a separate method to avoid duplications?
It seems like Java Boolean value could be null. Can we make it private if possible?
It seems like Java Boolean value could be null. Can you make check for that?
It seems like Java Boolean value could be null. Can we make check for that?
There's a View::hasPermission() method
There's no need to catch Exception here. At least it's a server error, and should be logged here.
There's no need to catch Exception here. At least it's a RuntimeException.
nit - move the deceleration one line up..
add CDA here and return false, if it fails you'll end up with NPE
missing null check
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused private "check" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this if statement which always evaluates to "true" [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this unused method parameter "request". [![rule](<LINK_2>](<LINK_0>
We need to test if the table is created for this test.
We need to test if the scanner is null in this case.
We need to test has it.
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to remove it altogether, no?
Looks like the 4th parameter is no longer needed. Since the NioEventLoopGroup is no longer needed, it would be fine to remove it altogether, no?
Looks like the 4th parameter is no longer needed.
setReturnValue can be Guid? As the snapshotId is not populated apart from Id, so is there any need in returning this?
setReturnValue can be Guid? As the snapshot name is not populated apart from Id, so is there any need in returning this?
setReturnValue can be Guid? As the snapshot name is not set as a member variable.
Could you please put the FQN on same line and add a space?
Could you please put the bar on the same line and add a space?
Could you please put the bar on the same line and add a space? }
This might need to be protected as well to make it package-private.
This might be simplified to just throw AmazonServiceException(ex)
This might need to be protected as well to be consistent with Builder
Can you rename this to maxDataVolumesSupported and then add deviceId to the message?
Can you rename this to maxDataVolumesSupported and then use deviceId?
Can you add a message to the exception?
should we only on recurse here if ids is null?
should we only set the configuration if ids is null? otherwise we will retrieve this for multiple times
should we only set the configuration once?
Why don't you pass true as the consumer?
Why don't you pass true as the timeouts?
Why don't you pass true as the createResponseHandler method?
Does it make sense to wrap this into a method, even if the code changes?
Does it make sense to wrap this into a method (and maybe even create a new method) with this name?
Does it make sense to wrap this into a method, even if it is not used?
I am having a bit of an odd time to figure out why you need to iterate over the list of fertilizerMap.
I am having a bit of code duplication in this method (and the one above) of parseConfig(). I think it's needed, but this isn't an expensive method.
I am having a bit of code duplication in this method (and the one above) of parseConfig(). I think it's needed, but this isn't quite the point that you need to do more than one.
Can you change this to unit.prettyPrintTime() as well?
Can you change this to just TimeUnit.DAYS.toMillis(time)?
Can you change this to just TimeUnit.DAYS.toMillis(time)
I don't understand this branch. Why just not to create it in this case? Because this is exactly what you do outside of this method. You call takeProducer() twice (in another method) and then you call takeProducer() again.
I don't understand why you need this change?
I don't understand this branch. Why just not to create it in this case? Because this is exactly what you do outside of this method. You call takeProducer() twice (in another method) and it returns the activeProducer which is not null.
Do we need to catch this exception?
Do we need to catch this IOException?
Do we need to catch RuntimeException?
This fix is incorrect and should not be changed.
This fix is incorrect and should not be rebased on scan of the set.
This fix is incorrect and should not be re-thrown.
Should check for disposal.
Should check for the shell here
Should check for the possibility of a shell here
Does this code really do anything?
Does this code actually do anything?
Does this same logic really belong in the 'else' block?
state.replayObserverFromIndex could be moved in a separate method.
state should be always >= 0.
state should always be null.
This also needs to be called not 'null' for this class.
This also needs to be called more often than once ChannelGroup transform
This also needs to be called not 'null' as a default list
This needs to be public.
This needs to be private method.
This needs to be public and private.
Should we add an error log to indicate that the environment config is not updated?
Should we add an error log to indicate that it is not an expected one?
Should we add an error message to this request?
It seems that the queue.poll is going to be called multiple times, would it be better to make a variable and reuse it?
It seems that the queue.poll is going to be quite big (like you did with the queue.poll), but there is no value in having a big timeout. Any way to avoid that?
It seems that the queue.poll is going to be quite big (like you did with the queue.poll), but there is no value in having a big timeout. Any way to avoid this?
Should it be 'true'?
Should we add the navigator explorer?
Should be 'false'
.obf is not always true.
.obf is not always true. This can throw an exception if a tree is empty.
This is not needed.
You could get rid of the catch block and just make this method return value
You could get rid of the catch block and just make this method return void
You could get rid of the catch block and just make this method return void.
Is this line necessary? If we move this to the beginning of the method, we'll be stuck here forever.
Is this line necessary?
Is this line necessary? If we have a INVALID_SHUTDOWN_TIME, we will get NPE here and below.
is this doing something different? it seems to me that we decrease the memory footprint for the index based on the population job, since otherwise we will not be able to get there to be no issue?
is this doing something different? it seems to me that we decrease the memory footprint for the index map, since otherwise we will not be able to get quite big.
is this doing something different? it seems to me that we decrease the memory usage for population jobs, yes?
Style-nit: missing braces
Style-nit: missing braces.
missing @Override declaration.
Here too - use Integer.valueOf(0)
Please use Integer.valueOf(0)
Please use Integer.valueOf(0) instead of 0
This should probably be defined statically
This should be defined statically
This should probably be declared statically
And here you are casting, but.distinct() is not necessary?
And if we do distinct on the subject, we could use a stream.
And if we do distinct on the subject, we should also invalidate the ID on the subject.
Wth checking you can remove all of these hard-coded string.
Wth. You already have a list of teams in the original code.
Wth. You are doing a lot of work on the previous line.
Position the iteration part of the loop is going to fail faster. e.g. java assertThat(CorfuTable.getSmrStream().pos()).isEqualTo(3);
Position the iteration part of the loop is going to fail faster. e.g. java assertThat(CorfuTable.getSmrStream().pos()).isf");
Position the iteration part of the loop is going to fail faster than add another loop here.
This exception is handled properly.
This exception is handled.
This exception should be handled.
Should be an IllegalArgumentException.
Should be an else.
Should be an else statement.
Uhe, we should add all the import cases.
We can add asserts for type safety.
We can add asserts for type safety here as well.
Why do we need the null check here? Is it done in the only place where we check this?
Why does this method need to be public? It could be private.
Why does this method need to be public? It could be private
I think this can be replaced with List<Object>
I think we can use newInstance to allocate ar
I think this can be replaced with List<Object>.
Why do you need to set the task to null?
Why do you need to set this to null?
Why do you set the task to null?
You can avoid the null check here, groupingPairs.get(start) is not needed anyway.
You can avoid the null checks by groupingPairs.get(start, end)!= null condition.
You can avoid the null check here, groupingPairs.get(start) is not needed anyway
this looks like an pitfall with the new ports, the ones are fixed here also
this looks like an pitfall with the new ports, the ones are fixed
this looks like an pitfall with the new ports, the ones are fixed there
Shouldn't this be: if (fallback!= null) { deprecatedFallback = resolvePath('/' + fallback); } else { return null; }
Shouldn't this be: if (fallback!= null) { deprecatedFallback = resolvePath('/' + fallback); }
nit: could extract the code here and remove the second if? I find it a bit hard to read here.
we shouldn't make the setting of the flag conditional on autostartup
we should make the setting of the flag conditional on autostartup
we shouldn't make the flag conditional on autostartup
please reformat code
please log as well
please log formatting
as we have a race condition here, wouldn't this filtering be done once?
as we have a race condition here, wouldn't this filtering be more efficient in this case?
as we have a race condition here, wouldn't this filtering be better placed in the createPath method?
style nit: we don't use braces around single line blocks
Use ILabelProvider.getText(i) instead of e1.toString()
Use ILabelProvider in the base class. getLabel(int) is the method used below.
Please add a null check: 1. SdxClusterRequest is not enabled 2. Config is disabled
Please add a null check for this.: 1. SdxClusterRequest is not enabled 2. Config files are not enabled
Please add a null check for this. Duplicated checks
Please also set the filter to gone when there is an error (line below).
Please also set the view to gone when there is an error (line below).
Please also set the filter first.
if you're not using anything other than _embedded, you should definitely convert it to a call to jsonOutputWriter.
if you're not using anything other than _embedded, you should definitely add the name of the trackingTool as a parameter of the addLinks method.
if you're not using anything other than _embedded, you should definitely add the name of the trackingTool to the break message.
revert this string
revert this file
This string is WebApplication
This is a local, let's rename it to location
This is a local, let's rename it to location (the source location is now in the future) where we know it's a policy.
This is a local, let's rename it to location (the source location is now in the future) where we know that location is a policy.
This assertion should be in the @Transactional annotation
This assertion should be in the @Test only.
This assertion should be in the @Transactional annotation.
Can you think of adding a new method to the form called "showAllImages" and call it from the constructor?
Can you move this line to the if(!enabled) {?
Can you think of adding a new method to the form just to have it call this method from the if condition?
Could we please change this to console.print(Ansi.Color.SHORT).print(Ansi.Color.RED);
Could we please change this to console.print(Ansi.Color.SHORT).print(Ansi.Color.RED.toString());
Could we please change this to console.print(Ansi.Color.none())?
model.getGenericParams() is an expensive call, why not just model.getDynamic?
model.getGenericParams() is an expensive call (makes a List and walks the PSI tree). Please either use getDynamic(), or getDynamic.
model.getGenericParams() is an expensive call (makes a List and walks the PSI tree). Please capture the value, then use it.
A save to DB is missing here (and above in ExportDms). Please adjust ExportMetsIT to test reload from DB.
A save to DB is missing here (and above in ExportDms). Please adjust ExportMeaglogIT to test reload from DB.
A method to create a export service would be nice.
Use'return' statement instead of if/elses.
Use equals instead of returns on strings.
Use switch-case or switch-case. The return true should be first.
May I ask you the purpose to check "retry_count"?
May I ask you the purpose the "retry_count"?
May I ask you the purpose to check "retry_count"?
I see you have done a similar change in the following patch, just this one. Currently it is the same as the one in the SQL query. With this change, the SQL query in the SQL query is inside the SQL query. With this change, thenReturn the SQL query in the SQL query and from the second parameter in the SQL query. With the current change, thenReturn the SQL query in the SQL query and from the second parameter in the SQL query. With this change, thenReturn the SQL query in the SQL query and from the second parameter in the SQL query (e.g. from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_
I see you have done a similar change in the following patch, just this one. Currently it is the same as the one in the SQL query. With this change, the SQL query in the SQL query is inside the SQL query. With this change, thenReturn the SQL query in the SQL query and from the second parameter in the SQL query. With the current change, thenReturn the SQL query in the SQL query and from the second parameter in the SQL query. With this change, thenReturn the SQL query in the SQL query and from the second parameter in the SQL query (e.g. from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_line.
I see you have done a similar change in the following patch, just this one. Currently it is the same as the one in the SQL query. With this change, the SQL query in the SQL query is inside the SQL query. With this change, thenReturn the SQL query in the SQL query and from the second parameter in the SQL query. With the current change, thenReturn the SQL query in the SQL query and from the second parameter in the SQL query. With this change, thenReturn the SQL query in the SQL query and from the second parameter in the SQL query (e.g. from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_from_to_id.
I'm not sure why this is needed?
As far as I understand, locking and addition of the reference counter is hard to read.
I'm not sure why this is here.
Why should we use a transaction to update all messages?
Why should we use a transaction to save all devices at the same time?
remove
Can the above be tested too?
Can the opposite be tested too?
Can the above change to assertEquals(1, chromosome, start, fileObject.getClass()).
What about putting this into the finally clause and do try/catch again inside it where you would again log warning that the stream cannot be closed in case close throws exception. By doing this, the stream will be attempted to be closed even if reading of properties fails.
What about putting this into the finally clause and do try/catch again inside it where you would again log warning that the stream cannot be parsed in case close throws exception. By doing this, the stream will be attempted to be closed even if reading of properties fails.
What about putting this into the finally clause and do try/catch again inside it where you would again log warning that the stream cannot be closed in case close exception. By doing this, the stream will be attempted to be closed even if reading of properties fails.
The StickyHoverManager also added a filter for SWT.FocusOut, I wasn't sure why, but now I figured it out: If you move out of the tool tip but into another non-Eclipse application, the tool tip does not close. But worst, if you click or Alt-Tab to another application to make it go to the front, the tool tip remains 'always on top' and hides the other application. You have to go back to Eclipse and mouse move on it to make it go away.
The StickyHoverManager also added a filter for SWT.FocusOut, I wasn't sure why, but now I figured it out: If you move out of the tool tip but into another non-Eclipse application, the tool tip does not close. But worst, if you click or Alt-Tab to another application to make it go together, the tool tip remains 'always on top' and hides the other application. You have to go back to Eclipse and mouse move on it to make it go away.
The StickyHoverManager also added a filter for SWT.FocusOut, I wasn't sure why, but now I figured it out: If you move out of the tool tip but into another non-Eclipse application, the tool tip does not close. But worst, if you click or Alt-Tab to another application to make it go away.
I would prefer to circumvent the call to pluginRepository.getPluginInfosByKeys() and then call pluginRepository.getPluginInfosByKeys() instead of pluginRepository.getPluginInfosByKeys().
I would prefer to circumvent the call to pluginRepository.getPluginInfosByKeys() and then immediately call pluginRepository.getPluginInfosByKeys() which is called. The former.
I would rather have a finally block
I think we should use a instanceOf and assert here just to make sure the exception is thrown.
I think we should use a FunctionalTestUtils class for this test
This is not needed.
suggestion String userId = StringUtils.requireNonNull(withUser.name())?
Cannot be null userId and value properties.
Cannot be null userId?
If the InputStream fails with an exception then the try-with-resources block will not get closed. We need to read the file again when an exception is thrown.
If the InputStream fails with an exception then the try-with-resources block will not read the stream.
If an exception thrown here, the try-with-resources block will get a NPE.
This was present even before your changes but I think worth to check as touching it, would you mind to have a look? kie-wb-common-stunner-extensions/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms-client/src/main/java/org/kie/workbench/common/stunner/forms/client/widgets/FormPropertiesWidget.java:155: error: NULL_DER object diagram last assigned on line 151 could be null and is dereferenced at line 155. 153. final RenderMode renderMode = formSessionHandler.getSession() instanceof EditorSession? RenderMode.EDIT_MODE : RenderMode.READ_ONLY_MODE; 154. 155. > formsContainer.render(graphUuid, domainObject, diagramPath, (fieldName, newValue) -> { 156. try { 157. formSessionHandler.executeUpdateDomainObjectProperty(domainObject, fieldName, newValue);
This was present even before your changes but I think worth to check as touching it, would you mind to have a look? kie-wb-common-stunner-extensions/kie-wb-common-stunner-extensions/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms-client/src/main/java/org/kie/workbench/common/stunner/forms/client/widgets/FormPropertiesWidget.java:155: error: NULL_DER object diagram last assigned on line 151 could be null and is dereferenced at line 155. 153. final RenderMode renderMode = formSessionHandler.getSession() instanceof EditorSession? RenderMode.EDIT_MODE : RenderMode.READ_ONLY_MODE; 154. 155. > formsContainer.render(graphUuid, domainObject, diagramPath, (fieldName, newValue) -> { 156. try { 157. formSessionHandler.executeUpdateDomainObjectProperty(domainObject, fieldName, newValue);
This was present even before your changes but I think worth to check as touching it, would you mind to have a look? kie-wb-common-stunner-extensions/kie-wb-common-stunner-forms/kie-wb-common-stunner-forms-client/src/main/java/org/kie/workbench/common/stunner/forms/client/widgets/FormPropertiesWidget.java:155: error: NULL_DER object diagramPath = formSessionHandler.getSession() instanceof EditorSession? RenderMode.EDIT_MODE : RenderMode.READ_ONLY_MODE; 154. 155. > formsContainer.render(graphUuid, domainObject, diagramPath, (fieldName, newValue) -> { 156. try { 157. formSessionHandler.executeUpdateDomainObjectProperty(domainObject, fieldName, newValue); } catch (final Exception ex) { log(Level.SEVERE, "Something wrong happened", ex); } }
We need to execute getTokens(hPools) once it is registered to the pool.
Why are we not separate the two for loops?
Yeah, what is the purpose of this PR?
I think this should be called [Runtime.getRuntime().availableProcessors()](<LINK_0>
I think this should be called [Runtime.getRuntime().availableProcessors(), new GitThreadFactory(), false](<LINK_0>
I think this should be called [Runtime.getRuntime().availableProcessors(), new GitThreadFactory(), false)](<LINK_0>
Do not start in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a duplicate, delete it.
The verify call should be in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a duplicate, delete it.
Do not start in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a bit more complex, delete it.
I think that che.infra.kubernetes.namespace.label=false is used in many places. It may be useful to add a similar sentence to che.infra.kubernetes.namespace.label=true".
I think that che.infra.kubernetes.namespace.label=false is used in many places. It may be useful to add a similar sentence to che.infra.kubernetes.namespace.label=true.
I think that che.infra.kubernetes.namespace.label=false is used in many places. It may be useful to add a similar issue. Maybe we can create a che.label instead?
Why is this change necessary? Wouldn't it make sense to checkForCancelled in the loop?
Why is this change necessary? Wouldn't the order of the changes in this method be enough?
Why is this change necessary? Wouldn't it make sense to checkForCancelled in the PR to checkForCancelled?
We can't use a [optional](<LINK_0>,%20java.lang.String,%20java.lang.Object...)) method.
We can use [this](<LINK_0> instead.
Does this method need to be public?
As we discussed, maybe we should raise issue only at the case to be false?
As we discussed, maybe we should raise issue only if case block is not empty.
As we discussed, maybe we should raise issue only if case block is not added.
I'd extract the logic of term.substring(1) into a variable to make it more readable.
I'd extract the logic of term.substring(1) into a variable.
I'd extract the logic of term.substring(1) into a variable
It should be added such check.
It should be renamed to isWhitespaceBeforeAsterisk
It should be renamed to isWhitespaceAfterAsterisk
would be nice to move this error message to InformNoToolHandler and use its message in the error message
would be nice to move this error message to InformNoToolHandler.java
would be nice to move this error message to InformNoToolHandler
I don't see where it is used
I don't see where it's used
Missing final
Should be a null check?
Should this be included in the PR?
Should be: suggestion if (series == null) {
I am not going to fight about this but I would like to wrap it into a private static method. something like: java private static void removeOperation(final List<TimerEntry> queue) { if (trackTime == null) { return; } final List<TimerEntry> queue = TIMER_ENTRIES.get(); if (result == null) { queue.remove(); } else { queue.peek().inNestedOperations += delta; } }
I am not going to fight about this but I would like to wrap it into a private static method. something like: java private static void removeOperation(final List<TimerEntry> queue) { if (trackTime == null) { return; } final List<TimerEntry> queue = TIMER_ENTRIES.get(); if (result == null) { queue.peek().inNestedOperations += delta; } }
I am not going to fight about this but I would like to wrap it into a private static method. something like: java private static void addConcurrentOperations(final long queue) { if (trackTime == null) { return; } final List<TimerEntry> queue = TIMER_ENTRIES.get(); if (result == null) { queue.peek().inNestedOperations += delta; } }
suggestion "If Username or Password is null"
suggestion "If Username or Password is null");
suggestion if (userName == null) {
can declare private final
Please declare private final
can using return here
You have the same problem: use Object.class.isAssignableFrom(object) instead of Object.class, the type is not adaptable to the object.
You have the same problem: use Object.class.isAssignableFrom(o) instead of Object.class, the type is not adaptable to T.
You have the same problem: use Object.class.isAssignableFrom(o) instead of Object.class, the type is not adaptable to the object.
Why do you need to take the chance of the Seek class here?
Why do you need to take the chance of the SeekE again?
Why do you need to take the chance of the Seek class here? This would be enough to ensure that the caching was taken.
Can't we extract these duplicate intent.putExtra and startActivity(intent) to outside the if-else? (line 101,102 and 115,116)
Can't we extract these duplicate intent.putExtra and startActivity(intent) into outside the if-else? (line 101,102 and 115,116)
Can't we extract this duplicate intent.putExtra and startActivity(intent) to outside the if-else? (line 101,102 and 115,116)
Why did you add this deleteOnExit if you call tempFile.delete()?
s/exists/try
Restore this file to final
I'm not sure if this is the right place for this. createFromPrintfStyle returns a StringFormat with no arguments, so we should throw an exception when it is not a StringFormat. Either the StringFormat should return Optional.empty() in such case, or this logic should be updated.
I'm not sure if this is the right place for this. createFromPrintfStyle returns a StringFormat with no arguments. Either the StringFormat should return Optional.empty() in such case, or StringFormat.createFromPrintfStyle returns a StringFormat with no arguments.
I'm not sure if this is the right place for this. createFromPrintfStyle returns a StringFormat with no arguments, so we should throw an exception when it is not a StringFormat.
I think the update should be done before runVdsCommand
I think the update should be executed before runVdsCommand
why updating this stored procedure?
Is it possible to simplify this logic with a super as follows? java final String[] tokens = lineTokens[0].isEmpty() && tokens[0].charAt(0) == '@'? tokens[0].substring(1, tsEnd); tokens[0] = tokens[0].substring(1, tsEnd);
Is it possible to simplify this logic with a super as follows? java final String[] tokens = lineTokens[0].isEmpty() && tokens[0].charAt(0) == '@'? tokens[0].substring(1, tsEnd); tokens[0] = tokens[0].substring(0, tsEnd + 1);
Is it possible to declare this as a super class constructor?
Isn't it left unused?
Isn't this left unused?
Irrelevant change I'll do this?
I think we need to verify that it's not called more than once.
I think you need to verify that it's not called more than once.
I think we need to verify that it's not called more than once?
Remove the extra parenthesis
Remove the extra brackets
Remove the extra parentheses
If you want to make sure that there is no project in the beginning of the test (test class) you can use CleanWorkplace requirement instead of calling after method which does the same in other way.
If you want to make sure that there is no project in the beginning of the test (test class) you may use CleanWorkplace requirement instead of calling after method which does the same in other way.
If you want to make sure that there is no project in the beginning of the test (test class) you can use CDIProjectWizard.create(PROJECT_NAME, CDIProjectWizard.class);
This is not good. Add a @Override
This seems unneeded
why not use It?
Is this test just for working with dds?
I don't think it's worth the effort of having a test that verifies the payment is not available.
I don't think it's worth the effort of having a separate test that verifies the payment is not available.
I like that put if (segment!= null &&!hasEntry.canExpire() &&!hasEntry.isExpired(timeService.wallClockTime())))
I like that put if (segment!= null &&!oldEntry.canExpire() &&!timeService.hasExpired(timeService.wallClockTime())))
I like that put if (segment!= null &&!oldEntry.canExpire() &&!timeService.containsKey(timeService.wallClockTime())))
Better to use @Test(expected = NullPointerException.class) and then you won't have to worry about whether the default is null.
You probably should be able to use modifiersField.set(null, value); instead, and then this test wouldn't be applied.
As mentioned, this should be removed.
"... subprocedure pid {}.."?
"... subprocedure pid=..."?
"... subprocedure instances..."
I don't think it's needed to fetch the Vm at this point
I don't think it's needed
this can be a template method
I would remove the variableInstanceLogIDComparator from the if statements since we already pass the variable to the function and the while loop changed.
I would remove the variableInstanceLogIDComparator from the if statements since we already pass the variableId as a parameter to the function and the while loop changed.
I would add this condition before the if
yes, this is the purpose of the PR.
yes, this is the purpose of the PR. The fix is useful.
yes, this is the purpose of the PR, but the message is misleading.
What happens when configSetter is null?
What is the reason for this change?
What happens when we have a file or memory buffer?
It feels like we should have a bnd.info file.
It feels like a perfect place to put braces to the if/else as we are not using braces.
It feels like we should have a bnd.info file in it.
i think it is better to move this to a separate method because it is almost identical to the one in the file.
i think it is better to move this to a separate method because it is almost identical to the one in findTest.
i think it is better to move this to a separate method because it is almost identical to the one in findFile.
InsertObject?
InsertObject or DebuggerObject?
InsertObject or WhenClass?
I forgot to mention in the other review: It's always good to call into a method. See other status as an example.
I forgot to mention in the other review: It's always good to call into a null pointer instead of making it an empty string. See other status as an example.
I forgot to mention in the other review: It's always good to call into a null pointer instead of making it an instance of DataSegment. See other status as an example.
better use isEmpty()?
better to use isEmpty()
better use isEmpty()
This will not work for very large vaults. Please add a method to guard such that we never call this method.
This will not work for very large vaults. Please add a retry-able message to the log statement.
This will not work for very large vaults. Please add a method to guard such that this span can be used.
Call this indeterminate maybe?
Call me a bit more readable: java if (result) { return i + 1; } else { return 0; }
Call me a bit sad.
You can get the performance improvement and simplify this method with a single return statement
You can get the performance improvement and simplify this method with a single return statement.
Is this a safeguard?
It would be handy to have severe logging here. (also in the PR description if it is an ERROR level.)
It would be handy to have severe logging here. (also in the PR description if it's an ERROR level)
It would be handy to have severe logging here. (also in the PR)
We could also try to use the icon theme here, for instance the user icon.
We could also try to use the icon theme here, for instance the default icon.
We could also try to use the icon theme here, for instance the image theme.
Please use StringUtils.format() rather than string concatenation, because it's a constant
Please use StringUtils.format() rather than string concatenation, because it will be faster,
This is a good sample class...
I don't see this being used anywhere. If an exception is thrown, the callable is not required
I don't see this being used anywhere. If an exception is thrown, the callable is not required.
I don't see this being used anywhere else.
This should not be making this public.
This should not be necessary if we have the marker from the outside
This should not be making this public
Should this be addTable(tableName, table) so it can be skipped?
Should this be addTable(...)?
Should this be addTable(tableName)?
should this method be private?
should this be warn?
should it be warn?
Can we combine these two if statements into one? java if (keyClass instanceof Class) { Class keyClass = (Class)keyType; Class valueClass = (Class) valueClass;...
Can we combine these two if statements into one? java if (keyClass instanceof Class) { Class keyClass = (Class) keyType; Class valueClass = (Class) valueClass;...
Can we add some safety here? suggestion if (keyClass instanceof Class) { //... }
log4jConfig too
log4jConfig is really intended to be null.
log4jConfig too?
This is a bit hard to follow. How about the following? java if (!HiveSessionProperties.isParquetOptimizedWriterEnabled(session)) { return Optional.empty(); }
This is a bit hard to follow. How about we drop the map out and only do the filter out column names?
This is a bit hard to follow. How about the following? java if (!HiveSessionProperties.isParquetOptimizedWriterEnabled(session)) return Optional.empty();
Seems to match the return of false asserted a few lines above this one
Sounds ok to me that the outcome matches the false return
Seems to match the return of false asserted a few lines below this one
Use CalciteUtils.getArgList()
Use CalciteUtils.getArgList() instead of new String()
Use stream api here?
This is interesting that the timeout is in the beginning of the test. I have two options: 1. Failure message: fail("The timeout wasn't applied to inner strategies."); 2. Failure message: fail("The timeout wasn't apply to inner strategies.");
This is interesting that the timeout is in the beginning of the test. I have two options: 1. Failure message: fail("The timeout wasn't applied to inner strategies."); 2. Failure message: fail("The timeout wasn't applied to inner strategies.");
This is interesting that the timeout is in the beginning of the test.
this.nsHandler = new MultilineParser(buffer)
this.nsHandler = new MultilineParser()
this.nsHandler = new MultilineParser() now
If GENERAL_TESTS is not set, then the DEVICE_TESTS will not be set.
If it is not defined, then the method can return void.
If it is not defined, then the method can be simplified.
I don't think it's safe to change this. We can return a Mono<Instant> as the response is a Flux<Instant>. This returns a Mono<Instant> which we can then return.
I don't think it's safe to change this. We can return a Mono<Instant> as the response is such a ReactorSession.
I don't think it's safe to change this. We can return a Mono<Instant> as the response is a Flux<Instant>. This returns a Mono<Instant> which we can then return a mono instead.
I think you could use logger.debug here.
I wonder if it would be better to do something like this instead of in general FrontChannelLogoutRequest?
I think you should use logger.debug here.
Would it be better to do: if (occurrence!= null &&!healthMapLocation.getAlerts().isEmpty()) { //... }
Would it be better to do: if (occurrence!= null &&!healthMapLocation.getAlerts()!= null) { //... }
In my opinion, we should be able to do: if (occurrence!= null &&!healthMapLocation.getAlerts().isEmpty()) {
same here, don't need to set the value to 'true'
same here, don't need to set the value.
same here, don't need to set the value to CLUSTER_RATE
Change this to an error?
Change this to an error level
Change this to an error and return the exception
I just noticed an error in one of my PR, it needs to be if (inexactSeek && selectedDuration / (int) DateUtils.SECOND_IN_MILLIS % 10 == 5) { Otherwise the seek durations get rounded up when opening the settings, even if inexact seek is disabled
I just noticed an error in one of my PR, it needs to be if (inexactSeek && selectedDuration / (int) DateUtils.SECOND_IN_MILLIS % 10 == 5) { Otherwise the seek durations get rounded down when opening the settings, even if inexact seek is disabled
I just noticed an error in one of my PR, it needs to be if (inexactSeek && selectedDuration / (int) DateUtils.SECOND_IN_MILLIS % 10 == 5) { Otherwise the seek durations get rounded up when opening the preference, even if inexact seek is disabled
My understanding is that when you start using the system to get the ID of the revision, the build.getProject() should be null. This is why you get it from the URL of the Url, but not from the URL to the build from
+ on newline to remove //NON-NLS-1
+ on newline to pass checkstyle
It may be better to check if the directory is actually a DDB path and throw an exception if it is not.
It may be better to check if the directory is actually a DDB path and throw an exception here.
It may be better to check if the directory is actually a child of the given directory.
Can we avoid using [table](<LINK_0> here?
Can we use LOG.error here?
Can we avoid using [table.length](<LINK_0>?
since accountNumber is an anchor, there is a lot of code copied here; would it be cleaner to move it to a common method instead of having two separate isSuccessful variables?
since accountNumber is an anchor, if you are not using it, why are you changing this line?
since accountNumber is an anchor, there is a lot of code copied here; would it be possible to move it to an else statement of this if() to make it easier to read?
Consider returning a 404 instead, so that it's more obvious what's going on if the machine doesn't exist or not.
Consider returning a 404 instead, so that it's more obvious what's going on.
Consider returning a 404 instead, so that it's more obvious what's going on if the machine doesn't exist, but it can be misleading.
We are using static methods for getting the schema field. Could you make it a static method?
We are using static methods for getting the schema field. Could you remove it?
We are using static methods for getting the schema field. Could you remove it, since the static methods are already deprecated?
This is not thread safe. But instead it should be better to do this in a constructor
This is not thread safe. But instead it should be better to do this in a separate thread
This is not thread safe. But instead it should be better to do this in a constructor or factory method.
Can we use TestUtils.assertFuture instead?
Can we use the final technique here?
Can we use TestUtils.assertFutureThrows?
This should be called after KafkaRecordSupplier.addConsumerPropertiesFromConfig
I think this should be called after KafkaRecordSupplier.addConsumerPropertiesFromConfig
You should be able to set the context classloader as a parameter instead of this?
This is the cause of RuntimeException, too. There is a reason to throw RuntimeException with this change.
This is the cause of RuntimeException, if you throw a specific exception, we should throw a runtime exception to this method.
This is the cause of RuntimeException, if you throw a specific exception, we should throw a runtime exception to this method. Use RuntimeException with the message and the stack trace.
Do we need the else if block here? java if (stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key), mergeFunc); else if (stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key), mergeFunc);
Do we need the else if block here? java if (stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key), mergeFunc); else if (stats2.containsKey(key) && stats2.containsKey(key), mergeFunc);
Do we need the else if block here? java if (stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key) && stats1.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key) && stats1.containsKey(key) && stats2.containsKey(key), mergeFunc); else if (stats2.containsKey(key) && stats1.containsKey(key), mergeFunc);
How can we get here if exception is thrown from initForCache()?
What will happen if exception is thrown here?
WDYT about this catch to reduce nesting?
Would be nice to also include the key in the error message.
Would be nice to also log this warning.
I would also return something like " ls-files\{ blah} or s3.list(tmp)"
Why do you need to check for null here, since getRouteStartPoint never returns a result?
Why do you need to check for null here, since getRouteStartPoint never returns a BlackboardArtifact? I feel like it should just be getRouteStartPoint(artifact) or even getRouteEndPoint.
Why do you need to check for null here, since getRouteStartPoint never returns a BlackboardArtifact? I used to determine that the GTFS Curator is a real item, so I could just do the following: * getRouteStartPoint(artifact) *..
@Restricted(DoNotUse.class)
@Restricted(DoNotUse.class) looks like a bad idea.
@Restricted(DoNotUse.class) is a better option in this case.
It seems like this should be a switch statement with an if (SAMRecord.NO_ALIGNMENT_REFERENCE_NAME) {... } else {
It seems like this should be a switch statement with an enum.
It seems like this should be a switch statement with an else statement on line 185.
perhaps this can be moved to the top; the collection itself is not useful.
perhaps this should be in an else if
perhaps this is not the right place to add the null check
use getPermanentOrLKIBattlefield instead
Use getPermanentOrLKIBattlefield instead
use getPermanentOrLKIBattlefield(source) instead
I think that if state is null we will get a NPE. It seems that this check is redundant.
I think that if state is null we will get a NPE. It seems that we have to check other places in the code.
I think that we could simplify this log.
not sure if this is correct. i think this will not work for theVariableIdentifierTree which is not in the VARIABLE_IDENTIFIER and not in the SUSPICIOUS_ARRAY_ACCESSES, you will get issue only on the end of the class, which is also wrong.
not sure if this is correct. i think this will not work for theVariableIdentifierTree which is not in the VARIABLE_IDENTIFIER and not in the SUSPICIOUS_ARRAY_ACCESSES, you will get issue only on the end of the class, which is not correct.
not sure if this is correct. i think this will not work for theVariableIdentifierTree which is not in the VARIABLE_IDENTIFIER and not in the index.
Is this change required?
Is this a bug?
Is there a reason to set the partition count repeatedly?
What happens if the buffer is not a byte array?
What if the buffer is not a byte array?
What about UnsupportedOperationException instead of a generic Buffer subclass?
|| not &&? is this even a requirement to make codependent?
|| not &&? is this even a requirement to make cohesive?
|| not &&? is this even a requirement to make cohesive?
Is forceWrite called times?
Is forceWrite called twice?
Couldn't this be configurable?
nit: this can be a method reference
nit: this should be a method reference
nit: this can be a bit shorter java
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "evts" is 11 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "evts" is 13 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "evts" is 12 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
Why not use action.getAlgorithm()?
magic constant
Why would the action string be null here?
Change isIncrementalHandoffEnabled to isIncrementalHandoffPeriod.
Change isIncrementalHandoffEnabled to be in the KafkaSupervisor.
Change isIncrementalHandoffEnabled to isIncrementalHandoffPeriod
Isn't this the default return type?
Isn't this just "enableRemote".
Why is this necessary?
if it is all the same, move the switch up into a function? Just more readable.
if it is all the same, move the switch into a function? Just to make sure this is really the only case.
if it is all the same, move the switch up into a function? Just to make sure this is really the only case.
3 * 1.
3 *..
2 * 1. And possibly more.
suggestion: how about extracting this into a method as exact code is being invoked twice and probably once VM.customProperties will be modified from String to Map it would be handy there as well?
suggestion: how about extracting this into a separate method as exact code is being invoked twice and probably once VM.customProperties will be modified from String to Map it would be handy there as well?
suggestion: how about extracting this into a helper method as exact code is being invoked twice and probably once VM.customProperties will be modified from String to Map it would be handy there as well?
Can this be a bit simplified to: if (ulimit instanceof Map) {... } else if (ulimit instanceof Map) {... } else {... }
Can this be a bit simplified to: if (ulimit instanceof List) {... } else if (ulimit instanceof Map) {... } else {... }
ret and ret are all used like if (ulimit instanceof Iterable) {... } else if (ulimit instanceof Map) {... } else {... }
No need to declare it here
No line in this method
No need to declare it here.
The indentation is a bit confusing here, it'd be nice if the overrides were shifter to the right past the first column of the new AuthorizationEntity line
The indentation is a bit confusing here, it'd be nice if you bucket the new AuthorizationEntity line
The indentation is a bit confusing here, it'd be nice if you have a overrides on IAuthorizationPlugin instead of just with the same name.
One concern here is that we might have a race condition between line 55 and line 62.
One concern here is that if we have a thread that is stop, we're still waiting for the node to be stop. Did you mean to do it?
One concern here is that if we have a thread that is stop, we're still waiting for the node to be stop. Did you mean to do that?
Why is this needed?
Why are we adding this else?
Why are we adding this extra code?
Missing final
Shouldn't be necessary.
Shouldn't be this.
Add a verifyUnaccessibleWithoutAdmin to verifyAccessibleForAdminToMasqueradeAsInstructor(submissionParams));
Add a verifyUnaccessibleWithoutAdmin to verifyAccessibleForAdminToMasqueradeAsInstructor(submissionParams);
Add a space between if and (
missing braces
missing brackets
missing { and }
This should be a warn. Even though we're going to retry and everything might possibly be recovered, it is important for sysadmins to know that a failure happened.
This should be a warn. Even though we're going to retry and everything might be recovered, it is important for sysadmins to know that a failure happened.
This should be a warn. Even though we're going to retry and everything might possibly be recovered, it is important for sysadmins to know that a failure occurred.
The new method should be added through the passwordHistoryRepository.
The new method should be accessible by all clients.
The new method should be added through the properties file.
The return type should be ICPPFunctionTemplate.
This test should be split into two tests, one for each test and another for the AST.
This test should be split into two tests, one for each test and another for the AST, correct?
use setLastCommand(Object)
use setLastCommand(null)
use log4j
Should be setItem(available, fill); not done outside of the if-else
Should be setItem(available, fill); not done outside of the else branch
Should be setItem(available, fill); not done.
suggestion SPF.optional( SPF.token("topicFormatName", SPF.token("v"), SPF.token("user")) )
suggestion SPF.optional( SPF.token("topicFormatName", SPF.token("v"), SPF.token("icon") ) )
suggestion SPF.optional( SPF.token("topicFormatName", SPF.token("v"), SPF.token("icon") ) );
Unnecessary log.
Unnecessary log message.
Unnecessary log line
finals
finals?
final methods
Style-nit: We don't use braces around single line blocks
Don't use braces around single line blocks
Style-nit: We don't put braces around single line blocks
Should we add this to the "else" clause, as well?
Should we add this to the "user" as well?
Should we add this to the tenantedUserNameUtils since it's used twice?
Instead of relying on close bytes, you can just use closer.register(this::new).
Instead of relying on close bytes, you can just use closer.register(this::close);
add a space after IOException
Shall we move this to WebmrsUtil?
Shall we just return here?
Shall we move this to UIUtils?
Is this a little bit too big? Can't we create a method in SimpleBaseChannel which will only ever return a non-null value?
Is this a bit too big? Can't we create a method in SimpleObjectCreationTimeoutException or is it better to have this return type in the caller?
Is this a bit too big? Can't we create a method in SimpleBaseChannel which will only ever return a non-null value?
ExistingEntityException is thrown, isn't it?
ExistingEntityException is thrown, isn't this an UnknownEntityException?
ExistingEntityException is thrown, isn't an UnknownEntityException a more valid choice?
Hopefully this does not happen often.
Hopefully this does not happen a often.
Hopefully we can do this?
can we add the exception to the log statement to make it easier to debug the problem?
Let's add the exception to the log statement to make it easier to debug the problem.
Can we add the exception to the log statement to make it easier to debug the problem?
Why downcast to boolean? That makes it easier to read.
Why you causes this to be false?
Really you want to pass this to the compileSync. Can you expose this as a static method?
nit: runTime -> runtime
nit: runTime -> worker
nit: runTime
I think it would be better to create a hidden class for the file extension, since it is stored in the file name. In this case, it is not necessary to have a file extension.
I think it would be better to create a File instance once and reuse it once. That way the file is closed once, and is not created again.
I think it would be better to create a hidden class for the file extension, since it is stored in the file name. In this case, it is not necessary to have a file name.
Can we move this to the outside the if statement? If so, then it is too late to call this method.
Can we move this to line 349?
Can we move this to line 390
maybe use the logger
maybe use the logger?
maybe use the parameterized logging??
I guess this should never happen in theory
hello?
suggestion
Better use file.getFilePath()
Better to use file.getFilePath()
Better use file.getRemotePath()
will users == null be perform if (users == null)?
will users.isEmpty()?
will it test if I understand the purpose of more code or less?
This could be isEmpty()
I don't think this line is necessary. Line 93 should already contain a set of CloudInfoProcessorName or CloudInfoSources.
This could be simplified to isEmpty()
Should be logged in the start() method
Should be logged in the start() method.
Should be logged in the start/stop
you can use lamdas here too.
you can use lamdas too.
you can use l.m here too.
Why are we adding a new constructor to this class instead of making it public?
Why are we showing the "this" icon?
Why are we adding a new constructor to this class instead of making it public?
Nit: this could be a constant, and reused in the other classes.
Nit: this could be a constant, rather than being hardcoded here.
Nit: this could be a constant, and at the same time use VanillaVersion.
@prahladyeri We can declare this in the void visit method as well.
@prahladyeri We can declare this in the interface here.
@prahladyeri We can declare this in the class as well.
Shouldn't the x be > scientific?
Shouldn't the consumer of the subscribeOn be the same?
Shouldn't the condition be the scientific JB / version?
I can't help but feel that there is a better way to format these than adding if/else statements everywhere and concatenating the string inside those blocks. Personally, I would: * Add a hasMuteReason method to UserData which does getMuteReason().
I can't help but feel that there is a better way to format these than adding if/else statements everywhere and concatenating the string inside those blocks. Personally, I would: * Add a hasMuteReason method to UserData which does getMuteReason().getMuteReason().
I can't help but feel that there is a better way to format these than adding if/else statements everywhere and concatenating the string inside those blocks. Personally, I would: * Add a hasMuteReason method to UserData which does getMuteReason(). * Use a ternary operator when concatenating the message and its contents.
Suggest extracting a method for extracting an inner class (ex: @Test(expected = IllegalArgumentException.class)
Suggest extracting a method for extracting an inner class (ex: @Test(expected = HttpMalformedHeaderException.class)
Suggest extracting a method for extracting an inner class (IHTTPSession session) to reduce duplicated code.
You should check if MANUAL is required to make it work
You should check if session is enabled before trying to call it again.
You should check if MANUAL is required to make it more explicit about the error message. For example, it would be something like "Should have failed i.e."
any chance to split it into two lines?
This method could be private.
final
I think it's better to use the [Guava syntax](<LINK_0> here.
I think it's better to use the constructor of ooKeeper.
I think it's better to use the [String constructor](<LINK_0> here.
I think we should also log the exception.
I think we should also log the exception. Otherwise the stack trace might be printed twice.
I think this method should be called getBasePodURI. I know this is not public API, but it should be changed in the future.
Another way to do this - would be to set the isGlusterCliBasedSchedulingOn flag to true whenever metavolume deletion is detected. This way you can avoid calling it twice. The current way, it is getting called for every online volume!
Another way to do this - would be to set the isGlusterCliBasedSchedulingOn flag to true whenever metavolume deletion is detected. This way you can avoid calling it for every online volume!
Will it create a new lock for all 5 minutes?.
Let's call it _ ;-)
You probably want to call the method 'createDisplayPreview()' in this line
You probably want to call the method 'createDisplayPreview()' here
i think we can simplify this to tokens.length > 1? tokens.length : 1? tokens[1] : ""; if(url.replaceFirst(path, replacement)) { url = url.replaceFirst(path, replacement); }
i think we can simplify this to tokens.length > 1? tokens[1] : ""; if(url.replaceFirst(path, replacement)) { url = url.replaceFirst(path, replacement); }
i think we can simplify this to tokens.length > 1? tokens.length : 1? tokens[1] : ""; if (url.replaceFirst(path, replacement)) { url = url.replaceFirst(path, replacement); }
Maybe it's more personal taste, but it's very hard to read the code a bit e.g. java List<Map.Entry<String, RubricRecipientStatistics>> recipientToRecipientStatistics = responses.stream().map(response -> new RubricRecipientStatistics(response.recipient, FeedbackSessionResultsBundle.class));
Maybe it's more personal taste, but it's very hard to read the code a bit e.g. java int recipientToRecipientStatistics = responses.stream().map(response -> new RubricRecipientStatistics(response.recipient, FeedbackSessionResultsBundle.class));
Maybe it's more personal taste, but it's very hard to read as it is.
This change is good.
This change is unnecessary.
I think this change is good.
Unused code.
Unused code. Also, consider deleting
Unused line
Fix the error message, has data structure defined in this method
make this method final
Fix the error message, has data structure defined in this method.
exception, so STDERR
Unnecessary, the first arg should be removed
import, ()
Do we need to make this a Utils.newThread?
Do we need to make this an option?
Do we need to make this a string resource for the timer?
Same as above in the method
Same as above in the method.
Strings.nullToEmpty(state)
There is no synchronization on request.requestSent. So it is not removed from the queue. Can you confirm?
There is no synchronization on request.requestSent. So it is not removed from the queue. Can you explain this?
nit: why are we removing here?
Perhaps consider adding the connectionParameters.getConnectionParameters() to the log statement, so that we have an idea how to handle it
Perhaps consider adding the connectionParameters.getConnectionParameters() into the log.info()?
Note that all the messages in this file are sent the connection parameters, rather than the first parameter of the method.
> initInstallers(originalConfig.getInstallers(), installerRegistry); [](start = 21, length = 1.
> initInstallers(originalConfig.getInstallers(), installerRegistry); [](start = 51, length = 1.
> initInstallers(originalConfig.getInstallers(), installerRegistry); line can be removed
What is the journal for?
What is the journal to use?
What is the value of this variable?
Use a list instead of referencing an existing reference.
Use a filter instead?
Use a list instead of false
It would be a bit faster to sample before applying the map.
It would be a little faster to sample before applying the map.
It would be a bit easier to sample before applying the map.
the Bundle could be null here.
The "this" here is good, but it has to be updated to null instead.
the Bundle could return null
I think this will be the source of the failures as the initial capacity will be 100x bigger than the max size of the cache.
I think this will be the source of the failures as the initial capacity will be 100x bigger than the default.
I think this will be the source of the build failure.
Log message should get cleaned up to remove braces.
Log message should get cleaned up to remove space.
Log message can be removed.
For a clearer way to do this, something like this: java T peek() throws IOException { for (int i = 0; i < end; i++) { subList.add(iterator.next()); } } Then the method becomes: java public abstract T peek() throws IOException { return peek(this); }
For a clearer way to do this, something like T peek(int value)
For a clearer way to do this, something like T peek(int start, int max)
nit: I would prefer a static constant for empty schema names.
nit: I would prefer a static constant over a public static final String with an empty string
nit: I would prefer a static constant over a public static final ArrayList
Can you remove the try/catch and merge with @Test( void testUnDeployDataSource( dataSourceDef ) )
Can you remove the try/catch and merge with @Test( void testUnDeployDataSource( dataSourceDef ) );
Can you remove the try/catch and merge with @Test(expected=IllegalStateException.class)
This should be startsWith
This should be startsWith.
This should be private.
We should create a separate, generic class for this execution, since the body of the method is always the same.
We should create a separate, generic function for this execution, since the body of the method is always the same.
We should create a separate, generic boolean expression for this execution, since the body of the method is always the same.
Why we need to set _clusterEventType.PeriodicalRebalance to _clusterEventType?
Why we need to set HelixCache here?
Why do we need to set HelixCache here?
Should be >= and not >=
Should be better to check if number is too big.
Should be >= and not >=.
log.info("Closed clean and recycled state", maybe?
I think this should be log.info("Closed clean and recycled state", pos);
I think this should be log.info("Closed clean and recycled state", e);
Maybe catch the IllegalArgumentException here?
Maybe catch an exception here?
Maybe use a lambda and a join here?
In general, try to prefer: model.isSetSsh() && model.getSsh().isSetSsh()
In general, try to prefer: model.isSetSsh() && model.getSsh().getPort()!= null
In general, try to prefer: model.isSetSsh() && model.getSsh().isSetPort()
no need for this change
does this do anything?
no need for the continue statement
This check can be billingDate!= null
This check can be billingDate == null
This check can be billingDate == null.
If we don't find a manager that can be used within this class, we should just initialize it in the constructor and let it be null
If we don't find a manager that can be used within this class, we should just initialize it in the constructor and let it initialize it in the constructor.
If we don't find a manager that can be used within this class, then we should just initialize it in the constructor and let it be null
Why is this empty if there is no spaces in the tree?
this trimTrailingWhitespaces() is redundant, because you do not have to use isWhitespace for the first element.
this trimTrailingWhitespaces() is redundant, because you will match the endIdx in a loop in the loop.
I'd rather add something like.setShouldReject(false).
I'd rather add something like.setShouldReject(false)..setShouldShowNotification(true)
I'd rather add something like this to lift into the for loop.
The constructor for Date(current - PROCESS_INSTANCE_AGE_LIMIT_SECONDS.get() * SECOND_MILLIS); can be replaced with new Date(current - PROCESS_INSTANCE_AGE_LIMIT_SECONDS.get() * SECOND_MILLIS);
Instead of having a create Date(), just use new Date(current - PROCESS_INSTANCE_AGE_LIMIT_SECONDS.get() * SECOND_MILLIS) (create Date(current - PROCESS_INSTANCE_AGE_LIMIT_SECONDS.get() * SECOND_MILLIS), just having a final static ARBIT_PREFIX = new Date(current - PROCESS_INSTANCE_AGE_LIMIT_SECONDS.get() * SECOND_MILLIS);
Instead of having a create Date(), just use new Date(current - PROCESS_INSTANCE_AGE_LIMIT_SECONDS.get() * SECOND_MILLIS);
Wondering why we need to use a servlet here. Isn't that just the one central part of the servlet container?
Wondering why we need to use a servlet here. Isn't that just the one central one?
Wondering why we need to use a servlet here. Isn't that just the one central place you want to pass in the servlet container?
It might be better to have this part in a no-args constructor
It might be better to have this part in a no-op function and also check the original type.
It might be better to have this part in a no-op function and also update the callbacks to the Proxy.
Any reason why the logic here is different than for userData just above?
Any reason why the logic here is different from for userData just above?
Any reason why the logic here is different from "org.apache.commons.lang.StringUtils"?
If you do the check earlier, you could do it earlier and if condition.
If you do the check earlier, you could do it earlier and if (index < polygon.numInteriorRing()) { }
If you do the check earlier, you could do it earlier and if (!index < polygon.numInteriorRing()) { }
Can you please remove this logging statement?
Can you please remove this logging output?
Can you please remove this logging statement, it is not necessary.
same here, why are you making a change to the test?
nit: considering using just 1 user?
same here, why are you making a change to every zk server?
Hadn't noticed before now, but would you be willing to update this to pass in the AgentPrincipals variable, rather than having the method here?
Hadn't noticed before now, but would you be willing to update this to pass in the AgentPrincipals variable, rather than having the variable here?
Have you decided to handle this exception?
The warning should be logged at warn level (we use our own mechanism, not for internal rules).
These messages should really be logged at a higher level, not info.
The warning should be logged at warn level.
minor: I noticed AmbryDataNode.getHostname() will print out DataNode, so you can remove this.
minor: I noticed AmbryDataNode.getHostname() will print out DataNode, so you can remove this log line.
minor: I noticed AmbryDataNode.getHostname() will print out DataNode, so you can remove this log.
Please use {} placeholders in the log message
Please use {} placeholders in logger
Please replace with {}
Can combine these two lines into one.
Can combine these two lines into 1
Can combine these two line into one.
use context.close()
use context.close();
use context.close()?
This also needs to be done in other place.
This also needs to be done in removeDevice
you can remove this also
If you merge master branch into master, you can get rid of this line.
If you merge master branch into this function, you can get rid of the upstream one.
If you merge master branch into this function, you can get rid of the code duplication.
What is the purpose of this comparison?
What is the purpose of catching this exception?
What is the purpose of catching this exception?
If the scrollable text is duplicated, could you try it?
If the mouse is squashed at 28 then you don't need to use the render method.
If the mouse is squashed at 28 then you don't need to use the fontRenderer, rather than the player.
I can't understand why this is a catch block and the method is only called in this block. Line 93 should be a bit longer as a separate function.
I can't understand why this is a catch block and the method is only called in this block. Do we need to catch it here?
I can't understand why this is a catch block, and the method is only marked as @Before
do we need to change the bloom filter here?
maybe change the string format to s/(s)/(s)/(s)/(s)/(s)/)
maybe change the string format to s/(s)/(s)/(s)/(s)/(s))/?
There's no need to pass the timeout task to completeExceptionally. The notifier is needed.
This doesn't need to be public
Race condition?
remove "java"
remove extra line
remove hard-coded string
Both of these work the same at the moment, but it would be correct to use the specific manager depending on case. Better make a disputeAgentManager and set to whichever type is being registered, or just move the specific registration code to their switch cases.
Both of these work the same at the moment, but it would be correct to use the specific manager depending on case. Better make a disputeAgentTypeSet a disputeAgentType and set to whichever type is being registered, or just move the specific registration code to their switch cases.
Both of these work the same at the moment, but it would be correct to use the specific manager depending on case. Better make a disputeAgentManager and set to whichever type is being registered, or just move the specific registration code to their switch cases..
I think that we can just do t.close() in the previous if condition. Or am I missing something?
I think that we can just do t.close() in the previous if condition. If someone calls t.close() multiple times, it'll take an NPE
I think that we can just do t.close() in the previous if condition. If someone calls t.close() multiple times, it'll take an NPE.
Does this work?
Does doOnNext ever work here?
Does this work for parallelStream?
Is it possible to get rid of this block?
Is it possible to get rid of this?
Is this block relevant?
@pynicolas let's rename it to handleSuccessors
@pynicolas As far as I understand, this check is not needed.
@pynicolas As far as I understand, this check is not required.
:question: Should be "started entry"
Format
:question: Should be "started entry: "
Wondering if we need to clean the folder when the test is done?
Wondering if we need to clean the folder when the test fails?
Wondering if we need to clean the folder when the test succeeds?
Does not handle entry being removed or not modified.
Does not handle entry being added or not modified.
Does not handle entry being removed.
The three lines above should be a _try-catch_ block.
The three lines above should be a _try-catch_ clause.
The three lines above should be a _if_ loop.
I wonder if this one should not be public, are there any reasons why this is package protected?
I wonder if this one should not be public, are there any reasons why it's package protected?
I wonder if this one should not be "id" in the log message.
new IllegalArgumentException("Unrecognized Java Configured"); or use the method.
this should be sslConfig.getKeyStorePassword()
this should be sslConfig.getKeyStorePassword() > null
I think it would be better to log this exception.
exception is now only logged here.
exception is now only logged here. So this exception is now obsolete.
annotate this method with @VisibleForTesting
Remove the public modifier
annotate with @VisibleForTesting
Can you confirm that those four Concepts are a mix of retired and unretired Objects? You should prove that this setMembers contain the unretired concepts.
Can you confirm that those four Concepts have a mix of retired and unretired Objects? You should prove that this setMembers contain the unretired concepts.
Can you confirm that those four Concepts are a mix of retired and unretired Objects? You should prove that this setMembers contain the unretired concepts. Should be added.
You can use the Essentials formatter to make this kind of check here.
You can use the Essentials's formatter.
You can use the Essentials formatter to make this more readable.
hopefully that it also needs to be closed.
hopefully that it also needs to be a separate test
hopefully that it also needs to be a separate test ;)
Prefer using try/catch here.
.*?s?
.*?s and english?
this code is using the same horizontal brace
this code is using the same context. what about using the context?
this code is using the same formatting.
This error message is misleading. Maybe change to "the order is placed and not yet confirmed" to "the order is placed"?
This error message is misleading. Maybe change to "the order is placed and not yet confirmed"
I think this error should be in a test
This is wrong; you're returning before calling super.tearDown() at the bottom of the function. Express this more directly: if (mHasWifi) { if (mWifiManager.isWifiEnabled()!= mInitialWifiState) { //... the rest of the wifi-specific teardown... } } super.tearDown();
I know this is just a refactor, but please remove the super.tearDown() call here and in the else below. Express this more directly: if (mHasWifi) { if (mWifiManager.isWifiEnabled()!= mInitialWifiState) { //... the rest of the wifi-specific teardown... } } super.tearDown();
I know this is just a refactor, but please remove the super.tearDown() call here and in the stop() only. Express this more directly: if (mHasWifi) { if (mWifiManager.isWifiEnabled()!= mInitialWifiState) { //... the rest of the wifi-specific teardown... } } super.tearDown();
Nit: I'd rename gaps to gapsTable. Then accidentally mixing this gaps instance with gapsTable.
trace()
trace
Use EqualsBuilder.reflectionEquals(this, other)
Use EqualsBuilder.reflectionEquals() here.
This is the same as the other instance of OgcMessage. It should be the same.
If we need to do this, shouldn't we use a private method with a generic name?
If we need to do this, shouldn't we use a private method with a generic signature?
If we need to do this, shouldn't it be a private static final String?
The part service is not in the editor object, so what about changing it to: if (partService.getParts().contains(part)) { partService.hidePart(part, force); return true; }
The part service is not in the editor object, so what about changing it to: if (partService.getPart(false)) { partService.hidePart(part, force); return true; }
The part service is not in the editor object, so what about changing it to: if (partService.getPart(false) &&!partService.hidePart(part, force, local)) {... }
Again, the local variable ListDataProject[] listDataProject is not used outside of this method.
Again, the local variable ListDataProject[] listDataProject = new ArrayList<>();
Again, the local variable ListDataProject[] listDataProject is not used outside of this scope.
Could you add a unit test for this case?
Could you add a default or size method instead of converting the array to an array?
Could you add a default or size method instead of assuming size?
Perhaps we could use entry.getValue() here instead of column.getFamily()?
Perhaps we could use entry.getValue() here instead of entry.getValue()?
Perhaps we could use entry.getValue() here.
nit: this won't use the FustainedConnectionWorker interface.
nit: this won't be called in the constructor.
nit: this won't be called when the queue is null.
Does this try-with-resources block make sense?
Does this try-with-resources block matter?
Does this try-finally block?
I think it would be better to use an API in this file: public JavaRDD<StructuredRecord> transform(SparkExecutionPluginContext context, JavaRDD<StructuredRecord> input) throws Exception { return context.wordVectors().length / loadedModel.wordIndex().size(); }
I think it would be better to use an API in this file: public JavaRDD<StructuredRecord> transform(SparkExecutionPluginContext context, JavaRDD<StructuredRecord> input) throws Exception { return decorateModel.wordVectors().length / loadedModel.wordIndex().size(); } private List<String> wordVector = loadedModel.wordVectors().length / JavaRDD<StructuredRecord> inputSchema; private List<String> formatStr(StructuredRecord input) throws Exception { return formatStr; }
I think it would be better to use an API in this file: public JavaRDD<StructuredRecord> transform(SparkExecutionPluginContext context, JavaRDD<StructuredRecord> input) throws Exception { return context.wordVectors().length / loadedModel.wordCount(); }
Can you remove the space between itemIdx and P[k].
Can you remove the check for P[k].contains(itemIdx) first?
Can you remove the space between itemIdx and P[k].add(itemIdx) and (k!= binIdx)?
get rid of this since its been deleted in getConfiguration().getStorages()
get rid of this since its been deleted in Configuration#getStorages(). This method is not needed anymore.
get rid of this since its been deleted in getConfiguration().getStorages().forEach()
Log
Could this be a static variable?
Could this be a static constant?
It might be interesting to use FakeBeanDeployment here if we have not specializedBeansMap.put(specializedBean, new AtomicLong(1)); in case of inheritance etc.
It might be interesting to use FakeBeanDeployment here if we have not specializedBeansMap.put(specializedBean, new AtomicLong(1));
It might be interesting to use FakeBeanDeployment here if we have not specializedBeansMap.put(specializedBean, new AtomicLong(1)); in case of spring-boot.
I think this should be a method on the response
I'd move this to the method return
I'd move this to the method return statement
Remove blank line?
Remove blank line.
Remove?
same exception issue
same exception issue -> no exception thrown
same exception issue as above.
Maybe we could add a wait condition to make sure that this wait is successful.
Do you need to wait for timeout here?
Maybe we could add a wait condition to make sure the new wait is successful.
gtm
what is this new code for?
what is this change doing?
Maybe catch here more specific exception?
I'd prefer to see the delay in the test here.
I'd prefer to see the moved out of the try block and put the catch around the test failure.
There's no need to have an extra param here, right?
There's no need to have an extra param here, the test method will close at the end
This loop is not properly closed, right?
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationStatement on the line above: we can just no declaration.getParent().getParent() here.
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationStatement on the line above: we can just no declaration.getParent().getParent().
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationStatement on the line below: we can just no declaration.getParent().getParent() here.
Maybe it would be nice to set the expiration time to a.0 seconds instead of 10 seconds?
Perhaps it would be better to set the interrupted flag in the stop() method, just in case once for whatever reason.
Perhaps it would be better to set the interrupted flag in the stop() method, just in case in the context of the refresh() method.
I'm surprised: I don't see any attribute attribute except for FoursquareProfile.
I'm not sure if this is necessary because it is for FoursquareProfile.
I'm surprised: I don't see any attribute attribute.
It seems like this could be refactored into a single method which takes a task name as parameter.
It seems like this could be refactored into a single function?
It seems like this could be refactored into a single method which takes a list of taskInfos.
log.debug("BAPI XMI Logon response: {}", logonResponse);
log.debug("bAPI XMI Logon response: {}", logonResponse);
log.debug(" BAPI XMI Logon response: {}", logonResponse);
This new String[]{ is unnecessary, it's a common practice.
This new String[] is unnecessary, it's a single placeholder test case.
This new String[]{ is unnecessary, it's a pass in the object
This method should be for both ContentResolver and ContentProvider, as other methods in this class.
This method should be for both, and also in ProviderTableMeta.CONTENT_URI.
This method should be for both disk and user.
getting the same metrics on both cases
An null check is necessary here. RequestMetrics is already available in the BlobInfo constructor.
An null check is needed here. RequestMetrics is already available in the BlobInfo constructor.
Glad to see a test for this case better. But it should be done in the dispose method.
Glad to see a test for this, but no code duplication, please extract to remove the "public" method.
cancel?
You could add an empty filter filter after the filter filter.
You could add an empty check for filter filter after the filter filter.
You could add an empty check for filter filter after the filter.
I'd prefer using StringBuilder here instead of StringBuffer.
I think you could use StringBuilder here instead of StringBuffer.
I'd prefer using StringBuilder in this class, for performance reasons.
Grate! I think we don't need an if (file!= null) any more after this.
Grate! I think we don't need an if (file!= null) any more before this.
Grate! I think we don't need an if (file!= null) any more after this..
Missing slash - should be "/miso/run/"
Missing slash when miso/run/" is not set?
Format
Useless extra line
This is unnecessary, you should use a bind here.
This is not an extra line
nit: wrap this block in curly braces
nit: wrap this block in curly brackets
static import
getInteractiveCommandTimeout()
See above.
what happens if the Repo command is null?
(I remember that the other tests are using assertj methods)
instead of duplicating the code for the tests, could we please have a common utility method like assertHasItem
you can use AssertJ for assertions on the headers
StringBuilder
You could have normalized queryId on QueryId here.
StringBuilder?
s/commit/bucket
Spacing
true
This appears to me to be a redundant check as it is already done in updateActionAvailability so the action would be disabled right
This appears to me to be a redundant check as it is already done in getEntity()
This appears to me to be a redundant check as it is already done in updateActionAvailability so the action would be skipped
Why are we doing this parallelStream?
Why are you using parallelStream?
Can use a constant for trim and skip the parallelStream
collectionName.substring(0, collectionTempName)
collectionName.startsWith(1) is enough.
collectionName should be collectionTempName.
Wrong method name, should be log.
Wrong method name, should be log. Please remove
Wrong method name, should be log. Please remove.
We should also have a test for the get() method.
We should also have a test for the get() function.
We should also have a test for the gw parameter.
Let's find better name for this.
Let's catch more concrete exception instead of generic one.
Let's catch more concrete exception here.
I'e tried with this url and it didn't worked: <LINK_3> this url was OK: <LINK_0> but it required 5 and 4 http requests to get the final answer each time. I think we should start search from the begin of the path and not from the end to avoid spamming on server and delays on client side. I also would propose that we should recognize http*://git.eclipse.org/* urls and only try <LINK_2> in this case: Eclipse web master and also end users will be really happy to need only one single shot to get the result. Additionally as the example above shows the automatic Gerrit config for git.eclipse.org/gitroot/ URL's doesn't work at all.
I'e tried with this url and it didn't worked: <LINK_3> this url was OK: <LINK_1> but it required 5 and 4 http requests to get the final answer each time. I think we should start search from the begin of the path and not from the end to avoid spamming on server and delays on client side. I also would propose that we should recognize http*://git.eclipse.org/* urls and only try <LINK_2> in this case: Eclipse web master and also end users will be really happy to need only one single shot to get the result. Additionally as the example above shows the automatic Gerrit config for git.eclipse.org/gitroot/ URL's doesn't work at all.
I'e tried with this url and it didn't worked: <LINK_3> this url was OK: <LINK_0> but it required 5 and 4 http requests to get the final answer each time. I think we should start search from the begin of the path and not from the end to avoid spamming on server and delays on client side. I also want to might have an example example in the example above: <LINK_1>
Might as well create a testcase for this line.
This test cannot be possible. We might as well create a new file for each test case.
Might as well create a test for this line.
I think this should be assertEquals("OS", certProds.get(0).getBrandType());
I think this should be assertEquals("OS", engProdId.getBrandType());
I think this should be assertEquals("OS", engProdId, "OS",...
I think it's better to do it this way: java ctx.addIssue(exceptClause.exceptKeyword(), "Merge this bare \"except:\" with the \"BaseException\" one.").secondary(baseExceptionExpression, null); If it's not, then you can achieve the same behavior with the following: * public static void handleExceptClause(SubscriptionContext ctx, Map<String, Expression> caughtTypes, ExceptClause) { if (exceptionExpression == null) { ctx.addIssue(exceptClause.exceptKeyword(), "Merge this bare \"BaseException\" with the \"BaseException\" one.").secondary(baseExceptionExpression, null); } }
I think it's better to do it this way: java ctx.addIssue(exceptClause.exceptKeyword(), "Merge this bare \"except:\" with the \"BaseException\" one.").secondary(baseExceptionExpression, null); If it's not, then you can achieve the same behavior with the following: * public static void handleExceptClause(SubscriptionContext ctx, Map<String, Expression> caughtTypes, ExceptClause) { if (exceptionExpression == null) { ctx.addIssue(exceptClause.exceptKeyword(), "Merge this bare \"baseException\" with the \"BaseException\" one.").secondary(baseExceptionExpression, null); } }
I think it's better to do it this way: java ctx.addIssue(exceptClause.exceptKeyword(), "Merge this bare \"except:\" with the \"BaseException\" one.").secondary(baseExceptionExpression, null); If it's not, then you can achieve the same behavior with the following: * public static void handleExceptClause(SubscriptionContext ctx, Map<String, Expression> caughtTypes, ExceptClause> { if (exceptionExpression == null) { ctx.addIssue(exceptClause.exceptKeyword(), "Merge this bare \"BaseException\" with the \"BaseException\" one.").secondary(baseExceptionExpression, null); } }
same, no need for "+"
same as above with new method
same as above with different parameter (for Lookup).
Multi key could be null.
I think customMetadata might be null here
I think customMetadata might be null
You don't need to make this a static.
You don't need to catch exception here.
You don't need to make this a static final.
minor: use nanoTime() for thread safety
minor: use thread.join()
unnecessary parentheses
I think this can be simplified to java result = ((CompletionStage) result).toCompletableFuture().get();
I think this can be simplified by adding a return statement on the following if-else if: if (result instanceof CompletionStage) { result = ((CompletionStage) result).toCompletableFuture().get(); } return result;
I think this is ok but it would be much better to throw an exception in the general case when we cast to CompletionStage in the future.
You can do the work and pass the Context menu to getContextMenuProvider
You can do the work and pass the Context menu to getContextMenuProvider.
You can do the work and pass the Context to getContextMenuProvider
On reflection, this should be done only if you need a method of the injection.
On reflection, this should be done only if you need a method of the injection, which just returns true. Why is it not required?
On reflection, this should be done only if you need a method of the injection, right?
This should be its own logger instead of System.out
This should be its own logger instead of System.out.
This is not correct?
nit: I think this can be more readable as hasPreferredIsForced || (isForced && selectedAudioLanguageScore > 0) || (isForced && selectedAudioLanguageScore > 0);
nit: I think this can be more readable as hasPreferredIsForced || (isForced && selectedAudioLanguageScore > 0)) || (isForced && selectedAudioLanguageScore > 0);
This needs to be addable, and add it to the parameters, add locale, and locale.
Might always be good to make this header in case of binary and file. This would probably also be good for test cases for binary and binary as well. Some of these headers might exist in the map, and we want to move to a properties file for cdrBinarySubPath headers. There's already a method to getHeader that does pretty much the same.
Might always be good to make this header in case of binary and file. This would probably also be good for test cases for binary and binary as well, but I think that'd probably be easier to read.
Might always be good to make this header in case of binary and file. This would probably also be good for the time we add property to the enum.
I personally prefer the "fast return" style, so that "if" branches which don't have to do match are placed first and ends with a return. This avoids too "deep" nesting.
I personally prefer the "fast return" style, so that "if" branches which don't have to do match are placed first and ends with a return
I personally prefer the "fast return" style, so that "if" branches which don't have to do match are placed first and ends with return. This avoids too "deep" nesting.
Use isEmpty()
Use isEmpty() to check for map name.
Use isEmpty() if mapInfoBeans.isEmpty()
I can't see any reason to remove this, it's needed for the newly added.
I can't see this :(
Should we remove this?
We can use pipeline here since there are no need to assert it.
We can use pipeline here since there are no rat configs.
We can use pipeline here since there are no rat mode in the cluster.
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Formatting
1. I know you haven't write this in the PR, but why IdGenerator.getLocalPort()? 2. Why IdGenerator.getAndIncrement()? Do we need to determine if it's a universal operation?
1. I know you haven't write this in the PR, but why IdGenerator.getLocalPort()? 2. Why IdGenerator.getAndIncrement()? Do we need to determine if it is a universally enough?
1. I know you haven't write this in the PR, but why IdGenerator.getLocalPort()? 2. Why IdGenerator.getAndIncrement()? 3. Why equals this to string? 2. Why equals this?
This name is a bit confusing, since it could be equal to gateChannelsPerCheckpoint.
This name is a bit confusing, since it could be equal to gateChannelsPerCheckpoint. I'd prefer to have either all of them equal to the entire block, or they are equal.
This seems a bit dangerous. Suggest removing gateChannelOffsets only and adding weight decorators to the channel. Wouldn't it be more flexibility to just gate to the caller?
Shouldn't this read: catch (RouterException e) {... }
Shouldn't this be RouterException?
Shouldn't this read: catch (RouterException | RouterException e) {... }
suggestion private String createAuthenticationRequestRedirectUrl(HttpServletRequest request, ISO_8859_1) {
suggestion return createAuthenticationRequestRedirectUrl(relyingParty, request, true).toUriString();
suggestion return createAuthenticationRequestRedirectUrl(relyingParty, request, false);
> CACHE_EVENT_COUNT, "1");
> CACHE_EVENT_COUNT (which is not needed for this PR)
> CACHE_EVENT_COUNT < 0
Do you think it's necessary to override the properties in the configuration? That will't be enough.
Do you think it's necessary to override the properties in the configuration? That will't be the case that the config loader will be missing.
Do you think it's necessary to override the properties in the configuration? That will't be the case that the config loader will't contain a table.
nit: add the ("RIT {};") before the assignment?
nit: add the ("RIT {};" in the log message?
nit: inline the variable?
Instead of defining constants for the string, the utility method could be simplified to use of the String.format() method.
Instead of defining constants for the string as a static final field, just use ints
Instead of defining constants for the string, the utility method could be simplified to use of the String.
Shouldn't this be public? (and maybe it can be removed?)
Shouldn't this be public? And maybe it can be removed?
Shouldn't this be public?
if (visited.add(term))
if (visited.add(term)) {... }
if (visited.add(term)) {...
I'd use "defaultCacheMode" instead of LOCAL_CNT - 1
I'd use "defaultCacheConfiguration" instead of 'FULL_SYNC' since it is the default value.
I'd use "defaultCacheMode" instead of LOCAL_CNT - 1 here and in other places.
Missing @Override annotation.
nit: you could make this a constant and use it here (and in onServerPoolMemberChanged).
nit: should be removed
DtoFactory.newDto(UserInRoleDescriptor.class).withIsInRole(isInRole()).withScopeId(scopeId).withScopeId(scopeId);
DtoFactory.newDto(UserInRoleDescriptor.class).withIsInRole(isInRole()).withScopeId(scopeId);
DtoFactory.newDto(UserInRoleDescriptor.class).withIsInRole(isInRole()).withScopeId(scopeId);
This is similar to Compressor
This transform operation needs to also check if the fields are not null
This transform operation needs to also take the name of the field to be created
Should this inspect the value of the userInfo to determine if it's a bucket owner? If not, why do we need to do this check?
Could you check that baseName is not null?
Could use a private method to create this class
Can we make this a static final variable for the keyType?
Can we make this a throw?
Can we make this a static final variable for it?
This can be done as a single line by using the.pack() call.
This can be done as a single line in the if clause.
This can be done as a single line by using the.pack() method.
Style-nit: Space after if.
Style-nit: Unnecessary blank line.
Style-nit: Space before {
do it in one line
use CollectionUtils.equals
use CollectionUtils.equals()
I am just not 100% sure why the exception is thrown here.
I just am just not 100% sure why the conversion to double here.
I just am just not 100% sure why the conversion to double is needed.
You can simplify this to if (imageView!= null) {
You can replace this with EventBusMethods.bind(this, View.OnClickListener.class);
You can replace this with EventBusMethods.bind(this, View.OnClickListener.class, CallbackAdapter.class);
Multi-line if statements should be braces.
Multi-line if statements should be indented
Did you make this change?
formatting
I think it'd be better to have this in the constructor
formatting looks off
This aligns with the new message.
This aligns with other error messages.
This aligns with other error messages. Please remove this break.
You should do the same test on both 187 and 188 :-)
You should do the same test on both branch and block.
You should do the same test on both branch and use Msec.
nit: rename processor -> processor.test(annotation) to something like methodAnnotationProcessors.stream().filter(processor -> processor.test(annotation)).forEach(processor -> processor.process(annotation, data));
nit: rename processor -> processor.test(annotation) to make the message more clear, e.g. methodAnnotationProcessors.stream().anyMatch(processor -> processor.test(annotation))
nit: rename processor -> processor.test(annotation) to make the message more clear, no?
change to TimeUnit.SECONDS.sleep(machine.getState())
change to TimeUnit.SECONDS.sleep(TIMEOUT)
is it possible that a VM needs to be started or not?
if there is no semantic element in the list: if there is no semantic element, this is always true.
return directly
break;
If you're using a static import for intervalInMs, you can use as() method.
If you're using a static import for intervalInMs, you can use as well defined in line 498.
If you're using a static import for intervalInMs, you can use as well defined in line 34.
Here it would be better if we can keep the other code and move the if/else logic inside.
Here it would be better if we can keep the other code and move the if/else logic inside it.
Here it would be better if we can keep the other code rather than handling a negative case.
SUM should not be needed.
throw new IllegalStateException
throw new IllegalStateException(message, e)
I am not sure if this is the right place. I would have thought we need to add a IGNORE_RETURN_VALUES to this method.
I am not sure if this is the right place. I would have expected a race condition on readLastConfirmed, but you need to shrink.
I am not sure if this is the right place. I would have expected a race condition on reading lastConfirmed, but you need to shrink.
Use the same approach as FsFamily.values()
Use the same approach as FsFamily in the other method
Is this operating system allowed?
Droprs. But we can't do this, right?
Droprs, otherwise we're shearable on Sheared, right?
With your change, we can't shearable on Sheared, right?
What about the iterators? There are multiple sortItems, it is better to return the sortedItems.
What about the iterators? There are multiple sortItems, it is better to return the sortedItems. It is easier to read and more compact.
What about the iterators? There are multiple sortItems, it is better to return the sortedItems. It is easier to read and more easily.
Why does this need to be set?
Shouldn't the message be set to null?
Why does it need to be set?
Why change to create?
clone to avoid changing the old behavior
clone to avoid changing the old methods
why not checking status here?
this one could be made static.
why not checking status in the caller?
nit: formatting
nit: this block of code is not needed
nit: combine these two if statements
This is not adding an exception. Why just don't let exception be thrown here?
This should throw an exception.
This is not adding an extra line.
Spelling: this is not obvious.
Spelling: splitted
Spelling: this should be lookupName
what about multiple storage domains?
why not just return the permission?
what about multiple storage domains? several hosts
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
We should log this properly too, i think. Errors in this class don't always bubble up where they can be inspected easily.
How about isHidden()?
rename to watch
rename to subnetId
rename to subnets
"(emptyString)"?
"(emptyString)"
".."
DatabaseUtils.makePlaceholders(revid, id)
DatabaseUtils.makePlaceholders(revid, String revId, String revId) throws DatastoreException {... }
DatabaseUtils.makePlaceholders(revid, String revId, String revId) throws DatastoreException {
Use Ds3DocSpecEmptyImpl
use Ds3DocSpecEmptyImpl
Use Ds3DocSpecEmptyImpl instead
Please use org.intellij.common.util.Objects.equals(String, Object) instead.
Please use "this" instead of constructing the local variables.
Please use org.intellij.common.util.Objects.equals(this, other) instead.
can we make this more readable something like Total running and compactor [], Maximum compaction queue capacity []. Thanks
can we make this more readable something like Total running and compacting [], Maximum compaction queue capacity []. Thanks
can we make this more readable something like Total running and compacted counts = (int) Math.min( indexingServiceClient.getTotalWorkerCapacity(), dynamicConfig.getMaxCompactionTaskSlots() ); else {... }
nit: I understand the logic here that getNextUnAssignedTask() is called for every datastream task, but this code doesn't seem to be doing it. So I think we can get rid of the loop and just do the check after adding it to the newAssignmentForInstance.
nit: I understand the logic here that getNextUnAssignedTask() is called for every datastream task, but this code doesn't seem to be doing it. So I think we can get rid of the loop and just do the check after adding it.
nit: I understand the logic here that getNextUnAssignedTask() is called for every datastream task, but this code doesn't seem to be doing it. So I think we can get rid of the loop and just do the check after adding it to the existing tasks as well.
Couldn't we not just use the width and height for the font here?
Couldn't we not just use the width and width for the dialog?
Couldn't we not just use the width and width for the font here?
Is this the recommended way in Karaf -f? I guess for the dummyxaresource it has to be this way but can we try a H2 datasource somehow?
Is this the recommended way in Karaf -f? I guess for the dummyxaresource it has to be this way but can we try a HALT-only Rule?
Is this the recommended way in Karaf -f? I guess for the dummyxaresource it has to be this way but can we try a HmException or Swift?
If someone reviews this PR, then this method could be moved into the following java private GlowBlock getNewGlowBlock(GlowBlock block, Random random) private GlowBlock getNewGlowBlock(GlowBlock block, 2)));
If someone reviews this PR, then this method could be moved into the following java private GlowBlock getNewGlowBlock(GlowBlock block, Random random) private GlowBlock getNewGlowBlock(GlowBlock block, Random random) { int radius = (bx - radius; x <= bx + radius; y++) {
If someone does the following val things in the future, this method could be private. This private method could be made private.
This change does not seem to be related to this PR, but should the future be completed?
This change does not seem to be related to the fix.
Why are you creating a new array of the size of it?
Please don't use.with( ) here. The assertion above is checking whether the URL is avro.fetch or avroUser.getSchemaAsString() is true.
Please don't use.with( ) here. The code uses.with(String) to build a string. It will be more readable to use that.
Please don't use.with( ) here. The assertion above is checking whether a new project exists.
Please use static import.
Please update the test name to reflect it.
Please update the test name to reflect the new instance.
not sure how this line was added here - this initialization is done in line 67 and needs to be removed.
not sure how this line was added - this initialization is done in line 67 and needs to be removed.
not sure how this line was added here - this initialization will go away.
You can add a cast to the symbol a bit more :: ra.setStrokeEnabled(strokeBox.isSelected());
You can add a cast to the symbol to a String to improve readability.
You can add a cast to the symbol a bit more :wink:
I am not sure whether this will work as expected if this method is used only by the VMs which are created. i think this check is not necessary.
I am not sure whether this will work as expected if this method is used only by the VMs which are created. i think this code should be moved to DisksMap as well
I am not sure whether this will work as expected if this method is used only by the VMs which are created before the creation time. i think this code should be moved to DisksMap as well.
null check
else if
Same thing about naming
why this?
Can we use TimeUnit.SECONDS.sleep?
why increment and decrement are not used?
An AssertionError is designed to throw an IllegalArgumentException than a NPE, so we should be able to recover from it.
An AssertionError is designed to throw an AssertionError than a NPE, so we should be able to recover from it.
throw AssertionError or IllegalArgumentException
Why is this not autoScaleDiagramCheckBox's selection listener?
Why is this text shown to the user?
final
Duped code. Any way of sharing?
Why not String.format("%s/hbase-site.xml")? It is better to put it in a constant.
Why not String.format("%s/hbase-site.xml")?
Wasn't it easier to understand why it was changed to support the subfolder?
Wasn't it easier to understand why it would be false for includePattern?
Unnecessary change?
We should log the exception before this for loop
We should log the exception before this call.
this should be an error
.collect(Collectors.toList())
Missing final
.collect(Collectors.toList())?
Since we're changing the default behavior of the cache backend, maybe we should only pass the coordinator here? In that case, we could _do_ want to use the new metrics everywhere and remove the old metrics.
Since we're changing the semantics of the old and new TimestampedCacheFlushListener, we could remove the call to StateStore.handleAsync(request) method.
Since we're changing the semantics of the updatedRecordsSensor it should be created once.
You don't need this synchronized block. It would be a performance impact if you rewrite the code using a double.
You don't need this synchronized block. It would be a performance impact if you rewrite the code using a stream when possible.
You don't need this synchronized block. It would be executed inside the synchronized block.
Is there a reason you didn't just shorten the code like this? String prefName = Router.EXTRA_ENROLLMENT, courseData); if (courseData!= null) { bundle.putString(Router.EXTRA_ENROLLMENT, courseComponentId); } else { bundle.putSerializable(Router.EXTRA_ENROLLMENT, courseComponentId); }
Is there a reason you didn't just shorten the code like this? String prefName = Router.EXTRA_ENROLLMENT, courseData); if (courseData!= null) { bundle.putString(Router.EXTRA_ENROLLMENT, courseData); } else { bundle.putSerializable(Router.EXTRA_ENROLLMENT, courseComponentId); }
Is there a reason you didn't use [this](<LINK_0> instead of this magic number?
The actual fix is this alone right?
It seems like this method will always return false. Am I missing something?
It seems like this method will always return true. Am I missing something?
Could you please add a check, please?
Could throw a more specific exception.
Could you please add a check what happens when mockJar is null?
Should this method be private? Is it only used outside this class?
Should this method be private? Is it only used in tests?
Should this method be private?
:warning:
Missing?
Missing some assertions
Do you still need this if you've created the api?
Do you still need this if you've created the api from the test?
Do you still need this if you've created the api instance?
this should be "testConcept"
this should be null since the createOrder method itself assumes that the encounter is created
this should be null since the createOrder method itself throws an exception
Add a severe logging message here describing the issue to server owners (and maybe tell them they will need to downgrade for now).
Add the severe logging message here describing the issue to server owners (and maybe tell them they will need to downgrade for now).
Add a severe logging message here describing the issue to server owners (with all useful information).
StateProviderImpl should be used there.
StateProviderImpl should be used here, but for consistency, it should be static.
StateProviderImpl
When extracting a method keep it (whenever possible, it's easier to review the changes)
Validations that startAt < maxRetryIntervalMillis startAt > now etc?
When extracting a method keep it (whenever possible, it's easier to review the code)
this is going to fail here.
Can we remove this?
This is going to fail here.
Use Collections.emptyList() to save a bit of overhead.
Use Collections.emptyList() instead.
Use Collections.unmodifiableList.
I prefer if you use instanceof here.
Not very useful in this PR.
Not very useful in this case.
Have you considered using try-with-resources here, to ensure this is only called once?
Have you considered using try-with-resources here? I don't think this is necessary.
Have you considered using try-with-resources here, to ensure this is only called in case of exception?
Log message here.
Log the exception
Log the exception?
same here, you need to call Context.getOrderService()
same here, you need to call ScopeService.CURRENT_SpatialX/ScopeService
same here, you need to call Context.getOrderService() and below
Move this to a shared method?
Move this to a shared method
Move this to a method
Does it mean we might have dataConsistentOnStandby = true?
Does it need to be public?
Does it work?
why not: boolean ret = false; try { prepareStatement = connection.prepareStatement(selectQuery); prepareStatement.setString(1, userName); prepareStatement.setString(2, domain); try { prepareStatement.close(); } finally { connection.close(); } } return ret; no problem to continue check... we do need to understand if we can provide database access detach from the engine... but in this case it is not that important as we will not use this vdc_options in future anyway. you have the configuration information within environment ENGINE_DEFAULTS, ENGINE_VARS. maybe I will move LocalConfig to uutils.
why not: boolean ret = false; try { prepareStatement = connection.prepareStatement(selectQuery); prepareStatement.setString(1, userName); prepareStatement.setString(2, domain); try { prepareStatement.close(); } catch (resultSet = null) { connection.close(); } } return ret; no problem to continue check... we do need to understand if we can provide database access detach from the engine... but in this case it is not that important as we will not use this vdc_options in future anyway. you have the configuration information within environment ENGINE_DEFAULTS, ENGINE_VARS. maybe I will move LocalConfig to uutils.
why not: boolean ret = false; try { prepareStatement = connection.prepareStatement(selectQuery); prepareStatement.setString(1, userName); prepareStatement.setString(2, domain); try { prepareStatement.close(); } catch (resultSet == null) { connection.close(); } } return ret; no problem to continue check... we do need to understand if we can provide database access detach from the engine... but in this case it is not that important as we will not use this vdc_options in future anyway. you have the configuration information within environment ENGINE_DEFAULTS, ENGINE_VARS. maybe I will move LocalConfig to uutils.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "id". [![rule](<LINK_0>](<LINK_2>
![MINOR](<LINK_2> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "id". [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable " am". [![rule](<LINK_0>](<LINK_2>
Maybe we can use Optional here instead of the above if-else at line 105.
maybe use isEmpty() or isNotEmpty()
maybe use TextUtils.isEmpty(...) or Optional.empty() for consistency
Can you just put this in line 60?
This is called a long time to stop the notification when this is called. Can you pull the value into field?
This is using getPackageName() because java.lang.Ever is not guaranteed to be non-null.
Replace passenger!= this with!Objects.equals(passenger, this)
Replace passenger!= this with!Objects.equals(passenger, this);
Replace passenger!= this with! passenger!= this.
if you don't use this class, there is no need to set this as a parameter of this method.
if we don't need this line
if you don't use this class, there is no need to set this as a parameter of this method
I think this is the right place to initialize the result.
I think this is the right place to initialize the waitTimeFer.
Why is this necessary?
I don't think this is necessary
I don't think this error message is helpful for users.

Does this work? If you use the Products, you will default to a default, and the label will not be available/disabled. You could use the ProductsBuilder instead.
Does this work? If you use the Products, you will default to a default, and the label is not set here.
Does this work? If you use the Products, you will default to a default, and the label will not be set?
If columnWriters is null then you don't need the if (page!= null) { validationBuilder.addPage(page); }
If columnWriters is null then you don't need the if (page == null) { validationBuilder.addPage(page); }
If columnWriters is null then you don't need the check in line 112.
Wouldn't it be better to use == instead of equals?
Wouldn't it be better to use == rather than equals?
why is this inside while loop?
Does this method need to be public?
Should this method be private?
Should this method be public?
Same. Should this be.realm instead?
Same. Should this be.realm?
Same. Should this be.realm?
This is kind of confusing.
This is kind of confusing, we should throw an exception with a different name.
This is kind of confusing, we should throw an exception if the assert fails.
It seems you have to throw an exception here if the index is not closed
It seems you have to throw an exception here if the index is indeed connected
It seems you have to throw an exception here if the index is not connected to a test index
merge with the previous line
merge with the previous line?
merge with the previous line.
Please use { and } for if statements.
Please use { and } for if statements instead of if statement.
Please use { and } for if statements instead of if statements.
Can we compose the stream stream into a single try-with-resources block, for consistency?
Can you handle the stream with try-with-resources, for consistency?
Can we compose the stream stream into a single try-with-resources block?
Couldn't we save the need for the temp variable?
Why the variable declaration is here and not in the for loop?
Why the variable name?
As before, this is shared code with File..CompareEditorInput. Shared superclass?
As before, this should be ReviewCompareAnnotationSupport. Shared superclass?
As before, this makes shared code more readable.
I think we can do something with the external ID here: if doNotForceEmission=false, the emittedEventDao.hasBeenEmittedBefore(event) is not true and the other 3 are not true. Otherwise, I think we need to provide a a "refundExternalId={}" on the DB.
I think we can do something with the external ID here: if doNotForceEmission=false, the emittedEventDao.hasBeenEmittedBefore(event) is not true and the other 3 are not true. Otherwise, I think we need to provide a a "refundExternalId={}" refundHistory.getExternalId()
I think we can do something with the class name rather than including the external ID
"essentially"?
Why is this change needed?
"essentially" is not a good name.
This might also need to be changed to start the ejb3SubsystemAddOperation.
This might also need to be changed to use the model for the i18n data files
This might also need to be changed to use the model for the i18n xml
do we need case insensitive checks?
remove the else
remove extra line
"else" is redundant here
"else" is unnecessary here
"intentional"
Maybe we can have a solution to the streamING_SOURCE_MONITOR_INTERVAL.
Maybe we can have a solution to the streamING_SOURCE_MONITOR_INTERVAL. calculated one and only use it.
Maybe use what included in the message
nitpick: "Log..."?
if (cmd.isPresent())...
Typo? "Log..."?
Can this be moved into the if block?
You can probably remove this if statement as this is done in line 119.
You can probably remove this if statement since it is done in both if blocks.
Nice, thanks for the fix!
Nice, thanks!
Nice, thanks for adding this!
nit: you could skip this announce task for every task
nit: you can probably skip this
notice
nit: _tasks = new HashMap<>();
Consider extracting this to a method
Consider getting this value as a constant
The docs indicate that we're not using the raw type here, but missing, right?
The cast to ( DirectDownloadAnswer) is useless, the warning is already available.
The docs indicate that we're not using the raw type.
This should be a static method.
nit: this should be a separate hot function, similar to the one below
nit: this should be a separate hotfix commit.
I think we should use AmbiguousSymbolImpl.isBindingUsage() here.
I think we should use AmbiguousSymbolImpl.initSymbol() here.
I think we should use AmbiguousSymbolImpl.isBindingUsage() here instead.
Do we need to check here?
"not implemented"
Do we need to log this?
remove from the local cache. Publish.
remove from here. WDYT?
remove from here - it doesn't create a new object.
This seems bad. The value in the composite block will never be drawn.
This seems bad. The value of the tree will be more readable.
This seems bad. The value in the composite block will never be ShapeNodeEditPart.
this is a larger change. if I handle the case when the exception is translated into an exception the current exception is not handled.
this is a larger change. if I handle the case when the exception is handled and wrap it with another exception that will be handled.
this is a larger change. if I handle the case when the exception is translated into an exception the current logic is to handle the case.
Could the cipher suite be made configurable?
Just generate a KeyPair here instead of thrice.
Just generate a KeyPair here instead of using KeyPairGenerator instead.
typo in var name
rename to launch
typo in var name " launch"
Since you are using this variable, can you refactor it to a local method and call it from the method?
Since you are using this variable, can you refactor it to a local private method and call it from the method?
Since you are using this variable, can you refactor it to a local method and call it from the method please?
This should be removed
This is a formal debugging statement that should be removed.
This is a pretty low-level debug statement that should be removed.
Replace these 3 lines with an assert please.
Replace these 3 lines with a single argument constructor
Should be an extra or two
Method name should be renamed.
Method name should be renamed to html
Method could be called with no name
I think we want to use class.getName() to generate the package name.
I think it's better to do a.trim() to make sure people are sure it's not only imported types.
I think it's better to do a.trim() to make sure people are sure it's not only importedTypes.
I'm not sure how much this can work if it's an aggregate by default. CalciteUtils.isAggregateFunctionSupported(aggCall.getAggregation())) return false; if (input.getGroupType()!= Group.SIMPLE) return false; else if (input.getGroupType()!= Group.SIMPLE) return true; else return false;
I'm not sure how much this can work if it's an aggregate by default. CalciteUtils.isAggregateFunctionSupported(aggCall.getAggregation())) return false; if (input.getGroupType()!= Group.SIMPLE) return true; else return false;
I'm not sure how much this can work if it's an aggregate by default. CalciteUtils.isAggregateFunctionSupported(aggCall.getAggregation())) return false; If the agg call list is empty, throw an exception.
Use 71 instead.
Use 71 too.
Use 71
no need to load the appender
why do we need this?
no need to load the appender for each test
Use GoPluginApiRequest. <LINK_0>
Consider using GoPluginApiRequest here
Use GoPluginApiRequest instead of passing null here.
Should wrap the original alias in a.collect(Collectors.joining(",")).map(Map.Entry::trim).toArray(String[]::new);
Should we instead return an empty set?
Should we instead return an empty set here?
You should use.setText("and gains trample until end of turn"), otherwise the text is gonna be all wrong
You should use CSS with the BoostTargetEffect here.
You should use.setText("and gains trample until end of turn"), otherwise the text is gonna be inconsistent.
setErrorMessage
setting is not necessary. Process should be used for that.
setting is not necessary. Processtrace to log message?
maybe you should not have to cast this to PatchsetCreated if you change it. This is why the class was generated but the message was not generated.
maybe you should not have to cast this to PatchsetCreated if you change it. This is why the class was generated?
maybe you should not have to cast this to PatchsetCreated if you change it. This is why the class was generated but the message was not updated.
Should this not be set?
This is not a good idea. If this is only used for testing, this is a PR that I don't think this is necessary.
This is not a good idea. If this is only used for testing, this is a PR that I don't think this is a good idea.
Is it possible to avoid duplication this code?
Is it possible to avoid code duplication and consider moving this logic into the searchCategoryFragment class?
Is it possible to avoid duplication of this code?
while at this, could you simplify this statement to throttleDown == rateInSecs > desiredRatePerSec? (IntelliJ suggests this).
while at it, could you simplify this statement to throttleDown == rateInSecs > desiredRatePerSec? (IntelliJ suggests this).
while at this, could we simplify this statement to throttleDown == rateInSecs > desiredRatePerSec? (IntelliJ suggests this).
This should be set as "".
This should be set as default:
This should be set as a default case too.
You may want to expose a mechanism for the client to cancel the AsyncTask or at least suppress the dialog show behavior. It looks like the easy way here would be just to expose a setter on Callback and do nothing if it's null when the asynchronous operation completes.
We may want to expose a mechanism for the client to cancel the AsyncTask or at least suppress the dialog show behavior. It looks like the easy way here would be just to expose a setter on Callback and do nothing if it's null when the asynchronous operation completes.
You may want to expose a mechanism for the client to cancel the AsyncTask or at least suppress the dialog show behavior. It looks like the easy way here would be just to expose a setter on Callback and do nothing if the asynchronous operation completes.
again, why is this done in the constructor?
again, why is this done here?
again not sure why you are doing this, but why not just pass the original format?
You can make this synchronized instead of the try-catch block.
You can make this synchronized. This method is un-entrant.
You could make this synchronized instead of the try-catch block.
I think the Java 8 way is as below: List<T> list = Arrays.stream(items).map(item -> (T)item).collect(Collectors.toList());
I think the Java 8 way is as below: List<T> list = Arrays.stream(items).map(item -> (T) item).collect(Collectors.toList());
Can be replaced with Stream#of()
style nit: we don't use braces around single line blocks
style nit: space after if
formatting
This assertion seems to be redundant since the new users collection is created for each user.
This assertion seems to be redundant since the new userDao.saveOrUpdate(john) method is called twice.
This assertion seems to be redundant since the new userDao.saveOrUpdate(john) method is called before the test
The - DetectedLanguageList can be null, you should check that it is correct.
The - DetectedLanguageList can be any better than theDetectedLanguageList.get(i) - this should only validatePrimaryLanguage if we have a primary language.
The - DetectedLanguageList can be null, you should check that it is correct and better to throw an exception or better, if it is not possible.
This is invalid output.
This is invalid output, should be asserted
This is invalid output
Why not return the result of the method, and then remove the if statement?
Why not return the first parameter?
Why not return the result of the method, and then remove the first if statement?
should we handle this?
should we handle the exception?
This is going to cause an exception to be thrown.
Another case to be consistent with the other tests: 1. Remove the public modifier. 2. Remove the public modifier from this class and use the fields directly.
Another case to be consistent with the other tests: 1. Remove the public modifier. 2. Remove the public modifier from this class and use the methods directly.
Another case to be consistent with the other tests: 1. Remove the public modifier. 2. Remove the public modifier from this test class.
Why did you switch to getAbsoluteCharPosition?
This shouldn't be needed.
This code can be placed in 'else'.
You should verify that the result is correct as well.
Why is this test necessary? It seems to me that we assert the number of threads returned by the method?
You should verify that the result is correct.
Probably want to set to false and then reset to true.
Probably want to pass the cause exception in here.
Probably want to pass the cause exception in here if it's null.
Do you think this still needs to be connected with vdsm?
It might be better to verify that this finally block is not called when expected.
Do you think this line is necessary since it is already connected with getDevicecurrentThread().
you can use CollectionUtils.isNotEmpty()
Just from my point of view, we should not add one big method to this block (lines 69-78).
Just from my point of view, we should not add one big method to this block.
Fix cyclomatic complexity sonar issue
Extract hasMbusDeviceTypeIdentification() and hasParticipantNumber() into separate methods.
Extract hasMbusDeviceTypeIdentification() and hasPbusVersion() into separate methods.
this is a change of behaviour, the getSourceExecutionCourse() may return null.
this is a change of behaviour, the sourceExecutionCourse is still null
this is a mistake...
This should be done in a finally block.
I think this should be: prefs.flush();
This should be done in a finally block. Otherwise, the caller might be responsible for handling the exception.
DtoFactory.createDto(LocationDto.class) dtoFactory.createDto(LocationDto.class)
Dto constructor is enough, you can inline parameter
Dto constructor is enough
This "synchronized" seems not needed as TLSNIOWriteStream.shutdown() already protects it.
This "synchronized" is not needed as TLSNIOWriteStream.shutdown() already protects it.
nit: you could do a frame.release(); here in case of an exception, because the frame is not canceled.
I'm fine with leaving this as it was. But even if you don't support the "host {} wasn't supported as it doesn't support this VM.
I'm fine with this patch since it's not related to this patch. But please add the host's version to the messages list.
I'm fine with this patch since it's not related to this patch.
We could potentially replace: if (targetFS.hasBeenInUse()) { return true; }
We could potentially replace: if (targetFS.hasBeenInUse()) { return false; }
We could potentially replace: if (targetFS.hasBeenInUse()) { return true; } )
You can probably do: long column = endTimeNS == null? 0 : getNodes().get(0).getBaseTime();
You can probably do: long column = endTimeNS == null? 0 : endTimeNS; Long node = getNodes().get(i);
You can probably do: long column = endTimeNS == null? 0 : getNodes().get(0); long endTimeNS = getNodes().get(0).getBaseTime();
I'm not sure this is correct. For example, it would be nice to update the message to: "Invalid event: {code} Unhandled error: {}"
I'm not sure this is correct. For example, it would be nice to update the message to: "Invalid event: {}"
I'm not sure this is correct. For example, it would be good to update the message every time, and then instead of just the message every time.
looping over sequentialDocId and NUM_DATA seems like it just doing: java for (int i = 0; i < sequentialDocId; i++) { if (i>0) { } }
looping over sequentialDocId and NUM_DATA seems strange. Why not just use NUM_settings?
looping over sequentialDocId and NUM_DATA?
given/ execute/ assert
would it be better to use assertAllInIndex(1, 3, 3, "Expected 0, 0") here?
would it be better to use assertAllInIndex(1, 3, 3, 4)
you can use RefreshActionListenerRegistry.INSTANCE.
you can use NLS.bind()
you can use SubMonitor.runInShell()
Please rename to organization.
I wouldn't call this method with all the details
I guess you should drop this line
Add newline before return.
Add newline before return..
Add newline before return
Instead of adding this to the HostControllerLogger, could you add a method to HostControllerLogger to get this error handling?
Instead of adding this to the HostControllerLogger, could you add a method to HostControllerLogger to throw this exception so the stack trace would be easier to debug.
This can be written as a for-each loop
Maybe catch NuxeoException as well?
before catch, please catch NuxeoException?
Maybe catch NuxeoException for better logging?
Maybe you can use the StringBuilder here?
Maybe you can take the name from the solver config here, if it's going to be too long?
Maybe you can take 'name' as the first argument?
The empty string is not needed here, no?
The empty string is not good - no?
The empty string is not good, no? Is there a way to log this?
We don't need this queryBuilder as you are already doing this.
We can use the constants for this without setting them here. I think we should also be consistent.
We don't need this queryBuilder as you are doing below.
Won't this also add a generalization to the BigDecimal.length in this case? I think that's wrong.
Won't this also add the BigDecimal.valueOf() call to the BigDecimal constructor?
Won't this also add a generalization to the BigDecimal.length in this case? I think it's problematic for the user to see a problem with the addition of the toString() call.
The current should be closed after the while loop.
The current should be closed after the while loop otherwise there is no chance of closing it.
The current should be closed after closing it
This change is problematic. The lease doesn't own the error stack (or any other reason why it's necessary to give it to the user).
This is problematic if the lease doesn't own the error message, as it causes an endless loop if there is no t defined. The reason, it's best to just print the stack trace and add it to the log statement.
This is problematic if the lease doesn't own the error message, as it causes an endless loop if there is no t defined. The reason, it's best to just print the stack trace and add it to the log statement, so that we can easily see the exact stack trace in the logs.
Add final keyword.
Add final keyword. Please use DolphinRuntimeException.
Same here. Add final keyword.
Please use a better name (primaryKeys, primaryKeyColumns).
Can't we use a better name (primaryKeys, primaryKeyColumns).
Can use a better name (primaryKeys, primaryKeyColumns).
You have removed the access to the storage_server_connections_per_host=StoragePool.class
You have removed the access to the storage_server_connections_per_host.
I don't understand this change.
Can we use a where clause here instead of.equals?
I think this should be Keyed.getMISSING_UUID()
I think this should be.equals
use variable for 'boolean'
use parameterized logging instead of string concatenation
use parameterized logging
Can you use String.valueOf instead of String.valueOf?
Can you use String.valueOf(String) instead of String.valueOf(String.valueOf(retention.toMillis))
Can you use String.valueOf(String) instead of String.valueOf(String)
use this utils method to show error <LINK_0>
use this utils method to show error <LINK_0> to show error <LINK_1>
use this utils method to show exception <LINK_0>
if ((persistKey == null))? : 0)
if ((persistKey ==...)?
if ((persistKey ==...)? 0 : 0);
Same here messager should never be null. Otherwise we can't report.
Same here messager should never show. Otherwise we can't report.
Same here messager should never be displayed. Otherwise we can't report.
Shouldn't this be "OpacPpns" instead of "\r"?
Shouldn't this be "OpacPpns" instead of "r"?
Shouldn't this be "OpacPpns cannot be null"?
nit: error message is not needed.
nit: error message is not used.
nit: remove empty line
This could be replaced with Player player = new Player(player.discard(amount, sourceId, ability, game).getCards());
This could be replaced with Player player = new Player(player.discard(amount, true, ability, game).getCards());
This could be replaced with Player::discardToDiscard.
@kirankumarkolli - you need to update this file with the proper spotbug issue which is failing here : <LINK_0>
@kirankumarkolli - you can update this file with the proper spotbug issue which is failing here : <LINK_0>
@kirankumarkolli - you need to update this file with the proper spotbug warning which is failing here : <LINK_0>
space
Why change?
space?
Could use a linked list here with computeIfAbsent
Could use a linked list here with the problem [1]
Could use a linked list here with the size of the list
This is not the same as superInjectionTarget.injectionMap.
This is not the same as "else". It will be better to "there is ainjection present.
This is not the same as super.injectionMap.remove(null)
How the flow get in here?
How the flow get break if returns false?
How the flow get in here? Will this ever happen?
We should have an early return here if the flush fails. The try-catch can be moved outside the for loop, but it's not a closed exception, which would be confusing.
We should have an early return here if the flush fails. The try-catch can be moved outside the for loop, but it's not a closed exception, since the close() will have already thrown it.
We should have an early return here if the flush fails. The try-catch can be moved outside the for loop, but it's not a closed exception, since the finally block will be invoked.
non-null check is redundant here, e.g. bindings.getConcurrency()!= null
non-null value should be the default value.
non-null value should be the first check.
Shouldn't the backup file be deleted as well?
Shouldn't you use the backup file as well?
Shouldn't the backup file be deleted to the temp file?
Might be more useful to add a link here, in case we're going to add new models.
Might be better to add a "Metastore" message in case we're not reading the JSON.
Might be more useful to add a link to the message.
I'm a bit worried about this one. Can we change the HiddenPreferences instead? For instance, if we're going to pass this as an argument to the logger, wouldn't this be enough to support this?
I'm a bit worried about this one. Can we change the HiddenPreferences instead? For instance, if we're going to pass this as an argument to the logger, wouldn't this be enough itself?
I'm a bit worried about this one. Can we change the HiddenPreferences instead? For instance, if we're going to pass this as an argument to the logger, wouldn't this be enough?
list.sort(Comparator.comparingLong(ps::getUri));?
list.sort(Comparator.comparingLong(ps::getUri));
list.sort(Comparator.comparing( ps1, PermissionSet::getUri));
This could also be a little more user friendly with Secret.fromString(String)
This could also be a little more user friendly by using Secret.fromString(String)
This could also be a little more user friendly with Secret.fromString(String) in the test now
you can use NLS.bind() here
you can use LabelsGeneratorInput.java
you do not need this line
Can you use GTK instead? Is it possible to wrap this in an if instead?
Can you use t.nedLanguage instead? Is there a real environment instead of hardcoded levels?
Can you use GTK instead? Is it possible to use windowd in this context? I thought it would be less readable, of course, but at least, if this is a constant.
suggestion final DomainViolation last1 = violations.get(violations.size() - 2);
suggestion final DomainViolation last1 = violations.get(violations.size() - 1);
suggestion when(v.getUUID()).thenReturn("null");
Are we guaranteed that we'll take a YamlMappingImpl instance here?
Does this mean that we compute both YamlMapping and YamlMapping here? Aren't we just checking for instanceof YamlMapping here?
Are we guaranteed that we'll be avoiding a recursive call?
Can we avoid the security manager creation if the security is not enabled? Should we just store this in a static field?
Is it possible for no security to be running on a security manager? Should we check for presence or absolute path?
Is it possible for no security to be running on a security manager? Should we check for presence or absolute?
- Have you considered using.stream() on the value of a map? - Have you considered adding the value to the map?
- Have you considered adding the value of the map to the end-user? - Have you considered adding the value to the map?
why not just use.keySet()?
what if processor.process() returns false?
what if processor.process() returns true?
what if processor.process() returns true? we still need to return the first state.
This check is not needed
This check should be removed
this check is redundant
The call to 'getRandXySquare' is useless now.
The call to 'getRandXySquare()' is missing.
The call to this line is wrong.
2 corrections: 1. Static imports 2. Have this to be done via a new method, since it won't change its signature
2 corrections: 1. Static imports 2. Have this to be done on the entire class, since it won't change its implementation
static import
We can use the empty() method to avoid all the boilerplate.
We can avoid empty() by using Stream.empty()
We can use the empty() here
why are we catching the InterruptedException here and throwing it at the end?
why are we catching the exception here and throwing it at the end?
why are we catching the exception here and throwing it at the next line?
We should be using something like _error_ here, too.
Can we use a constant here?
We should be using something like _error_ and _error__.
Passing in a timestamp here as well, this method doesn't seem to make sense to me.
Passing in a timestamp here as well.
Passing in a SQL query here as well.
Are these extra checks necessary since they all extend this if statement
Are these extra checks necessary since they all extend NumberBasedOptions?
Are these extra checks necessary since they all extend this if statement?
builderInfo.get( 0 );
builderInfo.get( 0 ); does not seem to be used.
builderInfo.get( 0 ); does not seem to be needed
Please change to: LOG.error("verifier time out, {}: {}", Thread.currentThread().getStackTrace());
Please consider using Collections.singletonList() instead.
Please, consider to use Collections.singletonList().
we should not be closing in finally block
we should not be closing this stream
we should not be closing JavaSE-...
for comparison with an enum it's better to use ==.
for comparison with an enum it's better to use ==...
for comparison with an enum it's better to use ==....
This is hard to read. What about moving both d.py and d.py to a new line?
This is what we tried.
This is hard to read. How about we test the case of this then?
Instead of your assert, just verify that the GetAuthInfoAction was actually called. If you want to assert that the GetAuthInfoAction was successful, you probably don't need this call at all.
Instead of your assert, just verify that the GetAuthInfoAction was actually called. If you want to assert that the GetAuthInfoAction was successful, you probably don't need to call assertFalse.
Instead of your assert, just verify that the GetAuthInfoAction was actually called.
should we also add a check for config.inputField in the error message?
should we also add if (inputSchema.getField(config.inputField) == null) so that users can diagnose the problem?
should we also add if (inputSchema.getField(config.inputField) == null) so that users can diagnose the problem
typo: continuator
typo: continuator instead of getMessage
typo: continuator instead of getPath
I would change the maxSizePercent to a long for clarity.
I would change to 50 for clarity.
I would change the maxSizePercent to a long.
I will go to WARNING log instead of e.printStackTrace()
I will change this to log.debug() instead.
I will change this to log.debug()
Why not just call System.err? if there are exceptions that are thrown out of the try block?
Why not just call System.err? if (reader!= null) {
Why is this method public? if there are no other methods, shall we make it private?
you could use the same uri for both of the test cases
you could use SoftAssertionsUtil.assertThat for a more concise way
you could use SoftAssertionsUtil.assertThat for a more explicit way
Must be object.change(db)
Must be object.change(db). The Change can be null if the object is not found.
Must be object.change(db) here.
final
rename to eReference
rename to ecore
It should be included in the test.
Type param?
It should be included in the test
Please always use curly braces, even for one-liners.
Please always use curly braces, even for one-line if statements
braces
We'll also have to catch RuntimeException here.
We also have to catch RuntimeException here.
Either with default or we should continue using the registry.
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this expression which always evaluates to "true" [![rule](<LINK_2>](<LINK_0>
Shouldn't this be a.delete()?
Shouldn't this be a.delete()? <LINK_0>
You can use assertEquals(expected, actual) here.
{} better
{}
Why assign it to a local variable?
You know it's not part of this patch, but why not use the sub-projects?
You know it's not part of this patch, but why not add it to drive here?
Why is it necessary to make it the same?
This This does not work because of this line.
Why is it necessary to make it the default for all cases?
this is not a good way to fix it. convertField already has a switch statement on the field type, you shouldn't duplicate that logic here, and shouldn't be creating a new transformer for each recursive call. Instead, just remove the output field field completely. The avro schema should always be calculated from the cdap schema.
this is not a good way to fix it. convertField already has a switch statement on the field type, you shouldn't duplicate that logic here, and shouldn't be creating a new cdap schema.
Unnecessary change?
what's the point of setting zkConnectionTimeout to 0?
what if kUtils.getAllBrokersInCluster(zkClient) throws exception?
what's the point of setting zkConnectionTimeout to 0 in this case?
Please add a space after the comma.
Please add a space after "if"
Please add a space after the cast.
You should use assertThat() as well, for better readability of assertion failures
You should use assertThat() here as well, for better readability of assertion failures
You should use assertThat( assertThat(...) ).isSameAs(...) instead of assertThat(...).
now that we have the random ID of the snapshot, I think it's better to name it ignite.context().cache().Context().cache().context()
now that we have the random ID of the snapshot, I think it is better to put this in IgniteUtils.nl() which has the generic level.
rename to 'block'
Why are you printing the stack trace?
Why are you printing the stack trace to console?
Why Data Service :" + msgContext.getServiceContext().getName()
If I understand correctly then this will set the value from the users list. We can probably simplify the code by creating a new list and then setting the value to null.
If I understand correctly then this will set the value from the users list. We need to avoid using hard-coded as the client can handle parameters.
Use more descriptive variable names.
Style-nit: extra curly braces
Style-nit: extra curly brackets
Do we need to check null here?
This can be replaced with UuidUtils.fetchUUID(String, String)
This can be replaced with UuidUtils.fetchUUID(String,String)
This can be replaced with UuidUtils.fetchUUID(String)
I think this can be rewritten as: java return casts.stream().allMatch(Boolean::booleanValue);
I think this can be rewritten as: java return casts.build().stream().allMatch(Boolean::booleanValue);
I think this can be done in a lambda
Shouldn't this be ts - ts - ts + 1?
Shouldn't this be ts - ts - ts - ts + 1?
Shouldn't this be ts - 1, why do we have to do it for every frame?
Use G.strings instead of sysout
Use Logger. sysout.
Use G.strings.
We should do it only when this page is enabled and not when it is enabled.
We should do it only when this page is enabled and not when it is disabled.
We should do it the same way as we did it above.
please use curly brackets for the if condition
please use curly brackets for the if statements
Please use curly brackets for the if statements
KClient validations are necessary here, right?
KClient validations are required here, right?
Wrong method name?
Break into multiple lines
Break into multiple lines for readability.
Break into two lines
I think this should be left out of this PR in favor of making the TwitterErrorHandler respect the Twitter4j RateLimitStatus reset time. I'd say to put this back to 10.
I think this should be left up to 10. I think this should be fine.
I think this should be left out of this try block.
For now we should keep this method package visible only
For now we should keep this line package visible only
For keep this method package visible only
Why is this no longer needed?
Why is this no longer necessary?
Why is this needed?
This (and following statements) should be done in the if statement
This (and following statements) should be done in the layout, like it was before
Let's name this property does not change
The indentation level shouldn't be changed.
This indentation level shouldn't be changed.
The indentation level shouldn't be changed. >
Maybe better to have a better name for the variable: "foundToken".
Maybe better to have a better name for the variable like "foundToken".
Maybe better to just catch Exception, since we are ignoring the exception later.
We don't need check for null.
we don't need check for null.
We don't need to check if the type of LedgerMetadataVersionException is possible.
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the file).
Better to get the bytes with StandardCharsets.UTF_8 (that's what will be used to read the file)
Better to get the compatibility with StandardCharsets.UTF_8 (that's what will be used to read the file).
suggestion final String pathAndNode = pathAndNode.getPathAndNode(path);
Perhaps we should have a log message here saying that the path was not found.
Perhaps we should have a log message here saying what's the actual path and message?
There is no need to use this, it is already defined in the method
I'd make this final.
Should we use the constants here?
This should get the containsKey(partition) implementation right?
This should get the containsKey(partition) implementation to make use of containsKey.
This should be @Nullable, right?
Use StringBuilder.append() instead of append()
Please remove it.
Use StringBuilder here.
if the view is already in the presenter, shouldn't we just copy and reuse that here?
if the view is already in the presenter, shouldn't we just move this above?
if the view is already in the presenter, shouldn't we just copy and reuse that?
This call should not be done before we set the initial datya received. Also, this call should be done from the FilesTabView class
This call should not be done before we set the initial datya received. Also, this call should not be done from the FilesTabView class
This call should not be done before we set the initial datya received.
Does this mean that statement.isClosed() is useless?
Can you change this to an if statement.isClosed()?
Can you change this to an if statement.isClosed() statement?
Use logging instead of string concatenation.
Use isBlank method or isEmpty method.
Use isBlank method or isEmpty instead of ""
toOSString() gets platform dependent path - Consider the case where you are looking at shared index location and if shared index is available, then you won't get a different URL if it is platform dependent - shouldn't this be toPortableString()?
toOSString() gets platform dependent path - Consider the case where you are looking at shared index location and if shared index is available, then you won't get a different URL if it is platform dependent - shouldn't we use toPortableString()?
toOSString() gets platform dependent path - Consider the case where you are looking at shared index location and if shared index is available, then you shouldn't return null.
Is the L.e(caught) needed?
This can be removed.
Is the old la new line?
This should be a specific exception.
Is this missing a return statement?
This should be a return.
I don't think you need to update the.json test here since when you're done with it anyway, we don't need to do it here and below.
I don't think you need to update the.json test here since when you're done with it, the AMQP 1.0 won't change on the protocol.
I don't think you need to update the.json test here since when you're done with it, the AMQP 1.0 won't make sense if the JSON is present too
@HeartSaVioR If there is a default value of "null" then the binding would be different from the one in the active form, and do not initialize them with null.
need to check containsKey
need to check containsKey()
there is no need for this variable.
There is no need for this variable.
There is no need for all these variable initializations.
Feels like this could fit on one line.
To me it seems clearer to make conditional nodes more clear if they want to set a minimum access time limit rather than an egress mode.
To me it seems clearer to make conditional nodes more clear if they want to set a minimum access time limit.
should be done in a finally block
looks like StormBase can be null, and should be not used.
looks like StormBase can be null, and should be not reused.
Please use the formatter, or change this to: java } catch (Throwable t) {... }
Please use the formatter, or change this to: java if (client == null) { return; }
Please use this formatter if it's only 1 statement instead of multiple.
maybe add the types in the message?
maybe add the types in the message for tracking the id and the instance id.
maybe add the types in the message for tracking the id and the instance id
Since it is used multiple times, make this a separate function returning List<SampleRowKeysResponse>? - try (BigtableSession session = new BigtableSession(bigtableOptions)) { - BigtableClusterName clusterName = bigtableOptions.getClusterName(); - BigtableTableName tableName = clusterName.toTableName(configuration.getTableId()); - SampleRowKeysRequest.Builder request = SampleRowKeysRequest.newBuilder(); - request.setTableName(tableName.toString()); - List<SampleRowKeysResponse> sampleRowKeys = - session.getDataClient().sampleRowKeys(request.build());
Since it is called multiple times, make this a separate function returning List<SampleRowKeysResponse>? - try (BigtableSession session = new BigtableSession(bigtableOptions)) { - BigtableClusterName clusterName = bigtableOptions.getClusterName(); - BigtableTableName tableName = clusterName.toTableName(configuration.getTableId()); - SampleRowKeysRequest.Builder request = SampleRowKeysRequest.newBuilder(); - request.setTableName(tableName.toString()); - List<SampleRowKeysResponse> sampleRowKeys = - session.getDataClient().sampleRowKeys(request.build());
Since it is used multiple times, make this a separate function returning List<SampleRowKeysResponse>? - try (BigtableSession session = new BigtableSession(bigtableOptions)) { - BigtableClusterName clusterName = bigtableOptions.getClusterName(); - BigtableTableName tableName = clusterName.toTableName(configuration.getTableId()); - SampleRowKeysRequest.Builder request = SampleRowKeysRequest.newBuilder(); - request.setTableName(tableName.toString()); + List<SampleRowKeysResponse> sampleRowKeys = - session.getDataClient().sampleRowKeys(request.build());
This is not needed anymore, java.lang.IllegalArgumentException at org.junit.platform.commons.lang3.exception.UnregisteredException.
This is not needed anymore, java.lang.String would be more appropriate.
This is not needed anymore, java.lang.String would be better.
You can do: if (fSashDragListener == null) { fSashDragListener = new Listener() { @Override public void paintDoubleClick(Event event) {
lambda?
You can do: if (fSashDragListener == null) { return; }
When did we start supporting yodacy? I didn't think that was supported in the current version of this project.
When did we start supporting yodacy? Was that added recently?
When did we start supporting yodacy? I didn't think that was supported in the current version of PR yet.
Since keyFile,passwd & alias are used for both methods, I think it will be nice to put them as private (final) members of the class
Since keyFile,passwd & alias are used for both method calls, I think it will be nice to put them as private (final) members of the class
Since keyFile,passwd & alias are used for both methods, I think it will help to put them as private (final) members of the class
Warn log level seems to high for a normal state transition.
This seems a bit surprising. Let's discuss.
Warn log level seems to high for this case.
should this move into the finally block?
should this move into the loop?
should this move to the finally block?
Why is this not using gethreadLocalRandom()? They seem to do the same thing.
Why is this not using new Thread? They seem to do the same thing.
Why is this not using the value? They seem to do the same thing.
Again, we should be careful about using a ReviewDb. This may be overkill for a performance regression. ReviewDb.open returns an actual cache instance.
Again, we should be careful about using a ReviewDb. This may be overkill for a performance regression. ReviewDb.open() returns an actual list of project names that have not been found.
Isn't we better off just using value == null?
Please, remove extra line.
Please, use just waitForElementInTheModel method.
See above.
Alex will say to use a view to access the items, though initializing with an initial capacity a bit higher than the number of items it will contain may make ArrayList more efficient. But Sets is also a good option, since you do not care about the order and it will avoid duplicates. But I would not block a patch for such a reason. Others may though... ;-)
Alex will say to use a view to access the items, though initializing with an initial capacity a bit higher than the number of items it will contain may make ArrayList more efficient. But Sets is also a bad option, since you do not care about the order and it will avoid duplicates. But I would not block a patch for such a reason. Others may though... ;-)
Alex will say to use a view to access the items, though initializing with an initial capacity a bit higher than the number of items it will contain may make ArrayList more efficient. But Sets is also a bad implementation.
Is this loop actually required? Couldn't the for loop also be replaced with a for-each loop?
Is this loop actually required? Couldn't the for loop just be replaced with an iterator?
Is this loop actually required? As I understand the original code the for loop suggests the _for_ loop was missing.
Could be inlined
could be factorized
could be inlined
Check if this inside testConnection
Check if this inside the loop
Check if this inside the loop?
This should now be done with an Unsupported op.
This should now be done with an Unsupported op exception.
This should now be removed
I think we should remove the tabs here as they are deprecated, but let's remove the existing code as well, which can be removed.
I think we should remove the tabs here as well, but let's remove the tabs from the code as well, which can be removed.
I think we should remove the tabs here as they are deprecated, but let's remove the existing code as well, which can be deprecated
Might be clearer to just do dialog.setFilterExtensions(new String[] {"*." + missingFileParts.getExtension()});
Might be clearer to just do dialog.setFilterExtensions(new String[] {"*." + missingFileParts.getExtension()}));
Might be clearer to just do dialog.setFilterExtensions(new String[] {"*." + missingFileParts.getExtension()})
Is there a reason why you don't use a sleep like this to avoid the stop() call?
Is there a reason why you don't use a sleep like this to stop the controller, rather than the one below?
Is there a reason why you don't use a sleep like this to stop the controller?
please replace with: new ArrayList<>(lunsToResize);
s/ lunToVds/host
please replace with: new ArrayList<>(lunsToResize);.
The macs are always added in the compensation state but not in the compensation state. So if you remove the mac, the compensation parameters will remain.
The macs are always added in the compensation state but not in the compensation state. So if you remove the mac, the compensation parameters are not being used.
The macs are already added in VmInterfaceManager.
So hideTopMenu isn't hide by default?
So hideTopMenu isn't hide by pressing the button?
So hideTopMenu isn't hide by default as a file Selection?
Wondering if there's a better way to handle this exception as well. Like move it to the if block above. 1. move this to a UtilMethods.isSet(emailAddress) method that you added below. 2. move the if block into the else block because you added the else clause like this one. 3. move the if block into the else block because you added the else clause which will make the code more readable.
Wondering if there's a better way to handle this exception as well. It seems like this is nice to use the logger for the user.
Wondering if there's a better way to handle this exception as well. Like move it to the if block above. 1. move this to a UtilMethods.isSet(emailAddress) method that you added below. 2. move the if block into the else block because you added the else clause like so: if (CollectionUtils.isNotEmpty(list)) {... }
please rename the field; remove the fessor.
please rename the field and use it everywhere, no?
please rename the field; remove the fessor field.
let's rename this variable to relationshipTypeUuid
let's rename this variable to relationshipUuid
check that the person uuid is equal to the uuid
If this check is hit, it would be nice to simplify the code and include the "else if"?
If this check is hit, it would be nice to add a null check and "return null" to the above check to avoid NPEs.
If this check is hit, it would be nice to simplify the code and include the "else if" so it will be used only once.
I don't feel it right that in a class delivered by our library we have a method not signalled with @Nullable that returns a null. Of course we don't have anything meaningful to return because it's a fake client... But checking the code I see that in one of the methods there is one SphereApiConfig with fake data. Maybe we can go on that line and provide a dummy config with a project key and API URL that leaves no doubt this is a fake config. Maybe @katmatt has a better idea?
I don't feel it right that in a class delivered by our library we have a method not signalled with @Nullable that returns a fake client... But checking the code I see that in one of the methods there is one SphereApiConfig with fake data. Maybe we can go on that line and provide a dummy config with a project key and API URL that leaves no doubt this is a fake config. Maybe @katmatt has a better idea?
I don't feel it right that in a class delivered by our library we have a method not signalled with @Nullable that returns a null. Of course we don't have anything meaningful to return because it's a fake project... But checking the code I see that in one of the methods there is one SphereApiConfig with fake data. Maybe we can go on that line and provide a dummy config with a project key and API URL that leaves no doubt this is a fake config. Maybe @katmatt has a better idea?
Use [ExpectedException](<LINK_0> here.
Use [ExpectedException](<LINK_0>
This is unnecessary.
shouldn't this be read from the channel?
shouldn't this be in a getter?
shouldn't this be getDelayedAsyncConnection?
We should pass in the name?
We should pass the name?
We should pass in the name we pass in the worker instead of doing this.
we should throw exception here? Or it could be bad behavior
we should throw exception here? Or it could cause exception to call vra.init correctly?
isNewMessageUpdated == true?
No need to define it here - it is runtime exception.
No need to define error message here - it is runtime exception.
No need to define it here - it was runtime exception.
suggestion throw new AssertionError("Clone should never cause an Invalid SPDX Exception", e);
Suggestion: That's a bit more expressive and readable, I'd use an expected exception (e.g. IllegalArgumentException) instead of an AssertionError.
Suggestion: That's a bit more expressive and readable, I'd expect an AssertionError instead of an AssertionError.
Remove the nesting here by moving the return of the get() and return here.
Remove the nesting here by moving the return of the get(0) and return here.
Remove the nesting here by moving the return of the get() up into the first line.
Or, assertThat(category.getAttributes().get("Title").getValue(), is("The Title")); because it will print a more useful message when the test fails.
Or, assertThat(category.getAttributes().get("Title").getValue(), is("The Title")); because it fails if the categories don't match.
Or, assertThat(category.getAttributes().get("Title").getValue(), is("The Title")); (this might also be a bit more readable!)
I think this could be more readable as: java if (toCopy == null) { throw new NullPointerException("toCopy == null"); }
I think this can be shortened toCopy.annotations!= null? toCopy.annotations : null.
I think this can be shortened toCopy.annotations!= null? toCopy.annotations : null;
Lets call Arrays.ensureCapacity(is.available()) instead.
else: also space between ) and '('
use System.arraycopy()
Providers of this class are public, so I would prefer to move it to a separate class.
Providers of this class are public, so I would prefer to move it to the external API.
Providers of this class are public, so it should be private?
the sql statments should be in a db transaction
this statement can be moved inside the if ()
this statement can be removed
call isEmpty()
order of operands
call.add(ecAction)
Need to close the stream in finally block.
Need to close the stream in finally block to ensure it's closed.
Need to close the stream in finally block
This is not an issue, it should be fixed in a separate commit.
This is not an issue, it should be fixed by changing the value of host.getHost() to "https-remoting".
This is not an issue, it should be fixed by changing the value of host.getHost() to host.port().length
Prefer using "Internal Server Error." and not "Internal Server Error.". suggestion
Prefer using "Internal Server Error." and "Internal Server Error.". suggestion
Exception#getMessage() is not required.
You can use a short explanatory name for all of these methods
You can probably use the distanceTo version in this case
You can use a short explanatory name for all of these parameters
Please use the generated body
Please use the generated body in the assertSent.
Please, use the generated body
Is this not needed?
Is this line redundant?
Is this needed?
this can be moved to the above for loop String message = new MetadataResponse("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
this will be better off in case of a null value value is null, the other code is to validate this.
this will be better off in case of a null value value is null, the other code is if this check is necessary.
Whitespace around if and else clauses
Whitespace around if and else statements
Formatting, remove
this equal is now redundant since you have already verified encounterDatetime.
this equal is now redundant since you have already verified encounterCreated
this equal is now redundant since you have already verified encounterDatetime is null
The frame.flags() should be true.
The frame.flags() should be < 0, I think.
The frame.flags() should be the first argument in this function.
Should not the above check be unnecessary?
Should not the above check be unnecessary since the getLabel() is never empty
Should not the above check be unnecessary since the getLabel() is always empty?
can you make this a final variable? It's not an unused key right?
can you make this a final variable? It's not an unused key out of the scope of the issue.
can you make this a final variable? It's not an unused key out of the scope of my ticket.
This should be input.status(status.name().toUpperCase()).
suggestion input.status(status.name().toUpperCase());
This should be input.status(status.name().toUpperCase())
why is this a single line?
why is this a single line? This will already compile.
how about a single line: this.
You can leave the return value as it was before, so the behavior is that if we get rid of this line, the merge logic will fail.
You can leave the return value as it was before, so the complexity of the method is better.
You can leave this as sparseSet to merge related to appropriate size change.
Consider moving this null check into the next if.
Consider moving this null check to the next line.
Is each mapping created on the same name?
I don't think we can change this 'll' commit on top of my head if we remove the post-start option. > AUTO_QUICK_START_OF_TIMES_TO_SHOW_QUICK_START_DIALOG; AUTO_QUICK_START_TEXT_MS can be removed.
I don't think we can change this 'll' commit on top of my head if we remove the post-start option.
I don't think we can change this 'll' commit on top of my head if we remove the element.
Just to make sure I understand it correctly We only optimizing simple projections/filters of a bucketed table into the other bucketed table? It doesn't look like it does at all.
Just to make sure I understand it correctly We only optimizing simple projections/filters of a bucketed table into the other bucketed table? It doesn't hurt to have a test case for this.
Just to make sure I understand it correctly We only optimizing simple projections/filters of a bucketed table into the other bucketed table? It doesn't hurt to have a test for this.
Group exception types handled identically in a single catch block.
Part of this class throws IllegalArgumentException and another part returns the exception.
Part of this class throws IllegalArgumentException and another part returns the error message.
nit: Its better to have such logic in DefaultCatalogReplicaLoadBalanceReplicaLoadBalanceReplicaLoadBalanceReplicaLoadBalanceReplicaLoadBalanceReplicaLoadBalanceReplicaLoadBalanceReplicaLoadBalanceReplicaLoadBalancePage.
nit: Its better to have such logic in one place.
Is it possible to keep config value in one place? Seems like we could have moved logic to the constructor
Please rename this to use of type
Please rename this to checkDataWithGeneration
Please rename this to checkRemote
why is it not just accoundId?
why is it not accoundId?
why is it not just accoundId?
assertNotEquals?
assert assertEqual?
assertEqual?
Since InvalidChangeOperationException cannot occur anymore, I think it would be nice to remove it from the method signature here. If we do this, we can also remove InvalidChangeOperationException from the AbandonChangeHandler.call() method.
Since InvalidChangeOperationException cannot be thrown anymore, I think it would be nice to remove it from the method signature here. If we do this, we can also remove InvalidChangeOperationException from the AbandonChangeHandler.call() method.
Since InvalidChangeOperationException cannot occur anymore, I think it would be nice to remove it from the method signature here. If we do this, we can also remove InvalidChangeOperationException from the AbandonChangeHandler.call().
@Josephblt in cases like this you can use a more functional code like List<String> uuids = elements.stream().map(Element::getUUID).collect(Collectors.toList()); I think it is easier to understand, but just as easier to read, I'd be fine.
@Josephblt in cases like this you can use a more functional code like List<String> uuids = elements.stream().map(Element::getUUID).collect(Collectors.toList()); I think it is easier to understand, but just as easier to read, I'd be fine with this code.
@Josephblt in cases like this you can use a more functional code like List<String> uuids = elements.stream().map(Element::getUUID).collect(Collectors.toList()); I think it is easier to understand, but just as easier to read, I'd be fine with this change.
Use slf4j if possible. If it is a common thing to be implemented, consider creating the predicate and make it injectable so other classes can benefit from it.
Use slf4j if possible. If it is a common thing to be named, consider creating the api and make it injectable so other classes can benefit from it.
Use slf4j if possible.
Checking this is probably redundant now when the label doesn't exist.
Checking this is probably redundant now when we return an Optional<LabelMeta>?
Is this the same as the other transform implementation?
Missing final
Missing a final
id
is it really needed?
is it really needed?
throws InterruptedException
WDYT about moving such code to InternalRuntime and do not bootstrap at all if installers are missed
Does it make sense to specify the path of the machine in the msg string as well?
maybe we can use here <LINK_0>
It's not consistent with the rest of the code, I think it should be: if (showSystemApp || ((info.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) { itemList.add(map); } else { itemList.add(map); }
It's not consistent with the rest of the code, I think it should be: if (showSystemApp || ((info.success & ApplicationInfo.FLAG_SYSTEM) == 0)) { itemList.add(map); } else { itemList.add(map); }
It's not consistent with the rest of the code, I think it should be: if (showSystemApp || ((info.success & ApplicationInfo.FLAG_SYSTEM)) == 0) { itemList.add(map); } else { itemList.add(map); }
nit: I think you can do this in a single statement as well.
nit: I think you can do this in a single statement as opposed to the lambda lambda
nit: I think you can do this in a single statement as opposed to using first lambda
should be "kalmonLatitude"
shouldn't this be "kalmonLatitude"?
shouldn't this be "kalmonLatitude"
the FileOutputStream and out should be closed in finally block
the FileOutputStream and out should be closed in a finally block
the FileOutputStream and out should be closed in a finally block.
Nit: I'd probably not use if for this just to be consistent with the rest of the code.
Nit: I'd prefer to avoid the ifs since they aren't needed
Nit: I'd probably not use if for this just to be consistent with the order of the items.
Please update this log message to be more generic.
I would rename this to something more generic, such as inFolderAvailableOffline
I would rename this to something more generic, such as openFile() or openFile()
Please split to multiple lines.
Can you please add isTraceEnabled check?
Please add isTraceEnabled check.
Device cannot be set on the command line. We should also verify the "try with an explicit device".
Device cannot have a centroid spec. We should also add a parameter to the "try" parameter to indicate the device.
Device cannot be set on the command line. We should also verify the action.
Wouldn't be better to use a logger?
Would be nice to remove this line
Wouldn't it be better to remove this?
You shouldn't need this catch block
You shouldn't need the catch here.
The path
tidied.size() -> tidied.containsAll(tidied))
tidied.size() -> tidied.containsAll(tidied)
tidied.size() -> tidied.get()
Can be simplified: java if (tree == null) { parseCompiledR(null, (TypeElement) element); } else { parseCompiledR(respectivePackageName, (TypeElement) element); }
Can be simplified: java if (tree == null) { parseCompiledR(respectivePackageName, (TypeElement) element); } else { parseCompiledR(respectivePackageName, (TypeElement) element); }
Can be simplified: java if (tree == null) { parseCompiledR(respectivePackageName, (TypeElement) element; } else { parseCompiledR(respectivePackageName, (TypeElement) element); }
s1.getKSafetyStatsSet().stream()...
This condition is too complex to be.
s1.getMissingCount() is a bit longer
Please follow our code style: Space after if, always use braces. In case I understood the code correctly, this statement is a fail-fast one. In this case, I would change the code to java if (isFirstCharDigit(value) { return Optional.empty(); }
Please follow our code style: Space after if, always use braces. In case I understood the code correctly, this statement is a fail-fast one. In this case, I would change the code to java if (isFirstCharDigit(value) &&!isFirstCharDigit(value)) { return Optional.empty(); }
Please follow our code style: Space after if, always use braces. In case I understood the code correctly, this statement is a fail-fast one. In this case, I would change the code to java if (isFirstCharDigit(value) &&!isFirstCharDigit(value) { return Optional.empty(); }
Domain '{}' is not being used, please remove.
Domain '{}' is not used, please remove the check and add it.
Domain '{}' is not being used, please remove the "=="
Prefer "temp" over "temp".
Prefer to move this method to the beginning of the file
Prefer "temp".
suggestion if (getUnit().getTech().isClan() && (getUnit().getTech().isClan()) {
suggestion if (getUnit().getTech().isClan() && (getUnit().isClan()) {
suggestion if (getUnit().getTech().isClan() && (getUnit().getTech().isClan())) {
Can we put this call in the MetricsServiceImpl itself? Won't this be called twice?
Can we put this call in the MetricsServiceImpl itself? Won't this cause problems with the code?
Can we put the conf directly in GrillSessionImpl to match the default path?
Shouldn't we also set the default locale?
Shouldn't we also set the default locale if we provide a DFA way?
Shouldn't we also set the default locale if we provide a DFA descriptor?
This may be null - are we just relying on never calling this before loading the cube?
This null check is just no longer needed because it was before.
This null check is just no longer needed because it wasn't before.
An exception should be thrown?
An NPE if jsonReader is null?
An NPE if jsonReader was null?
This does not seem correct. If there is a URL containing a format string and the file path, it's "java.lang.String".
This does not seem correct. If there is a URL containing a format string and the file path, it's [here](<LINK_0> would be better.
This does not seem correct. If there is a URL containing a format string and the file path, it's [here](<LINK_0>
Does this method return a null?
I find this method return void. Is it really needed?
I find this method return void.
nit: Would Iterables.getLast(rootOutputBuffers) looks more concise?
nit: Would Iterables.getLast(rootOutputBuffers) looks slightly better?
nit: Would Iterables.getLast(rootOutputBuffers) be more concise?
why only removal of this event, is throwable accepted here? I expect that the flow gets restarted from the beginning upon exception. we should also log error on this throw block.
why only removal of this event? I expect that the flow gets restarted from the beginning upon exception. we should also log error on this throw block.
why only removal of this event, is throwable accepted here? I expect that the flow gets restarted from the beginning upon exception. we should also log error on this issue.
You can't skip the taskFuture.get() call, it'll be handled by the taskFuture.notifyOtherMembersReady() method.
You can't skip the taskFuture.get() call, it'll be handled by the task future.
You can't use the interface interface here.
How about renaming this to SortedAssignmentContainer or something along those lines?
How about renaming this to SortedAssignmentContainer or something like that?
Why change the access modifiers?
doesn't it throw an exception if config is not found?
doesn't it throw an exception if the config is not found?
doesn't need to be public?
If the topology changes only for tasklet the this node, it is not guaranteed to be loaded. I would like to see this error.
If the topology changes only for tasklet the this node, it is not guaranteed to be loaded. I would like to see this behaviour.
If this is null, why not throw a TopologyElementException?
This boolean 'empty' is redundant - we could just use adapter!= null and let it 'empty'
In other places we use getAdapter(). getAdapter() which is called from a check. Is that the case?
In other places we use getAdapter(), so maybe mark it as final.
Declaration should just be Map
Declaration can be made private.
Declaration can be just List
This way it won't return templates, but it will be better to call addLinks(populate(vmTemplate, entity));
This way it won't return templates, but the method name is wrong...
This way it won't return templates, but it will be better to call addLinks(populate(vmTemplate, entity)); here
"listeners" is not a term, please :)
"listeners" is not a term, please change the variable name to queue
"listeners" is not a term, please change the variable name to queue.
Should return an empty list instead of null, to avoid the extra return.
Should return an empty list instead of null, to indicate there was no entry in the state system
Needs to be private
This should be actionStates instead of emptyMap
This should be emptyMap().
This should be actionStates instead of emptyMap.
setErrorMessage
setFehlermeldung should be a Helper.setErrorMessage which bundles both calls.
setFehlermeldung -> setErrorMessage
Can't we throw a ProtocolAdapterException elsewhere!?
Can't we throw a ProtocolAdapterException!![image](<LINK_0>
While an argument for theoretical advantages could be made, I haven't seen code where the! and! can be omitted.
Normally you should be skipping the service.pid time.
Normally you should be skipping the advance time.
Normally you should be skipping the plan.
Move this in in the commit message? Otherwise the EPackage list may not be updated by all the commit message subprojects.
Move this in in the commit message? Otherwise the EPackage list may be updated twice...
Move this in in the commit message? Otherwise the EPackage list may not be updated unless isValidTimestamp is false.
why are we doing a double check here?
why did you add this check?
why not move this line to the previous if statement?
Why is this check necessary?
Why do we need this check here?
Why not require it here as well?
It looks like this store will be stored in the previous account, no need to call.unbundle() here.
It looks like this is no longer "this".
It looks like this store will be stored in the previous account, no need for the hard-coded Long value.
Is there a way to close the output file system?
Is this a problem? Should we have a way to read the file before opening it?
Is there a way to simplify this?
i think here we do not need to cast throwable to AuthenticationException, its already an instance of AuthenticationException.
i think here we do not need the cast to AuthenticationException, what if we cast here?
i think here we should throw an exception, rather than simply returning null.
why is this delay?
why is this delay needed?
why is this delay necessary?
The return type should be just Map<String, String>
The return type should be just Map
should return an ImmutableMap
suggestion if (!VALID_PROTOCOLS.contains(scheme) || host == null || port == -1) {
suggestion if (!VALID_PROTOCOLS.contains(scheme) || port == -1) {
nit: could use apache.commons.lang3.StringUtils.isBlank() here instead
Suggestion: compiling the URL pattern with the characters then relying on the order of the test, i.e. RegexUrlPatternMap.matches("/app/{jobName}/enable", 16) would work as expected.
Suggestion: compiling the URL pattern with the characters then relying on the order of the test, i.e. RegexUrlPatternMap.matches("/app/{jobName}/enable", 4
Suggestion: compiling the URL pattern with the characters then relying on the order of the test, i.e. RegexUrlPatternMap.matches("/app/{jobName}/enable", 16) will work as expected.
This test will not work properly for tests. If we have a non-default changelog, we should also fix that.
This test will not work properly for tests, instead we should de-dupe the code in the tests.
This test will not work properly for tests. If we have a non-default value (e.g. out of scope, filters, not recurse) then this test will run.
Unless I am missing something, the instance variable response is not used, and had better be removed.
Unless I am missing something, the instance variable response is not used, so the log statement should be removed.
Unless I am missing something, the instance variable response is not used, and had the trace at line 119.
This whole convoluted mess can be replaced with String.format()
This whole convoluted mess can be replaced with String.class.getSimpleName()
I would return null at this point
This line isn't needed since the onMediaUploadProgress is called in line 254.
This line isn't needed since the onMediaUploadProgress is called in line 155.
This line isn't needed if we are synchronizing on the same UI thread.
This will require us to special-case an empty collection everywhere, which I think will make the code confusing and probably error prone during maintenance. I think it'd be nice to modify the GranularitySpec interface somehow. Maybe it could return an Optional<SortedSet<Interval>> from bucketIntervals?
This will require us to special-case an empty set of granularIntervals if the input interval is null. I think it'd be nice to modify the GranularitySpec interface somehow. Maybe it could return an Optional<SortedSet<Interval>> from bucketIntervals?
This will require us to special-case both granularIntervals and granularIntervals. Can we expose both?
These first array has shape info. Make sure to cover both cases.
These first conversion can't pass in the map. Make sure to cover both cases.
These first conversion can't pass in the map. Make them public?
Files.deleteIfExists(OCBinary.get().getFile())
Files.deleteIfExists(OCBinaryFile.get().getFile())
a io.file.separator
You should always use BAD_REQUEST as the message doesn't get any information.
You should always use BAD_REQUEST for the Exception
You should always use BAD_REQUEST as the message doesn't get logged in the user, not a dead request
I tend to put ">=" for these kinds of things, juuust in case something weird happens. Maybe it's just me.
I tend to put ">=" for these kinds of things, juuust in case something weird happens. Maybe it's just me
I tend to think that ">=" is a better check?
I may be missing something here, but this is something that was added to the store now.
I may be missing something here, but this seems a little strange.
StoreInfo will be null.
Do you need to close the stream in a finally block? I think you can just try-with-resources
Do you need to close the stream in a finally block? I think you can just do for (int i = 0; i < 5; i++)
We can use File.toURI()
It's tad we have an executor, but I would guess it would be simpler to have a single statement java try { Future<CheckResult> future = Executors.newSingleThreadExecutor(); try { return future.get(1, TimeUnit.SECONDS); } catch (Throwable ex) { log.debug("An exception took place when trying to retrieve the check result. Will return null.", ex); } } catch (Throwable ex) { log.debug("An exception took place when trying to retrieve the check result.", ex); } }
It's tad we have an executor, but I would guess it would be simpler to have a single statement java try { Future<CheckResult> future = Executors.newSingleThreadExecutor(); try { return future.get(1, TimeUnit.SECONDS); } catch (Exception ex) { log.debug("An exception took place when trying to retrieve the check result. Will return null.", ex); } } catch (Throwable ex) { log.debug("An exception took place when trying to retrieve the check result.", ex); } }
It looks like we have lost a test here, it would be nice to have it in one place.
Do we need to register the connection listener?
Why not move this to NioEventLoopGroup?
Why not move this to NioEventLoopGroup?
This needs to throw a ComputeCommandException.
This needs to throw a RuntimeException.
This needs to throw a Exception.
should this be warning or debug as well?
should this check be done outside the if as well?
should this be warning or error?
needsComma I think would be a better name than hasComma
needsComma I think would be a better name here, e.g. hasComma
needsComma I think should be a space after if, otherwise nested spaces are allowed.
Could you please use StringUtils.isEmpty(name) instead of name.length() == 0?
Could you please use StringUtils.isEmpty(name) instead of name.charAt(0) == ':'?
Could you please use StringUtils.isEmpty(name) instead?
this can be removed since the previous if is still needed
for readability, could you refactor this function since you are using it twice?
this can be removed since the previous if is still true
I think is fine as the removePublishCache() method is also for the enabled case. Do you think it is necessary to do that?
I think is fine as the removePublishCache() method is also for the enabled state. Let's see if tests are passing and then we should use that instead.
I think is fine as the removePublishCache() method is also for the enabled case. Do you think it would matter?
we should add a loggable which is being added
we should add a loggable which includes cinderDomainId
we should add a loggable which is being added.
I think we have to change this, if we don't have mTaskId list, we can get get task by calling pollTasks for that list.
I think we have to change this, if we don't have mTaskId list, we can get get task by calling pollTasks for example.
I think we still need to remove this, since we already have it in DteConfigManager
this test is failing if I am not mistaken.
this test is failing if you do not assert the size of "he" instead of simply verifying that the size of the data is what you expect to be.
this test is failing if you do not assert the size of "he" instead of simply verifying that the size of the data is the correct one to the page.
Can we not swallow the exception?
Can we not log the region id?
Can we not throw the exception?
rm
rm public
rm?
This logic seems to be duplicated in IgniteEx. Can we move this logic to base test?
This logic seems to be duplicated in IgniteEx. Can we move this logic to base class?
This seems to be needless
this is easy to reason about. Perhaps: Bytes.copy(col, row) Also not sure whether this is easy to as well, as it's easy to avoid copying of the data twice.
this is easy to reason about. Perhaps: Bytes.copy(col, row) Also not sure whether this is easy to as well, as it's easy to avoid copying.
this is easy to reason about. Perhaps: Bytes.copy(col, row) Also not sure whether this is easy to as well, as it's easy to avoid copying: this.
@Godin Move this pattern to a static method in the class.
@Godin Move this pattern to class utility class.
@Godin Move this pattern to a static method in class.
The code that erroneously includes this listener, but the workbench window is not enabled. Could you instead do something like this:!(parent instanceof MWindow) e4Context)
The code that erroneously includes this listener, but the workbench window is not enabled.
Missing test for null
In this case, we are just setting limit to 0. If the container is empty, this should probably be filtered out.
In this case, we are just setting the value to true. This is a bit strange.
In this case, we are just setting the value to null, right?
This looks like it's not used anywhere?
Having a test method here looks great, but it's possible to validate that the output is null. I don't see any reason to change this test?
Having a test method here looks like it would be better to validate that the output is read correctly.
Why is this? Is it possible for this to be null?
Why is this? If we're going to be processing _and_ every time we return displayName.
Why is this necessary?
please add brackets to this
please add {}
please add braces
Could you create a method in AbstractGitRepository to handle the error and return true/false from these methods? I believe that will be more maintainable.
Could you create a method in AbstractGitRepository to handle the error?
Could you create a method in AbstractGitRepository to handle the error and return true/false from elsewhere? I believe that will be more wise to be able to handle it and simplify the logic.
This method should be in its own file like Update_OLD. Not sure about it.
This method should be in its own file like Update_OLD.
This method should be in a separate class.
> /var/base/vs/ I would rather use Util.calculateMdAndNmTag(record, refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName())
> /var/base/vs/ I would rather use Util.calculateMdAndNmTag, and its a bit shorter. RefSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName())
> /var/base/vs/ I would rather use Util.calculateMdAndNmTag, and its a bit shorter. RefSeqWalker.getSequenceDictionary().getSequenceIndex(record.ReferenceName())
Should the test be made into a separate test for both creationDate and SINGLE, as they are only present in the json?
Should the test be made into a separate assertion for both creationDate and SINGLE, as they are only present in the json?
Should these tests be made into a separate test method?
we have this logic here as well
we have to reformat this method any more
we could also return null to avoid NPE here
Is this post-processor? (I'm not sure how the original code is)
Is this needed? (I think it's not)
Is this post-build ever used?
If this is a bugal account, is it possible for a techs to be null? If not, I would prefer to raise an IllegalArgumentException (I think that this should be addressed)
If this is a bugal account, is it possible for the techs to be null? If not, I would prefer to raise an IllegalArgumentException (I think that this should be addressed)
If this is a bugal account, do we want to continue to remove the techs?
now you can just do int scanId = telephony.requestNetworkScan(
now you can just do int scanId = telephony. requestNetworkScan(
now this synchronized is redundant
- check this.
- check whether sSecretKeyFromAndroidKeyStore is null
- check whether sSecretKeyFromAndroidKeyStore is null. - Remove this if block
eventCount should be set before the if statement.
I'm a little worried about the performance of this query here. If I select count(eventId) from P.S, I saw "eventId <= toEventId" is inside the above "if". Maybe better "select count(eventId) from P.S.
I'm a little worried about the performance of this query here. If I select count(eventId) from P.S, I saw "eventId <= toEventId" is inside the above "if". Maybe name instead?
Nitpicking: do you mind splitting this in 2 tests for readability / style.
Nitpicking: do you mind splitting this out into 2 tests for readability / style.
Nitpicking: do you mind splitting this up here / in 2 tests for readability / style.
Check args?
Variable is never used
CheckArgs?
Could you make this final?
Could you refactor this into a method?
Can you make this final?
Did you get a chance to make the tokenTime a Long?
Did you get a chance to make the tokenTime a variable?
Did you get a chance to make the tokenTime a descriptive?
I think the braces are redundant now.
I think the braces are redundant now. I think they are not needed.
I think the braces are unnecessary now.
we should warn that this is not null
we should not allow null values for columns.
remove
Can you return String.parse(columnType).toEpochDay(); instead of the cast?
Can you return String.parse(columnType).toEpochDay(); instead?
Can you return String.parse(columnType).toEpochDay();
Why will ugi be null here and not below?
Why will ugi be null here and below?
Why will ugi be null here?
If you're in the middle of the message, then you can use java.util.Objects.equals to check for a null value.
If you're in the middle of the message, then you could use java.util.Objects.equals() to check for a null value.
If you're in the middle of the message, then you can use 'final' and 'else' to have it in the message.
I don't think this block and the changes are necessary. The getInternalNumericId can be part of this if block.
I don't think this block and the changes are necessary. The getInternalNumericId can be part of the if block to do it.
I don't think this block and the changes are necessary. The docId is part of this.
This authorization test is a bit hard to read. It would be better to have a dedicated method in ContentServiceFactory.getInstance().
This authorization test is a bit hard to read. It would be better to have a dedicated method named isLoginOnBehalfOfLoginOnBehalfOfFeature.NAME, and put the rest of the code in that method.
This authorization test is a bit hard to read. Please use the new authorizationFeatureService.
"th attempt on initialization of partition." can be removed.
"th attempt on initialization of partition."
Minor: I think, you can just pass ++count into while loop. That way you do not need to check for this once.
use.name() instead of hard-coded string
Use.getEffect().getParameter(String) instead.
use.name() instead.
This check is not needed since the defaultParts is empty.
This check is not needed since the defaultParts.size() == 0 check is done internally.
This check is not needed since the defaultParts.size() == 0 check is done already.
Won't this always be STARTUP_CRASH?
Won't the path always be STARTUP_CRASH?
Indentation is off here.
Missed the arg.
Wondering if we should throw an exception if the file does not exist.
Wondering if we should throw an exception if there is a process that is not a directory?
we should handle return types java.util.Date and java.sql.Date
we should handle return types java.lang.Date and java.sql.Date
we should handle return types java.util.Date and java.sql.Date too
what is the purpose of this println?
why did this need to change?
why did this need to be removed?
do we need the taskId here?
why do we check/break here, everything is fully empty?
do we need the task id here?
currentTimeMillis() instead of Long.currentTimeMillis()
currentTimeMillis()
Collect
You can call the constructor with 4 args instead of this.
You can call the constructor with 4 args instead of passing null.
You can call the constructor with 4 args instead of this..
now that the expected value is updated, is the replace all still needed?
now that the expected value is updated, is the replace all still needed here?
now that the expected value is updated, is it intentional?
strange name
why not public static?
strange name, can you point me
should stormpathJsonView be a constant somewhere?
stormpathJsonView should be a constant somewhere.
this should be stormpathJsonView.
This should probably be inside of mNativeMap.clear()
This should probably be inside of mNativeMap.
This should probably be inside of the for loop.
As an FYI, should we use the printStackTrace();?
I think we should let the exception bubble up and handle it.
I think we should let the exception bubble up and handle it?
remove
System.out.println should be removed
System.out.println should be better
You may want to add a log here. It seems like a bit verbose while it's not that useful.
You may want to add this to the finally block, so it's more readable.
You may want to add a log here.
It's better to create a separate util function for this purpose.
It's better to directly use the WizardUI.
It's better to directly use the WizardUI
There are two httpclient.execute(HTTPPut and POST).
There are two httpclient.execute(requestUrl).
Do we not ignore content-type header in the request?
BTW try to read.
} else { in the if.
} else { in the }
ChangePackageEnvelope.class should be used on both places.
ChangePackageEnvelope.class.isInstance(fs)?
ChangePackageEnvelope.class should be used on the next line
A random header id should be added if httpHeaders is null.
A random header id is added if httpHeaders is null.
A random header id is already added if httpHeaders is null.
This error message is not valid anymore
This error message is not valid at this point
This is not a valid value, but I'd assertNotNull() on the value
Maybe change this to: if ( Build.VERSION.SDK_INT > 25 ) { Log.warn( "Unable to deserialize server response: " + e.getMessage() ); }
Maybe change this to: if ( Build.VERSION.SDK_INT > 25 ) { Log.e( "Unable to deserialize server response: " + e.getMessage() ); }
Maybe change this to: if ( Build.VERSION.SDK_INT > 25 ) { throw new IllegalStateException("Unable to deserialize server response: " + e.getMessage() ); }
should this be "query/time" in line with the method name?
should this be "query/time"?
should this be moved outside the method?
This is very hard to follow. I would suggest just StringUtils.trim(mdString, separator).
Is this if else necessary?
@Override
Perhaps single quotes around actual code
You probably want a list of strings here and pass it to the CWL workflow.
You probably want a list of strings here and pass it to the constructor
Constraint::toString
Is this none given that we have a single value?
Constraint::toString?
why does this need to insert a listener in the middle of the callback chain? Can the queue reader manage its own queue?
why does this need to insert the queue reader? Can the queue reader manage its own queue?
why does this need to insert a listener in the middle of the callback chain? Can the queue reader manage its own listener?
This method can be declared private.
This function can be declared private.
This method can be package-private.
Why not stream?
Why not stream().forEach()?
Why not stream? suggestion final NotificationAttribute[] attributes = {
How is this different from what is it doing?
How is this different from what is the other one missing?
How is this different from what is the other one fix?
I would consider cleaning this up using the content of the acquireTokenSilentSync() call here instead of the acquireTokenSilentSync() call.
I would consider cleaning this up with the content of the acquireTokenSilentSync() call instead of the acquireTokenSilentSync() since you can just assert that there's no value
I would consider cleaning this up with the content of the acquireTokenSilentSync() call here instead of here.
This assertion should also be inside synchronized
final
This assertion should also be inside the synchronized
I think it will be better to perform the removal of the managed block disks after we start the async operations to remove the regular images because the removal is currently synchronized. (as the removal of the cinder disks)
I think it will be better to perform the removal of managed block disks after we start the async operations to remove the regular images because the removal is currently synchronized. (as the removal of the cinder disks)
I think it will be better to perform the removal of managed block disks after we start the async operations to remove them from the regular images list. (as the removal of the cinder disks)
Why is this required?
Why is this required? The constructor already takes care of it.
Why is this required? This is already done in the constructor.
Why aren't you removing the texts in here?
Why aren't you making this fragment fragment?
Why aren't you removing the stacks?
Remove the catch block and let the exception propagate normally (which fails the test)
Remove the try block and let the exception propagate normally (which fails the test)
Remove all exceptions that are thrown from the test.
Instead of ".getName()" should use the e.getMessage() method, that should be enough.
Use method reference instead of string concat
Use method reference instead of string concatenation
Must be AIDontUseIt (otherwise AI will discards all own players.
Use getPermanentOrLKI if possible
Use getPermanentOrLKI if possible.
we don't need to check for StandardCharsets.UTF_8
we don't need to check for Exception.
you don't need to check for StandardCharsets.UTF_8
Why ignore interrupts here?
Why ignore interrupts here? Is there a reason for ignoring interrupts here?
Why ignore interrupts here? Is there a reason to propagate uninterruptibles above?
Collections.emptyMap()
use Collections.emptyMap() instead of new HashMap<>()
How about Collections.singletonMap()?
Is this deliberate?
consider extracting this into a separate method.
Is this really needed?
don't change this
don't think you want to change this
don't think you want to update request as it is if a stand-alone, right?
If going through a different order, just use birthday (for birthday) instead.
If going through a different order, just use birthday (probably due to only birthday) instead.
If going through a different order, just use birthday (probably due to not having birthday) instead.
In addition to dropConglomerateDescriptor, we could do it in XxxStreamReader in presto-orc. This is probably OK if we need to do something different.
In addition to dropConglomerateDescriptor, we could do it in XxxStreamReader in presto-orc. This is probably OK for now, but I think we should use the MetaDataSchema based on the table name in this PR.
In addition to dropConglomerateDescriptor, we could do it in XxxStreamReader in presto-orc. This is probably OK for now, but I think we should use the MetaDataSchema based on the table name (or not, maybe better for now).
Please rename this variable list to pushResults for example
- PushRequest is DTO. DTO should not have null values for collections. - You can use getOrDefault()
- PushRequest is DTO. DTO should not have null values for collections
This log statement is wrapped in a isDebugEnabled check, but logged at INFO. Should it be logged at DEBUG or should the warn be logged?
This log statement is wrapped in a isDebugEnabled check, but logged at INFO. Should it be logged at DEBUG or should the isDebugEnabled check be removed?
This log statement is wrapped in a isDebugEnabled check, but logged at INFO. Should it be logged at DEBUG or should the warn be logged at all?
I am not a fan of SKIP_CACHE_LOAD here and it is marked as internal method to public. I think the methods that are not part of this PR will be easier to read.
I am not a fan of SKIP_CACHE_LOAD here and it is marked as deprecated in tests. I think the previous behaviour was to use cache1 to avoid confusion.
I am not a fan of SKIP_CACHE_LOAD here and it is marked as deprecated in tests. I think the previous behaviour was to use cache1 to make it easier to read.
Why this change should be a part of this PR? cardinality < cardinality + numProcessed; if (hasDimValSelector) { numProcessed = computeNewLength(dimValSelector, numProcessed, numToProcess); }
Why this change should be a part of this PR? cardinality - numProcessed might be much better than just mentioning it in the first place.
Why this change should be a part of this PR? cardinality - numProcessed might be much better than just setting it to 0 if it was already taken into account.
Space after,.
Space after /..
Missing?
Please remove unnecessary soft assertions.
Please remove unnecessary blank line
Please remove unnecessary blank line.
please extract to variable
please use trim
please extract to variable or rename to something like hostEmulatedMachine
This can be replaced with : List.subscribe(NotificationThread::items);
This can be replaced with : didNotAcquireSanLock();
I did not understand what to do with this variable. It seems to be unused
assertEquals(boolean actual, boolean expected)
assertEquals(1, groups.size())
assertEquals(1, groups.size())?
if(attributePath.charAt(cursor) == 0) {
isArray is a bit misleading?
isArray is fully thread safe?
Instead of calling this and awaitPartitionMapExchange() again I would expect to have a method awaitPartitionAwareness() that call stopGrids(MAX_CLUSTER_SIE, 1).
Instead of calling this and awaitPartitionMapExchange() again I would expect to have a method awaitPartitionAwareness() that call stopGrids(MAX_CLUSTER_SIE, 0, 1, 2, 3);
Instead of calling this and awaitPartitionMapExchange() again I would expect to have a method awaitPartitionAwareness() that call stopGrids(MAX_CLUSTER_SIE, 1, 2, 3);
Won't this be a warning?
Won't passing a bare repo here cause an issue?
Should be private.
same as above, please use API
same as above, please use artifact11Path variable
same as above, please use API method
Please add a null check, i.e. if (o instanceof ScalarSynchronousObservable<? super R>) { return; } child.onNext(((ScalarSynchronousObservable<? super R>)o).t); child.onCompleted();
Please add a null check, i.e. if (o instanceof ScalarSynchronousObservable<? super R>) { return; } child.onNext(v); child.onCompleted();
Please add a null check, i.e. if (o instanceof ScalarSynchronousObservable<? super R>) { return; } child.onNext(((ScalarSynchronousObservable<? super R>)o).t); child.onCompleted(); }
Is this really an error?
Is this really needed?
Is it possible to get an empty hash map outside of this method?
move it to the top of the method
move it into the if block above?
move it into the if block
this method says top-level but not at the bottom that a reader is over-engineering to me. I think we need to consider a case where the reader is over-engineering to me.
this method says top-level but not at the bottom that a reader is fully consumed. Why not just get the size of the readers at the end?
missing braces
I think we should be able to handle the case where lccPushed=true and activation.getLanguageConnectionContext()!= null
The previous code was throwing an exception if lccPushed is false, so it's not required.
I think we should be able to handle the case where lccPushed will be set, and if so, we can continue with it.
if (libraryPreferencesEnabled &&!libraryPreferencesEnabled) { return; }
if (libraryPreferencesEnabled) { return; }
if (libraryPreferencesEnabled) { return; } to reduce indentation?
It's a bit strange that the exception is thrown in the constructor, something like: new RuntimeException( "missing parameter 'id'", ) );
It's a bit strange that the exception is thrown in the constructor, something like: new RuntimeException( "missing parameter 'id'" ) );
It's a bit strange that the exception is thrown in the constructor, something like: new RuntimeException( "missing parameter 'id'", ) )
This can throw if there are no principals. It should probably have an explicit check to throw the AuthenticationException
This can throw if there are no principals. It should probably have an explicit check to throw a proper exception
This can throw if there is no servicePrincipal
It looks like we have duplication of code in the ingest file filters tests. We should look into creating some new utility methods for creating and deleting a case.
It looks like we have duplication of code in the ingest file filters tests. We should look into creating some new utility method for creating and deleting a case.
It looks like we have duplication of code in the CASE_DIRECTORY_PATH.
rename to event
rename to listener
rename to event?
Typo: DropObjectsRequest -> CompartmentEditPart
Typo: I think it should be droppedProtocols
remove blank line
I would have put the.getFileType() at the top of the file, so we don't have to rely on the resource paths
I would have put the.getFileType() at the top of the file, so we don't have to rely on the resource paths (since we might have to add additional paths for other types)
I would have put the.getFileType() at the top of the file, so we don't have to rely on the resource paths (since we might have to add addFilenameFilter() to.js).
Since we had a class name for exception, I think it would be better to use buf.append(t.getLocalizedMessage()) instead of buf.append(t.getLocalizedMessage())
Since we had a class name for exception, I think it would be better to make this method private.
Since we had a class name for exception, I think it would be better to avoid this reuse.
This validation logic should not be in the descriptor, it's already done in the validator
This validation logic should not be in the descriptor, it's common to do validation.
This validation should not be done in the constructor, it's executed from build method.
What about negative values? And also please, add {} arround the method.
What about negative values? And also please, consider negative values?
What about negative values? And also please, add {} arround the value.
README2.md -> README1md
s/indexState/indexState/
README2.md -> README1md?
this method is almost identical to this one - can you refactor to more readable code?
this method is almost identical to this one - can you refactor to implement a method?
this method is repeated in two places, can you refactor it?
If we are changing the default behavior of this method, I would prefer to use Collections.singletonList(cacheTypes) instead of creating an array.
If we are changing the default behavior of this method, I think it should be List<CacheType> cacheTypes = Collections.singletonList(cacheTypes);
Inline this variable.
could this be debug?
minor: The name "channelRead" and "bufferRead"?
could this be debug logging?
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression.
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within..
As a small refactor you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression.
Return an empty list instead of null (same for L59)
Return an empty list instead of null.
Return an empty list instead of null (same for L59).
Add a check to make sure the folder is really deleted.
Add a check to make sure the folder is really deleted?
Add class to method deleteProject()
Why do you close the connection here?
Why don't you use the closeQuietly() method here?
This should be synchronized
I don't think you need this if. The implementation of this method is already implemented by the super class.
I don't think you need this if. The implementation of this method is very similar to the following. Whether the context is Async consumer OR Async consumer should be explicitly completed. This is common pattern to all the sub-classes.
I don't think you need this if. The implementation of this method is very similar to the following. Whether the context is Async consumer OR Async consumer should / handle this logic.
Shouldn't we check if the field was a RealmModel?
Shouldn't we check if the field was a RealmModel and not have yet changed fields?
Shouldn't we check if the field was a RealmModel and not have the class name?
I think this one should be: if (post) { validationResult.merge(service.getSecurityService().validateSecurityRoleName(securityRole.getRoleName())); return Response.ok(savedRole).build(); } else { return validationResult.toRestError(); }
I think this one should be: if (post) { validationResult.merge(service.getSecurityService().validateSecurityRoleName(securityRole.getRoleName()))); return Response.ok(savedRole).build(); } else { return Response.ok(savedRole).build(); }
this one should be: if (post) { validationResult.merge(service.getSecurityService().validateSecurityRoleName(securityRole.getRoleName()))); } else if (post) { return Response.ok(savedRole).build(); } return Response.ok(savedRole).build();
![MAJOR](<LINK_0> 'Severity: MAJOR') Rename this method name to "setScheduledTime". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Rename this method name to "isPendingYet". [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Rename this method name to not2 through the name. [![rule](<LINK_1>](<LINK_2>
Stack trace needs to be logged instead of printed.
exception handling looks realy inconsistent.
Stack trace needs to be logged instead of printed()
Why don't put the listener in the handleEvent function?
Why not add the listener in the handleEvent function?
Why don't put the listener in the listener?
This should be put into a boolean flag.
This should be put into a boolean value.
This should be put into a boolean.
I'd prefer to have the confirm remove permitted to be called even if there's a reason not to.
I'd prefer to have the confirm remove permitted to be called even if there's a "no" session property.
I'd prefer to have the confirm remove permitted to be called even if there's a reason to not do something else.
Shall we log the exception as well?
Shall we log the number of times?
Shall we print the resulting application to a service?
Please use.collect(Collectors.toList())
Please use more specific parametrization
Please use more descriptive e8
It looks like an NPE can occur here. If values is null, we should throw an exception.
It looks like an NPE can occur here. If the getSinglyIterable() method returns null, it will crash.
It looks like an NPE can occur here. If values is null, we should throw an exception instead of returning null.
How about changing code block (line 141  line 147) to following loop: for (RequestOrResponseType requestType : EnumSet.of(RequestOrResponseType.PutRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.ReplicaMetadataRequest)) { requestsDisableInfo.put(requestType, Collections.newSetFromMap(new ConcurrentHashMap<>())); }
How about changing code block (line 141  line 147) to following loop: for (RequestOrResponseType requestType : EnumSet.of(RequestOrResponseType.PutRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest)) { requestsDisableInfo.put(requestType, Collections.newSetFromMap(new ConcurrentHashMap<>())); }
How about changing code block (line 141  line 147) to following loop: for (RequestOrResponseType requestType : EnumSet.of(RequestOrResponseType.PutRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest)) { requestsDisableInfo.put(requestType, Collections.newSetFromMap(new ConcurrentHashMap<>())); }?
Pass settingsRepository as argument to DownloadLanguageTranslationUseCase is not necessary
Pass settingsRepository as argument into DownloadLanguageTranslationUseCase is not necessary
Pass settingsRepository as argument to DownloadLanguageTranslationUseCase is less confusing than you have here
Can we extract this to a private method?
Should we also assert that it's empty?
Can we extract this into a private method?
Here we are always using this.message.length() * 2
Here we are always at least one of the length of the array. Just a suggestion.
Here we are always using this.message.length + 1
Can you also check the getConnections!= null?
Can you also check the connection list?
Can you also check the getConnections()!= null?
You could wrap the event.getChannel() inside a null check.
You don't need event.getChannel().ifPresent, because it would be redundant.
You don't need event.getChannel().ifPresent() here, because it would be redundant.
why are we having the braces around the if statement?
why are we having the indentation in the logs?
why are we having this check for S3 SDK?
Don't need this. Just getRootEntityType( sessionFactory, entityInfo.getClazz() ) should work.
Don't need this. Just call getRootEntityType( sessionFactory, entityInfo.getClazz() )
Don't need this. Just call getRootEntityType( sessionFactory, entityInfo.getClazz() ) directly.
suggestion assertThat(arguments.size()).isEqualTo(CLUSTER_SIE);
suggestion assertThat(arguments.get(CLUSTER_SIE - 1).isEqualTo(CLUSTER_SIE));
suggestion assertThat(arguments.get(CLUSTER_SIE - 1).isEqualTo(CLUSTER_SIE);
Probably should be SURF RAM login, same for description.
Probably should be SURE RAM login, same for description.
Probably should be SURV, same for description.
Can we change this catch to IgniteCheckedException?
Could we change this catch to IgniteCheckedException?
Could we change to "Performance statistics writer started [file] here?
Why not to remove the code that builds the message builder on each case?
Please remove unnecessary else if here.
List?
please remove the extra space.
you can remove the {} here
please remove the hashmap and just use this.
Maybe we can reuse the code from the android code here?
Maybe we can reuse the code from the ActivityResultListener.putExtra() here.
Maybe we can reuse the code from the ActivityResultListener#resetPassword here?
You also have to notify the m_ prefix for a replica after a read.
You also have to notify the m_ prefix for a read lock.
You also have to notify the m_ prefix for a truncation handle.
signal should be new TmfNanoTimestamp
signal should be TmfNanoTimestamp
could use TmfNanoTimestamp
as we are changing how the digest is computed anyway, we can simplify this as buf.append(',');
as we are changing how we are computed anyway, we can simplify this as buf.append(',');
as we are changing how we the digest is computed anyway, we can simplify this as buf.append(',');
You should use the foreach syntax here, and remove the second instruction.
You should use the foreach syntax here, and remove the second loop.
You should use the foreach syntax here, and remove the second loop
I would use an IndexOutOfBoundException here, similar to the checkUnpublished() method above.
I would use an IndexOutOfBoundException here, instead of the check.
I would use an IndexOutOfBoundException here, instead of a check.
Shall we make these constants in DatastreamProducerRecordBuilder as well?
Shall we make these constants defined in DatastreamProducerRecordBuilder as well?
Shall we make these constants in DatastreamProducerRecordBuilder? It's used multiple times.
I think createFromXmlInputStream is preferred here, and createFromXmlInputStream is Closeable, so it's more interesting.
I think createFromXmlInputStream is preferred here, and createFromXmlInputStream is deprecated. If this times out, it's more readable to use a try-with-resources statement to close the stream.
I think createFromXmlInputStream is preferred here, and createFromXmlInputStream is Closeable, so it's more interesting to see a reason for this.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "serverLog". [![rule](<LINK_0>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Exceptional return value of java.io.IOException. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Exceptional return value of java.io.File.mkdirs() ignored in com.vaadin.flow.server.frontend.installer.DefaultFileDownloader.downloadFile(Path, String) [![rule](<LINK_1>](<LINK_2>
You can move this check to superclass
You could move this check to superclass
You can remove this check as you have done in super
You should be able to remove the device id from this list instead of adding it to the list.
You should be able to remove the device id from this list.
You should be able to remove the device id from this.
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "isLinked" is 13 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "isLinked" is 13 which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_1>
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "getEncryptionKey" is 11 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
Maybe it's a little bit cheaper to just use entsIdsToFilter.removeIf(entsIdsToFilter)
Maybe it's better to break this long statement in a named function.
Why not just do this partition once?
Maybe we should always use org.apache.commons.lang3.StringUtils.isNotBlank() to do the null check.
Maybe we should always use org.apache.commons.lang3.StringUtils.isNotBlank() to do the same.
Maybe we should always use org.apache.commons.lang3.StringUtils.isNotBlank() to do the same thing?
You do not have to push a new IllegalArgumentException to error logs. Just print the log line.
You do not have to push a new IllegalArgumentException to error logs. Just print the log level.
You do the same thing here. Would MODULE_ID be more readable or better just use String.format().
Nit: java if (Build.VERSION.SDK_INT > 13) {
Nit: java if (Build.VERSION.SDK_INT > 13) {... }
Same thing about this.
This fits properly in the previous line
This fits properly in one line
Should be removed
Does this work?
Where do you feel about this?
Does that work?
Ok, it's better to keep the author state for test method, also if the author data is the same, we should assert on the state.
Ok, it's better to keep the author state for test method, also if the author data is the same, it will assert on the state.
Ok, it's better to keep the author state.
Can use parameterized logging here.
Does it make sense to have debug level log here?
Can't you use the property file separator here?
for what it can be used instead of smallestFiles?
for what it can be used?
for what it can be used? if it is a directory?
minor: we could simplify this statement by using the return value of getStoredCookies.
minor: we could simplify this statement by using the return value of the while loop at L132.
minor: we could simplify this statement by using the return value of the while loop at L132
I would be smart to throw this exception in this case, and leave it as is.
I would be smart to throw this exception in this case too.
I would be smart to throw this exception in this case.
Will paylod be null if originalContentType is null? I suppose we could use something like UserAgentUtils.isNonBlank()
Will paylod be null if originalContentType is null? I suppose we could use something like assertTrue(originalContentType.isEmpty())?
Will paylod be null if originalContentType is null?
I don't think this is a good idea. You can check whether the ByteBuffer returned by invoke(fileAPI.PROVIDE_BUF_READ_METHOD, "Unexpected error reading into a ByteBuffer"
I don't think this is a good idea. You can check whether the ByteBuffer returned by invoke() is bad, and then throw EOFException("Null ByteBuffer returned");
I don't think this is a good idea. Why?
I'm not sure this would work. Can we change this to taggedMemoryAllocations.stream().filter(entry ->!Objects.equals(FORCE_FREE_TAG))?
I'm not sure this would work. Can we change this to taggedMemoryAllocations.stream().filter(entry ->!Objects.equals(FORCE_FREE_TAG))?
I'm not sure this would work. Can we change this to taggedMemoryAllocations.stream()? I understand this is a bit hard to follow.
redundant semi-colon
correct spelling.
correct spelling
This looks potentially dangerous... You need to check that the payload is really an expected type, please use something similar to <LINK_0>
This looks potentially dangerous... You need to iterate through the payload and check the type.
This looks potentially dangerous... You need to check that the payload is really an expected type, please use something like <LINK_0>
Magic number?
make your mind to remove the field at the end of your patch
make your mind to remove the field from the name.
style nit: no braces here
style nit: no braces around single line blocks
style nit: no braces around single line block
Can we insert a new field into the middle of an existing review? What about backward compatibility?
Can we insert a new field into the middle of an existing reviewSummary attribute? What about backward compatibility?
Can we insert a new field into the middle of an existing reviewSummary class? What about backward compatibility?
I'd split all auth checks into BASIC and all the metal and Kerberos are common enough.
I'd split all auth checks into BASIC and all the metal and Kerberos are common enough. The PKs are the actual resource.
I'd split all auth checks into BASIC and all the metal and Kerberos are common enough. The PKs are the actual columns of the app.
Activator.PLUGIN_ID use activator of tmf.core
again, it is a nice idea to use Activator.PLUGIN_ID rather than fTrace.getName()
again, it has a + s
for (Map.Entry<String, String> entry : hostGroups.entrySet()) {
for (Map.Entry<String, String> entry : hostGroups) {
for (Map.Entry<String, String> entry : hostGroups.entrySet())
nit: let's move it into trainer.runMiniBatch() method
nit: let's move this into trainer.runMiniBatch() method
nit: let's move it closer to where it is used
Minor: call it index or something.
Minor: () -> ()
Minor: call it indexOf.
This should never be true, right?
This should never be true, but I think it is a valid behaviour of this class.
This should never be true, but I think it is a valid implementation of this class.
Ideally this should be created once in the base connection.
Why is this change necessary?
No timezone!
Why not change this to just this.getStudentForEmail(identifier)!= null?
Why not change this to just this.getStudentForEmail(identifier) since it's the same course.
Why not change this to just this.getStudentForEmail(identifier) since it's the same course?
should we return when! webSocketMessage.payload.isEmpty()?
should we return when this method is called? the message would be more generic.
should we return when this method is called? the message would be more specific.
Why private?
Why default to protected?
Why default to public?
final
@cvrebert Why do we need this variable?
@cvrebert why do we need this variable?
Personally, I like to have a lambda expressions inside a lambda. It is particularly hard to read this kind of code. Consider the following: java if (element instanceof Node) { final Node node = (Node) element; final Definition definition = (Node) node.getContent(); hasExpression.ifPresent(e -> view.setReturnToDRGText(Optional.ofNullable(definition.getDefinition())))); }
Personally, I like to have a lambda expressions inside a lambda. It is particularly hard to read this kind of code. Consider the following: java if (element instanceof Node) { final Node node = (Node) element; final Definition definition = (Node) node.getContent(); hasExpression.ifPresent(e -> view.setReturnToDRGText(Optional.ofNullable(definition.getDefinition())) });
Personally, I like to have a lambda expressions inside a lambda. To be on the safe side, I think we can extract this lambda expressions to a separate method call.
error message is never printed
error message is never printed.
error message
I think it's better to implement equals() and hashCode() in a special way, to avoid NPEs.
I think it's better to implement equals() and hashCode()
I think you can use Objects.hash() here
This looks like a copy paste mistake, it should be Sns
Why do we need these three lines, if!isTraceToAllRegionsSync() is merged into the if statement, or should the if statement be moved to the method, as it is used in the SNS queue.
Why do we need these three lines, if!isTraceToAllRegionsSync() is merged into the if statement, or should the if statement be moved to the method, as it is used in the SNS queue?
throw new FreeIpaClientException(message, throwable);
throw new FreeIpaClientException(message, response.getStatus());
Log lines ERROR
Can we move these strings to a private static final field?
Can we move these strings to a private final field?
Please add a @squashCall to the set.
if databaseValue is null, right?
if databaseValue is null, right? will it be used?
if databaseValue is null, right? will be good for us
This should be moved to the sFieldsForClasses array
This should be moved to the sFieldsForClasses constructor
This should be private.
It's vaguely worrying that this function has multiple failure modes but its only indication of failure is a debug message if DBG is true. I imagine the API is set in stone and the function can't be changed to return a value? Failing that, if add default route fails, perhaps it makes sense not to set mDefaultRouteSet to true?
It's vaguely worrying that this function has multiple failure modes but its only indication of failure is a debug message if DBG is true. I imagine the API is set in stone and the function can't be changed to return a value? Failing that, if DBG is true, perhaps it makes sense not to set mDefaultRouteSet to true?
It's vaguely worrying that this function has multiple failure modes but its only indication of failure is a debug message if DBG is true. I imagine the API is set in stone and the function can't be changed to return a value? Failing that, if add default route fails, perhaps it makes sense not to add default route?
avgTemp1 and avgTemp2 are redundant.
avgTemp1 and avgTemp2 are useless.
avgTemp1 and avgTemp2 are same.
Please remove the null check - only Eliminate it will be added - there will be added privileged block instead: <LINK_0> (discussion in <LINK_1> )
Please remove the null check - only Eliminate constructor will be added - there will be added privileged block instead: <LINK_0> (discussion in <LINK_1> )
Please remove the null check - only Eliminate it (for <LINK_0> (discussion in <LINK_1> )
Instead of having println() around all of them, you'd use requestPreferences.setHeatmapMatrixSize(ImmutableSet.of(contrast.getId())) directly.
Instead of having println() around all of them, you'd use requestPreferences.setHeatmapMatrixSize(ImmutableSet.of(contrast.getId())) directly.
Instead of having println() around all of them, you'd use requestPreferences.setHeatmapMatrixSize(ImmutableSet.of(___key)) directly.
Use printStackTrace() instead of e.printStackTrace()
Use printStackTrace() instead of Log.e().
Use printStackTrace() instead of System.err
The two statements above can be conveniently combined to: java Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient = sortedMap.computeIfAbsent(recipientTeam, k -> new LinkedHashMap<>());
The two statements above can be conveniently combined to: java Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient = sortedMap.getOrDefault(recipientTeam, new LinkedHashMap<>());
The two statements above can be conveniently combined to: java Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>> responsesForOneRecipient = sortedMap.computeIfAbsent(recipientTeam, k -> new LinkedHashMap<>());
It looks like this will end up being called twice (for each row in the currentgetCellCommand() method). Can it be made into a private method?
It looks like this will end up being called twice (for each row in the currentgetCellCommand() method) and once here and again on the cellCommand. I think we should do the same for both cases.
It looks like this will end up being called twice (for each row in the currentgetCellCommands() method) and also the parent command in the new command.
We should probably avoid hard-coding the participant.getSubstudies() call here. If we change the participant.getSubstudies() to be empty, we probably don't need to evict anything at all.
We should probably avoid hard-coding the participant.getSubstudies() call here by using participant.getSubstudies().forEach()
We should probably avoid hard-coding the participant.getSubstudies() call here. If we change the participant.getSubstudies() to be empty, we probably don't need to add it to the account.
Returns an empty File[], if the path exists but is a directory.
You can use artifactsLocation.toFile().listFiles() instead of listFiles.
You can use artifactsLocation.toFile().listFiles() directly.
This should be initialized to Collections.emptyMap().
Could use for-loop and a HashSet for the fine-grained approach.
This should be initialized to the field, to avoid the null check.
Please extract method GoStringLiteral to GoStringLiteral.
Please extract method GoStringLiteral to GoStringLiteral and call it everywhere
Please extract method GoStringLiteral and GoStringLiteral to GoStringLiteral.
move this into an else statement
Can we move this into an else statement?
move this into a private method to reduce duplication.
Similar to above, we should probably throw the exception as the cause.
Similar to above, we should probably return the created FunctionInfo
Similar to above, we should probably throw the exception as the cause
Is this job to retry if we are not a ReplicationFactor e.g. ReplicationFactor?
Is this job to retry if we are not a ReplicationFactor e.g. ReplicationFactor e?
Is this job to retry if we are not a ReplicationFactorException?
I think we should fail here, if error is not available.
I think we should fail here, if key is not found, then this will fail.
I think we should fail here, if key is not found, then this is a  jdbc config.
Magic string. I would suggest to use org.eclipse.papyrus.uml.text.FileUtils.separator.
Magic string.
Magic constant.
Can you please make Dropping this line into the if statement below? It's not necessary to keep the code separate.
can you please make Dropping this line into the if statement below? It's not necessary to keep the code separate.
can you please make Dropping this line into the if statement below?
Break the first param out into a separate method?
Break the line before it?
Break the first param out into a separate method for readability?
here we'll want to throw only if we are not already tracing this packet.
here we'd want to throw only if we are not already tracing this packet.
here we're not already tracing this packet.
is there a better name for this?
I think this should be assertTrue?
is there a better name for this variable?
please remove the java.util.Objects.equals()
please remove 'java.util.Objects.equals'
please remove 'java.util.Objects'
some properties that enable basic can be at application context, so we have one place to read, but we do not need to at all.
Please call the FormField: smtp1 = smtp2 = smtp1 = smtp2.parse(smtp2) { smtp2.parse(smtp); }
Please call the FormField: smtp1 = smtp2 = smtp1 = smtp2.parse(smtp2) { smtp2.parse(smtp2.parse) }
I think it would be better to have a single parameter to the function call and then call it from each of these methods. if (parent.getmaps().size() == 0) {
I think it would be better to have a single parameter to the base class function called #8
I think it would be better to have a single parameter to the function call and then call this method with the appropriate name.
I would recommend calling String.format() here instead of concatenation.
I would recommend using String.format() instead of concatenation.
I would recommend using String.format() here instead of concatenation.
Remove the printing stack trace.
Remove the printing stacktrace.
extra space
Why do you need to create AccessibilityChanger instance in all the setters?
Why do you need to create AccessibilityChanger instance here?
Why do you need to create AccessibilityChanger instance in all the methods in Builder?
Use ':' instead of ':' for clarity
Use ':' instead of ':'
Use ':' instead of ":"
What is the purpose of this line?
What is the purpose of these lines?
What happens, if the onsetDate and endDate is null?
Good.
Please use English only for variables.
Please use English only for new code.
perhaps doing this just once in the constructor and save one level of code?
perhaps doing this just once in the constructor and save one level of nesting?
perhaps do this line ;)
Shall we throw the InternalWorkflowException
Shall we merge the try with resources with try with resources
Shall we merge the try with resources with try
Since you're using a stream here, you could just do one filter operation with a stream and forEach
Since you're using a stream here, you could just do one filter and get the organization from the one returned by getTokenSource().getSourceControl().
Since you're using a stream here, you could just do one filter and get the organization from the one made in a forEach.
I do not think this is necessary. The behavior of the method should be changed to return void.
I do not think this is necessary here - it should be set to the point that we're looking for
assertThat
Isn't this already protected?
Isn't this already public?
Declare exceptions (which I don't see)?
no need to add it.
no need to add this.
no need to add it
This is not (and should be) "group-x-binding"
This group name should not be changed as we can not copy anything.
I think it would be better to handle this case in the constructor.
I'm not sure why do you use forks here? I'm not a big fan of two tests.
I'm not sure why do you use forks here? I'm not sure on MTC or other tests.
What is the reason for this one?
nit: I would log the exception in the message for easier debugging.
nit: I would log the exception in the Exception constructor instead of the throwable.
I think we should log the exception here.
should it be handled using a security manager?
should this be encapsulate on the ?
should it be handled with session id in the abort?
You should check if the lock was acquired. If it is released you just release these resources.
You should check if the lock was acquired. If it wasn't there you just just release it
You should check if the lock was acquired. If it wasn't there you just just release them
I think stack trace is a little better here to have a WARN message in this case.
I think logger should be moved to this class
I think stack trace is a little better here instead of e.printStackTrace().
i'd add this here: if (unmanagedControllers.isEmpty()) { device.setManaged(true); }
i'd add this here: if (!unmanagedControllers.isEmpty()) {
i'd add this here: if (unmanagedControllers.isEmpty()) {
should these be logged at the beginning of the exception?
Log using standard log statement and exception handling.
Log using standard log statement
change the message to "Invalid data in the network buffer, will not send SSL Close message"
An AtomicBoolean with an AtomicBoolean would be cleaner.
An AtomicBoolean with an AtomicBoolean would be better.
IMHO this should include a descriptive reflog update, since this is a local repository that a user might be poking around in. cf. the output of "git reflog refs/remotes/origin/master" in a repo of your choice.
IMHO this should include a descriptive reflog update, since this is a local repository that a user might be poking around in. cf. the output of "git reflog reflog refs/remotes/origin/master" in a repo of your choice.
IMHO this should include a descriptive reflog update, since this is a local repository that a user might be poking around in. cf. the output of "git reflog reflog reflog refs/remotes/origin/master" in a repo of your choice.
Also you can use: DirCache dc = repository.lockDirCache(); try { String repoPath = new Path(file.getPath());... } catch (IOException e) { throw new RuntimeException(e); }
Also you can use: DirCache.getInstance().getRepoRelativePath(new Path(file.getPath()).toString()
Also you can use io.File.separator instead of.toString()
I think this needs to be moved to the try-catch block
I think this needs to be moved to the start() method
I think the whole transaction manager needs to be moved to the start method
Any reason for the specific guard? I.e. GTK3.14.13 instead of 3.14.0. If there is no specific reason then please change this to: if (OS.GTK_VERSION >= OS.VERSION (3, 9, 0)
Any reason for the specific guard? I.e. GTK3.14.13 instead of 3.14.0. If there is no specific reason then please change this to: if (OS.GTK_VERSION <= OS.VERSION (3, 9, 0)
Any reason for the specific guard?
nit: we should include the Throwable in the log message.
We should use a warn level log here.
nit: we should include the Throwable in the log line.
Please, use { } for the else.
Please mind to use a more explicit variable name.
Please mind to use a more explicit exception message.
If we're not using this orElse(null) above, is it necessary to just return?
If we're not using this orElse(null) above, is it needed?
If we're not using this orElse(null) above, is it really necessary?
add a message, e.getCause()
add a message resource, e.getCause()
add a message, e.getCause() here
Maybe just 'wrappedMonitor.isDataStall()'?
Maybe just 'wrappedMonitor.isDataStall'?
Maybe just 'wrappedMonitor'.
Change 'else' statement to block i.e. add braces.
Change 'if' statement to block i.e. add braces.
This will result in ClassCastException in several cases.
nit: Waited %d seconds and operation was not complete
nit: Waited %d seconds and operation was %d
nit: Waited here.
nit: Instead of casting for NPE here it would be better to return from the method.
nit: Instead of casting for NPE here it would be better to return from the method since it is already initialized by the method.
nit: Instead of casting for NPE here it would be better to return from the method since it is already initialized.
I think this should be firstAndLastStopsDoNotHaveTimes
I think this should be firstAndLastStopsDoNotHaveTimes - no?
If firstAndLastStopsDoNotHaveTimes == 0, then StreamSupport.stream is needed
If we have a device with less than one account we should call SmartStoreSDKManager.getInstance().getUserAccountManager().getCurrentUser()
If we have a device with less than one account we should call SmartStoreSDKManager.getInstance().getUserAccountManager().getCurrentUser().
If we don't have any accounts on a device, shouldn't we also call this reset()?
Should this be "if (u.isExternalResource()) {"?
[optional] Do not write the ";" in the end of the line.
[optional] Do we want to write the ";" before the write?
Maybe consider String.valueOf() to circumvent NPE
Maybe consider Strings.isNullOrEmpty()?
This shouldn't be needed anymore (?)
This is usually the service interface, not the implementation.
This is usually the service interface in theExecutionService, no?
thanks for that. This should be stored in a field.
I think the unit test is missing.
won't the test fail much if the test failed?
Assert some value of verification, such as checking startTime > 1
similar question here, but would be nice to verify the message here (and in the test below)
similar question here, but would be nice to verify the response size
In the testExecuteSingleUploadBlobSizeTooLarge, would it be better to test the error message here?
I'm a little concerned about this change. It was needed to be able to run this in the background thread, but now it is needed to be able to run the background action.
I'm a little concerned about this change. It was needed to be able to run this in the background thread, but now it is submitted to the background thread (which is needed in the background callback), but now it is submitted to the background thread. I'm assuming this is for the reason, but now it is submitted to the background thread that is running in the background thread (which is what it is for).
I'm a little concerned about this change. It was needed to be able to run this in the background thread, but now it is submitted to the background thread (which is needed in the background callback), but now it is submitted to the background thread. I'm assuming this is for the reason, but now it is submitted to the background thread (which is what it is).
It looks like the constant must be before the variable.
The constant must be before the variable.
It looks like this variable is not used.
Maybe also log the invocation of getAllDimensions.
Maybe the second filter should be collapsed into single filter?
Maybe it should be called method?
This validation fits better in the meaning of the method in this file, which is not true.
This validation fits better in the meaning of the method in this class, which is not true.
This validation fits better in the meaning of the method in this file
Can we rename this to something like "field" or something?
Can we rename this to something like "isAttribute"?
Can we rename this to isValidAttribute?
I think id_Not_Found should be a STRING.
I think id_Not_Found should be a RuntimeException.
I think id_Not_Found should be a toString()
@Override
@vilchik-elena Suggested "ColumnarArray {}"
@vkdrn Thanks for toString()!
Are these values meant to be null?
isn't it the same as just use "mem"?
Are these values meant to be passed to the constructor?
Can this be merged with the previous?
Can this be warn?
Can this be merged?
if the disk doesn't exist you'll fail with NPE here, please first verify that it exists.
if the disk doesn't exist you'll fail with NPE here, please extract to variable
please rename to "disk"
I think we need to close the client if we're not going to use it.
I think we need to close the client if we're not going to use them.
I think we need to close the client if we're not going to use the expected one.
@exper0 let's use Matchers.containsInAnyOrder here
@cvrebert let's use Tv.TEN instead of hardcoding one.
It's better to use.next() than.get() to avoid runtime exception
shouldn't you also return those?
shouldn't you do this?
shouldn't you be using the synchronized block here?
You do not print in the println() call, it is sign of improper place to process exception.
You do not print in the println() call, it is sign of improper place to process exceptions.
You do not print in the println() call, it is sign of improperly formatted
entourage -> entourage
entourage -> subject?
entourage -> subject
The second condition is always false.
The second condition is always true.
The second condition is always true. But is it intentional?
nit: might want to add a null check for paymentExternalId before the cast
nit: might want to add a null check for paymentExternalId before the assign
nit: might want to put the else branch on the next line
you should simplify.
why?
formatting
Use equals() instead of duplicating the code..
Use equals() instead of duplicating the code.
Use Version.isVersion()
use else if
use if (!isRepositoryGroupNode(element))
use if (!(item)
It's good practice to put these three lines into a function call along with the other conditionals, especially when they are closed.
It's good practice to put this logic into a function that can be called from both cases, to avoid the switch statements.
It's good practice to put this logic into a function that can be called from both methods.
Is this line of code actually required? Perhaps we need to add an entire function to KeyVaultBackupOperation to KeyVaultBackupOperation and have the KeyVaultDeleteOperation implement the KeyVaultDeleteOperation, and the KeyVaultDeleteOperation would need to be able to call this method?
I think this line of code is mis-wrap, but I'm fine with either way.
Is this line of code actually required? Perhaps we need to add an entire function to KeyVaultBackupOperation to KeyVaultBackupOperation and have the KeyVaultDeleteOperation implement the KeyVaultDeleteOperation, and the KeyVaultDeleteOperation would need to be executed in the separate method (maybe we could call it whatever is right now) and just from that method?
nit: still space between ) and {
nit: still space after 'if'
nit: still space between ) and!
The name of the method is missing. I think it's better to assert the cause of the failure.
The name of the method is missing. I think it would be nice to assert if the exception is not thrown and just that it was unexpected.
The name of the method is missing. I think it would be nice to assert if the exception is not thrown and just that it was a success
rf should always not null?
We can't use a variable here. What determines to me is the contents of the replicas?
rf should always not not null?
the variable name is not used
the formatting is off
the formatting is off here
minor: would be nice to define the Void/null key for control messages in ControlMessage.getDefaultKey(), or, defining OutgoingControlMessageEnvelope(systemStream, partitionId, controlMessage) to be used here.
minor: would be nice to define the Void/null key for control messages in ControlMessage.getDefaultKey(), or, defining OutgoingControlMessageEnvelope(systemStream, partitionCount) to be used here.
minor: would be nice to define the Void/null key for control messages in ControlMessage.getDefaultKey(), or, defining OutgoingControlMessageEnvelope(systemStream, key, name, partitionCount) to be used here.
/s/in/is
/s/IsUnreasonable/is
s/in/is
Call RxJavaHooks.onError so no exception is lost.
Call RxJavaHooks::onError so no exception is lost.
Call RxJavaHooks.onError so no exceptions are lost.
Here reset should not be inside update() method, otherwise since StampedLock is not reentrant, this could be deadlock
Here reset should not be inside update(), otherwise since StampedLock is not reentrant, this could be deadlock
Here reset should not be inside update().
I'm not sure why you're using setSubtreeChecked here?
I'm not sure why you're using checkedElement here?
I'm not sure why you're using setSubtreeChecked here.
Same. Only catch NPE?
Same. This catch block throws IllegalArgumentException
Same. This catch block can be removed.
Would this work? Timber.w("addNewTemplate() lastExistingOrd was %s", lastExistingOrd);
This seems to be changed to Timber.v(this)
This seems to be changed to Timber.d?
The method should be the check for null.
The method should be the default entity (the interface), not the object.
The method should be the default entity (the enum could be removed).
This is a bit hard to follow. Can we have a file or directory instead of a/proc/self?
This is a bit hard to follow. Can we have a file or directory instead of a/proc directory? (like the one below)
This is a bit hard to follow. Can we have a file or directory instead?
Why do you need to increment the count?
Why does this need to be a Map?
Why does this need to be a hashmap?
log.debug
this line is not needed.
this line is not necessary.
Should this be logged at the user?
Should this be logged at the warn level?
Should this be logged at WARN or so?
This method should be private.
Why not three three?
Why not suggestion PlanNodeTree subPlan =
As we are changing this code, we should also remove the "this.workbenchDataManager.getPermission(permissionId)".
As we are changing this code, we should also remove the "this." field.
As we are changing this code, we should also return the permissionList from the original permissions if it weren't found.
This should be delivery.getProtocolData()!= null? delivery.getProtocolData() : null instead of instanceof.
Why delivery.getProtocolData()!= null and not v.getProtocolData()?
This should be delivery.getProtocolData()!= null?
It looks like we are doing this same thing right? Should a separate method be added to the intent?
It looks like we are calling this activity again, right?
It looks like we are doing this same thing right?
This one should be final.
This [minor] final missing.
This one should be final
looks like we should be logging the error to the user
looks like OpenShiftCoreException is not thrown in this case
looks like OpenShiftCoreException is not thrown
Is this correct? channelsToSync.remove(force) will sync the entire block and the channelsToSync will be removed from channelsToSync, so the synchronization will not be needed.
Is this correct? channelsToSync.remove(force) will sync the entire block and the channelsToSync will be removed from channelsToSync. That's why the test fails.
Is this correct? channelsToSync.remove(force) will sync the entire for loop, right?
you might want to check the Java.lang compatibility here.
Use the Java.vendor.toURL instead of string.format()
I think this will be an 'String.format()' method which can be used for this.
consider using Utils.sort and static import
nit: remove curly brackets
remove the curly braces
I would change this to for(int i = 0; i < treatments.size(); i++) { this.treatments = get(i).setDrugs(treatments.get(i).getDrugs()); }
I would change this to for(int i = 0; i < treatments.size(); i++) { this.treatments = get(i).setDrugs(treatments.get(i).getDrugs()); Or even better, use isEmpty() and check if the list is empty
I would change this to for(int i = 0; i < treatments.size(); i++) { this.treatments = get(i).setDrugs(treatments.get(i).getDrugs()); } Or even better, use isEmpty() and check if the list is empty
This is not correct. It is handled by the consumer.
This is not correct. It is supposed to be handled by user code.
This is not correct.
Insert break here to avoid running the loop more than necessary.
Insert break here to avoid running the query more than necessary.
Insert break here to avoid running the loop
same here, getContentsAspects can't be null.
same here, getContentsAspects can't be null
same here, getContentsAspects can't always be empty
Please add also VOOBSERVER.
The message should be "canBeMember".
Please, add also VOOBSERVER.
No need to use UriBuilder
No need to use this.home
No need to use this.home()
Can we keep the implementation so developers can override how the notification is built if they want to add new features or modify settings (that's why makeNotificationIf... methods were protected if devs are overriding MixpanelFCMMessagingService)? We need a way to let developers override the notification before its posted to the notificationmanager
we should keep the implementation so developers can override how the notification is built if they want to add new features or modify settings (that's why makeNotificationIf... methods were protected if devs are overriding MixpanelFCMMessagingService). We need a way to let developers override the notification before its posted to the notificationmanager
we should keep the implementation so developers can override how the notification is built if they add new features or modify settings (that's why makeNotificationIf... methods were protected if devs are overriding MixpanelFCMMessagingService). We need a way to let developers override the notification before its posted to the notificationmanager
should this be logged at debug level?
should this be logged at error level?
Remove this.
what's the point of this?
Is the (confusing) needed?
Be careful with this (the second statement on line #285).
Will this test pass after the year 2100?
Will this test pass after the year 2100 with none of the dates?
Will these test pass after the year 2100?
The cookie uuid should start with equals.
The equals/hashCode operations are happening here. If the cookie does not exist, this will throw an NPE.
The equals/equals check is redundant here.
This should be set instead in the if (ignoreDTD) statement. If ignoreDTD is false, then we should allow DTDs.
This should be set instead in if (ignoreDTD) statement. If ignoreDTD is false, then we should allow DTDs.
This should be set instead in the if (ignoreDTD) statement. If ignoreDTD is false, then we throw an exception and then we should allow DTDs.
This is not very important. If the consumer is not configured, this code should be called before tableGenerator.configure.
This is not very important. If the consumer is not configured, this code should fail.
This should be called in tableGenerator instead.
Throw an exception here instead of returning false.
return value should be 'null'
Shall we keep the code and log.info instead?
That's a significant change in behavior. Is it needed for this PR?
Saner to set normalExit = false initially, and set it to true in the end of try block. Otherwise Throwable which is close() could be not be released.
Saner to set normalExit = false initially, and set it to true in the end of try block?
I think the functionality here is not right. Setting the empty sequence here is an object that is returned when the expression is an object.
I think the three fields here are already an array.
I think the functionality here is not right. Setting the empty sequence here is an object that is returned if the value is an object.
you could pass clusterCompatibilityVersion to the constructor
you could use DomainXmlUtils#USER_ALIAS_PREFIX instead.
you could pass cluster compatibility version from parameters to the constructor
Whats the benefit of this solution?
Whats the purpose of this comparison?
Whats the purpose of this method?
assertNotSame?
add assertNotSame to verifyNotSame?
add assertNotSame to verify that the original results are in fact.
Please move this to string constant
Please move this line to after try
Please move this line to after try.
Doesn't there need to be a translation call in the failure event handler? This code drops it right through to the failure event handler. The previous code would translate it first.
Not in the scope of your patch. But- error message should be localized
Doesn't there need to be a translation call in the case of getCanDoActionMessages() containing a single message? This code call is internal logical
I'd change it to 'createTask' method
s/in/createTask/
I'd change it to'return void'
I think.ii(...) would be clearer with the check in the range [0, 1), so you'd want to check <.125 instead.
I think.i=* is better, instead of just the range [0, 1), because you'd want to check <.125 instead.
I think.ii(...) would be clearer with the check in the range [0, 1), so you'd want to check <LINK_0> instead.
What is the default value of "task_locks" in this case? I'm a little bit confusing the definition. But this component is used by "agent" and uses "database" for task queuing so :-) of course we can change later.
What is the default value of "task_locks" and used in the next line? I'm a little bit confusing the definition. But this component is used by "agent" and uses "database" for task queuing so :-) of course we can change later.
What is the default value of "task_locks" in this case?
I think it is better to use computeIfAbsent() for this list.
I think it is better to use computeIfAbsent() for that.
I think it is better to use computeIfAbsent() for this list
Why does this need to be inside the for loop?
Why does this need to be inside the loop?
Why does this need to be public?
This method should be clickFeedbackSessionPublishLink instead of OPEN feedback session
This method should be clickFeedbackSessionPublishLink.
This method should be clickFeedbackSessionPublishLink
The implementation of getDefender().getAbility() is already implemented by the base class. This will simplify the implementation.
The implementation of getDefender().getAbility() is nice. This will simplify the implementation.
The implementation of getDefender().getAbility() is nice. This will simplify the logic.
You need a check for packs.length == 0 here to just return early. Its a protection against an empty repository throwing ArrayIndexOutOfBoundsException when it was given a list of objects to find.
You need a check for packs.length == 0 here to just return early. Its a protection against an empty repository throwing ArrayIndexOutOfBoundsException when it were given a list of objects to find.
You need a check for packs.length == 0 here to just return early
This queryBuilder will always be called repeatedly. Is that intentional?
This queryBuilder will always be called repeatedly. Is this the case?
This queryBuilder is never used.
Do we need a case where lastKnownVersion() > latestVersion?
Do we need a case where lastKnownVersion is not exactly latestVersion?
Do we need a case where lastKnownVersion is not more than latestVersion?
I would rather use plain "NodeName" here. It is sufficient.
I would rather use plain "not-eq" here. It is sufficient.
I would rather use plain "Muin" here. It is sufficient.
you removed the extra space in the condition
you removed the extra space before the 'if'
you removed the extra space here and in the condition.
Merge these two if statements.
Merge these three if statements.
Merge these 3 if statements.
It may be better to use setHeader(RestUtils.Headers.DATE, new GregorianCalendar().getTime());
Correct me if I am wrong. If the issue is that attributes are sent in a ReadableStreamChannel, but not in a ReadableStreamChannel, then we don't need to set headers.
Correct me if I am wrong. If the issue is that attributes are sent in a ReadableStreamChannel, but not in a ReadableStreamChannel, then we don't need to set them on the server side. This customization is missing.
If you move this to a field, since it would have nice performance mentioned earlier that not which I think are nice.
If you move this to a field, since it would have nice performance mentioned earlier that not which I think is nice.
If you move this to a method of ensureThrottler would be reasonable.
The adminTimeout is a class member, so this line should be removed.
The adminTimeout is a class attribute, so this line should be removed.
The adminTimeout is a class attribute, not a Scheduler. It could be configured to be used for such a setting.
optimization: int i = partLengths.stream().map(index -> index.getQueryResults(r)).collect(Collectors.toList());
optimization: int i = 0; for (int i = 0; i < numReferences; i++) { Arrays.parallelPrefix(offsets, (a, b) -> a + b); }
optimization: int i = 0; for (int i = 0; i < numReferences; i++) { Arrays.parallelPrefix(offsets, (a, b) -> a + b); } Or is this necessary?
The return value of this method is never used since it's false in initializeColumns.
The return value of this method is never used since it's removing the column's width.
The return value of this method is never used since it can be removed
This should always be a fixed length - 1 if at all?
This should always be a fixed length ( 16 * 2 - 1)
This should always be a fixed size in Vec2
This block should be removed as is it's own method
This block should be removed as is it's own method.
This catch block should be removed.
I'd like to keep this line to be private
I'd like to keep this.
I think this is just duplicated
Can you remove the thread name here?
Can you remove "currentThreadName" and use the String instead?
Can you remove "currentThreadName" and use the String below?
remove this please
remove this line
remove this print statement
We should define a static factory method.
We need to define the string schema here.
We need to define a class for this.
Typo. "<%s> wikibase:kafka ( \"%s\" %d ).\n"
Typo. "<%s> wikibase:kafka ( \"%s\" %d ).\n"
Typo. "<%s> wikibase:kafka ( \"%s\" %d ).\n" ".\n"
Optional: use Boolean.TRUE.toString()
Optional: use Boolean.FALSE.toString()
Optional: use Boolean.FALSE instead
can we make this a method that does not throw an exception?
can we make this a method that does not need to be public?
can we make this a method that does not throw an exception anymore?
can we use the metric registry instead of the data structure?
can we use the metric registry instead of the main one?
can we use the metric registry here?
I don't think it's necessary to check for -1 here, now that the rowNumbers is initialized with zero size and the index is not used.
I'm wondering if we could just call this multi-valued column even if there are none in the multi-valued column. IOW, if the column is unknown we could have a query that is not executed.
I'm wondering if we could just call this multi-valued column even if there are none in the multi-valued column.
I think you should add null checks for DimFilter here before checking the DimFilter.
I think you should add null checks for DimFilter here before accessing the field's DimFilter.
I think you should add null checks for DimFilter here before accessing the field in the set.
this warning is desired
this is a directory: <LINK_0>
this is in the build function in case of data has been closed
Would prefer if Date was initialized using ts's getValue and getScale converted to ms
Would prefer if Date was initialized using ts's time zone, here or perhaps in the setUp method.
Would prefer if Date was initialized using ts's getValue and getScale converted to ms explicitly.
Was this change intentional?
Was this change intentional, or did you mean to remove the file from the parent?
Was this change needed?
could you change this to org.mule.maven.client.api.model.RemoteRepositoryBuilder.RemoteRepositoryBuilder(RemoteRepository remoteRepository)
could you change this to org.mule.maven.client.api.model.RemoteRepositoryBuilder.RemoteRepositoryBuilder.RemoteRepositoryBuilder?
could you change this to throw new Exception(e) so that we have the full stacktrace
This won't be needed anymore, isn't it?
This won't be needed anymore
This too.
Please add import to avoid fully-qualified class references. Also, why not simply do this: Locale parsedLocale = LocaleUtils.toLocale(localeKey.trim()); result.add(localeKey.trim());
Please add import to avoid fully-qualified class references. Also, why not simply do this: Locale parsedLocale = LocaleUtils.toLocale(localeKey.trim()); result.add(parsedLocale.trim());
Please add import to avoid fully-qualified class references.
You can replace baseDir.toAbsolutePath().normalize() by.map(e -> e.getKey().endsWith(".projectBaseDir"))
You can replace baseDir.toAbsolutePath().normalize() with.map(e -> e.getKey().endsWith(".projectBaseDir"))
You can replace baseDir.toAbsolutePath().normalize() by.noneMatch()
Nit: Do we really need this variable?
Nit: these can be defined as a constant
Nit: these can be defined as a constant.
not sure why we need this.... Lets not call Config.TOPOLOGY_LOCALITYAWARE_TOP_BOUND_PERCENT here.
not sure why we need this.... Lets not call Config.TOPOLOGY_LOCALITYAWARE_LOWER_BOUND_PERCENT here.
not sure why we need this.... Lets not call Config.TOPOLOGY_LOCALITYAWARE_LOWER_BOUND_PERCENT as the default
No need for FrontendCompilationException
Why not use FrontendCompilationException?
Why not use FrontendCompilationException?
Can be final
Please use mixinName.
Can be written as a map.
pushdown is not supported yet
Add a message like: "Bucket conversion is not supported yet"
Add a message like "The bucket conversion is not supported yet"
Are these loggings for debug? If so log them at debug/trace level.
Nit: Are these internal variables used? If so, can we get rid of them.
Nit: Are these internal variables used? If so, can we get rid of the stat variable?
It seems to me that you should throw exception if there is no members with a given name.
It seems to me that we should throw an exception if there is no members with a given name.
It seems to me that you should throw exception if there is no members with a given name. Why not just throw it away?
Does this have side-effects? Otherwise could be a performance benefit to moving it inside of the if condition below.
Does this have side-effects? Otherwise could be a performance benefit to moving this inside of the if condition below.
Does it have side-effects? Otherwise could be a performance benefit to moving it inside of the if condition below.
I don't think it'd be better to call mDelegate.delete() here. Instead, it's better to do this: mDelegate.delete(db, taskAdapter, false); mDelegate.delete(db, taskAdapter, false);
I don't think it'd be better to call mDelegate.delete() here. Instead, it's better to do this: mDelegate.delete(db, taskAdapter, false); mDelegate.delete(db, taskAdapter, mDelegate.update(db, taskAdapter, false);
I don't think it'd be better to call mDelegate.delete() here. Instead, it's better to call mDelegate.delete() directly to mDelegate.delete().
suggestion jmxDomain = null;
suggestion jmxDomain = "vertx" + vertx.hashCode();
suggestion jmxDomain = "";
How about to use sortedList.sort(Comparator.comparingLong(T::getSimpleName)) here?
How about to use sortedList.sort(Comparator.comparingLong(T::getSimpleName));?
How about to use separate data model?
This looks exactly the same as nonRepeatableDirectivesByName. I think it's better to use the UUIDUtil method here.
The lambda here is a lot more readable
This looks exactly the same as the method name.
Since this is only called once, why don't you use the return value?
Since this is only called once, why don't you use the returned PatientService?
Since this is only called once, why not use the return value?
the compatibility version should not be set if there was an update.
how about renaming the compatibilityVersion to'version', since it's cluster-update?
the compatibility version should not be set if the cluster was passed in the parameters
It would be nice to add more error messages to the error message in case it fails
It would be nice to add more error messages to the error message in case it fails.
i would add the structural errors to the error message, so it would be easier to understand
This could be a singleton. Could this be null?
This could be a single-line lambda.
This could be a single-line lambda
suggestion dataMap.put(toData(e.getKey(), toData(e.getValue()));
suggestion dataMap.put(toData(e.getKey()), toData(e.getValue()));
suggestion dataMap.put(toData(e.getKey(), toData(e.getValue())),
are you shutting down a zookeeper? why is this.bookieStatus.setToReadOnlyMode()?
are you shutting down a zookeeper? why is this.bookieStatus.setToReadOnlyMode()?
why we need to close ledger storage?
In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the meterResponseDataService here to obtain the response data seems inconsistent at first sight. If there is no particular reason for this difference, I think it might be cleaner if obtaining the actual response is treated alike in different endpoints.
In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the getConfigurationObjectResponse() method here to obtain the response data seems inconsistent at first sight. If there is no particular reason for this difference, I think it might be cleaner if obtaining the actual response is treated alike in different endpoints.
In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the ad-hoc response data to obtain the response data seems inconsistent at first sight. If there is no particular reason for this difference, I think it might be cleaner if obtaining the actual response is treated alike in different endpoints.
Can you use LOG.info("Executing {}", mountCommand);?
Again, can you use LOG.info("Executing {}", mountCommand);
Executing
nit: we could have BoundedUtils.close(Duration.ofMillis(unit.toMillis(timeout)));
nit: we could have BoundedUtils.close(Duration.ofMillis(unit.toMillis(timeout))); instead
nit: this implementation is really awkward to me. Maybe we can just call close on the next line?
(nit) Space after '('
(nit) Space after " {".
(nit) could be removed
I think this should be more like:.query(parameter.getSort().getField()).filter(SortOrder::ASC).map(TimeValue::timeValueSeconds).collect(Collectors.uniqueIndex(TimeValue.timeValueSeconds(elasticsearchQueuedConfig.getScrollTimeInSeconds())).collect(Collectors.uniqueIndex(TimeValue.timeValueSeconds(elasticsearchTuningConfig.getScrollTimeInSeconds())).collect(Collectors.uniqueIndex(TimeValue.timeValueSeconds(elasticsearchTuningConfig.getScrollTimeInSeconds())).collect(Collectors.uniqueIndex(TimeValue.DESC, SortOrder.ASC);
I think this should be more like:.query(Query.getSort() == SortOrder.DESC SortOrder.ASC); searchRequest.scroll(TimeValue.timeValueSeconds(elasticsearchGenerationConfig.getScrollTimeInSeconds()));
I think this should be more consistent with the sorting method.
This is unnecessary as the constructor doesn't have the default value.
This is unnecessary as the constructor doesn't initialize the value.
This is unnecessary as the constructor doesn't need to be public.
Hmm, didn't think of this earlier, but it might be neater to do this using the VerificationWithTimeout mock methods. So you'd mock the eapCallback, then assert that the callback was fired within a timeout. I think that gets rid of our locks and booleans entirely, and make sit easier to read.
Hmm, didn't think of this earlier, but it might be neater to do this using the VerificationWithTimeout mock methods. So you'd mock eapCallback, then assert that the callback was fired within a timeout. I think that gets rid of our locks and booleans entirely, and make sit easier to read.
Hmm, didn't think of this earlier, but it might be neater to do this using the VerificationWithTimeout mock methods. So you'd mock the eapCallback, then assert that the callback was fired within a timeout. I believe that gets rid of our locks and booleans entirely, and make sit easier to read.
Why do we need this change?
What if the state is not SUCCESS?
What if the state is SUCCESS?
this should just be telephonyManager.getNetworkType()
this should just be an int, not an int
this should just be an int, not an int.
This is a little crazy simply because the suggest oracle may be called many times in rapid succession during the course of one operation. It would be easy to have a simple Cache<Boolean, List<Account>> with a short expiration time, say 30s. (The cache will only have a single key, say True, we're just using Cache for the expiration behavior.) (Also totally will not work for googlesource.com but we can wait till there's a proper secondary index for accounts.)
This is a little crazy simply because the suggest oracle may be called many times in rapid succession during the course of one operation. It would be easy to have a simple Cache<Boolean, List<Account>> with a short expiration time, say 30s. (The cache will only have a single key, say True, we're just using Cache for the expiration behavior). (Also totally will not work for googlesource.com but we can wait till there's a proper secondary index for accounts.)
This is a little crazy simply because the suggest oracle may be called many times in rapid succession during the course of one operation. It would be easy to have a simple Cache<Boolean, List<Account>> with a short expiration time, say 30s. (The cache will only have a single key, say True, we're just using Cache for the expiration behavior.) (Also totally will not work for googlesource.com but we can wait till there's a proper secondary index for accounts.), but we should have a simple Cache for the expiration behavior.
Tracking the call to getGrillSessionIdentifier to make it consistent with the code above. Why do we need to create a new method for this?
Suggest moving the try-catch into the method
Formatting
expiringObject should be renamed to expiringObject
expiringObject should be a lambda and a lambda should work :)
expiringObject should be a lambda and a lambda should work
please add a log
Please add a log
please add a log message
no need for the new empty line
no need for the new empty lines
You can add the new empty line above.
Pass in the exception instead of catching it.
No. You want a stack trace here instead of only the exception.
No. You want a stack trace here instead of only the message?
Please move the initialization of the disposables to a local variable to avoid all the null checks.
Please move the initialization of the disposables to a local variable to be consistent with the rest of the activity.
Please move the initialization of the disposables to a local variable to be consistent with the rest of the code.
Style nit: Curlies not needed
Style nit: Unnecessary blank line.
Style: Unnecessary
shouldn't it check the getCluster().getCompatibilityVersion() from the cluster?
shouldn't it check the getCluster().getCompatibilityVersion() from the cluster.
shouldn't it check the getCluster().getCpuName() too?
if ( StringHelper.isNotEmpty( withClause ) && StringHelper.isEmpty( filter ) ) { return ""; } else if ( StringHelper.isNotEmpty( withClause ) && StringHelper.isEmpty( filter ) && StringHelper.isEmpty( filter ) ) { return ""; }
if ( StringHelper.isNotEmpty( withClause ) && StringHelper.isEmpty( filter ) ) { return ""; } else if ( StringHelper.isNotEmpty( withClause ) && StringHelper.isEmpty( filter ) ) { return ""; }
if ( StringHelper.isNotEmpty( withClause ) && StringHelper.isEmpty( filter ) ) { return ""; } else if ( StringHelper.isNotEmpty( withClause ) && StringHelper.isEmpty( filter ) ) { return ""; } }
Nice catch Kamil. Btw, why do you need to use an atomic boolean?
Nice catch Kamil. Btw, why do you need to use an atomic boolean instead of a synchronized one?
Nice catch Kamil. Btw, why do you need to use an atomic boolean and then immediately catch it?
This might be cleaner if you put the whole thing into the method and used variables where needed
This might be cleaner if you put the whole thing into the method and used variables where it's used.
This might be cleaner if you put the whole thing into a private method and used variables where needed
Mentioned all logs, but I would also prefer info messages.
Defaults.MAPBOX_S=true
Mentioned all logs, but I would also prefer info logs.
ParSeqGlobalConfiguration.getInstance().isCrossThreadStackTracesEnabled()?
ParSeqGlobalConfiguration.getInstance().isCrossThreadStackTracesEnabled()
ParSeqGlobalConfiguration.getInstance(). isCrossThreadStackTracesEnabled()?
Should handle the case where an exception is thrown. Can you change it to return void.
Should handle the case where an exception is thrown
Should handle the case where an exception is thrown.
Again, we are braking a bad request to the code.
Again, we are braking a no-op for this.
@carlosmiranda we can assert the exception message directly
Can you use the constants in the HTTP HttpHeader.CONNECTION and HttpHeader._KEEP_ALL?
Can you use a specific Exception for the status code?
Can you use the constants in the HTTP HttpHeader etc?
Was it somehow forgotten?
Magic number?
Factorize these two lines?
this should be "isSetConsoleDeviceEnabled"
this should be 'isSetConsoleDeviceEnabled'
this should be "isSetConsoleDeviceEnabled" no?
All the implementations for the throwableFunction are the same in this test. Maybe there is a way to de-deduplicate this line: final CompletableFuture<Terminated> actorSystemTerminationFuture = actorSystem.getWhenTerminated().toCompletableFuture();
All the implementations for the throwableFunction are the same in this test. Maybe there is a way to de-deduplicate this line: final CompletableFuture<Terminated> actorSystemTerminationFuture = startResponse.orElseThrow(cause -> new FlinkException("Unexpected exception", cause));
All the implementations for the throwableFunction are the same in this test. Maybe there is a way to de-deduplicate this line: final CompletableFuture<Terminated> actorSystemTerminationFuture = startResponse.orElseThrow(cause -> new FlinkException("Unexpected exception", expected));
Consider making a helper method to ensure that we don't throw exceptions.
Consider making a helper method to ensure that we don't send the correct salt byte array.
Consider making a helper method to ensure that we don't send the correct salt byte array in case of error.
I think just passing file is enough instead of filesInProcess.size().
I think just passing file is enough instead of file.toPath()
I think just passing file is enough instead of filesInProcess.size()
How does the retry handler distinguish "failure in initialization + failure in handling all items" from "success in initialization + failure in handling all items"?
How does the retry handler distinguish "failure in initialization + failure in handling all items"?
How does the retry handler distinguish "failure in initialization + failure in initialization + failure in handling all items"?
Let's add a new method validateBeforeSet(Object value) that does nothing
Let's add a new method validateBeforeSet(Object value) that checks if the object is not null and avoid calling this method.
Let's add a new method validateBeforeSet(Object value) that checks if the object is null and avoid calling add later if nothing else
Please use buildAndStartWithDirectExec#buildAndStartWithDirectExec instead.
Please use buildWithDirectExec#buildAndStartWithDirectExec instead.
Please use buildAndStartWithDirectExec#setTaskManagerConnection#setTaskManagerConnection instead.
Can we change the logic to return an empty list instead of null?
Why not just do it in the next line?
Can we remove this?
This line can lead to a DNS lookup (blocking call). Would createUnresolved work as well?
redis() should be accessed as static method.
This line should be accessed as static method.
here we should use else if instead of if.
here we should use else if instead of if
here we should use else if instead of if (schemaFilter)
_nitpick_: I don't think you have any strong opinion on this, but I would use an anonymous inner class instead: long sizeInBytes = 0; long sizeInBytes = 0; //NON-NLS-1
_nitpick_: I don't think you have any strong opinion having this.
_nitpick_: I would have preferred the earlier (100 lines) - maybeLog() would have helped with readability.
@Iprogrammerr Let's use StandardCharsets.UTF_8 constant
@Iprogrammerr Let's use StandardCharsets.UTF_8 constant here.
@dmzaytsev It's better to have this value in a constant
Minor nit: Use try-with-resource to close conn and use try-with-resources.
Minor nit: Use try-with-resources to simplify this.
Minor nit: Use try-with-resource to close conn and avoid 'try' part?
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
I think this broke the sonar build: <LINK_0> if this source change was intended, can you take a look at the Jekins configuration?
I think this broke the sonar build: <LINK_0> If this source changes was intended, can you take a look at the Jekins configuration?
The Timeout of the Timeout is now different than the Timeout of the Timeout. According it, the [this](<LINK_0> 'Severity: MAJOR') Reduce the number of conditions of this condition to: if (request.getRequest()!= null) { if (request.getToken()!= null) { this.startRequestStore.remove(request.getToken()); } }
The Timeout of the Timeout is now different than the Timeout of the Timeout. According it, the [this](<LINK_0> 'Severity: MAJOR') Reduce the number of conditions of this condition to: if (request.getToken()!= null) { observeRequestStore.remove(request.getToken()); }
The Timeout of the Timeout is now different than the Timeout of the Timeout. According it, the [this](<LINK_0> 'Severity: MAJOR') Reduce the number of conditions of this condition to: if (request.getRequest()!= null) { if (request.getToken()!= null) { this.request.getToken(idByToken); } }
Please use consistent formatting (spaces vs. tabs) so that the alignment of text blocks in the file doesn't become any worse than it already is. I realize that the text formatting is already inconsistent, but I would prefer to not have new inconsistencies added.
Please use consistent formatting (spaces vs. tabs) so that the alignment of text blocks in the file doesn't become any worse than it already is. I realize that the text formatting is already inconsistent, but I would prefer to not have new inconsistencies added. What do you think?
Please use Java 7's String.format() instead of string concatenation.
Is this always true? Perhaps a caused by this change. Perhaps a caused by the change in behaviour?
Is this always true? Perhaps a caused by your change in behaviour?
Is this always true? Perhaps a caused by your change, should this change be detected?
I wonder we should close the buffer here. It could have been that the code expects to write 2 bytes back to the same buffer.
I wonder we should close the buffer here. It could also be that the code expects an I18n of the code to read.
I wonder we should close the buffer here. It could have been that the code expects a I18n of the code to read.
Are you sure this is what you want? The method can have multiple listener and log the subject.
Are you sure this is what you want? The method can have multiple listener and log it.
Are you sure this is what you want? The method can have multiple listener and log it if you want.
You can probably use CollectionUtils.isNotEmpty()
You are using SUBTREE here.
You are using SUBTREE here, which is the better choice.
should it return getTotalStats?
should it be monitor.isCancelled()?
should it return void?
can you add a matcher for the fail call?
can you make a constant called HOST_NAME in the plugin name?
can you make a constant called HOST_NAME to keep it more readable?
All the time metrics are in the same scope. Same with line 359 along with others as a switch statement instead.
All the time metrics are in the same transaction. Could we split them into separate method?
All the time metrics are in the same transaction. Could we split them into two transaction? One for each metrics operation.
This should be moved above the try/catch block in this case
This should be outer
This should be moved below the try/catch block
Please add a ArgChecker.isTrue(false) or use the ArgChecker directly
nit: remove "final".
Please add a ArgChecker.isTrue(false)
Do you want to get the BranchProperty from the Project?
Do we want to get the BranchProperty from the Project?
Do you want to catch this exception?
This is a localized message, we should probably put it in an own method.
It looks like this really needs a localized string to put in them.
This is a localized message, we should probably have a constant for the pretty and generic name.
We already have a builder for this kind of thing and I don't think we need to create?
We already have a builder for this kind of thing and I don't see why we need to set the default value.
We should set the default value of SIGNING_ALGORITHM, not NONE.
If you have ocm2 on the same line, this reads a bit nicer.
final
final?
This is not a good idea, but I think it's a good idea to let the logger figure out what was wrong if it's to go. You should use a helper method to get the result.
This is not a good idea, but I think it's a good idea to let the logger figure out what was wrong if it's to go. You should be able to get all the keys for each message, if it's not a big deal.
This is not a good idea, but I think it's a good idea to let the logger figure out what was wrong instead of just putting it in the first place. You can use the trace message.
nit: I think this could be replaced with String.valueOf(ctx.longArrayBody().longElement(i).getText())
nit: I think this could be replaced with Long[] values = ctx.longArrayBody().longElement(i).getText();
nit: I think this is redundant, since the array's length is the same as the size of the array.
Shouldn't you use TypeUtils.nullSafeEquals here?
I'd prefer if you keep the Typeser interface closer to the cast.
I'd prefer if you keep the Typeser interface closer to the serialization framework and use reflection to compare.
minor: this could be changed to optionLengthNibble
I think we should have a message for the first time, no?
minor: can we add a message to the log message in the log.
Maybe we could use some utility to do this this way: java class KeyboardEvent { private final Button managerButton; private final Button managerButton;
Maybe we could use some utility to do this this way: java private void typeSelectorKeyDownEventListener(final Object event) { KeyboardEvent keyEvent = getManagerButton(); managerButton.focus(); }
Maybe we could use some utility to do this this way: java class KeyboardEvent { private final Button managerButton; private final Button managerButton; }
space after +
Formatting - we can space between "if" and "(".
I think it's better to format the string at the next line.
channel.close()?
channel.close();?
channel.close();
Can we remove this switch and just use the default case?
Can we remove this switch and just use the case it is not covered by the switch?
Can we remove this switch and just use the case it is not only for debug log?
I mean here. You have access to the values of this class, so when you can do it, you can do the conversion at this point.
I mean here. You have access to the values of this class, so when the values are changed, you can do the conversion at this point.
I mean here. You have access to the values of this class, so when you can do it, you can do the conversion at line #64
I think we should move this to line 306; we first wait for the thread to finish (join) then we start interrupting it if it still alive. We can still attempt a join() after the thread is interrupted, but with a shorter timeout, i.e. java _eventProducerPool.shutdown(); try { _eventProducerPool.shutdown(); } catch (InterruptedException ex) { /* omitted for brevity */ throw ex; } while (_eventThread.isAlive()) { // Thread won't be alive if it's gracefully exited try { _eventProducerPool.shutdown(); _eventProducerPool.shutdown(); } catch (InterruptedException ex) { /* omitted for brevity */ throw ex; } }
I think we should move this to line 306; we first wait for the thread to finish (join) then we start interrupting it if it still alive. We can still attempt a join() after the thread is interrupted, but with a shorter timeout, i.e. java _eventProducerPool.shutdown(); _eventProducerPool.shutdown();
I think we should move this to line 306; we first wait for the thread to finish (join) then we start interrupting it if it still alive.
I know the original code was also in the original, but just to be consistent with the rest of the code in this class. Assertions.assertThat(status.getModule().length()).isEmpty()
I know the original code was also in the original, but just to be consistent with the rest of the code in this class. Overall this is quite a few lines to test.
I'm fine with the original code.
Can you please move this local variable to the top of the class, where it is used?
Can you please remove the final qualifier and add a new local variable to the left and right of the for loop?
Can you please move this local variable to the top of the class, as it is used in other places?
This tag should be defined as constant somewhere.
This attribute should be defined as constant somewhere.
This doesn't look right.
"Type information is missing" or "Type information is missing"
"Type information is missing" or maybe "Type information is missing"
"Type information is missing" or maybe better "Type information is missing"
I think this is leftover code from the original builder, and the method should be private (so that it can be overridden by the subclass)
I think this is leftover code from the original builder, and the method should be private (so that it can be overridden by subclass)
I think this is leftover code from the original builder, and the method should be private (so that there is no reason to use it)
@Serranya Please, move this string to a constant file
should we set this to null to ensure we're always going to detect it?
@Serranya Please, move this string to a constant
primitive (int) would be sufficient
If parameters are configured in property files, they end up as Strings in this map - so make sure that you do not contain the parameters here.
If maxThreads <= maxThreads, they end up as Strings here.
please rename to contig names
please rename to h
please rename to conf/config
same as above.
same as above. If we want to keep this method
same as above
Formatting (pursue) use a separate x;
Formatting (<LINK_0>,%20int)
Formatting (<LINK_0>
Why this change?
Why this?
Where is this used?
this could be encapsulated on a method called findFirstStepByElement(String) and then check for null if does not found
this could be encapsulated on a method called findFirstStepByElement(String)
this could be encapsulated on a method called findFirstStepByElement(String) and then check if does not found
Can we remove a level of nesting?
Can we remove a line of this?
Can we remove a line break?
Maybe it would be better to check pendingBlocks and do a single lookup?
Maybe it would be better to check pendingBlocks and do a check for whether the element is expired before calling performPut?
Maybe it would be better to check pendingBlocks and do a check for whether the key is contained?
Should we change this al.getCertificates() to just ent.getCertificates().clear()? If so, I would suggest adding the line 86.87 as the second line of code.
Should we change this to "Entitlements.remove(ent.getCertificates().size())" to more correctly?
Why ignore this?
Again, this could be removed.
You can use allMatch here to simplify the logic.
You can use allMatch here to verify if the result is not null.
Ideally we are as specific as possible with exceptions based on what developers might see.
Ideally we are as specific as possible as possible with exceptions based on what developers might see.
Ideally we are as specific as possible with exceptions based on what developers might see. ex.
Why this is needed?
Why we need this?
Why do you need to save it?
I suggest to add a log of the exception here, just to ensure that the feature is not available.
I suggest to add a log of the exception here, just to ensure that the feature is not available
I suggest to add a fail-fast condition, to ensure that the feature is not deleted
Calling the method to getChargeExternalId will cause it will be called twice.
Calling the method with a response can be replaced with withGateway3DSAuthorisationResponse.of(BaseAuthorisationResponse.AuthoriseStatus.ERROR, message, response.getMessage()). This is how we handle exceptions.
Calling the method to getChargeExternalId will cause it will be called twice. This is probably fine.
Why is this conditional necessary?
Remove this conditional
Remove the negations
Do you need to return InputStreamReader(charsetName)?
Do you need to return InputStreamReader?
Do you need to return InputStreamReader(charsetName) here?
1. The default DOUBLE_TYPE can not be used 2. the case should be removed, e.g., DOUBLE_TYPE. What about adding a case for that?
1. The default DOUBLE_TYPE can not be used 2. the case should be removed, e.g., DOUBLE_TYPE.
1. The default DOUBLE_TYPE can not be used 2. the case should be removed, e.g., if you return it, it is not supported.
put else in a new line
put else in its own line
put else into a new line
Doesn't Qulice complain about this line?
Doesn't Qulice complain about this call via the method tcpConnection.
Doesn't Qulice complain about this call via the method call?
Why do we need to return here?
Why are we catching exceptions here instead of just logging them?
Why are we returning here?
this could be inlined
this should be inlined
this should be created above as it is always created
overflow = ((xl  yl) & (xl  zl)) < 0;
overflow = ((xl  yl) & (r >= 0) && ((xl  zl)) < 0;
overflow = ((xl > yl) & (xl > zl)) < 0;
I think in the case where we would still want to recycle the buffer packets. (I think you could avoid the datagramSize truncation and RecyclableArrayList.length)
I think in the case where we would still want to recycle the buffer packets. (I think you could avoid the datagramSize)
I think in the case where we would still want to recycle the buffer packets. (I think you could avoid the datagramSize truncation and bufferPackets.length)
Looks like there are leftover lux extraneous whitespace in the code here?
Looks like there are leftover setAttributes in the first place?
Looks like there are leftover lux extraneous whitespace in the code here.
This code can be simplified to a single line: List<String> certificates = Files.readAllLines(new FileInputStream(file.toFile()));
This code can be simplified to a single line: line = Files.readAllLines(new FileInputStream(file.toFile()));
This code can be simplified using a stream.
I think we should be using CancelRebalanceCommand here as well.
I think we should avoid using magic numbers like this in this file.
I think we should be using CancelRebalanceCommand here as well, not sure if it would make sense.
I would move the createNewFile check into a separate method as it's an expensive operation.
should be warn, not info.
should be warn
could we simplify the logic as: if (childType == null) { return new MessageType(subfield.getRootName(), ImmutableList.of()); } typeBuilder.add(childType); parentType = childType;
could we simplify the logic as: if (childType!= null) { return new MessageType(subfield.getRootName(), ImmutableList.of()); } typeBuilder.add(childType); parentType = childType;
could we simplify the logic as: if (childType == null) { return new MessageType(subfield.getRootName(), ImmutableList.of()); } typeBuilder.add(childType); parentType = childType; }
This is not required.
This is not correct. Did you mean append(where.length() > 0)? " and capacity_type in equals()?
This is not correct. Did you mean append(where.length() > 0)? " and capacity_type in the loop?
shouldWriteWrite here be read or read?
shouldWriteWrite here be shouldWrite?
shouldWriteEntry also be stored as a property?
you can inline item
please inline item
please use static import
I don't think this is a good idea. Removing reserved pool does not necessitate removing reserved system memory. I suppose we will always need to set aside a part of our heap to things we don't track, various overhead, etc. We can probably now set reserved system memory to a lower value.
I don't think this is a good idea. Removing reserved pool does not necessitate removing reserved pool. I suppose we will always need to set aside a part of our heap to things we don't track, various overhead, etc. We can probably now set reserved system memory to a lower value.
I don't think this is a good idea. Removing reserved pool does not necessitate removing reserved pool. I suppose we will always need to set aside a part of our heap to things we don't track, various overhead, etc. We can probably now set reserved pool to a lower value.
Isn't there a low-level error code in CveDB?
Isn't there a clearCache() method where this check is done?
This is impossible :/
I think this should return status as well. Could we declare this as FAILED since it's a race condition?
I think this should return status as well. Could we declare this as FAILED as the default value?
I think this should return status as well. Could we declare this as FAILED as the default value? suggestion return status;
check for non null?
check for nonnull?
check for non empty?
I think this can be final.
I think this can be final
I like that you use an actual file:///projects for the new method.
It would be nice if the default type is ForkJoinJoin.
It would be nice if the list of collections was extracted to separate methods for better readability
It would be nice if the list of collections was extracted to separate methods for better coverage.
Shouldn't this be verifying that the element was applied to the filter?
Shouldn't this be verifying that the element was added to the filter?
Shouldn't this be necessary?
this.
this code is already created in <LINK_0>
this is not needed
Why do you need canonicalList.size() - 1 here?
Why do you need canonicalList.size() - 1?
canonicalList.subList(0, pageSize - 1)
Can this response be read and verified?
Can you response text here and verify that commit id is what you expect?
Can you response code use findById() instead of get()?
should we use a format that allows the reader to use multi-byte columns?
should we use a format like in the next line do not avoid the concatenation of strings?
should we use a format like in the next line do not avoid the concatenation of char and fields?
static import for assertValue
static import for assertions
static import for milliseconds please
nit: move it before the for loop.
nit: move it before the for loop, as you do in the other methods.
nit: move this line before the for loop, as you do in the other method
use fieldType rather than fieldSchema in the message.
use fieldType rather than member variable, the message.
use fieldType rather than member variable, the name of the field
NTPROC_JUNK_ID is highly misleading
Cleanup on error?
Can you change log level.
Can you explain why this change?
Can you explain why this is needed?
Can you explain why are you checking again?
I find the other way around: if (shouldLogDebug()) { return true; } else { return false; } Then you can then just have the return statement
I find the other way around: if (shouldLogDebug()) { return months; }
I find the other way around: if (shouldLogDebug()) { return true; } else { return false; }
Useless blank line?
Use of this. prefix
Useless blank line
This rw is not used, as you can't close it.
This rw is not used, as you can't use Iterables.getLast
This rw is not used, as you can't use RevWalk
Can you explain why this is here?
Can you extract a constant?
Can you elaborate on why this is called?
All "args[i].getSize() == PROPERTIES_TAG_DESC" in "args[i].getSize()" is the same in "locale" method
All "args[i].getSize() == PROPERTIES_TAG_DESC" in "args[i].getSize() == PROPERTIES_STATIC" is the same for upgrade()
?
Shouldn't we call countDown() here just after the waiterIds is cleared?
Shouldn't we call countDown() here (or below) instead of catching the InterruptedException?
Shouldn't we check the waiterIds list first and increment the waiterIds list in this method?
"default" here is not a constant
"default" here is not a constant.
....
Rename this method too.
Rename this method too (even though there are three cases).
Rename this method too?
I think inside 'pwd' it will still get null. Not sure how the final value is being set.
I think inside 'pwd' it will still get null. Not sure how the check above is happening.
I think inside 'pwd' it will still get null. Not sure how the final value is being used?
Why is this necessary?
Why is the test here?
Why is the test not failing?
could move this declaration to the top of the class
could move this to the top of the class
could move the variables to the top and remove the field
Do you think it's worthwhile to check!my responses.isEmpty() as well?
Do you think it's worthwhile to check!myHeaders.isEmpty() as well?
Do you think it's worthwhile to check!my responses.isEmpty()?
This variable is never used.
This variable is not used.
This variable is not used anymore.
This is un-Alphabetical (I think it'd be somewhat ugly). Is there any reason not to use reflection?
This is un-Alphabetical (I think it'd be somewhat ugly). Is there a reason not to use reflection?
This is un-Alphabetical (I think it'd be somewhat ugly). Why not make copyHeadersIfAbsent private and have copyHeadersIfAbsent be defined in the constructor?
I think that this loop would likely be better if it used split()
I think that this bug might be that you should re-fetch the function for each loop so that it used only once. This way, the state of the function could be local to the outside of this loop, and then you can use it in cleanup()
I think that this bug might be that you should re-fetch the function for each loop so that it used only once. This way, the state of the function could be local to the outside of this loop, and then you can use the full task.
Don't we have to lock the email field again? We didn't have to do this before because it would check to see if the user had an existing email but we're in the editor. Now it looks like the user can change the email without us knowing if they already have an existing email. Also, shouldn't this condition always be true?
Don't we have to lock the email field again? We didn't have to do this before because it would check to see if the user had an existing email but we're in the editor. Now it looks like the setUpTermsOfService() can be removed!
Don't we have to lock the email field again? We didn't have to do this before because it would check to see if the user had an existing email but we're in the editor. Now it looks like the setUpTermsOfService() can be removed?
Use logger
Use logger?
Use logger instead.
I would pull this else if into a private method and then make the code more readable.
I would pull this else if into a private method and then make it a method, and then call it here.
I would pull this else if into a private method and then make it a method. The only function should be the error message.
How about making it more explicit and specific?
How about making it more explicit and fewer?
How about making it more explicit and avoid a variable altogether?
please remove this validation (and setSucceeded(false)
please remove this
please remove
Should we remove this?
Should we remove the duplication?
Should we remove the SPARK_ prefix?
Pull this logic out into a utility method succinctBytes.
Pull this logic out into a helper method succinctBytes.
Pull this logic out into a utility function.
- you need to explicitely add the null here if you want it to be selectable. - this should also take into account the selected OS. Ideally, fill this list according to the values returned by osinfo.
- you need to explicitely add the null here if you want it to be selectable. - this should also take into account the number of values returned by osinfo.
- you need to explicitely add the null here if you want it to be selectable. - this should also take into account the oldValue of the OS. Ideally, fill this list according to the values returned by osinfo.
This seems too broad and could be removed.
This seems too complicated but could you create a separate method for it?
This seems too complicated but could you create a separate PR?
More magic numbers; use variables for longitude/latitude?
More magic numbers; using variables for longitude/latitude?
More magic numbers; use variables instead.
I think it is save to remove the debug output
I think it is save to remove the System.out.
I think it is save to remove the debug output.
We can't use the scale variable here since the code for the widget is constructing a new style. At a minimum we are using the pattern of a class in the not instantiated constructor so best to use that is, and add a new constant to the code in the else clause.
We can't use the scale variable here since the code for the widget is constructing a new style. At a minimum we are using the pattern of a class in the not instantiated constructor so best to use that is, and add a new constant to the pattern lifeWindow.
We can't use the scale variable here since the code for the widget is constructing a new style. At a minimum we are using the pattern of a class in the not instantiated constructor so best to use that is, and add a new constant to the pattern lifePattern.
IMO toolingPod.getSpec().getContainers().add(container); makes sense to me.
IMO toolingPod.getSpec().getContainers().add(container); is better here.
IMO toolingPod.getSpec().getContainers().add(container); is better
Rather than hard-coding a file in the class and test, it's better to have a static final String variable that can be checked by File.separator.
Rather than hard-coding a file in the class and test, it's better to have the string class have a static final String variable that can be checked by File.
Rather than hard-coding a file in the class and so, I suggest to use class.getName() +''
Don't log and throw the same exception
Don't log and throw as a WorkflowException
Don't log and throw with same exception
as far as I can see, better to use a constant
as far as I can see, better to use this.
These should be spaces.
This is a bit of a shame. Have you decided to provide a method on a JavaType?
This is a bit of a shame. Have you decided to provide a way to get the Type reference into a JavaType?
This is a bit of a shame. Have you decided to provide a way to get the Type reference?
This line is too long: ElasticsearchSplit split = new ElasticsearchSplit(table, index, group.getShardId().getId(), nodes[nodeIndex].getHostName(), nodes[nodeIndex].getAddress().getPort(), layoutHandle.getTupleDomain());
This line is long: ElasticsearchSplit split = new ElasticsearchSplit(table, index, group.getShardId().getId(), nodes[nodeIndex].getHostName(), nodes[nodeIndex].getAddress().getPort(), layoutHandle.getTupleDomain());
Change to debug("split: {} index: {}", index, group.getShardId().getId(), nodes[nodeIndex].getHostName(), nodes[nodeIndex].getAddress().getPort(), layoutHandle.getTupleDomain());
Reverse the condition, so it is less readable.
Reverse the condition, so it is less confusing. Can you also add a "String username = rootName.getUserName();" to the String?
Reverse the condition, so it is less confusing. Can you also add a "String username = rootName.getUserName();" in the client?
Would be simpler to make this a switch if statement
Make constants
Make a funky constant of type
Why 5?
In general, 100 is usually a good default. Could you re-use the default?
In general you can use the for each loop.
It would look cleaner if you moved this to inside the if statement
It would look cleaner if you moved this to line 92 above and refactored into a method
It would look cleaner if you moved this to line 92 above and take care of the result
maybe we should guard this with world.getName() p.get("host"); and public. then use the getters
maybe we should guard this with world.isBlockLoaded() p.getName() p.getOpened()
call this squash
Code style
Code will be more readable as well
Check code style
decorateHtmlElementList
decorateHtmlElementList(loader, field)
If you want to make the binderyer.
Shouldn't null here just be interpreted as an empty array?
We'll first want to change the field, and then dispose the former codeMiningProviders. So this line could move in line 99. Also, with this approach of greedily disposing, it's very like that setCodeMiningProviders( codeMiningProviders.length) is called only once.
We'll first need to change the field, and then dispose the default here.
The City class is defined in another package used by other tests. Any changes in City could potentially break the test. I would recommend using a class defined within the test itself. It is easier to maintain the code.
The City class is defined in another package used by other tests. The City class is defined in another package used by other tests. I would recommend using a class defined within the test itself. It is easier to maintain the code.
The City class is defined in another package used by other tests. Any changes in City could potentially break the test. I would recommend using the class defined within the test itself. It is easier to maintain the code.
See if you could reuse the toString in MultiValueMap.
See if you could reuse the toString method from super class.
avoid format stringbuilder
@ivandalbosco Why not send this message as a result?
@ivandalbosco Why not use the method reference?
@ivandalbosco Why not send this message when you have a success case?
It looks like you can use Collections.unmodifiableSet instead of new HashSet<>(reqBody.indexOf(value)
It looks like you can use Collections.unmodifiableSet instead of new HashSet<>(reqBody).
The AntiCsrfToken should be created only once, otherwise there is no need to keep references to it.
This should be done once in the execute method.
This should be done once in the constructor.
This should be done once in the constructor. avoid the need for the temp variable.
The formatting of the file should be more fixed.
The formatting of the file should be off.
The formatting of the file should be more fixed. Otherwise it is missing.
I'd suggest not assuming an enum value in the acl field.
I'd suggest not assuming an exception will be thrown if the repo object is empty.
I'd suggest not assuming an exception will be thrown here.
I think we should use TypeMetadata instead of its constructor.
I think we should use TypeMetadata instead of its String.
I think we should use TypeMetadata instead of its TypeMetadata
why kWorker is removed?
why kWorker is not existent?
why kWorker is not being removed?
The more appropriate null check here is to return false if the definition is here.
The more appropriate null check here is to return false if the definition is here as well.
The more appropriate null check here is to return false.
This is not 'per node' It is the count of all CPUs defined in all NUMA nodes.
This is not 'per node' It is the count of all CPUs defined in all NUMa nodes.
This is not 'per node' It is a multi-valued function, is it?
Please use { } around if body.
Please use { } around if body
Please use curly braces around the body of if/else statements
Can we get rid of this conditional? Maybe 3 lines above?
Can we get rid of this conditional? Maybe 3 lines 41 and 42.
Can we get rid of this branch?
I would extract this to a private method and just call it from the test
@erdemedeiros I would test the flow here
I would extract this to a private method and just call it from here
I think we should always log errors to the logger.
At least log the full exception message.
I think we should always log errors to DEBUG.
Considering this is a public method, I think we can make it package-private.
Considering this is a public method, I think we should move it to the constructor.
This is not necessary. Let's make it into FeatureSupported class.
Use the Json object, as you did with [here](<LINK_0>
Use the Json object, as you did with [this](<LINK_0>
Use the injected Json object, as you did with [here](<LINK_0>
It seems we could directly use the field reference here. Any reason we do not define it anymore?
It seems we could directly use the field reference here. Any reason we need to define it again?
It seems we could directly use the field reference here. Any reason we don't define it anymore?
lets export this to a method
please add it to the method
make this method lockImage(Image)
Can we do this?
I think it would be better to do this?
Can this be protected?
Redundant code.
Redundant line 88
Unused
You should be able to remove this line since it's not used.
You should be able to remove this line since it's not required.
You should be able to initialize the listener with the default value
Shouldn't it be "2.3"?
Shouldn't you use the same regDC as the toolbar?
Shouldn't you use the same reg exp again?
Better to use [IDialogSettings.OBJECT_ID_STRING_LENGTH](<LINK_0> instead.
Better to use [IDialogSettings.isDialogSettingsToInDialog](<LINK_0> instead.
Better to use [IDialogSettings.OBJECT_ID_STRING_LENGTH](<LINK_0>
Why this change? It seems to be unrelated to the patch (and I'm not sure it is really related to this PR)
Why this change? It seems to be unrelated to the patch (and I'm not sure it is really needed ;))
Why this change? It seems to be unrelated to the patch.
seems like this variable should be named with a test ModelDescription(SourceModelA.class, "3.0.0.SNAPSHOT");
seems like this variable should be called 'testModelTransformationFromAtoB' and 'SNAPSHOT' with the test class
seems like this variable should be named currentModelDescription
Why is this behavior changed? It used to be NOT waitForHole(false) as it was true, but now it waits instead. Is that true?
Why is this behavior changed? It used to be NOT waitForHole(false) as it was true.
Why is this behavior changed?
This could be replaced by Encode.forHtml(...)
This should be Encode.forHtml(...)
This could be replaced by Encode.forHtml(...).
Line too long.
Flip the if/else statement, please.
Flip the if/else statement?
This would not be necessary if a requirement is provided a Set.
This would not be necessary if a request is sent
Not necessary.
Shouldn't this be context.readResourceForUpdate(...)?
Shouldn't this be context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS, false)?
Shouldn't this be context.readResourceForUpdate()?
Please add final for local variable, and rename validNetworkInterfaces.
Please add final for local variables.
please add final for local variable, and rename validNetworkInterfaces.
Should be 'null'
Should this be warn?
Should be warn
can you make a constant for 4 please?
+2 for a more readable variable name.
+2 for better readability.
Need to revert this line.
custom values can contains a negative value
Need to be a test for this method
I wonder if this method can be moved into the AnalyticsUtils as well as we are going to need to keep track of the media files up for each media.
Doesn't this need to be public?
I think this method can be private
Can we have a constants for these strings?
Can we keep a constant here?
Can we keep a string constants class for these?
This won't need to be done by each thread here. You can call sendEventToSystemProducer only once.
This won't need to be done by each thread here. You can call sendEventToSystemProducer once.
This won't need to be done by each thread here. You can call sendEventToSystemProducer() for each event.
can be simplified as java return Objects.equals(baseImage, that.baseImageId) && Objects.equals(baseImage, that.baseImageId)
can be simplified as java return Objects.equals(baseImage, that.baseImageId) && Objects.equals(baseImage, that.baseImageId);
can be simplified as: return Objects.equals(baseImage, that.baseImageId) && Objects.equals(baseImage, that.baseImageId)
What about extracting 2000 to a constant and reuse it in 2 places?
What about extracting 2000 to a constant variable and reuse it in each of these places?
What about extracting 2000 to a constant variable and reuse it in each of this method?
Add a check here to verify that the serialDataReceived method was not called.
Add a check here to verify that the serialDataReceived method was not called?
Add a check here to ensure that the serialDataReceived method was not called.
Please use falcon instance " + "api on individual entities."
Please use falcon instance ID as well.
Consider using StringUtils.format instead.
Shouldn't it be dropDowns.get( processDeploymentIdListBox.getValue( selected )?
Shouldn't it be dropDowns.get( processDeploymentIdListBox.getValue( selected ) )?
Shouldn't it be new ArrayList<String>()?
Keep it final because it's an instance method?
Keep it final?
Keep @Partial public access?
can be simplified as:.map( v -> v instanceof Optional? (( Optional ) v ) : v ).orElse( null )
can be simplified as:.map( v -> v instanceof Optional? (( Optional ) v ).orElse( null ) )
can be simplified as:.map( v -> v instanceof Optional? (( Optional ) v ).orElse( null ) ).orElse( null )
I'm wondering if it would be better to use the vdsm command instead of vdsm?
I'd use getTaskIdList() instead of getExecutionContext()
I'd use getTaskIdList() instead of getTaskIdList()
consider extracting to a method since you're repeating those two checks in several places.
consider extracting to a method since you're repeating those two checks.
you can use FeatureSupported
Worth using "None" here.
Shouldn't we add "None" here?
Shouldn't we use here an UI script?
I'd suggest you do this without the break, and add a space after the if
I'd suggest you do this without the break, and add a space after the if.
space
Why not X500Principal principal = null;?
Why not X500Principal principal, instanceof X500Principal?
Why not X500Principal principal, instanceof X500Principal?
Does it make sense to move this while you're in here?
Does it make sense to move this while you're waiting for an evaluator to complete?
Does it make sense to move this while you're waiting for an evaluator to be online?
this could be a single line, you can just set the string here and pass it to the constructor.
this could be a single line, you can just set the string as null.
this could be a single line, you can just set the string here and pass it to the method
Please use this.
Please use ObservablePath instead of ObservablePath.
This should be ObservablePath. observablePath
closeResources()
closeResources() or getLazy AssertionError
closeResources() and getCheckoutTiedly()
This logic is not in the model, it should be in the base class.
This logic is not in the topology.
This logic is not stored in the topology.
please reformat code
please reformat
please reformat.
typo exsusts
exsusts
typo or word
Minor: Why do you need to do this in a finally?
Minor: Why do you need to do this in a finally block?
White space.
does this make sense?
does this make any sense?
does this need to be executed?
Can we factor out this logic into a method?
Can we factor out this logic, i.e. private void combineStateStatus(final List<IAtsTask> countingMap, final IStateToken currState) {
Can we factor out this logic, i.e. extract to a method?
Collections.singletonList
Collections.emptyList()
Arrays.asList
Should this be a catch?
Should this be removed?
Should this be a catch?
Can we please also test itemGroup == null, in case that it is an AbstractFolder?
Can we please also test itemGroup == null, in case that it is non-null?
Can we please also check for NON_ITEM in the labels?
The method could be removed instead?
The method could be removed as well?
The method could be removed as well.
use the static substring() method, I think
use the static substring() (since it's a class in the interface)
use the static substring method, I think
you can introduce new interface that you can ask if the new one is not supported by context (as before)
you can introduce new interface that you can ask if the run should use fork or not. default would be true, also if the new interface is not supported by context
you can introduce a reporter for this
You can save the size of once
You can use the method saveMultiTrees
You can save the size of once.
@kahowell, the code should be: key = path.substring(0, childReplicationIndex); key = path.substring(childReplicationIndex + 1);
@kahowell, the code should be: key = path.substring(0,.lastIndexOf("[.")) + 1); key = path.substring(dotIndex + 1);
@kahowell, the key should be Integer.valueOf(path)
add null check for call id
add null check for callID
add null check for L66
How about adding a log statement if the window is not null?
How about to move retractionStorage and return in the catch block?
How about to move this into the if statement?
There is already a [Network.network_id](<LINK_0>; ad it to the base class predicates and use it here instead.
There is already a [Network#resolve(String) method to the base class predicates and use it here instead.
There is already a [Network.network_id](<LINK_0>; ad it to the base method predicates and use it here instead.
shouldn't this be removed?
don't system out please remove this line.
don't system out please remove this line
I understand what you want to achieve, but can't it be fetched only once on Container initialization?
I understand what you want to do, but can't it be fetched only once on Container initialization?
this check doesn't do what you want to do. it's already fetched only once :)
Is it possible to write a header without a length? If so, I would prefer to use a method from the Message interface (e.g., artext-like).
Is it possible to write a header without a length? If so, I would prefer to use a method from the TreParser that could be used to write the header.
Is it possible to write a header without a length? As a trace log, it should be written as a header.
This line is no longer needed.
This can be private
This line is unnecessary.
Couldn't you just extract a method for getRepositoriesPanel()?
Couldn't you just pass in the RepositoryLocation directly to the constructor?
Couldn't you just pass in the registry instead of of ViewModel?
Actually with [bean.getClass().getSimpleName()](<LINK_0>, you should use as the second parameter but with [this.getBean().getClass().getSimpleName()](<LINK_1> (which I think makes more sense in this case)
Actually with [bean.getClass().getSimpleName()](<LINK_0>, you should use as the second parameter but with [this.getBean().getClass().getSimpleName()](<LINK_1> (which I think makes more sense and less error-prone)
Actually with [bean.getClass().getSimpleName()](<LINK_0>, you should use as the second parameter but with [this.getBean().getClass().getSimpleName()](<LINK_1> (which I think makes more sense and less error-prone.
Ah, OK, that would be clearer.
Ah, right, that would be clearer.
My main area of this was that it is using a logger, and not a System.out. Is there a reason for this?
The method can be declared as HistoryReference.TYPE_SCANNER_TEMPORARY, HistoryReference.class
The above code is not covered by the previous if condition.
The null here should be a NO_REF
This is using.toString(). If you want to keep acting, you should use the new method to check the state of the entity.
This is failing because the toString() call also logs. If you miss a logger then you could easily create a missing log message.
This is using.toString(). If you want to keep acting, you should use the new method to check the state.
this part is the same as in restore restore, could you refactor it into a separate method?
this part is the same as in restore restoreAction, could you refactor it into a separate method?
this part is the same as in restore restore method, could you refactor it into a separate method?
Still wrong index... It really must be dependent on the TmfEventTableColumn, we cannot assume that the received 'columns' list is either in creation or visible order.
Still wrong index... It really must be dependent on the TmfEventTableColumn, We cannot assume that the received 'columns' list is either in creation or visible order.
Still wrong index... It really must be dependent on the TmfEventTableColumn, we must have known implications.
At this point we're right, but let's remove this (and the specific null check).
At this point, we're right, but let's remove this (we have the instance where it's used).
At this point we're right, but let's remove this (and the @Override)
Can you add some auto-formatting to the message?
Can you add some auto-generated keys to the message?
Can you please remove this block?
the method needs to be private. otherwise it will be accessible to the "adoutout" file.
the method needs to be private. otherwise it will be accessible to the "adoutout" class.
the method needs to be private.
The problem here is that if the expression is not in the multivalued expression, and count must be non-null for a singlevalued expression, the problem is that the multivalued expression is not in the specific error message.
Why not change to if (count == null || count == null)?
The problem here is that if the expression is not in the multivalued expression, and count must be non-null for a singlevalued expression, the problem is the re-thrown exception
add asserts
Assert.assertNull on new lines?
SettableConfig has a private constructor
debug/trace/remove?
I'd suggest to remove the debug/info text
I'd prefer to remove the debug/info text
What about dumping the statements into a file to make it clear that they aren't missing?
What about dumping the statements into a file to help the user? It's much easier to read.
What about dumping the statements into a file to make it more obvious that they aren't missing?
@tmjee what about proper shutdown sequence here?
@tmjee same here shutdown awaitTermination shutdownNow
@tmjee before awaitTermination you should call shutdown then shutdownNow
I support doing the same here, yes?
suggestion String file = Optional.ofNullable(args, "--parent-accession)?
I support doing the same here, yes
Don't you need to make this a constant (and isNestedLoadEnabled)
Don't you need to make this a constant (e.g. jsonLoader.nestedLoad.disabled)?
Don't you need to make this a constant?
Type can be null. If so, maybe it's better to check it before.
Type can be null, maybe it's better to check it isn't null, and then do the rest of the method.
Type can be null.
in DruidColumnHandle::getColumnType
null check
null checks
Any reason for 2 and 2?
Any reason for 2?
Any reason for 2 and 3?
suggestion assertEquals(manager.getUserSelectedResolver(), null);
suggestion assertThat(manager.getUserSelectedResolver(), null);
suggestion
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we need to see where the supplementary files are stored... (path of the state systems of analyses generated for this trace), so that we don't have orphaned files. Does having the resource make the supplementary files deletable?
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we have to see where the supplementary files are stored... (path of the state systems of analyses generated for this trace), so that we don't have orphaned files. Does having the resource make the supplementary files deletable?
When opening a trace in the unit tests, the resource is often set to null, it is not required.
This should be factorized, e.g.: int row = column == tb.numColumns()? thisRow : 1; if (lastRow == -1 || TupleUtils.cellCompare(tables[childIndex].numTuples() - 1)!= 0) { thisRow = thisRow - 1; }
This check should be moved into TupleUtils.cellCompare implementation.
This should be factorized.
This should be done at the end of the System.properties file.
This should be done at the end of the System.currentTimeMillis()
This should be done at the end of the sample.
Why did you removed the check for -1 here? Do you not need it, right?
Why did you removed the check for -1 here? Do you not need it?
Why did you removed the check for -1 here? Do you still need it, right?
@onursumer wondering if this function should maybe be private just to avoid people from accidentally using it?
@onursumer wondering if this function should really be private just to avoid people from accidentally using it?
@onursumer wondering if this function should maybe be private just to avoid people from accidentally making it public?
Probably better to name the response to something more like "publishing-queue"
Probably better to name the response to something more like "publishing-queue" rather than "publishing-queue"
Probably better to name the response
Note that this exception only occurs if the change is going to be spammy. When you use this exception like this I think it is better to state that the change is a draft commit and not a new one.
We need to be careful with this exception. Call this edit commit has e multiple parents.
We need to be careful with this exception. Call this edit commit has e three parents.
This test would pass even if an exception is thrown. The cause of the test is not to verify the cause. There are a few ways to do that. First, I think we should wrap all test in a try-catch with an exception and then just throw. The second. The cause may be an IOException. Secondly, I would recommend to try to catch more than one exception, since this test throws Exception. So, if an exception is thrown, we know that the cause was to fail.
This test would pass even if an exception is thrown. The cause of the test is not to verify the cause. There are a few ways to do that. First, I think we should wrap all test in a try-catch with an exception and then just throw. The second. The cause may be an IOException. Secondly, I would recommend to try to catch more than one exception, since this test throws Exception. So, if an exception is thrown, we know that the cause was not thrown.
This test would pass even if an exception is thrown. The cause of the test is not to verify the cause. There are a few ways to do that. First, I think we should wrap all test in a try-catch with an exception and then just let the exception be thrown. The second test will fail, so the exception will be printed as _before_ the try-catch_.
I think it is better to remove the 'UserDn' parameter from the 'UserFilter'.
@nvazquez the user profile is empty and isNotEmpty will throw a exception, which is not what we want, right?
I think it is better to remove the 'UserDn' parameter from the 'UserFilter'. If the userFilter is empty and userFilter is empty, we fail on an exception here.
It appears that we don't need to catch this exception here. suggestion throw new IllegalArgumentException(e);
It appears that we don't need to catch the SecurityException here.
It appears that we don't need to catch this exception here.
Message is incorrect here
Message is: "Snapshot {} was already registered"
Message is: "Snapshot {} was already **not** registered"
Throw a named exception here.
Add null checks, or throw IllegalArgumentException.
Add null checks, or throw IllegalArgumentException?
nit: don't need public here.
nit: don't need this extra line
nit: don't need this extra variable
Please change this to: if (response.getStatus() == ConfigurationUpdateStatus.SUCCESS) { entityManager.merge(update); } entityManager.merge(update);
Better to use try-catch here.
Better to use try-catch with final catch
Better with other example domain (e.g. example.org).
This test is just the case. Can this be changed to also verify that alert is startsWith?
This test is just the case. Can this be changed to just verify that alert is startsWith?
Are you sure this condition is not null?
Are you sure this is what was already in the original code?
Are you sure this is what we want?
it looks like a constant
it looks a constant
it looks like a typo
If states is sortedStates, do we still need to sort it?
If states is sortedStates, do we still need to sort it again in the map?
If states is sortedStates, do we still need to sort it again?
Please add null check here.
We should check for null here.
We should check for null null before accessing the config.
There is no point in having an IQ7Element here.
There is no need for IQ7Element here.
There is no point in having an IQ7Element at all.
Inject the client instead of this sleep()
Inject the client instead of this singleton.
Inject the client instead of this sleep
This looks good, but the bindingResult check should be executed only if the repository exists. In other words, something like this: suggestion if (repository == null &&!RepositoryTypeEnum.PROXY.getType().equals(repository.getType())) { //... }
This looks good, but the bindingResult check should be executed only if the storageType is not null. In other words, something like this: suggestion if (repository == null &&!RepositoryTypeEnum.PROXY.getType().equals(repository.getType())) { //...
This looks good, but the bindingResult check should be executed only if the storageType is not null. In other words, something like this: suggestion if (repository == null ||!RepositoryTypeEnum.PROXY.getType().equals(repository.getType())) { //...
can you please rename to vmPayload?
can you please rename to vmPayloads?
can you please rename to vmPayloads
This is pretty dangerous because alerts bigger than 1MB will break the emitter
This is pretty dangerous because alerts bigger than 1MB will have nothing to do with this logic. The logic here is going to fall out of the if statement and emit the data for the alert. Can we add a similar function to DatabaseRuleManager?
This is pretty dangerous because alerts bigger than 1MB will have nothing to do with this logic. The logic here is going to fall out of the if statement and emit the data for the alert. Can we add a similar info in the alert?
It seems this code will always return null, no?
It seems this code will always return null, no? Please use isEmpty()
It seems this code will always return null, so we can merge with the above lines.
The Exception is never thrown.
These Exception is never thrown.
The Exception is never thrown..
1 =
final
1
You also have to replace anyMatch with allMatch here, otherwise there is only a validator error if _none_ of the media are in the physical structure tree. However, there should already be an error message if _only one_ is not in the physical tree.
you also have to replace anyMatch with allMatch here, otherwise there is only a validator error if _none_ of the media are in the physical structure tree. However, there should already be an error message if _only one_ is not in the physical tree.
You also have to replace anyMatch with noneMatch instead of using anyMatch.
Do we really need this.valueString = "";? Can we use this instead?
Do we really need this.valueString = "";? Can we use this pattern to be used later?
Do we really need this.valueString = "";? Can we use this pattern and get the full graph name?
Maybe you could factor the entire method?
Maybe you could avoid creating a new stream here?
Maybe you could avoid creating a new variable here?
Now one can only static import state methods for either TransformationState/Module, but that isn't a big issue
Now one can only static import state methods for either Transformationer or TransformationStateer.
Now one can only static import state methods for either TransformationService or TransformationService. I don't see any reason to make it static
Log messages appear to be incorrect here too.
The first half of this method is very similar to some of listPhrasesForPage(), could you refactor por favor?
Log messages should be parameterized
Is it possible to have a file action method. This is a recipe for getting NullPointerExceptions.
Is it possible to have a file action method. This is a recipe for getting NullPointerExceptions?
Maybe you can also catch the exception like the previous line
@zack-shoylev Do you know what the underlying issue is here? Waiting for locks to be released, or.?
@zack-shoylev Do you know how this is handled? Waiting for locks to be released, or..?
@zack-shoylev Do you know why you need the last line?
Can we replace these 4 lines with: assertTrue("purgeLessThanEqualTo", Math.min(formattedValues, 0);
Can we replace these 4 lines with: @Test public void purgeLessThanEqualTo(Duration actual) { // persist public method
Can we re-use these asserts?
I would really prefer to serialize not only the first element, and then check if it is null.
I would really prefer to serialize not only the first element, and then check if it exists.
I would really prefer to serialize not only the first element.
Nitpick: 'if' is redundant
Nitpick: 'if' is not needed
Nitpick: 'if' can be removed
Can this reuse the function...
Can we reuse the function that is also done by the FunctionHelper class?
Can we reuse the function that is also done by the FunctionHelper?
nit: extra space after (
nit: use Arrays.fill instead of a new line
nit: use Arrays.fill instead of a new line.
Ctrl + D
Stacktrace will go to the log if you 'do not' put a auto formatter bracket for it.. like this log for you.
Stacktrace will go to the log if you 'do not' put a auto formatter bracket for it.
There is another reason to be wrapping this into another ArrayList and do not do it manually.
There is another reason to be wrapping this into another ArrayList and do a List again (as it will never have a number of elements).
There is another reason to do this here.
line > 120 chars
line > 120 characters
line> 120 chars
I'm not sure how this is working, but we probably need to do something with @Test(expected = IllegalStateException.class)
I'm not sure how this is working, but we probably need to do something like assertNotEquals(long, pauseMonitor.getNumGcInfoThresholdExceeded());, if quorumPeerConfig.isClientShutdown() is true, then the name of the method is misleading.
I'm not sure how this is working, but we probably need to do something like assertNotEquals(long, pauseMonitor.getNumGcInfoThresholdExceeded());, if quorumPeerConfig.isClientShutdown() is true, then we can probably check number of pauses here.
Maybe a bit extreme? timeoutInSeconds * 1000 would be clearly in milliseconds.
Maybe a bit extreme? timeoutInSeconds should be set to a reasonable value.
Maybe a bit extreme? timeoutInSeconds should be set to a default value.
<LINK_0>
Is this the right status code we're catching?
Is this the right status to 400?
nit: can probably put this on a previous line
nit: can keep the Exception
nit: can use a better name (creating all these methods)
Isn't this a bug in the current budget list instead of the list of budgets?
Isn't this a bug in the current budget list instead of the parsing of the budget object?
Isn't the purpose of having the list as a list of budgets?
use curly braces
use curly brackets for 'if'
use curly brackets for else statement
These will never be equal because run.id was never changed. The check is unnecessary now though. A similar check was used previously because the generated name was based on a predicted ID before the Run was actually saved. Since it is now saved first, the ID is solid. Above (L1535) should be changed to run.setId(run); if (baseId!= AbstractRun.UNSAVED_ID) { //.... }
These will never be equal because run.id was never changed. The check is unnecessary now though. A similar check was used previously because the generated name was based on a predicted ID before the Run was actually saved. Since it is now saved first, the ID is solid. Above (L1535) should be changed to run.setId(run); if (baseId!= AbstractRun.UNSAVED_ID) { //... }
These will never be equal because run.id was never changed. The check is unnecessary now though. A similar check was used previously because the generated name was based on a predicted ID before the Run was actually saved. Since it is now saved first, the ID is solid. Above (L1535) should be changed to run.setId(run); if (baseId!= Long.MAX_VALUE) { //... }
DatasetException or a subtype would be better here.
Should this be done in the try block?
Should this be done in the OutputCommitter#wrap?
We don't want to invoke setVds, because get the whole VDS object is fetched from db during saving audit log to db. If we invoke only setVdsName, then we can spare this unnecessary VDS fetch. if (host!= null) { event.setVdsName(host.getName()); }
We don't want to invoke setVds, because get the whole VDS object is fetched from db during saving audit log to db. If we invoke only setVdsName, then we can spare this unnecessary VDS fetch. if (host!= null) { event.setVdsName(host); }
We don't want to invoke setVds, because get the whole VDS object is fetched from db during saving audit log to db. If we invoke only setVdsName, then we can spare this unnecessary VDS fetch. if (host!= null) { event.setVdsName(host.getName); }
After some thinking about cases when a table exists but is empty, setting to "null" and then setting to "null". Not sure if this will be the case, though.
After some thinking about cases when a table exists but is empty, setting to "null" and then setting to "null". This will only revert to the default, and this will delegate to the other constructor.
After some thinking about cases when a table exists but is empty, setting to "null" and then setting to "null". This will only revert to the default, and this will delegate to the new constructor.
CollectionUtils.isNotEmpty(value)
I think CollectionUtils.isNotEmpty(value)
I think CollectionUtils has a contains() for this.
To be more explicit, should we throw an error if "clean-on-flush" is specified without neither "flush" nor "flush-size" being present?
To be more explicit, should we throw an error here if "clean-on-flush" is specified without this value?
To be more explicit, should we throw an error here if "clean-on-flush" is specified without neither "flush" nor "flush-size")?
This should only happen if an error is thrown, or is this a valid state?
This should only happen if an error is thrown, or is this the only reason that we want to handle?
This should only happen if an error is thrown, or is this a serious error?
It doesn't seem to be the default for the snomedRelationshipIndexEntry relationshipWithAdditionalCharType anymore, is it?
It doesn't seem to be the default for the snomedRelationshipIndexEntry relationshipWithAdditionalCharType anymore, is it possible to put this there?
It doesn't seem to be the default for the snomedRelationshipIndexEntry entry.
This is too complicated for a slave. Slave attributes are sent at INFO level
This is too complicated for a slaveInfo that is a label and you can ignore it
This is too complicated for a slave. Slave attributes are sent at INFO level.
There is no need to add an org.jboss.as.test.shared.ServerVerifier class here.
There is no need to add an org.jboss.as.test.shared.ServerVerifier class here. The combined usage is exactly the same as the popular in PR.
There is no need to add an org.jboss.as.test.integration.testutils.DomainVerifier class here.
Better to use the old one, taking the capacity, and construct the new one with the old one.
Better to use the old version, taking the newer version. It is API.
Better to use the old one, taking the capacity, and construct the new one with the different offset.
This is called twice, might as well refactor the logic into a method
This is called twice, might as well refactor it into a extract method
Same here, don't apply the displayName.
What there is a random text?
Can use feedback response ID? Same in multiple places.
What there is no Ajax call to this method?
Please, add the indent to highlight the blocks and avoid the mess in the code.
Please, add the indent to highlight the blocks and avoid the mess in the function.
Please, add the indent in the log.
I ran the snippet against multiple versiones on my machine and the issue reproduces on all of them -- even the last one is the last one, so this should be false.
I ran the snippet against multiple compiled GTK versions on my machine and the issue reproduces on all of them -- even the first GTK3.10.9 release() before initializing the layout.
I ran the snippet against multiple compiled GTK versions on my machine and the issue reproduces on all of them -- even the first GTK3.10.9 release() before initializing the array with the new layout.
please use CollectionUtils.isNotEmpty()
please add a log
please add
Do we need to check for null? If the exchange user does not have any password, the exchange user will get an error.
Do we need to check for null? If the exchange user does not have enough nodes of the given project, we can use it.
Revert to ExchangeRepositoryMetadata
Can it be better to use getIn().getHeader(SqlConstants.SQL_PARAMETERS, Iterator<Object>).
Can it be better to use getIn().getHeader(SqlConstants.SQL_PARAMETERS, Iterator) here?
Can you change this to use the logger.debug method instead?
"uppercase".equals(textTransform) && textToInsert!= null
"uppercase".equals(textTransform) && textToInsert.toUpperCase()!= null
"uppercase".equals(textTransform) && textToInsert.toUpperCase() == null
Is this really needed?
Is it necessary to specify a phase context flag?
Is it necessary to specify a flag of apiCall here?
minor: don't need to define a Supplier here.
minor: don't need to define a Supplier here
Was this change intentional?
I would suggest that you add new methods to com.google.common.base.Preconditions#checkNotNull(String, int)
please remove.buildBasicValidationTable()
please remove the format by default
Can we get rid of this stuff by moving the footerLayout into the getErrorType method?
Can we move this logic to the setErrorType class? That way we could get rid of the unused method.
Can we get rid of this TODO?
This shouldn't be here. The constructor will init the connection pool. I think the call to the constructor will only happen once, right?
This shouldn't be here. The constructor will init the connection pool. I suggest calling the constructor with a builder, a default constructor will init the constructor.
This shouldn't be here. The constructor will init the connection pool. I suggest calling the constructor with a builder, a default constructor will init the connection pool.
In TribbleException, the RspList (and other cases) is a symptom of falling over time. It seems like it would be better to fix this as well.
In TribbleException, the RspList (and other cases) is a symptom of falling out of nanoTime. It seems like it would be better to fix this as well.
In TribbleException, the RspList (and other cases) is a symptom of falling over time. It seems like it would be better to fix the exception to be caught and handled as a proper symptom.
not required.
no need to cast to long, the casting will be done inside the for loop.
no need to cast to GlusterVolumeEntity, the type casting is enough.
This will be more readable for multiple accounts.
This will be more readable for multiple users.
This will NPE.
I'd suggest using just this: if (getSupportFragmentManager().getBackStackEntryCount() > 0) {.. } else {.. }
I'd suggest using just this: if (getSupportFragmentManager().getBackStackEntryCount() > 0) { // do something here }
I'd just put this in the if.
I think you can remove this if statement.
I think you can remove this if statement by using!StringUtils.isEmpty(symbol.fullyQualifiedName())
I think you can remove this if statement by default.
Component type for the inactive device exception should be DOMAIN_TARIFF_SWITCHING here.
Component type for the inactive device exception should be DOMAIN_TARIFF_SWITCHING.
Component type for Device should be DOMAIN_TARIFF_SWITCHING here.
trace
log warn
log.info?
why not just use countALL_ON_EMPTY?
why not just use countALL_ON_EMPTY directly?
why not move this logic to groupStates?
Again might want to check the iterator behavior here.
Again should use the iterator and not the iterator.
Again might want to check the last element in the list.
I think we should fail("Data validation didn't work for mismatched data.")
I think we should failBecauseExceptionWasNotThrown(VerifyException.class) here instead?
I think we should failBecauseExceptionWasNotThrown(VerifyException.class) here instead.
we can delete this line, it doesn't need to be executed.
we can delete this line, it doesn't use the project name.
we can remove this line?
please add brackets to all of these if statements
you should use.equals() instead of.equals()
please add {}
May I be here, it looks like we are setting position to zero?
May I be here, it looks like we are closing reader twice. Is that right?
May I be here, it looks like we are asserting on reader.next()?
As you already have a bloom filter column, please remove this duplication.
As you already have a bloom filter, please remove this duplication.
As you already have a bloom filter topics, please remove this unused properties can be removed.
This is not necessary now.
This is not necessary now, right?
This should not be necessary now, right?
does it make sense to call this method more than once? The same applies to all the other methods
does this method need to be public?
s/1/INDEX/?
Why do we need to synchronize on this.
Why do we need the synchronized block here?
Why do we need to synchronize on this?
This defines what we are migrating from, and we are migrating from boxc3 data which currently uses the Normalization event, so you'll need to leave it as NORMALIATION in this case
This defines what we are migrating from, and we are migrating from boxc3 data which currently uses the Normalization event, so you'll need to leave it as NORMALIED_TYPE in this case
This defines what we are migrating from, and we are migrating from boxc3 data which currently uses the Normalization event, so you'll need to leave it as NORMALIED_DOES_ID.
I think we should have the same behavior as MTrimWindow.trimBars.add(trimBar);.
I think we should have a test that verifies that the trimBars are not present in the same folder.
I think we should have the same behavior as MTrimWindow.trimBars.add(trimBar);
Instead of throwing the exception, can we just throw it away? That way we can get rid of the catch logic and all three cases together.
Instead of throwing the exception, can we just throw it away? That way we can get rid of the catch logic when it is unexpected.
Instead of throwing the exception, can we just throw it away? That way we can get rid of the catch logic and all the logic is not duplicated.
You can do this in class variable
Is there any way to refactor this method? When is it called from a activity that is called from this activity?
Is there any way to refactor this method? When is it called from a activity that is called from the activity/ presenter?
This test queries are not necessary.
This test queries are not necessary..
This test queries are not initialized with shouldDelete before.
This should probably be a warning, not an error.
This should probably be a warning, not an info.
This should probably be an info, not a warning.
Could we also add an assert that the resource.getAll(new PagingContext(0, 0, false, false)) is not called?
Could we also add an assert that the resource.getAll(new PagingContext(0, 0, false, false)) is the expected order?
Could we also add a check that the resource.getAll(new PagingContext(0, 0, false, false)) does not contain the expected behavior?
I don't think this is good, with this pattern we are using try {... } finally { lock.unlock(); }
I don't like this pattern, why do we need to loop around this?
I don't think this is good, with this pattern we are using try {... } finally { lock.unlock(); } rather than the whole block...
because writer.put() can fail, you should enclose it in a try/finally like: try { writer.put() } finally { writer.close() }
because writer.put() can fail, you should enclose it in a try/finally like: try { writer.put() } finally { writer.close(); }
because writer.put() can throw an exception, you should enclose it in a try/finally like: try { writer.put() } finally { writer.close() }
Should we not assert for null not empty, instead of checking for null before calling process?
Should we not assert for null not in the first place?
Should we not assert for null not just that it's null, instead of checking for null in all cases?
We can merge this into the single line check. Remove the.orElse(null) line.
We can merge this into the single line check. Remove the.orElse(null); line.
We can merge this into the single line check. Remove the if else branch.
Please check your code formatting and save rules. I would expect the 'this' keyword for the calll to the 'this' method.
Please check your code formatting and save rules. I would expect the 'this' keyword for the calll to the 'this' keyword for the calll to the 'this'.
Please check your code formatting and save rules.
Including the null case for the parameter, or is it a better idea? When it's null, please delete the null check for it. If it's not present, please add a descriptive error message. Maybe: "This configuration should be non-negative".
Including the null case for the parameter, or is it a better idea? When it's null, please delete the null check for it. If it's not present, please add a descriptive error message.
Including the null case for the parameter, or is it a better idea? When it's null, please delete the null check for it. If it's not present, please add a proper error message.
Another place to deal with rolling back the transaction in case of error.
Another place to deal with rolling back the transaction in case the transaction was missing something like CommitTransaction.commitTransaction();
Another place to deal with rolling back the transaction in case the transaction was missing something like "Commit transaction after error:"
Why remove? Just put this in the constructor.
Why remove the initResponseMessage parameter? Please use ctx.pipeline() instead.
Why remove the initResponseMessage parameter? Please use ctx.pipeline()
Do we ever expect this to happen?
Do we ever expect this to happen? If so, we should throw an exception.
Do we ever expect this to throw an WorkerOutOfSpaceException?
Should be setText(showNotificationButton, notificationButtonView); here
Should be setText(showNotificationButton) here, or below
Should be a null check
Need to change this to be a String.valueOf(element.getAttribute("role")
Need to change this to be a String.valueOf(element.getAttribute("role"), no?
Need to change this to be a String constant - likely.
Please avoid formatting like } else {... }
Please don't change this inside the if. ;)
Please don't change this inside an if that's a no-op.
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_1>
I think this should be done at the end rather than in the finally block.
the exception message should be changed to "unable to send due to buffer full"
the exception message should be updated with a more useful message.
the exception message should be changed to "unable to send due to buffer full".
This should not be needed as it would have been replaced with a WBeanComponent as default component.
This should not be needed as it would have been replaced with a WBeanBeanValue.
This should not be needed as it would have been replaced with a WBeanBeanValue. Kind of unusual
Sleep might make this test flaky. Would it be ok to do the throttleThread.acquire( channel ) here instead?
Sleep might make this test flaky. Would it be ok to do the test before the rest of the test?
Sleep might make this test flaky. Would it be ok to do the throttleThread.await() here instead?
suggestion } catch (Exception e1) {
suggestion } catch (Throwable e1) {
It looks like the exception is being swallowed only when toBeStopped is true.
To let's create a method setUpServerModules() to return the list of valid modules
To let's create a method setUpServerModules() to return the list of valid monitors (or null) instead of empty checks.
To let's create a method setUpServerModules() to return the list of these fields like this: java setUpServerModules(); //.. }
If we use DataColumn.NUMBER in the DataColumn class, then I don't think we need this new method.
If we use DataColumn.NUMBER in the DataColumn class, then I don't think we need this method.
If we use DataColumn.NUMBER in the DataColumn constructor, then there should be an UP
is this the place that we're hiding this bug? if there's no storage type, then I think we should remove the redundant version.
is this the place for this major release? if not, we'll probably want to be consistent with the 80 chars in the DC, and not with the storage type.
is this the place for this major release? if not, we'll probably want to be consistent with the 80 chars in the DC, and not on the storage type.
I feel like it can be moved to an external method and use it multiple times.
I feel like it can be moved to an external service.
I feel like it can be a leftover of the refactor.
String.valueOf(text)
String.format(null)
String.format(String) does same
WALs not in expected range -> WAL
WALs not in expected range -> wait for WAL
WALs have a better name than WAL.
This method can be removed.
Simpler to just say: for (VDS host : hosts) {
This can be removed.
You don't need to collect the entire stream if it's not used.
Change the message to: "The re-commit has been disabled for the re-commit!");
You don't need to collect the entire stream if it's already done.
You could use == Subject.ANONYMOUS.equals(event.getEventType())
You could use == Subject.ANONYMOUS.equals(event.getEventType()) here
You could have moved the log code to the else block
mmm... I was not so sure why we are changing this from trace to warn?
mmm... I was not so sure about the "ton"...
mmm... I was not so sure about the "to" in future...it's not related to this change...
You only want to use logged. Otherwise you want to log the exception.
You only want to use logged. Otherwise you want to log the exception stack trace.
You only want to use logged. Otherwise you want to log the exception stack trace and remove it.
Create a constructor without the last field?
Create one constructor without the last field?
Create it locally and pass to the constructor?
Restriction should be replaced with [] in this case.
Restriction should be replaced with Restriction.
s/arguments/argument
Please don't use this instance names. It's still the same. Maybe we want to test the new value?
Please don't use this instance names. It's still the same. Maybe we want to test the new class name?
Please don't use this instance names.
why public?
why private, if we move it outside the "if" block?
why private?
I'd suggest not to catch all exceptions, but just let the exception bubble up to the caller.
I'm not 100% sure we can just catch Exception here?
I'd suggest not throwing a more specific exception here, the caller would be responsible for propagating the exception.
A duplicate?
A duplicate of above?
A duplicate.
Not sure if I just can't see it, but should we close the zkWorker if we get an exception?
Not sure if I just can't see it, but should we close the zkWorker if we find an exception?
Not sure if I just can't see it, but should this be wrapped in a try-with-resources block?
Could we break this to : "WatchDog is a free"?
Could this be optimized by a post-processor or something similar?
Could we break this to 'if' statement?
I know this is old code, but I still don't see a reason to change this to java return product.getProductContent().removeAll(toRemove);
I know this is old code, but I still don't see a reason to change this to java return product.getProductContent().removeAll(toRemove); which is confusing.
I know this is old code, but I still don't see a reason to change this of the method. Both removeContent and removeContent are doing the same thing, which is good.
In all the log messages, we use "Exception" instead of e.getMessage(). Can you swap them for consistency?
In all you code, we log.error("could not instantiate class '{}' due to error '{}'", instanceName, e.getMessage()); I think we should print that entire stack trace, instead of just the message.
In all you code, we log.error("could not instantiate class '{}' due to [{}]", instanceName, e.getMessage());
nit: it might be a bit easier to read if it was the last thing to say java if (delegate.latestSequencesPreparedOrAccepted(cacheKey).ifPresent(this::processDigest); return Collections.unmodifiableMap(cachedEntries);
nit: it might be a bit easier to read if it was the last thing to say java if (delegate.latestSequencesPreparedOrAccepted(cacheKey).ifPresent(this::processDigest); return Collections.unmodifiableMap(cachedEntries); Same goes for the line below.
nit: it might be a bit easier to read if it was the last thing to say java if (delegate.latestSequencesPreparedOrAccepted(cacheKey).ifPresent(this::processDigest); return Collections.unmodifiableMap(cachedEntries); Same for the remaining if statements below
Could you please add an explanation in the message?
Could you please add a log message here?
Could you please add an empty default case here?
possible NPE
that have been checked already in cando action
can be inlined.
this should be regionInfo = new CompatRegionCoprocessorEnvironment() {
Is this change needed?
this should be regionInfo?
should use {}-placeholders instead of string concat
could use {}-placeholders instead of string concat
should use {}-placeholders instead of concatenation
constructor name is not required
constructor name is not precise
fDeleteAction=
This naming looks unfortunate as it is not descriptive.
This naming looks unfortunate as it is a call.
This naming looks unfortunate. not descriptive.
Why do you need these separate conversion?
Why do you need these two lines?
Why do you need the second stream here?
Hardcoded order is probably better
Hard-coded order is probably better
Hardcoded order is probably better here
I'm afraid this is a good place to print what we got here? (ie no variable)
I'm afraid this is a good place to print what we got here? (ie no variable name)
I'm afraid this is a good place to print what we are looking for :)
Why did you change these?
Why did you not have an assertion here?
Why did you not have an assertion for server.expect(...)?
If previousFormatParameters is empty you will enter this if while it used to not be the case before.
If previousFormatParameters is empty you will enter this if while it used to not have the previousFormatParameters
If previousFormatParameters is empty you will enter this if while it used the previousFormatParameters
Shall we use a variable here?
Need to log the exception here.
formatting
Please consider adding a Preconditions.checkArgumentcheck to verify that c == '8' is never null.
Please consider adding a Preconditions.checkArgumentcheck to verify that c == '8' is non-null.
Please consider adding a Preconditions.checkArgumentcheck to verify that c == '8' is never null
Please revert this change, too.
Please revert this change, too. e.g. "The number of inputs is not equal to the number of labels"
Please revert this change, too. e.g. "The number of inputs is not equal to the number of keys"
is this necessary? we already have it in SingularityRunNowRequest.
is this necessary? We already have a few variables to test?
is this necessary? We already have a few variables to start with.
Use StringBuilder instead
StringBuilder instead of StringBuffer.append...
You are using StringBuffer instead of StringBuffer.
Seems better to call writers.put(request.getCheckpointId(), buildWriter((CheckpointStartRequest) request)) instead.
Seems better to call writers.put(request.getCheckpointId(), buildWriter((CheckpointStartRequest) request)) so that the code doesn't have to repeat the same code.
Seems better to call writers.put(request.getCheckpointId(), buildWriter((CheckpointStartRequest) request)) so the same stream can be used for a single checkpoint.
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to remove it altogether, no?
Looks like the 4th parameter is no longer necessary. Since the PR targets master/, it would be fine to remove it altogether, no?
Looks like the 4th parameter is no longer needed. Since the getColumnNameOutput is no longer, it would be fine to remove it altogether, no?
Inline statsCalculator?
Inline statsCalculator into this.
requireNonNull
This implementation would be fine for the filtering because it is executed only once per searched value. But for building the bloomfilter at write time it has a huge performance penalty because it is invoked for every value. I would suggest keeping the different hash functions for each parquet primitives to support write time performance. You may implement a convenient method for type T to be used for filtering.
This implementation would be fine for the filtering because it is executed only once per searched value. But for building the bloomfilter at write time it has a huge performance penalty because it is invoked for every value. You may implement a convenient method for type T to be used for filtering.
This implementation would be fine for the filtering because it is executed only once per searched value. But for building the bloomfilter at write time it has a huge performance penalty because it is invoked for every value. I would suggest keeping the different hash functions for every parquet primitives to support write time performance. You may implement a convenient method for type T to be used for filtering.
Just use [JsonUtils](<LINK_0>,%20java.lang.Object%29) instead.
Use { } around if body
Just use [JsonUtils](<LINK_0>, don't use the fields, just the headers.
Californium should be e.getMessage()
Californium -> Data Lake
Californium should be e.getMessage() not printStackTrace()
I think we should make sure that symbols.qualifiedName() is not null.
I think we should make sure that symbols.qualifiedName() is not null (and its name doesn't match)
I think you forgot to add these 2 statements to make sure that symbols contain references to the same name.
This one should be called after onComplete.call().
This one should be called with a onComplete.call().
This one should be called with onComplete.call().
The query string is not used in the test case anywhere.
The query string is not used in the test case otherwise it will be hard to read. Should we just create a URL or something like that?
The query string is not used in the test case otherwise it will be hard to read easily.
Please use codec.dataComplex(codec, decodedDataComplex) instead.
In some cases, it would be good to provide a static import for the codec.
This may not be true.
do we need to preserve this behaviour?
nit: make this a synchronized if it's private?
nit: make this a synchronized
Use createConfiguration(false, keytabFile) to get the keytabFile.
Use createConfiguration(false, keytabFile) to get the keytabFile. The param isn't used anywhere else.
You can omit the createConfiguration unless you inject it.
I think we should keep the old methods and use these in Set methods.
I think we should keep the old methods and use these names.
I think we should keep the old methods and use these in Set methods to check for consistency.
receiptThread.toString().equals(key)
How about objectValue.entrySet().equals(key)?
How about objectValue.entrySet().equals(key)???
This should actually fix the problem, the neighborBlockRead should change from all the segments, not just the pixels, let's add that to all the blocks. A better fix would be to change the all the lines in this method to what is neighborBlockWrappable.
This should actually fix the problem, the neighborBlockRead should change from all the segments, not just the pixels, let's add that to all the blocks. A better fix would be to change the all the lines in this method to what is displayed in the neighborBlockReadHandler.
This should actually fix the problem, the neighborBlockRead should change from all the segments, as well as that.
palka - we can use Collections.emptyList()
s/hostCount/cluster
Users can use Collections.emptyList() if the value is not available.
Using an enum as mentioned above, this would become if (savePaths!= NONE) which seems cleaner to me.
Using an enum as mentioned above, this would become if (saveComponents) which seems cleaner to me.
Using an enum as mentioned above, this would become if (saveComponents) which seems cleaner to me. So if we were to move the value of SOFT_UNIT to where we would like to have it as an enum, then we wouldn't need to store it for each of these.
You should make this explicit that it is (i.e. if (controller.isAreaClicked(mouseOverOnePlayer, input)) {
You should make this explicit that it is (i.e. if (controller.isAreaClicked(mouseOverOnePlayer, input))
You should make this method protected.
Should this method be private?
Should we keep the lock while we're in here?
Should this method be synchronized?
[minor] Can we add a "list" or something like that?
Minor: Do we want to repeat this line?
Minor: Do we want to add a "pipeline" parameter to  pipeline config?
shouldn't be removed
why do we need this?
shouldn't be removed this?
java assertThat(logs.get()).containsOnlyOnce("test debouncer.eventReceived(event));
java assertThat(logs.get()).containsOnlyOnce("test debouncer enqueued more than 10000 events");
I think it would be better to name the logging level here too.
Add a log statement.
Add a log statement above?
Add a log message like
No need to break as it is already in the while condition.
No need to break as it is already in the loop.
No need to break as it is already in the while loop.
I think this is not necessary to check the data type here.
I think this is not necessary.
else {
Wrong variable, should be memberGroupId
Missing null check.
Missing final
Is there a reason you can't use from.getSequencerReference().getPlatformType().getKey()?
Is there a reason you can't use RestUnitUtils.setNone() here to avoid the null check?
Missing null check on from.
I think we can use Math.equals() here but not in the for loop.
I think we can use Math.equals() here but I don't see any reason to change this.
I think we can use Math.equals here.
Could you please print the request ID in the log
I don't think you can use "extractData" here.
I don't think you need to print requestId.
Add localName to the thread names? Makes it easier to debug when logs from multiple instances are merged into the same logging system
Add localName to the param? Makes it easier to debug when logs from multiple instances are merged into the same logging system
Add localName to the localMember map? Makes it easier to debug when logs from multiple instances are merged into the same logging system
scaledLinkDist (i.e. _int_) should be sufficient to calculate the maximum time on start and end of the loop.
scaledLinkDist (i.e. _int_) -> _int_
scaledLinkDist (i.e. _not_ equal to MAX_OFFS_SIE * 1)
why doesn't this be done in the MockIndex constructor?
why doesn't this be done in a finally block?
why is this changed?
I understand this is not good, but you need toBytesRead it should be && this.streamBytesRead == this.streamSize && this.streamBytesRead == this.streamSize && this.chunkSize < this.streamSize && this.streamSize < this.streamSize && this.chunkSize < this.streamSize && this.streamSize < this.streamSize && this.chunkSize < this.streamSize && this.streamSize < this.streamSize && this.chunkSize < this.streamSize;
I understand this is not good, but you need toBytesRead it should be depend on this.streamBytesRead it is only used inside this class
I understand this is not good, but you need toBytesRead it should be && this.streamBytesRead == this.streamSize condition
Verify divide by zero size.
Verify divide by zero length.
Missing white spaces.
Be careful, I know it is the original version of the test method, but I am aware that you're making some modifications to the original version, and I'm not sure if that is the reason to include it, I know it is the original version, but I wouldn't keep it as is.
Be careful, I know it is the original version of the test method, but I am aware that you're making some modifications to the original version, and I'm not sure if that is the reason to include it.
Be careful, I know it is the original version of the test method, but I am aware that you're making some modifications to the original version, and I'm not sure if that is the reason to include the test data, or the original version?
Problems creation user for registration\"}", HttpStatus.CREATED
Problems creation user for registration vs automatic accounting
Problems creation user for registration and activationToken are no longer required
There's no reason to separate the 'clusterId' from the id here. It should be replaced with 'nr.getRackName()'.
There's no reason to separate the 'rackName' from the URL here. It seems like what we do is to do the job of the sub-indexing.
There's no reason to add short labels.
We should add a DEBUG log message here.
We should add a DEBUG log here if the FederationException is thrown
We should add a DEBUG log here (maybe at least on DEBUG?)
Do these two lines have any blocking code?
Do these two lines have the same meaning?
Do we need this?
this log statement is duplicated
this log statement is unnecessary
this should be debug level
So, do you expect the code to crash in those circumstances?
So, do you expect the application to crash in those circumstances?
This is neat! We'll have to remember to use it elsewhere!! ;)
Please remove "protected" modifier since it is not needed.
Please remove "protected" modifier. We are not doing it for the first parameter.
Please remove "protected" modifier. We are not doing it for the second time.
Is it possible to extract this to a method?
Is it possible that a LaserDispatcher will also do this for some reason?
Is it possible to extract this to a class variable?
This method could be reduced to DetailAST lambdaParameters = parent.findFirstToken(TokenTypes.PARAMETERS); if (lambdaParameters == null) { return false; } else if (ast.getType() == TokenTypes.PARAMETER_DEF) { return true; } else { final DetailAST param = parent.getFirstChild().getText().equals(ast.getText()); return param!= null && paramDef.findFirstToken(TokenTypes.IDENT); }
This method could be reduced to DetailAST lambdaParameters = parent.findFirstToken(TokenTypes.PARAMETERS);
This method could be reduced to DetailAST lambdaParameters = parent.findFirstToken(TokenTypes.PARAMETERS); return paramDef.findFirstToken(TokenTypes.IDENT);
nit: [ERROR] /home/travis/build/openmicroscopy/bioformats/components/formats-gpl/src/main/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/commons/lang/StringUtils.java:[127,28] variable fed here
nit: [ERROR] /home/travis/build/openmicroscopy/bioformats/components/formats-gpl/src/main/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/input/RestApi.java:[line 579]
nit: [ERROR] /home/travis/build/openmicroscopy/bioformats/components/formats-gpl/src/main/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/java/org/apache/dubbo/common/base/input/RestApi.java:[line 579]
Could we refactor this to push the predicate to the client as well?
I don't think we should refactor this into a boolean.
Could we refactor this to push the predicate to the client as a class variable?
I don't think we need sdkLocation anymore since it is used only once. We can just use the ExternalProcessUtility class and use it here.
I don't think we need sdkLocation anymore since it is used only in WPCore. We already have util method for this.
I don't think we need sdkLocation anymore since it is used only in WPCore. We already have util method for this in my opinion.
Couldn't you use an instead?
Couldn't you use an empty string here?
Couldn't you use an empty string here instead?
If the group is "db," the current index should be "db", then you should also be able to use try-with-resources to close it. java try ( Admin admin = queryServices.getAdmin()) { TableName tableName = TableName.valueOf(qIndexTable); if (isLocalIndexBuild) { admin.truncateTable(tableName, false); } }
If the group is "db," the current index should be "db", then you should also be able to use try-with-resources to close it. java try ( Admin admin = queryServices.getAdmin()) { TableName tableName = TableName.valueOf(qIndexTable); if (isLocalIndexBuild) { admin.disableTable(tableName, false); } }
If the group is "db," the current index should be "db", then you should also be able to use try-with-resources to close it. java try ( Admin admin = queryServices.getAdmin()) { TableName tableName = TableName.valueOf(qIndexTable); admin.disableTable(tableName, false); }
this is a double-/, you should be able to use a lambda here
this is a double-/ now-ish
this is a double-/, you should be able to use a single statement
You should always pass the [] to the logger. Arguably, it's not the sligtous one.
You should always pass the [] to the logger.  surrounded by a [] array.
You should always pass the [] to the logger.  surrounded by brackets.
Not sure what the one is supposed to be.
Not sure what the string means.
Not sure what the string means here.
I would extract this logic (as well as some other logic in this method) in seperate methods. This entire method is 30 lines long. In my opinion way too long. This does not only provide better code readability but also code reusability.
I would extract this code (as well as some other logic in this method) in seperate methods. This entire method is 30 lines long. In my opinion way too long. This does not only provide better code readability but also code reusability.
Maybe a good idea to return the generated token.
can't we merge this with the previous condition?
are we ok with either of these conditions or just reverse them?
are we ok with this?
AJ, An encounter also has a time limit of time set to close if the  vital map is a pattern. Try 'computeIfAbsent' instead of 'if'. :) The logic could be a performance-specific code if the  vital map is a pattern of  vital map: <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_2> - if the  vital map is a closed file, better to use a time limit of a time limit
AJ, An encounter also has a time limit of time set to close if the  vital map is a pattern. Try 'computeIfAbsent' instead of 'if'. :) The logic could be a performance-specific code if the  vital map is a pattern of  vital map: <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_2> - if the  vital map is a closed file, better to use a time limit of a time limit
AJ, An encounter also has a time limit of time set to close if the  vital map is a pattern. Try 'computeIfAbsent' instead of 'if'. :) The logic could be a performance-specific code if the  vital map is a pattern of  vital map: <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_0> - <LINK_0> - <LINK_1> - <LINK_2> - if the  vital map is a closed file, better to use a time limit of a time limit of a time limit
The code here is the same as "only instructors of the same course". Why are these two different?
The parameters are reversed here.
The code here is the same as testCancelOfNonMatchedUser.
:stuck_out_:
:confused:
:see above:
s/byte/byte/
s/context/redisHost/
Could we please avoid the space char?
Is it possible to use a waitForAssert like this?
Is it possible to use a waitForAssert like this and remove the sleep?
Is it possible to use a latch in all tests?
I think this should be "Unfiltered"
I think this should be "input"
I think this should be "BigDecimal" not "Parts"
ok, I've been wondering if it makes sense to add a _new _()_ method to ArgSpec and then implement the same method in ArgSpec. I think that's a better solution.
ok, I've been wondering if it makes sense to add a _new _()_ method to ArgSpec and then implement the same method.
any reason not to add a ArgSpec interface?
suggestion noEntryFoundDialog.setContentText("No entry found for ISBN: {}", identifier + ".");
suggestion noEntryFoundDialog.setContentText("Failed to...");
suggestion noEntryFoundDialog.setContentText("(" No entry found.");
Is this should be primitive?
Is this should be true by default?
Is this for debugging?
This code is repeated a lot. Can we factor it out into a static method?
This code is repeated several times. Can we factor it out into a static method?
This code is repeated a lot. Can we factor it out?
do not set the correlationId for the request. It is only applicable for the reqeust of the response.
do not set the matcher each time and use the matcher set in the last iteration. It is only applicable for the reqeust of the response.
asserttrue
Why do we need this check?
Why do we need this check? If this result is an error, it's OK to leave it as it was.
Why do we need this check? If this result is an error, it's not an error.
We should show the entity location in the exception. We should show the user the link.
We should show the entity location in the error message. We should show the user the link.
We should show the entity code.
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
I think this broke the consistency: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
I think this broke the findbugs build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
Why don't you use the iterator?
Why don't you use the expected exception here?
Why don't you use the expectException here?
You can just use getFieldValue(Json.class); here
You don't need to add more log statements here
You can just use return here
Can you move this whole method to MojoBase?
Can you move this whole block to the base method?
Can you move this in to UIUtils.showUserUpdatedPocketCode?
zoomInEnabled = true;
zoomInEnabled = zoom.create().setAmount(zoom);
zoomInEnabled = true; and this method only has one zoomIn
Perhaps you can extract this into a private method (i.e. private RequestProgress<AllTypes> POLLING_RATE)
Perhaps you can extract this into a private method (i.e. use it from AsyncTestUtils)?
Perhaps you can extract this into a private method (i.e. use it in ThreadFactory)
Could you add { } around the if body?
Could you add { } around the non-null check?
Could you add { } around the non-null checks?
use a final boolean in the class?
use a final boolean in copyFileIfNeeded
use a final boolean in the class
Is this really something we have to do? If the request is the same, could we put it by a new flag?
Is this really something we have to do? If the request is the delete we should log a warning, right?
Is this really something we have to do? If the request is the same and we don't have a new value, I think we could just put the check on and deleteOptions.
You can use nextBatchFuture.setException(new IllegalStateException("Mock failure"))
You can use nextBatchFuture.setException(new IllegalStateException("Mock failure"));
You can use nextBatchFuture.setException(new IllegalStateException("Mock failure")) here.
[StringUtils.isBlank](<LINK_0> will return true for " " strings.
[StringUtils.defaultString(encryptedValue))](<LINK_0> will return true for "encrypted_value" which is not the "text".
[StringUtils.defaultString(encryptedValue))](<LINK_0> will return true for "encrypted_value" which is not the "text". WDYT?
Don't print in console output :)
Don't print in console output.
Don't print it.
can there be no "else" clauses?
can just pass in a mandatory parameter for the message.
can just pass in a Map here and then have a String key
This is too early fqDB. If the new question is older than 1 question, we should throw an exception from updateFeedbackQuestion().
This is too early fqDB. If the new question is older than 1 question, we should throw an exception from updateFeedbackQuestionQuestion().
This is too early fqDB. If the new question is older than 1 question, we should throw an exception from updateFeedbackQuestionQuestion.
This should work, but I guess that the lifecycle methods (VoiceRegistry) are not loaded in every test. Does it work?
This should work, but I guess that the lifecycle methods (VoiceRegistry) are not loaded in every test. Does it matter?
This should work, but I guess that the lifecycle methods (throws Exception ) are not necessary.
Do you need a space after nullSafeEquals?
Do you need a space after the parenthesis here?
Do you need a space here?
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetPushSetupAlarm should be tested on an EKnownDevice domain, not an EKnownDevice.
SetPushSetupAlarm should be tested on an EKnownDevice instance.
if (jsonInfo.equals("err"))
if (jsonInfo.equals("err")) {
if(jsonInfo.equals("err"))
Maybe remove this and use logger.warn(error, ex)
Maybe remove this and use logger.debug()
Maybe remove this.
minor: consider using try-with-resources
minor: consider using try-with-resources for these
static import
This is also incorrect. @rishabh-997 application constants should be used in the code.
This is also incorrect. @rishabh-997 application constants should be used for retrieving information from patientEntities.
This is also incorrect. patientEntities.get(0) will return null for it and expectedPatientEntity2.
There is a nice way to do this.
Maybe the way to do this is not to depend on the class name.
There is a nice way to do this. :)
StringUtils.equals are used for Long and Long
StringUtils.equals?
StringUtils.equals are efficient
If we threw this exception, then will will not be caught and logged as severe
If we threw this exception, then will will not be caught and there is no need to wrap logic here
If we threw this exception, then will will not be caught and there is no need to wrap
This should be done in an IntentService. This approach is likely to lead to issues with rotation
This should be done in a finally block.
This should be done in a try with cursor.moveToFirst(), not in the cursor.
Is this doing what I think it is -- using a normal directory as temp directory - outside or temp folders...
Is this doing what I think it is -- using a normal file as temp directory - outside or temp folders...
Is this doing what I hope?
It's really hard to come up with a name for this.. not happy with this because it suggests action with DO but doesnt specify the action. I am unable to come up with any better though. Will post if I do.
It's really hard to come up with a name for this.. not happy with this because it suggests action with DO but doesnt specify the action.
nit: rename this..
Since we're modifying this line, feel free to remove the String 'username' variable and just inline the boolean to displayError.
Since we're modifying this line, feel free to remove the String content and getString() calls.
Since we're modifying this line, feel free to remove this as well
Leftover debug statement?
Format this file.
Leftover debug code?
:+1: for using this kind of thing
:+1: for using this later on.
:+1: for using this kind of code
Why are we catching an exception here?
Why are we blocking here?
Why?
Why do you need another set? Just use fTagLocations to check if it is there or not
Why do you need another set? Just use fTagLocations to check if the entry is there or not
Why do you need another set here? Just use fTagLocations to check if it is there or not
Should we also check for index > 0?
Should we also check for this?
Should we also check for null?
Please use more descriptive error message.
Please use log4j-style logging
Please use log4j.
I generally prefer the empty string comparison over the comparison, a single integer comparison would be more readable than the other string comparison.
I generally prefer the empty string comparison over the comparison, a single integer comparison should be avoided.
I generally prefer the empty string comparison over the comparison, a single integer comparison would be more readable and more readable.
Is there a reason to use 'try-with-resources' here instead of 'finally'?
Is there a reason to use 'try-with-resources' here instead of 'try' statements?
Is there a reason to use 'try-with-resources' here instead of 'try'?
I would prefer not to use this method in the TemplateProcessor, because it's not clear how to create new language data.
I would prefer not to use this method in the TemplateProcessor, because it is not clear how to create the TemplateProcessor knows about the template.
I would prefer not to use this method in the TemplateProcessor, because it's not clear how to create the TemplateProcessor knows about the template.
Let's be consistent and use DiskImage.Builder instead of Collections.singletonList.
Let's be consistent. I see this method exists in the master. What do you think?
Let's be consistent. I see this method exists in the master.
Are you sure it does not matter?
Are you sure it's not needed?
Are you sure it's required?
Accidental white spaces?
Accidental IDE?
Formatting
These five lines should really all be in their own method, along with the parsing of the timestamp in the beginning.
These five lines should really all be in the beginning of the method, along with the parsing of the timestamp in the beginning.
These five lines should really all be in the beginning of the loop, along with the parsing of the timestamp in the beginning.
Why not to catch Exception here?
This is a good idea. You need to have a test for this :)
Why not to catch Exception?
This should be done before calling the non-view method, because we don't really need to go through all the buttons.
This should be done before calling the non-view method.
This should be done before using the non-view fragment
shouldn't need to handle the response.
shouldn't the response be fetched from the database?
Remove call to the getSmsDetails
I don't think you need to add the default gate name to the error message. Isn't it enough to provide that name?
I don't think you need to select the built-in profiles as the built-in profiles is the default values.
I don't think you need to select the built-in organizations here.
I think it's safe to use StringUtils.hashCode() for this kind of thing.
I think it's safe to use StringUtils.hash() here.
I think it's safe to use StringUtils.hashCode() for this.
wow, can we just keep totalLifespans and use totalLifespans.getAsInt() every time the value is used?
wow, can we just keep totalLifespans.getAsInt() every time the value is used?
wow, can we just keep totalLifespans and use totalLifespans.getAsInt() every time the value has changed?
use try-with-resources
final
This should be above the try()
we're rebuilding these key names every time _android_devices is called. Is there a reason we didn't pull it out?
we're rebuilding these key names every time _android_devices is called. Is there a reason we didn't use it in other places?
we're rebuilding these key names every time _android_devices is called. Is there a reason we didn't use it in the future?
cle.getCloudlet().getVm().getFreePesNumber() is a Cloudlet, so no need to call it again
cle.getCloudlet().addFreePesNumber() is a cle.getCloudlet().removeFreePesNumber() is a cle.getCloudlet().addFreePesNumber(). Likewise for nextCloudletFinishTime
cle.getCloudlet().addFreePesNumber() is a cle.getCloudlet().removeFreePesNumber() is a cle.getCloudlet().addFreePesNumber(). Likewise for nextCloudletFinishTime!
why create a new IntervalList? why not just use snp.getChrom()?
why create a new IntervalList? why not just use snp.getChrom()?
final
java8-isation [forEach]
java8-isation forEach loop
Guava formatting
You can have this method and pass the arguments to the nodeIndexMatcher.onMatchingSchema( state, indexes, node, after.propertyKeyId(), values) to the method, and then use that here.
You can have this matcher and pass the values collection to the OrderedPropertyValues.of method call, right?
You can have this method and pass the values collection to the OrderedPropertyValues.from() method.
We could still use the unbound parameter, even if you do this in EnumerableTest.
We could still use the unbound parameter, even if you do this in EnumerableLimitSortBuilder.
We could use the Null check here too.
TimeUnit.DAYS.toMillis(System.DAYS)
TimeUnit.DAYS.toMillis(300)
You're setting this value over what it's set in the constructor. Why don't you use the DEFAULT value?
setErrorMessage
setErrorMessage or setErrorMessage
setErrorMessage?
Put in a static variable, (static) for you avoid "//Folder.jpg".
Put in a static variable, (static) for you avoid "//qualify"
Put in a static variable, (static) for you,
Could you please elaborate on why is the DC 1 here?
Could you please also check that the ksession is still null?
Could you please elaborate on why is the rational of the failure here?
This list is not used anymore.
This list should only contain expectedConceptEntity1?
This is not used anymore.
Please extract this into a method, e.g.: private ExpressionAnalyzer createWithoutSubqueries( metadata.getFunctionRegistry(), session, types, ImmutableList.of(), node -> new IllegalStateException("Unexpected Subquery".of()));
Please extract this into a method, e.g.:.map(Expression::format).
Please extract this into a method, something like isExpression(Expression expression, ExpressionAnalyzer::create)
you don't need this.
you don't need this. You could just call registerClusteredLockManager directly.
you might want to check the upper case basis to make it clear there's a cache.
same suggestion as above with Class<CronJob>
Camel case
Camel case please
Reword this to "Aborted".
Reword this to "Aborted"
Does this need a context.
Constants.MB should be in the same level.
Constants.MB should be in the same way as it is in the migration
Constants.MB?
can be replaced with Stream.of(processors)
can be replaced by ListTopologyProcessors(processors)
can be replaced by ListTopologyProcessors
A better name for this is 'lastAlias' and 'date'.
A better approach would be to create a method in DatasetForData which returns an object and then return DatasetKey for a given date. That way, we don't need to create a new object.
A better approach would be to create a method in DatasetForData which returns an object and then return DatasetKey for a given id. That way, we don't need to create a new object.
Can you remove this?
Can you remove this {} for all cases?
Can you remove this {} for all branches?
no need for final here. You can use this inside of the method.
Shouldn't you be assuming that the scheduler is not running yet?
no need for final here. You can use this directly in GlusterConstants
"The server does not support any of the driver and server versions that you are using."
"The server does not support any of the driver and server versions that you are using a driver."
Worth doing this with a logger.warn()?
I think we can rename this to subPiOne and childTwo.
I think we can rename the test to be more specific: deploymentService.isDeployed(deploymentUnit.getName());
I think we can rename the test to be more specific: deploymentService.isDeployed(deploymentUnit.getName())
This is optional, but I wonder if this should be optional.
nit: I believe this is a debug message instead of System.out.printf.
nit: I believe this is a debug statement that should be removed here.
this is not a good practice
this is not a good idea
this is not a bug fix
why do we need this?
why do we need this line?
please remove this line
Please add curly braces around the body: } catch (SocketException ignored) { continue; }
Please add curly braces around the body: } catch (SocketException ignored) {... }
Please add curly braces around the body
Do we really need a new exception type? Should we just use Throwables.propagate(e) here?
addTaskInternal will take care of that
Do we really need a new exception type? Should we just use Throwables.propagate(e) here? Formatting is a little off?
why is this line necessary?
rename 'topTableIsEdited'?
rename 'visible'
Why do you need to a nested synchronized?
Why do you need to a synchronized on the factory?
Why do you need atomic?
The "main" is intended to be constructed. If you do this (which is the default value) then this will be called, resulting in the debug output. I would prefer the following instead: java public static void startServer() { LogReplicationContext context = new LogReplicationContext(); opts.put("--network-interfaces", getAddressFromInterfaceName((String) opts.get("--network-interface")); opts.put("--bind-to-all-interfaces", false); }
The "main" is intended to be constructed. If you do this this will lead to a pre-load exception.
should the "main" be the default?
This is invalid format.
I think this is invalid format.
I think lastIndexOf(':')() can be used.
This won't be how Jackson default handles a JsonProperty annotated method, it'll attempt to remove the Java class name.
This won't be how Jackson default handles a JsonProperty annotated method, it'll attempt to remove the Java class prefix of get or is.
This won't be how Jackson default handles a JsonProperty annotated method, it'll attempt to remove the Java class something that was loaded beforeJsonIgnore.
code style
code format
code duplication
we can use multi-catch here.
Duplicate line
Duplicated code
Can we use the constant for the uuid so it's more visible?
Can you use the constant for the uuid so it's more visible?
Can we use the constant for the uuid so it's more new?
remove debugging code
remove debugging.
remove debugging output
coding style
startPosition - 1
startPosition - 1?
Why do we need frontend changes when we don't plan to expose Guids?
Why do we need frontend changes when we don't plan to expose Guids in the UI?
Why don't we use return Guid.Empty here?
suggestion throw new NotEnoughArgumentsException();
Do we need this?
Typo - missing the second {}
rename to child
rename to childItem
rename to rootItem
Can combine the two lines into a single line.
Can combine the body of the loop.
Can combine the body of the two lines onto one.
should not be protected
should be private
should not be private
I'm not getting it. Why those beans are checked? If this is a change about virtual facility attribute, we should check presence of Attribute and Facility within the beans read from message.
I'm not getting it. Why the beans are checked? If this is a change about virtual facility attribute, we should check presence of Attribute and Facility within the beans read from message.
I'm not getting it. Why those beans are checked? If this is a change about virtual facility attribute, we should check presence of Bl entity by pref.
An exception is caught and converted to a runtime exception. Any reason to catch this?
An IllegalArgumentException is caught here, which is not caught. Any reason to catch a checked exception here?
An IllegalArgumentException is caught here, which is not caught. Any reason to catch a checked exception?
Can the code be simplified to: if (allServers.size() == 0) { return Collections.emptyList(); }...
Can the code be simplified to: if (allServers.size() == 0) { return Collections.emptyList(); } Then we can remove the duplicate check for null.
Can the code be simplified to: if (allServers.size() == 0) { //... }
don't we want to default to UTF-8 here?
don't we want to change the existing behavior?
don't we want to use the BuildWebContextFactory here?
could this call be moved to the export project?
could be moved to the export project in the resources.
could be removed
@vmaletta use final
@vmaletta use search instead
@vmaletta use search criteria
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace this usage of a generic type. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace this usage of HashMap and simply use a synchronized block. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace this use of isEmpty() as it does a safe comparison. [![rule](<LINK_1>](<LINK_2>
I actually like this. Why do we need to call applyFilter() and handle the filter in the case the filter is not present?
I actually like this. It would be better to remove the call to applyFilter() and use the filter in the layout to get the filter value.
I actually like this. It would be better to remove the call to applyFilter() and use the filter in the layout to get the filter value (if available).
I'd make this code more compact.
I'd make this an empty line, rather than a blank line.
I'd make this code more readable.
It seems this is missing a null check.
It seems to me there is no need to pass the class name around. This seems to be unnecessary
It seems to me there is no need to pass the class name around. This seems to be changing.
- convertValue isn't really a great way to handle this. I'd vote for refactoring this method to something like: java public static Object convertValue(Object deserializedObj) { Map<String, Object> fields = new HashMap<>(); for (Schema field: fields) { keyValues.put(name(), convertValue(indexedRecord.get(row)); } }
- convertValue isn't really a great way to handle this. Suggest setting the type of underlying object to a Map<String, Object> - the type of convertValue isn't necessary.
- convertValue isn't really necessary.
If all of these are null, default should be the default.
If all of these are null, this code throws a NPE.
If all of these are null, this code throws an exception (which is what is expected).
So we basically use this to bypass hostname checks?
So we basically use this to bypass registry requests?
So we basically use this to bypass hostname registration?
Is there a way to "track" the number of consecutive failed attempts to open that pack file?
I think we should allow to also log the stack trace by switching log level to DEBUG to enable analysing problems we don't yet anticipate
Is there a way to "track" the number of consecutive failed attempts to open that pack file? I think we should keep the log message and allow a user to handle the error.
This doesn't seem right...
This doesn't seem right... can you please remove isExpired()?
Could you remove isExpired and don't call insertEntry?
Make it public
Make it final
Make it protected.
Nitpick: The API is to return a json (you forgot to put it rather than get("tuples") for each invocation of the method.
Nitpick: The API is to return a json (you forgot to put it rather than get("tuples")
Nitpick: The API is to return a json (you forgot to put a.get("tuples") rather than the return value.
Is this logic needed? I thought it is only needed if bufferId is -1.
Is this logic needed? I thought it is only needed on the if block.
Why is this logic different than fileId == -1?
Should be Response.ok()
Is it intentional to return a MongoDatabase?
Why not just mappedFeatures = root.stream()?
You can use the parser-style method in the spatial reference object, and use it here, so the spatial reference will be created correctly.
You can use the already parsed geometry available. Instead, just call the parser.execute() on the geometry.
You can use the already parsed geometry available.
This should be refactored out to a method, since it would be more readable.
This should be refactored out to a method, and return this instead.
This should be refactored out to a method, since it would be more readable
I think it would be easier to do this: java TMutation tm = cm.toThrift(); List<TCondition> conditions = convertConditions(cm, compressedIters); //...
I think it would be easier to do this: java TMutation tm = cm.toThrift(); List<TCondition> conditions = convertConditions(cm, compressedIters); cmidToCm.put(cmid.longValue(), new CMK(tcondMutaions);
I think it would be easier to do this: java TMutation tm = cm.toThrift(); List<TCondition> conditions = convertConditions(cm, compressedIters); cmidToCm.put(cmid.longValue(), new CMK(tcondMutaions));
Are you sure the 'enabled' flag is correct?
you can use the new UDC as a constant here.
Are you sure the 'enabled' flag is correct here?
I'm sure in this case, but.trim() won't be called if watchService is null
I'm sure in this case, but.trim() won't be called if watchService is null.
I'm sure in this case, but.trim() won't be called if watchService is null?
I think this is invalid, as the expression _arguments is not valid.
I think this is invalid, as the data type can either be a single-valued number or a sub-valued number
I think this is invalid, as the expression _arguments is invalid, but the data type is invalid.
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this call from a constructor to the overridable "addListener" method. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_1> 'Severity: MAJOR') Remove this call from a constructor to the overridable "addListener" method. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this call from a constructor to the overridable "add" method. [![rule](<LINK_1>](<LINK_2>
Do we want to add a ScanResultValue((List) srv.getEvents()) at the end of the check?
Do we want to add a ScanResultValue((List) batch).getOnlyElement((List) srv.getEvents())?
Do we want to add a ScanResultValue((List) batch).getOnlyElement((List) batch) here?
s/UpdateCluster/Edit
please use <LINK_0>
s/updateCluster/getReturnValue
log this instead of debug logging please
log the missing plugin name here
log this instead of debug logging.
Should we check for null here?
Should be VALUE, not null.
Should we break out to the loop?
It is better to throw an exception if there is no wallet for the wallet.
It is better to throw an exception if the user doesn't have the wallet type.
It should be new StringTokenizer(walletLogin).
Actually the concept with id 88 in the test dataset is a drug and not a test, so this should be "DrugOrderValidator.java"
Actually the concept with id 88 in the test dataset is a drug and not a test, so this should be DrugOrderValidator
Actually the concept with id 88 in the test dataset is a drug and not a DrugOrderValidator
I think this assertion is redundant. You should just check if the value is an int.
I'm wondering if this assertion is redundant. You should just check if the value is an int.
I think this assertion is redundant. You should just check if the value is an instance of HashCode.fromString.
consider moving the if to the addVmCinderDisks method.
Consider moving the if to the addVmCinderDisks method.
please remove the if, it's not needed
Should use the term "record" here.
Should use the term "record" here. All the other tests should be aligned: JTable(myModel);
Should use the term "record" here. All the other tests should be aligned: JTable(myModel)
Use getServiceRegistry().getService(IMetadataService.class)
Use getServiceRegistry().getService(IService)
Use getServiceRegistry() to create a new logger class here.
this is redundant check - just use Objects.hash()
this is redundant check - just use Objects.hashCode(additionalOptions)
this is redundant check - just use Objects.equal(a, b)
It looks like we are not using placeholders in tests..
It looks like we are not using placeholders in tests.
It looks like we are not using placeholders in parametersConsumer.
I think you should use a constant for the "magic" length
I think you should use a constant for the "magic" length (I know you didn't do that before but looking at the code base).
I think you should use a constant for the "magic" length (I know you didn't do that for the other classes).
:bug: this is a bad idea, given the 65 65 extension does not make sense for a user setup, which makes it harder to expire by default.
:bug: this is a bad idea, given the 65 65 extension does not make sense for a user setup, which makes it less likely that the 30 minutes
:bug: this is a bad idea, given the 65 65 extension does not make sense for anyone.
Again, please don't use tabs as it makes the code more readable.
label2 can be null
Again, please don't call this unless ImportNode is is a ImportNode.
nit, adding parenthesis to the calculation so it is easier to read.
nit: adding parenthesis around _softConstraints.stream().map(v -> v)
nit: adding parenthesis around _softConstraints.stream().map(v -> _softConstraints.stream())?
do you think checkArgument is more appropriate here?
"for" -> "for"
"for" -> "for"?
An empty string?
permission check is a bit strange
An empty string? Can we check for null somehow?
Why not just use the getStringForArticleLanguage() function from the getArguments()?
Why not just use the getStringForArticleLanguage() function from the getArguments() call?
Why not just use the getStringForArticleLanguage() function from the EntityModel?
nit: return results.entrySet().stream().map(e -> e.getKey(), e.getValue().isSuccessful()).collect(Collectors.toMap(e -> e.getValue().getErrorMessages(), e -> e.getMessage()));
nit: return results.entrySet()
nit: return results.entrySet()?
Here indentation is screwed again. Just remove the whole method with this example
Don't change these please
Here indentation is screwed again. Just remove these changes
Move this to a ResponseUtil class instead of duplicating the code here.
Move this to a ResponseUtil class?
Move this to a ResponseUtil class instead of duplicating the code.
I would prefer to check isInAnyOrder() first, then use it in the else clause of the if below
I would prefer to check isInAnyOrder(testSuite, testClass) instead of calling getTestSuite() twice.
I would prefer to check isInAnyOrder(testSuite, testClass) instead of calling getTestSuite()
Style-nit: Parens aren't necessary here around the conditional block.
Style-nit: Parens aren't necessary here around the conditional statement.
Style-nit: Parens aren't necessary here around the new operator.
move this line in to a method to be consistent with line 80
move this line in to request
move this line in to a method to be consistent with line 80.
I think this is better: java if (!isTryCatchOrFinally(parent) && ast.getParent().getType()!= TokenTypes.LITERAL_ELSE)!= parent) { updateCommitVariable(prevScopeUnitializedVariableData); }
I think PrevScopeUnitializedVariableData should be renamed.
I think PrevScopeUnitializedVariableData is a better name.
The.sorted() method could be used here, then you don't have to do it.
The.sorted() method could be used here, so it's's way more readable.
The forEachOrdered
maybe we can throw an exception here if the currentSortBuffer is null?
maybe we can throw an exception if the currentSortBuffer is null?
could you please check if currentSortBuffer is null? I guess it's not @Nullable.
I think onError(timeoutException) is generally better?
I think onError(timeoutException) is generally better than throwing an exception since it can kill the thread.
I think onError(e) is generally better than throwing an exception since it can kill the task entirely.
Can we check if this project exists or not?
Does this really work with CDT or CDT? If so, I'm OK with it.
Does this really work with CDT or CDT? If so, I'm OK with this change.
Why not chain these setting in the previous statement?
Why not chain these setting in the previous constructor?
Why not chain these setting in the previous clause?
the caller should throw exception instead of returning ValidationResult
the cast is not necessary, shouldn't it be done automatically?
the caller should check if the value is not null here, not not.
Shall we remove the empty line?
Shall we move this to debug level
isDebugEnabled
Could you move the new DefaultStatisticsServiceConfiguration() to this class?
Could you move the new DefaultStatisticsWriter() to this class?
Could you move the new DefaultStatisticsServiceConfiguration() to this class and remove the constructor?
Nitpick: this is an unnecessary space.
Please change this to motech.tearDownTime.
Nitpick: this is an unnecessary space
This is not a good name, it should be "badPluginInfos" or something. It's not a boolean or a Boolean
This is not a good name, it should be "badPluginInfos" or something.
This is not a good name, it should be includeJson or something.
Perhaps have a default method named isAlternativePresent(String name) so that we will be more confident that alternatives doesn't have the same name?
Perhaps have a default method named isAlternativePresent(String name) so that we will be more confident that alternatives doesn't have the same effect?
Perhaps have a default method named isAlternativePresent(String name) so that we will be more confident that alternatives would be present/unnecessary?
This logic partly duplicates the loop above that is using GoImportOptimizer#findDuplicatedEntries. This leads to duplicated error message![screenshot 2015-09-09 21 44 35](<LINK_0>
This logic partly duplicates the loop above that is using GoImportOptimizer#findDuplicatedEntries. This leads to duplicated entries that are not necessarily duplicates.
This logic partly duplicates the loop above that is using GoImportOptimizer#findDuplicatedEntries. This leads to duplicated entries that are not necessarily exist in GoImportOptimizer#findDuplicatedEntries.
Won't this change prevent the use of the Alumnini? if so, it could be refactored into a method, which returns the next time as well.
Won't this change prevent the use of the Alumnini? if so, it could be refactored into a method, which returns the next time and is being deleted.
Won't this change prevent the use of the Alumnini? if so, it could be refactored into a method, which returns the next time and is being handled by the else.
One more.
One more. Could you remove this try/catch.
One more. Could you remove try/catch.
Missing space after )
Missing space after,
Missing space after,.
I don't think we should be using try catch here as there is no exceptions thrown by the method.
I don't think we should be using try catch here as there is no failed value.
I don't think we should be using try catch here as it is already caught in the catch block.
Same here. If you're just going to return an empty string, the API version will be an empty string.
Same here. If you want to test this logic that is performing the job, it'd be good to lift this out into a utility method.
Same here. If you want to test this logic that is performing the job, it'd be good to lift this out to a utility method.
As with others, I would not assert on the result of the operation, only on the resilience strategy being invoked.
As with others, I would not assert on the return value of the operation
As with others, I would not assert on the return value of the operation, only on the resilience strategy being invoked.
This should be TableMeta.queryType()
This should be TableMeta.queryArray().
This should be TableReference.queryType().
use this utils method to show error <LINK_0>
use this utils method to hide error <LINK_0>
use this utils method to show error <LINK_1>
Please parse exception to parse it.
Please parse exception to parse here.
Please include the cause exception in this response
IMO, you can merge both ifs if (rv == null ||!needsUnboxing(ctx)) return null;
IMO, you can merge both ifs if (rv == null ||!needsUnboxing(ctx))
here you can merge both ifs if (rv == null ||!needsUnboxing(ctx))
Are we sure that we should have the same values in the map?
make new attributes final ITmfStateSystem
Are we sure that we should have the attribute with the correct ID?
... 1000L?
" age". TimeUnit.SECONDS.toMillis(milliseconds)
" age".
Dangerous whitespace here.
Dangerous whitespace
Dangerous whitespace here!
why break?
CriticalMuleError(List<Throwable> errors>) {
CriticalMuleError(List<Throwable>) is a huge method!
missing final
How is this locking necessary?
This needs to be synchronized
getGMFDiagram()
get rid of this
getGMFDiagram().getDRepresentation().worked(1)?
This is registered at line 631 to 76. Not sure if you want to do this.
This is registered at line 631 to 111, so the PR still does not need to be re-thrown
This is registered at line 631 to 76. Not sure if that is good, but we can leave it as it is.
Please make sure the message is consistent with the format.
please rename to sample
Please make sure the message is updated properly
I think we should use Build.VERSION_CODES.JELLY_BEAN
I think we should use getExternalFilesDir(String, String) instead of hardcoding.jpg form.
I think we should use getExternalFilesDir(String, String) instead.
what if the annotation is null before this cast?
what if it was null before the previous check?
what if the annotation is null before this cast?
I think you should return a 404 instead, which shows the issue
I think you should return a 404 instead, which shows the 404.
I think you should return a File not a byte[].
nit: import org.apache.hadoop.mapreduce.db.db.db.DBOutputFormat()
nit: import org.apache.hadoop.mapreduce.db.db.DBOutputFormat()
nit: I think these constants should be defined in the Constants class.
Close this with it
Close this with a.
Close this with a./
Typo: "hinky"
Typo: "finky"
Typo: "hinky" -> "from made"
IOException is not thrown in this method.
Why is this method public?
Why is this change needed?
Could also be a void
Could be a static import.
Could probably be a static import.
See getAllLifelines remarks
Add a hashset instead of an iterator: java Set<Operand> allOperands = allOperandsCache; allOperands = allOperandsCache.stream().filter(AllContents.of(getNotationDiagram()), ISequenceEvent.VERTICAL_RANGE).forEach( allOperandsCache -> allOperandsCache.add( allOperandsCache));
Add a hashset instead of an iterator: java Set<Operand> allOperands = allOperandsCache; allOperandsCache = allOperandsCache.stream().filter(AllContents.of(getNotationDiagram()), ISequenceEvent.VERTICAL_RANGE).forEach( allOperandsCache -> allOperandsCache.add(allOperands));
this.keyNativeHashCode = requireNonNull(keyNativeHashCode, "keyBlockNativeEquals is null");
this.keyNativeHashCode = keyBlockHashCode;
this.keyNativeHashCode = keyBlockHashCode; this.keyBlockNativeEquals = keyBlockHashCode;
Good idea. Will do.
As far as I understand we are testing two different things with the sameTermination method and a separate test case.
As the same here, will be difficult to understand.
Why do we need to loop on 'role_id' for each role?
Again, we don't have to change this code - since it is already executed from the "next" method, so better to skip such loop.
Again, we don't have to change this class for role role. If we do not allow it from DB, we can move this whole method to SQL injection.
Pull this out into AbfsInputStreamContext.build()
Pull around and use the field too
Pull around and use the field too?
this should also be wrapped in a RxTextView.textChangeEvents()
This should also be wrapped in a RxTextView.textChangeEvents()
This should also be wrapped in a RxTextView.
1) Is this change correct? 2) Why do we need to update the error message?
1) Why do we need to call.getJDBCTypeId() for each enum? 2) Why do we need to use.equals()?
1) Is this change correct? 2) Why do we need to call getTypeId() more than one?
@merciesa maybe matter of taste, but why not i-- instead of i -= 1?
@vilchik-elena why not i-- instead of i -= 1?
@vilchik-elena Why not i-- instead of i -= 1?
The original code was pretty sketchy. I think it's fine to leave generatedKeysResultSet and null in that case.
The original code was pretty sketchy. I think it's better to keep the null check.
The original code was pretty sketchy. I think it's fine to leave generatedKeysResultSet and new[].
We have a few conventions in dasein: - for collection return types we use either T[] or Iterable<String>, - when returning such collection we never return a null, but an empty list, we simply return AutoScalingData(new ArrayList<>());
We have a few conventions in dasein: - for collection return types we use either T[] or Iterable<String>, - when returning such collection we never return a null, but an empty list instead of an empty array to avoid a NullPointerException, as the compiler will tell us that we have to do a null check, but the compiler will tell us an empty list instead of null.
We have a few conventions in dasein: - for collection return types we use either T[] or Iterable<String>, - when returning such collection we never return a null, but an empty list instead of an empty array to avoid a NullPointerException, as the compiler will tell us that we have to do a null check, but this is probably better expressed by using [Collections::emptyList](<LINK_0>
why not use equals here?
why not use ExpressionTreeRewriter.isDefaultRewrite()?
Why not use equals here?
Does this need to be closed?
Does this actually test the same behavior?
Does this actually test the same behavior as before?
Actual value is on the left, expected on line 107
isEmpty()
nit: Use assertEquals()
Does the method need to be public?
<LINK_0>
Does the method require throwing Exception here?
This line is unncessary. You can use this here: <LINK_0>
This line is unneccessary. You can use this here: <LINK_0>
This line is not required.
Just curious, what's the purpose of this change?
Just curious, what happens with this if an NPE?
Just curious.. Unnecessary check for putIfAbsent.
If not inlined, requestedCount reference should be read into a local variable outside the loop.
If not inlined, this should be read into a local variable outside the loop.
If not inlined, it will be easier to read as compareAndSet and use a atomic field in all cases.
fix formatting add space after bracket
fix formatting add a space after bracket
fix formatting add space after bracket I think
Before, if there was an error, it would setToolTableJson_ID when the version is null. Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Before, if there was an error, it would setToolTableJson_ID when the workflow is in progress. Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Before, if there was an error, it would setToolTableJsonGeneration at the end of the check, whereas now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
I didn't see a reason for this change.
I didn't see a reason for this variable.
I didn't notice this in the PR, but I'm not sure why we need to remove this line and set the link to the appropriate iconSpinningAnimator. I would recommend to make this final.
this can be set by user
this can also be set by user
this can be set by user.
I'm a bit picky here, but the tests would be clearer by replacing those 3 lines by a call to a method, such as this.store = getStore(KEY_SET_A, KEY_SET_B); private Store getStore(Set<String>... sets) { Map<String, String> originalStoreContent = getEntryMap(sets); FakeStore fakeStore = new FakeStore(originalStoreContent); return spy(fakeStore); } especially since there's a getCache() method to encapsulate the cache creation
I'm a bit picky here, but the tests would be clearer by replacing those 3 lines by a call to onEvent.
I'm a bit picky here, but the tests would be clearer by replacing those 3 lines by a call to a method, such as this(fakeStore).
Should this line be moved to line 41?
Should this test be on  CircleShape?
Should this line be moved as a check of > 0?
I think this should use a foreach loop instead of a loop.
I think this should use a foreach loop instead of the old one...
I think this should use a foreach loop instead of the original loop.
try-with-resources.
nit: I think this could be a try-with-resources.
try-with-resources
In this case IMO we should use the isEmpty() check instead of size check.
In this case IMO we should use the isEmpty() check instead of size check. If there are more than one parent list, we should use it.
In this case IMO we should use the isEmpty() check instead of size checking.
Since we don't want to go through all this file, move the whole point of parsing the query string.
Since we don't want to go through all this file, move the whole point of parsing the query string. And then just get the first parameter from the loop on line 139.
where is this used?
Since you're using the same media directory name here, could you use something like mediaFileList instead?
Since you're using the same media directory name here, could you use something like mediaFileList?
Since you're using the same media directory as the name here, could you use something like mediaFileList?
it is safer to use VmDeviceType.DISK.name().equalsIgnoreCase(device.getType()) no risk for NPE.
it is safer to perform the comparison the other way: VmDeviceType.INTERFACE.name().equalsIgnoreCase(VmDeviceType.DISK.name())
it is safer to use VmDeviceType.DISK.name()
I'd add a function to AggregateFunctionImplementation that will map empty aggregations and bail out early if not. These rules get applied many times throughout the optimization process, so the behavior is much more obvious.
I'd add a specific method isOrderSensitive to Aggregate.
I'd add a function to AggregateFunctionImplementation that will map empty aggregations and bail out early if not. These rules get applied many times in the optimization process, so the no-op case should be be aggregations
Such case is not covered by tests.
Such instanceof check is not necessary, since the shutdown() method will already shutdown the connection.
Such instanceof check is not necessary. And needs to check for null,.
Instead of calling.get() multiple times, you could use the.get() to fetch the preference and then call.get() if it is not null.
Instead of calling.get() multiple times, you could use the TextUtils.isEmpty() function.
Instead of calling.get() multiple times, you could use the.get() to fetch the preference and then pass it to the.setWifiOnlySync().
use enum for the constant (algebric)
use enum for the strings.xml and is hardcoded.
use finals.
why aren't we handling this case?
still want to log the username to be sent?
still?
This does not look right. "_parallel" means that we're not using _parallel property by default. If the logic in the request is to start with "_parallel property", then we could simplify the code here.
This does not look right. "_parallel" means that we're not using the "_parallel" constant in the code.
This does not make sense to me. "_parallel" in the code base
same as other places, you can replace <LINK_0>
same as above
same as other places
check for null before accessingClass.
check for null or empty
Again, this should be a while loop
Can you change this to STRICT_MANAGED_TABLES.getHiveName() as a static method variable?
Can you change this to STRICT_MANAGED_TABLES.getHiveName()?
Can you change this to STRICT_MANAGED_TABLES.getHiveName() as it is used only for local replication?
Any reason to not use Collections.emptyMap()?
Any reason to not use new HashSet<>?
Any reason to not use the constructor with a setter?
The closePartition should be called in the constructor. And since the close() is abstract, it can be called multiple times.
The closePartition should be called in the constructor. And since the close() is abstract, it can be void.
The closePartition should be called in the constructor. And since the close() is abstract, it can be called directly within the PartitionProcessor. Instead, move it into the initialize method.
Useless extra line
This is wrong.
Use camelCase
Should be done in the init method.
shouldn't it be vdsProxy.close()?
shouldn't be done explicitly when vdsProxy is already initialized?
I think it is better to have a check on exception and throw as IllegalStateException.
I think it's better to have a check on exception and throw as IllegalStateException.
I think this line should throw an exception instead of returning false
Can be null?
Can be removed, don't need to be changed.
Can be removed, don't need to be changed
As mentioned above, use String.format() instead.
As mentioned above, return value is OK?
As mentioned above, use / instead of +.
It's not necessary to have the keyboard focus, just the text is changed. In the View.edit() we have a way to properly handle this, but in the model.getNetworkDao().getSelectedItemChangedEvent().addListener() I'm not sure why this was necessary.
It's not necessary to have the keyboard focus, just the text is changed. In the View.edit() we have a way to properly handle this, but in the model.getNetworkDao().getSelectedItemChangedEvent().addListener() I'm not sure what that would be.
It's not necessary to have the keyboard focus, just the text is changed. In the View.edit() we have a way to properly handle this, but in the model.getNetworkDao().getSelectedItemChangedEvent().addListener() I'm not sure why the text is.
I believe this needs to be tmp
I believe this will be sufficient.
I believe this needs to be tmp.
In allocator there is only a property, where this value is just added to the tag chunk?
In allocator there is only a property, where this value is just used as a tag.
In allocator there is only a property, where this value is just added to the tags map
should we also check the volume is also enabled in the manifest?
should we also check the volume is also set inside the activity?
should we also check the volume is enabled in the manifest?
Suggest checking if result.getResults().containsKey(criteria)
Suggesting this PR at the end, so that the method is clear.
Suggesting this PR at the end, so that the method is clear
Is this message correct?
Minor: remove this line
Minor: remove this timeout
Might be my math skills, but 5 + 20!= 35 ;-)
Might want to ask the above re: 5 seconds.
Might want to put the 5 seconds seconds before forcefully.
Optional: use parameterized log if possible
Optional: use parameterized log if possible.
LogEventSecureRequestType is a mandatory parameter, and can be used here.
I don't see the point of this test, it would be better to confirm that the project is actually accessible as a specific project, and not be a specific project
I don't see this test being used.
I don't see this test being tested.
This is PRE_DELETE event. Don't think it's necessary.
This is PRE_DELETE event.
This is PRE_DELETE event. Don't think we really want to.
Don't use Dtos.newDto()
Don't use Dtos.newDto
Use Dtos.newDto()
Not every id record has an email address.
Not every id record has an email address. The lookup should be done right after the email is saved.
Not every id record has an email address. The lookup should be done right after the database is completed.
Please remove the 'throws' here.
Why is this needed?
Please remove the 'throws'.
I think we should add a version that takes in a Vector and can be shortened as: java public Vector<T> drop(int n) { if (n <= 0) { return this; } else if (n < length()) { return length(); } return empty; }
I think we should add a version that takes in a Vector to remove the unnecessary size. Vector.size() could be cached on construction.
I think we should add a version that takes in a Vector to remove the unnecessary size. Vector.size() could be cached on methods.
suggestion throw new IllegalArgumentException("The input uri list is empty");
suggestion throw new IllegalStateException("The input uri list is empty");
Is there a reason to have this checked?
a typo? expeced -> not
a typo? expeced -> info
a typo? expeced -> not?
This object shouldn't be closed if there's an exception.
This object shouldn't be closed if there's an invalid state. That could be a different operation than what's specified on the fly though.
This object shouldn't be closed if there's an invalid state. That could be a different operation than what we expect.
this should probably be getStartTime() and not getEndTime()
this should probably be package protected
this should probably be getStartTime() and getEndTime()
I would remove this and keep the flow as it was before.
I would keep this and keep the flow as it was before.
I would remove this and keep the flow as it was before
nit: space after "Connection: keep-alive"
nit: space after "if"
nit: we could probably also assert the return value here
I wonder if we should keep the in memory of the interpreter and only the 'default' one. We have to be careful about this...
I wonder if we should keep it consistent with the 'next' part?
I wonder if we should keep the in memory of the interpreter and only the 'next' part. We have to avoid hard-coding the queryEnvironment.
rename to fileName, name, file to avoid confusion.
rename to fileName, config, dir, etc.
rename to fileName, name, file
unused
a null check
unused?
use java.util.Objects.equals
!= null
!=
Causes ctf tests to fail
Causes ctf tests from fail
Causes ctf test failures
This could be simplified to: java if (potentialNextSeqNb > childStart) { potentialNextSeqNb = children[i]; }
This could be simplified to: if (potentialNextSeqNb > childStart) { potentialNextSeqNb = children[i]; }
This could be simplified to: java if (potentialNextSeqNb > childStart){... }
this can be replaced with existingLoadBalancer = existingLoadBalancer.map(existingLoadBalancer -> existingLoadBalancer.get()).filter(lb -> lb.getScheme() == scheme).findFirst();
this can be replaced with existingLoadBalancer = existingLoadBalancer.map(existingLoadBalancer).filter(lb -> lb.getScheme() == scheme).findFirst();
this can be replaced with existingLoadBalancer = existingLoadBalancer.map(existingLoadBalancer -> existingLoadBalancer.get()).filter(lb -> lb.getScheme() == scheme).findFirst();
nitpick: I think we could even simplify by assignedValue.stream().filter(element -> element instanceof HasSymbol).forEach((HasSymbol) element).symbol(), ctx.addIssue(element, MESSAGE);
nitpick: I think we could even simplify by assignedValue.stream().filter(element -> element instanceof HasSymbol).forEach((HasSymbol) element).symbol());
nitpick: I think we could even simplify by assignedValue.stream().filter(element -> element instanceof HasSymbol).forEach((HasSymbol) element).symbol(), MESSAGE);
Should you use here getStoragePool().getId() also, the id remains the same between the 'old' DC and the 'new'
Should you use Version.greater(vm.getCustomCompatibilityVersion())?
Should you use "\n" here (and also at the error message before printing the entire string)?
This should be in a finally block to release resources. If there's an error, an exception will be thrown.
This should be in a try/finally block to release resources. If there's an exception for resourceBundle variable, then shouldn't be printUsageAndExit.
This should be in a try/finally block to release resources. If there's an exception for resourceBundle variable, than System.err will be to call into.
Use component instead of this. this in this context will refer to the WebViewClient object, not the Web component (which is what it needs to be).
use component instead of this. this in this context will refer to the WebViewClient object, not the Web component (which is what it needs to be).
Use component instead of this. this in this context will refer to WebViewClient object, not the Web component (which is what it needs to be).
Also, should we check if loadedMap is null here?
Also, should we check if loadedMap is empty?
I think we should do the same trick as for the other methods.
Are these local variables used at all? Looks like they can be avoided in more than one place.
Are these local variables needed? Looks like they can be avoided by getting them from a map.
Are these local variables used at all? Looks like they can be initialized as soon as they are constructed.
Maybe we should also throw ToolException here to clean up later.
Maybe we should also throw an ToolException here to let people know that the error occurred
Maybe we should also throw an ToolException here to let people know that the error happened
It would be better to put this in the finally block.
This injects the password in the constructor. That should be done in the finally block.
It would be better to move this code inside the if block.
Not sure if you could just set attribute to the value, though, it looks like a value is assigned even when it is set.
Not sure if you could just set attribute to the value, though it looks like a little bit too complex to be.
Not sure if you could just set attribute to the value, though, it looks like a value is assigned even when it is assigned.
A dedicated method to check this would be nicer.
A dedicated method to check this would be better.
A dedicated method to check this would be better: File currentResource = context.file(inputFile); if (fileKey!= null) { return new File(currentResource); }
This method's logic appears to be an exact copy of serialize(Page page) except for slice = Slices.copyOf(slice); line. Would it make sense to extract this logic into a helper method and make a copy logic conditional on slice.get() or have a boolean flag that tells whether the copy should occur or not?
This method's logic appears to be an exact copy of serialize(Page page) except for slice = Slices.copyOf(slice); line. Would it make sense to extract this logic into a helper method and make a copy logic conditional on slice.get(int) that returns the copy of serialize() or copy the private field?
This method's logic appears to be an exact copy of serializePage. Perhaps, extract it into a helper method and make a copy logic conditional on slice.isBuffer() or have a boolean flag that tells whether the copy should occur or not.
Maybe using the String webappPath = Optional.ofNullable(extensionPath).orElse(null);
Maybe using the String webappPath = Optional.ofNullable(extensionPath).orElse(null) instead of webappPath below?
Maybe returns reachable from the server?
I think this is spirit of the source of this code and the others should be private. I also know this is PR and I could be wrong.
I think this is spirit of the source of this code and the others should be private. I also know this is PR and I'm not sure that makes sense.
I think this is spirit of the source of this code and the others should be private. I also know.
This assignment and the one above is the same. Is it necessary to fix all the occurences?
This assignment and the one above is the same. Or this must be changed.
This assignment and the assignment on line 69 is incorrect. If the goal is to test for null, this must be the same.
I think this should be a break, no?
I think this should be a break, no need to check uid.
I think this should be a break, no need to check type and alias
You can use the absolute path here.
There is other test does not use the same path.
There is other test does not use the path to read the file.
"rebootAllowed" is already a constant so we don't have to worry about it here.
"reboot_virtual_machine" is now a VM so we don't have to use the VM as a parameter.
"reboot_virtual_machine" is now a VM so we don't have to use the VM object. This is an inner class.
add fBot.waitUntil(ConditionHelpers.xyViewerIsReadyCondition(chartViewer)); here too
probably don't need this if setPoint do not change the fBot.waitUntil(ConditionHelpers.xyViewerIsReadyCondition(chartViewer)); here too
probably don't need this if setPoint do not change the fBot.waitUntil (ConditionHelpers.xyViewerIsReadyCondition(chartViewer)); here too
Please add @Nullable to the child.
You want to consider using lambda syntax here, not sure why the _else_ is necessary.
You want to consider using lambda syntax here.
Instead of calling deleteServer method, I would use that method.
Instead of calling deleteServer method, I would use that method in the test
Instead of calling deleteServer and then deleting the client, I would use that method.
review if you're going to use a hamcrest matcher, but you're not sure it's a good idea to set it. This line of code should look like: @Override public void void saveAbout(@Nullable List<INetwork> networks) throws QuadrigaStorageException {
review if you're going to use a hamcrest matcher, but you're not sure it's a good idea to set it. This line of code should look like: @Override public boolean hasTextBean() { return hasTextBean(); }
review if you're going to use a hamcrest matcher, but you're not sure it's a good idea to set it. This line of code should look like: @Override public boolean hasTextBean() { return hasTextBean(); } and the same for the other methods.
Should we just return true if it's not null?
Should we just return true if it's not a non-null?
Should we just return true if it's not a member of this class?
In general, if you put setter/getters to static variable, it should be done in the model, not here it should be done in the getter.
In general, if you put setter/getters to static variable, it should be done in the model, not here it should be done in the backend
In general, if you put setter/getters to static variable, it should be done in the model, not here it should be done in the model.
this should rather be SUPPORTED_PARAM_ANNOTATIONS.size() == 1
this should at least be SUPPORTED_PARAM_ANNOTATIONS.size() == 1
this should at least be SUPPORTED_PARAM_ANNOTATIONS.length == 1
I assume you can keep the code as concise as possible in the loop. The only thing that comes from a single thread is that the value is already in the array.
I see all the places where you have done this, but why not just go with the number of handlers and add it instead?
I assume you missed the value124
why not just throw exception, since the exception is not thrown, I thought that TestHelper.fail() method will go after the exception, but forgot to remove the exception one :)
why not just throw exception, since the exception is not thrown
why not just throw exception, but junit report? Given the priority of 1, I thought that TestHelper.fail() method will go after the exception, I thought that TestHelper.fail() method will go here.
I think there's no need to copy the elements of the array in order to compare it with DOT_GIT_ATTRIBUTES
I think there's no need to copy the elements in order to compare it with DOT_GIT_ATTRIBUTES
I think there's no need to copy the elements in order to compare them with DOT_GIT_ATTRIBUTES
Please use StringUtils.isEmpty(id)
Please use StringUtils.isEmpty(id) instead of trim()
Please use StringUtils.isBlank(id) instead of trim()
@rishabh-997 Place the instanceof check here and call getKeyGenSpecBuilder(service) in the try
@rishabh-997 place the instanceof check since it can be null.
@rishabh-997 Place the instanceof check before the instanceof.
Dof isAccess = dooneIds.contains(zone.getId());
Dof!= null check is needed here
Dof==null means dooneId.getId() is the default.
Is it possible to implement such decision to be not copied directly from container?
Is it possible to implement such decision to be not copied from container?
Looks like we need to set workspace prefix here
i don't know if we want to cycle through the iterator. What do people think?
i don't know anything about this scope, but i would prefer solution to hard-code it like this: try (final ResultSet rs = stmt.getGeneratedKeys()) {... }
i don't know anything about this scope, but i would prefer to clean the iterator once it is used, instead of multiple try..
Please implement toString() to provide debugging state information for debugging purposes.
Please implement equals() to provide debugging state information for debugging purposes.
Please implement equals() to provide debugging state information for backwards compatibility.
I tend to go with the other cleanup in this method... it's completely unfriendly.
I tend to go with the other cleanup in this method. It doesn't really matter which behavior.
I tend to go with the other cleanup in this method. It doesn't really save much typing any behavior.
What happens if there is no previous value?
What happens if we don't have a system property?
What happens if there is a previous value?
Why protected? What's the same thing?
Why protected? What's the same package?
Should only be removed if the record is already removed.
Remove Coinmarketcap ratesource.
Avoid calling Coinmarketcap ratesource.
Avoid calling Coinmarketcap ratesource twice.
I would modify this message to be is defined multiple times
I would modify this message to contain multiple times
multiple times
Is there a reason why this hardcoded string is a static field instead of a class member?
Is there a reason why this hardcoded string is a static field instead of a magic number?
Is there a reason why this hardcoded string is a static variable?
Not sure we should use R.layout.bookmarks_widget?
Not sure we should use R.layout.bookmarks_widget here?
Not sure we should use different parameters here. If the URL parameter is "org.apache.dubbo.common.ui" instead we could have a method for this.
consider to consolidate into a single if block as both do the same, unless there is a particular reason.
consider to consolidate to a single if block as both do the same, unless there is a particular reason.
consider to consolidate into a single if block as both do the same.
You should be able to remove this class and make the mocks private. That will allow us to add more methods to the Entity interfaces that are supposed to be mocked.
You should be able to remove this class and make the mocks private. That will allow you to remove the implementation of the createMockUserSession.
You should be able to remove this class and make the mocks private. That will allow us to add more methods to the Entity interfaces that are supposed to be a MockUserSession.
This can throw if there are no principals. It should probably have an explicit check to throw a proper error message
This can throw if there are no principals. It should probably have an explicit check to throw a proper exception
This can throw if there is no servicePrincipal
Could you verify that the folder doesn't exist?
Could you add a listener on FileNavigationState to save having a more precise listener?
Could you add a listener on FileNavigationState to save having a more important code?
If the ID is not set, shouldn't we check it?
If the ID is not set, shouldn't we assert on it?
If the ID is not set, shouldn't we assert on the ID?
I guess VOOBSERVER role should be allowed too. Otherwise you're not able to get VO from the REST.
I guess VOOBSERVER role should be allowed too. Otherwise you're not able to get VO from any given VO.
I guess VOOBSERVER role should be allowed too. Otherwise you're not able to get VO from the *Service that's not allowed by VO.
Missing braces.
Missing braces
Don't you want to also add bumping to the delegate of the functions?
If this is called before setupToC, then it's better to use the constructor of ToCInteractionFunnel.
If this is called before setupToC, then it's called twice.
If this is called before setupToC, then it's re-useful.
Can you change this to assertBuildSummary(view.getBuildsSummary(), false, false, true);?
Can you change this to assertBuildSummary(view.getBuildsSummary(), false, false, true);?
Can you change this to assertBuildSummary(view.getBuildsSummary(), is(empty())));
Optional.ofNullable should be used instead
Optional.ofNullable should be used instead of a local variable.
Optional.ofNullable should be used instead.
I think we don't need to check for the emptyness of the constructor as we expect it to contain localhost.
I think we don't need to check for the emptyness of the constructor as we expect it to be null.
I would also check for the GPUInfo.
set the supplier to new AtomicLong(123)::getAndIncrement
setT1 as the default?
setT1 as the second parameter?
I think this would be better moved to the beginning of this method.
I think this would be better moved to the Status object

This might be clearer if it was extracted to a method with descriptive names. java public static Cipher getCipher(String cipherSuite, String securityProvider) { Cipher cipher = null; if (cipherSuite.equals("NullCipher")) { cipher = new NullCipher(); } else { cipher = new NullCipher(); } }
This might be clearer if it was extracted to a method with descriptive names. java public static Cipher getCipher(String cipherSuite, String securityProvider) { Cipher cipher = null; if (cipherSuite.equals("NullCipher")) { cipher = new NullCipher(); } } return cipher; }
This might be clearer if it was extracted to a method with descriptive names.
In order to be consistent, you should convert this to an enum: java public static final int USE_STATS_FOR_PARALLELIATION = Boolean.TRUE.toString();
In order to be consistent, you should convert this to an enum: java public static void setUpTestDriver(final ReadOnlyProps clientProps) { this.clientProps.put(QueryServices.MAX_HASH_FOR_PARALLELIATION, Boolean.TRUE.toString()); }
In order to be consistent, you should update the test to use an accessor.
If we're on it's own line, we should return an Optional
If we're on it's own line, we should return an Optional not null
If we're on it's own line, we should return an Optional not null.
fValueTimestamp is derived from fValueTimestamp, should it be considered for hashCode() and equals()?
fValueTimestamp is derived from fValueTimestamp, but it is also considered for hashCode() and equals().
fValueTimestamp can be null
This can use the parser to generate the floor for the user, otherwise it's going to be useless.
This can use the parser to generate the floor for the user, otherwise it's already generating the floor.
This can use the parser to generate the floor for the user, otherwise it's already generating it.
Is this the right error message for the user? This should be: "Cannot add member: " + a.getFullName()
Is this the right error message for the user? This should be: "Cannot add member 'xxx' to group 'xxx'.
Is this the right error message for the user? This should be: "Cannot add member 'xxx' to 'foo'.
what if currentUser!= null &&!currentUser.getObjectId().equals( userId )
what if currentUser is null?
need to change the alias of userStatus as well
It is really nullable, this should return an empty list.
It is really nullable, here you should use isNull()
Probably should return here
Any reason why we need to swap strings?
What makes sense to me?
What makes sense to me? Should we handle URLFileName too?
So you are setting this if you have an issue in the future? Two options here are: 1. Create a rule with the given name and use it here instead of the constant 2. Let's discuss tomorrow in person.
Did you miss to change this?
So you are changing this if-statement to apply? Are you simplification?
nit: Make this method private?
nit: Make this method private
nit: Make this a constant because it is used multiple times
can be replaced with return fromTarget.getInterval().getStart() - fromInterval.getEnd() - 1;
can be replaced with return fromTarget.getInterval() > fromInterval.getStart() - fromInterval.getEnd()
can be better as motivated
We could just call toInstant().atOffset(oneOffset.UTC) instead of atOffset(oneOffset.UTC)
We can just call toInstant().atOffset(oneOffset.UTC) instead of atOffset(oneOffset.UTC)
We could just call toInstant().atOffset(oneOffset.UTC) instead of atOffset(oneOffset.UTC).
Add newline before return.
Add newline after return.
Add newline before return
out of curiosity, is this case sensitive?
out of curiosity, is this an error condition or should this be handled by the exception?
throw an IllegalArgumentException instead?
This won't work if it's an exception. At least this is a warning.
This won't work if it's an exception. At least this is an indication of a bug.
This won't work if it's an exception. At least this is an indication of a bug in the user's connection.
Another question. If we have an ReplicationStatus here, do we need to be able to handle the case where this method is called?
Another question. If we have an ReplicationStatus here, do we need to be able to handle the case where an exception is thrown?
Another question. If we have an ReplicationStatus here, do we need to be able to call this?
This logic doesn't seem very correct. I would say that we would have to use for the binding for the let's not have to use this bean's ;) With the current implementation, we could end up with a bean where the logging were just used for logging.
This logic doesn't seem very correct. I would say that we would have to use for the binding for the let's not have to use this bean's ;)
This logic doesn't seem very correct. I would say that we would have to use for the binding for the let's not have to use this bean's ;) With the current implementation, we could end up with some issue, but I guess it will be very hard to debug?
how come we don't need this check?
how come we don't use the return value?
how come we don't use the returned value?
let's use logger instead of string concat
let's put this in log.info
fix logger
newExternalViewMap is really necessary here
newExternalViewMap is really a critical data structure. It would make sense to have a helper method somewhere.
newExternalViewMap is really necessary here.
is this anonymous class necessary/intentional?
is this anonymous class necessary/intentionally?
is this anonymous class needed/intentional?
else is unnecessary here, since when previous 'if' is true, we jump out of the method. extract vmNames.size() and removedNetworks.size() to variable so it's not calculated multiple times.
else is unnecessary here, since when previous 'if' is true, we jump out of the method. extract vmNames.size() and removedNetworks.size() to variable so its clear what is not that important.
else is unnecessary here, since when previous 'if' is false, we jump out of the method. extract vmNames.size() and removedNetworks.size() to variable so it's not calculated multiple times.
double check that no group has been created
again double check that no group has been created
double check that no group hasn't been created
What do you think about using assertEquals(result.size(), result.size()) to make sure the list isn't empty?
What is the point of this test?
@nielsbasjes26 Can you point me why are you using assertEquals(Object actual, Object expected)?
This variable seems not being used
This should be in the pull method.
This variable seems not being used.
make sure that okbuckState and literal values are not treated as immutable.
make sure you add the empty line below. Also, okbuckState.toString()!= null is not necessary.
make sure you add the empty line below. Also, okbuckState.toString()
For sake of consistency I'd suggest using CodePointIterator.ofString(...) instead of using CodePointIterator.ofString(...).
We can use CodePointIterator here as well.
For sake of consistency I'd suggest using CodePointIterator.ofString(...) for consistency.
How about adding a function for filtering based on the index?
How about adding a space before the ==?
Can you refactor this logic to use the same logic for multiple subs?
This is no longer true; the index is always non-null.
This is always true. Why not just skip the whole line?
This is no longer true; the index is always non-recursive.
this seems like an unnecessary step - let the factory do it?
this seems like a simple merge
this seems like a simple merge to one line.
Code style: please use brackets
Code style: rename -> layer
add break statement
The 'else' part could be moved out of the loop.
The 'else' part should be moved out of the loop.
The 'else' part could be moved out of the for loop.
please remove this line and change to: Observation.setNumberOfObservations("0")
please remove this lines
please remove this line and change proper formatting
I think it would be nicer to return an empty list instead of throwing an exception. You can add the metadata in the try block.
I think it would be nicer to return an empty list instead of throwing an exception. You can add the metadata in the finally block.
I think it would be cleaner to return an empty list instead of throwing an exception. You can add the metadata in the try block.
I'm not sure how this would work: Do we should not show the button in the UI only if there are outputs? I'm very uncomfortable with this solution.
As discussed this should be a different method in the workbench page.
As discussed this should be a different method in the workbench page. I'm not sure the dialog should be revertable
Why do you need to use runLater?
This need to be set in the constructor. The way the default constructor is the same as this.
This need to be set in the constructor.
In general with these kinds of callback-centric workflows it's pretty dangerous for the way that the callback to be completed to rely on the callback being handled in this kind of manner. (sorry, clicked enter too soon, elaborating)
In general with these kinds of callback-centric workflows it's pretty dangerous for the way that the callback to be completed to rely on the listener being handled in this kind of manner. (sorry, clicked enter too soon, elaborating)
use Butterknife an injectable function.
> /var/tmp
'static' is a pile of utility methods.
'static' is a pile of methods.
We should probably add the PassivationCapable check, and just call it validateBeanAttributes(). And TBH I like the current code even if we moved the lambda-related code to a separate class. It's kind of a nice idea to do it, but maybe it's not ideal.
We should probably add the PassivationCapable check, and just call it validateBeanAttributes(). And TBH I like the current code even if we moved the lambda-related stuff to a separate class. It's not clear how the Passivation existed, but maybe it does not require an PassivationEnabled check.
We should probably add the PassivationCapable check, and just call it validateBeanAttributes(). And TBH I like the current code even if we moved the lambda-related stuff to a separate class. It's not clear how the Passivation existed, but maybe it does not require an PassivationCapable.
Please use if (boolean.TRUE.equals(getBooleanProperty(Message.HDR_LARGE_COMPRESSED)) {... }
Please use if (boolean.TRUE.equals(getBooleanProperty(Message.HDR_LARGE_COMPRESSED)) { here.
Please use dubbo Constants.java.api.util.Boolean instead of String.
Did you check here what happens if you don't pass ldapServers parameter to cmd line? Do you get an empty string, or null?
Did you check here what happens when you don't pass ldapServers parameter to cmd line? Do you get an empty string, or null?
Did you check here what happens if you don't pass ldapServers parameter to cmd line? Do you get an exception that causes an NPE?
Can this be moved to a logger?
Can this be moved to a logger? Or will it be used anywhere? I don't think we should be throwing an exception.
Can this be moved to a logger? Or will it have a lot of println?
Same here, you need to do Arrays.asList(orderSetMember).
Same here, you need to do Arrays.asList().
Same here, you need to remove private methods
Good cleanup!
no need to cleanup
no need to change this
"cannot" is a slightly better error. It is not a very critical error, but rather confusing.
"cannot" is a slightly better error. It is not a very helpful from other parts of the code. I would suggest something like "cannot create a thing with a primary key" or "cannot be configured correctly"
"cannot" is a slightly better error. It is not a very helpful from other parts of the code. The toString is automatically very useful (non-editable)
should update currentEvent in the loop?
should update currentLocation here as well
should update currentLocation here too
Shouldn't we avoid the asset keyword? Are we sure that Eclipse is started with the -ea switch?
Shouldn't we avoid the asset keyword? Are you sure that Eclipse is started with the -ea switch?
Shouldn't we avoid the asset keyword? Are we sure that Eclipse is started with the -ea switch? This would avoid the asset keyword?
suggestion EmbeddedServers.create(task, port, sslStores, maxThreads, threadIdleTimeoutMillis);
suggestion EmbeddedServers.create(new Thread(() -> {
It is always safer to use the SingleThreadExecutor rather than the executor service.
can't you use constants.empty() here as well?
can't you add constants.empty() here as well?
can't you use constants.empty() here as well? to avoid possible NPEs
Hi. @sbespalov, please use proper logging.
Hi. @sbespalov, please use proper logger.
Hi. @sbespalov : What is wrong with this change?
We should probably check the error message as well
We should probably check the size of the project rather than just the line number in the test below
We should probably check the size of the project rather than just the line number to avoid issues.
I would replace this if-else with ternary statements to make it shorter. but that's a matter of style - so just consider it
I would replace this if-then with ternary statements to make it shorter. but that's a matter of style - so just consider it
I would change this to null if the selectedTimeones is null
Not sure why we need it here.
Not sure why we need it here, since we have it in a couple places.
Not sure why we need it here, since we have it for the 'java.io.file'?
It seems to me that it would be better to throw an exception if you do not match the logic here, or just return the value of the method.
It seems to me that it would be better to throw an exception if you do not match the logic here, or just return the value
It seems to me that it would be better to throw an exception if we do not match the logic here, or just return the value directly.
You can remove the else block and simply do: if (blobProvider.performsAccessControl(blobInfo)) { throw new NuxeoException("blob provider " + providerId + " does not perform access control", e); }
You can do without else after this.
You can remove the else after return.
This seems to be unrelated to the PR
This seems to be unrelated to this PR
This seems to be unrelated to this PR.
Should this be a debug level?
this seems like a debug statement in the main code path
this seems like a debug statement in the main code.
an Style-nit: I'd prefer having the '{' at the end of the closing brace on the same line.
an Style-nit: I'd prefer having the identical code in one line.
an Style-nit: I'd prefer having the '{' at the end of the closing brace on its own line.
Can return directly.
Is there a benefit of using StringUtils from commons-lang?
Is this still needed?
Prefer a StringBuilder here: StringBuilder rawNonceBuilder = new StringBuilder();
Prefer a StringBuilder here: StringBuilder output = new StringBuilder(format("-", new Long(timestamp));
Optional: use a StringBuilder here
I don't think this is correct. If cache == null it will return false. I think it should be like this: java if (compatibility && indexing) { cache = cache.getAdvancedCache().withEncoder(cacheManager); }
I don't think this is correct. If cache == null it will return false. I think it returns the cached instance.
I don't think this is correct. If cache == null it will return false. I think it should be like this: java if (compatibility && indexing) { cache =... }
Unused constant.
Unused.
Unused
Can be changed to: if (PROXY_USERS == null) { return; }
This could be made into a method, as it's only used once.
This could be made into a synchronized block, as it breaks the loop and always called if it gets called.
so, the code is easier to read, how about to wrap the whole thing inside the if statement and put the line number inside that method?
can this be made final?
so, the code is easier to read, how about to wrap the whole thing inside the if statement and just call the method with the response.
Could we keep this on one line?
Could you add some message to the exception message here? e.g. "In bundle group org.nuxeo.apidoc.core"
Could you add some message to the exception message here? e.g. "Not true for field '" + name + "'");
Hey @cranville : Could you try to use /lock for this resource location instead?
Less error prone to break.
/lock/like lock.
Instead of adding size to array, and then adding after the for loop, you could do something like: for(Object o : connection.getRemotingService().getConnections()) {... }
Instead of adding size to array, and then adding after the for loop, you could do something like: for (Object connection : connection.getRemotingService().getConnections()) {... }
Instead of adding size to array, and then adding after the for loop, you could do something like: for (Object o : connection.getRemotingService().getConnections()) {... }
Does it really need to be in a separate thread? If it has error, it should be its own exception.
Does it need to be in a separate commit?
Does it really need to be public?
there is a function in DiskReformatter that you can move here maybe. /** * Deletes {@code location} * @param location the location to delete * @throws IOException if there are any problems deleting {@code location}. */ private void safeDelete(Path path) throws IOException { if ( Files.notExists( path ) ) { throw new IllegalArgumentException(); } } Would this implementation do the same thing?
there is a function in DiskReformatter that you can move here maybe. /** * Deletes {@code location} * @param location the location to delete * @throws IOException if there are any problems deleting {@code location}. */ private void safeDelete(Path path) throws IOException { if ( Files.notExists( path ) ) { throw new IllegalArgumentException( "Could not delete " + path ); } } Would this implementation do the same thing?
there is an exclamation marks
@tmjee It's better to create all instances ant then reuse them
@tmjee It's better to create all instances ant then reuse that complexTypes
@tmjee It's better to create all instances ant then reuse that complexTypes object
For a field, please use CollectionUtils.isEmpty()
For a list, please use CollectionUtils.isEmpty()
For a field, please use CollectionUtils.isEmpty()#size.
This will call getLocalEndpoint() every time, even if it's not available, right?
This will call getLocalEndpoint() every time, even if it's not available, right? Can it be hard to check?
This will call getLocalEndpoint() every time, no need to check it. It is called twice.
looks like this change is not related to the fix?
looks like this change is not related to the change?
looks like this change is not necessary, it can just be removed.
Shouldnt we return 'asyncTask' here? If some task, succedded flag is set to null
Shouldnt we return 'asyncTask' here? If some task, succedded flag is set to null.
possible NPE
Should we use something like EXTENSION or EXT instead of SER?
Should we use something else here instead of SER?
Should we use something like EXTENSION or EXT instead of SER?
suggestion assertThat("json_content.text:tweet")
suggestion assertThat("json_content.text:tweet");
why do you want to pass the results?
In this case, the render() method is named "createRenderingStage()". It seems to me that this method is meant to be used in both places.
In this case, the render() method is named "createRenderingStage()". It seems to me that this method is meant to be used in both places. Can you move it to a method named "createRenderingStage()"
In this case, the render() method is named "createRenderingStage()". It seems to me that this method is meant to be used in both places. Can you move it to a method in the render() method?
Can we use constant as well?
Can we use AssertJ here?
Can we use this instead?
add the string to finally? Otherwise IP stream may be corrupted if cf.deleteOnExit.
add the check to finally? Otherwise IP stream may be corrupted if cf.deleteOnExit.
add the check for null?
Won't this create a problem when two threads call execute on the same thread?
Won't this create a problem when runQueries() is called multiple times?
Won't this create a problem when two threads call execute on a same thread?
without **a** 'MessageHandler'.
without **MessageHandler** we are not a general term, because even if the value is not a Map, why not just use Map?
without 'MessageHandler'.
Why is this change necessary?
There's a utility method for this purpose in the fragment. Please try to avoid cluttering the source code.
There's a utility method for this purpose in the fragment. Please try to avoid cluttering the copied code.
Iterables.filter(fEntries, CounterTreeViewerEntry.class)
Iterables.filter(fEntries, CounterTreeViewerEntry.class))?
Maybe add a syncExec() method in the name?
You added a parameter but this command is also used from other places, so this check can be removed.
You added a parameter but this command is also used from other places, so this check is redundant.
You added a parameter but this command is also used from other places, so why not to use it?
Shouldn't use t=0. Anyways, I believe all new attributes are already initialized to null.
Shouldn't use t=0. Anyways, I believe all new attributes are already initialized to null. Why do you need to change the state system?
Shouldn't use t=0. Anyways, I believe all new attributes are already initialized to null. Why do you need to catch the exceptions here?
This method is only called if the user is removed.
Looks like this isn't thread safe. The semantics of this method should be synchronized.
Looks like this isn't thread safe.
This variable is not used.
This variable can be written more simply using a local variable.
This variable can be removed.
I'd rather have this method only for 'isImageOperation.Moving' and'move' if we aren't going to use it anyway.
I'd rather have this method only for 'isImageOperation.Moving' and'move' if we aren't going to move the job properties
I'd rather use StringUtils.isEmpty()
I don't understand why you are calling Optional.get() twice instead of using.findFirst()?
I don't understand why you are calling Optional.get() twice instead of calling it twice.
I don't understand why you are calling Optional.get without checking the null case.
May be we can rename DvNonEmployeeTravel().getDvNonEmployeeTravel().getDvNonEmployeeTravel().getDvNonEmployeeTravel().getDvPerdiemStartDttmStamp() and use it for all if statements.
May be we can rename DvNonEmployeeTravel to DvNonEmployeeTravel().
May be we can rename DvNonEmployeeTravel() to DvNonEmployeeTravel().
Let's wrap the whole method with RangedClientPartition(boolean refresh) so that we don't have to do this.
Let's wrap the whole method with RangedClientPartition(boolean refresh)
Let's wrap the whole function in try/catch, so we don't do this.
I think you try to reinvent here executeWithRetry which we use in other places.
I was thinking if is there any chance of an error causing this property to remain available, I think we should wrap this statement in a TopicCreationException and get its value. Do you think we should wrap this statement in a finally clause?
I was thinking if is there any chance of an error causing this property to remain available, I think we should wrap this statement in a TopicCreationException and then wrap it in a TopicCreationException. I'd suggest we wrap this exception in a TopicCreationException and then wrap it in a TopicCreationException.
do we need one System.out.println?
do we need one System.out.println?
do we need one System.out.println on console?
Might want to call it validateAttributeSerializable
Rename to validateAttributeSerializable
Might want to use serializables.transform here
This method should be private.
This is better as: if (stripe.size() >= MAX_SIE) return false; else return false;
This is better as: int MAX_SIE = (int) pageId & STRIPES_COUNT; return Math.min(MAX_SIE / STRIPES_COUNT, 0;
How about something like CharArrayUtils.fromString(fValue)?
How about something like CharArrayUtils.fromValue(fValue)?
Catchs for much more errors, maybe something like CharArrayUtils.valueOf(fValue)?
Only return true
continue
Only return true.
I think it would be better to do something like this instead:.withConnectionPoolConfiguration(new IndexProperty(0, Integer.MAX_VALUE))
I think it would be better to do something like this instead:.withConnectionPoolConfiguration(new IndexProperty(0, 1, Integer.MAX_VALUE))
I think it would be better to do something like this to keep the existing code in place.
why is it called HelixAdmin#getInstancesInCluster?
why is it called HelixAdmin#getInstancesInCluster? I think you can try to initialize the cluster on the node.
why is it called this once?
extract method
extract this out into a dedicated function
extract this into a dedicated function
note, IgniteDistributions#project already does this.
note, IgniteDistributions#project already does this for you: <LINK_0>
rename to constraint
Strangely enough, this method returns null and throws an exception if the experiment is non-empty.
Strangely enough, this method returns null and throws an exception, returning null is not useful. We should probably throw an exception or?
Strangely enough, this method returns null and throws an exception if the experiment is non-empty. We should probably throw an exception here
What about this instead? <LINK_0>
What about this instead? <LINK_1>
Is this really what you are trying to do?
use explicit Locale.ROOT instead?
should this test as atomic? The advantage of explicit time results is that the test is run only once.
use explicit Locale.ROOT to make it consistent
We have VersionInfo.VersionKeys.MINOR to be a constant in VersionInfo class.
We have VersionInfo.VersionKeys.MINOR to be a constant in VersionInfo.
We have VersionInfo.VersionKeys.MINOR in 2.6.x
Can you add check for null here?
Please add check for null here.
Can you add check for null here?
Even this is not necessary. This is not really hiding anything.
Even this is not necessary. This is done in the [Java Code style](<LINK_0>
Even this is not necessary. This is done in the [Logic](<LINK_0> page.
FileNotFoundException is a subclass of Exception
I think we should not throw the exceptions at all and let the caller handle the exception. We should then traceTypes.get(0) instead of just the first one.
I think we should not throw the exceptions at all and let the caller handle the exception. We should then traceTypes.get(0)
I think this is a good idea, but can you move it to the caller?
I think this is a good idea, but can you move it to the @Before method?
I think this is a good idea, but can you add a log about what's missing?
pull.repo().coordinates().repo() is the same as pull.number("/pulls")
pull.repo().coordinates().repo() is the same as pull.tag().uri()
@CarlosGines Let's extract these as variables to the pull object.
Use TaskType.STANDBY.
Standby task should never be in REST -- how..?
Standby task should never be in REST -- how..
Can you put the mappers in the get( "/forms/result") before the get( "/forms/sharing", (req, res) -> util.getMetacardsByFilter(QUERY_TEMPLATE_TAG)
Can you put the mappers in the getEmailAddress() method?
Can you put the mappers/modification code in the get method?
Shouldn't this be if (model.getSubTypes()!= null &&!model.getSubTypes().isEmpty()) {?
Shouldn't this be: if (model.getSubTypes()!= null &&!model.getSubTypes().isEmpty()) { return; }
Shouldn't this be: if (model.getSubTypes()!= null &&!model.getSubTypes().isEmpty()) { return; } to avoid creating a new array in the first place.
Why not rename to 'this.'?
Why not rename to 'this.'?
Why not rename the variable? This is not actually used anywhere else.
Move the throws up to the first line of the method.
Move the throws up to the first line.
move the throws up to the first catch
A lot more vals please
A bunch more vals please
A bit more vals please
Nit: whitelisted is not actually a failure, it could be a failure, right? The failure would be handled by the server.
Nit: whitelisted is set, then it is set. (The list is parsed at the end)
Nit: whitelisted is not actually a failure, it could be a failure, including the stack trace.
this will remain the same?
this will remain the same
Why this change?
@tsurdilo You can use here rather assertNull(processInstance).getProcessInstance(CONTAINER_ALIAS, differentReleaseId101)
@tsurdilo You can use here rather assertNull(processInstance).getProcessInstance(CONTAINER_ALIAS, differentReleaseId101); Using the same value would be better.
@tsurdilo You can use here rather assertNull(processInstance).getProcessInstance(CONTAINER_ALIAS, differentReleaseId101) - the second need to be removed.
There is no need to prefix + "azkaban.flow.projectlasychanged by"
There is no need to prefix + here as the string is not required.
Please use Strings.
style nit: we don't use curly braces around single line blocks
style nit: we don't use braces around single line blocks
" -c".equals(current) is stil use.equals()
This is impossible, blockLength is an int.
You don't know that the next packet is an blockLength, but blockLength is an int.
You don't know that the next packet is a blockLength, but blockLength is an int.
Why did you add this parameter? It always has the exact same value as the other. So maybe just drop it?
Why did you add this parameter? It always has the exact same value as the root beanMetaData, right? So maybe just drop it?
Why did you add this parameter? It always has the exact same value as the root. So maybe just drop it?
Suggest throw new SamzaException(String.format("Exception occurred when storing JobModel: %s.", jobModel, jobModelVersion), e);
Suggest to throw at most one exception.
Suggest to throw at most the exceptions.
it is better not to cast result to Collection... why not cast it?
it is better not to cast result to Collection... I prefer to use List<?>
it is better not to cast result to Collection...
Is this equivalent to org.apache.commons.lang3.Validate#isTrue?
Is this value still needed?
Is this value really needed?
Does this work? Aren't we still skipping the access token lookup even it's still valid?
Does this work? Aren't we still skipping the access token lookup even it returns null?
Does this work? Aren't we still skipping the access token lookup even it's still valid? What if I run the test in the next step?
suggestion mounted.setShotsLeft(0);
Small nitpick: extra space after }
Small nitpick: unnecessary space after }
There's no locking on this? Also, isn't this the functionality you wanted in the Facade layer?
There's no locking on this? Also, isn't it the functionality you wanted in the Facade layer?
There's no locking on this? Also, isn't it possible to just use event.getId() instead of this?
I'm starting to move this into Crashlytics if we do Crashlytics, to keep code consistent
I'm starting to move this into Crashlytics catch, to keep it consistent with our code style.
I'm starting to move this into Crashlytics if we do Crashlytics, to keep code clean
@vmaletta use Iterable instead of List
@Override is missing.
@Override is a missing line
At this point we don't log the exception each time it is called. It is better to log the exception inside the log.
At this point we don't log the exception each time it is called. It is better to log the stack trace each time a log message is triggered.
At this point we don't log the exception each time it is called. It is better to log the stack trace each time.
Formatting
Can you also remove the " +
Can you also remove the "\n"s?
Why calling a static method to create ConversationFragment and a static method? I much prefer readability.
Why calling a static method to create ConversationFragment and a static method?
Why calling a static method to create Conversation?
can we use logger.info("*** got {} ", event.getType(), event.getRunner().getClass().getName())
can we use logger.info("*** got {} ", event.getType(), event.getRunner().getClass().getName()) here?
can we change the logger name to debug?
Let's use System.currentTimeMillis() instead.
Let's use System.currentTimeMillis() instead. It's a bit tricky.
Let's use System.currentTimeMillis() instead. We really don't want to start a new instance every time.
Similarly here, we're still using the value and not the condition.
Similarly here, we're still using the value and ignore when we call getValue on it.
Similarly here, we're still using the value and ignore when we do warn.
The list may be bigger than the size of the list. Just Comparator.comparing(ProjectData::getName)
The list may be bigger than the size of the list. Just Comparator.comparing(ProjectData::getName).
The list may be bigger than the size of the list. Just Comparator.comparing().
Don't we need to make the DataFileWriter instance instance? In general, I'd suggest to use a static instance of the DataFileWriter instance.
Don't we need to make the DataFileWriter instance instance? In general, I'd suggest to use a factory method for creating the DataFileWriter instance.
Don't we need to make the DataFileWriter instance instance? In general, I'd suggest to use a factory method for creating the DataFileWriter as well.
make this final I think
make this final I suppose
make this final I guess
use!= null to pass null to the config constructor
use!= null to pass null to the config constructor in the constructor
use!= null
DoubleArray.ofUnsafe(strikes)
DoubleArray.ofUnsafe(strikes)?
A worth the use of the for each loop could be avoided by directly calling a get(int) method.
Should we just throw the exception?
Can you just call the expression expression?
I like the syntax better.
missing space after if
missing space after if.
missing space before if
You could use ThreadLocalRandom.current().nextInt(MAX_VALUE) here.
We don't need this to be public.
We don't need this to be a lambda, directly returning Future<World>
Subscribing to channel -> Subscribing
There is also a code duplication here. Shall we move that into the sendMessage?
There is also a code duplication here.
I think there is no reason to do it here. Just calling translationsMap.put below will make the code more readable.
I think there is no reason to do it here. Just calling translationsMap.put below will make the value more concise.
I think there is no reason to do it here. Just calling translationsMap.put below you are doing it.
Perhaps it would be better to add a checkType method for FieldPartitioners that you can consolidated this logic to one method in one place.
Perhaps it would be better to add a checkType method for FieldPartitioners that you can use to represent the type of partitioner in one place.
Perhaps it would be better to add a checkType method for FieldPartitioners that you can use to represent the partitioner in one place.
suggestion List<SnapshotInfo> infos = snapshotDao.listByVolumeId(volumeId);
suggestion List<SnapshotVO> infos = snapshotDao.listByVolumeId(volumeId);
This local variable is only used once. Please consider collapsing into lint 1122. Also, please add the type to the return statement as well.
Should be able to break this up with the null check
Should be a throw here.
Should be able to break this up with the null check.
Let's make sure the key for the Content-Type is implemented and you will have your new entry here instead of just the key.
Let's make sure the key for the Content-Type found for the response body you can use here instead of just the NetworkResponse.
Let's make sure the key for the Content-Type found for the response body you can use here instead of just the NetworkInfo.
I wonder if we should check that the payload is actually a byte array, otherwise we could write some kind of data by not having a ByteBuffer like the other parts.
I wonder if we should check that the payload is actually a byte array, otherwise we could write some kind of data by not having a ByteBuffer and having the original payload at the right time.
I wonder if we should check that the payload is actually a byte array, otherwise we could write some kind of data by not having a ByteBuffer and having the original payload at the right moment.
These strings can be extracted as constants.
These strings could be extracted as constants.
These strings can be constants.
This test case seems overcomplicated. Consider adding a new test case for it.
This seems like a mismatch, since you are not using the same key?
This test case seems overcomplicated. Consider adding a new test case for it?
Style-nit: Can be removed.
Style-nit: Space before (. In general what if you keep braces in our code style.
Style-nit: Space before (.
Consider including the password (and UUID) in the test so they would not be overridden
Consider including the password (and UUID) in the test?
Consider including the password (new String(String) inside the test method so they would not be overridden).
Same here, you could have inheritedRights = null and inheritedRights = getProjectStateFactory.create(p.getNameKey());
Same here, you could have a Project.Id key = null and you wouldn't need to force ProjectState here.
Same here, you could have a Project.Id key = null and then you could have getProjectId(key).
the key set will be modified in #get(), it is expected that we have to create a new bookies set from quarantinedBookies's key set
the key set will be modified in #get(), it is expected that we have to create a new bookies set from current quarantinedBookies's key set
the key set will be modified in #removeBookies, so you don't need to create a new map.
I'm wondering if any code be moved outside this try block to clarify what can throw an IOException and what can't.
I'm wondering if any code be moved outside this try block to clarify what it returns.
I'm wondering if any code be moved outside this try block to clarify what can throw an IOException and what can't. Because the upsert() doesn't throw an exception, and doesn't remove the data.
Shall we take the chance and move all these assertions to a setUp like in other classes (in other classes)?
Shall we take the chance and move all these statements to a setUp like in other classes (in other classes)?
Shall we take the chance and move all these assertions to a setUp like in other classes?
@hanm can you please invert this and remove this change? we've already breaking changes in master in master.
@hanm can you please invert this and remove this if statement?
@hanm can you please invert this and remove this change? we've already breaking this into master in master.
Please use a meaningful name for the value of autoDownload.
Please use a meaningful name for the action name.
Please use a meaningful name for the action value instead of a single name.
Is my understanding correct that the m_globals is not null when you are doing this?
Is my understanding correct that the m_globals is not null here?
Is my understanding correct that the m_globals is not being set to true?
use StringUtils.isNotEmpty
this method should be private
use Arrays.stream
Suggest you use ternary operator: if ((bucketName = amazonS3URI.getURI().getScheme()) == null) {
Suggest you wrap this block in a separate if.
Suggest you wrap this block in a separate method and check this once in the if block.
I think it's better to delegate to ByteArrayPool.get().
I think it's better to delegate to the method so that it does not return anything when data is OutputStream.
I think it's better to delegate to ByteArrayPool.get() to avoid the extra get()
Please create a new PR for this.
Please extract the filter into a seperate method.
Please extract the map to a ViewerFilter object.
Use LocalTime created in tests
Use LocalTime created in the constructor
Use new DateAdapter
Does this mean an empty string in the select query?
Does this mean an empty string in the select query? How do we handle such cases?
Does this mean an empty string in the select definition?
This condition should be read from the "if (selection.size() <= 0)" section. Even for the other case, this is not correct.
This condition should be read from the "if (selection.size() <= 0)" section.
This condition should be read from the model in the file, not the model.
no need to log at info level, I would return it as it's fine to make it safe (and a little brittle).
no need to log at info level, I would return it as it's fine to make it safe (and a bit brittle).
no need to log at info level, I would return it as it's fine to make it work.
Why is this synchronized? The idea behind it is to avoid a race condition, since it is a separate thread for all connections.
The idea behind this synchronized is that these methods should only be called at the end of the class. Couldn't we just get the LeastUsedCache directly?
Why is this synchronized? The idea behind it is to avoid a race condition, since it is a separate thread for every connection.
After trying it, we would prefer that the state color could be drawn with two lines. The reason is that when the'real' state interval extends beyond the window limits, a rectangle highlighting gives the false impression that the state starts and ends at the window edges. We tested this code which seems ok: gc.drawLine(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect
After trying it, we would prefer that the state color could be drawn with two lines. The reason is that when the'real' state interval extends beyond the window limits, a rectangle highlighting gives the false impression that the state starts and ends at the window edges. We tested this code which seems ok: gc.drawLine(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect
After trying it, we would prefer that the state color could be drawn with two lines. The reason is that when the'real' state interval extends beyond the window limits, a rectangle highlighting gives the false impression that the state starts and ends at the window edges. We tested this code which seems ok: gc.drawLine(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect.height, rect.x + rect.height, rect.x + rect.width, rect.y + rect
what is the reason for this change?
that's ok, but it looks like you can make a constant.
that's ok, but it looks like you can use schedule.getCronExpression()
To conform with our team standard, would you please prefix the variable with this.?
To conform with our team standard, would you please have a look at this class in the future?
To conform with our team standard, would you please have a space after if and before the &&?
Instead of defining this same block twice, do we already have the 'if' in the doExecute() above?
Instead of defining this same block twice, do the.trim() on opaqueUser above and reuse the block below.
Instead of defining this same block twice, do the.trim() on opaqueUser above and save the user principal (or null) in a variable.
can the name be more descriptive?
can the name be more generic?
can the name be more specific?
nit: move this to on line 57
nit: move this to just before the if statement.
nit: move this to just before the if statement
It's actually quite unlikely that Catalog will override the default behavior, but even if it's not used, it should be that the exception is thrown.
It's actually quite unlikely that Catalog will override the default behavior, but even if it's not used, it should be that default.
It's actually quite unlikely that Catalog will fail if it's null. The exception is that the default access to the queryableIndices class, which means that Catalog will fail if it is null.
Extract the building of the ResponseMessage to it' own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make it a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
![MAJOR](<LINK_0> 'Severity: MAJOR') Method has 7 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
looks like this is duplicated code
looks like this method could be called if you remove the service and registerBasePath method.
looks like this method could be called if you remove the service and replace service
Missing @Override
Missing!
Missing @Override?
This could be done simpler if you used logEntries(logEntry -> (OnlineLogRecord) logEntry)
This could be done simpler if you used logEntries(logEntry -> (OnlineLogRecord) logEntry).
This could be done shorter as a lambda.
Please use logger instead of println
Please catch RuntimeException instead of using println()
Please catch RuntimeException instead of using Throwable.
We cannot assume all fields. If you look at the original code, DSpaceObject is the thing being indexed. This is because Communities and Collections are *also* indexed in Discovery (so that you can search on their names/descriptions).
We cannot assume all fields. If you look at the original code, DSpaceObject is an instance of DSpaceObject. This is because Communities and Collections are *also* indexed in Discovery (so that you can search on their names/descriptions).
We cannot assume all fields, if pushCommit is true, we will get an empty list at this point.
I don't think this is necessary and the refactor should already be part of the try block block
I don't think this is necessary and if it is just for debugging purposes, it should also be logged at debug level
I don't think this is necessary and if it is just for debugging purposes, it should also be logged at debug level.
explain this
explain this catch block?
explain this PR
May be extract the NewDataSourceEvent constructor into a separate method to keep the code more readable?
May be extract the NewDataSourceEvent constructor into a separate method to keep the code more readable.
May be extract the NewDataSourceEvent constructor to a separate method and reuse it here, instead of having two places.
nit: this could be a bit clearer with : HttpSession session = request.getSession(false); if (!requestURI!= null) { if (!requestURI.contains("/t/") { //... } else if (session!= null) { request.getSession(false); } else { return domain; } }
nit: this could be a bit clearer with : HttpSession session = request.getSession(false); if (!requestURI!= null) { if (!requestURI.contains("/t/") { //... } else if (session!= null) {... } }
getTenantDomain
if(amount.toAmountString() + "/" + 'toAmountString()) {
if(amount.toAmountString() + "/" + 'toAmountString()) {}
maybe use String.format instead of +
I think you could return null if artifactPath is empty, and then you don't need to create a new ArtifactBuilder on it.
I think you could return null if artifactPath is empty, and then you don't need to create a new ArtifactBuilder on line 120.
I am not sure where this can return null, but you could just return null
This will need to be revisited to throw proper exceptions.
Change to DMLStatus.INVALID_OPERATION
Change to DML.
We should use a cache map here to avoid multiple threads calling it. It would also be a good idea to change the return value of this method and also check for the regex above.
We should use a constant for the regex here, or do we need all caps if we are using a lot of the code.
We should use a constant for the regex here, or do we need all caps if we use that pattern.
static import
nit: One param per line
nit: static import
use raf.readLong();
use a format here.
use a format
I believe using this method doesn't exist in your code, but typically you are not sure if there's an exception so do we want to create an ITs exception?
I believe using this method doesn't exist in your code, but typically you are not sure if there's an exception because this indicates a problem.
I believe using this method doesn't exist in your code, but typically you are not sure if there's an exception so do we want to create an I18n instance?
should this be extending an interface instead of a base class?
should this be extending an interface instead of a public class?
should this be extending InternalDAO?
This convert is unnecessary in this method. You could just call getClusterByServiceList()
This convert is unnecessary in this method. You could just call getClusterByServiceList(map)
This cast to ArrayList is redundant - you could be using generics on the left side
You need to use server.getPermanents().contains("Sliver") to check that the element is not contained in the list.
You need to use server.getPermanents().contains("Sliver") to check that the element is not contained in the game, so the iteration below will never be executed
You need to use server.getPermanents().contains("Sliver") to check that the element is not contained in the game.getBattlefield().
Why not use Preconditions.checkNotNull?
Why is this declared as private? It seems like there are some types of methods in the Phoenix implementation.
What is the most specific error message? Would it be more informative for this message?
I don't think you need the line break here.
I don't think you need to have the test data.feedbackQuestions.for that there is a param.
I don't think this line is necessary.
If this throws an exception, it should be added to the log.
If this throws an exception, it should be added to the log statement.
If this is only for debug, it should be error.
Minor: maybe extract "5000" to a constant
Minor: why 2?
Unused
when we set the calculator to the GoalDownload object, we don't need to have it again. Just define a static factory method that creates the calculator to the constructor.
when we set the calculator to the GoalDownload object, we don't need to have it again. Just define a static final instance of the calculator to the constructor.
when we set the calculator to the GoalDownload object, we don't need to have it again. Just define a static final instance of calculator to the calculator.
It is already public. Did you intend to use assert here?
It is already public. Did you intend to remove these names?
It is already public. Did you intend to use assert statements?
If you want to clear this list, please pass it to eclipse.
If you want to clear this list, please pass it to @Before rather than a setter.
If you want to clear this list, please pass it to @Before rather than a set to it.
The above change is not needed.
The above code (here and elsewhere) could be extracted to a method with descriptive name.
The above code (here and elsewhere) could be extracted to a method with descriptive names.
I think.reset() returns a value in the range [0, 1), so you'd want to check <LINK_0> instead.
I think.reset() returns a value in the range [0, 1), so you'd want to check <LINK_0> in the beginning of the test
I think.asBoolean() returns a value in the range [0, 1), so you'd want to check <LINK_0> in the beginning of the test
nit: put the else on the same line as the if (interruptedAgain) {
Instead of skipping it here, we should throw an exception if it is interrupted.
nit: put the else on the same line as }
Why are you catching and ignoring?
Why are we catching and ignoring?
why is the batch created even if it already started?
If you are extending this to null, you will end up with a null pointer exception in the other methods if that makes sense.
If you are extending this to null, you will end up with a null pointer exception here.
If you are extending this to null, you will end up with a null pointer exception again.
Was this line break backwards compatibility?
Was this line break?
please add missing braces
You can use org.apache.commons.lang3.StringUtils.isNotBlank(String) here
You can use org.apache.commons.lang3.StringUtils#isBlank here
You can use org.apache.commons.lang3.StringUtils.isNotBlank(String) instead
When testing, I got an NPE when studentProfile is null. This needs a non-null check. Also needs a test to prevent that from happening again.
When testing, I got an NPE when studentProfile is null. This needs a non-null check instead.
When testing, I got an NPE when studentProfile is null. This needs a non-null check. Also needs a non-null check.
Was there a particular reason to add the exception to the getArgument call here?
Was there a particular reason to add the exception to the end of the check?
Was there a particular reason to add the exception to the getArgument call here, rather than its number?
Please use any(State.LEADER) rather than never()).askAndProcessSnapshotOnDemand
Please use any(State.LEADER) with never() to be more reliable
Please use any(State.LEADER) rather than any(State.class)
This is a remnant of the original body.
This is a remnant of the original body. Please use just body.getName() instead of.jpg pattern.
This is a remnant of the original body. Please use just body.getName() instead of.jpg here.
Why do we need to use Math.min()? It seems to me that this would always be faster.
Why do we need to use Math.min()? It is enough to check the upper case.
Why do we need to check the vertex of the hash code?
should not this be removed
should be removed
should not this be removed?
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
I think the try/catch block is intended, can you add the exception's try { } finally { connection =!success; }
I think the try/catch block can be removed, or the closeOnError should be made so that the exception was logged.
IMO, it is better to keep the private static field in class. DetailAST<...>.findFirstTokenByPredicate?
IMO, it is better to keep the private static field in class. DetailAST
IMO, it is better to keep the private static field in class.
I think this line is not needed because we have the plugin java convention in the ui-web.xml
would it be handy to have a better name for this?
would it be handy to have a better name?
Maybe it's worth extracting a method like getMessage()?
Maybe it's worth extracting a method like this from the DataSource class?
Maybe it's worth extracting a method like this from the DataSource.
handle APIException
handle exception
handle exception.
what is this lock for? Do we need a separate lock?
what is this lock for? Do we need a separate lock for each thread?
what is this condition doing? Do we need a catch block to catch it?
This should be 1PC
This should be 1)
This should be 1PC?
Should it be included in the type parameter?
Should it be the type parameter?
Does it make sense to have a type parameter?
If it is not possible to retrieve the same interval multiple times, then it is not needed.
A constant? So it is not needed to test the code to work correctly.
final
I don't see why we need this?
I don't see why this is needed?
can we move this out of the loop, then?
latch
latch.countDown()?
latch.countDown()?
Why does this need to be public?
Why not use Arrays.toString(this) instead of this?
Why not use Arrays.toString(this)?
Add a fail() after this line, so that the target fails.
Add a fail() after this line?
Add a message
Please add a space after the comma.
Should this be a Set? If not, shouldn't we use a Set as a return type?
Should this be a Set? If not, shouldn't we use a HashSet as a return type?
This is Presto code base, but I think there's a better way to test this. If it is written like this, use the most specific Cassandra (which may be the same as the first PR) to create a Block instance for this.
This is Presto code base, but I think there's a better way to test this. If it is written like this, use the most specific Cassandra (which may be the same as the first resident of a new Block instance) instead. Or create a new interface in the LightEmitter that takes in a float, and use that.
This is Presto code base, but I think there's a better way to test this. If it is written like this, use the most specific Cassandra (which may be the same as the first resident of a new Block instance) instead. Or create a new interface in the LightEmitter that takes in a chunk using the min/max bounds?
How about using String.valueOf(size.split("x")? We do not have a usecase in long time.
How about using String.valueOf(size.split("x"))? We can then get a value with the actual size.
How about using String.valueOf(size.split("x")?
:notebook: [System.out.format](<LINK_0> may be able to help here
:notebook: [System.out.format] (<LINK_0> may be able to help here
:notebook: [System.out.format](<LINK_1> may be able to help here
It is possible to get rid of this variable, since you're already using it again.
It is possible to get rid of this variable, since you're not using it again.
It is possible to get rid of this variable, since you are using it again.
If videoEnabled is true, this can be replaced with a call to createPeerConnectionFactory()
can you make this private?
If videoEnabled is true, this will not work.
Minor nit: this can be simplified to this: HasText hasText = (HasText) node.getContent().getDefinition(); return hasText.getText().getValue();
Minor nit: Should this be duplicated with the following if statement? suggestion HasText hasText = (HasText) node.getContent().getDefinition();
Should this be duplicated with the one below?
@ FieldInfoeong Won't this solve the issue?
@ FieldInfoeong Won't this solve the problem?
@ FieldInfo4j would solve the problem as well
This getFrom method should take a modifier to determine which method should be called. The decorability of the getFrom method.
This getFrom method should take a modifier to determine which method should be called. The deceleration of getFrom() is rather confusing.
This getFrom method should take a modifier to determine which method should be called.
Is it possible to check that connProps.putAll(propertiesFromPairs(propertyPairs))?
Is it possible to use the.toString() method?
Is it still needed?
WordsEnvironment.getObject() should throw this error if the object isn't found.
WordsEnvironment.getObject() should throw this instead of checking for null.
WordsEnvironment.getObject() should throw this instead.
what is this extra code?
what is this //?
@exception
Check if the second argument is null, otherwise return.
Check for nulls before building the plugin?
Check for nulls
Rename to getMostRecent
Rename this variable to indicate that we are returning a true or false?
Is this a for-each loop possible?
You can use symbol.isSubtypeOf(symbol) here, no need to cast it.
You can use symbol.isSubtypeOf(symbol) here.
You can use symbol.isSubtypeOf(...) method
It would be nice to use more abstract class of the FixedCouponBondTrade, which is the default one.
Please use ExpectedException for the list of valid attributes.
Please use ExpectedException
what's the purpose of this test? you don't can just replace it with assertThat(...).assertEquals(...).
what's the purpose of this test?
What's the purpose of this test?
This is already done by the Log_OC.d(TAG,...) line above, so it's better to remove the extra space.
This is already done by the Log_OC.d(TAG,...) line above, so it's better to remove the null check here too
This is already done by the Log_OC.d(TAG,...) line above, so it's better to remove the null check here.
You may also want to do this in the pom file.
You should always close the old resource.
You should always close the resource in the try
I'm not a lover of synchronized! Can we make a synchronized method in a system.
I'm not a lover of what you do here. Looking at the code more closely suggestion if (nextProjectNegotiation.isEmpty()) {
I'm not a lover of synchronized! Can we make a race condition?
@Draidelcano, please add final
@Draidelcano, please use width variable.
@Draidelcano, please try to use findById method.
Why does this need to be null?
Why does this return null?
Why not null?
This change does not seem necessary for this PR. I would like to know why this line was changed.
This line does not seem necessary for this PR. I would like to know why this line was changed.
This change does not seem necessary for this commit. I would like to know why this line was changed.
This should say resource == null.
This should say resource.openStream()
This should be removed.
side question, but do we really need to check for cluster level?
Does this also log the information from the Exception?
side question, but do we really need to check all these args?
Could you remove AudioManager.SOUND_DIR and use AudioManager.SOUND_DIR here?
Could probably remove AudioManager.SOUND_DIR and use AudioManager.SOUND_DIR here?
Could you remove AudioManager.SOUND_DIR from this PR?
I think this is too much generic. If the pattern ends with a path that doesn't match (or the path ends with a /) then the matches will not match.
I think this function should be moved to line 206.
I think this function should be moved to line 206 and not place the match.
Wouldn't this be problematic when detaching the network from cluster and this code will run?
Wouldn't this be problematic when detaching a network from cluster and this code will run?
Maybe you should move the network check to the removedNetworks() method and use it here and in removeNetworkToVds()?
This seems like a common pattern to be used in multiple places. Is it better to create a common method in this class?
This seems like a common pattern to be used in multiple places. Is it better to have a common method in this class?
This seems like it should be a generic log message in the Exception.
I might be missing something, but it's very wrong. You can use digits.length() to check this too.
I might be missing something, but it's very wrong. You can use digits.length() to check this.
I might be missing something, but it's very wrong. You can use digits.length() to check that the string is the same as the digits.length() > 1
java.map(this::new).orElse(null)
java.map(Object::new).orElse(null)
Please leave these tabs
I think these variable names should be changed as well.
I think these variable names should be changed.
I think these variable names should be changed as well
this looks like it's not meant to be a public API, it should be a private method and let the API instantiate the object directly.
this looks like it's not meant to be a public API, it should be a public API.
this looks like it's not meant to be a public API, it should be a private method
The key should be testGetVariantsByRegionHelper.
The key should be testGetVariantsByRegionHelper.testGetVariantsByRegionHelper().
The key should be tested by the corresponding test, not just the region id.
@benzonico can we reduce the issue message by overriding the method in order to ease the reading of the code?
@benzonico can we reduce the issue message by overriding the method in order to ease the reading of the code?
@benzonico can we reduce the issue message by overriding the method of the parent class?
Perhaps single quotes around actual code
You probably want a different way of doing this, although less important since we can see all the paths
You probably want a list of strings here, although less important since we can see all the paths
WorkflowRuntimeParameters.EMPTY_VALUE may be better than empty string.
WorkflowRuntimeParameters.getOnlyElement() is a bit better than using.filter() method.
WorkflowRuntimeParameters.getOnlyElement() is a resource type. Please use try with resources for both methods.
In theory, this is not the JMSCorrelationID. The JmsMessageReader generates a new CorrelationID if none is received via JMS. So it is more the Scout Correlation ID.
In theory, this is not the JMSCorrelationID. The JmsMessageReader generates a new CorrelationID if none is received via JMS. So it is more the Scout CorrelationID.
In theory, this is more the JmsMessageReader generates a new CorrelationID if none is received via JMS. So it is more the Scout Correlation ID.
Should the datname be taken from pg_stat_database where datname=connector?
Could you please use pg_stat_name instead of hard-coded string?
Could you please use pg_stat_name instead of hard-coded string in the SQL query and avoid using Jackson altogether?
setMembers(new User()) is unnecessary.
setMembers(new User())
setMembers(new User());?
Is this change related to not being tested?
Is this really needed?
Is this actually needed?
Why do you need this check?
Why do we need this check?
Why do you need this? I think these tests are failing on Windows
Missing space after (
If using existing means the change is no longer needed, we should remove it.
Missing final
I know it's not part of those PR, but to have this method return a map of VmDevice so you can declare it with it, it should be a set in VmDevice
I know it's not part of those PR, but to have this method return a map of VmDevice so you can declare it with it, it should be a Set, and it's returning a specific set of it from the VmDevice
I know it's not part of those PR, but to have this method return a map of VmDevice so you can declare it with it, it should be a Set, and it's returning a generic set of it to 1.
This is not right - we need to tell the receiving side that the transport did a byte array with a name like: byte[] bytesToWrite = new String(byte[]) (toObjectType.getParameter("type"))) { URI content = fromObjectType.get(contentType); if (payload instanceof byte[]) { String[] result = fromObjectType.getParameter("type"); if (resultClass!= null) { result = new String((byte[]) payload, "UTF-8"); } else { result = new String((byte[]) payload, "UTF-8"); } catch (UnsupportedEncodingException e) { logger.error("Could not convert String to bytes", e); } return payload; }
This is not right - we need to tell the receiving side that the transport did a byte array with a name like: byte[] bytesToWrite = new String(byte[]) (toObjectType.getParameter("type"))) { URI content = fromObjectType.get(contentType); if (payload instanceof byte[]) { String[] result = fromObjectType.getParameter("type"); if (resultClass!= null) { result = new String((byte[]) payload, "UTF-8"); } else { result = new String((byte[]) payload, "UTF-8"); } catch (UnsupportedEncodingException e) { throw new IllegalStateException("Could not convert byte array to byte array", e); } }
This is not right - we need to tell the receiving side that the transport did a byte array with a name like: byte[] bytesToWrite = new String(byte[])
botForce.getCamoCategory() can be null
botForce.getCamoCategory() can be null?
botForce.getCamoCategory() can be replaced with this code
This is not needed. There is an option of having a default value, which would mean the query is used only if it was defined.
This is not needed. There is an option of having a default value, you can use the default when calling the other constructor
This is not needed. There is an option of having a default value, you can use the default when calling the other methods.
to avoid duplicated code i guess, it can be folded into method, e.g.: java return ImmutableSet.of(NUMBER_OF_NON_NULL_VALUES, MIN, MAX_VALUE_OF_DISTINCT_VALUES);
to avoid duplicated code i guess, it can be extracted to method to reduce duplication
to remove empty lines
Can we make this method private?
Can you update this to use parseStringValue()?
Can you update this to use parseList()?
that code looks funny. Is the exception expected or not? Seems like a fail() should either be in the normal or exception flow path, no?
that code looks funny. Is the code not expected or not? Seems like a fail() should either be in the normal or exception flow path, no?
that code looks funny. Is the exception expected or not? Seems like a fail() should either be in the normal or error flow path, no?
Can we use standard sanitizedName instead of sanitizeedName?
Can we use standard sanitizedName instead of sanitizeing to make it work?
Can we use standard sanitizedName instead of sanitizeing to make it work automatically?
I think this is okay, but it looks like we are still iterating the expected keys twice. Just one of the equals methods in a loop.
I think this is okay, but it looks like we are still iterating the expected keys twice.
I think this is okay, but it looks like we are still iterating the expected keys twice. Just one iteration over the map and check the values for the equals method.
if you have to verify that the table exists before that we can use it. <LINK_0>
if you want to verify that the table exists before that we can use it. <LINK_0>
if you want to verify that the table exists before that we can use it.
Need to change the name here too
Need to change this string to a constant
capacity
Why do we need to move it from the coordinator? Won't the managed-session be created prior to the payment system?
Why do we need to move it from the coordinator? Won't the managed-session be always created after we've got the charge and and then we can verify if the payment is active?
Can we avoid using the old api here?
Q: We have statefulTasksToRankedCandidates as a class-level static final variable, so we can just use it directly in statefulTasksToRankedCandidates.
Q: We have statefulTasksToRankedCandidates as a class-level constant, we can use it here instead of copying the list.
Q: We have statefulTasksToRankedCandidates as a class-level static final, and we assign the tasksToRankedCandidates to use them in assignStandbyReplicaTasks().
If there is another test case for this line than it should be removed.
If there is another test case for this line than it is used.
If there is another test case for this line then do not make it another test.
suggestion ServiceReference -> methodHandler.getMethod(serviceMethod, methodHandler.ServiceInterface() );
suggestion ServiceReference -> methodHandler.getMethod(serviceMethod, methodHandler.getClasses()) );
suggestion ServiceReference -> methodHandler.getMethod(serviceMethod, methodHandler.getClasses() );
This should be EAP_CODE_SUCCESS I think.
This should be EAP_CODE_SUCCESS
This makes no sense, and is where I think the error message is null.
Since you're only going to be using the fact that these get pressed, consider just passing Events instead of Booleans. (Igneous.joystick1.getButtonSource will give you EventInputs directly.)
Since you're only going to be using Booleanstick1.getButtonSource will give you EventInputs directly.
Since you're only going to be using the fact that these get pressed, consider just passing Events instead of Booleans. (Igneous.joystick2.getButtonSource will give you EventInputs directly.)
remove first argument
remove first parameter
change to addLog
You could use org.kie.workbench.common.stunner.core.util.StringUtils.nonEmpty(..) (but how was you to know!?!)
You could use org.kie.workbench.common.stunner.core.util.StringUtils#nonEmpty(..) (but how was you to know!?!)
You should use org.kie.workbench.common.stunner.core.util.StringUtils.nonEmpty(..) (but how was you to know!?!)
Please check with isEmpty()
Please check with isEmpty() if it's more robust.
Please check with isEmpty() if it's more readable.
if(title.trim().length > 1) { return ImmutableList.of(title, pubmedIds); }
if(title.trim().length > 1) { return ""; }
if(title.trim().length > 1) {
Can this happen?
Remove this log statement
Remove this log statement?
Variable name should be unused
A lot more vals please
Variable name from elsewhere
InfraVariables is not set but RMDBManager is set
InfraVariables is not set but also persistInfraVariables. Is it intentional?
InfraVariables is not set but also persistInfraVariables
shouldn't we add a warn message here?
is there a reason why we need to use null?
is there a reason why we need to use null explicitly?
unused
maybe we should add a private method getTotalNumberOfInterfaces(DataCommand params) since this one is now unused
maybe check StateSystemException
I think we should use the.toArray() utility method in here.
I think we should use the.toArray() /.toArray()
I think we should use the.toArray().
v1? Not v1beta1
v1? Not v1beta1?
v1
- [x] Why is this InterpreterProperty("SPARK_HOME")?
Explain - why is this SPARK_HOME?
- [x] Why is this 'else'?
We need a better way to do this without the step property being there. For example: Properties existingStepProperties = this.stepProperties.get(stepName); if (stepProperties.containsKey(stepName) {... }
We need a better way to do this without the step property being there. For example: Properties existingStepProperties = this.stepProperties.get(stepName); if (stepProperties.containsKey(stepName)) {... }
We need a better way to do this without the step property being there. For example: Properties existingStepProperties = this.stepProperties.get(stepName); if (stepProperties.containsKey(stepName) {... } }
this validation should be in the commcare controller, not the service integration
this validation should be in the commcare controller, not the service integration view
this validation should be done in the commcare controller, not here I think
Do we need this check?
Do we need to check retries == null?
Do we need this check for retries?
Should be fine in this case.
That's a good idea.
Should be fine in this case
I think you should also save the condition groups anyway, if the condition is not save, then the test will fail.
I think you should also save the condition groups separately, if the condition fails to save, otherwise just save it as is
I think you should also save the condition groups anyway, if the condition is not null, just save it once
Why not just add the prefab to the CoreRegistry?
Why not just ImmutableList.copyOf()?
Why do we need a singleton?
I'm not sure this is appropriate, but wouldn't it be better to fail the process entirely if chmod command returns 0?
I'm not sure this is appropriate, but wouldn't it be better to fail the process anyway?
I'm not sure this is appropriate, but wouldn't it be better to fail the process?
getCount() - count() is pointless here.
getCount() - 1. This isn't necessary, the number of getCount() - 2.
getCount() - 1?
((Server)server).setModuleState(temp, state) is called twice in this loop
((Server)server).setModuleState(temp, state); is called twice in this loop
((Server)server).setModuleState(temp, state) is called twice in this cycle
I don't think we need this extra variable to be used.
I don't think we need this concat step in the constructor.
I don't think we need this extra variable
Do we have tests for this? I think it's better to use branchName == null here.
Do we have check for null here?
Do we have tests for this?
It would be better to just check the interrupted status of the Thread.currentThread().interrupt()
Subjective Exception to be thrown, we should be more specific here.
Subjective Exception
Can we add a log.error() here?
Can we add a test to confirm this work without any changes?
Can we add a test to confirm this work without any tests?
If we go to the cqlParser class, we could reuse this class.
If we go to the cqlParser class, we could use this class to annotate this class with @Context.
If we go to the cqlParser class, we could use this class to annotate the cqlParser class as well
please move this sibling.findFirstToken(TokenTypes.IDENT).getText(); before the for loop.
please move this sibling.findFirstToken(TokenTypes.IDENT).getText(); before for loop.
please move this sibling.findFirstToken(TokenTypes.IDENT).getText(); in all 3 methods at the top.
do you get the redundant newline thing now?
again, Is just logging the correct thing?
again, Is just logging the correct behaviour?
for readability I think we should have one here: public void createWebViewClient(List<String> allowedURL) {
for readability I think we should have one here: public void onPageStarted(view, String url, favicon) {
for readability I think we should have one here.
Does this have to be public?
Does this need to be public?
Does this need to be hard coded?
Use a new method in InputPortInfo constructor.
Use a new method in InputPortInfo.java
Use I18n
This looks a little confusing - it should extend privileges at all
This looks a little confusing - it should extend privileges that is set
This looks a little confusing - it should extend privileges at all. I think we should probably leave it as is and only check if it is a parameter, not just the empty string.
Why do you use java.util.Arrays.asList()?
I think this check should be moved to the if-else statement.
I think this check should be moved to the if-else statement of the synchronized block.
Can this be changed to ArrayList<> instead of ArrayList<>?
Can't we rename to suffixValue or something like that?
Can you rename to suffix?
Consistently use position, offset, length. Not important.
Consistently use variables, all names that are not used _after_ the same variable. This is the same as the current one.
Consistently use variables, all names that are not used _after_ the variable. This is the same as the current one.
Sorry, please remove this error.
Sorry, please remove this error message.
Sorry, please remove this error log.
why not put image?
why not put image as parameter and use it in the if condition?
why not put image as parameter?
can you extract this to a method, e.g.: @Override public List<String> getExportedResources() throws IOException {
can you extract this to a method, e.g.: @Override public List<String> getExportedResources() throws IOException { return getExportedResources(); }
can you extract this to a private method, e.g.: @VisibleForTesting public List<String> getExportedResources() throws IOException {
Maybe I'm being daft, but where are the CDA message being added?
Maybe I'm being daft, but where are the CDA message being added? If yes, then there are no CDA messages in the disks.
Maybe I'm being daft, but where are the lines 121 and 176?
You should rather use.isEmpty() WDYT?
You can use.isEmpty() instead of equals("")
You can use.isEmpty() instead of equals("").
Shouldn't it be template.
Shouldn't it be template to select it?
Shouldn't it be template for both Open and Windows file?
confirmDelete = new DeleteRepositoryGroupConfirmDialog(getShell(event).refresh(); if (!confirmDelete.open() == Window.OK) {... }
call getView(event).refresh();
Just "groupName".
Nit: make it more descriptive.
Nit: make it more descriptive?
Nit: remove empty line
So the logic here is in getService() and this method is supposed to be in the abstract create method. Was there a reason for doing it here?
So the logic here is in getService() and this method is supposed to be in the public api? It should be in getService() too.
So the logic here is in getService() and this method is supposed to be in the abstract classes?
why aren't you using "setSucceeded(true)"?
why aren't you using "setSucceeded(false)"?
why aren't you using "getStoragePoolDAO().updateStatus(pool.getId(), pool.getstatus());"
What happens if job.getJobId() == null || job.getJobName() == null?
Would it be better to merge these 2 if statements into one?
What happens if job.getJobId() == null or job.getJobName() == null?
I think you need to do the null check on the CorrelationAttributeInstance's constructor.
I don't think you need the null check on the CorrelationAttributeInstance here.
I think you need to do the null check on the CorrelationAttributeInstance's object.
I don't think we should assume that here, since it's not the same as the one in line 119 -- :P
I don't think we should assume that here, since it's not the same as the one in line 119 --?
I don't think we should assume that here, since it's not the same as the one in line 119 --. Done
why is it required to pass the status to refreshVdsRunTimeInfo()? see also in line 103.
why is it required to check the return value of refreshVdsRunTimeInfo()? see also in line 103.
why is it required to check the return value of refreshVdsRunTimeInfo()? see also in vdsEventListener.vdsUpEvent, it will be always null.
s/isSeparator/isSeparator?
s/isSeparator/isSeparator
s/isSeparator/isSpace
This is unnecessarily slow when change!= null and we know the branch name from the change object.
This should be changed to: IncludedInDetail _detail = resolveBranches(c);
Can't this be changed to: IncludedInDetail _detail = resolveBranches(c);?
This is a pattern where this should be used, this should be in the for loop.
This is a pattern hardcoded, this should be in the for loop.
This is a pattern where you can use a regex each time, this should be faster.
Only thing I think we should be more general: if (patientBundle!= null &&!patientBundle.isBuilding(), true)) { Something like java } else { patientBundle = getIntent().get(); }
Only thing I think we should be more general: if (patientBundle!= null &&!patientBundle.isBuilding(), true)) { Something like java } else { patientBundle = getIntent().getAndroid(); }
Only thing I think we should be more general: if (patientBundle!= null &&!patientBundle.isEmpty()) { Something value = patientBundle.get() } It's often more lightweight to use java myoptional logic.
There should be a null check on this.
There should be a null check on getArguments() here.
There should be a null check on getArguments() instead.
Consider renaming value to something like "value".
This method is not used at all
This is suspicious.
Again, the indentation is wrong.
Again, a constant
Again, logging
If we want to fail the timer here, we should also log an error message.
If we want to fail the timer here, we should also log something about tsNanos.
If we want to fail the timer here, we should also log something like: DataConnectionRealTimeInfo.isPendingState(e);
Also, shouldn't this be synchronized?
Also, shouldn't this be protected?
Also, shouldn't this be a warn?
Predicates.instanceOf(MongoDBRouter.class)
Predicates.instanceOf(MongoDBRouter.class) should work
Predicates.instanceOf(MongoDBRouter.class) is sufficient
I think we should only reset the task if the user selected something. What do you think?
I think we should only reset the old config when the user has finished.
I think we should only reset the task if the user selected something.
I think that textBytes[fieldId] is also valid in the input schema.
I think that textBytes[fieldId] is already null and we should throw an exception if we don't have fieldId in the array.
I think that textBytes[fieldId] is already null and we should throw an exception if we can't get fieldId from fieldId.
so we're not using the Java 8 output here?
so we have the outer try/catch here also?
so we're not using the Java 8 output?
Lot
Should set as creator as well
Lot of duplicated code
I don't think you need this check.
I don't think there is a need to introduce any accessible methods like this.
I don't think there is a need to introduce any runtime exceptions here. This should be done at compile time.
I wonder if the following should work: FileDescriptor fileDescriptor = createFileDescriptorSource(FileDescriptorSource.fromResources("/sample_bank_account/bank.proto")); FileDescriptor fileDescriptor = parseAndResolve(fileDescriptor.getFields()); for (FileDescriptor fileDescriptor : descriptors) {... }
I wonder if the following should work: FileDescriptor fileDescriptor = createFileDescriptorSource(FileDescriptorSource.fromResources("/sample_bank_account/bank.proto")); FileDescriptor fileDescriptor = fileDescriptor.get(name);
I wonder if the following should work: FileDescriptor fileDescriptor = createFileDescriptorSource(FileDescriptorSource.fromResources("/sample_bank_account/bank.proto")); FileDescriptor fileDescriptor = parseAndResolve(fileDescriptor.getWebApp().getResourceAsStream(getContent()));
We do not want to call mkdirs. If you have a directory already, maybe pass the exception as the cause to the FileOutputStream.
We do not want to call mkdirs. If you have a directory already, maybe pass the exception as the cause and create a directory.
We do not want to call.equals here, so maybe log the exception as well?
I don't want to fail to display this. We can always just print the Entitlement object.
I don't want to fail to display this error
I don't want to fail to serialize it
I think you should also mention the username in the error.
I wouldn't bother with including the username in the error. It is already an error.
The groups should be inside ProjectControl.
is this null check necessary?
is this null check needed?
we should probably throw an exception if the query doesn't have a valid timeseries but not with a timeseries
Utils.validateUser hash
'public static final'
Formatting.
:ant: If we use Timeone.setDefault(DateTimeone.UTC) instead of setting it to one value, I think we should create a private method to onedDateTime.setDefault(Timeone.getTimeone("UTC")); and call that instead of onedDateTime.setDefault(DateTimeone.UTC);
:ant: If we use Timeone.setDefault(DateTimeone.UTC) instead of setting it to one value, I think we should create a private method to onedDateTime.setDefault(Timeone.getTimeone("UTC")); and call that instead of onedDateTime.setDefault(DateTimeone.UTC)
:ant: If we use Timeone.setDefault(DateTimeone.UTC) instead of setting it to one value, I think we should create a private method to onedDateTime.setDefault(Timeone.getTimeone("UTC")); and call that instead of onedDateTime.setDefault(DateTimeone.UTC).
nit: any reason this change is needed?
nit: any reason why this change is needed?
nit: any reason this change is needed? (I'm assuming it is needed before)
Please use Factory.getCRUDControllers()
Please use crudControllers
Please use crudControllers!= null
You should use the org.elasticsearch.client.Person instead of a concatenated string.
You should use the org.elasticsearch.client.Person instead of an elastic search
You should use the org.elasticsearch.client.Person instead of a concatenated string. For example, would that work?
nit: you can get rid of the negation and use TimeUnit.MILLISECONDS.toNanos(System.nanoTime()).
nit: you can get rid of the negation and use TimeUnit.MILLISECONDS.toNanos(System.nanoTime())
nit: you can get rid of the double / 1_000_000 code, right?
This one should also assert that the _result_ is at least one of the keys.
This one should also assert that the.size() == 1 because of the one above.
This one should also assert that the.size() == 1
I don't think the atLeastOneIndexUsed should be used here. If the query does not contain a text, it would be better to have something like SELECT _id FROM \"%s\"", tableName) instead.
I don't think the atLeastOneIndexUsed should be used here as there is no need to have an additional null check.
I don't think the atLeastOneIndexUsed should be used here.
I'd rather rename it to checkUserAndGroupsAuthorization
Please remove this extra empty line.
I'd rather rename it to checkUserAndGroupsAuthorization.
catch (CliInitializationException | IOException e) { throw new IllegalStateException("Unable to connect to controller.", e); }
catch (CliInitializationException | IllegalAccessException e) { throw new IllegalStateException("Unable to connect to controller.", e); }
catch (CliInitializationException | IllegalAccessException e) { throw new IllegalStateException( String.format("Unable to connect to controller.", e), e); }
Are we assuming that if oVirt is installed and managing the cluster, scheduling will be done from oVirt? I think we should disable the CLI scheduler only if there's an existing schedule setup from oVirt. How would we handle the case of multiple schedules on a volume, if a customer wants it. Currently that can be done through CLI. Meta-volume could exist because of geo-rep use case too.
Are we assuming that if oVirt is installed and managing the cluster, scheduling will be done from oVirt? I think we should disable the CLI scheduler only if there's an existing schedule setup from oVirt. How would we handle the scenario of multiple schedules on a volume, if a customer wants it. Currently that can be done through CLI. Meta-volume could exist because of geo-rep use case too.
Are we assuming that if oVirt is installed and managing the cluster, scheduling will be done from oVirt? I think we should disable the CLI scheduler only if there's an existing schedule setup from oVirt. How would we handle the case of multiple schedules on a volume and if a customer wants it. Currently that can be done through CLI. Meta-volume could exist because of geo-rep use case too.
Sorry, I didn't yet look into it. Could you explain it and figure out why the code was failing?
Sorry, I didn't yet look into it. Could you explain it and figure out what was the problem, and how can we handle it?
Sorry, I didn't yet look into it. Could you explain it and figure out what was the problem, and how is this code kept?
I don't follow this logic. If the array is empty then this method returns an empty array? And if the array is empty then an empty array is returned. Is that intentional?
I don't follow this logic. If the array is empty then this method returns an empty array? And if the array is empty then an empty array is returned.
I don't follow this logic. If the content is null, then this method returns an empty array? And if the if block returns if the acl is not null, then we return an empty array?
The first three lines can be replaced with a single call to scanClass.
The first three lines can be replaced with a single call.
It seems that this method will throw IOException. The code that is in a separate implementation.
I don't think you need to return the result here. You can just check for "removingType" in this case.
I don't think you need to return the result here. You can just use tupleDomain.getDomains().get(column) instead.
I don't think you need to return the result here...
true -> false?
this is always true?
true?
If I am correct then this loop should be in its own method.
If you put this in a private method this method can be modified by the method below.
If you put this in a private method this method can be modified by automated refactorings and e.g. in the future we should avoid making this method synchronized.
Can you please use StringUtils.isNotBlank(configStr) instead?
Can you please use StringUtils.isNotBlank(configStr) instead of containsKey()?
Can you please use StringUtils.isNotBlank(subparts) instead of containsKey()?
This is too slow. It should be releaseExportBytes(long releaseOffset)
Minor: can you remove this?
This is too slow. It should be releaseExportBytes(long releaseOffset) instead.
double check that the group is still here
double check that no group is still here
double check that no group is actually created
I'm not sure if this is good or not, but would it be better to make this private static?
I'm not sure if this is good or not, but would it be better to just use something like this? SecureRandom.getInstance("SHA1PRNG");
I'm not sure if this is good or not, but would it be better to just use something like "loadUserToSession" to simplify the code?
Would it make sense to put this at the top of the method? That is more explanatory and the user-friendly.
Would it make sense to put this at the top of the method? That is more part of the operation.
Would it make sense to put this at the beginning of the message?
should be 'task'with its description here
should be 'task' with its description here
should be 'task Name' with its description
It would be useful to add a second check if is enabled, in debug mode.
It seems like this call is missing a second check, because it would be useful to print out the first time.
It would be useful to add a second check if is enabled, in case it's running in the loop.
can we make resourceName for all the states be same e.g. "state" instead of being specific as that requires the conditional and hardcoding of URLs? I'm not sure if we need to give each one a different name.
can we make resourceName for all the states be same e.g. "failed" instead of being specific as that requires the conditional and hardcoding of URLs? I'm not sure if we need to give each one a different name.
can we make resourceName for all the states be same e.g. "state" instead of being specific as that requires the conditional and hardcoding of URLs? I think we need to give each one a different name.
1) When would 'IStatus.ERROR' be null? 2) Why drop the exeption message and use the message?
1) When would 'IStatus.ERROR' be used? 2) Why drop the exeption message and use the message?
1) When would  monitor be null? 2) Why drop the exeption message and use the plugin?
I think it makes more sense to use Log.e(TAG, "Marker can not be found, click event won't fired.", Log.ERROR_MODE);
I think it makes more sense to use Log.e(TAG, "Marker can not be found, click event won't fired.", Marker.class);
I think it makes more sense to use Log.e(TAG, "Marker can not be found, click event won't fired.");
I'd recommend using.orElseGet(() -> LOG_CHUNK_SIE) here since the parameter is in the logAndReplaceRequest method - it doesn't seem to matter.
I'd recommend using.orElseGet(() -> LOG_CHUNK_SIE) here since the parameter is in the logAndReplaceRequest method - it doesn't seem to be.
I'd recommend using.orElseGet(() -> LOG_CHUNK_SIE) here since the parameter is in the logAndReplaceRequest method. The same for the other logAndReplaceRequest method.
Isn't it better to catch (PermissionException | IllegalAccessException | Exception e)?
Isn't it better to catch (PermissionException | IllegalAccessException |...)?
Isn't it better to catch (PermissionException pe) here?
These 3 lines could be moved into a method and reused.
These 3 lines could be private methods and used in groupLabelUpdateEvents.
These 3 lines could be moved into a method and reused as method reference.
Should we add a warning log here?
Should we add a warning log here (e.g. skippedIdempotentUpdatesTimestamp)?
Should we use the droppedRecordsSensor.record() here?
Should this be moved into the Validate method?
Should this pass the type to the constructor?
Should this be the case where the wildcardType is a AnnotatedTypeVariable?
Should be meanSingularData.
Should be meanSingularTime.
Should be logSingularData.
Need to declare them before declaration.
Need to declare them before the try-with-resources.
Need to declare them before you try-with-resources.
If we're doing this, then we should be able to use the verifyHash method instead.
If we're doing this then we should use the self constructor rather than the actual value.
If we're doing this, then we should be able to use the verifyHash method below.
This looks like it should be a NOT_METASTORE_ERROR?
This looks like it should be a NOT_METASTORE_ERROR.
This looks like it should be throwing TimeoutException.
Format the whole code (ctrl + alt + L)
this code (ctrl + alt + L)
this code is a bit crashylytics.
We should probably update this to use the newer convenience method getHostPath()
We should probably update this to use the newer convenience method
We should probably update this to use the newer jettyRequest.builder().initialAuthentication()
Can metadata.getPrivatePort() return null if the property is not present?
why not log details of the type + message instead of the exception?
why not log details of the event?
@adrielparedes this line is redundant right?
@adrielparedes this line is redundant right? because we've checked that the path here not the watcher.
@adrielparedes this line is redundant right? because we've checked the watcher being registered even if it is not registered again to the bottom.
checkNotNull(itemName, "itemName")
Formatting.
Formatting
this.
I think you can just add this constructor to AbstractCrashGenCleaner.
I think you can just add this constructor to CrashGenCleaner.
Shouldn't this always create a table? If the user changes the location it should be REPLACE_PATH, no?
Shouldn't this always create a table? If the user changes the location it's an existing one, should we keep that one?
Shouldn't this always create a table? If the user changes the location it's an existing one, should we keep that location?
lets add the original exception as the second parameter.
lets add the original exception as the second parameter
lets add e as the second parameter
@subkrish, please move declaration of var to its usage.
@subkrish, please move declaration of map to its usage.
@subkrish, please move declaration of credential on the next line
Where are we setting the cmVersion?
Where is this changed?
Where are we setting the cmVersion to UNKNOWN?
why is this useful?
why not use the created GetBlobResult object?
why not use the created GetBlobResult here?
you put the newThread interrupt in the wrong spot. You want a catch (InterruptedException ie) here just above the catch (Exception e). In that new catch clause is where you call newThread.start(). That interrupt will (potentially) interrupt the sleep and when interrupting the sleep, you just simply "return". You want to tell the inner thread to stop doing what its doing - and you do taht by catching the interrupt and just returning.
you put the newThread interrupt in the wrong spot. You want a catch (InterruptedException ie) here just above the catch (Exception e). In that new catch clause is where you call newThread.start().interrupt(). That interrupt will (potentially) interrupt the sleep and when interrupting the sleep, you just simply "return". You want to tell the inner thread to stop doing what its doing - and you do taht by catching the interrupt and just returning.
you put the newThread interrupt in the wrong spot. You want a catch (InterruptedException ie) here just above the catch (Exception e). In that new catch clause is where you call newThread.start(). It stops the interrupt and when interrupting the sleep, you just simply "return". You want to tell the inner thread to stop doing what its doing - and you do taht by catching the interrupt and just returning.
this method could be declared private
this method can be declared private
this method could be package private
Java style: prefer to break at higher semantic level.
Java style: prefer to break at higher semantic level. This helps to read code readability.
Java 7 has a good feature.
Isn't this the wrong place for this? If the mac is imported you'll get a NPE.
Isn't this the wrong place for this?
could be inlined here.
Probably you could foresee an interface rather than just concrete implementations.
Probably you could foresee an interface rather than just concrete implementations
Better import
should this be startsWith instead of equals?
should return an empty list and put an error message if not authenticated.
should return an empty list and put an error message in the else case
variable not needed
variable not used
variable is not used
To me it seems clearer to make a clear variable for this if statement to if (calculateAccessibility). I like the form with booleans though.
To me it seems clearer to make a clear variable for this if statement to if (calculateAccessibility).
To me it seems clearer to make a clear variable for this to be if (calculateAccessibility).
REC_SIE -> REC_SIE
You can get rid of this particular block by simply doing: java try (ReadableChannel rc = ctx.db.openFile(rc, Cache.newChannel(INDEX)) {... }
You can get rid of this particular block by simply doing: java try (ReadableChannel rc = ctx.db.openFile(rc, Cache.newChannel(ctx)) { // rest of your code }
When is the first parameter of the method? I think it's fine to leave the explicit null checks.
When is the first parameter to be null? Java classes should never be null.
When is the first parameter of the method? I think it's fine to leave the explicit set of what it is instead of atts?
This should be done from whitin the locked block, after we've received the sigal from "notResolving".
This should be done from whitin the locked block, so that we'll be notified of notResolving.
This should be done in the finally block.
you can simplified the if/else with the one below
I'm not sure this if else should be here
I'm not sure this if else can be removed.
Was this early?
Was it possible to pass species to the method and make this useful?
Was this necessary?
You can use Objects.requireNonNull(omap).
You need to build your own message. Please change accordingly
You can use Java 8 streams for this.
Do we need this check here, or is the actor#hasPermission above?
Do we need this check here, or is the actor#hasPermission just used?
Do we need this?
I think it would be worth making this error a bit more useful. At least adding the node number so that if errors pop up in the log then someone can see if a particular device is generating lots of errors.
I think it would be worth making this error a bit more useful. At least adding the node number so that if errors pop up in the log then someone can see if a particular element is generating lots of errors.
I think it would be worth making this error a bit more useful. At least adding the node number so that if errors pop up in the log then someone can see if a particular node is generating lots of errors.
use Objects.equals()
use == for Classes.
use ==
We can't cast to BinaryMetadata here.
We can't fail hard here if we use "normal" server error message.
We can't use warn level log here.
It may be a better idea to use a lambda here
It may be clearer to use a lambda here
It seems safer to use a lambda here
null == adapter
how about Collections.emptyMap() instead?
how about Collections.emptySet()?
Maybe we can use Preconditions.checkArgument here?
Maybe we can use Preconditions here?
I think this is a good idea.
consider using assertEquals() instead of assertTrue()
what about assertEquals? if this is null, what are the reason for this test?
what about assertEquals? if this is null, what assertEquals will be printed?
doc
Is getNumDataChunks() > 1 necessary? Doesn't this condition need to be moved into the if block?
Is getNumDataChunks() > 1 necessary? Doesn't this condition need to be synchronized?
I think this should be private. It shouldn't be public.
I think this should be private now, since it's not used anywhere.
I think this should be private
not entirely sure about this, but why not just use the old constructor and have the option call the new one?
not entirely sure about this, but why not just use the old constructor and have the option call the new one with -h flag?
not entirely sure about this, but why not just use the old constructor and have the option call the new one with -h option?
This is a set, should we just return the unused tasks count?
This is a set, should we just return the unused tasks instead?
If we are going to throw Unused tasks, should we just return them?
why?
Why we're hiding the error?
Why?
And which is the point in making this loop @Test(expected=FeatureBasedDiagnostic). There is no real need for each test. Just a suggestion.
And which is the point in making this loop @Test(expected=diagCode.values()).
And which is the point in making the loop simpler.
verifyExceptionMatch() blocks on future.getException(), so isDone() will always be true when you're here, no?
verifyExceptionMatch() blocks on future.getBlobInfoCallback.getException(), so isDone() will always be true when you're here, no?
verifyExceptionMatch() blocks on future.getException(), so isDone() will always be true when you're here, no? Also, if the callback was received, then we should ensure that future.getBlobInfoCallback() returns Future<BlobInfo> and if the callback was received.
Could be simplified as java if (authentication == null || authentication instanceof AnonymousAuthenticationToken) { return ACL.SYSTEM; }
Could be simplified as java if (authentication == null || authentication instanceof AnonymousAuthenticationToken) { SecurityContext old = ACL.impersonate(user.current()); }
Could be simplified as java User user = Objects.requireNonNull(authentication);
Is it really necessary to do something with this? Isn't it enough to do something with the logic?
Is it really necessary to do something with this? Isn't it enough to check if the user has permission to do this?
Is this change related to updating the PR?
please remove the try/catch, you are catching it in public methods
please remove the try/catch, you are catching it in public void error(final Activity activity, final Task Task task)
please remove the try/catch, you are catching it in public void error(final Activity activity, final TaskTaskTask)
I would rather do this as follows: java public boolean canSpawnAt(NonNull world, int x, int y, int z) { if ((double) block.x, y + check.y, z + check.z)) { return false; } }
I would rather do this as follows: java if ((double) block.x + check.x, y + check.y, z + check.z)) { return false; }
I would rather do this as follows: java if ((double) block.x, y + check.y, z + check.z)) { return false; }
s/lease already exists/storage domain/
need to check if leaseInfo is null
s/lease already exists/storage domain '{}'
I thought there was an issue with unboxing the value from expectedMetrics.get(metric.name()). I think it would be cleaner to do: Long value = expectedMetrics.get(metric.name()); if (value!= null) { Long value = value.longValue();...
I thought there was an issue with unboxing the value from expectedMetrics.get(metric.name()). Long value = expectedMetrics.get(metric.name());
I thought there was an issue with unboxing the value from expectedMetrics.get(metric.name()). I am fine with it, though.
This is confusing. Since it's not a part of the overall function, would it be better to add a "isBuyButtonAvailable(position)" method to WordPressDB?
This is confusing. Since it's not a part of the overall function, would it be better to add a "isFreePlan()" method to WordPressDB?
This is confusing. Since it's not a part of the overall function, would it be better to add a "isAddedButtonAvailable(position)" method to WordPressDB?
I am still confused by this method. I would expect that try-with-resources would be better here.
I am still confused by this method. I would suggest to change the name to something like "...be" to better describe what the error is.
I am still confused by this method. I would suggest to change the name to something like "...be" to better describe what it is.
I would return Collections.emptyList() instead of letting the caller handle/handleBatchRequest() do the job.
I would return Collections.emptyList() instead of letting the caller handle and continue.
I would return Collections.emptyList() instead.
This case is not covered in other places.
This case is not covered in unit test
This case is not covered in the unit test
The logo would be nice, I'd rather do this.addEventHandler call in the next line.
The Datacenters also need to be done in the ShowPreferencesPageDataView.
The logo would be nice, I'd rather do this.addEventHandler call in the next line..
There's technically a race condition here, I think this function needs to be synchronized, and set the function inside rapidParseInt()
There's technically a race condition here, I think this function needs to be synchronized, and set the function.
There's technically a race condition here, I think this function needs to be synchronized, and set the function inside the function.
do we want this to continue even if the thread was interrupted above?
do we want this to continue even if the service is undeployed?
do we want this to continue even if the service is in progress?
there is a faster way to check if it is a Gitlink.
there is a simple loop here. The code will return true if there is a commit in the version of the loop.
add final
what about : import static com.caelum.vrelum.http.Parameter;
what about : import static org.caelum.vrelum.http.Parameter;
what about import Parameter?
Replace it with RECEIVING_VARIABLE_NAME
Replace it with RECEIVING_TRACKING_ENABLED
Replace it with state *= 1000;
need to call.getSucceeded()
needs to be checked
redundant
You should have done it right when writing this for the first time
You should have done it right when writing this for it.
You should have done it right when writing this for the first 10s
You should be able to replace all this with Utils.getTemporalPath(mAccountName, Boolean.FALSE)
You should be able to replace all this with Utils.getTemporalPath(mAccountName, File.toPath())
You should use Utils.getTemporalPath here instead of Places.
should be indented
should be final
should be an else if
susceptible to various XXE injections by the looks of it...
susceptable to various XXE injections by the looks of it...
susceptable to various XXE injections by the looks of it.
I think it's better to let this exception bubble up and declare it in throws of the method. this is how all other methods in the library work
I think it's better to let this exception bubble up and declare it in throws of the method. this is how all other functions in the library work
I think it's better to let this exception bubble up and declare it in throws of the method. this is how all other methods in this class work
As I said, I don't think this is necessary. The constructor already throws DtgovUiException and throws DtgovUiException from the constructor.
As I said, I don't think this is necessary. The constructor already throws DtgovUiException and throws CtgovUiException.
As I said, I don't think this is necessary. The constructor doesn't add any value.
You should be able to use something like: import static org.junit.Assert.*; org.junit.Assert.*; assertThat gives a much more useful message, but without reflection.
You can use assertj's assertThat.
You can use assertTrue() here.
I thought we were going to end up here, but not sure if we should do a list of modules and throw an exception. If the configWalk is empty, we shouldn't use the user-facing config here.
I thought we were having a file and one in the file system?
I thought we were going to end up here, but let's not go it up.
Could this throw an exception, instead of catching and ignoring?
Could this throw IOException, instead of catching and ignoring?
I don't think this is the right check if it is not found in the properties file.
This will create the same object every time the constructor is called. There's no need to create this object at all.
Missing @Override annotation.
This will create the same object every time the constructor is called. There might be a better place to put this logic in the createService() method.
We appear to be re-implementing some of querying logic to find the metadata. Instead, leverage the existing APIs in DataConsumer.
We appear to be re-implementing some of querying logic to find the possible metadata. Instead, leverage the existing APIs in DataConsumer.
We appear to be re-implementing some of querying logic to find the metadata. Instead, leverage the existing APIs in DataConsumer.Desciion.
TerminalConnector doesn't have to be created for the workspace, but here you should use brackets here: for (String name : prj) {... }
TerminalConnector doesn't have to be created for the workspace, but here you should use brackets to check for the workspace word
TerminalConnector doesn't have to be created for the workspace, but here you should use brackets here: for (ITmfConnector inner : openmConnection) {...
Could you please change this to use a constant in AherlockAttributes class? So you can use it here.
Could you please change this to use a constant in AherlockAttributes class? So you can have a single shared constant.
Could you please change this to use a constant in AherlockAttributes class? So you can use it here and below?
why not use the iterator?
why not using the iterator?
please extract to a method and reuse it
please change the method name to something like "modelItem".
please change the method name to something like "modelItem" or something similar.
Do not check if modelRepository is null, in which case I would add something else.
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName.
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName().
The rest of this method changed the purpose of this change?
Remove the hard coded string
Remove the hard coded value
Remove the hard coded string here.
Do we need to set the number of digits here?
This is not the right way to set the number of charges
This is not the right way to set the number of results to zero.
Shouldn't the condition be: if (!(e instanceof HttpResponseException)) { throw e; } catch (IOException e) {
Can you invert this condition and make the flow more readable?
Can you invert the condition to avoid negations?
Remove CoinexchangeRateSource.
Remove CoinexchangeRateSource..
Remove CoinexchangeRateSource. Create a final constant
why do you need this?
I'm not sure how this is related to this change.
I'm not sure this is correct.
@sebing please put spaces around :
@sebing please put spaces after :
@sebing please put spaces before and after =
Be more specific about the input stream - close the stream - close the stream - closed via try-with-resources
Be more specific about the input stream - close the stream - close the stream - close the stream - close the stream
Be more specific about the input stream - IOException?
I'm not sure this is a good idea. In this case the exception is not handled properly, right?
I'm not sure this is a good idea. In this case the exception is not handled properly, since we are expecting that the query is actually executed.
I'm not sure this is a good idea.
suggestion assertThat(ldapUserDetails.getDn()).isEqualTo("uid=base64encoded-issue-1840,ou=Users,dc=carlspring,dc=com"); assertThat(ldapUserDetails.getUsername()).isEqualTo("{MD5}5f4dcc3b5aa765d61d8327deb882cf99"); assertThat(passwordEncoder.matches("password", ldapUserDetails.getPassword())).isEqualTo(true); assertThat(((List<SimpleGrantedAuthority>) ldapUser.getAuthorities())).contains(new SimpleGrantedAuthority(SystemRole.REPOSITORY_MANAGER.name()), new SimpleGrantedAuthority("USER_ROLE"));
suggestion assertThat(ldapUserDetails.getDn()).isEqualTo("uid=base64encoded-issue-1840,ou=Users,dc=carlspring,dc=com"); assertThat(ldapUserDetails.getUsername()).isEqualTo("{MD5}5f4dcc3b5aa765d61d8327deb882cf99"); assertThat(passwordEncoder.matches("password", ldapUserDetails.getPassword())).isEqualTo(true); assertThat(((List<SimpleGrantedAuthority>) ldapUser.getAuthorities())).contains(new SimpleGrantedAuthority(SystemRole.REPOSITORY_MANAGER.name()), new SimpleGrantedAuthority(SystemRole.REPOSITORY_MANAGER.name()), new SimpleGrantedAuthority("USER_ROLE"));
suggestion assertThat(ldapUserDetails.getDn()).isEqualTo("uid=base64encoded-issue-1840,ou=Users,dc=carlspring,dc=com"); assertThat(ldapUserDetails.getUsername()).isEqualTo("{MD5}5f4dcc3b5aa765d61d8327deb882cf99").contains(new SimpleGrantedAuthority(SystemRole.REPOSITORY_MANAGER.name()), new SimpleGrantedAuthority("USER_ROLE"));
This construct is weird: description <LINK_0> /** The output schema of the input record is the action to select * the output schema of the output record. * * @param inputRecord The output schema of the input record is the input record of the output record. */ public void validateSchema(StructuredRecord outputRecord, StructuredRecord inputRecord) { Schema outputSchema = getOutputSchema(outputRecord.getSchema()); validateSchema(outputSchema, uniqueFields, filterFunction); }
This construct is weird: description <LINK_0> /** The output schema of the input record is the action to select * the output schema of the output record. * * @param inputRecord The output schema of the input record is the input record of the output record. */ public void validateSchema(StructuredRecord outputRecord, StructuredRecord inputRecord, String textRecord) { Schema outputSchema = getOutputSchema(outputRecord.getSchema()); validateSchema(outputSchema, uniqueFields, filterFunction); }
This construct is weird: description <LINK_0> /** The output schema of the input record is the action to select * the output schema of the output record. * * @param inputRecord The output schema of the output record is the input record of the output record. */ public void validateSchema(StructuredRecord outputRecord, StructuredRecord inputRecord, String textRecord) { Schema outputSchema = getOutputSchema(outputRecord.getSchema()); validateSchema(outputSchema, uniqueFields, filterFunction); }
<LINK_0> This is only true when the insert has failed. Instead get an exception on the next line.
<LINK_0> This is only true when add() is successful. Instead get a PK_KEY, then check for PK_ID.
<LINK_0>
This is good and all, but in the chromeos_system_trace.xml the trace elements are non-runtime and non-runtime ones, runtime exceptions should be thrown by a handler handler or a runtime exception.
This is good and all, but in the chromeos_system_trace.xml the trace elements are non-system by default. You have to introduce a new method and call it only once and reuse the trace elements.
This is good and all, but in the chromeos_system_trace.xml the trace elements are non-system by default. You have to introduce a new method and call it only once and reuse the traceElement on each iteration.
Why is this necessary?
Why is it necessary to create a provider?
Why is it necessary?
These changes shouldn't be avoided.
This doesn't look like setting the actual attributes should be avoided.
These changes shouldn't be necessary
Is this logic correct? I would expect this to be handled by the above "else" block.
Is this logic correct? I would expect files to be deleted either.
Is this logic correct? I would expect this to be handled by the above try
can we use try-with-resources here?
Can we use try-with-resources here like you did before?
Can we use try-with-resources here like you did in the assignment?
I think a short circuit exit at the top of the method is much easier to read.
I think a short circuit exit at the top of the method and try to get rid of all this if.
I think a short circuit makes more sense here.
style nit: no braces around single line blocks
style nit: not braces
style nit: no braces here
Is not necessary? Wasn't it just moved to the top?
Is not necessary? Wasn't checking for null before?
Is not necessary?
This method should be invoked before updating the files in the new one.
This method should be invoked before updating the files in the new location.
So this method should be called before updating the files in the new location?
copy
copy?
copy to StringBuilder
Generics?
Can be static.
Collections.emptyList()
This should be done only once in the UI, otherwise there is a bug where the dialog is not available.
This should be done outside of the UI thread.
This should be done only once in the UI thread.
This could be protected.
I think this would be safer if you put the span span here in channelRead.
I think this would be safer if you don't call Tracer.ChannelRead() here.
This method does not need to be public
This method is used by two places, so it does not really matter.
This method is used by two places, so it should be a little to remove it.
For each test case, it should be a nicer way to do it using lambda syntax: java try (byte[] splitKeys = Bytes.split(startKey, endKey, 2);
For each test case, it should be a nicer way to do it with the expected result.
For each test case, it should be created once?
wrap this line (and above)
wrap this line (column limit 100)
wrap this line (and below)
if (StringUtils.isBlank(proxyHostPath)) { this.mount =...; } else { throw new VolumeException("Unable to mount Filesystem", e); }
if (StringUtils.isBlank(proxyHostPath)) { this.mount =...; } else { throw new VolumeException("Unable to mount filesystem", e); }
if (StringUtils.isBlank(proxyHostPath)) { this.mount =...; } else if (windowsDriveLetter.isEmpty(proxyHostPath)) { get() } Will let you make this cleaner?
Can we introduce a new method to createWallet(String walletLogin) and put these two checks into one method?
Can we introduce a new method to createWallet(String walletLogin) and put these two checks into one and use it?
Can we introduce a new method to createWallet(String walletLogin) and put these two checks into one and use it here?
I strongly prefer inverting these kinds of tests so that they bail early, instead of wrapping the entire method. E.g.: if (!mHelperItemList.isEmpty()) { return; } It's a little thing, but getting rid of one level of nesting reduces conditional context for the reader.
I strongly prefer inverting these kinds of tests so that they bail early, instead of wrapping the entire method. E.g.: if (!mHelperItemList.equals(mStableIdMap.get(i)) { return; } It's a little thing, but getting rid of one level of nesting reduces conditional context for the reader.
I strongly prefer inverting these kinds of tests so that they bail early, instead of wrapping the entire method. E.g.: if (!mHelperItemList.contains(isExpanded() && mHelperItemList.remove(i)) { return; } It's a little thing, but getting rid of one level of nesting reduces conditional context for the reader.
IMHO, this method should take the StorageDomain from the template disks in the storage domain
Why not just getStorageIds().get(0)?
Please import DiskImage
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why KeyManager needs to explicitly be referenced? We allow config contexts that don't start with the defaults?
This block looks the same as in the other constructor. Should it be DRYed out?
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why KeyName was chosen to be used to form the KeyName.
Curious why this is not android specific?
Curious why this is not android-support-Android support?
Curious why you are allowed to use non-Android support?
It is better to set it in the constructor.
It is better to use the MetricRegistry for the thread name.
Use a logger here.
TypedId was created for this type of TypedId, not an TypedId. Is this change necessary?
TypedId was created for this type of TypedId, not an TypedId. I think it needs to be changed.
TypedId was created for this type of TypedId, not an TypedId. I think it needs this test to pass.
What happens if there is no notification?
What happens with withButtons?
What happens if there is no notification?
I'm not sure if this is necessary, but the future is completed if the requestManager.onOK is set to true
I'm not sure if this is necessary, but we should make sure that requestManager.buildResponse() is not null
I'm not sure if this is necessary, but we should make sure that requestManager.buildResponse() is not null if status == ProcessingStatus.SUCCESS
I would really hope that we would have constants, too.
is it ok to have this
if we have constants, you should use them also
Assertion failed: <LINK_0>
Assertion should be on the right line
Assertion failed: pageid
Remove this variable
Remove this variable.
Remove this variable?
set the charset to UTF8
use UTF-8
set the charset to UTF-8
I'm always a bit suspicious about using method calls with ternary operator, since Java will invoke the method even if the precondition equals to false
I'm always a bit suspicious about using method call with ternary operator, since Java will invoke the method even if the precondition equals to false
I'm always a bit suspicious about using method calls with ternary operator, since Java will invoke methods on it anyway.
Not sure if using title change is a good idea. 'example.com' is a progress indicator.
Not sure if using title change is a good idea. 'example.com' is a progression.
Not sure if using title change is a good idea to introduce.
inline tEntry
why not use ITimeGraphEntry?
tEntry
Instead of a while loop, what is the point of setting up the index at this point?
Instead of a while loop, what is the point of setting up the index index?
Instead of a while loop, what is the point of setting up the opaqueBlocksBitSet?
the exception is logged and not logged.
the exception is logged twice after the if statement
the exception at this point is logged. I think it is better not to log it at all.
You could avoid the ternary operator here: DatastreamPids originalDs = metadata.getDatastreamObject(ORIGINAL_FILE.getId());
You could avoid the ternary operator here: DatastreamPids originalDs = metadata.getDatastreamObject(ORIGINAL_FILE.getId()); if (originalDs!= null) { return; }
You could avoid the ternary operator here: DatastreamPids originalDs = metadata.getDatastreamObject(ORIGINAL_FILE);
The other test does not have this delay; why is it needed here?
The other test does not have this delay; why is it needed here? I would expect the test to run in the fork() method.
The other tests have this delay; why is it needed here?
You should be able to call onGetVisitTypeResponse(response.body()) and not onGetVisitTypeResponse().
You should be able to call onGetVisitTypeResponse(response.body()) here, for consistency.
You should be able to call onGetVisitTypeResponse(response.body()) here, and have the callbackListener on the next line.
I'd move this to a field on the class rather than do it here.
I'd move this to a field on the class rather than override the method, and do the filtering within the anonymous class field.
I'd move this to a field on the class rather than override the method, and do the filtering based on the header here.
This could be rewritten with something like callExpression.arguments()
This could be rewritten with something like callExpression.arguments().arguments()
Utils.validateArg
I think it would be better to create an enum that contains the "null" element and a string instead of comparing them if null returns.
I think it would be better to create an enum that contains the "null" element and a string instead of comparing them.
I think it would be better to create an enum that contains the "null" element and a string instead of comparing them if null.
Nit: why not use the constant in the beginning of the class?
Nit: Might want to change the variable name to something more meaningful, like "SlaveSlave".
Nit: why not use the constant in FocusTopology instead?
Please go with FQN here as well
Please go with FQN here as well.
Please go with "," here.
This will always be true. It could be extracted out into a method.
This will always be true when the fragment is launched, Since it is no longer used after this change
This will always be true when the fragment is launched, Since it is not in the background, it could be dropped afterwards.
Should we also validate that the table name is a non-empty table?
Should we also validate that we can reuse the table-level property.
inline
this seems like a big change.
this seems like a big function, can we add a function in it?
this seems like a big function, can we add a function in it?
Instead of doing this, you can get the request method once and again just pass it to the HttpRequestHelper.printRequestParameters()
Instead of doing this, you can just pass the requestType to the HttpRequestHelper and call createDefaultString() so that this will be easier to read.
Instead of doing this, you can get the request method once and again use this variable.
This should be warn, not info.
I think we should default to GDC_DEPRECATED. This will be logged with the ability to get a response with version 4 for now.
I think we should default to GDC_DEPRECATED
I'd suggest using a class-level org.apache.kafka.common.utils.Utils.closeQuietly here.
I'd suggest using a.onException(e) here.
I'd suggest using a.onAddress(Protocol.HTTP_1_1.asString()).
This catch-block should be removed
This catch block is quite confusing
This catch-block should be a multi-catch-fail
Cannot the following be more elegant here: java if (key instanceof Variable && (tmp!= null) { transformedConjunctiveFormula.add(Pair.of(key, value))!= null) { transformedConjunctiveFormula.simplify(context); } for (Term p : conjunctiveFormula.equalities()) {... }
Cannot the following be more elegant here: java if (key instanceof Variable && (tmp!= null) { transformedConjunctiveFormula.add(Pair.of(key, value))!= null) { transformedConjunctiveFormula.simplify(context); } for (Term p : conjunctiveFormula.equalities()) {... } }
Should be final.
It would be more readable if MODE_FOR_SEARCH and MODE_FOR_SEARCH are defined as static final, to avoid potential NPE
It would be more readable to use StringBuilder, it is more efficient.
Can you use StringBuilder instead?
Same as above for these objects.
Same as above for these and use.increment.
Same as above for these and use.append.
Please invert the condition and move line 69 to the else block.
Please invert the condition and put the try-with-resource around the progress monitor.
Please invert this
Not sure what this exception means. As it is possible, I do not get anything by checking if the service is null rather than using a boolean value.
Not sure what this exception means. As it is possible, I do not get anything by checking if the service is available?
Not sure what this exception means. As it is possible, I do not get any idea what is the expected behavior.
