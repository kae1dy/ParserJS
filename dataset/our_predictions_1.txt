Is this order guaranteed, ie ls-refs before fetch?
This is really minor, but could you use Path api here? As it will return better error message than File will. giving some context on what is going on...
throw an exception? this is not intended to use.
Here is also that unusual check.
Please remove an excessive space character.
Strings would be better to be stored in a constant
Maybe relate those hardcoded strings to the enum above?
ACCESS_CONSENT_ATTR and INST_ACCESS_CONSENT_ATTR are defined in both SamlConstants and NhincConstants. Remove from NhincConstants.
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Maybe not needed? We don't have to check if a target process definition exists in the source container.
nit: create static variable for this empty set and return that static variable
ERR_DELETE_ERROR, add if there isn't one already
Out of interest why can you not do DecisionTableOrientation.values()?
in what scenario path list will be empty with copy error set to true ?
No need to log here: return binary.getLong();
no need to specify type on RHS
check to make sure notificationUUID is not null
static
Agh code duplication! But I don't see a simple way around it. I was thinking about some fancy Java 8 streaming thing, but it's not trivial.
Seems like there's a spacing issue here, two spaces instead of 4.
do the comparison the other way around
Because it can be called by both focusGained and mouseEnter, sometimes you have two active contexts. Maybe there should be only one?
You don't need this line because of green 31.
Yes, polymorphism is what you want. instanceof generally is a last-resort kind of solution. Here you're in charge of the design so you can easily avoid it by adding another level to your hierarchy.
The responsebody annotation can be removed, because the class is annotated with RestController. suggestion public Promise<CodeSystems> searchByGet(final CodeSystemRestSearch params) {
this.redisTemplate
can't be null?
Why the sub string ?
This filter lead to me to look at the factory again and ask about why/where the exception would be thrown! It seems strange that a factory could NOT return a concrete object.
Should this be String.valueOf or is cnn the way to go?
I think pNode.getClass() doesn't have to be in the loop, you can move to above and return empty is the condition is true
See above about checking the labels
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Make this a typed exception (e.g. PlatformServicesException)
Why does this need to be ordered by the synthetic primary key?
Was seconds an intentional omission here?
Hash code
Please store these values in a static variable, such as ASSISTANT_USERNAME :smile:
no need to create a set here..
Maybe it's just me, but I would find a simple if-else clause more readable.
fail
null or empty list?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
can you pull this from a static string?
can be simplier: showing empty array even if the value is null is not really a big deal imo. Also, toString are usually only used for logger..
recordCount++; doesn't work?
Should use StatusHandler.log() instead
Could you check for null or empty? Via StringUtils.isBlank
rm 99
Same concern here. true looks wrong.
i would split this line into two for better readability. also gameUser.getAchievements() could be puted to variable
@Serranya The same here. See above.
2xx
You should use ThreadContext.putAll() here.
I think it might be easier to create a list and compare that?
same as above... why not use simple if/else here?
For readability sake, can these two increments use the same atomic method call?
You can inject the header variable in this class too, to avoid dealing with static methods.
Immutable?
Please use networkClusters instead of getNetworkClusterList().getItems()
so for IPv6 hosts when a machine is cloned this is going to break?
I continue to think that **aifc** should to be here...
SetConfigurationObject should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
Is there a reason not to use Util.TOLERANCE?
This could be null, we should probably handle this if the JIRA api changes again
I don't see a test for this new method
More accurate error message
would this be called often, and would the list copy be expensive?
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
Add check that non-null
if (realm != null) maybe - just to be safe.
final
minor: don't need this. qualifiers
bad name of method <LINK_0>
Add a message. Without it, you just get a NullPointerException with no message. ie. "'containerName' cannot be null." Same with another usages of this.
Seems like the previous tests should also assert on the length?
I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon
fileNameBytes is interpreted according to platform encoding. Give it a StandardCharsets.UTF_8 to pin it down.
Checking for test mode is fine, but maybe we should do it when this method is called, rather than in here -- the environment it's run in doesn't seem like a concern of this class.
And this change should be reverted as well.
This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though running == false. I think the only safe place to do the check is after creating the spliterator.
Is this really sufficient to test your WCheckBoxWebElement? One check box is sufficient if it is exposed through a getter so the tests can set properties on it.
We should validate that's non-null (to fail sooner).
This should return an immutable collection.
Do we want to use the platform's default charset when we read this from the database? I suggest we use a fix encoding here like UTF-8? suggestion return new String(licenseResource.getBytes(java.nio.charset.StandardCharsets.UTF_8));
If the code fails to close in, it will never try to close out
I guess this will crash as well if getCompatibleOperatingSystems() returns null.
I keep seeing these checks everywhere that provider is not in SOCIAL_PROVIDERS. I think a positive assertion would be better. Like GENERIC_PROVIDERS.contaains(providerid)
You need to check that conceptUuid is not null and blank
+ desc
I think this should be headers.get(name).
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
Do we really want to move this from trace to debug?
@apc999 This needs to be public or reflection will not work
No need to use ConcurrentMap.
Can this method return void instead? I feel it's a bit funny to return the same thing we just provided as input.
Why give relayType its own variable and rcIndex and rcIntern not? And is it safe to parse a String to an Int without a try / catch?
style nit: we don't use braces around single line blocks
is DebugLogger.INSTANCE.w a sneaky way of calling the logger even when logging is disabled?
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
With these changes, the test should fail as no exception is thrown anymore. The only reason this still passes is because there is no fail call before the catch block. Can you adapt the test to make sure it tests what was tested before?
throw an assertion here, i should probably do that in my code as well
Constructors can call other constructors in Java, so this should also work:  this(name, signature, ImmutableList.of())
In the plugin.xml, you said TmfTraceStub and now you make the check for CtfTmfTraceStub, that is not coherent (even though I think it will fail elegantly).
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Unknown file name and known line number? Should that be an error?
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
We don't need to minus LOCAL_TZ offset for TimestampData, the millis is already an epoch milliseconds.
Would it make sense to add something this.caches.clear() to the stop ?
Preferably have one call the other?
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
Could we consolidate these catch clauses? Or is HornetQException a RuntimeException?
I see a problem with this error - user doesn't know where the expected type comes from (it is already added from other task).
Do a detection.  if (e instanceof RuntimeException) { throw (RuntimeException) e; } else { throw new RuntimeException(e) }
Is it the same as this?  java final StringBuilder sb = padding(element, length - back.length()).append(back);
does this needs to also do a null check for payload before assigning a new reference ?
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
<LINK_0>
why the new line?
I'd rather toLowerCase() is applied after substring(), not before.
Use MethodType.DERIVATIVE.getCode() and MethodType.MAINTENANCE.getCode()
Space before {
studentsWhoRespond -> studentsWhoResponded
let's call it updateCodeMinings() instead.
We should avoid using Java8 for issues which could be backported in 2.4.
kind of curious what these magic numbers are
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
Does this mean that new null handling unconditionally adds overhead in groupBy query processing?
This null check should be done in line 274
don't need optional, just use ImmutableSet.of(ports.get(getNodeType()) should work
This is basically a guaranteed crash right? To be avoided at all costs, it's just making future work. A toast and a fall back to the note editor or anything is better than throwing a RuntimeException if we can avoid it
Lots of unnecessary this. qualifiers.
The return statement can be simplified return (currentTime - lastHealthCheck) >= minInterval;
getParent() can return null
Simple for-each?
This check needs to be done in hasMore(), not nextRow(). hasMore() can block, nextRow technically cannot and just because there is another from hasMore() doesn't mean that it will be within the minTime.
Please close client at the end.
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
Just return data.
Let's do return fDetailedLoad; even if it is always null for now
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
may be it is going to be more obvious to have dedicated variable for that? 'boolean predefinedSamplesCount' instead of 'totalSamplesRequested != -1' ?
Same as above - log or throw the weird state.
To be safe, should check gerritTrigger.getJob() != null first.
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
fileName seems a bit redundant - why not do this in a single line? File file = new File(baseDir + "/src/main/resources/bundles/AppErrors.properties");
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
throw exception
Geometry is comparable?
also check this
Assert.notNull(expiry,..) checking might make sense here
we should not throw an exception here, simply ignore
<LINK_0>
Question: Should not we add braces to this statement?
Whoops, this needs to be the other way round (the first block is for ExecutionException and the second is for InterruptedException)!
Please use curly braces for conditionals
Could you add an assertion on one of the associated props? Just to be sure...
As [mentioned](<LINK_0> in #408, this variable should be renamed to "args" to be more descriptive.
add message to log
@apc999 This needs to be public or reflection will not work
Any reason in particular that it shouldn't give the effect to players?
static import
Looks like validation result is ignored. Let's wrap it with Assert.assertTrue(). Also constants on rows 115 and 118 should be changed to long (0 -> 0L and 1 -> 1L accordingly).
Sorry forgot to mention to change the read to access here too
is this required ?
please add new HelpTag and HashName (as in StorageListModel)
suggestion processInstanceIds.forEach(processInstanceId -> {  You dont need to use _.stream_ to access _forEach_
This should check to make sure that notificationUUID is not null before attempting to delete it.
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
You could instead have a storeTTL option taking a string and parsed using DurationUtils, for more readable config. Actually I see other places already using storeTTL and using that so something is inconsistent.
Per IRL, I meant to say uploadApiBase. This is fine too, but unrelated.
Please use the Spring's Asserts for that, for consistency with rest of codebase
Please add a check Objects.requireNonNull(supplier, "supplier is null");
don't catch, but instead allow the ExceptionMapper to handle it
we never use NULL, it is a bad practice in general.
don't forget default case
The try-catch surounding this can be replaced with JUnits [ExpectedException](<LINK_0> rule. It reads a bit nicer.
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Just return checkNotNull(id, "id").split("/");
Consider adding null check here.
Use org.ovirt.engine.core.compat.StringHelper.isNullOrEmpty(String)
Do you need the fully qualified class name here?
Oh yuck. ;)
protected instead of package protected
Why we removed final?
rename to contribution
Likewise don't need the if statement since the optional value will return empty.
Please use TIME_FORMAT instead of "HH:mm:ss"
nit: use SUBJECT
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
check name?
Have you intentionally omitted index check?
No need to use UriBuilder
return tags;
I would not call the leaderContender under the lock because of the risk of introducing potential deadlocks.
Asserting the actual message isn't a good idea because this could be localised or message changed which would break the test.
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
you can actually use the returned boolean value to nullify astroDiscoveryJob and print the log.
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
agentDisconnect also sets this state.
ImmutableSet.copyOf(Iterables.filter(...)) ?
Can this happen ?
you should have here setSucceeded(true) IIRC.
Mid return may worsen readability
The "Name" class implements correctly the "equals" method, so you can do just this: return SCHEMA_ENUMS.contains(type.getName());
Why decryption is excluded?
assertThat(element).hasTotalSize(6)
having wallClock = 4 for atlasTs = 4 is potentially confusing (ditto below with 6/6).
Because there is only one argument, we can pass workerMetrics instead of an object array.
Value nor envVar wont be ever null, but empty strings, so that check will be valuable
super.init() method never throw an exception.
Hi, @nvazquez. I see a little mistake in you test, you are testing if the method has inserted a tag or not, I think that this test needs to verify if the template inserted in the templateResponse is the same that you has passed in the first param of the method. You can do it checking if each variable in both templates are equals. The same problem in the other tests cases. Ty.
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
From <LINK_0> I still think that a declarative programming approach with streams is a much more elegant implementation than this.
Why change the order? You normally stop in opposite order to creation. So, if you create embedded cache manager first and then the server, you normally stop server first, then the cache manager.
does this need to be a class member?
please add setSoftLimitInterval() setter and use it.
@fanifieiev Let's put this in a constant.
We get to rename this variable to prefix it with is I guess
should be false unless one of the vm's disks has true for this
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
Is this a good practice? Casting to an abstract class? it may be better to have an interface AccessControl and AbstractAccessControl then implements that interface... but that way you program against interfaces which seems cleaner to me.
Please remember this ctor changed.
Would be simpler as: return Arrays.asList(Action.RELOAD);
I realize that the test case was just moved, but maybe for a separate commit or a follow up: Maybe the error could also give a hint on what would be correct. E.g. StringType can only have a single parameter value, received: ... Also in the other error messages. E.g. with 0 it could point out that it must be > 0.
user.get() can return null
value is redundant, just return right away.
Duplicate in both createSubject and createEvidenceSubject methods. Consider to refactoring into helper method.
Shouldn't this be a field so we don't have to create one each time
On START_DATE, the discount factor for start date should be 1.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
this.lockVerbs (like below)
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
Assuming this is noting completion of initialization, perhaps "Finished initialization."
Let's re-word this to a forced shutdown
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
Pretty sure this is also supposed to just be the localization key.
You could simply do super.setClazz(CommonLog.class)... You don't need to have a vaeiable pojoClass.
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Doesn't List as a Collection have a defined method to check whether it's empty or not?
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
Could you check for null or empty? Via StringUtils.isBlank
Can lease.getStartingAllowedRequests() every equal zero? Might want to check for that.
Verify the injector has been set before using the delegate here
Please remove this line
Is it the 'native snappy library' that is missing or the java-snappy jar?
addPermissions means you added a permission, but it doesn't mean that no restart is needed... unless I'm missing something here.
I think this should be > 0 since a value list item of 1=One does not work.
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
Pull this into a static final variable
Needs to be in finally - we might get interrupted.
I would put the return 0L here. This is probably the one and only place where you do not propagate the exception
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
same as above with the actionBarWrapper
please use java.util.Objects.toString(username, "") instead
I haven't tested yet but the code seems ok
Can this be private, or is there another use case for default attribute outside the builder's call?
To make the tests more resilient to future changes, please pick values that are unlikely to ever be the actual defaults. For example 234MB and 11MB.
Removing the interceptors removes logging.
Here and below: previously the code used only one table lookup operation, not it performs two lookups. Please consider to use get(name) and check the value to decide if it is illegal or not.
Use this.key
why exit here ?
not sure why this field is public
> Use emoveCallbacksAndMessages(null) to remove all the messages. > Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
I'd recommend using <LINK_0>
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
different value 50 versus 1. Is that intended?
why do we have a ; here?
Probably makes sense to move this up too.
are spaces OK in namespace strings?
fos can be inside try ()
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Is this reload really necessary?
Do you have time for this? We talked about it on Slack.
probably don't want to keep filling this map up as we browse around. could just use getOrDefault?
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
Should this refer to a platform-relative constant?
use use java.util.Objects
Could you update this method to include "AbfsPerfInfo" introduced by HADOOP-16612?
super.init() method never throw an exception.
I feel like we should be able to take out a lot of these nullity checks. Let's keep this in mind for a future refactor.
This cycle has very confusing brackets. Could you please add brackets to if and properly tabulate the last bracket?
This one is already done on line 816. Do we need it again here?
Likewise.
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
what happens if you call this several times? It will recreate again and again the asked number of threads. You should have some flag to specify that it's already started no?
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
Aren't there any chance that super.inputStream() **is** already PushbackInputStream, so, we don't need to wrap at all?
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
Can this be private, or is there another use case for default attribute outside the builder's call?
merge else if?
I think it is done on purpose to avoid auto boxing/unboxing.
no!
You should also update the error message in order to tell users that this option can be used in order to switch the duplicate field validation off.
Done, it looks like the change was not included in patchset1.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Ik. Maven has logging facilities. We should use them.
one more method where it can take file location of properties would be good.
close streams
Needs some sort of assert to show it succeeded
You have yo use compareAndSet
Why going for semantic here ??
minor, is it method scope for Visible For Testing? If not please change it to private.
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
This should always be read from the configs.
Why is this removed?
Could we prefer a proper logger instead of System.x - we already have a logback.xml in the module.
Assert.areNull
You can remove the inheritance from translator and make this method static. So you won't need to create any instances of EnumTranslator.
We can't do this - breaking change for anyone that has subclassed and implemented destroy(). I suggest we use // NOSONAR TODO: remove throws in 5.2, which removing it from our subclasses.
suggestion
should be named resource
This needs to be changed to support locked stream syntax now.
"else if" maybe?
should be logged only once, not for each block (spooling is either enabled or disabled).
This is not necessary.
It's safer to call getProperty("replicatorFactor", DEFAULT_REP_FACTOR). You should validate the arguments as well.
What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run.
This could be entirely done as a stream.
Also added a try with resources here.
How about:  int size = Math.min(b.height, b.width); setMinimumSize(new Dimension(s, s)); setPreferredSize(new Dimension(s, s)); setMaximumSize(new Dimension(s, s));
Please add the 'can not recover' back? It clearly tells why we must abort the region server.
given/ execute/ assert
Not worth debugging for this QS
hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm! so we cannot validate this on gwt, but I do want to validate it at core. can we have something conditional? if the isAssignableFrom works then perform validation else not? when gwt will not use these classes any more we can just remove the conditional.
Don't we have to say that this is uniqueId JDBC?
Thanks for this clean-up throughout the code! I should probably start enforcing fcrepo4 code style rules sooner rather than later...
One more - this will be 3
is Options.INDEX_ON_THE_FLY the same as Defaults.CREATE_INDEX?
any particular reason why this method doesn't require an IJavaProject ?
This should be 10 << 20 so that the default is 10 MiB. That allows users to specify configuration with standard suffix units e.g.: [merge] inCoreLimit = 10m for a 10 MiB limit.
given that specificity of this SV is exception type I would add the exceptionType in this.
This will add the flag to *all* read-resource operations. I'd rather add it only when necessary as suggested at <LINK_0>
are these setters used anywhere?
this is not thread safe, nodes can be modified while building the subgraph. I suggest to use Lock for reading and writing accordingly instead of synchronized blocks
I'd still prefer to have the operation for generating the 'key' for a muted topic to be a separate function, or even embed it into the Message object. for example:  mutedTopics.add(message.concatStreamAndTopic()); ... // in Message.java private String concatStreamAndTopic() { return getStream().getId() + getSubject(); }
This is now hard to read since it combines two multiline expressions. Please break it up into separate expressions and use suitable variables for each value.
instanceof Dataset is redundant
pull this out into getMockAuthorizer() {return getFileSystem().getAbfsStore.getAuthorizer()}
This will remove description set, please remove.
There is no need to set the local scope reference to null, but if you prefer...
matter of taste, this could also be return this.profileTypeRegistry != null;
Can this be private, or is there another use case for default attribute outside the builder's call?
Is value == null a valid case here?
nit: Same here. Leave the checks in the switch and do the assignment at the end: this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
Why uppercase fs?
I would just delete the version check from master. The logic is very simple and unlikely to cause clashes that are hard to resolve even in the unlikely event of someone adding another field in the lifetime of 7.x.
use return ... ? ... : ...?
A little sanitization here would make a lot of sense, if nothing else make sure no ' ?
[nit] There is also a cleaner approach using Guava:  java return Enums.getIfPresent(LoadbalancerAlgorithm.class, value).or(UNRECOGNIZED);
Can the current method be executed on an other thread than the UI thread ? The layout command might need to get the figure info wth ui thread access.
All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);
Use constants
the workspaceitem needs to be deleted
final?
You may also want a test case for a search value that is non-blank but invalid.
Can be reduced to throws IOException.
Should we add null check?
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
I've always been slightly confused by this - is this only used for the pause before we start sweep? If so, it might be better to defined the backoff time you're adding completely separately from the definition here, unless it should always be 5x this one.
As there's no extra handling when an IndexOutOfBoundsException is caught, both old and new code behaves the same way: any exception thrown by logicalPages.get( page ) will always be thrown back! As so, the try-catch is dispensable and it's best to leave the code as it was.
get rid of "..." not enterprisy!
move this line before above line, After super.cleanup method couldn't do any of the server requests.
You should use ThreadContext.putAll() here.
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
Maybe let the stop() method throw the exception instead of catching and printing?
:smile: We prefer to use fail("BeanDefinitionStoreException expeted.") within try...catch
You can use try with resources here so the Input stream is closed automatically.
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
.endsWith("'sParty") has an implicit semantical meaning and therefore should be put into a dedicated method. I'd guess something like boolean isOwnPartiesChannel(String name) But just comparing the end of the name sounds really... odd?
Delegate to isNonCodedDrug() when making the check.
need to remove this print or convert it to log stmt
Config class have constant defined for default config file name
Can you please compare something else than integers (String will be ok)? Silly code change in assert method can break its logic but pass this test because both index and value are 2 :)
This needs an @Override annotation.
consider to inline uris
Nitpick: startingCounter?
Type casting again.
Could this potentially be shortened? return acceptHeader.length() > BROWSER_ACCEPT_MAX_LENGTH ? DEFAULT_BROWSER_ACCEPT_HEADER : acceptHeader;
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
We should still be able to set the dialog's title (?) In this case, title is always dynamic as it comes from UI plugin API function call.
rename to contribution
Why do we have this constructor?
nit: language is not supported: %s ?
can this just be boolean instead of Boolean?
.hasSize(), 2
Do we need to null check event.post here?
Is this signum call really needed here? compareTo should already return the correct value.
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
getFullName()
Don't need the hostAffinityEnabled check here. You can assume standbyContainer is present only when host-affinity is enabled.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
close already done in Util.read(..)
Now this method does not do as it's named...
nit, just make this real instead of mocking i.e. () -> FALLBACK_INT
Wouldn't it be nice to check the path was observablePath rather than _any_ path?
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
Check the env variable before returning true.
We should close the FileOutputStream, relying on finalizers is very finicky
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Are you sure we need that condition? Are you able to cover it by test case? The null-test was not present before and I can't see any test related to that.
You can use GenericMath.DBL_EPSILON here.
Why is this removed?
DEFAULT_HTTP_TIMEOUT?
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
Let's use debug level instead of info.
Instead of repeating the addition assign it to a value on the stack.
Move the logic to configAccessor.
Nitpicking, but I'd prefer creating the builder with  org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder(hotRodServer);  and then setting the marshalling. Same in RemoteStoreMixedAccessTest
There is no call to this method outside TableManager, shouldn't we change it to private?
Magic number <LINK_0> Try to use a constant for the timeout. Review the constants in the project.
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
Don't we need to return something like -1 in the null case (i.e. when the type is not in-house one)?
Why is there a fromByteArray method? Why not call the constructor directly?
For each?
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
this("Safety Command")
You could remove method("POST") as you set the HTTP method on create
Same here, no need a transaction
HQL/JP-QL
Could you please use DecisionTableInputType.XLSX
Optional.ofNullable could be used?
Ingest modules need to throw IngestModuleException if there is an error in startUp, with a user readable exception message, since it is displayed to the user. You need to wrap the NoCurrentCaseException in an IngestModuleException and throw, not log here.
"notation".equals(resource.getURI().fileExtension()) to avoid potential NPEs.
Encapsulate this here. Should be returning a MapView here.
we need a gauge metric here to ensure the thread is running
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
-1. This means input does not get read.
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
suggestion return Arrays.toString(value);
I would suggest using the related constant instead.
name could be more descriptive
Returning a class instance _or_ a null? This calls for an [Optional](<LINK_0>!
could uh, use checkState(false, "") instead of a lambda ;)
Do we need some kind of synchronization here, or will next() never be concurrently called from two separate threads?
If you remove the condition, the retry analyzer instance will never be null. Better: DisabledRetryAnalyzer should be the default value if clazz == null unless you think the null value is important.
This could be confusing here. How the user know the all fields?
@drcrallen I tried a hadoop batch ingestion job with this patch applied, and the task didn't pick up my hadoop-client jars. Passing in the directory:  new URL[]{extension.toURL()}  doesn't seem to get the jars picked up, I had to change the URLClassLoader creation back to the original implementation with a url for each file to get the task to proceed.
Please remove an excessive space character.
Added because?
To defend against catastrophes from bad future refactorings, I would recommend extracting a protected method for the computer's log directory, to make it clear that what you are deleting is specific to this computer only.
seems like synchonized is not needed here, given increment/decrement already protect
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
Should we use UTF-8 instead of default character setting?
Is it really worth checking before setting it?
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree)  return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
suggestion if (this.currentTask != null) checkAndRethrow();
How does this work for (ridiculous) timezones with 30 or 45 minute offsets form UTC?
This method can be static, as all the methods it calls.
Shall Alter database to add source_of_replication DB property and see if Dump succeed afterwards.
final
Pretty minor but would you mind adding some parentheses around the arithmetic? :) Is it possible to have a divide by zero error?
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
minor: don't need this. qualifiers
The two methods above are the same except for the first line...perhaps reuse the code instead?
Parameter should be a string instead and be called label
Braces on following line
If this should never happen throw an IllegalArgumentException instead.
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
I believe this whole catch block can be removed. The standard WaitUntil handling will be sufficient I believe.
We don't need to use System.out.println() here. These two lines should be assertTrue("Expecting: " + expected + ", got: " + e, e.getMessage().contains(expected));.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
you could be more specific and check instance of Function0 maybe?
For loop?
After checking how MimeBodyPart is implemented, it might make sense to tweak this to:  java return String.format("%s; charset=%s", mimeType, MimeUtility.quote(charset, HeaderTokenizer.MIME));
style nit: we don't use braces around single line blocks
Apply changes similar to setVisibility.
A message might be helpful
you need call addColorSettingsListener on the new instance.
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
Just in case, please wrap with Collections.unmodifiableCollection()
Define "data-agent-conf.xml" as a constant
Did you intentionally ignore the patientProgram parameter?
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
log.trace if at all
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
can just be return pattern.matcher(value).matches();
Use logging framework instead of printing to stdout
This updates all gauges when any of these gauge is visited. It'll be better to override getValue() instead, and only calculate the percentile for the gauge currently being visited.
Be explicit about e.getMessage here? (and perhaps enclose it in double-quotes)
Padding should probably be extracted in a separate method. (I could also argue that getting the int value could be another method, but I sense that there might be some opposition there).
This can just be catch Exception.
suggestion return Optional.ofNullable(getLhsType()).map(s -> s.getTypeImage() + ".").orElseGet(() -> Optional.ofNullable(getAmbiguousLhs()).map(s -> s.getName() + ".").orElse("")) + getImage();  and avoid computing the ambigousName unless necessary
An optional of not null is a bit painful. Use another constraint perhaps? Do we have one test on the payload business btw. (applying it to the wrapper)?
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
Why this change?
This must be unique, as it is the ID jclouds will try to find when calling the computeService.getImage(id) method. Is this label unique?
Something like this.
several style nits: spaces before {, before variable names, between functions, etc.
suggestion throw new IOException(MESSAGE, (Exception) DummyClassLoader.apply(TestCallable.class));
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
Move this validation to PluginProfileService.
side note to bringing in this dep, installing this module would also likely start up a number of pollers/db connections/zk connections/etc which we don't want
LinkedHashMap please <LINK_0>
should be setSucceeded(true)
I would replace this by System.nanos() instead of doing a call to nanos. To prevent running out of inlinining budget.
Same here.. we should not have these checks here.
Why is it public?
Should return ReadOnlyArray.
ImageData for current image needs to be updated in the array?
I would prefer to move this line in the if branch, so it is more clear, "return element" is done if a managed provider is available only
I think only one impassable entity should be allowed on a Square. Exception otherwise.
you have to add a canDoAction message if you fail canDoAction
Program to interface, not to implementation - please change return type to Map<String, Object>
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
there is Long.hashCode(long value) method.
can it be made in one line?
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
is logics correct here?
ChannelClosed needs to be added to (though not strictly necessary)
can move ListVersionView object construction in ViewFactory? this will replace publicBodiesConfiguration dependency by ViewFactory to make it consistent with other resources.
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
rename to child or childItem
That is not clear, why do we have "Save" is not adding alarm item is enough? Actually, it is saved in Realm but not scheduled in Alarm manager?
should we use ObjectUtils.nullSafeEquals here as well?
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
Move this else if just after the } above
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
Is there any particular reason to call getMuteReason instead of just checking the value of muteReason directly?
Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
This is a test for the userRepository in my opinion and should not be here.
super() can be spared here.
I think it should return Array here.
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Shouldn't this message be changed to "Should be 500"?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
nit: param doesn't need final
I want to method accessor to be package private :eyes:
Add log.info "connecting to ATSD at host:port"
rename to comply java standard name convention. validateEmail
70-75: extract method (see following methods)
Maybe wrap in an immutable map.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Current code doesn't detect port 8080 is used by my local EAP. The only way it works for me is if it's implemented as  java try (Socket socket = new Socket("localhost", port)){ return true; } catch (IOException e) { return false; }
Why is this still using the Id?
Unfortunately, you cannot delete this method. This is how we initialize our Indices when they are created via reflection in the AccumuloRyaDAO.
rename
Should we return immutable list here?
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
this should be config.get("path-style-access", boolean.class, false)
This method should first attempt to get it's result from a file stub.
Please add ioe to the exception.
Ahhh, the speaking check is here. Calling speakNames() to have to sometimes not speak names is confusing and wastes a method call. I think we should just pass the boolean into presentation manager.
This doesn't honor the contract of an iterator's remove. In fact, i'm not sure you can support this atomically with only a single file.
Static string constants
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
Should have a space after add
I'm wondering why we even need this class; can we not simply add a boolean property to the base class called "appendPartitionId" ? Also, the ticket description says "If SingleFileOutputOperator is partitioned into **more than one** physical instances then it should append partitionId to file name" (my emphasis), I don't see any check for that condition before appending the partition id.
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
As iirc a HC can not spontaneously become a DC, I wonder if we could cache this data. Otoh, this is a relatively light-weight call and not done often, so probably does not warrant the hassle of cache invalidation checks.
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
collect to a set that can preserve order?
Once again, just use getMonth(calendar), which embeds the knowledge of the +1 difference in its body. DRY.
CheckReturnValue?
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Optional.map
remove
Add here if (outlinePage != null) { outlinePage.setSelection(new StructuredSelection(selected)); } to make the normal outline page follow the selection in the quick outline.
Is there a subclass? I'd like to see these protected methods be private if possible.
Should check if the Counterparty that should be updated belongs to the logged AppUser
Add not-null check here.
Why change the name the property? Accident due to mass refactor/rename with IDE?
Let's use the same logger we use for the rest of Baragon rather than System.out, for example <LINK_0>
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
immutable copy!
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Better to return "";.
Is it really filter name?
Currently we know that close doesn't throw, but just to make the code future proof we can use guava Closer here to make sure that both readers get closed.
lockRefreshToken should be set to Optional.empty() here, otherwise isHeld() will still return true. There should be a test for this.
We don't need this, the ConfigSaved would handle this already.
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_1>
Missing codes.
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
The binding shouldn't refer to the currently selected entry because this might change in the future and then the binding needs to be reevaluated. The following should work suggestion ObjectBinding<BibEntry> entry = Bindings.valueAt(selectedEntries, 0); return Bindings.createBooleanBinding(() -> { if (entry.get() == null) return false; else return entry.get().getFields().stream().anyMatch(fields::contains); }, entry, entry.getFieldsObserable());
Can you avoid duplicate code here? (PreferenceManager.getDefaultSharedPreferences)
We are always in a case of an AbstractDiagramElementContainerEditPart host here?
EchoParametersDao.getEchoParameters() already returns a list.
We can use guava Closer to make sure we close all of these clients (just in case if one of them throws a runtime exception in the middle of the loop)
This might throw exception
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
Does it still make sense to use forkJoinPool? The tiles are no longer downloaded at this point, so it would add an overhead to run this in parallel.
What you should be sending is the cluster compatibility version, not a constant version.. You could send the host's version but that would be confusing to the users. The norm in oVirt is to restrict version specific features by either cluster or DC - since this is clearly related to cluster (and not related to storage), the restriction should be by cluster level.
Lists obtained from a message are immutable. No need for extra copying.
I don't see where we handle HibernernateException.
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
suggestion return new SearchHitsImpl<String>(hits.size(), TotalHitsRelation.EQUAL_TO, 0, "1234", hits, null);
Could use assertEquals?
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Shouldn't this be set to false?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
secretLabels = Arrays.stream(labels) .map(l -> l.split("=", 2)) .collect(Collectors.toMap(p -> p[0], p -> p.length == 1 ? "" : p[1]));  ?
Fair enough. I don't think it was meant as a cost saving thing, just to make it easier to understand when something did or did not have caught-up clients. If you find this logic easier to follow, go for it
should be VOT.Storage
No need for the *31 here.
nit: Maybe more explicit:  Only function definition classes (classes annotated with @ScalarFunction) can define SQL functions via non-static java function. Function set classes can only define SQL functions via static java functions. Thus constructor in function set classes is used to define SQL functions.
You can use CollectionUtils.toImmutableList
Couple more static imports here?
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Should be ClassNotFoundException. Catching all exceptions and disposing them may miss unexpected exceptions.
Can StringUtils.fromUtf8 be used?
Methods in Preconditions should be imported statically
StringPool.EMPTY instead
Why are you looping here? Can you give a use-case?
Do we really want to always assume Latin-1?
Why don't we make inDegrees to ConcurrentHashMap also?
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
setSelection takes an ISelection, no need to cast what you get from the viewer. you also do not need a local variable
I am still in favor of removing this static. I don't think its necessary. I think if tserver wants to keep one instance, then it should keep a reference to it. All the current static stuff we have is troublesome and we would like to move away from it. Could rename this method to newInstance if you drop the static.
This should be part of the try-with-resources block.
Item dropped should be a hopper
is this still needed?
The this. in getters are unnecessary too.
assertTrue or assertFalse but never equals. Also add a message so if it fails you know what has failed.
Missing types
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
Single or double pipe?
Can we make logger a private static final
what does compare and hascode mean for datanode if they have different ssl ports?
why this change?
Currently we don't have PERUNOBSERVER role assignable by config to specific credentials (unlike perun admin). This mean, we will always have User, related to this role. So anywhere, check on SELF (without specifying user or where passed user is only own) will let PERUNOBSERVER pass too. Only if it would filter result, we would have to separate them. What do you think @stavamichal @licehammer @martin-kuba ? Will we need PERUNOBSERVER role for accounts without User in Perun or not ? I suppose not, it is always safer to have account with contact info etc.
type might not always be a Class. If the API method returns List<User> this will be a ParamterizedType which isn't not a Class.
should be debug and consider moving logging to checkData()
please keep style changes separate from PRs (or better just don't create them at all)
Please extract this string
static imports
does this have to be a list or can it be an iterable?
innerInterfaceOrClass checks parentType, but in line 236 similar check is performed. They can be merged in one method
createObjectFromMap(name, NAME_TO_FULL_MODULE_NAME); should be the first thing we try. It will be the fastest and the most common scenario. pure createObject(name) should probably be used last when user supplies full package as name. Order of finding module should be, imo: 1) our module map test 2) 3rd party map test 3) full package (or raw) test 4) fail. We can probably discuss skipping 1-2 if given name has a period in it. 3 is only really needed if we don't examine maps for the full package. I don't really see a benefit from doing this.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
What do you think about changing to stripContextPath(request)? So stripContextPath ask for contextPath and requestURI internally.
extension can't be empty or /
I understand the purpose of the change is to make sure we streamline the value change in the class variables to happen as late in time as possible, and issue the notifyDatSetChanged() signal right after that. Can we then enclose these 3 below lines in a synchronized block to make sure these 3 are packed together in an atomic action?
use 'waitForElementByElement(newestVideoDeleteIcon); and use 'waitForElementByElement(deleteConfirmButton); before each click
Are there mandatory parameters which require validation?
This won't invoke the additional interceptors, is that okay?
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
Why don't we make inDegrees to ConcurrentHashMap also?
Hey @oguzkocer , should this array include VIEWERS_TABLE as well?
I think it makes sense to use builder and return ImmutableSet...
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
Reads nicely if this is written as if (isBinaryValueAvailable()) {.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.
nit: I'd prefer warn, this is probably not super actionable for us?
Why not create the taskExecutionDAoFactoryBean in the ctor?
if we continue with this convention, please init to true also here
You probably want checkNotNull here - assertNotNull is no op if assertions are disabled resulting in a NPE below, checkNotNull will always fail on null leading to a consistent error message.
can be replaced by List.of
why not an empty map?
Rather than calling run here, make run() call out to a no-args method like this: java public void onClick(View view) { // ... if (id == R.id.button_done) { nextWithEmailAndPassword(); } // ... } // ... @Override public void run() { nextWithEmailAndPassword(); } private voidNextWithEmailAndPassword() { next(mEmail, mPasswordField.getText().toString()); }
Before go through the loop make sure that position and symbol parameters are not null.
What does the magic number 2 mean?
name it github config
Idem this could be handled with an Optional...
Wouldn't this test be more "accurate" if the only thing that changed in each entry was the timestamp (and not the value)?
Call I18N.getString(String) (there are no parameters in the resource messages).
This logic needs updating to handle non-deterministic filters. See latest BooleanSelectiveStreamReader.
I think the annotations should be on separate lines
remove static
Instead of FileHandler, you should use the PropertyConfigurationLayout to save it to a FileWriter.
I believe this line is incorrect and should be removed
hasAnnotatedAllParameters is already checked in the super class, right?
you can either remove else or add pair of curly brackets
Is there a chance of a NPE? could be getFile() null?
@dmzaytsev let's inline this
Add { and }.
Debugging code?
same here for node
return id;
Should be added the Override annotation.
Maybe take the opportunity to set index = null here?
Same as above: I think it is clear enough without the id variable same for below too
I think it will be better to close the other store as well.
Check command and status null.
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
Does TYPICAL_LOG_MESSAGE need to be a local variable? You can hard-code /typicalLogMessage.json here if only used once.
null != settings
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet()
suggestion return new Intent(context, CustomTabsManagerActivity.class);
Should be here ac.stateChangingCheck(); @zlamalp?
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
@Before / @After could overwrite System.out :-P
Which type would be assigned in this case?
You could just use Closeables2.closeQuietly(azureBlob);
The original version is more precise?
reference equality?
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
The %2$s is positional and needs to be adjusted since payload type moved from position 2 to position 4. Or, alternatively keep this the same, but move getQuoteString to the end and use %3$send%3$s above rather than %send%s.
should atleast check o being non-null and instanceof IdentityExtractionFn .
Can we please add limit to the exception message? So it will be much easier to see the problem!
This was purposely catching both checked and runtime exceptions, hence catch of Exception, because if this were to have a fundamental flaw causing a runtime exception it could conceivably kill all sling resource fetches.
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
nit: maybe merge the lines as the formatting looks a bit strange.
@inverno Why public?
can we use sysprop or something for url?
use Long.valueOf() instead of new Long() - always for performance reasons
Is start check needed? Could it be problematic (somehow delay/miss the start when it should be immediate)?
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
Why we return AsyncClient here?
Not sure about coding style, but I wouldn't use an else here ("else after return").
Nit: it is a good practice not to reassign the input parameters so I would change this to something like the following: Map<String, String> mapToUse = (map == null) ? emptyMap() : map; JSONObject pathPartMap = new JSONObject(mapToUse);
How about AM's memory mentioned at Line 111?
the idea of using a builder is a bit off here :-)
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void ...) This avoids extra sync objects (and saves one level of indentation!)
@weisebrazil all indentations should be 4 spaces, not 8.
If environment accepts null, mark it as <code>@CheckForNull</code>
Create date once and use it twice. That way the acceptance time will be the same for both.
From reading this line I'd expect this test to pass. We should probably name this CONFIG_WITH_KEYSPACE_2, or make CONFIG_WITH_KEYSPACE receive KEYSPACE and compare it to KEYSPACE_2.
no braces around single line block
Let's do return fDetailedLoad; even if it is always null for now
using compareAndSet() might be better since you need not execute the rest of the statements if this is already false, right?
To clean up properly, please place the Builder in a try-with-resource block java try (Builder b = new Builder()) { // test }
what about location ? we do not need LocationSerializer ?
Used to be fileSystem.deleteFileOrThrow underneath.
Shouldn't we call removePropertyChangeListener, BEFORE we call doEdit, since doEdit will change the current object?
I think we should at least log this exception here before throwing other one
I believe this method should be getServerMetricConf()
This is a local variable, should be camelCase not fCamelCase
Sort of believe We should have MetricManager in parameter given this case.
log message is about "attach" in the "detach" method. this is misleading.
This is duplicated
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikiPage object/browser info.
Why include the name in the comparison? fullName should be enough.
Check if byte[] b is null.
SHOW+DATABASES? looks strange.....
Same as above, this looks like an error.
targetValues is a List<String> so we don't need to use toString. Could use String.join(", ", targetValues) instead.
events can't be null
Would you mind if we kept our privates on bottom? I'm a class client (reader) of more code than I author, which means the most relevant source is almost always the public API. It's quicker to get to on top since codes read from top to bottom.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
should be edit
why don't you just use a node here that does the right thing? There should a node to read outer, no need to duplicate that logic here, or is it somehow special?
RuntimeException would be sufficient
This change could break people.
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
i would add additional check to make sure we will never make it to more then 100 :)
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Why U don't want to consider id in equals and hashCode ?
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
We don't need to cast to int.
DoubleMath.isMathematicalInteger?
Should be public.
In fact, I don't think it's a good idea to allocate a Long. This function should be fast. Thus, a three branch if seems to be the solution. if (a < b) ... else if (a > b) ... else ... The domain trick works to avoid the "sign" hack.
throw exception
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
System.out.format instead?
true=>false
I don't think we ever use this method again
I think the code will be easier to understand like that: java Object object = getInstance(); if (object == null) { clazz = getConstructorOrMethod().getDeclaringClass(); } else { clazz = object.getClass(); } ITestOrConfigurationclassAnnotation = getAnnotationFinder().findAnnotation(clazz, annotationClass);
@paulodamaso the braces and return are not needed here
We only set thisReadSequence and mateReadSequence in the ReadHead, right? Why don't we have set(long uuid) for those kmers which aren't ReadHead?
public?
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
Null comparisons can be replaced by UtilMethods.isSet(object)
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
Same as above. this is deprecated and should no longer be used.
reuse getAcceptableTokens()
Replacing "\" does not require regular expression, use replace("\\", "\\\\\\\\") or replace("\\", "\\x5C") instead of replaceAll().
Use getSimpleName instead?
For increasing stability "wait" is better to use than "Assert":  waitUrlStartsWith(testRepo.getHtmlUrl()); } private void waitUrlStartsWith(String expectedUrlPart){ seleniumWebDriverHelper.waitSuccessCondition(driver -> seleniumWebDriver.getCurrentUrl().startsWith(expectedUrlPart)); }
could this hide bugs? Would it make sense to throw an exception or simply remove the check? Also because 0x0 is a valid code point this makes this return value a bit ambiguous. I'd be in favor of just accessing the array and let the JVM throw an error if this is possible.
Hum seems we are already setting this listener
nit: you can merge both lines above as checkNotNull will return the given argument
What do you guys think about setting this method to Evolving, at least for one release.
remove 'driver' parameter (yes, a know you didn't write this line, but please change it :) )
IMO it's better to use different values, e.g. 0 and 1 to be sure, for example, that the "delegated" method is not simply using the first parameter twice...
use execute i mentioned above
Looks like both XmlTest and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
Or even better, this.mName = Objects.requireNonNull(name);. To be check everywhere else.
Why do we print a secret systemUserPassword here?
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
Item dropped should be a hopper
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
Why do we use iterators? I know the base class does, but why in the first place?
Why the change? This is going to cause a memory leak if the SaveSmartLock fragment is rotated since it's a setRetainInstance(true).
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Is this already protected by a lock?
I would suggest that it checks the count of the entries to see if it increases one after the recovery happens.
If createParams should always have commonParams and commonServerParams, why not just define it that way to start with? And I think you could make the collection a static final variable at the class level.
@cvrebert maybe MkIssueEvents.class.cast(?
Remove useless assert
don't use finalize, it's a bad practice
This check will be needed in case of every single widget button. If so it would be better to create our own WidgetButton class that will extend com.google.android.material.button.MaterialButton (then you can use it in your layout file). In such a class we can then override:  @Override public boolean performClick() { if (MultiClickGuard.allowClick(getClass().getName())) { return super.performClick(); } else { return false; } }  what do you think about this approach?
use the constant defined earlier (moreover, aren't jdo connection options available from some sort of options class)
Do we want to include data= (since it's required) similar to how we include connection= for SQL? It would also be nice if the cursor was placed at the end of data= (as we do for connection=)
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
Can we rename from exonCollection to something more appropriate, like targetCollection?
@ILikeToNguyen Why the change in visibility here?
can you explain why this change ?
can't we just store filename = String.format("%s.%s", filenameBase, "values"); and not have makeFilename called in multiple places?
It's good practice to use getters (like getPerunBl()) than directly accessing attributes.
- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
I am a bit confused that this check will be called on almost every line of code.
shouldn't we return a new or immutable copy of our internal list? just returning the list allows plugins to fully modify the list. @WonderCsabo wdyt?
Is there a need to have log.debug within transaction scope?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
please decrease severity to "debug"
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
public?
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
I would add a check here: if the ID contains the suffix, throw an IllegalStateException or InvalidParameterException, otherwise, there's a chance that you'll have an ID like abc-client-client, which is never appropriate.
not all listener
@erikdw MESOS_SANDBOX is set by Mesos correct? Wondering if we should override System.getenv("MESOS_SANDBOX") with logdir only if storm.log.dir is configured?
Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.
Lol! You're going to remove that, right :)
This can be java return valueOf(value.toUpperCase(ENGLISH));
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
Maybe for cases like this where the list is only consumed once it would make sense to add a mapLazy that is based on something like this: java static class LazyMapList<I, O> extends AbstractList<O> { private final List<I> list; private final Function<? super I, ? extends O> mapper; public LazyMapList(List<I> list, Function<? super I, ? extends O> mapper) { this.list = list; this.mapper = mapper; } @Override public O get(int index) { return mapper.apply(list.get(index)); } @Override public int size() { return list.size(); } }
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
I think we need to check validation of the state transition diagram. Let's handle it in a separate issue. Please create an issue for this.
Are consecutive reloads necessary or will be one reload at the end sufficient?
These 2 conditions can be merged into 1 condition
upt.unifyGraph(graph) is double code. Better use this structure: new ReferencePositionTraverser(reference).referenceMapGraph(graph);. The graph = isn't needed.
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
s/policies/policy
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Should we break the for-loop early if the condition is not met?
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.
entry
delete
directly return
Do we need to make sure these file names are also Windows-compatible? If so, we should include a few more characters to the list. - Linux/Unix: / (forward slash) - Windows: < (less than) > (greater than) : (colon - sometimes works, but is actually NTFS Alternate Data Streams) " (double quote) / (forward slash) \ (backslash) | (vertical bar or pipe) ? ( question mark) * (asterisk)
Default should be false
return Promise just to symmetric with start()...
This method is no longer waiting for the refresh operation to complete. Not sure if that is important for the test flow or not.
This will probably be permanently unsupported.
should return false if the validation fails
The operator should be && not ||
please use (1 << priority) instead of priority + 1
looking at the gson code base, remove also could return null if element not exists hence we might want to guard aganist NPE here as well.
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
These implementations are fine, but I wonder if the code wouldn't become a bit simpler if the defaults were stored as String values, and instead of the parameters.containsKey(String) you would do something like: return EventLogCategory.fromValue(Helpers.getString(parameters, PlatformSmartmeteringKeys.EVENT_TYPE, DEFAULT_EVENT_LOG_CATEGORY)); as a one-liner.
inUse is set twice in this constructor
remoteVolumeName passed twice. I feel remoteHost to be passed as second arg
Can you just change the return type of this method?
Just want to double check that the following null check is correct:  if (mScrollDirectionListener != null) { mDetector.onTouchEvent(event); }  I think yes, since mDetector is always not null, and it fires updates on mScrollDirectionListener.
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
this does not handle the empty 'lists', it will throw an exception
This should follow the normal exception handling path and let the caller handle the printing of the exception.
So, if the xpath query matches event than this method will return true, right? Than the event will be propagated to TreeWalker. This java if (!filter.accept(event)) {  will be evaluated to false and the message will not be removed from the set. Thus, what is the sense of the suppression? What do you filter? Look at testMatching. The user writes the query /CLASS_DEF[@text='InputSuppressByXpath'] in order to suppress the violation, the filter should deny the event, but your filter will accept it.
Please use assertThat (result, failsWith(NAME_OF_FAILURE))
StringUtils.isEmpty
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Why did we make this public?
I think 15, 11, and 4542278 should be named constants.
could be simplified: Collections.addAll(refsSpecs, specs);
Formatting issues. Please use appropriate spaces between string literals.
unneeded throws Exception
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
Is it necessary to call this again?
Argument name
Looking at the CommandCache#reset() method you pointed me to, it made me realize that we should check here that ctx is not null first, to avoid any risk of NPE.
+ NUM_HEADERS + NUM_FOOTERS;
No interest in removing the stageTimeoutMs value?
Can you add getId() and mark id() as deprecated?
Is this method used?
That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead.
this change is no longer needed.
Is payeeIdL a typo or intentional?
make this synchronized.
Here it would be nice to use a static import - that would make it more consistent with the other code
Why is this necessary? This should probably use the generic updateBiometicListeningState(). I think you're doing this to turn on the iris scanner? If so, you should leave it authenticating state, like we do for fingerprint, and send another signal to go into high power mode to complete authentication. This is what we do in fingerprint.
Please add a java Objects.requireNonNull(computation, "computation is null");
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
Program to interface, not to implementation - please change return type to Map<String, Object>
Maybe wrap in an immutable map.
Can we have a thread name here?
must be package local
suggestion connectionFactoryList.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
this("Safety Command")
Should be a SamzaException with a message, not NPE.
use ShellIsAvailable
DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now
Just curious, why do we need to change the access qualifier to protected?
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
We need to check offset + length <= arr.length?
We usually don final local variables.
I thought you wanted to end this practice, Adrian?
Use Guava hashCode function
!reason.isEmpty() can be used
can be delegated as: putByteProperty(key(key), value)
use a constants in PicsConstants for page.png
On iOS I chose to not ignore this error since it makes the data structure useless and should require some action from the API consumer.
This should stay final
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
backspace (bracket should be one tab back)
Wouldn't it make sense to at least log a warning? I mean, in the end it's the user who accidentally made a mistake/typo, the service silently "accepts" this configuration but it somehow does not really work as expected. Or did I miss anything?
@slubwama provide an error message description of what has failed in addition to the stack trace
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
Why is there a fromByteArray method? Why not call the constructor directly?
Could we reuse instances? Perhaps justified if getCoder is frequently called.
This should say "LocalTime".
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
return an Optional<Integer> instead, then you can probably also get rid of JMXServer#getInstance
Huh? :-)
have a look [<LINK_0>](here). This class should be deprecated and no longer be updated, at all.
return symbol != null ? symbol.qualifiedName() : "";
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
I think you want to do this in the reverse order
Can we have a message assert on this? I think the point here is that the exception thrown by the runner close isn't the exception that happened inside the shutdown operation
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
final
Why are we doing double math here? This should be: return Math.max(1L, nano / 1000L);
Should this have output partition too?
Consider Arrays.asList("xxx","yyy", "zzz");
filter could still be null when this line is reached - we should check it isn't null
- log warning that option is not supported by SNMP
nit: remove brackets to be consistent with 2 lines below.
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
To increase readability of this test I would just drop this statement, and move ifCond block inside if condition
isInfoDebug
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
rename
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need anything to be added to DB.
But we have already clicked the button in the command before, haven't it?
If you instead call this lastItemPositions and subtract 1 here, does that save you from having to subtract 1 from the final return? I think it reads clearer not to have a "- 1" on the last return.
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Args.notNull
think you should add it as method somewhere
I don't think we need this catch - this is handled by the boolean return value.
same here. In case you want to open an ErrorScreen, you can do so by using one of the reportError() methods from <LINK_0>
can you make all of these as just Query and not org.hibernate.Query?
return ImmutableSet.of();
studentsWhoRespond -> studentsWhoResponded
This should be removed - it's absolutely fine for entity data to be empty. It's only during serialization to native format that it should not be empty (ie adding the EntityType field)
Use same order as the field declarations.
does this need to be calculated on the fly each time or can we save the iterable?
We should call the init() method first, instead of letting the KerberosAuthenticator do that for us.
Unsure this addition is useful.
Remove all "null" cases. There is a default case for that.
static
ctx.close()
is the server name mandatory still ?
replacing this with helper method would be great
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Add a blank here, please.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
If you are using synchronization to control access to the session data, than I would suggest reverting the map type to a simple HashMap and synchronizing around the map as opposed to this whenever you read, put, remove, or alter it.
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
Should be externalized.
Which tests fail if we don't have this line?
use log's parameter here
hmm, why don't you verify the type ?
you can simplify it with a single line by replacing the method's body with: return validate(hostExists()) && validate(hostStatusValid());
this is 3.3 feature, not 3.2
This check feels a little weird for a few reasons. It behaves like a factory (in that it returns new instances) but sLock is not assigned here. It also initializes a static field from an instance method and that feels strange. I suspect that if the lock is not being acquired in one method and released in another, and there aren't any waits involved a more primitive synchronization technique may be sufficient (such as a synchronized method or block, without the use of a ReentrantLock) -- I'll leave this up to your judgement but this looks dodgy
Can this be private, or is there another use case for default attribute outside the builder's call?
Don't need toString()
unused field
It's beeter to used int type.
Maybe catch Exception? Otherwise propagation stops.
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
Can you please move the Preconditions up to the constructor? Also perhaps check for matching with " projects/(projectId)/instances/(instanceId)/clusters/(clusterId)"?
it needs to be protected against concurrent modification
why not replace these two lines with return (getState(key) == State.SET)
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
throw e will never be executed.
Should this return the AzureTable?
Remove by dn/key.
please use String.format to concatenate strings
Everywhere we call entity.getClass - we need to use the EntityDictionary.getTYpe instead.
Why are you changing to patient 7 here too?
Log debug - not info.
could we check this without throwing an exception?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
@benbosman : I'd still encourage us to start with minimal/basic unit tests rather than waiting for "perfection". As you'll see above, I already have concerns that the UUID parsing is very fragile. So, having unit tests to prove it is working at a basic level would be helpful here, especially since the client using the REST API can literally send *anything* in a text/uri-list...so we need to ensure the parsing works as we expect.
What if we have only private static boolean isIncluded(String[] groups, Collection<String> includedGroups, Collection<String> excludedGroups) instead of 2 methods?
I think on reason to wrap into isDebugEnabled() since we don't do any logic with argument to log.
This field is written here but never read, can be removed (Findbugs)
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
Please, use text "Project owner login" (Name was fixed after sending this pool request) thank you.
This can be made static
no need for an ArrayList
clickGallery is not the name of the method
"ws" and "wss" must be defined as constants.
UnknownHostException can be removed
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
This isn't doing anything special (such as transform) before calling forEach, so write it as a normal for-each loop
It's better to use static import here to improve readability of code.
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
shouldn't print the stack trace from the test
should be setSucceeded(true)
Which type would be assigned in this case?
we can remove this validation since it's done encodeAltSequences now
Why is it a list of lists, not just a list?
Why protected and not private?
You shouldn't depend on the expected value passed by the developer - you should go by MaskValidator.getInstance().isMaskFormatValid(mask).
Consider adding this in another commit, it's easier to note the (important) change/fix.
Remove this if it's not needed.
Could this and the above constructor be changed to use the below contructor? e.g.:  public Region(){ this(null, 1, Integer.MAX_VALUE); }
bad hashcode.
isn't it stringbuilder better? too may strings to add.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
Another %n?
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
want to change this logging also while you are here
Would be better to test against more complicated Completable, for example check that some function was invoked
Rename -> CosmosDbFactory to CosmosFactory
Adding content to the commit message is not a good idea. Also, it's better to have unified commit message like: Change file <pathToFile>
nit, Collections.EMPTY_MAP?
Why does the handler require a zkUtils reference itself? Same for the other one.
I think this method could be private.
pls substitute these three lines with setInternalState( this, "toolchain", toolchain );
i wonder if using Pattern.compile() as a static member to hold the compiled expression is more efficient.
If there are tests where this is common you can create a helper (minor suggestion)
I do not like createExtension modify the entry... I think it should be: entry.setExtension(createExtension(entry)) there is no reason to load the module here and not within function... also, I am unsure the function of createExtension is worth a separate function but not that important. the activateEntries.put()... should be after initialization is success as last action, this will enable you to skip extensions that fail initialization. you should catch exceptions within the loop, to allow proper initialization without faulty extensions.
I think will only pass a single sql statement here, can use SqlParserFactory.parse(sql)
no need for the additional check if propertyParts.length is ok?
I think you need a null check here similar to the getViewIndexId. If the view index was created by an old client it won't have the VIEW_INDEX_ID_DATA_TYPE and you can assume its a short.
No, I mean take the Log.e() near the return null;.
These might look a bit tidier as static imports
You don't need to have this condition as there's just a loop doing nothing if filters is empty.
Commit message seems to be wrong. It is Operation not Function.
not needed; just cut it
suggestion driver.get("http://host.testcontainers.internal:" + port + "/foo");
restore empty line.
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
As IOUtils has been imported why not just use IOUtils.closeQuietly()?
please rebase, arik removed the lock in a different patch.
"valid times" should probably be "setup time" or just "setup"
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
It makes sense to introduce ICPPNodeFactory.newLiteralExpression(int, String, , char[] numericCompilerSuffixes) method, use it in GNUCPPSourceParser, and get rid of the setNumericCompilerSuffixes method.
Integer.valueOf
This is not time zone?
Should use the log, maybe a warning.
Why this check? This method will not get called unless performRuntime is called, and performRuntime has no such check.
Return the zone id here instead of returning an empty string.
Why does the report contain a file-name pattern instead of a real file name?
count(*) is more canonical than count(1).
For this value, we should do something closer to what ProductDTO does. Leave the building of the URL to the actual entity so we don't have two implementations of it floating around. We should also update Pool to be nicer about generating it so we either generate a valid URL or nothing at all (see Product for an example)
We could in theory do this multiple times within a second with concurrent access, but it doesn't seem like that big of a concern. To get around it we could create a new FetchedTime if the check passes and then do a CAS, and if the CAS succeeds, call fetchTimeMicros and fill in the fields of the new FetchedTime.
Shouldb't be this i18m
please check here isSetPmProxies() otherwise you can get NPE
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
There's also a race here if someone calls setDisconnectListener(null). Do you want to allow unsetting with null? If not, prevent it.
do we need a null case?
Please consider adding a Preconditions.checkArgument to check that base64EncodedKeyContent is not blank.
Why can't you use MoreObjects.firstNonNull here as well?
@apearc03 ASL header is missing causing the build to fail on Travis.
This should be package private?
Is there a situation that getAvailableNamespaces doesn't return result, so we are required to traverse over authz extensions directly here?
Will this have any effect to legacy data (i.e. those existing before this PR)?
@lauravignoli Any reason you split the declaration and initialisation of the query variable into separate lines? I think it would be best to keep the style here the same as the methods above, but it's just personal preference so I will leave it up to you.
you have to add a canDoAction message if you fail canDoAction
does it make sense to send 2 versions of the verb to different hosts in the data center? (if one is older than 3.3 and other is 3.3) i think you should use storage pool compatibility to be consistent with all hosts in the storage pool.
Parameter should be true here, no?
But why do we handle 400 differently than all other errors?
Is this method really needed? It's similar to make init public
I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
add {},
this variable may make more sense just as itag given it isn't only for items.
Is this method really needed? It's similar to make init public
Streams used in proper way, however I would propose slight improvement: java categoryWidgets.entrySet() .stream() .filter(entry -> !Objects.equals(entry.getKey(), categoryId)) .forEach(entry -> entry.getValue().setVisible(false));  I think proposed formatting is more readable and prevents NPE in filter part, let me know WDYT.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
throws TaskException is part of the interface, did you mean to remove it?
Collections.emptySet() should be all that is required here, no generic.
rename to className
Use this.key
Same as above, let's not instantiate the FBO within process and let's try to use BindFBO in initialize() instead of this bind() line.
Normally we would do this to prevent accidental bugs to trigger the wrong failure:  private RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder() try { builder.rxFactory(null) } catch (IllegalArgumentException e { //... }
Does this truly need to be done in arjunaCore or could it be guarded in XTS alone? It is fine if it is an arjunaCore issue and we should code to fix it but I need to see an arjunacore test case that shows this or reasoning it can't be sole change in XTS
why not use the MessageLevel type?
It should be Memory metadata/dump disk could not...
Assert.areNull
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
I thought empty was OK, and it would point to latest?
I know this wasn't your code, Lars, but you may want to use SubMonitor to fix this progress monitoring bug while you're in here. pm is used twice in this method.
It should return ReadOnlyDictionary not ReadOnlyDictionaryInterface. Also IIRC, ReadOnlyDictionaryInterface is internal for Java.
@rui-castro why don't you keep skipsOnStream as it was?
The SQLTable shouldn't need the default and connectionDetails map. It should just be handed the only ConnectionDetail object that pertains to it.
Isn't it also important that adType was async and method was top?
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
could be a single return statement
Perhaps it would be beneficial to add the mac address as a replacement in this message (in a separate patch).
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
Nit: if the call doesn't throw an exception, then this should print a "success" message.
Do you forgot to compare items and label?
I would prefer to have a constant (from the plugin providing the language) here, it will also show that the plugin is missing a Manifest dependency to the plugin that provide the language org.eclipse.papyrus.uml.textedit.transition.xtext.ui
// nitpick-mode-on Can you change this.ctx to ctx? // nitpick-mode-off
(nit) no need to make a copy of the array (save the garbage). We don't usually guard the callers from modifying the list as it is internal code.
this.currentLocation.get() this may fail, as the currentLocation is not always guaranteed to be set. Check for presence
This is dangerous, as it will potentially lead to looping tests. the retryClickUntilPopupDisappears already tries clicking for 10 seconds. Let's restrict the number of iterations to some fixed (small) like 2 or 3 using for loop or something.
<LINK_0>
It should be "Then that player shuffles their library", the oracle text in the spoiler file is outdated. I've been dragging my feet on updating all of it.
If the arg isn't modified, you can use Collections.emptyList() to avoid an allocation here suggestion writeReport(output, Collections.emptyList());
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Shall we return Collections.unmodifiablemap?
You can make this method private
no checking flow when user sets grace period in the action
you can fail inside of try block instead after db.execute then you do not need to have return statement inside your catch block; also you can use ExpectedException rule
We might want to consider calling the new method from this one so we don't duplicate code isPublishDateInTheFuture(dateCreated, new Date()) wdyt?
Might want to log a WARN if you are going to drop the command due to no myqOnlineData.
I would prefer to use String.valueOf(value)
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
can you add to Builder as well
use new Guid(String) - this literal can't be null
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
"http.url" is the current name, when query parameters are present (which I think this is..)
new Not( ? Why not use the static method like for the other matchers?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
The job of a dispose method is either to free unmanaged resources / memory and to deregister stuff properly so that the object can be garbage collected. Of course you can set all references to null / clear datastructures etc. to help the garbage collector but this is just boiler plate code with little benefits.
return Collections.emptyList();
In some places we have recordStorage(), here we have the get prefix. I think it would be better to have recordStorage() everywhere.
This plays the current, not the next station.
Copy-paste bug - should be "getDeviceListWithoutStatusSupported"
@antonini you can use Matchers.allOf() to combine these two assertions and get rid of one-time variable head
This is not clean. If this method now returns an absolute path, you should also change the method name from "getName()" to "getAbsolutePath()". Also, you will need to change the messages. With your change, the FSOperation_ConfirmFolderReplaceMessage would now say "This folder already contains a folder named /foo/bar/target/file" . Which is not accurate. Instead, the message should now say something like "Folder '/foo/bar/target/file' already exists. Do you want to...' Or you could change the code even more, to say "Follder /foo/bar/target" already contains a folder named "file". Do you want to..." Please make sure that you test the workflow, and validate that your final message makes sense.
Why uppercase fs?
does this need to catch all exceptions?
These two could be simplified to assertNull.
return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM) if it needs to be modifiable - add new ArrayList<>(...)
I'm seeing MySQL use an error code like this: 533 throw SQLError.createSQLException("Unable to unwrap to " 534 + iface.toString(), SQLError.SQL_STATE_ILLEGAL_ARGUMENT, this.exceptionInterceptor);
This from field appears to be redundant, as this is an inner class.
use getDiskVmElementDao(), please apply to all the dao calls in that class
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
This reads as if TenantIndex initializes the BoundedContext.
can we give different name to this variable? it is meaningless
Should we avoid using 'disloyal' here, since it's not about Byzantine style fault, and the vote is not disloyal against the protocol? Maybe something like 'quite leading due to a voter previously voted me changed its vote because of ....'. ?
Since the menu item click has been handled, return true instead here.
Do we need !block.isAir(world, x, y, z) here? Wouldn't (block == Blocks.dirt || block == Blocks.grass) return false if it was air?
style nit: we don't use braces around single line blocks
Similar change as first(count).
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
can we explain here why do we need such function?
Please log Bundle ID data here.
Did we want to have this normalize the path also by returning the normalized version from Path?
this should be like other errors.. create EngineError key and a corresponding message in vdsmerrors.{java/properties} files then throw a EngineException with this key
It might make sense to use try...finally here, putting enableDeepLinking in the finally block. Otherwise deep linking won't be re-enabled if something goes wrong.
Can be cached
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
do not call real method.
other places use "error" lower case
I foresee clashes here. Should at least use <type> + "/" + <name>
Go ahead and be specific about size and who is in the list. A check for non-empty list is not going to be enough to ensure this doesn't break in the future.
Not convinced that getCurrentVersionString() throws a NullPointerException.
I'm confused. Which of these catch clauses is the expected one?
should this call SQLUtil. sanitizeCondition instead?
This must be supported.
Do we need to swap expected and actual here (and also for the next two as well)?
Do we not want to filter on isInstance first? (even just to protect from wierd bundle reloading errors?)
Same here when trying to save the context without specifying the script (or when trying to import the context).
return (radius <= maxMeasurementPointRadius && radius >= minMeasurementPointRadius);
Can this be private, or is there another use case for default attribute outside the builder's call?
By right, soft deletion should not result in InvalidParametersException
Use Converters.getElementToIdConverter.convert(x) so we can swap out the conversion without having to refactor.
This seems wrong, it should be rawField( absoluteFieldPath, Object.class ). And tests do not fail, so you're missing a test here.
any special characters to block in webhook name?
we need good docs here
Can this be private, or is there another use case for default attribute outside the builder's call?
![MAJOR](<LINK_0> Make "isExcluded" a "static" method. [![rule](<LINK_1>](<LINK_2>
I think we could implement this in a more concise form as well: java if (!parameter.isAnnotationPresent(Auth.class)) { return null; } else if (principalClassSet.contains(parameter.getRawType())) { return new PrincipalContainerRequestValueFactory(); } else { final boolean isOptionalPrincipal = parameter.getRawType() == Optional.class && ParameterizedType.class.isAssignableFrom(parameter.getType().getClass()) && principalClassSet.contains(((ParameterizedType) parameter.getType()).getActualTypeArguments()[0]); return isOptionalPrincipal ? new OptionalPrincipalContainerRequestValueFactory() : null; }
need to add more information about dimension/index/length
Adding this to a field is good manner.
Swap the order of modifiers, like it in all other methods in this class.
What if type is not Class type?
Can the connection or the context be null at this point?
use Java8 stream anyMatch() instead of this loop.
Please have a look at org.jboss.as.controller.operations.common.Util.createEmptyOperation.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
? element.getName()?
simplify this
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), CANCELLING, EMPTY_VALUE);
can this be part of new module as InputSource seems to replacement for firehose related interfaces ?
Then I wonder if this is the correct behaviour in the case of garbage being returned. Isn't the contract to retry in the case of invalid reads?
Checking containsKey before calling remove is redundant and should be removed
I do not like this check at all. What if we want a screen free from animation?
@vilchik-elena Charset.defaultCharset() should be replaced with a given charset.
isn't the currentRow the instance of RowBuilder which was just added?
SourceImpl?
This doesn't look like it does what a stopGracefully should do. Maybe we should rename that method to something like suspend (not in this PR though). But, what it's supposed to do is suspend a task quickly so the jvm can be shut down and then restarted. Specifically it shouldn't be trying to publish or anything like that - just persist to disk and then stop.
Several things here... First, the condition you're using is slightly wrong: a big decimal may not be normalized, in which case its "unscaled value" may end with zeros, in which case it might not require rounding after all. For example 12.34 may be represented as 123400 with scale 4. With a decimalScale of 2, value.scale() > decimalScale, which would trigger the warning despite the fact the resulting number after applying the scale, 1234.00, does not require any rounding. You really want to use value.stripTrailingZeros().scale() > decimalScale. Second, I don't think you should issue a warning when rounding. At best a trace, but only if you really want to (and please guard the computation with if ( log.isTrace() )). Rounding big decimals is really not a problem; it's even a valid use case. The user may want very high precision in the database, but he might not care as much in the index. Third, there's another problem, much more important in my opinion: values that are too precise to fit in a long after scaling will not be rounded, they will just be completely wrong. I don't know how Elasticsearch behaves, but I think that, if it doesn't fail, we should throw an exception on our side when that happen. For example try to index new BigDecimal(String.valueOf( Long.MAX_VALUE ) + "345") with a decimalScale of 0, or even -2, and watch all hell break loose.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
Item dropped should be a hopper
specify charset?
this mapping should happen via public enum and not via mapping backend enum to string
Can you please use static exception instance?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
move depageLock.lock() right before the try statement
Please add a check Objects.requireNonNull(supplier, "supplier is null");
if ai is not null, then return appLabel. Otherwise return null. => return ai? -- edit nvm, I guess return null is more explicit!
Can you change to static variable ?
Why you do not call it in finally block as before?
is this needed?
I thought I already implemented this for the MavenArtifactGenerator...?
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
This should always be read from the configs.
Conceptually, this should be readRaf() since querying the length is a "read" operation. (I realize that in practice, it won't matter due to the exists() check beforehand, but the code looks strange/wrong with writeRaf() here.)
Can header name and value be null?
Not sure whether this will work, If it does, do you think it makes sense to just clear out the offsets for the partitions that got reassigned, This way we will still have checkpoint state for the partitions that didn't get reassigned?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
Imho , some style inconsistency. On one hand you have a final char for delimeter, on the other hand you append hte literal '=' (no final char for it) why?
Please do the List changes in a separate PR. This PR should contain only benchmark changes.
Extract this try-catch block to a method to avoid code duplication
This is redundant. If results.isEmpty() then we have empty singleton and can return results
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
Doesn't the record name, org.apache.avro.compiler.UnresolvedSchema, make this an unresolved schema? I think this error message should be that the unresolved schema name was missing.
It would be good if you can applytrimming for white spaces on platform.
We could just catch "Throwable". It isn't a good practice in general, but I think it is acceptable in this case.
Split the request line.
Isn't a HTTP Status 404 just enough? Do we really need to write a json message as well?
Same as in Alientype2.java (add type of alien)
These tests don't seem to assert anything about their output.
The types could be removed.
I see this is used just in kie-wb-common as log message, however maybe could contain also fact/field, or some more details.
specify charset?
better to cast to string instead of using toString() .
cosmetic: move the catch line to prevous line following }
nit: check if this is empty, and if it is pass null? Otherwise you can't add an initializer on the copied instance. (I'm looking at the constructor and trying to figure out what the opposite assignment is!)
As previously discussed this is not thread safe. We cannot use Map.computeIfAbsent() or Map.putIfAbsent() introduced in JDK8 so I propose to add ConcurrentMap<K, C> concurrentMap field and corresponding param to the constructor. It would be illegal to provide both suppliers. The get() method could have two branches. One for regular map:  if (map.get(key) == null) { V newValue = supplier.get(key); if (newValue != null) map.put(key, newValue); }  And second branch for ConcurrentMap - the same as the current version but using putIfAbsent() instead of put(). Of course, we would have to modify SetMultimap and ListMultimap.
minor nit: can we check mSavingContentProgressDialog == null and only create a new ProgressDialog in such case? something like this:  if (mSavingContentProgressDialog == null) { mSavingContentProgressDialog = new ProgressDialog(getActivity()); mSavingContentProgressDialog.setCancelable(false); mSavingContentProgressDialog.setIndeterminate(true); mSavingContentProgressDialog.setMessage(getActivity().getString(R.string.long_post_dlg_saving)); } mSavingContentProgressDialog.show();
Instead of returning Repository, maybe we should return a Git. That way the Git object is ready to be used by the caller.
Missing @ Override
Fix please :-)
maybe worth calling this TimelockRpcs or TimelockRpcClient or something like that? TimelockServerInterface seems a bit fixable...
lets export this to a method
move it before synchronized
suggestion Objects.requireNonNull(in, "InputStream cannot be null");
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(logTag); // Or sanitizeTag or normalizeTag, etc ...
Actually the underlying objectExpr could have free variables.
What's the point of the 6 trailing zeros ?
this seems like it should be a try() with resources
The title should be HTML escaped here if it's going into an HTML constant (which is presumed safe)
@fchauveau there is no null handling of source, is this intended ?
Revert this.
I would turn this && around. A simple deadlineName check is a lot cheaper than the full parameter assignment verification.
not needed; just cut it
I'd call the variable entityClass
here too, can this be done with computeIfAbsent?
I would prefer not to use null ... just a empty set and then assert that its not null
Does a straight comparison work here? NaN isn't usually equal to itself.
There is jenkins.util.Timer.get() for these sorts of things, I'm debating with myself if that one can handle once a second... It probably would I think.
Same as above. Can also move this common block into a method of Function and use at many places
Should this be delegating to a different method than encodeLink, above?
Looks like approach proposed in line 92 would help here too. The less code duplication, the better :)
use the interface here
Using the error message in the metric could get really messy. These are arbitrary strings, and could be very long. For Error, we're using the error code-a _very_ different thing, since these are well known, and short. The exception type name is enough for Exceptions.
Maybe a wider exception would be better idea here if anything rather than sql exception happens. Since we don't deal with the exception itself.
Does this code check only the parent or any ancestor? Is it valid to check only the parent?
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
This line sets the Item.image field which can be used instead of enabledImage.
remove printlns before this is merged
I see in this diff that count = DEFAULT_COUNT. I assume somewhere else in here it is binding the value provided in the properties file that could overwrite that?
Is it possible in a non-HBase environment to have a non-null bulkOptions but to not have set maxInflightRpcs? If so we might not have a valid value to pass through to ResourceLimiter.
shall we add some message here?
I'm not sure the sorting should be in ArenaImpl. The reason getNonreadyPlayers() returns a List rather than a Set is likely because of its original call site in the notready command, where it is fed to a utility method that stringifies a List. So it's probably past laziness more than anything :P I think it makes more sense to do the sorting at the caller site rather than in here. If nothing else, it reduces the blast radius of the pull request and keeps the changes "collected" in the signs/rendering code.
Not ImageJ style.
here you discarded .xref class, are you sure that any javascript does not depend on this?
Just seen this... Would it be more convenient for this method to be named assertPredicate? The current name seems to mean that it will perform arbitrary assertions...
To clean up properly, please place the Builder in a try-with-resource block java try (Builder b = new Builder()) { // test }
It would be good inline the logic of isConcatCall() here and use it to pull apart n into the bits you'll need and early exit if it turns out n isn't a concat call. Then the utility methods that do the work would take the pieces, which you could check the validity of with not-very-bright checkArgument() calls etc. This reduces redundant logic and improves readability. java Node calleeNode = checkNotNull(n.getFirstChild()); if (!calleeNode.isGetProp()) { return n; // not an array.concat() call } Node callTargetNode = calleeNode.getFirstChild(); String methodName = calleeNode.getLastChild().getString(); if (!"concat".equals(methodName) { return n; // not an array.concat() call } // etc.
/dataset/commons-lang/ will not pass the CI test since this repo is present just on your local machine right now and hence an error will be thrown on the CI server. Make it repogit4testv0 maybe.
I think we should still allow it to blow up other tnt blocks, or else it isn't very fun.
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
Isn't it more standard to use getEngine() instead of using the maybiInitialize... return getEngine().contains ... Also I would make engine private instead of protected so as any plugin using it is changed to use getEngine()
static import DataSize.Unit
Remove log statement. Let's consolidate logging into fewer (more complete log statements).
I think you need a null check here similar to the getViewIndexId. If the view index was created by an old client it won't have the VIEW_INDEX_ID_DATA_TYPE and you can assume its a short.
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
URL Decode would be necessary for parameter name and value
I would change the message to: "The resume() method was called more times than pause()."
I fail to understand what is going on here. The end action mode of the command is UPDATE_COMMAND_S TATUS_ONLY. But here you are not updating the command status but changing the end action mode to RUN_END_ACTION_METHOD. Also if the parent command endAction is being execute doesn't it mean the child command has completed execution and it the responsibility of the parent command to invoke endAction if necessary on the child commands.
Not sure, why not use @NotNull?
Can you make these final?
This code could also be written like the following, and then maybe the map in the superclass does not need to be made visible. java for(CacheType ct : CacheType.values()) { //not sure if values() is the correct enum method name ((LruBlockCache) getBlockCache(ct)).shutdown(); }
I don't have strong preference here. - Shall protected or package-private enough here? - Or, on the other hand, with these two methods made to the public, we can avoid several test codes using INSTANCE_DN_KEY and RESOURCE_DN_KEY directly. Not a must in this PR, though.
At this point, too, an AtomicReference does not bring any added value compared to a volatile variable.
do you need to check for nulls on paymentWorksNewVendorDetailDTO and paymentWorksNewVendorDetailDTO.getRequesting_company()?
naming
This should stay final
As above, assertions the wrong way around?
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
ConcurrentHashMap might not be necessary in getValueAndReset(). This function is called every X seconds to sample the current metrics and export by Heron instance, so it is not called from multiple threads.
I'd suggest simplifying this block to (and for the similar cases below):  return super.getConfiguration(igniteInstanceName) .setIncludeEventTypes(EventType.EVTS_ALL);
@ILikeToNguyen Why the change in visibility here?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
So this would leave the View in an inconsistent state with the Presenter? Should you not show an error in the View that the value was wrong? Or default to a valid value and update the View? etc
there's formatting issues here
nit: this is a filter function, might be better to use filter replicaIds.stream().filter(r -> replicaAndState.get(r) == state && (dcName == null || r.getDataNodeId().getDatacenterName().equals(dcName))).collect(Collections.toList());
I prefer using Preconditions.checkArgument over asserts (at least for cheap things), since the former will always run and catch issues that might crash at any point early even in production (IIRC assert is disabled there by default).
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Is it possible/problematic here when the member is force set to the same effective time it currently has?
The coverage is not the only important thing in a unit test. Notice that the getValue method is **100%** covered, however, I could change it to this: java @Override public String getValue() { view.getValue(); return "Wrong value!!!"; }  ..and the test testGetValue would still pass. We need to **really** test the logic of the method. See the following unit test (now, it really tests the method and breaks when the logic changes): java @Test public void testGetValue() { final String expectedValue = "value"; when(view.getValue()).thenReturn(expectedValue); final String actualValue = dateSelector.getValue(); assertEquals(expectedValue, actualValue); }
you didn't use methodName here, is it intended?
Please replace the following 2 lines with return failCanDoAction(VdcBllMessages.HOT_PLUG_IS_NOT_SUPPORTED);
Can be simplified to: java results.stream().anyMatch(entry -> value.getK1().equals(entry.getKey()) && value.getK2().equals(entry.getValue()))
Instead of assign and return, just return the last statement.
Let's keep the boxing as is please and focus this PR on the new API. If you want to go through the whole code base and consistently use one boxing style that's a different PR IMO. But: I prefer to know when boxing and unboxing takes place since it is not free; this gives the compiler the opportunity to flag unintentional boxing and unboxing and let the programmer decide that's really what should happen.
Missing types
This is super silly. Never do this and read about java string pool. Just hit java string pool in google and you will see a lot of articles.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Maybe check for if name ends with ':' so we don't do a double one?
I agree to Robin's proposal
Didn't we use the JLS suggested modifier order all the time? I would prefer to keep a consistent order in the framework.
Minor: since locateMember has been renamed to locateMainArtifact, maybe downloadMember should be renamed, too?
I think this should be done in the constructor rather than here - or at least, in the if-clause of this method. Otherwise we risk adding the instance as a listener multiple times for each getInstance call
Is it really worth checking before setting it?
It's a good update
It's hard to see why one would care about having a stored value that's not current, and indeed it seems that this method is only used in ImmutableComputableGraph::statusToString, which is never used.
What if values.length is longer than COEFFICIENTS.length?
null? why not just a () -> {} ?
you could use: prefix.ifPresent(prefix -> if (isBogon(prefix.toString())) ...
return Collections.emptyList();
I think we don't use 'final' in this place anymore.
Does it still make sense to use forkJoinPool? The tiles are no longer downloaded at this point, so it would add an overhead to run this in parallel.
Can be simplified, use assertNull instead.
This should throw an UnsupportedOperationException instead of a RuntimeException. Also, standardize the error message with the other UOEs throughout this package.
These catch code blocks seem to be very repetitive, should they be factored out into a utility function/lambda?
Only the first row should be explicitly typed; the rest can benefit from type inference. Alternatively, use method reference here, e.g. InstructorFeedbackResultsResponseRow::get*.
Use a constant for this path.
Why setting Token or MID imply sent = false ?
Checking whether text is null seems properly defensive. If text is not null, I believe that text.getData() is guaranteed not to be null, so that part of the check is unnecessary.
This one seems too broad
Recommend to use ToStringBuilder
return Collections.emptyList();
The last assert is different from the first 2
Is there a more specific exception that can be caught?
minor: could you add disabledReplicas as well?
Would it make sense to automatically call this method via on-persist/commit hook, depending on the event state?
suggestion thrown.expect(containsCause(new ValidationException("Option 'csv.quote-character' must be a Character.")));
Detail: FROM capitalized.
add this selector to UI mapping at the beginning
Why is this necessary?
- log warning that option is not supported by SNMP
the return type could be tightened to OGCPoint
I don't think this should be public; or even be a method.
it'd be nice if we could use polymorphic deserialization, but i thinkthat is a bigger change
Style issue: @Override shuld be on line above the method declaration
can be inlined
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
Is this conversion really necessary? The SUT does not involve an array at all.
Can you pull this out into a property?
I must be missing something; I don't understand how the above change would make any difference performance-wise. Was this change made to be more readable, rather than to improve performance?
Use Strings.isNumeric
why did this swap places?
Why do you need the non primitive class check?
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
I have noticed a few occurrences of catch (Exception e). According to <LINK_0> we should catch the most specific type we can. Can we catch more specific exceptions here?
It is not necessary to test REPLICATE region in this test.
Can you reuse the scan variable? That will save connection time for every request.
Lets create constants for these strings
return null to make this more explicit ?
return tags;
Add stack trace to exception.
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
seems like a string that should be stored as a constant and defined only at the side who returns this message to prevent breaking this assumption - unless it isn't doable
We may also want to cancel our subscription.
It's easiest to initiate the field directly, and I'm not sure it's needed, the primitive should be false by default
please remove or decrease log level to TRACE
can be simplier: showing empty array even if the value is null is not really a big deal imo. Also, toString are usually only used for logger..
The original code was there to demonstrate the syntax, even though all paths are locked down by default. I think you still need to permit everything but /restricted for this example to work properly. I will double check as a UAT step.
Why are you keeping the conversion-less method?
IOUtils already checks for null...
No key for encryption? ;-)
Could use a StringBuilder.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
Same thing about calculateInvocationTime
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
Typo: Ant**P**atchersPathVariablesCa**mm**elCaseVariables should be Ant**M**atchersPathVariablesCa**m**elCaseVariables
@gaurabdg interesting approach, but can we store this depth inside object to avoid unnecessary calculations
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
Why not declare GLOBAL_ID as a long?
If VM's custom compatibility version is set, cluster's compatibility version is ignored. That means we don't need to display any warning, because nothing was changed for the VM.
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
Check if KEY_MEASUREMENT_FILTER_ID for specific measurement filter is present in request parameters. If present set value from request parameters, otherwise don't set...
createCache simply
It crashes because lastSearchedText is null on first launch. check for isEmpty?
Lets use super.cleanUpUsingRest() here
What does the constant mean?
This shouldn't be synchronized, as nothing else in MetricRegistry uses this lock.
Do we need this to be public?
Should this not be by.css as well?
KFSConstants has a constant for a single-space string if you want to use that here instead.
Hi @mderamos, Add code to check if value is not null before using substring.
I think can just indent 8 spaces from [t]his
Why do you omit SecurityException e in the caused by chain?
Just a small micro-optimization here: If you swap the ItemSetting and the Material check, then this statement may execute just a tiny bit quicker as Enum comparisons are sped up by the compiler. Other than that this is looking good to go!
I suppose there is nothing wrong with this, but there is no need either, is there? (other cases of the same marked with ditto3)
Could you maybe look if this could be removed? I mean the new DefaultVariableNameFunction().apply(this). It's already handled in the other constructor.
Shouldn't this be < instead? if the end of the time range of this request is before the time range that has been updated in the traceRangeUpdated signal handler?
This can be static.
use namespace instead of DEFAULT
You should test for both instructor and student?
Is this really needed? Is there a more deterministic way of waiting?
setErrorMessage
can u extract a final constant with a readable name out of "<[ ]*/[ ]*%s[ ]*>" ?
This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this
Let's add a couple more here to increase code coverage -- maybe one in which there's no label, and another in which there are no options?  {r echo=TRUE} {r thisisalabel}
Style-nit: I'd prefer dropping the curly braces, but I'll submit this as-is.
move 5 and 1000 to variables. Its used in so many places
Can we inject this feature directly ?
To note potential further benefit of a value object, a value object for bonus type could encapsulate this logic and remove redundancy, eg: if(rule.getBonusType().isOldArtilleryRule())
I see this method does something similar to execute minus the optional processing with the rowProcessor
this and m_ is redundant
You forgot this!
You want to use assertEquals instead?
this mapping should happen via public enum and not via mapping backend enum to string
calling endAction here is dangerous, I don't think we have it anywhere else. it is problematic because the execute phase was not finished and there is all the infra in CommandBase that handles it. Please call endSuccessfully directly instead (and need to verify that the 'log' method is called)
No new line. You can actually drop the whole else if and only keep the mVersion check as early abort. getVersion() should never return null this would lead to unforseen behavior of the other methods. It actually can never return null as we can never reach this if mPkgInfo is null (Constructor would crash).
You can use assertEquals here as well.
can be inlined into a single line by using Streams
why not final Iterator<CompareInputAdapter> candidates = Iterators.filter(node.eAdapters().iterator(), CompareInputAdadpter.class); It will avoids create an intermediate iterable (see Iterables.filter implementation)
This may be a reasonably common return value so error logging isn't appropriate. I think perhaps we should make this method return boolean (and return false if the update fails), and just do debug level logging here.
~1 minute & ~3 minutes respectively?
Very minor, but our code style conventions are to have a space after if and before the (
Is order important here? Should the 2 collections correlate each to another?
Should return the empty list, not null
do {   } while (current == null) is more natural here.
The aforementioned "never return null" rule would be good for all the string getters here.
Why not? Or it just doesn't support it _yet_ since there's no need?
It could use the string constructor instead which already has that behaviour (not much advantage in providing a utility method for that IMO).
Other places in this module handle buffer == null.
Will * <LINK_0> * <LINK_1> work as well?
@ptirador I mean it should be like this: java this.of(coordinates).buildPublishJson(); return getPackagePath();
tracef
nit: this definition looks really awkward
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
AFAIK it would be good to shutdown the executor when it isn't needed.
Overriding is quiet hard now that the method is private ;-)
Would prefer this to call getVersion(), rather than the deprecated getVersionFromStatic().
are you sure you want to search for translated tags only, don't you think it could be better to search for the tags value and the translated tags ?
Should we add: Objects.requireNonNull(record)?
Why the switch statement? I propose: if (action == null) { throw new NullPointerException(); } setDeny(action == Action.DENY);
return Collections.emptyList();
unsafeSubscribe shouldn't call the ERROR_HANDLER.
ImmutableMap.copyOf()
is this tear down necessary? the next setup overwrites anyway, doesn't it?
Objects.requireNonNull
I this refactoring, very nice. Could make this method protected.
Aren't there any chance that super.inputStream() **is** already PushbackInputStream, so, we don't need to wrap at all?
This class should abstract the client from the underlying connection, returning a Response forces the client to deal with it.
Do not add the check here. Add the check just for dateuploaded.
executionOrder++ increments after use, which changes the previous behaviour. Are u sure this is what you want?
This function is presuming that the method caller is verifying "messages" is not null prior to being called which is ok for these changes as that is happening but if this private method is used elsewhere in this class in the future that may pose an issue.
this test is identical to hash_value_blank()
Have a Semaphore that guards this method call (make sure to release the permit in a finally block)
iiuc, the AddGlusterWebhookInternal is responsible to deny the request if the action isn't supported. This is blocked by the can-do-action and not going to be recorded anywhere (maybe only by the validation failure message to log) and as for any failure during the execution of the AddGlusterWebhookInternal command: The AddGlusterWebhookInternal command is responsible for creating events log if it fails, so no need to record it in this context. Shouldn't the result of AddGlusterWebhookInternal affect the execution of initGlusterHost() ? meaning, if initGlusterPeerProcess(vds); fails, should there be an attempt to execute the AddGlusterWebhookInternal ?
same here as well - on failure to stop vdo service, activate and move host to original status
Spelling
call notFound
Unnecessary parentheses (and an extra line break).
java.util.Collections.singletonList() should be prefered for singleton list. (always a better practice to rely on JDK classes rather than libs).
Oh yuck. ;)
Can we define a final CONSTANT for the MD5 ?
Stream closing?
static import?
this.url = checkNotNull(url, "url");
Shouldn't we use, or instead of nor ?
does this have to be a list or can it be an iterable?
These 2 can be called just once.
I would rather store the response in the cache when we are sure it parses correctly.
add brackets to make this expression more easy to understand
This actually could be return !isEmpty(triggerId) || !isEmpty(triggerIds);
this can be replaced by getGroups().forEach(group -> cache.flushGroup(group));
Not an exception
If we test the public interfaces, can we keep the implementation package-local?
As I suggested in another patch, we should consider having a version for persistAsyncTaskPlaceHolder with one argument (parentCommand) which by default uses a DEFAULT_TASK_KEY. Same goes for getTaskIdForTaskKey - we should have a "getTaskIdMethod". This is not mandatory, it's a suggestion.
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
why? for debugging purposes? sure, but don't keep it in testsuite by default it just messes up with CI servers
Can this be private, or is there another use case for default attribute outside the builder's call?
this method should be changed to private
might be useful to print it, no?
Will this have any effect to legacy data (i.e. those existing before this PR)?
I would add mcast-port=0 as a default
are these setters used anywhere?
At the very least, extract '(CreateImageTemplateParameters)getParameters().getImagesParameters().get(0)).getVmId());" to its own method...
nitpick: tab
listeners are not notified?
I would rather choose to have a while loop to implement this rather than a recursive call (call stack can grow quite big unecessarily because of this call depending on the level of nesting of the file) and moreover, I believe a while loop would be more readable.
Empty line, also it could be better with more fields (use your ide toString generator).
this can be 'long' instead of 'Long'
use more descriptive names
Please use style instead of getStyle(), as this is more consistent with the rest of the code base. I.e.: if ((style & SWT.HORIZONTAL) != 0)
Use "guid" instead of "asGuid(id)".
Namespace prefix 'p:' should not be hard coded. This will generate some false positives if the namespace definition does not use 'p:', for example: xml <beans xmlns:x="<LINK_0>"> <bean class="org.springframework.jms.listener.DefaultMessageListenerContainer" x:acceptMessagesWhileStopping="true"></bean> </beans>
@ekondrashev Here too, let's use throws Exception as per our [coding standards](www.yegor256.com/2014/04/27/typical-mistakes-in-java-code.html#test-method-names).
-1 since the interpreter is only used with JMX now.
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
Would it be possible for a key to be null? Do we need to add a check for that?
shouldn't you return templates?
Why not public access?
Why dashes instead of dots?
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage?
Should we add null check?
Why do we need those lines? Unit tests are still green if I remove them.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
Why don't we make inDegrees to ConcurrentHashMap also?
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
can't be null?
Possible NPE with calling contains on artifact.getName() ? Better checking for nullity before calling .contains
final float sleepDuration = (int) ((double)  feels odd.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Yes, it shouldn't be cached in memory.
...this change really doesn't make sense. > Changed off screen limit for unlocks to 1(on unlock it was 2 and once activity open it would report usage of all 3 fragments, so to add little more accuracy I moved to 1 off screen as on SoldierStats) Are you really considering to give the user a WORSE experience, just so that we can get a bit more accurate analytics? I for one would rather get analytics with a known misrepresentation (all three fragments) than a random misreprentation. Example in your current implementation: 1. User opens unlocks 1.1. Fragment A and B are downloaded (A=1,B=1) 2. User scrolls to fragment B 2.1. Fragment C is downloaded (A=1, B=1, C=1) 3. User scrolls to fragment C 3.1. Fragment A is cleared (A=1, B=1, C=1) 4. User scrolls to fragment B 4.1. Fragment A is downloaded (A=2, B=1, C=1) 5. User scrolls to fragment C because he forgot something 5.1. Fragment A is unloaded (A=2, B=1, C=1) 6. User scrolls to fragment B again 6.1. Fragment A is downloaded again, third time now (A=3, B=1, C=1) So, basically, what that would generate would be... three hits for A, one for B and one for C. How is that more accurate? If we load all fragments at the same time, we get one for each, which is a more viable representation. I'm just trying to make sure that we don't do stuff that makes the app worse for the users (and the experience). For example, I would rather look into if we can use the ViewPager "hooks" and send a "trigger" once we switch to a given fragment. That way, if we go from A -> B -> C -> B -> C, we'll instead notice that the user used fragment B and C twice, and A once. This seems both possible and more useful to me, instead of causing people to re-download information just because we're doing it wrong. :+1: @peter-budo
return id;
I would prefer not to use null ... just a empty set and then assert that its not null
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Does it have to be public? Couldn't it be package visible only?
We should leave these as assertEquals and just add the MariaDB check since we are not making the global change to assertj on 2.1.x
I was wondering about a situation when isVaultExpression returns true (value is in the form of ${vault.xyz}) and we are unable to transcribe the value from the vault. Should we somehow notify users this situation happen? I think in the majority of cases this will be caused by a wrongly configured vault (maybe a typo in vault id, etc.). The result of this would be for example _unable to connect to the SMTP server (wrong password)_, which is actually not the root cause. Maybe we can somehow let users know that this is actually caused by vault configuration. Does it make sense?
lets cache interruptor instance. If JIT leaves double de-reference inside the loop - its bad
I think it is unnecessary to use synchronized here
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
I would use the canonical name here, to avoid having two classes marked as equal but have a different hashCode
Has to be public? Can't be package private?
It's better if you could make a function like getStringWithFormFieldId(String formFiledId). You could call the function getStringWithFormFieldId("clientID"); getStringWithFormFieldId(clientSecret);, ....
Wouldn't it be better to redirect the user to wondergem root in this case? I seems to me that this triggers a user being logged out instantly.
If these values can never be null they should be stored in int not Integer.
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
This doesn't check all fields. Use the super.equals() to check the parent class's fields and, if that returns true, then check this class's additions ((volumeSize).
- [x] I think you should wait page loading only when execute script that click button. How are you think?
The local var is useless, you can remove it.
java boolean result = false; final DetailAST parent = colonAst.getParent(); if (parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT) { result = true; } return result;  ----> java final DetailAST parent = colonAst.getParent(); return parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT;
ofNullable maybe, no?
It seems updating the delegateAvailable every time this is invoked would be remedy the issue of having another timer task?
The error message doesn't match the actual behaviour.
Could we get a deadlock now in some cases? #reset holds a lock for the outer ProxyWhitelist, and when this is called it will also acquire the lock for the delegate ProxyWhitelist. Do we know that the locks will always be acquired in the same order? I would be surprised if there are cyclic references between instances of ProxyWhitelist, so my guess is that it should be fine, but it would be good for someone to confirm.
Don't we have to say that this is uniqueId JDBC?
Same here for doing empty check instead of non null check.
does setBrickPosition do something different than brickPosition in all other brick tests? if not, please rename to brickPosition
Why do you need to check for null here but not at the other queries above? I think it is better to change 0 : result into 0d : result for readability
It would be good that user can resize the dialog box. If you do that set also a minimum size.
I have some concerns about this. 1. Wouldn't this make crashlytics run in debug mode as well? The old Crashlytics didn't "ignore" things in debug, but we definitely don't want them reported. That was why it was in the if...else in LoggerStarter. 2. The reason for crash logging to be initialized in LoggerStarter is b/c if the content provider is accessed through a Context which is not ours (like if we export our data), then our Application does not get launched so crashes would not get reported to us. LoggerStarter is initialized in the content provider, which circumvents this limitation. 3. Does this create a Twitter singleton that we keep around for the lifetime of our app? If so, that seems like a waste of memory since we only use it for the login stuff and even then only for vendors who actually use twitter.
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
Restore the spaces.
Might this be clearer as: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return capabilityLimitMap.getOrDefault(capability, UNLIMITED_STORAGE_AMT_IN_MB); } else { return capabilityLimitMap.get(capability); }  This captures the logic of subscription licenses having unlimited offheap by default quite succinctly I think.
Should this be marked as deprecated as it is in Page?
SINGLE_THREAD_FOR_AUTOBATCHER?
-1 just noticed now: forgot about skipExec here. This must also be handled, otherwise it will be ignored now.
I'm thinking that we should make this protected so that it can't be inadvertently called unless the subclass explicitly makes it public and provides the right Simple annotations.
Same as JDBC implementation, select the smallest globalIndex for an event on or after given date. Subtract one from the result to ensure first event is included in the openStream
I don't understand that this line is saying.
the ConnectorTopology.NONE is one of the supported connectors of the this component. So i don't understand this filter here.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
As is the case for the UMLDiffExtensionPostProcessor, this creates a totally useless post-processor. Change the call so that it reflects the plugin.xml declaration : super(Pattern.compile("<LINK_0>\d.\d.\d/notation"), null);
Thinking out loud: - This method is doing almost everything we need: it creates a CompletableFuture that is completed if the callback is called (send success/failure). - The only missing bit is canceling future after timeout elapses if future.isDone() is false, which can be accomplished with a ScheduledExecutorService. I know this is exactly what CompletableFutureUtils.failAfter() is doing but I think the logic over there is more than what's absolutely necessary; we don't really need the other CompletableFuture failAfter() creates or the additional logic in within(). We can just cancel this same future if it isn't done when timeout elapses. java scheduler.schedule(() -> { if (!future.isDone()) { future.cancel(); } }, _sendTimeout, TimeUnit.MILLISECONDS);  - future.cancel() causes a java.util.concurrent.CancellationException to be thrown, which means we don't have to construct a TimeoutException ourselves because a CancellationException can only mean we cancelled it after the timeout elapsed. This seems like something this method can do with a private executor service. I am not sure we really need a utils class just for this purpose.
Maybe we should cache the BluetoothManager in onCreate instead of the BluetoothAdapter. Or both.
It probably makes sense to set up a timer to get some metrics about the download times. Similar to: <LINK_0>
These triggers should have a type retrievable from the generic type that does not require comparison to the interrface
suggestion moveSequences.add(new ArrayList<>());
I'd prefer Assertions.assertThat(connectionPoolFactory).isInstanceOf(OkHttpClientConnectionPoolFactory.class). That way, if it fails, we have a decent message :-)
I think it is better to do that on the code calling it, and in the getter.
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
No need for getInstance(), the container can be passed
yuk! a System.out! Either remove or use a slf4j logger here
I think this can be private. Also it seems that its only use immediately makes an ImmutableList, so maybe it'd be better for this method to just return an ImmutableList.
@dalifreire this doesn't throw IOException anymore now, you're just creating a stream on a Strings bytes :)
It is permitted, but discouraged as a matter of style, to redundantly specify the public and/or abstract modifier for a method declared in an interface.  <LINK_0>
this debug is redundant
Remove new line.
please use org.apache.commons.lang.StringUtils IsBlank()
I suggest to keep the order consistent for easier reading/comparison: * field declarations in StashNotifier (maybe) * setters/getters in StashNotifier (maybe) * default values (lines 751-758) in StashNotifier::configure * assertThat calls (lines 27-33) in ConfigAsCodeTest::should_support_jcasc_from_yaml * setter calls (lines 40-47) in ConfigAsCodeTest::should_support_jcasc_to_yaml
nitpick: don't need keyword public
does it need to consider Windows?
Should we maybe wrap other throwables in a RuntimeException here? Or throw a new RuntimeException? Seems inadvisable to just ignore an error. Someone who's already using this might see an AggregateException with no causes.
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
Is this correct? Based on the definition of the special day entries in the DLMS Blue Book I would expect a long-unsigned value (newUInteger16Data).
Please have a default value (unknown-development?)
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
should be "*notconfigured-it.war" Double check the folder because not sure how this passed.
Move String values used more then once to a constant.
Label should be reporting.parameter.onOrAfter
nit: you could also move all the setUpServerChannel() calls
That's good to know.
Map
UnlockImage is performed anyway, so it can just be removed out of the if-else.
please use NotImplementedException()
I think in these cases, assertTrue() and assertFalse() would work better. It's quite a long read now :) Please consider.
why final?
HashMap should be good here I think.
emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet()
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
I would ignore empty notifications and would log warning.
So, this seems a really long way to get from event to orders. Go via SoldProduct, thanks to @martijnjanssen
We try to prefer these to be the proper enum for the getter/setter methods, with the translation of char<->enum hidden inside of the getter/setter methods. That way we store the smaller char in the database, but application code isn't exposed to the database's insane char based storage.
There must be a more succinct way of doing this using streams.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Use the solution in the large Overall/Manage PR instead, please.
diff - source.readInt() == 1 ? true : false + source.readInt() == 1
Since we are improving this code anyway, I think we should switch to using [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, since lowercasing a string is not always the same for non-ascii characters.
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
Use Iterators.transform from Guava?
Use same order as the field declarations.
As discussed before you can use WorkbenchContext for this
Is there any reason to do that here rather than encapsulate the logic in the constructor of NewExternalSubnetModel? Especially when as far as I can see, it has to be called whenever the dialog is instantiated.
ArrayList is non thread safe. We should use a CopyOnWriteArrayList
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
catch IOException and rethrow to avoid wrapping an IOException with an IOException
If shouldSchedule() and shouldRun() are overridden, the if is not necessary here.
Looks like the ListRejectAttributeChecker could be used here instead.
System.out.format instead?
Are there any const that can be used instead of duplicating strings like this?
attr.length() doesn't do anything here, you can remove it.
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
This needs to use justOrEmpty as the response value can be null which is an illegal value in a Reactor stream.
Maybe check for if name ends with ':' so we don't do a double one?
suggestion private <A extends Annotation> Optional<A> getAnnotation(Class<A> annotationClass) {  Avoids the "suspicious call" warning on annotations.get.
Can we add a log message with the iteration number, size of workload, and computationSpeed before each iteration? This could help authors debug their optimizers. (Since the computationSpeed doesn't change, we could log that once, on initialization if preferred.) Maybe we can even log this once on start and once on exit?
Same here, would be better to leave it on the previous line
Should this return Flux.error instead of throwing?
firstDigitsCardNumber is already a String
Are you sure this is right? Please double check.
Better to return "";.
something is wong with the indentation, please fix.
@dmzaytsev let's inline this
needs check for stats == null
You could do the same thing by doing @Test(expected = BluefloodServiceStarterException.class) I would say checking for exit code equals -1 is not that important to do.
Please keep this.cell near the related fields (previousFamily & cell count) below
Should those hashcodes be hardcoded ? They depend on HashCodeBuilder.toHashCode() implementation.
I am not following here - why do we want this in sync block?
final
Ok if already stopped? idempotent?
Better to organise this in a double empty try-with-resources idiom: java try (Closeable ignore = level1; Closeable ignore2 = level2) { // Just for closing }  To delegate boilerplate exception and suppression handling to the Java construct. If it appears unnatural, you could extract this in a utility method, e. g. called  void closeBoth(Closeable, Closeable) throws IOException
Why is the call to trim() necessary? If it's necessary, I would move it to the client.
Might be worth having a displayName?
Even if core.worktree wasn't set in the configuration file, it might have been set by the caller of Repository. We have like 8 forms of our constructor that takes various arguments... one of those is the work tree path, which could have come from an environment variable.
For loop?
Should we also have the same tests for the email template?
call _loadTaskLogs_?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
Can be simplified:  private String getTemplateDirectory(String template) { String templateDirectoryName = infrastructure.toString().toLowerCase(); if (infrastructure == k8s){ templateDirectoryName = k8s.toString().toLowerCase(); } return format("/templates/factory/%s/%s", templateDirectoryName, template);
We need to get out of the habit of returning null when bad things happen. It's a SUPER bad practice. ANd it leads to exactly this kind of defensive null checking that clutters up code is distracting.
You have to configure formatter in IntelliJ
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
return Status.BACKUP_FINISHED.equals(status) || Status.RESTORE_FINISHED.equals(status);
this method deserves a description
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
No key for encryption? ;-)
Could return a Collections.singletonMap(key, list)
Fix the method name with impl$ prefix.
use ShellIsAvailable
throws
Maybe we should use ordinal and values()[offset] instead of writing the entire name? And actually do you find the Externalizer for enums, are they worth it still?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
URL Encode
Shouldn't be here a warning log and in else branch the actual code - setNotificationService(notificationService.get()); ?
you could use a newly added utility to get the color based on the state color to avoid "white on yellow": Color stateColor = gc.getBackground(); gc.setForeground(Utils.getDistinctColor(stateColor.getRGB()));
clusterVersion can never be null - if there is no cluster (which is not likely to happen), then 3.0 is returned by ClusterUtils#getCompatibilityVersion so 124-126 is redundant - can be removed
In UserPortal, TabModelProvider#getCommonModel always returns null because UserPortal's ApplicationInit doesn't call CommonModelManager#init at all - there's no CommonModel instance in UserPortal. This could be refactored into something like this: if (hasModel() && handleItemsChangedEvent()) { ... } with new method in TabModelProvider: /** * Returns {@code true} if the associated model instance is available to this model provider. */ protected boolean hasModel() { return getCommonModel() != null && getModel() != null; } with UserPortal-specific override in UserPortalDataBoundModelProvider: @Override protected boolean hasModel() { // Don't call super, there's no CommonModel in UserPortal return getModel() != null; }
change to List
declaredOuputStreams is too verbose. the variable/method can be outputStreams/addOutputStream.
This is less noisy and reads better:  import static org.hamcrest.Matchers.startsWith; ... startsWith(BASE_URL + "/customers/")
java postRunTasks = null; return Mono.empty();
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Can't we just set without compare?
The raw data shouldn't be removed here. The raw data is allowed to contain invalid routing data.
pvk should not be visible. Please remove it.
unnecessary array new: {{true}, {false}} should work here
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
Map.put already returns the previous value, so this can be simplified.  public int setExtraData(int index, Vector3i pos, int value) { extendExtraDataTo(index); Integer prevValue = extraData.get(index).put(pos, value); return (prevValue != null) ? prevValue : 0; }
that class would be better with a builder, though I wouldn't ask changing it now
suggestion return Objects.equals(this.getName(), actionParameter.getName());  The reason for this suggestion in general is that it handles nulls properly, e.g. if this.getName() returns null the previous implementation would crash
suggestion timer = getMetrics().timer("file-read");
Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
This is no place to update a cached member. Either do it properly or don't do it at all.
I would consider cleaning this up using JSONObject -- since this JSON is currently pretty simple and this is only test code I wouldn't let this stop ship. That said, I'd much prefer to see something like the following  JSONObject json = new JSONObject(); json.putString("id_token", TEST_IDTOKEN); json.putString("access_token", "blah blah"); ... return json.toString();
docIds.size() > 0 -> !docIds.isEmpty()
if (!isConnected()) { return; }
Why are you using an Iterator instead of a for loop?
please use {}
I don't see any problem with prohibiting x-site backup to/from a LOCAL cache, but I'm not that familiar with x-site configuration and I don't know if it's possible to do that validation.
Maybe we can extract out the always blocking filter; would be more readable.
Could we extract this logic into a separate class? I'm worried that the BuildView is doing quite a few things already.
Don't we want the normal artifact lod of the alt allele with the highest tumor lod? Say we have two alt alleles: A->C and A->AC, where A->C is a real somatic mutation and A->AC is just an artifact. Let's also assume that A->C has a higher tumor lod. Then we do not want to filter this site even if we get a high normal artifact lod for A->AC.
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
can be replaced by List.of
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
I am wondering where is it better to add this check here or inside RexBuilder#makeFieldAccess. Clients who call RexBuilder direclty will still get the NPE.
return this.parent == null ? this : this.parent;
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Definitely use parameterized logging here instead of string concatenation, because otherwise this method will be generating garbage objects on every call!
Use this(...)
Shouldb't be this i18m
Are these returns used anywhere? If not, might as well make the method void. Applies throughout.
Nit: Why public?
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we can say "don't do that."
We want to allow a null value for the LDIF file, since it is not required for the developer to provide one.
This is unnecessary, its called via canFillFluidType() in super.fill().
If this is just for test validation, why not verify the pojo instances instead of doing the toString conversion?
@apc999 This needs to be public or reflection will not work
I think we should treat this like we do in Data, and assign currentTime if ctime <= 0. Don't let bogus ctimes be passed in.
ServerSocket implements AutoClosable, so try (ServerSocket s = ...) {} might be stylistically better?
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
I agree hashCode() and equals() should be done same way, it should be changed for PackageMaterial as well
fos can be inside try ()
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
Same here, would be better to leave it on the previous line
nit: This seems like it should be a separate test (the name of the test would lead me only to expect line 84, not this one).
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
You can remove the super();.
Usage of StringBuilder would be more readable IMO
consider saving the value of group 1 and group 2 here rather than the whole matcher
maybe a log message here?
but this doesnt solve the issue, even if the events are disabled in the config eventsRefresher will be created because it will pass the first 'if' statement (above) why not adding the check for events to the line above?
can we validate that we actually have UQ tags?
Safer to check if entry already exists for the given table. If yes, re-use else put new one.
"" + x.doubleValue() - is this the most elegant way to get a String from a double...? And if it is a usecase to instantiate a QuantityType without passing a unit, might we want to add a constructor for double as well)?
Please use a 2-space indent and braces around the throws block.
Wdyt about using a java 8 method to check lists ?  public boolean isRowSorted(List<String> info) { return info.equals(info.stream().sorted().collect(Collectors.toList())); }
hmm for node based traversal the traversal id is the node id so I think getTraversalId makes sense (more general) ? But yes, let's replace the edge parameter with the adj node id.
This is only valid because the empty version is defined as "0.0.0". But AFAIK it could have been "0" as well. So I'd rather use a "0.0.0" (or "1.0.0") constant here.
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
@dskalenko can you post me this tree? You can nicely visualize it in Checkstyle GUI: <LINK_0>
I think you can remove the surrounding if, it's quite safe :]
is this complete or startSnapshotApply? it seems the semantic of that method changed, we should also revisit the messages that are within that method.
You can get rid of this "if" if you implemented the suggestion above
checking at least the important fields like chromosome and position and alleles would be nice. just in case we are returning an object will all fields as null. Applies to the other test class too.
decrease to DEBUG
Its best to just do one atomic "test" per method in this class. I'd probably break this up into - testAssignVariable - testAssignVariableMultipleAssignment - testAssignVariableNotDefined Also note that junit has some built-in exception checkers <LINK_0>
Is null the right thing to do here as the default or should we do something like throw new UnsuportedOperationException()?
this should be catch (Throwable t)
import or create (considering we may not use the imported configuration)? there was a good patch by Liron [1] where he called that handleVmLease. not that important though [1] <LINK_0>
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
This looks weird
return descriptorToImageData.get(descriptor);
Same here, this can be boolean
might be better to return the exception so that you can directly see that it exits in the code throw dataTableHeaderMayOnlyContainVariableNames(column.get(0));
remote this
unrelated: this can do 'super(msg, cause)' now that we require Java 7.
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
rename to signature
This can be done simpler. I've refactored addSenderBuddyLinkIfAvailable as an example:  private void addSenderBuddyLinkIfAvailable(MessageDto message) { message.getSenderBuddyId().ifPresent(buddyId -> message.add( BuddyController.getBuddyLinkBuilder(goalIdMapping.getUserId(), buddyId).withRel(BuddyController.BUDDY_LINK))); }
Use dynamic string, please :)
nit: use SUBJECT
Why 0,8 if all we are setting is 7?
Sorry to be a pain, but we should use uk.gov.pay.logging.LoggingKeys.PROVIDER here, similar to how <LINK_0> does it.
Why is it a list of lists, not just a list?
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Are consecutive reloads necessary or will be one reload at the end sufficient?
there is no need for this.
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
Wouldn't we want to call s.beginTransaction() inside the try-block and then add a catch-block to determine if a transaction is active and rollback?
Subscribing to METHOD is only introducing confusion, and cause problem with the rule. Subscribing to METHOD_INVOCATION should be enough. When hitting a method invocation, you can then look into the map if something exist for that symbol. If it's not the case, retrieve the parameters names and add a new entry on the map. Then you check for parameter names.
Perhaps make it private so no one will be able to initialize it outside the class? It makes sense cause regular initialization will not do much without injecting the members
public?
Use of reflexion as per BaseLoadingListFragment.java
ArrayList should be constructed with fixed capacity.
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
To increase readability of this test I would just drop this statement, and move ifCond block inside if condition
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Immutable fileinfo
missed to implement
@ivandalbosco super minor: no space before !isDocStringsAndNotImplementedError(node)
other than the previous implementation in subclasses this doesn't create the directory anymore.
let's change the semantics of this class so it is not crossing thread boundaries unnecessarily, otherwise you need to worry about the SubscribeProcessor synchronization. I would add the following fields: private Publisher pub; private List<SubscribeCommand> cmds; AtomicBoolean exit = new AtomicBoolean(); Then the methods on the task become: private void setData(Publisher pub, List<SubscribeCommand>> cmds) { // TODO: check not null synchronized (this) { this.pub = pub; this.cmds = cmds; } thread.interrupt(); } private void exit() { exit.set(true); thread.interrupt(); } private boolean isRunning() { return (thread != null) && !exit.get(); } none of the other operations are needs anymore and then your run() method becomes a loop: try { while (!exit.get()) { try { Publisher p; List<SubscribeCommand>> c; synchronized (SubscribeTask.this) { p = pub; c = cmds; } // execute .... } catch (InterruptedException e) { // re-execute with the updated commands } ... } } finally { process.close(); }
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
move it to be aside of deleteFolder
could be static
We should also check the servers which we want to update the hook content is in UP state.
Switching ON admin mode...
Better do this as a static variable
Too broad a catch. IndexOutOfBoundsException should be enough.
judgment.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgment.getJudges()
This should check the endorsedBy field I guess, since that is what is displayed in endorsed responses.
We may need to put this behind the flag, especially if we want to back-port it to older GCS connector versions. We can enable it by default in master branch though.
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
Should use the log, maybe a warning.
UnsupportedOperationException ?
Should the name of the FileSystem be included in this message? Would help troubleshooting issues.
i think this might need to encdoe the name and bitmap type too.
Not related to this change but this should be spelled "Cancelled" to be consistent with method "isCancelled" of ProgressMonitor.
GPS should be caps
When using a byte[] buffer, I believe we need to capture the returned byte count because it will likely be less than the full array on the last read. As in: int byteCount = 0; while ((byteCount = in.read(byteArray)) != -1) { out.write(byteArray, 0, byteCount); }
Why does do all methods have to be inspected in the constructor, instead of checking for the annotation in this method, after checking the static list (possibly caching the result in a field so it does not have to be repeated on each call)? That way not all methods have to be checked for each instance created, which is quite expensive time wise. And I expect most methods will not be annotated. Furthermore if the annotation is NOT present a wait was required, so the time spent checking for it is most likely not that important.
Static import the assertion methods
Might this be clearer as: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return capabilityLimitMap.getOrDefault(capability, UNLIMITED_STORAGE_AMT_IN_MB); } else { return capabilityLimitMap.get(capability); }  This captures the logic of subscription licenses having unlimited offheap by default quite succinctly I think.
When is this case triggered? If a commit is produced only when all other commits referencing it have been emitted... how can it be reached again? Is this because some interaction with other generators?
Throw the proper exception if something is not supported: - NullPointerException if status == null or command == null. - IllegalArgumentException if frameID < 0 or if frameID > 255.
Same as above for otherNonCodedConceptUuid
Use Assert.fail() instead
ChannelClosed needs to be added to (though not strictly necessary)
Better to return "";.
MemStore is used for tests, so we need to implement this function.
is there a reason why this method isn't implemented?
You don't need to call .getValue() here, since the method neither does anything with the value, nor does it return it. You can invoke the API and leave it at that.
You could instead have a storeTTL option taking a string and parsed using DurationUtils, for more readable config. Actually I see other places already using storeTTL and using that so something is inconsistent.
Is it going to return null in case the request is not authenticated?
How would you feel about using more descriptive column names? For example, day(shipdate) as ship_day and month(shipdate) as ship_month? These 2 will give you values within TINYINT range and will have meaningful names that are easy to understand.
I would separate the message that should be logged as info from the exception that should be logged as debug as we don't want to pollute the log with a stacktrace at all times.
hope you know the diff between ceilingKey() and higherKey() and you are using higherKey intentionally
Remove all "null" cases. There is a default case for that.
Now the commit action is not enabled when I select a non-project resource. The method getRepositories does only work for projects.
This should not be registered on an HC.
Remove
This seems like a logic error here (alternate output is either some string or empty string). I cannot see a situation where alternateOutput is null.
suggestion return Optional.of("org.junit.platform");
Missing StringUtils.isNotNullOrEmpty() check
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Instead of loading the classes here, why. not just iterate over compiledObjects.values()
As a nit, should have a null guard here.
If this is not used you might want to throw an UnsupportedOperationException
static importa
Why do we return the parents name instead of the name we store a few lines above?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
nit, Collections.EMPTY_MAP?
I don't know, but isn't the class also of interest?
why is it adding null?
FWIW, I benchmarked Math.pow(k - m, 2) vs (k-m) * (k-m) and there is no difference in performance.
other.updCntrs?
In fact this test is not useful, the framework will fail to start if the injection can't be processed.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
please reuse the constant
see below re: spaces
@dmzaytsev ThreadInfo can read currentThread in Ctor, no need to pass static
Do not contacte file paths. Use HomeDir.toFile().toPath() and resolve from it.
IMHO better "HashSet". I don't see that you use the iteration features of "LinkedHashSet".
Simple for-each?
Would be better to move this resolution to the afterPropertiesSet() if we can't inject an errorChannel from the @Configuration level.
ChannelClosed needs to be added to (though not strictly necessary)
hyperlink
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Wouldn't it be better to only show iterations OR epsilon?
should probably be named m
no need to extract this out to private method if it's only being used here. same for onClusterRemoved
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
Don't forget to update this
put(uri, stream) on a concurrentHashMap avoids the "synchronized"
please remove newline
this for is exactly the same in all the array tests, let's move it to a private method
Why we don't call onDestroy() method of playerSkinLayoutController as early?
nit: public abstract void
Same here regarding the messages.
Either call getComputedValue(buffer, ...) here or remove the second signature of getComputedValue since I don't see it used anywhere.
Absolute or just path?
Can we compute this lazily only once hashCode is called, then cache it in an instance field?
Why this change?
No need for 0.0.0.0
local variable e is never used.
Load and termination parameters should belong to Load and Termination entities
For loop?
There should be a white space before else Also you could use word.charAt(i) in both the if and else statements (e.g. word.charAt(i) == 'y') instead of using substring, that might make it a bit more obvious what you're doing
why you change the sequence here?
Don't rely on the JRE platform encoding here. Use a specific encoding, like Constants.encodeASCII(). This also applies to the other getBytes calls below.
Aren't there any test methods that require compatibility?
lowercase for package names.
nit: verify(callback, never()).run() before this
this change is not correct for other content where Payload is used, obviously it has Base64 encoding there
"This method is not actually very useful and will likely be deprecated in the future."
Couldn't this just check unavailableException if it is null or not? Seems we wouldn't need the managerAvailable variable as well then.
Please throw NullPointerException instead (also, use braces for the if statement)
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
Why is it a list of lists, not just a list?
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
I think it can be logged with WARN as this is situation that we create ourselves and we are aware of it, so it's not really an error.
I don't see why is isConnectionSetup() necessary. Shared in SharedPubSubWebSocket client means it is shareable and must support concurrency. It should be the responsibility of SharedPubSubWebSocket to ensure that its state is properly managed and if setup() can't be called concurrently, enforce it.
The test is OK whereas it shoulf fail as the code fix is not merged
deserialize can return null.
Add name to exception message
null? why not just a () -> {} ?
UOE instead of ISE (x3)
Is this an error condition or just timing? When will it happen?
Formatting
I think you should dispose the ShapeRenderer here.
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
can this use submit?
Are we sure that getCanvasHandler() and event.getCanvasHandler() are always not null values? Otherwise, I think we should use Optional.ofNullable(..).
Ok if already stopped? idempotent?
Can be simplified: java return HashUtil.combineHashCodes(Objects.hashCode(ul), Objects.hashCode(ur));
Why not in combination with above do this: setValue(value, false);
extract private method boolean waitForOperator(Operator operator, Duration timeout):  try { operator.isBlocked().get(timeout.toMillis(), TimeUnit.MILLISECONDS); return true; } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException("interrupted", e); } catch (ExecutionException e) { throw new RuntimeException(e.getCause()); } catch (TimeoutException expected) { return false; }  and build assertions around this method
you could just do setConfirmWindow(null); like above method
We should store LongMetric inside object instance.
Not sure I like this. This starts a new thread where we retrieve the access token. I'd rather we do the token retrieval right at connect time. If we need to spin off a background thread (which it looks like we do) we should do that and complete the connection stuff in a callback to ensure things are done in the proper order.
does this method need to be public?
Please use @BeforeMethod(alwaysRun = true) insted of init() inside of test body
space before trailing {
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
Need to remove codec from here too, right?
Does this cope with the case "The previous session ended in a crash. In other words, one session can only have 1 crash at most." in the project definition? Should we also check if there have been unhandled errors?
The message should be "definition is null". Same for all other requireNonNulls
(SlimefunItem.getByID(getId()) WTF...
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
m_totalAvailable needs to be cleared as well.
FYI All instances of HardSoftLongScore.ofHard(1L) may be replaced by HardSoftLongScore.ONE_HARD,
Why do we need to first slice and then also duplicate ?
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified label, and he selects "yes" on this option?
does this need to catch all exceptions?
Access
This is another minor nit, but this routine seems oddly written. The variable pos isn't really necessary.  public int getIndexOfCriteria(FilterCriteria tm) { if (tm != null && mFilterValues != null){ for (int i = 0; i < mFilterValues.length; i++) { if (mFilterValues[i].equals(tm)) { return i; } } } return -1; }
use the interface here
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
mark this method private as this is only used in this class.
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
Another place where we could note that the boolean is unused.
Why do we play with environment variables in both MesosMaster and MesosContainer? I know, it's not exactly about changes in this PR ;)
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
VmDeviceUpdate::getName
See UseCase.
suggestion if (this.currentTask != null) checkAndRethrow();
Personally, I'd prefer to format it like digests elsewhere as <hash>/<size>. WDYT?
I notice a bunch of tests that use camel-undertow have been switched to WAR. Are we now mandating WAR for any camel-undertow consumer usage?
Shouldn't this be wrapped in a try... finally block?
Locale.getDefault().getDisplayVariant() works for me but getScript() returns an empty string.
Please remove that
can we use sysprop or something for url?
I would put this on the failure path: if (!d.mkdir()) { if (skipExisting && d.isDirectory()) return; throw new IOException(...); } Because odds are the caller wants to make a new directory and we can reasonably assume it doesn't exist yet. If it does, we'll fail on the mkdir and check its mode, if its a directory, we're fine, if its not, we fail.
This is the replacement for [this](<LINK_0> We might want to consider --non-interactive at least.
Is this change related to supporting commit validation by plugins?
The message is missing.
Merge conflict. This should be comparing width to x and height to y
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
You've got some auto formatting thing on which basically adds "this." everywhere. You may like it, but it makes for a very noisy diff :-( This diff Should be a 2 lines fix. There's no need for the incremental approach here either, given that it's a trivial change. Making it an incremental PR just delays it's acceptance.
@ekondrashev Too much indentation for lines 61-64, move them back four spaces.
you might want to make 10_000_000 a constant
inline lists
nit: are we just checking that it doesn't throw? if so no need for the class check
nit: you can merge both lines above as checkNotNull will return the given argument
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
I am curious couldn't we just test this by default given that all schemas need to be present in "schema/" directory. we could just load all of them and based on what schema xml reference test that by default. Overriding is still fine for all corner cases but by default it shouldn't be needed.
I'd need to check, but this might fail in when poolId is null or empty. If so we need to wrap this (and other lookups in similar methods) in a null or empty check.
Args need to be included in operation.
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i = ...; if (i == -1) { return false; } mRoutes.remove(i); return true;
This wouldn't take the precision into account so if the other method would return a fully qualified host name, this would always return that instead of a substring of it.
I think JPA requires this to return a Long
nit: extra line after if
It's useful to put something like this here:  java LOGGER.info("Groovy console starting...");
Use guava's firstNonNull: return firstNonNull( overridden.get(permissionName), Collections.<PermissionRule> emptyList());
minor static import isWhitespace for readability
if second is not present, you return empty if second is present but has all fields absent, you return first Why? Leave some explanation in the code. (here & a few times below)
Please use: return !steps.isEmpty();
Maybe wrap in an immutable map.
nit: Should be public. We're only using this inside of the package, but there is no reason to restrict it, and it should have the same visibility as the constructor, since it is just a shortcut for the ctor.
This version check could be removed as we already move to 2.6.x
Why absent?
We might not need this setup method as we are doing the static mocking within the test method.
checkState
it looks like you have to adjust this one to your recent changes -> see pr build on travis.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Fire the event outside of the monitor.
Why not check the flag directly on symbol then ?
- Tested at 199 dpi, it gets mapped to 175% zoom.. reason being zoom is an 'int' and it looses it's precision in above calculation, instead it should be float.
So we decide this class to be a leaf ByteCode Node? (Alternative would be make this returns ImmutableList.of(block, position)
Please remove the maverick ";"
This filter lead to me to look at the factory again and ask about why/where the exception would be thrown! It seems strange that a factory could NOT return a concrete object.
same here - result should be null
Nit-pick wouldn't Assert.assertThat(v, allOf(StringStartsWith.startsWith("jar:file:"),StringContains.containsString(dir.toURI().getPath()),StringEndsWith.endsWith("::hello"))); be nicer... that way you have one assert and if failing it will report exactly how it has failed... otherwise you have to run the test three times to ensure you have fixed all the potential issues: - oh its not got the right start... fix and run - oh its not got the right contains... fix and run - oh its not got the right end... fix and run vs - oh its not got the right start, contains and end... fix and run
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
I think JPA requires this to return a Long
exactly one sort key is required for RANGE units
According to the current way how those methods are implemented, it should be return false
Switch the order of getting the mean and filtering:  java segments.stream().mapToDouble(ACNVModeledSegment::getSegmentMeanInCRSpace) .filter(x -> Math.abs(x - 1) < 0.1)
Check for null
You can use e.ordinal() instead of e.value, and remove the value field.
Isn't the result always of length 4?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
rename to childItem
should the message include "command _with options_:" + this.options ?
There should be an assertion I believe ;) assertTrue(conflicting.contains(...)); And probably alos useful to check that model.di and model.notation are not in conflicting state in the git repo?
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
Should this be protected, or do we really want to allow to call it outside this class?
Looks like these two typeTextIntoEditor commands can be united into the single command:  editor.typeTextIntoEditor("\n\nobject = MyClass()\nprint(object.");
use: import static org.hamcrest.CoreMatchers.instanceOf; ... assertNotNull(result); assertThat(result, instanceOf(ClassName.class));
Is these method guaranteed to be called only by sync method (at least from us)?
Can just return this overloaded method's result rather than requesting the record twice.
Maybe we want to keep something similar to what id was before
If you remove the condition, the retry analyzer instance will never be null. Better: DisabledRetryAnalyzer should be the default value if clazz == null unless you think the null value is important.
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
Capitalize Thrift (or remove the word)
Have you considered <LINK_0>,%20java.nio.charset.Charset)
Please use static import where-ever possible
why public? Are we planning to use it outside of this class?
I'm worried that the current pretty print version of points is not only very verbose and will take more space in the index, but also that prettyPrinting is something that will change easily, and result in the need for index recreation. Perhaps we should have another method on Point for index printing that we do not need to change. The current PointValue.toString is actually a better choice, but could be copied to a different method for indexing only.
I think we should replace our new ArrayList<>(...) constructs with List.copyOf(...) especially when the list is immutable.
should this count be parameterized?
This combination of while and if-elses looks hard to parse. Could you simplify the logic a bit?
List#isEmpty()
method reference
Those two methods are similar. Consider using one.
License header is missing
I don't think we should call abortWorkItem here as the work item most likely won't be there as it failed to execute.
Possibly could store this in a field to avoid creating 3 objects every call
The method name has been refactored, but the log statement still uses the old name.
wouldn't this fail if pattern was null?
Should you attempt Path.toFile() here?
shouldn't be setDaemon(true)
about this API... for Cedric's VM, I just had to implement something that may change some style value for specific events. I'd like to just be able to update one style value, but the returned style map is read-only and for just cause! You could add a method Map<String, Object> getSpecificEventStyle(event) that would return only the difference and this method would merge the 2 maps if not empty. This one can be final.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
It's confusing that find**Literals** returns a list of ExpressionTree and not LiteralTree. Similarly at line 157 checkEqualityAssertWithOneLiteral has an argument named ExpressionTree literal, while it can be something else than a literal (a typecast). Why not working with LiteralTree everywhere instead (extracting the literal from the cast)? (it could also enable you to avoid a second call to isNullLiteral at line 159)
Could the instance var metricValues be dispensed with and the following done instead? java @Override protected void prepareMetrics() { long now = System.currentTimeMillis(); if ((lastUpdate + minimumRefreshDelay) < now) { recordValues(updateFromZookeeper()); lastUpdate = now; } }
I don't know what has been @sjka intentions and I agree that this could be removed... ... but didn't we have a discussion in another topic where you / Kai argued that we cannot rely on correct usage WRT to the nullness annotations for code that is called by third party ones (e.g. binding developers etc.)? So, if we don't trust non ESH framework developers that he uses annotations classes correctly, isn't that exactly what you want?
Please verify the returned can-do-action message is VdcBllMessages.GLUSTER_TASKS_NOT_SUPPORTED_FOR_CLUSTER_LEVEL
Just for consistency, please use final boolean actual
this ought to call verifyNoAsyncErrors(defaultTimeoutMillis())
What's up with this last one? Should it be in the finally block?
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
As in add command, no need for this to be here..
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
safety might be to filter first stream().filter( it -> it instanceof AbstractDescribedNode)..anyMatch(it -> ((AbstractDescribedNode) it).getDescription() != null)
@carl-mastrangelo I wonder why we not just use: java return AsciiString.contentEquals(s1, s2);
can be delegated as: putByteProperty(key(key), value)
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
This is strange.
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
I found this code called so many times during app execution. What are your thoughts about using a pre-compiled regexp to split the strings? private static Pattern languageSplitter = Pattern.compile("_"); and then use it with String[] opts = languageSplitter.split(languageCode, 0); Do you think that this will improve performance?
This is not needed anymore... now you can just return id
Default value is false to keep existing behavior for Mars dialogs
should hashCode really depend either on taskName, or description, or hashCode?
if service is not present it should throw error? same question to the other methods
Create your own session to make the property to be true.
I believe the conditional above will need braces otherwise this is considered outside of the block and will always execute, which may not have been your intent due to the indentation. If you did want it to always execute, you should update the indentation to reflect that.
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, NON_CANCELLING, EMPTY_VALUE);
should probably test for null delimiter and either ignore or preferably interpret null as "no delimiter" (the empty String)
this method seems to have some duplicate tests; to make it easier to read, consider creating a map between a pair of WKT shapes and a boolean indicating whether shape 1 contains shape 2, then loop over the map to test whether ST_Contains returns expected results; this way it will be easier to see which portion of the test matrix is covered and which is not and whether there are any duplicate tests.
Confused about the change of signature... what about keeping the field as Boolean for XStream, "boolean" for the methods, and then do a null check inside the body?
I don't see the point of having a cancel action in a subtab.
we should log a warning here so that users who have wrong permissions on ~/.gitconfig by mistake have a chance to detect the problem
Shouldn't this be !=?
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
audit log ? setSucceeded(true) should be added IIRC
You can inject the header variable in this class too, to avoid dealing with static methods.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
Local variable could be declared List instead of ArrayList. Is this worth caching?
i18n?
This could be confusing here. How the user know the all fields?
ObjectMapper is fully thread safe, we can have it as a single static variable inside this transformer class (also because we do not configure it differently per method usage)
This should never have a null value. I need to work out how LeashData is going to work.
Instead of defining this attribute, it would be better to invoke countdown for the latch (initialized in the constructor)
This is used in the App: <LINK_0>
what about getUniqueId() with some escaping (e.g. URL encoded)? It gives you human readable and unique strings like:  [engine:junit-jupiter]/[class:com.example.MyTest]/[test-factory:parameterizedTest()]/[dynamic-test:#3]
Don't call row.getDimension(dimension) twice. Please extract a small class, don't inline. It's unreadable.
For consistency, this should come from the Builder
Please remove printing to stdout
use static import.
Use StringUtils.isNotEmpty instead
nit: can be final Vector<URL> resources = new Vector<>();
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
nit: put the whole statement on the same line; ditto other methods
Are these mock objects used?
This class seems to have too many responsibilities in it. It looks like that in addition to it being a model, it also has knowledge about how it should be displayed in the generated code. Split these two responsibilities out.
I'm pretty sure BasePanel also has already the dialogServie object
Get the service registration reference and unregister within the deactivate method
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
the 10000 looks like a wrong digit.
declare throws please
I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.
You can remove this since hasNext will call checkInvariants
warn maybe? and not sure if we want the exception. maybe just the message?
again - encapsulation
constant or lineseparator from system?
does this need to be calculated on the fly each time or can we save the iterable?
Just let the exception bubble up, otherwise it can be confusing to debug IOException ' s.
IMHO, for things like variable naming, local consistency is arguably more important than global consistency, so naming this e is best. If we make a global change, I would prefer to rename variables of type Throwable to e
Is there a reason not to check (offset == 0 && length == array.length) here, and only wrap if that's the case? Is there a performance advantage of ZeroCopyByteStringUtil.wrap(array, offset, length)?
What does the above line mean?
Please use Objects.equals(...) (<LINK_0>,%20java.lang.Object%29) instead of manually check for equality.
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
We'll probably need to move this return out of the catch-block if we're going ahead with this. I'm guessing currently we get an NPE that blows up, so the change makes sense in general.
return symbol != null ? symbol.qualifiedName() : "";
Also what happens when there is a non-ASCII character ?
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
studentsWhoRespond -> studentsWhoResponded
return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA()));
can be inlined
I'd remove the whole guard, and simply return null (mSessionID MUST be set to null when the session has left a realm already - and of course it must be null when the transport is detached then too)
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
this is for ensureConceptIsSet
Is the throws InterruptedException declaration necessary?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Why there are things that are irrelevant to this PR? Although we need sanitise field here.
suggestion if (Validate.classExists("jakarta.ejb.EJB")) {
Can we stick to just probes? So name it scheduleProbes?
Shouldn't we add the Transmit options field here?
Define "data-agent-conf.xml" as a constant
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
Should this return getDefault(); instead, so have the default specified in fewer places?
Are prepare commands with 0 modifications that common?
I suppose we can pull this out to a static class constant.
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
Why is this check necessary?
suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task));
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
You'd better use a logger here to ignore the exception or propagate the exception using Throwables.propagate
this.subject = checkNotNull(subject, "subject");
If you don't think we want to expose it to the user, then I wouldn't include it at all. We can always add it later if there does seem to be a need for it. However, if this is part of building the response, then don't we need to include the version so it can be used for choosing prior versions to roll back to? Or at least, you need some kind of unique identifier for each version to enable that feature. If we don't want to expose the real primary key of that table, you could use sequential integers for each version (sorted), or something of that nature.
Oh yuck. ;)
style nit: we don't use braces around single line blocks
change "get(key)" to "redisSet"
suggestion blobSoftRef = (BlobSoftRef) field.get(accessPath.apply(descriptor.getReferenceInstance()));
Weird sentence structure. Why not Illegal choice for parameter foo: bar?
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
How about replacing these four lines with:  this(topic, Objects.requireNotNull(task).connector(), task.task(), discoverTimestamp);  and then removing the TODO line?
I think this should be done in the constructor rather than here - or at least, in the if-clause of this method. Otherwise we risk adding the instance as a listener multiple times for each getInstance call
The same Arrays.stream() can be applied here as well.
Wrong event name and bi value is getting passed here. It should be **VIDEOS_UNIT_DELETE**
I think it would be enough to check if affectedKeys is not empty, either on the originator or on the owner. After all, the invalidation will be done only if there are requestors for a certain key, and that will only happen on the owners. But that still sounds a bit expensive, couldn't we use the same L1WriteSynchronizer approach as for non-tx caches and invalidate only from the primary owner instead?
Please update this string to say "developer mode" instead of "debug build".
uuid can never be null here because if EntityPlayer.getUUID(player.getGameProfile()) were to return null you'd already get a NPE in line 44. Maybe use something like java UUID uuid = EntityPlayer.getUUID(player.getGameProfile()); if(uuid == null) { uuid = EntityPlayer.getOfflineUUID(player.getName()); } if(uuid == null) { CrafttweakerAPI.logError("Could not get UUID for player " + getName()); return ""; } return uuid.toString().toLowerCase();  Also, since I don't know these vanilla methods that well, can player.getGameProfile return null, and if it can, will getUUID(null) throw an error?
Are you sure that String.format is one of the effective ways to concatenate three strings together?
return List.of(new SimpleGrantedAuthority(getUser().getRole().getShortName()))
Minor thing: please use "something <operator> null" convention.
Perhaps rename the temporary directory as well
please decrease or remove this statement
:warning: requireNonNull on a nullable argument highlights that a UT is missing (could be testing that Optional.empty() is returned when argument is null)
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
Better to return "";.
remove
Why do we have min() within max()?
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
Shouldb't be this i18m
I think this can be set by spring application.properties without creating bean explictly.
I guess this will overflow maximum instructions per method before FIELDS_PER_CLASS is reached? Again, I wonder if it would be good to generate multiple companion classes.
Use KeyboardShortcuts.CREATE_RIGHT_PANEL?
Should also include context and suspend
FullTextSettings.closeAll appears to handle it's own synch needs, no need to mark this method as synch
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
Is there a reason we need the executeInternal() method, given we could just use execute() in the executeToX methods?
One last question. So we get and forget the returned result?
are you sure that == (as opposed to equals) is OK here?
Position position position.position. Hmm maybe there's a better name for some of these :thinking: Just thinking aloud, not the end of the world :+1:
Please just use a mod here...
why callback is null
These methods don't need to be synchronized any more due to the ConcurrentHashMap and the use of atomic operations.
Minor inconsistency: Return type is Boolean and not primitive boolean
Use isZKLogAvailable() instead
Shouldn't we throw here?
Shouldn't it be priority - Thread.MIN_PRIORITY (which is the same as priority - 1, but just by accident)?
I think this should just return null, similar to the default MyFaces implementation of InjectionProvider.
what happened to handling of nullables?
return tags;
I haven't investigated what exactly this does, but it looks a bit weird. I can understand if by default the logging level should not be DEBUG or so, but I would definitely like to see errors and probably also warnings by default (i.e. without having to investigate how to change this manually). Please disregard if I missed something.
We can replace this with: return date.getTime() / TimeUnit.DAYS.toMillis(1);
Lol! You're going to remove that, right :)
Sort of believe We should have MetricManager in parameter given this case.
Could this relatively general code be reused in the needsOrderBy method?
> "When providing an 'async-rest-template'... Correct? To properly reflect the reality.
Think it might be worth doing this in scanHttpRequestSend as well? In case Jso is being POSTed, etc. The method could be changed from using the msg to accepting the body.
You could simply turn this into !isEmpty()
You can make this a bit cleaner by calling data.isData() and data.isHole().
We might want to actually make isRebasing() a method in RepositoryState.
Looks like unnecessary microoptimization to use SearchKeywordResolver[2] instead of new ArrayList<>(2) which does pretty much the same as rest of code below. Is the impact actually measured?
Why static?
This is not going to compile. You can't return an object in a void method.
assertTrue(annotationMetadataMongo.isDefault());
I'd use getPathAsString instead of getName to provide unambiguous info.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
Ingest modules need to throw IngestModuleException if there is an error in startUp, with a user readable exception message, since it is displayed to the user. You need to wrap the NoCurrentCaseException in an IngestModuleException and throw, not log here.
Is there any other ID we have in relation to an envelope? Why do we need a longer name in this context?
why do we need to make this method final and none of the others?
Gson doesn't run on these versions so I don't see any reason to include them.
remove printlns before this is merged
You can do it in one line. More lisibility.
You can also use IO.close(bb) as IO.close will not throw any exception.
why that ? I think internalCommit() returns true if a job was scheduled
these should be 2 separate tests
bad hashcode.
Is that down-cast required?
This should be obtained from the i18n file in case there is a language specific reference. The solution should actually provide some guidance, this CS could be added to the references.
Should this be compared with || instead of &&?
vus always has lastEdit?
this.redisTemplate
This should be synchronized
Symmetry (throw)?
Would it be helpful for debugging purpose to log out a statement when this method is called. This way, we can easily tell from the log.
suggestion bean.setSourceList(new ArrayList<>());
does this happen or is it an error? Maybe just throw an exception.
These ones too.
remove when the export button is implemented
Can header name and value be null?
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Nit: Wouldn't it be good to move the settings to new lines? suggestion Settings settings = Settings.builder() // .put(loadConfig()) // .put("transport.type", "netty4") // .put("http.type", "netty4") // .put("path.home", this.pathHome) // .put("path.data", this.pathData) // .put("cluster.name", this.clusterName) // .put("node.max_local_storage_nodes", 100) // .build(); node = new TestNode(settings, Collections.singletonList(Netty4Plugin.class))
Don't put any logic in the descriptor, it should be pure data. Do everything in the caller.
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
Initialize this in the field declaration
I think the "if" is the wrong way around here. Or more precisely, we must always do the super.decrementInstallCount() The way to test if super.decrementInstallCount() is working as expected is: 1) insert breakpoint, observe it is a blue dot, no check mark 2) start debug session, the breakpoint should change to a check mark 3) Stop debug session and breakpoint should become a dot again.
you forgot to inline into one liner method as moti suggested on patch #1 .. :-) other than that - looks good to me.
pls format (>120 chars)
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
.event() is might be better
Use config.getTrimmedStrings() instead?
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
I'm probably stupid, but I can not get this code. Each time when one call subscribeForCursorsReset() there will be cursorResetCache built. call for isCursorResetInProgress is dependent on previous call. (and btw do not work all the time, cause StartingState is initialized before StreamingState)
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
The aforementioned "never return null" rule would be good for all the string getters here.
audit log ? setSucceeded(true) should be added IIRC
Can you add getId() and mark id() as deprecated?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
Please check if it is non null and running before you cancel it.
not needed, empty c'tor is just for satisfying gwt. its modifier can be reduced.
Does mean there's no signal for "the user typing out a correct entry, not clicking on the entry in the list, and then clicking on the next question" which results in the value being set? Clicking the ">" or swiping would do it, since that triggers a "get answer", but I wonder if, say, losing focus should also attempt to set it?
No need of this. Its marked as @NotNull.
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
It's hard to read the multi line string. it's better to rewrote it by using **String.format()** method.
please use Assertion class
nice - thanks!
Would it make sense to add something this.caches.clear() to the stop ?
Add a message to checkState so that it's easier to debug if we ever hit it.
@ILikeToNguyen Why the change in visibility here?
MessageQueue.RegisterBankAccount_EventMessage
these are both a bit sketchy cases where compiler should have issued lint message warning: non-varargs call of varargs method with inexact argument type for last parameter;
throw exception
Am explanation would be nice
Use UTF-8 Charset here and the getBytes(Charset) implementation (it doesn't throw an exception). This use depends on the default system encoder and if it were to change it'll be trouble.
Instead of copying the list and requiring a (potentially) unsafe cast. I think we could make more use of generics in ClusterManagerCallback.
What about testing with ALTER FUNCTION sin ... instead?
@fuss86 we probably need to check that there were no exceptions here.
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
can return Optional from here
So, would the PII information be provided as plain text? If so, isn't that a security concern?
please instantiate the list right above the check where it is used.
suggestion return Objects.equals(caseRoles, other.caseRoles) && Objects.equals(caseFileVariables, other.caseFileVariables);
This is hacky and might be error-prone. Since it is always a leaf node, it makes more sense to parse the string with path splitter "/" and return the last section.
This can be handled by waitForRunningTaskToComplete accepting a callback function to be executed that can contain the following code.
false? Why not null?
Do not assign to n. Let the compiler verify we set n in both branches below.
"[\W]", "_" looks simpler
nit: suggestion log.error("User [%s] had role [%s], but role object was not found.", user.getName(), roleName);
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
you could be more specific and check instance of Function0 maybe?
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
"0"?
nitpick: There's an extra space after the =
If the parameters were changed to (Processor processor, String key ...) there would be no need to create the List and unpack it.
you can either remove else or add pair of curly brackets
why not just use currentBlock.write(text) here?
These should refer to constants rather than the string literals.
can you add mountPath here
Why not just use fixture?
This method can give an incorrect result if the last buffer is moved from the inner queue (which is then empty) to the output buffer (which was previously empty) in between those two calls.
isRemote(command.getKey()) instead of false
VertexInfo vs NodeTopologyEntity.
I'd use startsWith(prefix), rather than calling this constructor directly.
Can we get the root class as a generic parameter of the aggregate class or, more straightforward, the repository class? If we can, we won't need to accept it as a constructor parameter.
Can we and should we check that the short index is shorter than the long index?
Objects.hashCode could have been used here
Continuation of the comme?t on line #242 - Please notice 'messageLabel' and 'externalLabel' doesn't have representation in the model. The fields you're manipulating in 'onPhysicalNetworkChange()' do have, so please move this logic to the model.
Agree with you. We will probably test this on different level.
Why it's "EXTERNALVIEW"?
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
remove local variable
t1 shows up as unused variable, please remove the assignment.
I'd add a guard to prevent surprises if (db.isBare()) { return null; }
Shouldn't this still call through to the native implementation?
This is not necessary. It is done in the RestResourceController, indeed the value here retrieved is not returned
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Since this is a String, perhaps you could use Collections.nCopies
remove this extra line
@fanifieiev the same above.
no reason to explicitly set to null, its default behavior
Don't need last else
Can you reduce the nesting depth here?
I would suggest using the related constant instead.
There is also StringUtils.removeStart for that
Agree with you. We will probably test this on different level.
I think it is unnecessary to use synchronized here
Same here. Simple call to filter() is more readable
It might be helpful to use different min/max values for bounding box so we can test the order is correct.  peliasWithMock.search("test", "1", "2", "3", "4", "5", "6", callback);
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
Likewise, this should probably be /rest/script/sessions, and the sessions controller should be updated. The restlet framework handled servlet paths differently from the MVC framework I believe. Either way, you should verify in a 2.11 geoserver with script installed to be sure of the correct path.
nit, Collections.EMPTY_MAP?
This doesn't compile and should return locations.
would it be better to use isNotBlank here?
100 seconds is 1 order of magnitude more. It seems a lot. Would doubling to 20s be enough? Or could we instead use org.jboss.as.test.shared.TimeoutUtil#adjust to adjust the time of this test?
nit: might be clearer as: return involvedTables.stream().anyMatch(this::isValidationNecessary)
Is this method really needed? It's similar to make init public
"missing labels in its"
!= -1
Looks ugly and potentially a source of future NPEs.
40?
Why doesn't the following method fit this test suite?  public static TestCommandFactory newInstance(Class<?> testClass)
This can now be deleted.
add this (also below)
This duplicate detection doesn't work for version-less features. I think a better check would be (idEqual && (version-less || versionEqual)) --> If you want to add multiple versions of a feature, you need to enter a version for the first one before adding the second. WDYT?
Please chain the method calls: java return new URIBuilder(BASIC_SEARCH_URL)) .addParameter("query", query) .addParameter("sort", "score") .build() .toURL();
I still don't comprehend this approach - the class is used for interceptors, I get that much. We don't want/need post contruct callbacks there. What I don't get, is why we still invoke them? Putting System.out in postConstruct will trigger it. That is IMO not intended
Should be done before opening a db session - for to fail fast.
Maybe use an uppercase in the text: 'Thread sleep was interrupted'.
Ow damn, I broke Partitioned Search without realizing it because we clearly have no test coverage for it.
instead of building loadService in the constructor just a create MutableSupplier (see code in the ltr plugin). Make your QueryBuilders accepts Supplier<LoadService> and call the set method in createComponents when you have everything needed to build your service class. That's not particularly better but it allows to keep dependent services final in your class.
Let's go for 422 then ;)
You can simplify this by reordering the states.
you should also check that log contains GIT_COMMIT is
why is this return null??
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
WTF is lala
please use static import for Mockito
I think we have some constraints regarding the target URI? (e.g., exactly one? at most one?)
Make secrets an immutable list if present.
There seems to be an output change here: original: Base32.encode("a".getBytes()) => "ME" new: Base32.encode("a".getBytes()) => "ME======" We might need omitPadding() to ensure this is an exact drop in replacement.
Why show the 'MoveUp' button by default?
?? why this and the following ones could be left empty?
Make this private and implement a builder?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Why WARN for FAIR and INFO for other unknown entities?
This is redundant.
@vzool one more printStackTrace ?
I suspect that this bring in an XSS vulnerability. If for example the VM name you are about to delete contains some HTML (or JS), and you try to e.g. delete it, this dialog would interpret this HTML (JS). Please use something like SafeHtmlUtils.fromString(message).asString().replace("\n", "<br/>") or something like this.
Can you look at the resource test i pointed you in the ticket description and then put some thing in these method bodies? You can even just copy some ideas from the pull request i pointed you to done by one of your team members.
Unnecessary call to super()
This will basically do:  clearMapStore(); clearLockStore(); clearIndexedData(false); storage.clear(isDuringShutdown); mutationObserver.onClear();  The problem here is that we are clearing the data from the lock store and calling onClear for the mutation observers, one of which is the event journal. During reset, each service should clear only the data which it owns. This means that the LockService is responsible for clearing locks and the RingbufferService is resposible for clearing event journals. I also see this method is now calling clearIndexedData. Was that the leak?
does the order not matter ? is sorting not something UI should do rather than the model ?
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Here and above, can we have strings defined as constants?
Consider getting this value once, and save it, instead of calling it twice.
I think getExtras() is nullable, so we should handle that case.
![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: java.io.IOException, java.util.concurrent.TimeoutException, org.osgp.adapter.protocol.dlms.exceptions.ProtocolAdapterException [![rule](<LINK_2>](<LINK_0>
Will this always be this value?
another log that can be removed (I know it's not part of your commit, but please do it anyway).
constant
why 40 as a limit?
I'm missing the new field in the toString method.
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
new Error -> new RuntimeException
pvk should not be visible. Please remove it.
A question: Omitting the map.isEmpty() check is intended? Overrided default method does the check but here only a null check is done.
Prefer [java.nio.Files#createDirectories(Path dir, FileAttribute<?>... attrs)](<LINK_1>,%20java.nio.file.attribute.FileAttribute...%29) (and maybe [java.nio.Files#notExists(Path path, LinkOption... options)](<LINK_0>,%20java.nio.file.LinkOption...%29) on the line above, although this has slightly different semantics)
Please use P.lazy(u -> f.f(a)
Why is it a list of lists, not just a list?
suggestion ((WordPress) requireActivity().getApplication()).component().inject(this);  This getActivity() can be requireActivity().
TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - started)?
I would change this "#get()" to something more meaningful, like "there is nothing here, use has() first, to check"
I fail to see the difference to the previous test. Is there any?
Why is it a list of lists, not just a list?
While we're renaming, might as well remove that extra _.
You can use mapToLong here and then sum()
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
+ desc
Won't fix.
This is not correct, orderGroup and sortWeight need to be copied too, this should stay unchanged instead you update Order.copy to copy over these fields too
Let's avoid raw types, please.
"Called only after a call to prepareEntities" Might be worth adding a flag to enforce this; I'm guessing this could be unpleasant to debug if someone tried to manipulate entities before they were ready.
Consider returning a constant
sortParameters.size() - 1 could be computed only once and result stored in a variable that is used in the loop. Curly braces around _if_ please :)
I thought this was to be debug to prevent unwanted data from appearing in the log.
Or can just be omitted: java protected ToolDescriptor() {}
probably worth using a linkedlist here as well, although I doubt allocating 10 ints makes much difference though compared to other stuff we do
style nit: we don't use braces around single line blocks
You want to use FormField.getFirstValue() here and everywhere below.
return Collections.emptyList();
This code to get the feature is used here and in the remove method. I'd suggest to create a new BackendClusterFeatureHelper class and put this code there. Then you can call it from these methos. Look at BackendDataCenterHelper for example.
There's no reason to box.
I missed this one before, but if (!eventString.isEmpty())
Should be !socket.isValid()
I guess we could just assert without the temporary result variable.
There is a better way to do this, WorldServer holds a Map of 'entitiesByUuid' which you can use to directly lookup the entity.
How is this expression different from "this"?
Why is it a list of lists, not just a list?
what about setting the permissions for that?
Please keep lines < 80 chars.
you don't need to check for null since this gets set in the constructor
Please add a note why this cant be implemented right now
double checking - do we have coverage for this case?
I believe you can and should add the same wait for verifyByZkCallback too. The logic of verifyByZkCallback is that 1. subscribe to changes. 2. no matter if change happens, verify the state for once. 3. if subscription results in some notification, then verify in parallel. 4. any of the paths succeed, then the verify succeeds. In this case, we shall wait until the first subscribe to ensure the waitTillVerify config takes effect. This won't cause any problem with verifying logic. Since if the change happens before we subscribe, we are still fine because the first default verify check will be done once at least.
Remove this if block. We can move check for instance HasNewPresentation  into below if.
Call setFocus() on the table control.
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Preferably have one call the other?
Could you please remove all the unnecessary super. and this. ? Thanks!
We should use the spring.application.name boot property instead of the applicationContext.getId.
I would say use a flag  @garrettjonesgoogle thoughts?
code style
Similarly
Simpler: ArrayList<T> result = new ArrayList<>(collection);
Same here. Consider just propagating the current exception.
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
Are we sure that deleting entries in this entire **range** is safe/correct? I notice previously, this code only cleaned up Item, Collection and Community (range "2 TO 4"). Now, it's cleaning up "2 TO 11", which also includes Site, Group, and EPerson (seemingly by accident). Does, this need to be updated to clean "2 TO 4" (like original code) **and** "8 TO 11" (new objects)?
We can make DestroyProxyMessageTask implement the Supplier, so that this method will no create a lamda but return this instead.
since this happens before canDoAction, getVdsGroup() can be null
Should be done in the setup. Note this re-occurs in all your test methods
throw exception
You're not making defensive copies of the Set, how do you know that it's immutable?
foreach loop, append the comma always and then resize the stringbuilder => shorter, clearer code, and more efficient :)
Should this string literal be a constant?
Is that a valid station ID? Judging from the results of nearby stations, station IDs seem all to be prefixed with OAW:SP:.
I think we should depend on the fact that this is an instance of EmptyByteBuf... just check it's not readable and release it
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
Reason should be optional.
I thought this diff was about moving to Aggregation not away from it.
Can we use [!StringUtils.isBlank(versionSTring)](<LINK_0> to increase readability?
I think you can get rid of the first condition now, due to the change above.
String.format
warning: The static field AbstractProcessor.logger should be accessed in a static way.
Seems like we could just use DefaultReplicaView. Similarly below.
Why that read() has to be under lock? We only need to protect usage of the "position" field (or even make it atomic instead) and let actual read() / write() concurrency to be taken care of by underlying FileChannel.
This should return a BitSet.
+ desc
nitpick: don't need keyword public
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
This exposes the unicode workaround to the public.
Why is it a list of lists, not just a list?
Why to return false in this case? I don't expect this to happen, but if the cfg is deleted (by deleting the refs/meta/config branch) then the default submit type applies which could be different than the submit type that was set in the old config. This is why I think it should rather return true here?
other != null is redundant with other instanceof Module, which already returns false when other is null.
Is this still necessary? And saving the thread in general?
When will the write mode be DIRECT_TO_TARGET_EXISTING_DIRECTORY after the change?
suggestion return new BridgePath(virtualFile.parent(), fileSystem);
throw an error
Can you have an @After method that unbinds this connection. This is more reliable.
Use Arrays.asList instead.
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
Please make this variable final
given that specificity of this SV is exception type I would add the exceptionType in this.
Remove "TestAggregateIdFactory" as this method is already static-imported
Fantastic coverage, thank you!
static ?
Change the getter so you don't need the cast
although its nice to use java8 optionals. sometimes its easier to read old fashioned if null checks.
Question: If tablename is not null, in that case is m_index defined (from constructor definition it looks that it will be)? Not sure how this function is intended to be used but if this is for debugging/information thn might be useful to return m_index value along with it
"image provider ID == image ID"? Is that correct? And make protected rather than private?
Could use '/' and ']' to avoid the need for extra NON-NLS
use Long.valueOf() instead of new Long() - always for performance reasons
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
This whole block can be replaced with functional style Java, as per example given in Epdq.
You'll probably want to do the other closes even if the prior closes throw IOException
This actually could be return !isEmpty(triggerId) || !isEmpty(triggerIds);
I would suggest reverting the isSytemLibrary field back
id:name might not be enough to uniquely identify a container. I think you should also include the string representation of the parent account (i.e. parentAccount.toString()).
A flip != 180 rotation
return collection ? to avoid to create array
Why are you assigning 0 to numElementOnPage, as you assign some value again in the next line?
alias is count but the function is sum
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
let's update all the includeTextDetails references to includeTextContent
Why do you not rename your extracted method's parameters appropriately?
Cosmetic: Our loggers across the codebase are lowercase. Could you please change this? Thanks! :)
Why don't we make inDegrees to ConcurrentHashMap also?
Looks like index type is not persisted and not taken into account in hashCode/equals, so basically all deserialized index configs are of SORTED type.
Move to a separate commit
I'd say "block end cannot be before block start"
Oh, I see Well, I'm not against mentioning subscribe() as long as we don't just say to "set this error handler to avoid this exception" We can also mention onErrorXXX, might be a bit overwhelming tho
A sanity check like the one in isFullMajorCompaction() that checks if scope is majc would be nice.
I don't see a reason to return an Iterable here instead of the more specific return type Set. The result is very small and a lazy evaluation is not necessary (which could justify returning an Iterable). Returning Iterable instead of a more specific type unnecessarily limits what the caller can do with the return result.
Please format here. And maybe use method reference to simplify: indexToChunkIds.values().stream().map(Pair::getFirst).collect(Collectors.toList())
would be nice for the 4 to be a constant for readability
I think you mean "Liquid Glass"
Similarly use the Java 7 template
any reason for the double 'max' ?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Nit: Unnecessary extra level of indentation.
Activity state util check before starting any of this, maybe?
Do we need the above line? What happens if we get rid of it?
Generic type not used, remove.
Please format here. And maybe use method reference to simplify: indexToChunkIds.values().stream().map(Pair::getFirst).collect(Collectors.toList())
We also need to override that in NestedUDTMapper and EnumMapper (using an enum as partition key, though unlikely, is possible).
We could remove this if we add the parser module to the list of modules in the api metadata. Better to have the complete list there?
Please keep the indentation consistent.
Should me make it default and use Objects.requireNonNull? The logic of the setter is a bit unexpected
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
Pager builder can be replaced by Pager.single().
The "brackets for single statements" cleanup in this file should be done in a separate commit, as we should not mix unrelated changes.
We already have a list of FS objects we should use that here.
> I feel like site_id here makes more sense just because the only use of it is for the network calls. If it's used for network calls, it's not "local". Local_id was used for blogs/sites because we can have a mixture of self hosted and wordpress.com sites, so we can't use the id provided by a network response. Will this be used for wpcom sites only?
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
I know this default is here for backwards-compatibility but I'm not sure about the value. If I create a factory - "OffsetDateTimeFactory" - I wouldn't want that to be the logicalType name. In other words, what do you think about the default implementation being: default String getTypeName() { throw new UnsupportedOperationException(); }  This way it is required by any new LogicalTypeFactory to implement it?
waitUntilContainerStarted is executed by .start(), no need to do it here
I'd suggest parsing the week from "MMM" to "MMMM" even in this case. TalkBack is smart in English and it reads automatically the full month name, however it works only with some languages (doesn't work with Czech).
I don't think it should be renamed
I think we will have to discuss whether or not to include the fromKafka functions in this class.
J) we should use chamberId instead of divisionId. There is only coincidence that divisionId is equal chamberId.
I think we have a race here with close.  T1 check assertOpen T2 close() T1 factory.apply( slot )
nit: Intellij recommends using setProperty() instead of put(). I guess it's because the parameter type is more strict.
Strange naming. There is datastorePath and dsPath ? Maybe store dsPath as Path and use dsPath.resolve(applicationName.getValue()) and then dsPath.toAbsolutePath().toString() when needed.
This doesn't check that ok has the value true, just that it exists, and it isn't null
If you're not using these vars more than once, might as well inline them.
What is this log statement for, exactly? Seems like a trace?
nit: You could have a private method that takes a preparedStatement and invokes executeQuery() on it. That way you can also put the metrics logic in that method.
Please use the StringJoiner toString()s found elsewhere.
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
this seems dangerous, any reason not to manually construct the array as you did above?
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
This can be made final
I think we should keep the instance of check in this method. Meaning this method should never exception of even if the object is not of the right type.
Why is it a list of lists, not just a list?
Please use ? ternary operator
Default the member variable to Proxy.NOPROXY. Never mutate or translate a value in a getter, it breaks all expectations that the caller will have. This one breaks the relationship between the get and set.  options.getProxy(null); if (options.getProxy() != null) System.out.println("Whut?!");
You need to remove the client.close() below too since this test class is using @AfterClass for closing client
Comparing with [TestExecutionResult](<LINK_0> shouldn't this Constructor be private?
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
Avoid the use of swtDefaults(). fillDefaults() and explicit alignment makes the layout logic easier for others to read. applyTo() is preferred over create(...) when attaching to a control since it's easy to generate a ClassCastException if you mistype this and omit the ".create()". The applyTo version is also shorter. Change this to: GridDataFactory.fillDefaults().align(SWT.BEGINNING, SWT.CENTER).applyTo(l);
This causes a compiler warning, please either suppress it or remove the exception throw entirely. Warnings in snippets cause noise during the build process so we can't submit patches that introduce them.
What happened to this method? Why isn't it a private anymore?
The classical hack is to implement read() like this: byte[] b = new byte[1]; int n = read(b); return n == 1 ? b[0] & 0xff : -1; Its almost never used and this form is short and easy to read.
do not expose the list directly
wouldn't it be more flexible to allow to set the authenticated flag instead of always returning true in the MockEndpoint?
This and line 59 can be a global variable to clean up tests a bit
You're not closing DataOutputStream. Check SparseVectorCodec too.
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
AS should suggest turning this into a ternary
Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.
please use diamond on the right side <> (no need to redeclare the type)
NoSuchElementException is more accurate
Why iv.removeValue(i, this) and not iv.removeValue(i, aCause)?
This code repeats in multiple places. Until we replace Slice, please keep the code in SliceUtil or another central place.
this shouldn't have been here either, format is required.
Is there a reason not to initialize this where it's declared?
This is a change of behavior. Some tests might not require all nodes to be up and trying to enforce that here seems like a stricter check. The earlier check createKVS can succeed if we have quorum too. We can perhaps have a classRule in the test classes to disableAutoCompaction if thats the first thing to do? Does this nodetool command require the node to be up first?
instead of setEngineSessionId - why not having it at ctor?
Should this property be moved out of the splitDeveloper namespace?
studentsWhoRespond -> studentsWhoResponded
i18n?
I don't see you overriding this in your Bounded implementation, why make this protected?
Why not test and assign instance directly rather than passing it through local?
In this case we ALSO want to include the "if it keeps happening, talk to the person who asked you to collect data" message. I think just concatenating the two with a space would be fine (and concat does the right thing with LTR languages, I believe)
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
does this need to be a class member?
To be consistent with AbstractAssert.isEqualTo, this assertion should pass when both actual and expected are null. a possible implementation would be to make sameInstantInActualTimeZone return null when given null.
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
You almost got me right now. :-) There is no need to test the injection point. You only inject instances of this interceptor to the injection points where it should do its work anyway. Because of that it is unnecessary to provide and check the injection point. Just delete this method and the field and constructor parameter and change java private void invoke(IMethodInvocation invocation) throws Throwable {  to java @Override public void intercept(IMethodInvocation invocation) throws Throwable {  and you should be fine. :-)
Shouldn't it br something the reverse condition getActivePage() != getPageCount() - 1? I think you'd rather extract the expression getActivePage() == getPageCount() - 1 to a dedicated isActiveTabTextualEditor() method so it makes things clearer. There is also an occurence on line 94.
Unreachable code. The button is only visible if the user is signed in and the action is defined.
For loop?
IF EXISTS should be reflected in unparse
Same here. It's more readable when part of deserializeValue
As noted above, just put the init code in init() unless there is a reason not to.
Switching OFF admin mode...
Init should only be called one single time when constructing the controller. That is done in OnStart. Please add a space between if and (
Wrong JSR number in validation provider.
Follow the same order of argument definition. Always add requireNonNull unless we are sure it is not needed (@Inject) or the value can be null (usually annotate by @Nullable).
no need to say "public" here, it is always public in an interface. "static" is important though.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Shouldn't this be &&? How can they be equal if one exists and the other doesn't?
Should this be "shouldReturnEmptyString" instead? If so, there are also a few more occurrences of "shouldBeEmptyString" that will need to be edited.
That's good to know.
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this switch case number of lines from 10 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I think adapter should have Adaptive banner implementation.
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
you can use containsKey()
Here, size is the number of currencies.
Just new Date() is enough
be a good citizen and call System.exit too :wink:
I would remove the if an always log the number of entries removed, which can be 0
same logging here as in perform next operation
failCanDoAction?
Why do we need this change?
return Collections.emptyList();
Also this: parent.syncScroll(DisplaySide.A); // match A's viewport
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
it can be replaced with Objects.hashCode(channel) (since java 1.7)
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
do you ever get nulls here?
would be good if you match the expected values in here. I would recommend bringing some of the values you defined in init to here. Those are execution/parameter specific, init should generally be a setup only.
please refactor to use Enumerations instead
please remove else, code will be more readable
Remove throws Exception
Should be- setTitle(text.asString()) not setText.
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
StringUtils.isEmptry(XXX) if possible
.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))?
If Java 8 can be used, this method can be reduced to: return this.properties.stream().filter(p -> p.getName().equals(name)).findFirst().isPresent();
@dalifreire wrong indentation here as well
@Override this annotations is not needed in test inputs
In the real game when a bomb explosion hits another bomb, it detonates that one regardless of time left...I just looked at the project requirements though, and it doesn't mention this...so it might be simpler to leave that out anyways.
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
Check if an entry with the given key (name) already exists and throw in that case an exception.
Would we want to preserve the previous selection (before archive radio was selected)?
A LinkedList is better since you don't seem to access specific indexes anyways.
log the error or re-throw wrapped in a runtime. But do not just print it. We tend to use Throwables.propagate() from guava for this kind of use case.
Program to interface, not to implementation - please change return type to Map<String, Object>
check for READ_ONLY style is missing?
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
We should use IdentifiedElementQuery.getLabel Do not forget: * @not-generated
return array == null || array.length == 0
can this just be boolean instead of Boolean?
let's use LinkedHashMap
rename to segment
Maybe we should add element.toString to the error
please verify that the amend function is actually executed
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Could you also add a check for static explain whether the table BIG is the picked as the left table of the cross join? Thanks!
Simpler: ArrayList<T> result = new ArrayList<>(collection);
UncheckedIOException
please move the isEmpty methods to the scimSchema
It's a good idea to run your tests before submitting them to Gerrit.
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
... and below.
redundant ";" character
This could be removed if you change verifyThatCleanupOccurred so that it tries to get the NotFoundException and if not sleeps for one second and tries again (until finally timing out after 30 seconds for example)
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
make function synchronized. Res: done with syncronized block
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
I would replace " " with ' ' since there is only one character.
can't we use Util.checkNull(handler, "handler"); simply?
Use _Objects.hashCode(name)_ instead of _(name != null ? name.hashCode() : 0)_ And the same for other similar code
Please use CanDoActionAssertUtils.
Don't like catching exception in the constructor. use an init method with @PostConstruct annotation.
I would mark it as final. It is not safe to use non-final methods in ctor. Someone could override it and do something foolish.
Multiple threads can call updateAlarm at the same time, so we need to make sure that the usage of the outstandingAlarms map is thread safe.
The synchronized block needs to include this read from the map: - Thread 1 reads eventNameToListenerMap, gets null - Thread 2 reads eventNameToListenerMap, gets null - Thread 1 enters critical section, creates new HashSet containing listener 1 and stores in eventNameToListenerMap - Thread 2 enters critical section, creates new HashSet containing listener 2 and stores in eventNameToListenerMap Listener 1 has been lost.
is it not empty if for example type is an valid empty string?
what is your opinion about that you convert only the different value and you are using the .name() any other case?
there should be only one line between methods.
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?
You shouldn't need to specify it. I guess that Kubernetes API is the default mode.
Why is it a list of lists, not just a list?
Do you think we need sync control on all the map operations here?
Please add ? and % as well
As mentioned previously, the check for the service type does not really belong here. I have created <LINK_0> instead.
Not that it matters so much, but the idiomatic way to "unpack" thing from Optional given a value to return in case of empty is [orElse](<LINK_0> which makes this common pattern i bit less verbose: return parent.orElse(null) But this kind of defeats the purpose of using the Optionals in the first place (to avoid having to return nulls). Otherwise +1 to merge.
nope!
Unnecessary whitespace.
check for empty criterias?
Similarly here, exec. should not be necessary.
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
no need for concurrent
Simple test is also possible to verify result stat. See #971.
I can't remember, is there some protection to make sure names are unique
Aren't we also prioritizing savepoint barriers here? Or are they guarded by using NO_ALIGNMENT_TIME_OUT on creation?
The bit is either set or not, so != 0 is a faster test here.
@benzonico may be it is better to highlight tree which includes the !.
This will throw redundancy warnings in IntelliJ
It is preferred to use the getResource method for tests instead of regular relative paths due to potential issues with the classpath.
If these values can never be null they should be stored in int not Integer.
Again, use IOUtils.
Return value of the method is never used.
You can just do Slimefun.getLogger()
Why are you putting the annotation on the same line as the method name. Normally all annotations are on their own line
nit, Collections.EMPTY_MAP?
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
IMO the caller should do this check, in fact most callers already do.
you don't need this function, you can use constructor directly
Optional should be used in interfaces. Use null as internal value.
It's written nowhere, but I'd prefer to have curly brackets even for single line.
no need to check for null again...
This makes me very sad since it brings back bad memories of us trying to make super calls happy. How about we move the diff callback creation to the options builder and let devs overwrite it if needed?
This is never returned.
Use config.getTrimmedStrings() instead?
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Should this be above "isColorTeamMatch"? For example, on line #755.
That's good to know.
We do not have synchronized protection inside this function, If you would like to protect mUpdateLock from outside of this function, I think you may need to add a note to remind caller in the future to remember protect it.
Retry forever is a bit risky. Limit to a fixed number of tries. Also, use a delay between tries?
Don't need this keyword here - the rest of this code only uses this when necessary.
Can't we just have a whole UnsupportedOperationException as a singleton instance? Or that way we are going to lose a method context for stack trace?
So the algorithm here is: * if unencoded file exists, return it * if encoded file exists, return it * encode the filename if required * trim the filename and return the file Have I got that right?
If the partition being replicated is sealed, should we reflect that here? (Not sure if we have that info available.)
ClientLogger.logAndThrow all exceptions. Please search for all cases because soon Shawn will check in his CheckStyle rule and it will break the build.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
List#sort usage.
Did you think about using [appendQueryStringToURL](tests/blob/master/src/test/java/com/wikia/webdriver/common/core/url/UrlBuilder.java#L71) method for appending URL params to URL?
Why use a local variable?
Hmm...while at first look this looks ok, I think we should 'harden' it a little bit to prevent cases of leaving compensation context uncleared in the DB. I'd suggest doing the following: boolean clearCompensation = true; try { endSuccessfully(); } catch (Exception e) { clearCompensation = false; } finally { if (clearCompensation) { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand(); } } else { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { compensate(); } } The code can be improved, but this is the direction to go to reduce leaving compensation trace in case of a failure during the end action.
Formatting issues. Please fix.
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Please don't change API visibility. Thanks!
Maybe we should name this variable entityReferencesDescriptions?
Same here when trying to save the context without specifying the script (or when trying to import the context).
Why does the report contain a file-name pattern instead of a real file name?
@garg-anuj Yeah doing that only.
LOG_WARN should be the first argument
finalize?
can use org.apache.commons.lang3.StringUtils.isNotEmpty(value.textValue()) ??
two arguments is iffy. e.g. if you just want to enable -nestedLoading, you also need to specify 'org.apache.hadoop.mapreduce.input.TextInputForamt'. we can move input format also to arguments (-inputFormat). '-inputFormat' will be rarely used.
you can use your find method here also
I think this can return null if there is no timeout. From what I see, a null SocketConfig is supported and what occurs normally (if you have no customizations).
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
The value needs to be encoded/escaped when used as the key.
why this change? private port can never be null. Public port can though
You can also use IO.close(bb) as IO.close will not throw any exception.
Seems for me this would be enough:  java Query query = Query.query(Criteria.where("_id").is(key)); query.fields().include("value"); return (String) template.findOne(query, Map.class, collectionName).get("value");
We decided to get rid of service class version parsing in favor of passing explicit service+version at config time. Don't think we want to add this back.
is it possible that we don't pass enough arguments to this array?
IMO using a concrete instance of PerformAutomaticLayoutCommand and passing mock objects to its constructor is nicer than mocking the class under test and using doCallRealMethod(...)... but it's only my opinion.
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
please remove else, code will be more readable
this used to bail after this call if it wasn't the root, does returning v. not returning from onCreate() in that case affect anything?
We can't use the concrete HashMap.of here because it is an abstract Map test, the base for _all_ Map implementations. Please use the methods empty, of and ofAll which are implemented by all AbstractMapTest implementations.
Do you mind explaining a bit why this changed necessitated a switch from 1 to 2 for provider id?
Should we have an isAnonymous method that we can call here to make this clearer?
System.out.format instead?
It's sad we had multiple params per line before. Let's fix it by having one param per line.
move null check back as first action in the method to not change behaviour
oo fancy!
Let's refactor this to cfg.setClientMode(igniteInstanceName.startsWith("client"));
Should we prevent setting the executor while the connector is running? Otherwise we get concurrency issues with hasInternalExecutor flag. Is it even necessary to have this setter instead of setting it in the constructor? Then we could make the executor field even final. atm we are accessing the executor from different threads without appropriate locking or making it volatile.
don't forget default case
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
use getGuid(rs, "disk_id")
null check
plase fatcor out that hardocded path segment
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
return HConstants.EMPTY_BYTE_ARRAY; ?
Remove else statement here. It's unnecessarily
UnsupportedOperationException seems reasonable here.
suggestion return new CheckConstraint<>(name, mapper.apply(expression), expressionStr);
I noticed that you use this on many places, shouldn't this be NPE instead of IAE?
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
Then OpenShiftPreferencePage and OpenShiftCorePreferenceInitializer cannot use that method, they need 'pure' search for default in $PATH.
suggestion && (((BaArmor) part).getType() == getType());
Remove?
Make this static.
Let's not catch NullPointers but do a check whether element is null before trying to get the attribute.
don't need getName() just this.oldSelectedVersion.notEquals(newSelectedVersion)
Ditto formatting.
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
Use faster methods, should not use data processors when possible.
same, "error" seems redundant here
While strictly correct, it looks weird to have a size assertion of 2, next to a contains assertion with only one element. A single containsExactly(1,1) would match expectations better
The local var is useless, you can remove it.
you have made all the above code with ImmutableList.copyOf() why not here also
symbol cannot be null for a method tree.
is there a particular reason that you're setting the value of this node to 0? couldn't it just have no value?
as above - maybe a closeQuietly method?
is this needed for the test?
typo handle -> handled
uuid can never be null here because if EntityPlayer.getUUID(player.getGameProfile()) were to return null you'd already get a NPE in line 44. Maybe use something like java UUID uuid = EntityPlayer.getUUID(player.getGameProfile()); if(uuid == null) { uuid = EntityPlayer.getOfflineUUID(player.getName()); } if(uuid == null) { CrafttweakerAPI.logError("Could not get UUID for player " + getName()); return ""; } return uuid.toString().toLowerCase();  Also, since I don't know these vanilla methods that well, can player.getGameProfile return null, and if it can, will getUUID(null) throw an error?
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
Comparing with #2845 RSS feed will be with project name but not build status. This is not enough. We need to see project name (for rss with multiple projects, what #2845 broke), build name and build status like it was before.
are spaces OK in namespace strings?
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
Remove the if check and simply return getFirstElement
Again, please don't catch Exception. Code compiles fine without the try catch but you might want to replace it with catch for NumberFormatException.
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
We can get rid of these variables if they are being used in one place.
This is very unusual
do not assing parameter! nowhere!
Why do we need to change BlockHeadersMessage?
I think the setter would be a more appropriate place for this defensive logic.
use constant from Versions instead
labelX should be x + ...
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
This is throwing a StackOverflowException if invoked. Should probably be sendNow(event)
Extract notification to own method notify...
Should it be logged at the error level?
Remove final.
explicit real ref?
suggestion if (rowIdx >= rows.size() && requested > 0)
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
nit: either use this. for both assignments here, or for neither of them. Consistency is good :)
This equals implementation should include attributes from the Command super class.
As you edited this line, could you remove extra parenthesis too please ?
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
SourceImpl?
shouldn't this also check the "" case? Consider using Guava Strings.isNullOrEmpty
This doesn't need to be "re", as it's just evaluating stuff once, not twice.
Log the exception and pass the exception into it rather than doing a printStackTrace. Then, are we checking for null after build? Better wrap this into a Runtime exception with a descriptive message.
entity can be just grabbed in the context method not here (other fields probably can too?)
Should all the VoltDBL* relations assert the presence of the VoltDBLRel.VOLTDB_LOGICAL in the input trait set like VoltDBCalc does?
I think the underlying registry/restClient will return SchemaRegistryClientException instead of SchemaNotFoundException in this case.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
The string needs to be made translatable in a messages.properties file
Optional should be used in interfaces. Use null as internal value.
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
Use CommonImages.getImage instead of createImage so that we don't have a memory leak.
return defaultFilterFactorEnabled ?
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
negative logic
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Doesn't this approach imply that moving to Curator 2.12.x requires you to change the code base to not break backwards compatibility? Shouldn't the default be to be in compatibility mode? Then you can just upgrade to 2.12.x and everything will still work, but you need to change the code base to pick up the fix for CURATOR-275?
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
why not factor out this code ? It's repeated in quite a few places.
What about creating:  private static final Future<RecordMetadata> COMPLETED = CompletableFuture.completedFuture(null);  and then returning that instance in all of these places. Since it's already completed, immutable, and we don't allow cancellation, it should be fine to reuse in this LogReporter.
boundedElastic
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
Why don't we make inDegrees to ConcurrentHashMap also?
I think inverting this if check would improve readability/flow
So simple! I like it!
is this being used somewhere?
is this supposed to be result.toArray(...) ?
return (e.getScriptStackTrace().isEmpty() ? null : e.getScriptStackTrace();
So this would leave the View in an inconsistent state with the Presenter? Should you not show an error in the View that the value was wrong? Or default to a valid value and update the View? etc
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Add the info log back after this line?
If you"ll use generics you won't need this cast.
Do we want to check both getProjectId() and getJobProjectId() here?
Please remove system.out.println and add assertion
Why was this removed?
Replace by Objects.requireNotNull()
suggestion "part of a group or is participating in a rebalance right now. You should first call poll to complete " +
call tearDown on laggards operator
canConnect( server.address(), clientGroup ) can be extracted to a no-params method
just return "" instead of new String()
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Do we want to check both getProjectId() and getJobProjectId() here?
Why do we need it here?
rename to fileMatcher as it is a File predicate
We definitely need more details about what is invalid about the configuration (e.g. which keys are missing)?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
you can create an example test list and assert their values like testListNumbersForPurchase, testListWebhooks etc.
suggestion // Align up to 4k final long align = 4 * 1024; return ((arenaBlockSize + align - 1) / align) * align;  Marking the primitive variable as final would make it a constant variable and help the compiler to do optimization, please check [here](<LINK_0> for more details. We could also make it as a class-level static final field, but keeping it here directly maps to the RocksDB code.
You create a getColumnNames(table) method later on in this class. This change is unnecessary, as it should just use that other method.
Should use the log, maybe a warning.
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
I would ask to the catalog if the filter_key does not exists on publishing_bundle to proceed
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this issue.
Hm, is it allowed that the extended discovery services still use the callback if this component has been deactivated (e.g. because a mandatory reference gets lost)? Shouldn't you unset the callback?
suggestion List<Program> malPrograms = pws.getPrograms("MAL");
nit: should the last 3 lines be a separate test?
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
does this actually work ?
We should move the naming of the threads to common configuration as well. It is just easier from debugging point of view and production support can easily make sense as well.
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
nit: maybe call them flattenDictionaryBlock and flattenRunLengthEncodedBlock?
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Could you add some log message here? It is not good practice to ignore exception
Please remove system.out.println and add assertion
Better to add checkNotNull for the arguments.
tokenizer.skipString() I guess. No need to convert Utf8 to String here, just use the stream.skip().
Since this is a verification we should probably use any(CacheLoaderWriter.class) to ensure the loader writer is not null.
replace the if with checkIndex(toIndex)
factory must close its cursor (which is closeable)
that can be null? This means all the locks above can throw NPE? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIZATION. Please either make sure they are never null or use different objects for synchronization.
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
Use filePath.startsWith('/') instead of filePath.charAt(0) == '/'.
Fix the prefix, should be impl$.
The icon that is set is the same as the archive menu entry found above. This is only relevant to Android 2 devices, but it is worth choosing something other than ic_menu_upload. Maybe stat_notify_chat ![image](<LINK_0> or something else from <LINK_1>
listeners are not notified?
I wonder if it is better to pass the admin label here in getSystemAdmins()?
s/vmId, null, deviceEnabled/vmId, deviceType, null, deviceEnabled
to avoid a crash on orientation change in tablets we should add: if (handler != null && runnable != null) { handler.removeCallbacks(runnable); }
Please extract variables.
Call setFocus() on the table control.
There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.
this could all be one line i.e: return criteria.list() > 0
suggestion LOG.warn("listOffsets request failed.", e);  Thanks! (minor suggestion to make the log message more typical)
again, just set the element in the array ?
Is this a safety check? Whats the case where this would be null?
Add a message to checkState so that it's easier to debug if we ever hit it.
null or empty list?
Hm, should we thrown it as InternalProcessingException ?
So, technically, it is possible for a Sequence to get used more than once. Meaning that with this setup, we can actually get multiple decrement()s for a single increment(). We don't use them multiple times right now, but I think it would be better to be safe. In order to be safe, though, we have to do the increment on the Sequence.toYielder() call instead of here. This ends up introducing a delay in when the actual incremental happens, which is unfortunate, but I don't think it's the end of the world. I think we should move the increment into the toYielder() method of the ReferenceCountingSequence<>, and we also need to make the ReferenceCountingSegment thread-safe and aware of when it has been closed. Once it is closed, it should reject increment() calls (let's make it return a boolean and set it to false once it is closed, meaning that it is not safe to use the instance) and return null for all of the other methods that rely on the underlying buffers.
Since there are already multiple exit points, refactoring as (something like) below would make it much more easy to read:  if (jsonObject != null) { if (jsonObject.has("aggregations")) { return new Aggregation(jsonObject.getAsJsonObject("aggregations")); } else if (jsonObject.has("aggs")) { return new Aggregation(jsonObject.getAsJsonObject("aggs")); } } return new Aggregation(new JsonObject());  Other points: - getAsJsonObject instead of casting - the "aggs" passed to Aggregation seems like a magic value without any function, so I'd suggest creating a single argument constructor for Aggregation where the name is determined in that single point.
minor: this not required anywhere.
Nitpick: space
Do we need this? All it does is assert that the message is equal
This function could use some auto-formatting.
This is not appropriately thread safe. Whenever you require synchronization you must make sure all atomic operations are performed under the lock. In this case, it would be possible for two threads to race associating the same async pretty printer with the request id and both would report that the key was not already there and then both would attempt to add it. This is solved in one of two ways here: a) use a different locking object and synchronize on it for the entire method body or b) take advantage of the fact that put returns the old value if it was present and throw if it returns non-null.
We can use getIntent().getSerializableExtra(EXTRA_COURSE_DATA).
We should set the collection of UEIs we're interested in, instead of a getting a callback for every single event.
Ow damn, I broke Partitioned Search without realizing it because we clearly have no test coverage for it.
dont think a setter type function should return the "this"
Why not use assertNull and assertNotNull?
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
This is needed as otherwise it will go into an infinite loop.
This log message is not correct. The line above dir.mkdirs() actually tries to create the directory. This log message is in the event that you can't create the directory... one such example could be a file permissions issue. please revert this log message as it's incorrect as to what is happening here.
Maybe assert that #put() returns null
this is odd -- is toSQL returning a string with two single-quote characters?
nit: it's my personal style preference, but I much prefer instance != null ? instance : result.newModule() rather than the flipped case you have here.
Move String values used more then once to a constant.
Please let's use getUploadQueue() here instead - as mQueue could be null and we're using it like this elsewhere in the Service code
Are we sure this is only happening for invalid username password ?
putIfAbsent returns the **previous** value associated with the key. Shouldn't we tear down apnsClient instead of client?
Does this work if transactionCallbacks contains multiple callbacks? If previous code causes recursive call, I would think ConcurrentModificationException would be thrown.
can super be called first?
It's always used with join(), so I wouldn't return CompletionStage here.
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
This is one of the points we should use Zulu Time, but do use the configured default Timezone.
Can just use diamond operator on RHS
We have a removeConfiguration so let's not allow null value here?
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
Please remove System.out
Hii @ribhavsharma, this extra brace over here is causing the build to fail, kindly correct it :)
This does not match the endpoint in connector :(
unneeded check
I prefer using String.format, it is true that I come from C, but formatted messages are way more readable than concatenations.
Same. Return int?
consider saving the value of group 1 and group 2 here rather than the whole matcher
targetValues is a List<String> so we don't need to use toString. Could use String.join(", ", targetValues) instead.
this is incorrect (and should fail with my new test. This would mean that if disabled the output is null, which is not what is expected (we expect the list to contain a null value). Though I realize that this is not consistent with the Abi/Language version...
you have to add a canDoAction message if you fail canDoAction
Missing space after 1.
Maybe use message "Config job.name is missing" ?
Is it Novoda style to have this Exception in a new line? If not, could be better to have it in the same line.
Might be better to have dao.exist() and call it, but OK to do that later.
assertFalse(...);
0 is a legitimate option value for min. selectable choices. Why not -1?
Assuming this is noting completion of initialization, perhaps "Finished initialization."
<LINK_0> handled the case when metadata was null, does that check need to go here also?
Please use LOGGER.debug because this error is kind of expected.
isDirectory()
Lol! You're going to remove that, right :)
This also regresses in that it no longer works for multiple repositories.
groups.isEmpty() is a little better
I'm not convinced we need this extra complexity. Could we just call logger.error("", runtimeException) without changing level or modifying any of the other code?
Hmm I'd suggest logging some kind of error message if ImageIO.read returns null. Otherwise map makers might not realize that an invalid image was attempted to get loaded
"creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating the aliases here
This change should be made also for DiskListModel
You'd better use a logger here to ignore the exception or propagate the exception using Throwables.propagate
use Guava lists for consistency + throughout code
maybe a word mistake? it is orc instead of parquet
pvk should not be visible. Please remove it.
We still need to call to deactivateParticipants()
why would this be required again?
This is bytecode equivalent to using the for-each syntax on an array.
There's no validation in here. I'm not sure if there should be, but we can't assume the UI will provide "valid" numbers. My guess is that we should have a min value and a max value, defined as environment.properties values, and ensure that whatever the end user passes in falls within that range, or is constrained to that range by the code, if we want to allow that
if you remove the property, why aren't you removing this method as well?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
@jjl014 User id is optional, unlike client id and session id, which are required for user info
Can session.getPath() ever be null? If yes, instead of throwing a NPE (which requireNonNull will do) we should do throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Session path is null");.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
?????
Is it safe to let the else case fall through? Perhaps the entry display type should be the first thing checked in the method and return immediately if it's not DISPLAY.
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
Update labels to go with method names. Alternately, call super.toString for super attributes
It should test against the list size. Probably more understandable using fCursor.
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
You could remove "verify that the" from the logging description.
Not sure this would work. If 2 threads are racing for this code while val is still null, both can read val as null so both will create new instance and 1 count can be lost given the last of them will update the map so possibly using synchronized for cases like this is actually needed.
Should assert on the message contents to make sure it's the right one that got through.
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
That was exactly what I want.
What's the reason for marking all methods final? If you don't want this whole class to be subclassed, just mark the whole class final instead.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Is this going to cause a problem upon restart? Should we log something higher than debug?
The code can be simplified to rely on autoboxing.
See the Headers class.
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
why do you have the same test case in two different classes?
needs 2 _arguments_, plural
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
Interface can be used here.
nit. faster to write throw new RuntimeException(e); :)
Extract a method for this. (You now have two 'ends with ".erl"' checks in your code)
Cosmetic: Please, change this to lowercase: suggestion logger.error("Before execute failed for [{}]", r, e);
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
Shouldn't this message disappear (be hidden at some point) ?
Upon ValueChangeEvent<String> you would want to fire a ValueChangeEvent<T> to represent the change in the T value, so you have to know how to translate from String to T. ListModelListBox does it through GWT's ValueListBox, which translates according to index. You don't have indices, so you would need some sort of Map<String,T>. I would do that by implementing setAcceptableValues() in this base class, and in its implementation construct the map using renderer.render() for the map keys. The renderer for ListModelSuggestBox should just cast. Then when a ValueChangeHandler<T> is passed here, I would add a ValueChangeHandler<String> to the SuggestBox that calls handler(map.get(value)).
"amount of columns was typed: " + columns
Same here, a constant can be used instead.
getRecords() is marked as @NotNull, and then returns null here. Something like throwing an UnsupportedOperationException would be better/clearer too.
Local variable could be declared List instead of ArrayList. Is this worth caching?
method name in log message should be enableConnectivityChangeReceiver()
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
this seems unrelated to the setEmail call. Can we move this to a more logical place?
no need for this.
What if it's absent? In my account it may be absent, for example
Use closeQuietly from Airlift Closeables. It handles null.
Check first that target is not null.
should this be more strict ? i.e. require at least one character inside the parens ?
maybe rename this to show that it's usually a no op (e.g. addSdkLinkIfNecessary?
Can you also capture stats on the hit ratio, load time and total weight.
getAttribute returns null - add null check
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
Tip: If you actually didn't change the logic, please avoid formatting the existing code. You could have a separate PR with just reformatting and make it clear that there are no logic changes. It makes reviewing harder and you'll take longer to get it reviewed.
Use ImmutableDataCachingUtil.getValue(ImmutableSpongeValue.class, Keys.IS_SNEAKING, this.value, false); instead so that the value can be cached.
You don't need the null check, the analyzer method accepts a null without issue.
Maybe use the orElseThrow method of the Optional here
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
nitpick - s doesn't convey much information - in the Spring world we use loooooong variable names :smile:
On reflection, I suspect that this was done for backwards-compatibility reasons, since overriding and delegating to base would be a behavior change whereas this change is only a performance optimization.
Are we sure a null never reaches this point?
Use Iterators.transform from Guava?
Then this one could become java return ImOption.apply((Focus) getValue()).map(f -> f.getStringValue()).getOrNull();
It seems like you are expecting a certain exception here. Can it be made more specific than "Exception"?
move this line before above line, After super.cleanup method couldn't do any of the server requests.
The @Override annotation should be on a separate line from the onResume method.
I'd use warning instead: log.warn("No heartbeat message arrived from host '{}' for {} ms.", getHostname(), incoming);
Unsigned types are not used in the current implementation. So, you can omit them.
please remove this statement or enhance it to something more context/meaningful
pvk should not be visible. Please remove it.
The field should be removed as well.
This isn't a job. Please rename the object to match what the object actually is.
This can be defined as Lambda
Return value of the method is never used.
The Exception is never thrown.
Don't we need to use .toLowerCase()?, I thought the keys where saved lowercase in the keystore.
Should you call analysisReady(false) here?
This isn't the listener I was worried about. This should be fine, as the main tab model is probably destructed soon after its view. What I worried about was the systemTree listener, because the system tree stays there and will keep trying to send events to the disk main tab view (which will not exist anymore). So basically, I think instead all is required is CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent().removeListener(systemTreeChangedEventListener).
containsExactly oder isEqualTo verwenden
Can't be just assetListConsumer.accept(Collections.emptyList())?
Use try-with-resources so you don't need to manually close the session.
Shouldn't you just push this into the previous if? I don't see a point in setting the text of an empty string and not make it visible.
I think you're missing getDefaultConfigurationFile() here.
Could use constant in this message
Missing <>, this is a raw type.
These should use the internal vectors instead of these variables. As-is, both sticks return the same values.
Listener which does nothing, looks weird for me. Is it okay?
Something like return joinPagesNotNeeded.map(Future::isDone).orElse(true)
simplify this to  return getVarArgIndex() > -1;
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
s.a.
does this actually work ?
We could use assertThat(actualResult).isEmpty() here (and for the ones below) . This might be preferable because if the result is not empty, the error message will display the contents of the array rather than just the length. Sorry I didn't notice this in the first review.
Clean the "public" as well
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
What if the storage domain was inactive and you moved it to maintenance and failed.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Verify that at least returns one element?
consider to use method reference
possible NPE
This API is only reliable when the notifier is known a priori to be of the 'expectedClass' type. Usually we just check whether notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED The getFeatureID API is usually only employed for notifiers that aren't Objects, such as Resources and ResourceSets.
nit, brittle test code smell. If we change this string in production code, this test will fail unnecessarily. Recommend extracting the string to a constant, eg:  @VisibleForTesting static String NOT_ALL_UNITS_CAN_MOVE = "Not all units have enough movement";  I wonder a bit too if maybe the string that is displayed should be a downstream concern. For example, if we were to internationalize the strings (not on our radar, but for the sake of argument), then it will be odd to have the dependency on the string value. Perhaps a cleaner API would return an enum result, then the consumer could map that result to a string. That would make this test read more like:  assertThat(result.getValue(), is(SOME_UNITS_CAN_MOVE));  The other two enum values I would presume would be:  ALL_UNITS_CAN_MOVE NO_UNITS_CAN_MOVE  This also avoids a good bit of nullable args. Nullable return types are essentially a SRP violation code-smell, they represent values that have different meanings depending on the value. IE: if null, this variable means one thing (a flag), if not-null, it's a display string for the user. Having enum values would then imply non-null return type, and code that is closer to the front-end could decide about which display string to use.
why Object?
this could be done by a stream right? Like types = list.stream().map(e -> e.getName()).Collect(Collectors.toList())?
What do you think of the following: java int EXPONENT_MASK = 0x7f800000; int EXPONENT_SHIFT = 23; int MANTISSA_MASK = 0x007fffff int MANTISSA_SHIFT = 0; // ... private void setTemperatureMeasurementValue(...) { // ... int exponent = (bits & EXPONENT_MASK) >>> EXPONENT_SHIFT; int mantissa = (bits & MANTISSA_MASK) >>> MANTISSA_SHIFT; // ... }
I think driverPool.forEach(d-> d.getDriver().quit()); would look neater :)
Looks like previously we have had a CorrelationDataWrapper instance independently of the userData, but now you restrict it only if that one is not null. Also I see that you are protected against null in the CorrelationDataWrapper any way. So, what is the motivation to not do that any more?
You need to create an event in frameworks/base/core/proto/android/app/settings_enums.proto
Only here I see that the checking for whether tracking is enabled before logging an event. It isn't clear to me how that checking is handled in other places.
Avoid using admin credentials
Why?
Add Pagelogging
Nitpicking: would have been more compact with a constructor KeysSupplier(Collection<Object>, boolean).
Would be good to move this contstant to this file and name it something like WIDGET_ANSWER_STANDARD_MARGIN_MODIFIER.
userRepository and modelMapper invocations are not verified
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
Should be a SamzaException with a message, not NPE.
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
Why is this needed? You are already subclassing a CacheModule. This method body should only contain the lines 30-32
I think super implementation is correct (size == 0). Nulls are still considered part of the list, they just take no memory in internal structure.
Shouldn't this be wrapped in a try... finally block?
Why this check? This method will not get called unless performRuntime is called, and performRuntime has no such check.
Would it make sense to add something this.caches.clear() to the stop ?
is it ok by the formatter?
Let's avoid long code lines. Maybe it's better to use java.lang.String.format method? Also, please double-check that single quotes are not missed.
not a big deal but you can read in a local variable customCleaner to be sure that is not null while accessing the second time
Will this ever be ok? Not quite sure why this just wouldn't throw a SessionUnavailableException as part of the method signature
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Instead of doing the string replacement, we could also use suggestion final String randomID = new AbstractID().toString();  this would be a bit simpler.
return index == 0;
(Alt) Can we move the skip condition to the testSetup method just above.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
Do it also work with requestLayout() which is an asynchronous layout call?
No space after !. And Framework#isBooleanPropertyTrue(DISABLED_ISLATESTVERSION_PROPERTY)?
I think you want to specify the encoding explicitly here.
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
We only want to take the hit of saving the message in a TL __if the poller is transactional__ - we can easily tell that in the XML parser and via the DSL spec, but not so easily via the @Poller annotation; we may need to add a transactional property to @Poller for that. On the other hand, any "around" advice that can throw an exception may need access to the message if it throws the exception after the proceed. So, I don't mind if we always apply it if the advice chain is > 0 length - that's probably the simplest solution that would work in all cases while only taking the extra unneeded hit if someone configures an advice chain.
typo "should", also "In case".
Similar to PUT, perhaps split into separate function?
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
FYI, proper English grammar is "must not be null" or "must be non null" (I'm not sure if grammar requires a hyphen in "non-null").
@lautarobock Same here, let's declare throws Exception
Wow. This method is much more elegant that it was before :tada:
trace
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
Why not let this method throw IOException and change the caller accordingly?
This could be a singleton
conditional could be clearer here.
There is already logging for that in the EncryptionUtils.encrypt catch block
Small change, but can you swap the check around? First evaluate the ConcurrencyCheck. As this check has a greater chance to short circuit the conditional sooner.
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
this should be called only in endWithFailure()
You should use a consistent method naming paradigm within your class. I think this is the only setter that says "set" on the start. Either have all of them say set, or none of them. This might also be a good opportunity to change "rya prefix" to "rya instance name" since the prefix is Accumulo specific.
Might be worth having a displayName?
Would we want that exception to make it back to the JS caller?
I'd not thought about putting the logic to determine if it's a soft decline in WorldpayOrderStatusResponse. Good idea. (While I still think this class and its friends conflate being a representation of the actual response and our interpretation of it, this is what we have for now, so putting this new logic in here makes sense).
In a good implementation, the spatial reference instance should be shared between all instances of geometry coming the same dataset, so usually the esriSR size would not contribute to OGC types, but we don't enforce that on geometry side right now.
Why can you not have both a pre-login handler and a pre-register handler? You can when not using id site.
return getForecast() != null ? getForecast().toString() : "FORECAST IS NULL";
this is typically done by having a LoadSpec implementation that wires up the json config to the puller (see io.druid.storage.azure.AzureLoadSpec for a good example)
We also need to replace childTraits with enumerable convention. also hashjoin.
I would always suggest logging the full exception at DEBUG level for troubleshooting.
@paulodamaso the braces and return are not needed here
ARRAY_ELEMENT_DELIMITER is also a single character in CsvValidator.
Do we want to include input "type" as parameter in exception for debugging?
RuntimeException?
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
Even though it's java there is no reason for trailing spaces
You can put the whole ability text here instead of calling the super but if you don't you should add a comma after "steps"
An alternative here would be to use a Set instead of a Map and assume that membership in the set means that the corresponding event was detected. Clearing out the set is simply a call to .clear(). If you prefer Map then going with an enum and iterating over the values would be less error prone for additional states.
Maybe, debug would be more appropriate then?
I would name this method (and the following one) just containsOrderless, i.e. provide 4 overloaded methods with that name.
factory must close its cursor (which is closeable)
Not 100% sure if we want to swallow Errors - should this just be Exception?
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
The condition should be replaced with !TextUtils.isEmpty(assignmentId)
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
keep primitive, it's not used in JSON and can't have null?
See, here the problem is apparent : you are calling this in many cases where it's not needed. I suggest this should be called onStartProvisioning (or onBeforeProvisioning in this case maybe, because it has to be done before provisioning starts ?) and only ever called when provisioning is actually started, not every time this function is called.
we should not care about LOC metric. We should care about expressions without side effect. ~~ Ideally if test should not have modify anything, unless actually needed. Please update result variable, and only after that proceed with testing it.
nit: method name is awkward, maybe better just whenStandardClientStartsTransactionTimes? Also goes for all the subsequent methods
protected not needed. Android Studio warns you about that. ![Screenshot 2019-03-13 at 17 28 17](<LINK_0>
remove double a valid from test & implementation
Can we move this isAdded() check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
Why is it a list of lists, not just a list?
Maybe just via backspace? I've never really used the case list search functionality on older devices.
use .getUuid instead of getArtId, which will go away
could this block be simplified?  java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; }
What's the point of adding a copy here?
A for each loop on the listeners can be used here instead.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
If fOperator is op_throw, we need to return true :)
for readability, consider extracting it to a method..
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
Why empty string and not null?
use a dedicated method hasParameter(tree)
I think it makes sense to add a generic method for handling an IOException instead of repeat the logic in every method. Something like: java static BadMessageException handleException(String format, IOException e) throws IOException { if (e instanceof ZipException) { return buildBadDataException(format, e); } else if (e instanceof EOFException) { return buildPrematureEofException(format, e); } else { throw e; } }
No shallow copy as it was the case before?
minor: don't need this. qualifiers
Wouldn't we want to unify these names and pick either onReady or onDataChanged? Other than that, LGTM!
I'm not sure if we should add this to the interface. Not all implementations need to generate data ids in this method. How about removing this and instead throwing a RuntimeException at the implementations that use DataIdFactory?
specify array length (based on codecs.size) to optimize. <LINK_0>
Perhaps there should be some validation that if the name is the same as the current name, then to reject (ie the new name must be different from the current name).
The "encoded" field should remain null. There should be a "byte[] hash" field instead. Also, charset encoding should not be used for hash password types.
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Can we get some more information on the magic numbers here?
I didn't know the string "null" would become an actual null!
simplify this to  return getVarArgIndex() > -1;
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
suggestion if (castSource.toLowerCase().startsWith(clobReturningFunctions[i])) {
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
Will you be able to put methods that send broadcasts into your RecentListActionModeUtil?
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
I didn't even realize that we have logic in otj-server that also copies conserved headers to responses, apart from what already happens in otj-conservedheaders. Would the be any way to consolidate this logic in one place?
Did you intend on nesting the code block in a paragraph block? If so the method name should be changed to indicate what this test is about.
Please don't use null here. Just pass "" and make stateKey always concatenate.
The SSLContext should be exposed for configuration so users can set the keystore, truststore, protocol, etc. TLSUtils has some examples for doing that, used by SSLContextProvider for the internal HTTP client
Can this be private, or is there another use case for default attribute outside the builder's call?
you removed stats.waitUntilBuilt(). Why?
it would be better to reuse:  <LINK_0>  to construct PagePosition iterator.
I think you mean (d<=0)
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
It would be preferable for the PutHammer to keep putting data until the main test method has verified that rehash has completed instead of using a fixed-size loop
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
Use File.Separator - not "/"
This should be done with field declaration example:  java private Set<String> users = new HashSet<>()
Shouldn't this be set to true as daemon threads do not prevent the JVM from exiting when the program finishes.
Collections.EMPTY_LIST
The only reason this should be null is if the Activity context was used instead, so in that case we should throw an IllegalStateException or RealmException saying that the application context should be used, otherwise all the import logic will fail silently as far as I can tell.
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
bad hashcode.
This is always FALSE. since name is static final
maybe default to ":" like in other cases?
@sundaramrajendran Yes, I see the bug now. Thanks! This said, I think ConfigParser needs a few more changes. 1. We should not call readConfigFileContents in any constructor. 2. We should wait to call readConfigFileContents on the first invocation of parse 3. setConfigFile should return the ConfigParser instance to make it more like a builder. E.g. - ConfigParser.setConfigFile(file).parse().getInt(key) 4. Subsequent calls to setConfigFile should not change the static value of configFile once parse has also been called.
computeIfAbsent
We'd want to use Collections.unmodifiableList() here also with null check
fileNameBytes is interpreted according to platform encoding. Give it a StandardCharsets.UTF_8 to pin it down.
Use same order as the field declarations.
Same as above, why not use try with resources?
If we are returning Mono<Response<T>>, then method name should end with *WithResponse. In this case, getKeyWithResponse.
this is potentially costly, depends on what asMap is doing. Maybe getIfPresent and check for not null result?
any difference between this test and the previous one?
Why this change here?
>byte[] [](start = 11, length = 6) DecryptResult
Why need "bytesRead > switchToNextOnlyBytes"? Can do it directly?
Use Objects.equals() to handle nulls concisely.
Probably better to use computeIfAbsent() since it computes hash less time.
try (JarFile jarFile = new JarFile(srcFile)) {...}
-1 just noticed now: forgot about skipExec here. This must also be handled, otherwise it will be ignored now.
Please take into account that t could be null.
Entity#getTags returns the original set. While I don't see any vanilla code that makes use of the fact that the backing set is mutable, mods very well might. It would be stupid for them to do so, but they might. Thankfully, there is a really easy way to sidestep this: make this method return a Collection<String>! While Java doesn't let you vary only by return type, no such restriction exists on the JVM. That way our method and the vanilla Set<String> getTags() method can co-exist peacefully.
the 10000 looks like a wrong digit.
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
ChannelClosed needs to be added to (though not strictly necessary)
Inconsistent Upper and Lower case in description
I think the old way is correct as these methods are public factories for the class and thus are logically part of the class' public API. Visibility is controlled at the class level. Similarly, if we have a top level package-private class, we'd make the methods public rather than package-private. In addition to being more clear about the public API, it's a one line change if the class later needs to become public (instead of changing / thinking about each method).
nit: public static void But public here is irrelevant. Its only as visible as the inner class, which is package access. You can skip the public keyword.
calling super not needed
I don't know, but isn't the class also of interest?
Not sure if you wanted to leave this hardcoded?
Should we be checking for null before doing a toString()?
.split("[,]") and trim() to support multiple interfaces within single extension, please. return List<String>
You could use a Multimap instead
For loop?
Generally we don't check for GTK dev versions. GTK3.21 is a development version, so this call should be GTK3.22.
return Promise just to symmetric with start()...
This should be logged as error, if an exception gets this far it's most likely a bug in the custom menu items.
The message here should be: diff - "A delegate item reader is required" + "A delegate item writer is required"
We can shorten this condition: java (StringUtils.nonEmpty(value) && constraintType == null)  FQN for StringUtils is org.kie.workbench.common.stunner.core.util.StringUtils
Do we want a space here before the brackets?
Change this to PDataType.VARBINARY, as that's what the evaluate method returns.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
Why not just mark the whole method as synchronized?
I think this is unnecessary => "profile =" + this.profile is sufficient.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
we need hostName only to log error. Please call it there.
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
Missing types
I see that one method above you check instancof ArrayList. Is it ok that you check here instanceof Collection?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Just curious: why checking 'isClosed' ? Can't we call 'close' multiple times?
We try to avoid returning null to express absence. Could this method be refactored to return an Optional<URI>?
There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.
Very nitpicky, I'm not sure if we gain much by verifying the parameters of this test, we could make this more flexible by just asserting that any arg is passed to connect blocking.
This is not enough. Look at the method DecoratorAdapterFactory#dispose(). You have to iterate on the values of the map and dispose them propery
These magical values (NO_KEYS, NO_SUCH_USER) are going to be trouble. We can't tell them apart the empty list that was stored in the cache because they all serialize out the same way, so they deserialize into an empty list. You probably need to add a field to the SshKeyCacheEntryIterable to tell us what type of entry it is, and get rid of the magical constants NO_KEYS, NO_SUCH_USER and use that field to tell us what magical type it is.
!keys.isEmpty()?
suggestion assertKeyPair(file, null);
please add setSoftLimitInterval() setter and use it.
A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge
Please implement equals() method either. This will remove the potential problem when working with collections.
An create on-demand Direct Debit payment request should always have an agreement ID
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
curly braces
We should clear the list too, to not keep references to the threads longer than needed (ideally the thread/parser would remove itself once done too).
EventLoopWorker can implement Action0 and schedule itself to release.
This code will repeat itself in every command test... Can we please have a sensible util to do this?
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
can be replaced by List.of
s/RemoteTable/RemoteReadableTable
Again, I'd go with asList and a static import.
Why only return count for m_wrapper? Don't you need add the count for all the wrap in m_bundles? This also works for class-based importers, (i.e. socket importer), right?
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
Why negated? couldn't you just flip the branches?
These line is proof you don't need QuotaConsumptionParametersWrapper
@ccustine After this line, I would also indicate the service type for the provider: properties.setProperty(SERVICE_TYPE, ServiceType.BLOCK_STORAGE);
Should the name of the thread be maxwell-kafka-producer-worker instead?
I see this method does something similar to execute minus the optional processing with the rowProcessor
Should we use pushInlineDeployments here ?
shouldn't these fields be covered by the autogenerated driver.cleanup() method? (Since they are fields and implement HasCleanup interface)
A new ArcGISScene already has a Surface, so you can just add the new elevation source to the existing surface.
CoreUtilities.noDebugContext
While interesting, this is not a standard toString() impl in the Che codebase. We generally do not use multi-line string representation nor do we use "class" prefix. We generally do however enclose string fields in single quotes and use simple string concatenation to build the string. Please look around in the sibling classes for guidance.
Better use getters instead of fields directly
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
I would just do e.addInfo("At line: " + lineno) as the exception message is already in the exception itself.
Why not declare GLOBAL_ID as a long?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Why are these not returning mAlignmentStart / mAlignmentEnd ?
Maybe check if batch update exception has nested SQLTransientConnectionException?
Minor: Formatting is a bit off.  } catch (...  ..should be lined up with try.
Should check that the environmentTracker is not null
I would simplify to "return isValid(buf,off) && (buf[off] & X_BIT != 0) && (buf[off+1] & I_BIT) != 0)"
revert this unrelated formatting change
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
Better to return "";.
Should allowedValues be considered for object equality?
Ya this is some thing we can avoid
_verify
I'd maybe use Map.putAll instead of call putLabel in the loop?
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply);  (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
I'm sorry, I don't get it, could you explain why when I call getAnalysisRequirements() twice I get two different ArrayLists()
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Is it really worth checking before setting it?
Collections.addAll(whiteListPatterns, patterns) can be used here.
Better to return "";.
we should validate (and the feature support check) it in the validate() method.
<T extends EntityAttributes<? extends BaseEntity>>?
Please change to externalSearch =
Why U don't want to consider id in equals and hashCode ?
logging here is redundant, since we throw the exception
I think this should check that also the non coded value is not blank, we normally user StringUtils.isNotBlank
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
Do we need a LOG.info(..) here?
static (same for isMap).
Please use Yoda DateTime.now().getMillis() for a timestamp
final missing. Same for the other ones.
I would remove the if an always log the number of entries removed, which can be 0
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
I ask myself if SUBSIZED can be omitted here because there is at most one element in a single-valued type. It cannot be splitted anymore. But wait... Java 9 added Optional.stream(). I will ask jshell: java jshell> Optional.of(1).stream().spliterator().characteristics() & Spliterator.SUBSIZED $3 ==> 16384  Ok, we need SUBSIZED :)
super.canDoAction() assuming cluster id already set, when checking for up server, so need to overcome this also, please make sure non of the following commands inheriting from this command base doesn't assume the same, specially in getPermissionCheckSubject that is called before canDoAction (this is why usually we initiate params in the ctor)
also here. if true.remove(element) returns the same instance, we may test with == instead of size and length
since there is an exception being thrown, there is no need to log an error. Otherwise, there will be double logging.
I must admit that false to me carries little information. Maybe a constant with READ_ONLY in the name could increase the readability.
braces
suggestion
This looks like a leftover and it hasn't any usage. Can we remove it?
remove this
This will now recursively process all subdirectories from services. Is this intended? You may just call internalProcessConfigFile here to restore the original behaviour.
My expectation here is by the time the code is JITted the JVM will be able to predict ConverterHolder#getBestConverter() is both monomorphic and returns the same value for every invocation. There will be a bit of extra code to typecheck and branch (and de-opt) if the prediction fails, but I believe the branches will have the right prediction hints. The generated code will have the same performance characteristics as previous. If this is a concern, a jmh-based microbenchmark could confirm.
Maybe we want to keep something similar to what id was before
you can simplify that as return getInternal(key) != null
suggestion
I think this will replace a TERMINATED state with a FAILED state. We don't want to do that.
Possible to log only one debug line here?
I believe the Auth system should remain on in this method.
yes, this is what I mean. LGTM
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output, plainOldUserSchemaResource,PlainOldUser.class); avroItemWriter.setEmbedHeader(false);  Why should I provide a Schema if I can set embedHeader to false? For the reader, we can read PlainOldUsers from an avro file not containing a schema without providing a schema. In the same way, we should be able to write PlainOldUsers to an avro file without embedding any schema. In that case, why is the schema mandatory? To be specific, having a mandatory schema and an option to not embed it is confusing to me.
Why not throw a NuxeoException here?
Better to extract local variable for URL to avoid noise from Sonar that we defer NPE calling the method several times.
Why do we return the parents name instead of the name we store a few lines above?
is there an easy of checking whether or not we retried at least once (or twice depending on how you define retries)
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
Not all announcement activity is public. I think there might need to be a separate manager method to have the right permissions. There are specially written queries in one of the DAOs to get only appropriate announcement activity because it was a pain. Anonymous users should be able to see activity for public announcements and logged-in users should be able to see all announcement activity.
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
This log message is not correct. The line above dir.mkdirs() actually tries to create the directory. This log message is in the event that you can't create the directory... one such example could be a file permissions issue. please revert this log message as it's incorrect as to what is happening here.
"Modifier 'private' is redundant for enum constructors"
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, so no action needed.. just for you to know
Adding this to a field is good manner.
nit, Collections.EMPTY_MAP?
This is easier to read as: return type.getClass().isArray() || isList(type);
you don't need to do new HashMap<>() here
consider changing "alt text" to "link text" in the markup, since "alt text" could easily be confused with HTML "alt" attribute.
Are we sure WDateField is the only input element which has a div wrapper? It may be safer to limit in some other way too - such as a check on the outer element's class attribute containing wc-datefield. I am pretty sure a WDateField in a readOnly state is wrapped in a time element and a WPartialDateField in read-only state is wrapped in a span element (the div for editable WDateField is only necessary because of the need for a calendar in the polyfill). Therefore this will fail if trying to get the component in a read-only state and the other input extensions do allow getting read-only components.
OperandTypes.VARIADIC indicates a parameter list with varying length. But it looks like JSON_TYPE is designed for processing a single input value. Is OperandTypes.ANY enough for that?
Enums must always be compared using ==, not .equals()
I this this(url,new HashSet<>()); would better. What do you say?
Where did 31 come from? Why not use *=?
I think this should be stripe_account_id ? as per PP-4302
do we need to unvoid..?
Same here, I think this should be limited to 1 or 2 arguments
wouldn't you rather having the exception tracktrace be logged only on debug mode ?
Can the constructor be private?
Why are we configuring drawer in this activity. This activity shouldn't have it.
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
Can we deprecate one of getURL or getUrl, and have the deprecated one call the non-deprecated one?
nit: line to long (break each parameter in it's own line)
this("Safety Command")
please update - should we keep this or format to remove ====
Could you perhaps try to use similar approach to [this](<LINK_0> The point is not to copy-paste code between Page Objects and also not to put so many ugly selectors directly into the methods.
You could either use a constant for the id name here or use something like: java @FindBy(id = "export-form") private WebElement exportForm;
It feels like this logic should be refactored into a utility function since we have multiple copies of it. I generally also prefer to wrap compound clauses in parentheses to clarify that the second & third components are paired:  java if(ignoreHiddenFiles && (System.getProperty("os.name").contains("Windows") && Files.readAttributes(dir, DosFileAttributes.class).isHidden())){
No, no. Remove this logic (that checks whether the provider exists).
I'm guessing merge/rebase error. RequestManager method was the correct source for this. Controllers shouldn't require database knowledge (jdbc/table names)
Please keep this.cell near the related fields (previousFamily & cell count) below
You could do a contains here like you do with the ACCEPTED_ENTRY_PIDS.
filter(includedHeaders)?
DimensionSelector is closer to be an "object" selector, then numeric. So I think this method should just return false. Indeed, it couldn't return null from getLong/Double/Float, but it *could* return null from it's getObject().
copy.setFromOriginal(this); -- should use this here ?
Add a single quote around the metadataAlias?
Is there a reason why you want to do bitwise OR here instead of || Did you want to explicitly avoid short-circuiting?
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
To prevent code duplication, would it be possible to change the body of this constructor to the following? this(); this.builder = builder;
wasn't the purpose of DISCOVER_INIT_TOPOLOGY to call startDiscovery from there? DISCOVER_INIT_TOPOLOGY is not a supported event (processEvent)
Why is it a list of lists, not just a list?
Any worry about case sensitivity wrt to scopes?
why sync?
Suggest you use .add(BashCommands.sudo("yum install -y riak")). If running as the root user, then on some VMs it causes problems to try to execute sudo. The sudo(...) method gets around that by checking if the user is already root. Same applies for other uses of sudo.
This should incorporate the standard clock skew accommodation: <LINK_0>
Also too many dots
Fully-qualified class name not needed.
OperatingSystem.equals(String)?
This method as discussed is used in a synchronous() fashion. Not sure if you intend to do this in a separate thread
i18n too
Cache the call here and above.
Might affect the performance if we would do frequent DNS requests here. Not sure how frequent they are in fact.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
We could remove this switch by using an enum and having each part of the enum a value (-2, -1, etc.) that returns the proper ImageDescriptor. This would simplify this function to: return CommonImages.getImage(ReviewsImages.valueOf(reviewsScore.toString()))
Should not this be checked in the other way around to avoid NPEs ? We can anyway consider it as a best practice.
move this new private method to the end of the class
simplify this
I think we can use a pooled bytebuf
please use short names as apRequest
Should return type CorsConfigurer<HttpSecurity>
Are these mock objects used?
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
Wouldn't it be better to rename mPostsList to something like mQueuedPostsList now that this PR makes a clearer distinction between something being currently uploaded as opposed to something being in a _queue_ to upload?
is getServerKey() invoked for every request? Is it possible to pre-compute the value and cache the URI? I think new URI uses toString and string parsing underneath which is CPU intensive.
Not provided the Locale in the first argument can cause issues depending on which user the Locale has the app set to. I ran into this with the Simperium library.
same as above... why not use simple if/else here?
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
"Account" instead of "Accoun"
Can't this be done with a stream call?
This method is only used in test code?
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
This try-catch can be moved to the @Test annotation as well.
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
In all the other nodes, all the constructors call the most specific constructor to avoid constructor spaghetti. That would mean the this-call gets "null" at the end for example.
HTTP_HEADER_CSP
this query is not necessary as there are SELECT * FROM lineitem_ex queries in other tests
ins't KEY2STRING_MAPPER missing?
Remove the redundant null checks.
<LINK_0> Let me know if you have any issues managing or adding items to the project
You forgot this!
You could remove the braces around the first check.
use Utils.validateArg?
Please move such code to UI abstraction.
here for example could be remotePath.resolve(source.getName()) if pathPrefix was a java.nio.path.Path
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Run formatter
fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)
This is a weird place to add a listener.
default ?
LOG.info -> LOG.error
You can also use IO.close(bb) as IO.close will not throw any exception.
nit, Collections.EMPTY_MAP?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Let's avoid null and rework to empty string
Do you want to check the compile options before asserting this?
isn't it better to use the matrix in VdcActionUtils so the operation will be blocked in the UI as well? then we can validate the status like we do in RunVmValidator#validateVmStatusUsingMatrix
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
While we're at it... Maybe use a negative value in there, too?
who releases the request if an IOException is thrown?
Need to use parameterized logging instead of string concatenation. This should also be a warning and not an error.
Recursion should be avoided as much as we can because of obvious reasons. I believe this can easily be converted to a while loop.
For loop?
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
shouldn't the log message be updated?
This is not needed, since the constructor already checks it
toMap() should return only JSON based object. I think getObject() can return non JSON based objects.
Same here, you need to check that retireable fields are not null and null after
Is there a subclass? I'd like to see these protected methods be private if possible.
Why do we return the parents name instead of the name we store a few lines above?
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
LOG.error("Failed to getattr {}: ", path, e)
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
why is this if statement inside the function but checking whether snapshots are allowed is not? basically if it's not of type IMAGE then snapshots are not allowed so I'm not sure why we'd even get here (looks like the 'if' is redundant unless AllowSnapshot doesn't report correctly). In addition, personally I dislike a function with all code inside an 'if' statement. Also the name does not reflect what it does this way (it only updates if ...)
You can use checkArgument here, same as <LINK_0>
This code should be:  this.channel.close();
Could we log in the constructor rather than here? getBinding() can be called many times over the lifetime of the EvalBinding, so we'd just be getting many warnings for the same instance of the problem.
Neater: String.valueOf(value);
"isSearching" should be a class level string
In the old chaining way with only one input, we have source -> op1 -> op2 in the log and web UI. If I get this formatting correctly, we would have op1 [source1, source2] -> op2 now. I'd naively assume that it's easier for users to read [source1, source2] -> op1 -> op2. WDYT? Ofc, it kinda assumes that chaining is printed with " -> " in JobGraphGenerator, which might be less ideal. Also, how does it look for no source? Would it print op []? I guess we should have a special treatment for non-chained inputs.
Again, the default value is misused, perhaps do:  if deviceMap.contains(deviceId) { deviceMap.get(deviceId).put(folderId, completionInfo) } else { Map<String, Completion> deviceCompletion = new HashMap<String, Completion>() deviceCompletion.put(folder, completion) deviceMap.put(device, deviceCompeltion) }
desc.orElse / orElseGet would be more idiomatic
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
This & the other switch removals should be reverted, performance tests show that this isn't any more efficient. The change also increases memory usage, making this a net negative change.
The state should be deep copied if we want to store the state at this time.
Thoughts on changing this from using withContext and a String constant in Storage Common to making this a helper method in Storage Common?
suggestion edge.getTargetVertexId() + " hence failed to write to byte array");
I think when setting them to deleted individually you were also updating the last modified user. Is that necessary here as well?
Looks like these two typeTextIntoEditor commands can be united into the single command:  editor.typeTextIntoEditor("\n\nobject = MyClass()\nprint(object.");
This should be an Optional<...> on the member by convention instead of wrapping on access. I realize this is against IDEA advice.
Why is it a list of lists, not just a list?
This means clockHand will be hot at initialization time. Intended?
Check first that target is not null.
I'm missing the new field in the toString method.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Check if buffer us null.
I don't think it should be renamed
I guess this could blow up...
Unsigned types are not used in the current implementation. So, you can omit them.
Should we put the resource.getInputStream() inside of a try-with-resources block so we don't have to manually close it after copying?
Isn't this... just a re-implementation of natural ordering? I don't think you actually need this.
A for each loop on the listeners can be used here instead.
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
supernit: HashMap is [dead](<LINK_0> to me, and it should be dead to you too. LinkedHashMap is the only way to live.
Has the code formatted properly? As it looks like the indentation is not even.
I think we can remove this line.
This is a test for the userRepository in my opinion and should not be here.
We're on Java 8, so: IntStream.range(start, start+length).toArray()
To avoid old items from killing new ones, lets verify its the same reference coming back in the cache first: ObjectId key = ((LoaderRef) ref).key; if (classLoaderCache.get(key) == ref) { classLoaderCache.remove(key); }
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
There's a way to avoid that n+1: doing a query searching for all questions in (:ids) and, after that, using session.load to get the questions in the specified order as you're doing (the hibernate would get the questions from the first level cache once you already selected them before). (yeah, its not pretty, but works)
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
Would be nice to check different lengths and empty.
Objects.requireNonNull(buf)
Each of the getters in a POJO like this should have the same return type as the private member variables they expose. In this case, I'd recommend having extension, dateformat, and frequencyOverride be Optional<>s (in both their member variable types and their getter types). Our Jackson YAML deserialization should automatically take care of setting a missing field to an empty Optional<> in the resulting Java object.
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
Same thing than for the agent: no default value.
put lock() before try
let's apply the format template to the new code
style nit: no braces for single line block
Can be simplified to: java results.stream().anyMatch(entry -> value.getK1().equals(entry.getKey()) && value.getK2().equals(entry.getValue()))
This seems a bit profligate... and the stream construction around a spliterator seems a bit unusual.
Again: this else branch doesn't do anything except logging; is this really necessary?
== should be replaced by .equals(...) Same thing a few lines below.
return result != null && result.getCoverage(CoverageMetric.LINE) != null;
progress.split(1) ? Interestingly, the counts seem to off quite frequently. Here only 2 of 3 ticks are consumed. I wonder if that was intentional?
Should this also handle the suffix 'es'?
No, this. when you call methods.
Does this need to be public?
I'm in favor of just using the iterator and remove during the iteration..that's unneeded.
When is it not identifier? And does this cover things like new OuterClass.InnerClass() or new package.Class().
Be careful, this method is probably used by core plugins
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
still relevant?
I think the return type should be IborFutureTemplate as AbsoluteIborFutureTemplate is package-private.
What is the nullness contract here? Also missing docs.
How expensive do we expect calls to the ExternalResourceDrivers to be? I'm just wondering because here we retrieve the ExternalResourceInfos for every task, independent of whether they need it or not. I think I would prefer that this feature would not add additional costs for tasks which don't want to use it.
Should we use one of the core executors here?
This method should be static and need not pass this as an argument to the constructor.
Why have you added this line here? This will automatically choose first local address and then switch to remote address if the ping to local address fails. Adding this dissolves the purpose of having Local and Remote mode explicitly.
It should be final
Use CommonImages.getImage to prevent memory leak.
Wow. This method is much more elegant that it was before :tada:
This can be static.
null can't be returned here
Tokens are somewhat sensitive. Don't think we want to print them.
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
you can actually just set the private List<String> enabledTemplates = new ArrayList(); above and not have to worry about this. When dropwizard/jackson reads the config it will override based on the yaml if needed (since you also provided a setter)
Sometimes I also try to protect internal collections, but normally it only complicates things later. Can we return it as-is?
I would check getQosOverridden().getIsChangeable() instead of (!getIsToSync().getIsChangable() || getIsToSync().getEntity()) but as you wish...
Can you please add the name of the VM to the message, so that message will be more informative...
I as well would say it's necessary. If the text has \n\r and the method replaces only the \n, the String could become weird somehow.
can we validate that we actually have UQ tags?
For DTLSConnector this is configurable. I do not know whether you have given configuration of the TLS connector much thought yet ...
Is this method really needed? It's similar to make init public
40?
Why initialize this to a new OkHttpClient instance that is not being used?
This should have stayed camel case
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Not sure why you need this. If you're getting a leak here lets try to work out what's causing and see if there is a better way to solve it!
Suggestion: Keep it long instead of wrapper counterpart
Why not declare GLOBAL_ID as a long?
Why using empty string as first argument?
Could you java import static SalesforceLogger.Level.*;  So you could just write java logger.log(ERROR, TAG, ...)  Or should we introduce warn / info / error / debug methods on logger?
Can the processor name be null?
I think this should be pushed higher in patch chain.
You can safely remove the file.exists()(implicitly done by isFile
@fanifieiev the same above.
Use fs for initialization and extract GoogleHadoopFS to local variable here, and below.
does this url have to be hardcoded? can't we use the link rendering code we use elsewhere for field links?
Shouldn't throw a RuntimeException, but return null instead. The superclass should be handling the case when the returned object is null and handle it accordingly.
Could you mark the constructors @Deprecated instead of deleting them / reducing visibility? It makes it easier to transition between versions if we deprecate first, then delete later.
Should be pulled up to AbstractItem.doCheckNewName-it is not specific to Job.
You can just call optimize
Put these two assignments in order so it's clearer
This is called in the constructor, so consider using a StringBuilder here.
Check error code/description
Check first that target is not null.
Should the first parameter not be getTaskServerLogsByTag?
when you implement my suggestions with the DeribitException then it will get thrown here instead methods in *ServiceRaw classes should throw out DeribitException they should be caught and adapted in *Service methods
log a serious error that shutdown wasn't called, so as not to (inconsistently) cover for mistakes. ...nvm you did this... but why put the log over there...?
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
Too many dots, there should only be 3!
Equality/hashCode need to also take into account the attributeName field defined in superclass AbstractPredicate. Since there are quite a few subclasses of the AbstractPredicate superclass, maybe it's a good idea to override equals on the superclass to check attributeName equality in the abstract superclass.
I think the unmodifiableMap should stay in getRoutes().
this.id -> id
input is not @Nullable, remove annotation or add null check.
To always be safe please use context.getApplicationContext()
Sync clients cannot use withContext. You need to explicitly add a Context to the API args. Note that Context is supported only for APIs that return Response<T>.
Exposing PojoProperties (an internal class) to API
java LOGGER.info("Groovy console stopping...");
This is getting long, wrap wrap the arguments
can it be package private?
Please annotate DruidServerMetadata.getName() as @Nullable. Please use Objects.equals(), or regenerate equals and hashCode using intelliJ
about this API... for Cedric's VM, I just had to implement something that may change some style value for specific events. I'd like to just be able to update one style value, but the returned style map is read-only and for just cause! You could add a method Map<String, Object> getSpecificEventStyle(event) that would return only the difference and this method would merge the 2 maps if not empty. This one can be final.
please remove empty lines before } lines in this class
Replace contains + get with get and check if the return value is null
"Subscribe sample context" seems like a weird hardcoded value.
this.
We could the variable declaration and just use return decoratorClass.getConstructor().newInstance();
this should be catch (Throwable t)
Don't need this keyword here - the rest of this code only uses this when necessary.
Use readAsString(...) instead
Better to return "";.
studentsWhoRespond -> studentsWhoResponded
Why not IllegalArgumentException?
Again since the validation is done in the UI, I think you can go directly to writing the GB response
Is payeeIdL a typo or intentional?
check directly on viewOperations map.
you can make the same optimizations here as you did with the other ones: Meter meter = (Meter) checkCache(classSimpleName, fullMetricName).orElse(_metricRegistry.meter(fullMetricName)); and then remove the "if (meter == null)" check
Shouldn't this be transactional?
need to calculate logprob directly.
You don't need to start the execution plan for parameter validation scenarios
I don't think that is necessary.
Why don't you store the pattern in a final static (instead of only the String and compiling each time)?
mark this method private as this is only used in this class.
Returning the first chunk of the stream before "\A" [implementation] and returning the entire stream contents [interface] don't seem to be in sync.
What's the purpose of this line? I don't see any difference if the url is correct or incorrect. It just clicks on the Verify button and then continues with clicking on OK. It would be nice to preserve the verification result. For example you can return it as String result.
null? why not just a () -> {} ?
Change string to "EmailAddress{" + value + "}"?
Concern: These changes to the filters-related methods are definitely breaking changes, and seem like they're actually pretty likely to break existing code. (Unless I'm missing something, which is very possible.)
I think you should also have if (c == null || c.length < 7) return; or else we'll hav an NPE
Please keep the getter and setter closer.
Please, use the logger format of: [CLASS_NAME]\t[Additional Note if applicable]\t<"Message"> In other words add: [PLAYER]\t to the front of the String. <naming,organisation
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
Highly suggest isEmpty
No, RunVmCommand is executed before the VM is running, The VM's status should be down
fixen (in branch gammodes is the starting position een decorator)
Should this return the AzureTable?
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Can you throw ElasticProfileNotFoundException() if existing profile is null? the remove function below can be successfully run when null is passed to it, but the user won't know that nothing has changed.
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
You should statically define those colors, instead of a new Color each time
Missing codes.
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
Integer amount = 1 + amountOfCardsDrawnThisTurn.getOrDefault(playerId, 0); amountOfCardsDrawnThisTurn.put(playerId, amount); if (amount == 1) { // do stuff }
Create new lists rather than assigning them.
When the result of Math.pow is 15.9999999999999999, numberBuckets will become 15.
Log the exception to error.
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName());
Test should verify the DDB query. Also, we should probably return something "real" from the DDB query and pass it into the batchLoad() to verify that the data flow is working correctly.
public?
Don't you need a super.setUp() call here?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I think we should log this, at least at INFO level
wow don't fail the test here! Unfortunately,JUnit has no 'inconclusive' state, as in C#, so just log a message and return
Minor: you can be safe and make sure there is [already a folder. ](<LINK_0>
terminated = true ?
Can you reduce the nesting depth here?
Should return false if !super.supportsRefreshing()
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
Don't expose the whole list. Either a single getter getLocation(int), or an Iterable, or both if needed. And even when using Iterable, you also have to be careful for concurrent accesses. But in this case, elements are added to the array in loadXml(), which is called by the constructor. Which means that once this method becomes accessible (after the constructor has run), it should not be modifier afterwards. In fact, you know what would be clean? Putting the loadXml() stuff right in the constructor, and saving the fields themselves as unmodifiableList/Map's. Then you can expose an Iterable view, but don't have to worry about locking anywhere. Also, you often use List, when in fact the only operation to do is to iterate on them. If the order is not important you should use Set/HashSet (or TreeSet if you store Integers/Longs), it would be more performant.
This can be relaxed to Type<T> instead of RealType<T>, no?
we can remove the status variable by calling "return deleteEndpoint(endpointName);"
verify(fragmentMap.containsKey(id), "fragment id not in map: %s", id);
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
I think we need to find a better place to fit these attribute names as constants (the skipper.application.name and skipper.release.version). Currently, they are declared in the controller package but not in scope of the REST resources.
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Instead of defaultWriteObject, just handle it all yourself: oos.writeInt(hash); T object = this.object; byte[] buf = this.buf; if (object == null) { oos.writeInt(buf.length); oos.write(buf); } else { oos.writeInt(codec.sizeof(object)); CodedOutputStream cos = CodedOutputStream.newInstance(out); codec.encode(object, cos); cos.flush(); }
seems like this variable should be called json because it 'aint yaml...
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Also, why we need this change on every call to the intentChooser?
Any reason, why the plain endpoint is create in "onCreate" and the secure in "onStartCommand"? Did you read the android docu for the "on???" ?
should be called resources
should this count be parameterized?
We don't align on columns.
Why do we return the parents name instead of the name we store a few lines above?
would this be called often, and would the list copy be expensive?
Please rename this layout file as well removing _new_api.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Utils.validateArg(lowerBound < upperBound. . .)
filters method argument should be passed to isMessageInLogFile as an argument
I think we should make this default value as -1, util we have benchmarks show 500 is in general good for most of applications.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Can we revert this constructor argument change for classes that don't implement ResultBearing?
As above: eliminate magic literals.
please add line above to separate 'block'
@kujtimiihoxha Why not just "X-Netbout-Alias: %s" ?
since we're going to remove the vm anyway, this can be replaced with: if (startingVms.remove(vmId) && log.isDebugEnabled()) right?
Remove this (ORDER_MAP_ENTRIES_BY_KEYS).
This is where i think the connection would come into play: this.connection.getSenderSession()
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
Shouldn't this message be changed to "Should be 500"?
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
Why are we configuring drawer in this activity. This activity shouldn't have it.
I do not understand why is this template, I expect: public void put(VdcParameter param, Object value)
Possible candidate for bind() if that method is created.
same issue
You can clean the BlobStore via: java BlobStore blobStore = blobStoreContext.getBlobStore(); for (StorageMetadata metadata : blobStore.list()) { blobStore.deleteContainer(metadata.getName()); } blobStoreContext.close();
I think this has to go to the finally block, already after this.received = in;. Otherwise race condition.
It seems that wt10g and gov2 are pretty clean on tuna - there are no readme file or other unwanted folders. So we probably do not need these filters?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Won't fix.
why do we want to correlate cinder and managed block storage?
you can fail inside of try block instead after db.execute then you do not need to have return statement inside your catch block; also you can use ExpectedException rule
@lautarobock what this is for? there is no super class
This if is redundant. Question for you, @nezihyigitbasi: Do you see IntelliJ "warning"s for this? If not, you should turn those on.
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
This could be set in the constructor instead of checking this on every request.
Remove the redundant null checks.
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
The problem with image. It is a local variable which is returned to the caller, but you still use it in parallel as a container for image data. Situation to consider - user e.g. draw image on some panel, but in parallel the image is updated with a data from camera. Possible side effect - half of image is from old image and half is from the new one. This is because there is no synchronization between operation on image data.
- log warning that option is not supported by SNMP
same suggestion about static comparator
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
what is the new behaviour now that you don't setSucceeded to true ?
Use Iterators.transform from Guava?
This is the only place that add entry to the pool, is it the only way to fill the pool?
remove extra line
An exception without any messages or stack traces.
Do you want to make the check that portFields is of size 2?
Why WARN for FAIR and INFO for other unknown entities?
String.valueOf()
Coding conventions: Let's have the @Override on its own line please
same... do the reserveMemoryFucntion.apply() first.
public constructor in private class should be package level constructor.
This should not be done here. Use StudentFeedbackSubmitPageUiTest to test this.
You are not using getExceptionListener here.. is the test really duplicating the issue?
You could kill offset and pass 0
do not remove checkClosed()
The version check should come before the call to loadTemplates().
Have this just return an Iterator<String> because a List is a bit too specific and forces extra memory to be used even if not required.
blocking calls inside the SDK are not good. they can cause deadlock, perf hit, etc. We are not doing blocking calls anywhere else.
Consider a case where user entered a single quote ' in streamName, then the sql query can give a syntax error and the app will crash. I think it'd be better if we use ? in sql query and provide [arguments](<LINK_0>,%20java.lang.String...)) in queryRaw.
Remove extra empty line
You could also use path.endsWith("/")
virtualColumns and descending go in different order elsewhere in this class
This causes a compiler warning, please either suppress it or remove the exception throw entirely. Warnings in snippets cause noise during the build process so we can't submit patches that introduce them.
Although this won't make a difference right now (because memory: URIs are not translated) this should be return delegate.createRepository(translate(location), name, type, properties); for consistency.
You already log an error if JNDI lookup fails, as part of getAuditLogger() -- do we need this else statement?
just return "" instead of new String()
This is redundant in Mockito 2
ObjectUtils.objectsEqual(a, b) may help here.
currentTimeMillis() instead of creating a new DateTime() object
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Like, super.onFailedToRecycleView, this doesn't seem to do anything. Why call one super and not the other? Ditto for below?
nit: can be simplified to return counter++;
This change is still incorrect
Don't think the "Tenor" in the toString adds any value now. Merge toFormattedString into toString.
Exception propagation. No need for subsequent return null
We definitely need more details about what is invalid about the configuration (e.g. which keys are missing)?
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
If you create a new HttpClient' all the time and start it, doesn't it need to be stopped again?
Why do you use the qualified name here and not a standard import ? You could also call Path.fromOSString(path)
You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
Why the change? This does the same thing as the original code.
suggestion assertEquals(1, IOExceptionOnOnlineListener.onOnlineCount);  I suggest following the existing pattern in this file and calling the assert() methods directly. Then the new import also wouldn't be needed.
Please use more specific JSON type names.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Please catch specific exception(InterruptedException) not generic.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
nullity check here too :)
This should probably return WorkspaceChatSettings object
Will this work if I am trying to put a jar in the place of a non-empty directory? Which is the case when an exploded bundle is partially copied into storage I believe.
Maybe wrap in an immutable map.
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
return HConstants.EMPTY_BYTE_ARRAY; ?
This is wrong. We still need to use the folder name for equality checks.
Make this final and since we know how many tasks we're dealing with, make sure we're creating a list with the right capacity.
Do we have any threading concerns here?
again, just set the element in the array ?
These Overrides are generally on separate lines (I don't think our styles are set up correctly but check the rest of this file)
should the interface not the implementation suggestion public List<String> getTopics() {
I don't see any change that is related to elapsed-time, why is this change needed?
result -> results
need to add more information about dimension/index/length
these setters should not be public
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
Same nit as above.
Might be good to extract "Unknown" into a constant in this class
I would suggest reverting the isSytemLibrary field back
Why fakeThread
Please revert if possible
once again, equals/hashcode - does it make sense? please revisit in all value types you created
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
If partition awareness is disabled and a new node is joined it's fine to work with the current node until failure (we don't need to find new nodes unless we disconnected from the current).
remove this line
org.eclipse.papyrus.infra.ui.util.EditorHelper.getCurrentEditor() 1. do it for you 2. check no NPE calling it.
it is possible that getItemAtPosition returns null -> sure NPE here
It would be good to use constants instead of hard coded property names. Maybe you could use KFSPropertyConstants.BUILDING_NAME constant instead of "buildingName" or add new constants to CuCamsConstants.java
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
that would be name I think
Since earlier commits enhanced serialization to avoid losing multi-types this if can be removed.
simplify this
This should probably throw if the value is null.
ditto on readability here:  int result = name == null ? 0 : name.hashCode();
declare throws please
Not needed, delete.
instead of e -> e there is a Functions.identity()
A sanity check like the one in isFullMajorCompaction() that checks if scope is majc would be nice.
IMO it should be synchronized as well
Why the heck are we painting all columns ourselves? We only need to draw column 1 containing the graphical commit tree. This suggests a nice two-liner to fix this: replace above by event.index == 1 and...
truck is unused
Update the error message to say "taskLockHelper" instead of "segmentLockHelper"
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
This doesn't seem correct, you need to fetch all the active drug order and of the patient, loop through them to find all drug other orders and compare their none coded value to this drug's none coded value
See previous remark regarding explicit _Fail_ call
Please copy on construction for primitive arrays.
Please remove an excessive space character.
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
use an overridable getOperationTimeout() method instead
Instead of the Guava Objects.hashCode, use Objects.hash instead. It is available since Java 7, and reduces our dependencies to Guava (furthermore, this method is not available in Guava 21 :) ).
Let's avoid null and rework to empty string
I prefer flatMap for this. It sucks they left out Optional.stream() in Java 8 java return FACTORIES.stream() .flatMap(factory -> JdbiStreams.toStream( factory.build(expectedType, value, config))) .findFirst();
Why is it a list of lists, not just a list?
i think we should have a else here so we dont print the cwd if the user has enabled the help option.
How does the deadline in Context set by user? It seems to be harder to track where the deadline is coming from.
Why returning an unmodifiable map? The returned map is a new instance generated in this method. There should be no other reference to it except for what returned from this method. Returning a modifiable map would also save us from converting back to a modifiable map in getTaskManagerLabels and getConfigMapLabels.
Remove
why is this return null??
extra line
Could simplify to assertArrayEquals(new int[]{0, 1, 2, 3}, array)
We should name this special value so it's clear what calling with -1 does.
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Please use the generics-supporting Collections.emptyList()
This method seems weird, especially in a context of ValidAggregate. Let's discuss it.
Is there a way to do that waiting for an event to happen instead of fixed time interval?
just inline this. ex. if configuration.getPercentage() is mutable config, make a final copy. This code is simple enough that it can be inlined, and there's no reason to require an allocation or another type to do this math.
I would use getTreeItem you have defined below to access treeItem, since you implemented it. Instead of direct access.
Is this change related to updating apache velocity?
From the wiki: Its fuse lasts 40 redstone ticks (4 seconds/80 game ticks) if activated by redstone or fire, or a random number between 10 to 30 game ticks (.5 to 1.5 seconds) if it's destroyed by an explosion. In other words, right here the number of ticks needs to somehow be passed down to the explosion objects (setFuseTicks). My recommendation is to add an overloaded method to explodeBlock that accepts a boolean: blownUp (name is just a suggestion). If that boolean is true, this 'random' tick count is applied, otherwise the standard is used. I would almost go as far to say that the boolean should further propagate to the explosion object that holds the fuse ticks so that magic numbers aren't all over the place.
This is a race condition. done() releases slot, which can be written to right after done() and right before RetryHolder is retried. This can lead to unpredictable results. RetryHolder needs to be copied off before releasing queue slot
Hardcoded "Folder:", are you sure? Also check [this](<LINK_0> out.
I this refactoring, very nice. Could make this method protected.
It can be null?
We do not consider the whole resource, but only the selected elements (and their descendants). It should read "The selected elements do not contain".
"%setup -q -n %{name}-%{version}" is the same as "%setup -q"
Why is this file changing? I'm concerned that changing domain objects will have far-reaching effects. As well, there's no id that this.id can be set to in this method
events.isEmpty()
Can we use !mResponses .isEmpty()?
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
No tabs please.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Should this link to the course?
save data?
Remove this by returning null above.
I don't think this should trim the result. That's not what I'd expect from the wording getRemainderOfLineAfter. Let the caller trim instead, if it wants to.
should we enhance the statement to log the given message (and userid)? Did you omit these details on purpose?
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
input is not @Nullable, remove annotation or add null check.
Make null-safe: if (m_decimalFormat == null) { return null; }
....and then you don't need to call it on every other method
If the only parameter is the id, do you need to send it in JSON? Maybe just use an url-parameter and get it with params.getRequiredParamInt("id") so you don't have to worry about if it's not sent or if its not a number etc. Also remove the param getting out of the try-block so you don't wrap the possibly thrown ActionParamsException to a new ActionException spamming the logs.
You can use CollectionUtils.toImmutableList
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
Change the second part of || to an assert (verify).
I know this is not part of your patch, but I think we should do this only if initVirtResources() had succeeded (in gluster+virt mode). So, what I suggest here is, if (getSucceeded() && vdsGroup.supportsGlusterService()) { setSucceeded(initGlusterHost()); }
Do we really need this check? I think it's redundant.
my guess is that this should be: return receivedStatus[0] == statusCode[0] && receivedStatus[1] == statusCode[1];
Are we sure WDateField is the only input element which has a div wrapper? It may be safer to limit in some other way too - such as a check on the outer element's class attribute containing wc-datefield. I am pretty sure a WDateField in a readOnly state is wrapped in a time element and a WPartialDateField in read-only state is wrapped in a span element (the div for editable WDateField is only necessary because of the need for a calendar in the polyfill). Therefore this will fail if trying to get the component in a read-only state and the other input extensions do allow getting read-only components.
why is this public now?
Should this return the AzureTable?
it appears that this change can be reverted.
This method as discussed is used in a synchronous() fashion. Not sure if you intend to do this in a separate thread
post-content__title
Agreed. Maybe an Optional<VarRefNode>?
why uniqueKey, be consistent call it keyField
return defaultFilterFactorEnabled ?
shouldn't the last part be (getVm().getCustomCompatibilityVersion() == null && !newVersion.equals(getVm().getCompatibilityVersion())) ?
I'm not a lover of passing nulls to methods or constructors.. would another constructor without the contextId be better?
There's no real benefit to doing this check, so you can get rid of it and just do this.comparator = comparator directly).
This may not be thread safe if only one sender is instantiated. We probably only want one sender or at least only one httpclient.
Please do a format of all files before committing (ALT+SHIFT+F).
getGeometry call here is redundant, because OGCGeometry.createFromEsriGeometry(new Point(x, y), null) can't return anything other than point. Perhaps, remove it.
if at all possible let's try to avoid introducing more mess:)
We may also want to cancel our subscription.
keep requireNonNull
I think you're missing getDefaultConfigurationFile() here.
These "duplicate" entries should no longer be required afaik, because @AddonDependency now adds an implicit dependency. Try it out.
you should have here setSucceeded(true) IIRC.
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
This part of the patch looks fine and can be merged, with the small correction mentioned below.
The constructors should be package private
as long as it's the same event id that's fine i guess, though i don't really see a problem with using just one. but i don't mind
Call I18N.getString(String) (there are no parameters in the resource messages).
why would this be required again?
this is potentially costly, depends on what asMap is doing. Maybe getIfPresent and check for not null result?
@aunyks you should make expected a Set to begin with so you don't have to convert the return value of the describe method to an array
I'm not doing so much Java lately, but no flapMap available?
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
should we have an early exit if the trace is the same? I am asking, I don't know
Why not String.format("%s -> %s", argument, result)?
It's not needed to check null, also inside of QueryBy.valueOf has internal check if the item is not one of enum items, exception will be thrown, should be changed to something like:  @JsonCreator public static QueryBy of(String value) { return QueryBy.valueOf(value.toUpperCase()); }
This conflicts with the commit message - either Uninitiazlied is OK, in which case the commit message should reflect it, or it isn't, in which case the check should be removed.
nit: I prefer the other ordering for <= or ==, it's easier for me to read "n is greater than or equal to 0" than it is "0 is less than or equal to n".
lun disks removal can't fail actually in the execute part, as it's a simple removal from the db..but i don't mind having it for the future in case we'll add ops that might fail.
The dispose() could be called from a finally block, to ensure it is always called even if an exception occurs during the getText() (which is possible given that it may call user-specified code outside of our control).
Same as above LOG statement.
tracef
You can use the string overload when TypeCriteria is exact match.
These implementations are fine, but I wonder if the code wouldn't become a bit simpler if the defaults were stored as String values, and instead of the parameters.containsKey(String) you would do something like: return EventLogCategory.fromValue(Helpers.getString(parameters, PlatformSmartmeteringKeys.EVENT_TYPE, DEFAULT_EVENT_LOG_CATEGORY)); as a one-liner.
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
try/catch
Let's just catch relevant exceptions and at least log those
just a nit, perhaps move 42 to a DUMMY_VALUE constant? add a link to <LINK_0>
could metric == null?
suggestion
those operations needs to performed be in the same transaction
needs to be negated, right?
The attribute type needs to be exact here. suggestion public <T> AttributeRenderer<? super T> getAttributeRenderer(Class<T> attributeType) {
getter
Wrong test: the critetion to test is not whether the page was ever visible, but wether the user entered an explicit file name.
nit, deeply nested functional chain. Consider decomposing this a bit with helper methods. EG:  return battleState.getUnits(EnumSet.of(side)).stream() .anyMatch(unitIsActive(BattleState.side.OFFENSE));  I believe you can also get rid of the intermediate variable as well and just return the result directly as well.
np: s/LocalApplicationRunner/RemoteApplicationRunner
Which method throw exception? why change assertThatCode -> assertThatThrownBy?
Can we inject this feature directly ?
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
@fuss86 Sorry for disturbing, but don't you think that this is "tight coupling" here to check this optional every time?
The test is OK whereas it shoulf fail as the code fix is not merged
Can you make all of the accessors final?
Undertow handlers should never block. This can cause the server to hang. Instead the requests have to be queued somehow and replayed once the server finishes starting. Also I'm not really sure that a 404 is the right response if the server takes too long to start.
If this should never happen throw an IllegalArgumentException instead.
0?
The WFLY-1069 stuff should tie into this.
use { } around if body
Maybe you could split this assertion int two?
This should be an IllegalStateException.
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
@ILikeToNguyen Why the change in visibility here?
I suggest to drop this conditional, type cannot be null (unless I'm wrong :-)
This doesn't look right. Should be:  result = services.get(result.getId(), k -> this.serviceRegistry.findServiceById(id, clazz));  Also, don't forget to check the result to make sure it's has the correct type based on clazz
@eg04lt3r we've talked about this approach before in #123. there should be a thread pool.
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Is this correct?
Move to update please. < layout
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
I'm not convinced by all these _URN suffix. An urn is basically a string. And any IDE can tell you its type if really necessary. I'd remove them all.
Here, you must return getRetryAnalyzer().getClass()
suggestion LOGGER.warning("DNS multicast capability has been removed from Jenkins.");
Since this block is used twice, perhaps pull it into a private method?
I don't think it is right to return always return true for two different AuthorizationContext instances.
Should this be in line with YEdit's spaces-per-tab preference?
no need to break lines here?
Don't we have to say that this is uniqueId JDBC?
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
Actually.... what if we avoid using addFileSystemBind (that [creates a mountable file](<LINK_0> but use the bind API directly for the SHM? This ~~hack~~ adjustment does solve the problem too, but I think we're fixing it in the wrong place. WDYT?
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
We shouldn't have any LDAP-specific code outside of the LdapGroupBackend.
Should null check, anytime you encounter a boxed value you always have to null check.
+static
It is weird that getCurrentHttpClient() does not return a client actually.
The chance of creating a row is high, why don't we just create the builder at the beginning? if (lastResponseProcessed) { // illegal state exception ??? } RowMerger builder = new RowMerger();
you should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use org.apache.commons.lang.StringUtils.equals
Sorry, I suppose I wasn't clear. I meant that using == below would mean this check for null 'eref' and returning an unexecutable command would then not be necessary and could be removed. The idea being that perhaps the superclass would be able to do something useful (for example, look for a suitable reference and try again). So, let's remove this null check and see how that works.
you don't need use replaceAll, because above you used normalizeJson
method reference here as well -> anywhere we are calling a static method can be replaced by a method reference
Why is this method parameterized?
I've seen this a couple of times now, can we use Google Guava's ToStringHelper instead? Probably best addressed in a separate issue/pr.
I think it would be better to put the result of partitionsFor in a variable, rather than asking for it twice
Should this be onReplicationPutRecord?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Should this method be public?
Please use interfaces where possible.
@xupyprmv are you sure that we should use anything related to ec2?
Second condition is unnecessary (checked in while loop below)
Should getDataProvider() only be called once in the method? And should itemIdentifier.equals() be used because it can't be null?
rename to iu
Static import
Could just use Arrays.fill(max_byte_arr, (byte) 0xff); here
This if is useless, if you remove it you will get the exact same behaviour.
why not list.stream().forEach?
as with the others, need to "remember" the first via, not the last.
Don't also print stack trace, log.error will already print it. Also other instances below.
all these methods can be private
dbf.getEntityManager().merge(ref);
Can be rewritten as Assertions.assertThat(utilities.getValueList(column)).isEmpty()
Use Logger.
Please follow the style guide in CONTRIBUTING.md to add this to field access. You can turn on > save action .
do we need any content in this constructor at all?
Are we sure newValue is always non null?
it will have a bad result if the cronTaskConfigurations == null and someone will do getCronTaskConfigurations().add(configuration). probably it will be better to do it like this:  return cronTaskConfigurations != null ? cronTaskConfigurations : cronTaskConfigurations = new LinkedHashSet<>();
I suggest to keep the order consistent for easier reading/comparison: * field declarations in StashNotifier (maybe) * setters/getters in StashNotifier (maybe) * default values (lines 751-758) in StashNotifier::configure * assertThat calls (lines 27-33) in ConfigAsCodeTest::should_support_jcasc_from_yaml * setter calls (lines 40-47) in ConfigAsCodeTest::should_support_jcasc_to_yaml
Do we have to serialize the state in Operator? I think the caller class would be a better place to serialize it.
Change to StringUtils.isBlank?
I think in this class it is possible.
I think that we should send this event in task action logic Additionally used string constants should be added to task package into appropriate class
nit: space after 'if'
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
There should be an else clause which adds an error to the bindingResult, so that afterwards in the setServerSettings method we don't overwrite things with null (or get NPE).
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
Same here. See above
Same concern as above.
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
please add populate() call before addLinks()
I think Local.ROOT is probably a better choice.
@fanifieiev RequestOf is a better name than RqOf.
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
we can replace that with findAny/findFirst as we don't really need to know those vms
Should this include all the other fields a well?
nit <LINK_0> (which I think we use unless I'm mistaken) has 100char line wraps. It is easier to read when we don't wrap so often
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Remove "()", (input) ==> input
Shall we change this to "Unable to resolve the hostname of the ....". there are few other places as well with same error message.
This should not use the --metadata parameter since that is used for object metadata. We should probably use a different parameter like, --datapolicy-id or something like that.
return Collections.emptyList();
Please add ? and % as well
trivial: you can remove the isDebugEnabled wrapper
We probably should log and rethrow this exception, correct?
When does this happen?
I think we should use expireAfterWrite instead of expireAfterAccess here to ensure that we don't cache these objects for any longer than the configured time - the node details may change.
LZ4FastDecompressor requires the size of the uncompressed data as the last argument to decompress, vs. LZ4SafeDecompressor requires the maximum size of the output as the last argument, so we should only use lz4Fast if we know the size of the uncompressed data, which is not the case in this method.
There's a Map-specific assertion class:  assertThat(results.get(0)).containsEntry("name", "eric");
Doesn't this duplicate the nonNull check?
Typo here. should be service_type
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so that it can be overloaded, can we do that too?
inline please
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
Looks ugly and potentially a source of future NPEs.
just return m_closed.
can we also have a test that validates the case when we have a none-string field in span_ctx? (Validation should fail in this case)
?????
add block
I'm not sure we want to expose this. With Joey's work to add types to datasets, I thought we'd get rid of the type passing and do all of this internally.
Can we point users to some kind of regex about how to specify these options, or what the valid values are? I don't entirely understand the format based on the docs and usage string here.
No need for super()
Again, use IOUtils.
Collections.singletonList
Nipick: can we follow Java conventions of beginning variable names with a lower case? We also don't typically prefix variables with type information, though I guess that's not a big deal if you want to leave it as is.
!showButtons
would this be called often, and would the list copy be expensive?
Just "groupName".
refreshJob field should also be set to null on dispose.
Can you use azkaban.utils.Props#getUri(java.lang.String, java.net.URI) directly? e.g. getUri(AZKABAN_STORAGE_ORIGIN_DEPENDENCY_ROOT_URI, null)
Do you get any compiler or pmd error if you remove the line that throws the exception? I get wanting to make the default constructor private, but it would be cleaner if the method were simply empty.
I think that deathdateEstimated was only added in 1.11.x, it should not be known in the context of 1.10.x compatibility.
I think in this case is best ignore sonarCloud. Not sure who's reponsible for the sonarCloud rules, but in this case I'd just ignore.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
why would that throw a storage exception? It's not trying to store anythign.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
one more method where it can take file location of properties would be good.
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
other than the previous implementation in subclasses this doesn't create the directory anymore.
Why is stopScan() required here? The call to scanLeDevice(false) will call it.
not working for null input
this("Safety Command")
Make this job delete or disable it self after it has completed running. I believe its a one time Job
Can header name and value be null?
This logic is not correct since it would stop at the first '\r' in "// blah \r blah \r\n".
what about !selection.isEmpty() instead of selection.size() >= 1?
I would also include [CollectionUtils.isNotEmpty()](<LINK_0>, as it's also a null-safe check, with following method yields in case of false result : - result is false, arg0 is null; - result is false, arg0 is not-null ( and empty ) - result is true, arg0 is not-null (and not-empty)
Favor creating the exchange from the endpoint, eg endpoint.createExchange(...)
Type : stroes instead of stores.
Let's avoid changes in the classes not directly targeted by this pull request.
It looks like these two exceptions can be combined into one. I don't believe that you need to call out the specific exception since it will print the stack trace for the exception.
Please remove redundant type information in another follow up commit
public
Why leave the burden of capturing the exception to the user?
Can we use BinaryUtils#resolveClass instead of making this method public?
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Can we please add limit to the exception message? So it will be much easier to see the problem!
testType can be null, so it would be best to invert the equals() check as so: java if ("buckets".equals(testType)) {
If quality is an int, we don't need the check.
Perhaps add further information to this exception
boolean is never null. Please find a user where it is true.
missed one
please keep the buildVmNumaProperties a void method and access the vdsId fron inside
I think this should be > 0 since a value list item of 1=One does not work.
Change log level to debug
keep this the same
JDBC
You shouldn't create struct literal at this place. Because method name is getData and it's called in isAviable
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Why is this wrapped in an ArrayList? same in the one below.
Can have a isRef(Expression) and isLit(Expr)
please decrease severity to "debug"
Can we add a throws declaration to an existing public API, even if it's deprecated? We just reverted a change [1] because adding throws broke backwards compatibility. [1] <LINK_0>
avoid using \n, I remember windows contributors having tests failing because of such usage.
Recently, @yingsu00 removed all of the uses of the related form of getUnsetBits to not have an isNull vector. Her change had a good effect on memory pressure, and in some cases increased performance. I suggest we use the pattern she introduced in this new code.
one param per line; leave the first line empty
ArrayList (and HashSet for example) have a constructor taking a collection. You could just write return new ArrayList<>(LOMBOK_ANNOTATIONS);
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Please make the constructor private (see Invalid).
You should grab and store the terminationReason in a local variable, since in general a volatile field could change from one read to another.
Tests should never suppress exception but rather propagate them or use an ExpectedException rule.
The constructor should be made protected so that users can easily make a wrapper for it.
public?
I really think we should go to the bottom of this and understand why this does not resolve in the first place
You don't need a transaction here
This is super silly. Never do this and read about java string pool. Just hit java string pool in google and you will see a lot of articles.
delete() should be executed from within the future so it doesn't through right away.
Why not call put in this class for atomacy?
The local var is useless, you can remove it.
> isAssignableFrom fails because the classloaders used between the two classes is different I don't understand, this is with a built-in policy implementation right? How can two types that belong to the same JAR get loaded by different classloaders? Regarding Dynamic-ImportPackage: *, as far as I understand this is the nuclear option, so I still see a value in allowing users to pass their classloader to the builder.
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of the url.
And this change should be reverted as well.
You could probably use the same URL as in getResultById here.
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
return getView();
How about narrowing it to ClassNotFoundException and fail with other exceptions?
else if?
You can move all of this into getRadioGroupPanel, and return the FlowPanel. Or you can also do what I explained in the DiskContentRadioGroup and extend FlowPanel and simplify a bunch of this stuff.
Same as above, why not use try with resources?
This is strange.
Use the solution in the large Overall/Manage PR instead, please.
Use create instead.
@dalifreire let's get rid once time used variable
perhaps, verify that node is a ValuesNode  verify(node instanceof ValuesNode, "Unexpected node type: " + node.getClass().getSimpleName());
The code of the CompositeReconcilerStrategy constructor should be used here, and in case there's only a single reconciler strategy, it should be returned directly.
Needs some sort of assert to show it succeeded
I'm not sure silent catch is good as after that url is null and it will create exceptions
just for consistency, can we use final int?
this cast could be avoided thanks to the changes on generics on MultiIterator
the status in the message is now wrong (as you check more statuses), let's put the domain status.
Use Objects.equals() to handle nulls concisely.
throws
rename to advice or brandingAdvice
Can we log the debug message in one line? Those multiline messages could be interleaved with multiple processes.
Maybe check for if name ends with ':' so we don't do a double one?
This method is useful in some cases, but I don't think that we should make this public API. Without proper lock, this method does not guarantee anything.
This is check in the overriden enqueue method. I think this check is extra here.
perhaps if not has permission?
This looks like a copy/paste typo maybe?
indentation is a bit off here
Might as well add a comma
Please use lowercase as it refers to the argument: disposables is null.
I don't know if we should set a default key. We might want to require the user to generate something unique to their service.
@NielsCharlier consider refactoring this to use Java 7 try-with-resources.
should this have a ,  to match the rest of the pattern?
To avoid old items from killing new ones, lets verify its the same reference coming back in the cache first: ObjectId key = ((LoaderRef) ref).key; if (classLoaderCache.get(key) == ref) { classLoaderCache.remove(key); }
entryId is not used, please remove
no need for explicitly using 'this'
please move the isEmpty methods to the scimSchema
Might be worth having a displayName?
I think this should be stripe_account_id ? as per PP-4302
please use baseActivityTestRule.launchActivity() (without the "null")
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
When you bind here, you can hold a reference to the service so that this can be non-static. Also I'm not sure all the static access to the service is needed (regarding MigrationDownloadServiceBinder), you can check how is done here <LINK_0>
I'll check later, but should this be doesUserHaveCollectionAccess?
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
Let's use seleniumWebDriverHelper here
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void bitreserveClientWithTokenShouldSetTokenAndRestAdapter
@chaviw you can skip the check for null. If fragment is null then the instanceof check will also fail.
public static? Is that keyword ordering important in this codebase?
please, also check at least elements count
Maybe: if (!Guid.isNullOrEmpty(imageId)) { return validateImageTransfer(imageId); } else if (getParameters().getTransferType() != TransferType.Download) { return validateCreateImage(); } return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
Ya this is some thing we can avoid
this can actuall be: this.causes = new ArrayList<>();
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
I would prefer IllegalStateExceptions in such cases.
Same here, helps to debug.
You'd still want to tear it down. How about using a straight-forward if-else ?
According to which rules do we throw and InvalidSyntax or an IllegalArgument or an IllegalState exception. Sry, but this looks quite randomized to me
contains(null) case?
Better throw a SkipException to see the reason why this is not executed in the test output. this will also serve as a reminder for us that this needs to be implemented.
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
won't there be an NPE if upServer is null?
Shouldn't this be a field so we don't have to create one each time
please instantiate the list right above the check where it is used.
Core.ID
@ge0ffrey This is not factorial, this is base ^ base
Overdid: if null, return null :smile: From other side it can't be null. See ctor:  Assert.notNull(inputChannel, "inputChannel must not be null");
Also you missed similar fix in the lockInterruptibly() and tryLock()
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
you should account form previous page too
If I correct, we could replace this by if (cfg.isClientMode()) and remove 'client' field at all.
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Can't we instead of that peculiar disable/enableClose return here a wrapper with the empty close() impl and invoke delegate.close() in that releaseConnection() above? Something similar we have in the Spring Kafka: <LINK_0>
What if type is not Class type?
simplify this to  return getVarArgIndex() > -1;
I would consider eliminating this intermediate variable, validationResult, and just returning the result of the checkAccountingString() call directly.
should we swap method parametrr orders above?
You can use StringUtils from the commons.lang3?
"Initial connection"?
Please add at least of project in order to check that the result is empty because it return an empty list
Why do you need the non primitive class check?
Doesn't this variable actually represent surroundingChunksNotLoaded ?
Can't be just assetListConsumer.accept(Collections.emptyList())?
maybe test first char for empty letter as well to reuse s if possible?
> 0
what is this supposed to do?
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
Should throw at construction time instead.
Same here: should be Branding, not ProductBranding
This assertion should remain - when caching just Channels, there is only one connection (default). I suppose we can allow it to be set as long as they set it to 1. Will change during merge.
You might want to put the double-check-locking mechanism into a private getter of myAddrs to consolidate the logic in these 2 getters.
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
The doc needs to specify what the keys of the map are used for. From a quicklook I think it's the type of user but I'm not sure.
Error message "workspace" parameter seems to have been lost in translation
try to use LOG.warn("Unable to access property: {} {}", NhincConstants.KEEP_ALIVE_PROP, ex.getLocalizedMessage(),ex);
Why are we removing the call to hsync()? hflush() doesn't guarantee that data has been written to stable storage.
Exception again
Either of the events should be raised I think.
This method is a good idea! I know I'm nitpicking, but may I suggest to skip the contains() call and just do a get() and if null, then return defaultValue? This will skip at least one MultiMap call.
The call to super() is unnecessary.
Is this change related?
I still think you should throw an exception if name is null
remove tabs
why sampling logger? do we expect a lot of openFile?
This line is redundant.
Add the original ClassNotFoundException as cause.
The original job does not seem to extend UniqueByEntityJob, or implement the isSchedulable/scheduleJob methods, so there is no need for constraints on this job.
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
A data provider with a single entry is questionable. I was thinking the versions would be separate test cases in the provider (you'd have to duplicate the test string which is fine, and probably putting the getBytes call into the test method body) .That way, you could eliminate the rtCheck loop, and maybe the whole method.
So, if the xpath query matches event than this method will return true, right? Than the event will be propagated to TreeWalker. This java if (!filter.accept(event)) {  will be evaluated to false and the message will not be removed from the set. Thus, what is the sense of the suppression? What do you filter? Look at testMatching. The user writes the query /CLASS_DEF[@text='InputSuppressByXpath'] in order to suppress the violation, the filter should deny the event, but your filter will accept it.
I do not like tests that throw IOExceptions. I would argue that you should catch the IOException in the test and use:  java try { //.....snip.... } catch (final IOException ioe) { Assert.fail("Could not run test due to problems with a file", ioe); }
I believe this can be package protected. If so, please make it package protected.
Let's only use DsfDebugOptions... as mentioned above
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Wrong key name (unused new rewrite key name getting flagged by intellij inspection job)
extract method
I think it should be return executeCommand.execute(action, resultCallback); else you lose the "good" DispatchRequest in the process.
should it be error level?
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
The reason for the NPE in doStopJobExecution(org.springframework.xd.shell.command.JobCommandTests) comes from here:  final String startTimeAsString = this.configuration.getLocalTime(jobExecutionInfoResource.getJobExecution().getStartTime());  The JobExecution startTime can be null.
s/policies/policy
+ desc
you import ByteBuffer, no need to use the full package path
Which type would be assigned in this case?
oh, this comes form apache. Maybe jsut ust "" even if it is not that readable.
please just define on the next row.
This code style might give formatting error. Even if one line statement it should be within curly braces.
Use config.getTrimmedStrings() instead?
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during the git clone or other editor that changed the encoding. On my clone :  $ file src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest.java: UTF-8 Unicode c program text
Missing call to super implementation of onResumeFragments()
Same here: should be Branding, not ProductBranding
This method might be the one in public.
can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general.
use an overridable getOperationTimeout() method instead
Optional
better use a local variable for the return value instead of modifying the argument
Does it still make sense to use forkJoinPool? The tiles are no longer downloaded at this point, so it would add an overhead to run this in parallel.
getClients(this, null, null)
filteredProgrammes is a bad name for this, and as far as I can tell, these should be Episodes, not Programmes by now.
This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.
nit: as above for external, and entity here and below
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
Could you please explain this? Why should this hold everywhere?
Replaceable with Iterators.transform()
I would use List here
move check back as first in the method to not change behaviour if null is passed as unit but we are in the EventLoop thread.
Maybe those two should be extracted to constants since they are used in two tests.
exception does not need to be caught.
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within addToResponseBody()?
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here.
Log the Exception
why not just req?
Why we don't call onDestroy() method of playerSkinLayoutController as early?
Should be a SamzaException with a message, not NPE.
Lets use isRebalanceEnabled from kernal
What if we don't want to set it? How does the UI know that this has happened?
Does not make much sense to create a new instance of MentionsData to return a static.
these setters should not be public
suggestion this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace, "'fullyQualifiedNamespace' cannot be null.");
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
if mockTime was incremented by exactly the time required to trigger the operation timed out error, why would we need a loop?
nit: check if this is empty, and if it is pass null? Otherwise you can't add an initializer on the copied instance. (I'm looking at the constructor and trying to figure out what the opposite assignment is!)
if you compare against the ID of the view rather than the instance you don't need to maintain the fields
do these test methods really require throws Exception?
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return the status of #cachedVds ?
You can use ExpressionUtils.methodName(mit) for that.
I think you want observeOn here... although the effect is the same.
how about renaming this as newPage()?
should we have Objects.requireNonNull in these?
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
If we move the logic to the builder factories, this would not be needed.
Still getting the compile error in Eclipse and code is still littered with type warnings.
looks like duplicate code, can it be refactored so it's not in multiple places?
This function no longer needs to be protected. It should be private.
I am not sure if 503 is correct it this case. It indicates that something is wrong with server. In my opinion 403 will be better.
I think ServiceDiscoveryManager should be a field of this class.
@Happy-Neko Let's call this from, [avoid compound names](<LINK_0>
As discussed f2f, please see if the async flag used by the REST is a known bug or is there some other way to monitor async commands in the REST. Any how, this code will seem to monitor the tasks twice, once by the ExportVmCommand and also by the child command
replace with: Mono.when()
So before this change, it would make sense to return the reference to the stopped service, since it wasn't part of the API that we supported re-initializing the ErraiService. But if we are going to allow that, maybe we should be checking isInitialized() here, instead of just service != null?
this should probably fail on receiving interrupt
Should this be put in the try block so that the exceptions it throws are wrapped?
Could remove the else
suggestion + "The requested operation is not available while the JobManager is initializing.");
Is this one of those @VisibleForTesting things? Seems unnecessary
Yes, we should. Don't we have a helper method to automatically do this?
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
This is a change of behavior. Some tests might not require all nodes to be up and trying to enforce that here seems like a stricter check. The earlier check createKVS can succeed if we have quorum too. We can perhaps have a classRule in the test classes to disableAutoCompaction if thats the first thing to do? Does this nodetool command require the node to be up first?
static import readIntLittleEndianOnOneByte.
The only reason this should be null is if the Activity context was used instead, so in that case we should throw an IllegalStateException or RealmException saying that the application context should be used, otherwise all the import logic will fail silently as far as I can tell.
Let's avoid null and rework to empty string
This is a pretty cool solution :) I think we'd need to excavate something out (or bake something into a plugin) to make sure tests run with -ea, because I just tried putting assert false in a test and it still passed!
Please add ? and % as well
How about this one? I think there'd be a standard error code for this.
hey, I'm not super comfortable with "%n" and "%p" as delimeters (It's totally reasonable to imagine that people might have "%n" in their text). Are those directly in markdown? If not, we should talk about how to do this differently
since you are awaiting termination otherwise, seems like this should either be an isTerminated() check or you should do an awaitTermination() anyway in the else. Let me know if my understanding about the ExecutorService interface is wrong.
Missing StringUtils.isNotNullOrEmpty() check
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
This should really not be public.
To defend against catastrophes from bad future refactorings, I would recommend extracting a protected method for the computer's log directory, to make it clear that what you are deleting is specific to this computer only.
Great tests. I'd suggest using nio (Files.copy and Paths), rather than bringing in the dependency in the org.codehaus.plexus util, that is available now, but is not listed explicitly in the project dependencies. For simple things like these it's almost always better to use standard java library stuff in tests.
Calling a public method from a constructor is error-prone, could you extract the default implementation of refresh() to a private method?.
this needs to be wrapped in an if (timestamp != null) check
Maybe wrap in an immutable map.
could you rename this to storelogimages?
missing a final
If you want to remove not null validation from constructor, it should be added here
You'd probably dispose your stuff, and call super.dispose() at the end.
For me it looks very strange that for initialising collections we use two different approaches within 5-line method :) (Guava and java.util.Collections) I would prefer to have homogenous approach (at least within the same method) doesn't really matter which one.
I think "debug" is better here -- this kind of diagnostic is a bit too loud for logging by default.
Since v is not used/needed, could use thenRun here like .thenRun(() -> cd
These arrays could be defined statically in this class, as to not create a new array every time this method is called.
Please use object instanceof ResourceAtt...
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
Also this should be Log.d
can you pull this from a static string?
You change some methods signatures/arguments into _*NameCount*_ but these methods still containing _Segments_ wording
thrown.expecteMessage(). minor thing, i am fine with this.
We should still render as before, change the text size of the button based on the text_size attribute if present
For proper testability, should these also be listed in hasService()? ...or have we just been passing this test because we run it on the right kinds of devices?
I think this should be "Setup Trigger". Shouldn't that be externalised to strings.xml though?
we should change this - and the other two getters to @Nullable public Long and return objects instead of primitives
Same thing as above, let's split out a config for this.
White space.
Index could return a List<Question> instead of List<Long>, right? The less logic we have on the controller, better
pvk should not be visible. Please remove it.
Actually, the target of the test is the function onShutdown. I would like to test it to be sure that if something changes in the future, it has a test to verify it.
We always use brackets, even if the if only has one statement. Same goes for the else clause below.
This class is still beta--I would be OK just making this method non-static and using the registry
Could this be protected as well?
Can use validatePrimaryLanguage here and below.
Can you handle parse error here?
Why not public access?
Can this be private, or is there another use case for default attribute outside the builder's call?
I this refactoring, very nice. Could make this method protected.
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
Should not it be [less than 20](<LINK_0> ?
Same question as above
Maybe make it protected instead?
Would prefer to store the quark as a member of this class and keep the getThreadQuark method.
Once we start using placeholders, the getString() API can actually support it via additional parameters; it's pretty cool. suggestion String dialogContent = getString(R.string.confirm_deletion_message, " \"" + listName + "\");
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, (0xff & (hostAddress >> 8)), ... }; try { inetAddress = InetAddress.getByAddress(addressBytes); } catch(UnknownHostException e) { return null; }
i think it's slightly better to add one more argument in AzkabanFlow constructor called type, and let builder handle the default parameter passing.
After having a look at the entire class, all tests require this to be present. Throw a SkipException here to automatically skip all tests in this class, showing the reason?
The same as with previous - make it final, don't check for null (reduce amount of lines)
nit: remove else {}, throw exception after if block.
following the change above, i'd expect this one to look as: assertTrue(validate.isEmpty())
RetryState rs = null; while(!success) { rs = state.get(); ....
Is it possible to use a title here? I think PageTitle wants the normalized title. I know that in this case card.filename() uses the title internally but now there's a weird PageTitle dependency on filenames if it ever changes. For example, I could imagine it becoming file://foo and now PageTitle interprets it as the File page for //foo.
Make use of the [lazy holder pattern](<LINK_0> to prevent the conditional at each call.
Once we move to a simple, declarative boolean passing model, we won't need this line.
clone should not use duplicate... duplicate should be an alias of clone. hmmm... you created infinite loop? clone->duplicate->clone? this entire logic is incorrect... should be, something line: CommandContext cloned = (CommandContext)super.clone(); cloned.setFromContext(this); return cloned;
Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it. Maybe a link to general information about Validate Requirement Changes so that we could add other things as needed. An this would just be one of them.
Please put entry.getKey() in a local variable.
I guess it can be moved into the if statement
or just java public static Object[] data() { return TestPlatform.values(); }
I'm not a big fan of this format. Let's keep things consistent and put curly braces around the throw new CandybeanException
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
please fix the whitespace. You just need to return the options here.
If the list of users stays the same, make it unmodifiable in the class constructor.
The return value of this method has switched. getAndSet is going to return the previous value, which is true if it already was under backpressure and false if it was not. This is the opposite of  * @return true if an update was recorded, false if taskId is already under BP  This is used to control when the server sends messages to the client about backpressure, and could make it happen not frequently enough and the beginning and then way too frequently after that.
Load and termination parameters should belong to Load and Termination entities
This class is intended to be threadsafe, right? This would need to be a CAS on an atomic long then.
This code is correct, but it could be implemented in a more succinct manner that is a bit easier to read: public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrManagedConnectionFactory ) return this == other; return false; }
KernelMemoryAnalysisModule
Extracting the results of the getHeaderParameter() calls to local variables should make this easier to read.
I'm not 100% sure but I think this should be the other way around. feeds.size() seems to be the expected value. This problem is also present in other tests. Before, a failing test just showed something about a failed assertion. Now it shows actual value and expected value, so it is misleading if they are exchanged.
why the braces removed?
The null check should be done by the caller (if at all). Currently, a null will trigger the else() branch of the if()
nit: use SUBJECT
This can be simplified to return this.cmd.hasOption(optionName));
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
This will most likely blow up when running within Wildfly since Wildfly does not use DefaulCacheManager implementation directly AFAIK. They implement a delegating cache manager AFAIK. I really don't see the need for a removeCacheLocally method at all. Can't you create a private method in this command, get the component registry from the cache manager, which can be injected, and in the private method do everything you do in removeCacheLocally? If the method needs to be accessible from multiple places, add it to a util class as static method passing in all the parameters needed?
why not use super? like: return String.format("%s, volumeId=%s", super.toString(), diskImage.getId())
Swapping the order of parameters would be more consistant with the standard method this replaces/wraps, ResourceSet.getResource(URI).
An exception doesn't necessarily mean datastream not found, right? Why not check the http status?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
it appears that this change can be reverted.
Use switch - case - default instead of if - else if - else if - else?
better to have fail(); in the onSuccess()?
You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
You can make use of early returns here to reduce nesting, e.g. java if (userInfo.isAdmin) { return; } if (!userInfo.isInstructor) { throw new UnauthorizedAccessException(...); } // everything else
Should make a differentiation of the name and id.
Cache this value.
This should return T.
-1 as this should never happen, and the message highlights something fishy
Missing super() call?
you have to add a canDoAction message if you fail canDoAction
I don't think we need to observe on any particular thread
You're not checking the mediatype here. At this point, do we just have to assume that jax-rs has called the above method and is giving us something sensible?
remote this
This will only work if Jenkins is running on the same host as the docker daemon. It won't work in the general case where Jenkins is on a separate host from the docker hosts/swarms that it's talking to.
bad hashcode.
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Just return the result from parseInt from here, no need for the count variable.
Remove the public modifier.
Use java.util.Objects.equals().
can we change the deprecated (since java 9) call .newInstance() to .getDeclaredConstructor().newInstance() (and extend catch clause)?
equals!
This log will be shown pretty often..
null? why not just a () -> {} ?
we never use NULL, it is a bad practice in general.
I think this will not be enough, because you must wait until there are no currently running tasks
This exposes the unicode workaround to the public.
nit, Collections.EMPTY_MAP?
nit: can be chained onto previous line's assertion
test case works good but it is not clear where did I have got the resources for second card. how about splitting a method playPreparationStageAndBuyCardYearOfPlentyAndPassCycle() on several parts? for example: playPreparationStage() .nextRandomDiceValues(asList(1, 1)) // P1, P2, P3: -- .THROW_DICE(1) .giveResourcesForDevCardToFirstPlayerAndBuyIt(YEAR_OF_PLENTY) .giveResourcesForDevCardToFirstPlayerAndBuyIt(YEAR_OF_PLENTY) also create separate method passCycleAfterFirstPlayerTrewDice() when needed.
Please move to a separate "Polishing" PR.
Typo: The file already EXITS :) I would also be more explicit in the message: "The file already exists and the columns selected do not match the existing records"
I would try to avoid forcing crate the temporary folder at current path if possible. We can omit the constructor argument, and set executableFile.getAbsolutePath() to the configuration.
Maybe make this "Initializing monitor for..." to distinguish between the init() and configure() method below.
n["+fTimeArray.length+"]("+min()+'\u2025'+max()+')';
I think it is common to return the written value.
StringBuilder
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
\>= ?
These two assertions should probably be their own tests, testNullPath and testNullPathWithRoot respectively.
Shouldn't this test keep initial @Deployment annotation here, so it keeps using the same process definition as before?
should the SortExpressionExtractor be renamed as well?
Hi @diegolovison , I think the message here should be not stopped but: Pattern.compile(".*\\[org\\.jboss\\.as\\].*started \\(with errors\\) in.*"); (at least this is how it was before Gustavo's changes) Would be great if you will fix that too. Then I will rebase the PR as I am facing this issue too.
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
Could we consolidate these catch clauses? Or is HornetQException a RuntimeException?
I am guessing your builder needs to have isShared and isAudited set to default values (false) here. Also based on this: <LINK_0> Please add the corresponding docs for the properties here and in other places as applicable.
optional: This message doesn't look so great --- isn't it a valid ref name, but just a missing ref? We can avoid the test being too prescriptive by making the matching less exact (e.g. by checking that the message contains the ref name). Alternatively, a followup change could improve the message.
I think protected might be more appropriate
"Error while moving file from ..."
nit: space between if and (
This could use Objects.equals().
You can call this.setTimestamp(timestamp) from here.
Is this necessary? If I remove the update line everything seems still to work.
It should probably return ISegmentStoreProvider
Use Collections.emptySet() for initialization.
Where did 31 come from? Why not use *=?
this("Safety Command")
Maybe switch this around to use Logger?
Why is it a list of lists, not just a list?
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
nit: can you put "File connector started" instead?
remove mRoles
Typo "...position comman**d** failed..."
I have to admit that I don't understand enough about this, but could this be a binary compatibility issue?
the literal translation from Kotlin throws a NPE here (because the ResourceWebscript has a @NotNull constructor argument and the calles uses the !! postfix) throwing a null-pointer-exception here is not ideal
Use equals - there is no guarantee that it's the same Guid instance.
You can replace the screen position click with TestUtils.toggleNavigationDrawer().
We don't need another ImmutableList.copyOf. You are doing this when parsing.
You don't have to test if the hive is in the nether, because the nether hive is from binnie and not from forestry.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
please make sure you are rebased. this method was renamed on Feb 11.
The operator should be && not ||
format should default to "tar.gz" is null or empty and not throw an exception.
You've declared this method as nullable, but only use it as not null - why not make it not-null instead?
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
never null
nit, Collections.EMPTY_MAP?
do not assing parameter! nowhere!
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
Okay this is better where it can self-heal and reconnect. Fix checkstyle issue however!
We can use bit-operators here to test for the bits in the permission bitmask :) Executable is 0b001 = 1 Writable is 0b010 = 2 Readable is 0b100 = 4 So we can replace this with: java return permission & 4;
reduce to debug
Don't we have to say that this is uniqueId JDBC?
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
like line 63 but this is setFeature, so should be removed?
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
ChannelClosed needs to be added to (though not strictly necessary)
Actually the underlying objectExpr could have free variables.
Apply try catch to this line only
I think it should be NegativeLocationFilter (like the class name), as there is another class called NegativeNodeLocationFilter
What happened to this line?
You've declared it to be an string in the schema so why the need to convert it back to an int?
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
This can simply return NON_APPLICATION and isApplicationType() can be removed. The methods will always return false.
Don't you need a super.setUp() call here?
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
please use parameterized logging here :)
More user-friendly to say "', only Switch, Number, Dimmer, Rollershutter and String items are allowed - please check your *.items configuration"
The magic constant 2 is a smell here, can what's happening here be clarified a bit?
attr.length() doesn't do anything here, you can remove it.
you can just inline this
These should get saved in a data structure so that repeated calls with the same name return the same map.
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
you need call addColorSettingsListener on the new instance.
Collections.emptyList()
change
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
looks like we're only updating the timer metric if it's a writeAround cache. I'm not sure if we should do that - metrics should be updated regardless since you're measuring the time it took for the "delete" operation right?
No need for super()
Sorry did not get. How AtomicBoolean is different compared to boolean wrt repeated roll possibility. In the past we used to keep the Boolean state in a Map. Now in this object.
shouldn't this also check the "" case? Consider using Guava Strings.isNullOrEmpty
We can get rid of the above variable
currentRemoteHostId ?
Why not a for each loop?
This commit appears to duplicate changes from the #430. Is this intentional? Which branch do these changes belong on? They should only be on one or the other. Please amend one of the branches to fix this.
The logic of this method should return true if any part of the range is covered by any part of the Block's revision range. Currently it only returns true if the entire range is covered by the Block's range
Given the other changes, I wonder if the handler is needed at all or whether just need a way to disable it. If keeping it, I wonder if onReceived(Map<String, Object>) and onProcess(Map<String, Object>), and then all _received_timestamp and highWatermark logic could move into the handler.
Ideally, this test wouldn't require any change to pass. The aggregateType wasn't used in the past, and unless polymorphism is used, the type shouldn't really matter.
So we roll back to the previous behavior that only QUEUED queries has resource group info?
And get in the end to check that there is nothing in the collection on the matter.
do we need to unvoid..?
The test error seems to be due to redefining the table in a transaction while the client has cached data. Consider using a new table instead of redefining an existing table.
Can be private, I think
this method is useless. Can you send a patch to remove it so all the code that needs uuid will simply use UUID class?
throws IOException can be removed
return !sniDomains.isEmpty();
You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure
I would guess we can make the rule usage more expressive with chaining calls to this method instead of passing the classes in the constructor.
You could add a check(String sqlQuery, java.util.List<Row> expectedResult) to FileSystemITCaseBase.
Name doesn't look right
This empty is unnecessary, I believe :)
What is the reason for appending 1 to the variable name?
should hashCode really depend either on taskName, or description, or hashCode?
Please add an explicit encoding (using 'ISO-8859-1') when converting the string to bytes.
"Initial connection"?
This class is intended to be threadsafe, right? This would need to be a CAS on an atomic long then.
I would suggest create method for computing that selector and instead of replacing strings we can use string concatenation like: String.format("div.autocomplete div[title=\"%s\"]", toolName); Or we can use that inline here.
I'm not sure if we should add this to the interface. Not all implementations need to generate data ids in this method. How about removing this and instead throwing a RuntimeException at the implementations that use DataIdFactory?
Which type would be assigned in this case?
Any particular reason that you published an EventStatus instead of publishing an EventOutput directly? Remember that pumpEvent exists.
Making only this message a constant only makes it less readable, and is essentially meaningless. It's a good idea to undo the fix or standardize the argument checking.
Check for equality of error code
As with Fields, this should be immutable.
the write call might throw an exception which results in close not being called.
Optional
No, this. when you call methods.
nicer to have a method IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
These 3 methods should be private, or if useful outside of this controller, they should be in a utilities class
As setInstalledLineNumber, this should also set RESET_INSTALLED_LOCATION
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Please just use a mod here...
so this String.replace will be String.format(blah, blah) as per the above
Is order important here? Should the 2 collections correlate each to another?
If possible, generally please make all values final. It is one of the main rules to achieve functional programs.
finalize?
Needs to consider the new custom fields.
lowercase for package names.
Lists obtained from a message are immutable. No need for extra copying.
Lists obtained from a message are immutable. No need for extra copying.
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
return Collections.emptyList();
What about if there's an error? Make sure that done gets set back to true. Or at least report something.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Well, if we know the Exception so its not really "unknown" :-)
It's not public, it can be changed. We need to have it backward compatible for one minor version. If this is to be released as 3.9.4-c1, MC 3.9.x and MC 3.10.x needs to be able to work with this. You can add extra fields which we will use in an upcoming MC 3.10.x release. Removing the field needs to be delayed until HZ 3.11 where we can adjust the codebase to not expect the field.
java String desanitizedCourseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(obj1.course.getName()); String desanitizedCourseName2 = SanitizationHelper.desanitizeIfHtmlSanitized(obj2.course.getName()); return desanitizedCourseName1.compareTo(desanitizedCourseName2);
We may want to log a warning when files are _not_ applicable, since that would indicate that some kind of junk had been uploaded.
May be it is better to cast meta to BinaryTypeImpl right here?
consider renaming this to detectLanguageBatchWithResponse to be consistent
it doesn't work for multi reference + complete tests please.
Preferably have one call the other?
Is there a chance of a NPE? could be getFile() null?
now that we have some permissions in common in ImportVmCommand and ImportVmFromExternalProviderCommand, we should probably move the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to ImportVmCommand and have the permission check on the destination cluster only in ImportVmCommandBase as it is common to all import commands, what do you think?
add if (o == this) return true;
take a look at how the output schema is generated from the inputSchema, <LINK_0>, if it is not in the mapping list, it is identity, if it is, it gets mapped to some other value.
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
Can't we do this once at the start, since we always enable(true)?
Method doesn't appear to be used. Can't use day-of-year here anyways, as leap-day would make it behave strangely.
nit: can you put "File connector started" instead?
Another getBytes(StandardCharsets.UTF_8) opportunity
This method name does not reflect what the method does. Maybe call it "applyBuildersValues(conf)" or something.
I don't think copy is required here. Even if we did this for immutability, we'll have to do this again in getter methods which we are currently not doing. So, just copying here isn't useful.
remove this too
this does seem to cover some people who might have a legit reason. but some do "gc/runFinalization/gc".
Please implement toString() to provide debugging state information for debugging purposes.
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
![MAJOR](<LINK_1> Remove those useless parentheses. [![rule](<LINK_2>](<LINK_0>
I think we have to make as BlockingQueue and use its poll(timeout) to block the testing thread for the message from the async internals. There is no guarantee that all tests are going to be direct and sync. WDYT?
make this constructor private since all the methods in the class are static.
int[] props would make everyone including the style checker much happier
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
You can use assertTrue and assertFalse instead of assertEquals for these tests :)
suggestion Objects.equals(value, other.value);
you can do something like CategoryField.class:: isInstance
@olenagerasimova it should be appendText(this.text(item)), this.itext may point to wrong value, if text(item) != this.itext
Another minor note, any reason not to merge this into a single check? if(values == null || values.isEmpty()) return true ;
I would suggest making this method synchronized
The ListenerList implementation already takes care of this. Remove the "contains" test.
canConnect( server.address(), clientGroup ) can be extracted to a no-params method
negative logic
Why not declare GLOBAL_ID as a long?
could we use a descriptive value instead of empty string to denote the header was null?
I think JPA requires this to return a Long
null != settings
should this be splitted into several try/catch blocks because now the httpPoolingClient might not be touched if httpClient.close() throws an exception.
What is this for? Feels like some unintended checked in code?
What is the boolean here used for?
note when rebasing that i added the following here to handle missing data:  if (data.numHetsInSegment(segmentIndex) == 0) { return Double.NaN; }
Should be outside the if
This can just be catch Exception.
How about a test for an override in a nested class?
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
Here we could try to store the ObjectMapper in a static field - preferably in a package protected helper class. This way we would avoid that we recreate it again and again. And as far as I can see this should be thread safe too. What do you think about it?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
It is confusing to have unrelated asserts in one test method, please split those into separate tests.
Why not check result.isEmpty?
This could be replaced by Folder::new.
@pefernan here the message should be: logger.warn("Unable to parse value of " + KieServerConstants.KIE_SERVER_MODE + " = " + modeParam + "; supported values are 'DEVELOPMENT' or 'PRODUCTION'. Falling back to 'DEVELOPMENT' mode.");
Since this is an opaque entry, then you know for fact that the arguments array is an array of byte[]. So you don't need to allocate a buffer and do the copy just to calculate the size. java int size = 0; for (byte[] buf : arguments) size += buf.length; size += (SMRMethod.length() * Character.BYTES); size += Integer.BYTES; return size;
is this complete or startSnapshotApply? it seems the semantic of that method changed, we should also revisit the messages that are within that method.
same here (using getNode)
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
I'm guessing merge/rebase error. RequestManager method was the correct source for this. Controllers shouldn't require database knowledge (jdbc/table names)
size is calculated here. Do you want to change sizeCached to true?
The last assert is different from the first 2
We might want to add a null check on getActivity() here since the clients of displayNewPage have no idea about Fragment lifecycles.
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Coding best practices: Interface i = new Implementation();
maybe we could make shortcut for: FeatureSelection.all().without(ENGINE_ONLY).build()?
@fchauveau there is no null handling of source, is this intended ?
Is there a reason you chose _system_name environment variable instead of the os.name system property as described in the [Java properties](<LINK_0> tutorial?
I believe it would be more understandable to do the following:  // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
Override
Should this try to create a URI with the old logic when it's null for retro compatibility ?
This is effectively your synchronization barrier? After fetch(...) returns, you are guaranteed that the value will be populated in the cache, assuming the writer is utilizing the same cache. Am I understanding this correctly?
Why is the EMF specific RP is the default? Should this method (and the class) be abstract to indicate that a specific result provider implementation shall be selected?
Help me understand why lazySet is safe to use here. It seems we want to have visibility of this value when we next read, but my understanding of lazySet is that it does not guarantee that.
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
new HashMap<>() will do
No quotes at all? This won't work with drillthrough operations, where the column alias might be two words. Not quoting them will create invalid SQL.
File
We need to also support platform 2.1.*
revert as this code isn't used in this PR
Should be a space after ,.
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
Nitpicky stuff: This method performs the key lookup twice when you could do the same operation with only one: JsonNode node = json.get(key); return node != null ? node.textValue() : null;
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "key". [![rule](<LINK_0>](<LINK_2>
remove the explicit initialization?
I think this check can be stronger. Rather than checking the comparator's equality, why not check the underlying type? This check would allow merging stats for binary and binary/UTF8 types, but I don't think that's right.
Extract this try-catch block to a method to avoid code duplication
Shouldn't that be Class<?>
you turned around T & I here, it should be declared as:  protected <T, I extends T> @Nullable I getService(Class<T> clazz, Class<I> implementationClass)
omit using return in void methods, it is less readable and it is hard to debugging
Interface is one word, so no camel casing here
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
HashUtil.combineHashCodes
return only if the provider is an AnalysisModule?
So there's a bit of a elegant hack to doing this: You can redirect to do the same as the original method, and then override this injection method in VillagerEntityMixin to do all this logic that otherwise you'd be doing. I do this with WorldMixin_Tracker and ServerWorldMixin_Tracker to do extra logic only on server worlds for injections that are in the subclass.
please use vmDisksSource here as well
Should we return immutable list here?
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
Work is generic, so add <?> at least
not related to this PR but wondering if returning null or an Optional.empty() in case of corrupted data shouldn't be better.
If this is on the write side, keep in mind that texts can be reused.
The this. in getters are unnecessary too.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
This method should be private in visibility.
No, this. when you call methods.
nit: just a personal preference, but getting one less internal reference to a public function all makes the code usage check easier, like features.get(feature).
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
suggestion bannedColumns.add(COL_ID_ACTIONS);
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
Ran into a spark bug a few days ago where a shutdown hook firing during a "clean" shutdown causes problems. This method actually needs synchronized or else a shutdown hook fired from a SIGTERM won't wait for runCallbacks() to finish
Have we got room to always use 3dp
Can this be private, or is there another use case for default attribute outside the builder's call?
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <- remains unchanged logger.info("Not skipping file: {} ", source); <- just before the return false and let's drop the first looking into file...
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
Do we really need to check anything here? Surely the enterprise edition supports all constraints?
<String, Object> not needed.
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
return Collections.emptyList();
You can use && instead of nested if
extra space.
singular
docIds.size() > 0 -> !docIds.isEmpty()
Throw an unsupported operation exception here.
this field name is confusing since the parameter passed to the constructor is a File but this is a PackFileName, maybe better packFileName
There is no need to call super explicitly. Same applies to other constructors.
What a reason to have a public class without any public methods, with one package private method? Consider making class package private or method public.
These Overrides are generally on separate lines (I don't think our styles are set up correctly but check the rest of this file)
This test checks topic creation. Why do you call replyTopicStubs?
@pynicolas Can't we just compare hash codes instead?
Maybe we should also deny requests while recovering after a shutdown
This also regresses in that it no longer works for multiple repositories.
unused?
PG_TYPE_TO_NAME should be an array (dense)
Did you take a look at this? <LINK_0>
Please remove this empty line.
missing @since 4.5 for new API method
@dmzaytsev let's extract this into a private final String variable.
Need to check the hint is not null.
You can make this method private
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
I don't think you need this new String
would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
We have a removeConfiguration so let's not allow null value here?
lowercase for package names.
Debug has to be detected first otherwise we'll always take the INFO branch.
How about Collections.emptySet() ?
Move this validation to PluginProfileService.
What is the purpose of catching this exception. If this thread is interrupted it sounds more like an IllegalState somehow?
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
I'm not convinced that showing the context (Workbench, etc.) is particularly meaningful to most end-users and adds a lot of visual "stuff" that in most cases you'll train your brain to ignore? Plus when using a screen reader it causes that context to be read at the start of every command as you scroll through the list, significantly slowing down the time and cognitive load. At the very least, maybe an option to turn it off both visually and audibly? Or maybe it has more value than I realize.
What do you think about Comparator.naturalOrder() instead of null ?
remove.
Should we make special code for null (maybe by comparing size of this vs. size of hash map).
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Why wasn't this left as-is? I'm fine with it, but it just didn't follow the pattern of the rest of the PR.
Add default to the switch
Part of this method throws IllegalArgumentException and another part returns the error message. Please make all branches throw an exception.
Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?)
please move calculateScope(ast) inside expression to speedup a little bit performance, scope calculation is not always required.
Please move this method and patternIsEnabled to the end of the class, similar to PassCodeManager class
times(1)
I'd prefer to have a createAndSetUpSlotPoolWithoutResourceManager() to replace createAndSetUpSlotPool(false).
Consider returning a constant
return onCancelled()?
must be immutable :  if (null == this.map) { this.map = .. } else { throw new KasperException(..); }  if you can add this also on the CollectionQueryResult it would be really appreciated :)
Would effectively revert [JENKINS-60088](<LINK_0> Exposed labels in Kubernetes have no effect on the Jenkins labels. I would recommend reverting this hunk.
By composition, do we need this?
You're testing two completely separate features of the class: 1) closing of environment, 2) converting environment to string. There should be two separate test methods. This anti-pattern is sometimes called "Test it all" (<LINK_0>
BlockPos.ORIGIN
Any reason to use an unmodifiable list as the list is already a newly created one?
avoid using \n, I remember windows contributors having tests failing because of such usage.
any special characters to block in webhook name?
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Is it guaranteed that requestObject is a SmartMeteringDeviceDto !?
maybe test first char for empty letter as well to reuse s if possible?
nit: maybe call them flattenDictionaryBlock and flattenRunLengthEncodedBlock?
Tiny style thing, can we put brackets round boolean expressions like this e.g. boolean valid = (files != null);
The constructors should be package private
Actually the underlying objectExpr could have free variables.
wrong formatting - every parameter should be in new line
I think this could be logged as just debug.
@bdragan transformed variable is redundant, it can be inline
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
This line gives a warnings in Eclipse because implicit boxing between false and Boolean.FALSE is used. Better import import static org.junit.Assert.assertFalse; and use assertFalse(repo.getObjectDatabase().getPreservedDirectory().exists());
nit: this is Optional.ofNullable(metricName.safeTags().get(ADMN.TAG_CURRENT_SUSPECTED_LEADER)).filter(x -> x.equals(String.valueOf(currentLeader)).isPresent(); though I'll leave this as personal preference
This piece of code really would be easier to read:  haxe ResultHolder typeResult = getType(null); ResultHolder resolved = resolver.resolve(typeResult.getType().toStringWithoutConstant());  The way my mind works, I read getType(null) to call a local function, and the following getType() I also presumed to be the local function -- which didn't make sense. It took at least a minute just to figure out what was going on in that line; basically that the return value of getType(null) was not the same type as 'this'.
Can call the method directly, instead of using reflection. return FieldValidator.getPopulatedEmptyStringErrorMessage(...);
you added synchronized to the method here, wanted?
Use isZKLogAvailable() instead
use Long.valueOf() instead of new Long() - always for performance reasons
Where does the 5 come from? I feel like we should just throw an exception here.
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
Doesn't List as a Collection have a defined method to check whether it's empty or not?
I'm not sure we need this. II would prefer to let the logic of collecting exceptions hidden in the visitor. Why not directly handling this case in the MethodInvocationVisitor then? You can perfectly give the symbol of the current methodTree as parameter of the MethodInvocationVisitor constructor, so you don't lose the info from where you are calling. At the end of the visit, you could then simply add thrown exception from the default super constructor, if super has not been called and it's really a constructor.
I know the other methods are using asserts, however we are trying to move over affected code to org.testng.AssertJUnit.\* methods instead if you could. Thanks.
Hm, should we thrown it as InternalProcessingException ?
Nit: if the call doesn't throw an exception, then this should print a "success" message.
Please consider to add a log here (maybe warning) someting like : "connection " + connectionId + " has been removed from DB, no hosts were disconnected" Could be worth some scrubbing time
can we add a message to the result if it is stale request something like result.stale()
Pankti, do we have any test?
Please make the constructor private (see Invalid).
We already have a i18n runtime base class, could be used here instead
Use StringBuilder instead. Also, you can use ToStringHelper in guava.
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
What's the point of adding a copy here?
Minor: you can collapse the if blocks, same in CacheRemoveBackupOperation
I hope we can move the verifyManifestPermission to the end of the check. If the signature of the broker even doesn't match, then does it make sense to throw an error and tell the calling app that some permissions are missing?
This method and similar could use CacheKeyBuilder instead
Why?
Use Guava Streams.stream(myStream) instead of StreamSupport.stream(myStream.spliterator(), false)
why not entity?
emptyTextView can be made View.GONE?
> DRONE_TARGET_DIRECTORY it means that the last update cache is stored in the target directory, right? I'm not sure if it is a good approach as every new run of the test suite will require a new request - I had expected it in the ~/.arquillian/drone directory. On the other hand, I have to agree that the probability that you would run out of the limited number of request is very low.... Why you've decided to put it into the target directory?
Why this change here?
There is indeed a behavioral change, the previous code was trying to lookup the files using the resource loader even if the string representation had no scheme, this one does not. The following change fixes the specific build failure. suggestion return uri.getScheme() == null || "file".equalsIgnoreCase(uri.getScheme());  I've verified this change makes for a successful build (with all extensions included, -Prelease):  [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 06:12 min (Wall Clock) [INFO] Finished at: 2020-05-06T15:36:28+02:00 [INFO] ------------------------------------------------------------------------
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully backoff when an application wants to manually configure a value. What that means here is that if the application has configured any algorithms, then the auto-fetch doesn't get run.
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
Delegate to isNonCodedDrug() when making the check.
NIT suggestion throw new IOException("Failed to await LockPool evictor termination", e);
Maybe I am confused, but this is changing from number of children to number of siblings? ast.getParent().getNumberOfChildren() != 1 to ast.hasNextSibling() || ast.getParent().getFirstChild() != ast I am not grasping the equality of this.
[Checkstyle] INFO: '200' is a magic number.
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
Can be replaced with streams java List<CharSequence> titles = titleList.stream() .filter(titleProp -> fieldApprover.approve(titleProp.getDataInfo())) .map(StructuredProperty::getValue) .collect(Collectors.toList());
Use ExtensionsRegistry instead
(Alt) Can we move the skip condition to the testSetup method just above.
pvk should not be visible. Please remove it.
We won't detect if newProperties contains a property that is not in oldProperties. Shouldn't we? Why don't we just do oldProperties.equals(newProperties)?
These "Beginning" and "Finished" log statements will be redundant in a test report. That is, most test reports will list the test classes, and whether they passed or not. (And if the test assertion failed, there is usually a stack trace that will also pretty clearly indicate where the problem lies.)
Should we have the monitor test here as well?
Please update the exception message to say KieModule too?
no need to call super explicitly. Any construction implicitly always starts with a super() call (unless it's a this() call to another construction).
it has to be otherway round
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
no need to call super explicitly. Any construction implicitly always starts with a super() call (unless it's a this() call to another construction).
note that we should always take the cluster's compatibility version in that case, even if the vm is set with custom one and the cluster's compatibility version is cached in VmManager so we can take it from there instead of using this costly query
Why is this removed?
Do you care that this doesn't account for: <LINK_0> Is "Other Info" included in the docs?
In separate line ?
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
this cast seems dangerous: why is an optional stored in there?
Never rely on the ToString() method of a type. What if it change in implementation class for debugging purpose? Use thrown.name() instead.
If this is local host, why do we need it as a vaialble?
You are missing the logic.isValid() check.
this.awsRegions.toString() will do it for you, but please check awsRegions for null first
Using Collections.singletonList() is slightly more efficient as long as the result doesn't need to be modified, which is true here and and for getDescription()
You should use a consistent method naming paradigm within your class. I think this is the only setter that says "set" on the start. Either have all of them say set, or none of them. This might also be a good opportunity to change "rya prefix" to "rya instance name" since the prefix is Accumulo specific.
I have seen pcapNg files with a different extension. They don't work because the code expects pcap magic number...
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
could you also verify the results of these operations?
isn't this the same bug that you had before, that headset wasn't working while app was minimized ?
Avoid deeply nested control flow statements.
catching Exception looks an antipattern. It would catch OutOfMemoryException and any other RuntimeException and the job might continue but in such a bad state that it would probably be a waste of resources
updateAvialability() calls -> updateAvailability(SystemTreeItemType.System, null); Since the reports init is no longer blocking the ui there is no guarantee the system tree selected item is the 'System'. Calling updateAvialability() will update all the tabs (not just the reports) as if the system is selected. In my opinion, you should extract a method in CommonModel to update just the reports availability and call in from here.
Could be inlined here by using test()
why not using the reset methods?
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Can this be private, or is there another use case for default attribute outside the builder's call?
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
This method can be static, as all the methods it calls.
Don't make this public, instead. use. TableDefinition.id().
@marchof I'd prefer to name local variable invisibleAnnotations or even better runtimeInvisibleAnnotations instead of just list
return StringUtils.isNotBlank(value) && value.equals("true");
Why protected if the class is final?
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
Just replace all this new code with MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()).
I think that we should add some randomized part to thread name because we can end up with stale consumer that we cannot differentiate from newly created process. Or perhaps we should rename stale process with some suffix.
can you please reformat this test file to have something a bit more compact and coherent in term of style? You can also remove empty lines.
assertNull
Don't leave System.out calls in the code after you're done. Other use LOG.debug' or delete them.
Why do we have to reset it here? Is it because the standard, GZIP compression is not supported? How hard is it to simply support it?
uncessary call to super. No need to visit further.
Just "Kafka".
i don't think redeclaring the type on the right side is needed.
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
Use P.lazy.
Nice, included the row.
i would use a LinkedList here instead. i can't find anything saying ArrayLists sort faster and then you do not need to specify an initial size.
I think "$exists operator requires operand to be either true or false" a better error message.
Hi @ashrko619 What about For(List.range(startYear, endYear + 1), List.range(1, 13))? :)
Why is COLUMN_SORT_TYPE text? Shouldn't it be integer?
Should we use a checked exception here?
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
be backwards compatible
If you just retain the below line, the API contract for createInstance can be regular:  UserDTO user = userEntity == null ? null : UserDTO.createInstance(userEntity);
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
API breakage errors. You should declare another method and mark for deprecation this one.
I feel the isNotEmpty() check is not needed here. The for loop will take care of this case.
Generally, we haven't used java asserts anywhere before. So I would be a bit hesitant about doing it here? What is the reason for adding them?
Would it be appropriate to add some logger.warn() statements to these two IFs, to make more explicit what's happening, both here in the code and at runtime?
I think including taskStart.getId() would make the log message more informative.
Avoid the intermediate variable and directly assign selfID.
This adds 5 seconds per class, at 311 ITs that's 25 more minutes of runtime. Maybe we should disable this by default and only enable it if VacuumIT is failing to debug?
let's not do anything smart here - the provider should be able to decide how to map "default"
import or create (considering we may not use the imported configuration)? there was a good patch by Liron [1] where he called that handleVmLease. not that important though [1] <LINK_0>
Lazy load this to a field.
On macOS users may never hit DEFAULT_DNS_SERVER_ADDRESS_STREAM_PROVIDER. Therefore, we may defer initialization until necessary, if we move this constant to another class.
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
The philosophy of simple-mode is to work soundly on most code, with very minimal restrictions (using around reflection). We shouldn't be using type-based optimizations in simple mode.
Debugging? Remove.
isn't this condition always true?
return a boolean esp. given the semantics of the update operation if there is an existing node of the same name that is not the provided node instance
Doesn't Datanucleus advise against using id in hash?
Why not just simply "command.setVM(vm)"?
Make this AtomicBoolean
nit: you can merge both lines above as checkNotNull will return the given argument
same question
putIfAbsent or use synchronized block
Those two should be equals (and even ==) rather than going through FQN
Why need to catch to simply rethrow?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
You can also use single quote '[' to avoid putting //$NON-NLS-1$ at the end
The method actually determines if the given processorNode is a duplicate of any of the existing nodes. The action we take on duplicate is stopping the processors. Can you please update the doc?
Where do these numbers come from?
@overquota Should not #close do #closeConnection and #shutdown do #shutdownConnection?
Shouldn't this be refactored to something like this? entries.append( "- " + entry.getName() + " - " + entry.getMissingPluginId() + "\n"); if ( missingEntries.indexOf( entry ) == missingEntries.size() - 1 ) { entries.append("\n"); }
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
same opinion here :) (though break logic here seems correct)
this method should be changed to private
revert this string
Don't shade names like this on purpose... Also instance variables on Block is not a good idea..... Threads kill it...
can't you use constants.empty() here as well?
A design where this is side effect free would be most desirable.
by moving from commit to apply, there is now a file write on the calling thread, but the call is guaranteed to be persisted when the call completes. Does that change your API expectations?
Did you run your test? Does it work with Github account? I don't think it does, since you're creating one gist and deleting another one.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Can throw exception when created with no args constructor
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
For Right to Left test, you also need to test left models (those who have been modified).Please verify all other tests that present the same problem.
Isn't there some standard way to dump a stack trace?
Can you add the curly brackets to the if calls.
beginBlock should close the paragraph that was created in assertOpenBlock(), if there is one currently open. Note that it should not close *all* paragraph blocks, only the one that was implicitly created.
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
This makes this nullable. If you think this will never return null, then you may want to throw an exception NullPointerException. But if it can be null (like the trace is not set yet or something?) Then make this method @Nullable and do a null-check when you call it.
Oh yuck. ;)
This is the only place that add entry to the pool, is it the only way to fill the pool?
Should we do an Assert.assertTrue on the return value of verify()?
Can't be just assetListConsumer.accept(Collections.emptyList())?
Can be simplified to AutomaticProvisioningStatus.ENABLED.equals(getAutomaticProvisioning());
These 2 methods have some overlapping logic with methods getFeedSLAMissPendingAlerts and getSLAStatus of FeedSLAMonitoringService. Please reuse those methods, so that the API and this service are in sync.
How would you feel about making this passed as a json property in HashedPartitionsSpec and add it to the docs, so that people can use it ?
you can actually just set the private List<String> enabledTemplates = new ArrayList(); above and not have to worry about this. When dropwizard/jackson reads the config it will override based on the yaml if needed (since you also provided a setter)
can this throw an specific exception.
the return type should be M
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
SyncNetworkParametersBuilder contains those logic in labelAdded() & labelChanged() perhaps it could be reused ?
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
Take the limit (50) as a parameter, this will be useful for later
These two lines probably can be combined into one.
I'd rename this variable to memberValue.
This displays the internal account identifier (unified_inbox and all_messages) instead of the display name.
Since we get access to the Site here, it seems wasteful to throw it away, and then have to re-expose it through FeedCoordinatorBase. In all the other cards so far, the Site gets passed all the way through to the server request from here. Perhaps the same can be done for Random?
Check if credential and registryUrl are null before creating the Deserializer.
Use Objects.equals() to handle nulls concisely.
Are these cases all needed? Or what all of this just copied from categories?
return Collections.emptyList();
Have you considered Activity.RESULT_OK instead?
Retry forever is a bit risky. Limit to a fixed number of tries. Also, use a delay between tries?
do we need to unvoid..?
should be "*notconfigured-it.war" Double check the folder because not sure how this passed.
Could throw IllegalArgumentException instead.
Not sure whether failing on plugin level is OK. If it would be in test plugin and not an abstraction for manipulation with docker I would consider it ok. But on plugin level I would not do it. @rhopp thougts?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
You need to check for null after the first get as the query may have finished before you call this to kill it.
Can this be private, or is there another use case for default attribute outside the builder's call?
Don't also print stack trace, log.error will already print it. Also other instances below.
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
public isn't needed
float?
!getCustomTopicNames().isEmpty()
Ah no, I didn't think. It's of course possible because we're removing the same instance and equals therefore works...
Need to pass xmlEnvironment as second argument to XmlStringBuilder.
As this if became quite complex, I did small exercise and tried to refactor <LINK_0>, please let me know what do you think about changes I propose.
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
should the interface not the implementation suggestion public List<String> getTopics() {
@vilchik-elena Minor performance improvement: we currently always evaluate all 3 boolean expressions, but we could avoid that.
You should be able to use the diamond operator here, i.e. new ArrayList<>()
suggestion EMPTY_VALUE);
should it be an error condition or log something if both the invoice number and the customer payment number are both blank?
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
return dto
what's the intent of this change?
You can push this directly to the frame so you don't have to pop it manually.
does this need to catch all exceptions?
No need for getInstance(), the container can be passed
why is this noncompliant?
add this selector to UI mapping at the beginning
You might want to remove this one :-)
Use readAsString(...) instead
This converter does not have any effect
calling this command will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVds command
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
Would it make sense to add this method to ResourceManager interface ?
IMHO better "HashSet". I don't see that you use the iteration features of "LinkedHashSet".
This should default to true to preserve the previous behaviour.
Oh, I see Well, I'm not against mentioning subscribe() as long as we don't just say to "set this error handler to avoid this exception" We can also mention onErrorXXX, might be a bit overwhelming tho
I don't think you need this new String
No need for such harsh line wrapping, the style guide states it is up to 150 characters.
This variable is useless. Please just use return in your if/  branches.
This case is not covered.
the workspaceitem needs to be deleted
nit: Just write entry -> ...
You could also use path.endsWith("/")
public?
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
Could you include the invocation-future toString in the exception message?
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
This should have a static logger method with a code
Symmetry (throw)?
You can import OPTIONAL, BINARY, UTF8.
lets include e.getMessage() to be consistent with other plugins.
i'm surprised this passes checkstyle
Racy. Maybe just chuck a synchronized on.
-1. This means input does not get read.
return if already destroyed
Why is it still public final?
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Missing @Override
I was initially confused on why this wasn't being handled inside the onGoogleSignupError callback but after looking at UnifiedLoginTracker.trackFailure() I'm assuming it's to preserve the current flow and step. If that's the case, I think we need a way to communicate this behavior more clearly. UnifiedLoginTracker is currently not a part of the login library, so other library clients will only be able to look at LoginAnalyticsListener.trackFailure() to get more context on how this is supposed to work, which doesn't make it obvious. Let me know what you think.
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
space
I don't think this check is relevant
This is just a doubt. I think that most of the time the input list is fine. Do we really need to instantiate another object here?
Not necessary to call super(). There is an implicit call to super() with no arguments for all classes that have a parent
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
That's good to know.
final?
Shouldn't that be just root.retrieve() as we are setting the method on the create() method?
would this work? (also removing the import) suggestion .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice);
In practice this will never happen :) I'd suggest to remove this check, or throw a runtime exception instead of logging the error.
you need call addColorSettingsListener on the new instance.
No need to include this in these calls but it is a minor detail.
Note: This is not always true. We use 'utf8mb4_bin' for mysql and 'Latin1_General_100_BIN2' for SqlServer, because we need case sensitiveness on various places. The unit tests of ebean will run here at foconis also against a database with these settings. This means, the tests will fail here. What do you suggest? - can you change your mysql/sqlserver test setup to use a case sensitive collation? - can we introduce a flag (Systemproperty), so that I can run the tests against a case sensitve version of mysql/sqlserver? There are some special things to pay attention, if you change the collation/charset: - the maximum index length on mysql is 767 bytes, this means ~191 chars on 4-byte UTF-8 charsets - setting the collation on sqlserver to case sensitive, means also that the columns are case sensitive, I had to modify some tests for this. (I can diff the code and create a PR for this, if you want)
Please remove the unused method.
This does not actually verify it's only registered once - I suggest you use .containsExactly(monitor.callback)
Is it possible for two objects to test equal but have different hashcodes?
A percentage is between 0 and 100
Per our discussion, we need to delete any removed custom data properties before saving the account and its custom data changes.
We do not unpack it for all the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to byte is needed here.
bracket should be on the previous line
In the exception message, including the issue id is strange. Please put some brief descriptions in the message.
Argument name
Shouldn't it be "<LINK_1>"? I did not test it in the app, though.
Collectors.toList()?
Pass the whole geppettoManagerConfiguration
You can use ZoneOffset.UTC instead of ZoneId.of("UTC")
Please check the result here and break if false , since all values are with AND , there is no point to continue if we got false
?????
reportservice
This was renamed to PARTITIONED
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
unnecessary change
Why not: java if (val instanceof Double && Math.abs((Double) val) <= 1.0e-131) { return ZERO; } return val;
Maybe use the getStorageId method here?
please put each parameter in separate line :)
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
Consider the CollectionUtils.isEmpty(this.applicationDefinitions) instead
Please don't use null here. Just pass "" and make stateKey always concatenate.
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (long) tileCount.
I believe we should use ThreadPoolExecutor#shutdownNow() to stop all actively executing tasks and the waiting tasks as well.
Why delete this line?
I don't think we need this assumeTrue. Docker API has had build params since 1.18 <LINK_0>
I'd suggest calling this init method from the context file instead
using command line user can provide a wrong id (say, by mistake), so its better to check for getVdsGroup() == null here as well
public?
What if this path actually exists on the user's workstation?
I guess I'm out voted on using this. :-(
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
not relevant for localization.
Please use MantaClient.SEPERATOR and do not hardcode slashes.
I can't see any reason to throw CoreException here.
I would drop that since it is false by default
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
rename to allUnresolved and then just use unresolved in the foreach loop variable
I think we should keep this synchronized.
Is there any reason to remove 'private' access modifier?
Have you intentionally omitted index check?
This should also have a check for max of 25 like the constructor above, i.e. Math.min(...).
missing curly brackets.
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
Can't we create many arrays with this change if there are high partition counts? Maybe we should calculate the size upfront.
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
Update labels to go with method names. Alternately, call super.toString for super attributes
Use fire(event); for all EventHandler based events
lambda
The number should be canonicalized before retrieving the contact, using Utils.canonicalizeNumber(number, username)
ObjectMapper is fully thread safe, we can have it as a single static variable inside this transformer class (also because we do not configure it differently per method usage)
Shouldn't we avoid to have U+0000 or any other chars not valid for table name in the name? I think we should update TestHelper.getRandomString(int) to exclude U+0000 at least.
Might consider using a [SimpleConfig](<LINK_0> here. Won't make a huge difference with the class as-is, but will make it easier to make changes in the future if we ever want to expand on the configurability of this predicate.
Static import
can be omitted
redundant. 'super()' is called anyway if you don't call other ctor explicitly.
to remove, just use new ArrayList<>() in the constructor, two lines below
new Double is redundant here
Remove useless assert
The switch in the createPermissions function is now obsolete, it is never called with anything else than AUTHORITY_ENTITY_PREFIX
use same type for instanceof and force casting
Won't it better to through the exception in case of an error?
you can actually just set the private List<String> enabledTemplates = new ArrayList(); above and not have to worry about this. When dropwizard/jackson reads the config it will override based on the yaml if needed (since you also provided a setter)
Again, this is too much specific logic that this component does not need to know about. It should only depend on Prefs.showEditMenuOptionIndicator().
wondering which flow is better. Using the following might get rid of the reconnectToGemfire method in Cluster. suggestion String userName = authorizedClient.getPrincipalName(); if (isExpired(authorizedClient.getAccessToken())) { logoutUser(userName); authorizedClient = refreshExpiredClient(authentication, authorizedClient); } userName = authorizedClient.getPrincipalName(); String credentials = authorizedClient.getAccessToken().getTokenValue(); return getClusterWithCredentials(userName, credentials);
same here. we don't need to set explicitly for blob not found cases.
Shouldn't GetterTypedIdentifierAggregate be used for this test instead of TypedIdentifierAggregate?
Why would this make sense? Just because of the order?
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
Try using StringUtils.isTruthy(this.path)? <LINK_0>
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
in case closing one grouper throws ex, we would still want to close the remaining ?
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
What we are waiting here on?
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
qry -> query
Do update all the places where you can now just use typicalBundle, instead of getting it again.
consider moving those functions to TwitterWidgetPageObject and name the method:  createPageWithWidget
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
Maybe the simpler:  return Objects.hash(podSpec, podMeta);  or maybe not, because that involves an instantiation of an array under the hood. On the other hand, it leaves less room for error. :smile:
I think we should return a dto here and do the marshalling of the response in the IL as we do with other responses.
Is it really necessary to set prototype scope for EVERY Provider ? I do believe it can kill some logic if some bean of Provider.class should have singleton scope (in custom code for example).
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
When you will use I18n.marktr with ON_VERTEX you will have to use:  java JRadioButton bVertex = new JRadioButton(I18N.tr(ON_VERTEX));
You've declared it to be an string in the schema so why the need to convert it back to an int?
This is another one that might cause problems. @lbergelson you've done a lot of refactoring to pull interval/region-like methods out into a single class; do you see changing Interval.equals() to not accept subclasses?
This method has an external annotation now.
FYI, proper English grammar is "must not be null" or "must be non null" (I'm not sure if grammar requires a hyphen in "non-null").
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
nit: I would extract webDriverContainer.getContainerInfo().getMounts() variable :)
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
log should say store is not initialized.
Shouldn't you add a inQueue = 0; here?
Hello~ The classes in jars in extensions directory are loaded by URLClassloader, but the KafkaProducer here use the appClassLoader to load classes in org.apache.kafka.common.config.ConfigDef parseType() and this lead to org.apache.kafka.common.config.ConfigException. That is the problem I got. I found some code in KafkaIndexTask, in method newConsumer() such as:  ClassLoader currCtxCl = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); // ignore some code ... }finally { Thread.currentThread().setContextClassLoader(currCtxCl); }  This can solve the my problem. May I ask have you encounter this problem?
Why is it a list of lists, not just a list?
Better revert.
Can we combine 'pathPrefix' and 'stripPathPrefix' and only strip when 'pathPrefix' isn't null?
Why is it a list of lists, not just a list?
i remember that month number should be 11
The names should be consistent. As suggested, cancelAddInstructorLink is preferred over addIntrCancelLink.
It would be really nice if event updater will get some kind of criteria that will determine how often you do this instead. That will provide an ability to test it in an easy way and to make refresh interval configurable
It may be worth expanding this to include say: + "who also have 'Push' rights on " + GitRepositoryManager.REF_CONFIG
This will get logged twice and pollutes the log. Can we add this info to the Exception which will get logged.
enclose if and else within { } even if it's a single line
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
> Alternatively, as we're concerned about usage of the image in a Wiki article, I think it makes sense to copy the wikicode for the "thumbnail" image rather than the wikicode for the full image. I agree with the thumbnail approach, pictures are almost always displayed as thumbnails in wiki articles AFAIK.
This is not necessary.
More efficient: getDB().getRecPtr(record + DEFAULTVAL) != 0
Same here, return ImmutableSet.of(this.modelResultStream, this.rootResultStream);
As noted above, just put the init code in init() unless there is a reason not to.
Can be made package local
Formatting - elses should be on the same line.
assertFalse(...);
Are we sure that bricksForTask will never be empty? otherwise builder.length -2 would cause error
you forgot to inline into one liner method as moti suggested on patch #1 .. :-) other than that - looks good to me.
"data" is already a plural noun.
Wondering if we shouldn't fire event in the way we do in CanvasLayoutUtils.fireElementSelectedEvent
@dalifreire let's get rid once time used variable
is the Env.isMacOs() needed? as you pointed out to me. it would anyhow as raised it will just throw a NCDFE. Either that or we add Env.isLinux to epoll also. I agree i totally was wrong earlier. so i don't think the Env.IsMacOs is needed like you originally said.
Same here with length() == 0 -> isEmpty(). I'll stop mentioning for the rest of these :)
That is small duplication. If you add extra parameter key then you can replace two methods with one
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
you need to first trim input otherwise this doesn't match if input starts with whitespace
Why propagate and not simply Thread.currentThread().interrupt()
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
Although AsyncClient is deprecated retrieving event loop has some additional checks. Could you please check AsyncClient.findEventLoop?
Would be cleaner to call cancelAll() here. My expectation is that we would clear state and start afresh during a new session
uncessary call to super. No need to visit further.
Why does it need any change?
This has to diverged internally. Mady, can you incorporate this?
I marked this in #951 already.
Have you considered skipping the line above by having something like Queue<ControllerAction> result = new ArrayDeque(queuedActions);
ohh.. actually we should default to 443 if https!
So does this mean that pumpkins are easily duplicated?
How about applying this method inside convertColor to avoid duplication and to make sure the same input sanitation is applied? Looks like in all cases color.trim() is desired before calling convertColor anyway.
(nit) suggestion .computeIfAbsent(partitionId, k -> new PartitionUpsertMetadataManager(_tableName, k, _serverMetrics));
The value here is null right? If so why we try to print the value? I think it should say Empty userID. Also, can we use StringUtils?
typo: perfrom -> perform
This method as discussed is used in a synchronous() fashion. Not sure if you intend to do this in a separate thread
I'm not understanding the logic here. If isHTTPSForwardedProtoResolver returns true, why would we want SecureForwardedProtoAwareResolver to return false?
getAccountRequestCount.addAndGet(1)
let's call it updateCodeMinings() instead.
I don't think this should be public; or even be a method.
This method causes several build warning.
It is possible for this to return null if no matching Activity is found, e.g. if one has no browsers install or no browsers set as default (not sure if this will happen). In such case we should do a null check and return null. Also can you put a space after ,? Thanks!
@antonini please name it user
The writes in this method should be done under a lock, right? But I'm not sure that all execution paths do acquire this lock. Should we add synchronized (buffers) or checkState(Thread.holdsLock)?
I'd use << 3 to match MemoryAddressHash
this("Safety Command")
We should throw an exception here too, saying the cluster is invalid.
wrap with Collections.unmodifiableMap() ?
Why it's "EXTERNALVIEW"?
Do these methods actually get used? If not, then maybe throw UnsupportedOperationException instead. Then, if someone tries to use them, there will quickly be an exception thrown.
Move this check into getPropertyValue(String key, String name, int index), gut this method and have it just call the other one.
why not put this all in one if condition? if (input instanceof EditPart && ((EditPart) input).getModel() instanceof ConfigurableObject)
is there a version with more parameter than 3? If not i would use == 3 rather than >=.
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
In tests we can just declare that these methods and the test methods "throw IOException" rather than catching and wrapping them, and just get rid of the catch clause.
Have you intentionally omitted index check?
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Not atomic. Two threads can reach line 100.
do not expose the list directly
Please merge those two nested if statements. It can be just one.
latest from today's discussion: return URL
you can't get here with vm == null, so it should be removed from here.
this is obsolete
Do we want to use the LOGGER as well? There are other usages in this class where we're using both.
Move to a separate commit
assertThat(c.getParentCount()).is(2);
I'm not sure about coding OS-specific-ness. Is this the sufficient condition for all OS? 1. Does SWTBot has any users on SunOS/Solaris? Will the statemask be correct if someone uses GTK on Solaris ? It will be risky unless we test it. 2. See Util.isLinux() implementation in org.eclipse.jface.util package. It considers 'motif' also as Linux, along with 'gtk'. It seems SWT supports motif. It may be out-dated. Do we need to consider motif? Since 2-3 years we have been discovering some differences in SWT behaviors on win, linux, mac during our SWTBot reviews. There will be limitations to support each such difference. But then there will be inconsistency if we support such difference at some places. What is the best approach for swtbot?
You should have moved it here.
no need for an ArrayList
0 is a legitimate option value for min. selectable choices. Why not -1?
We have to close the Cluster instance here as well, otherwise the process keeps running forever after completing. Also this should be in a finally block to make sure we close it even in case of an error
I would prefer constant there.
The DateTime.now().plusDays(4).toLocalDate() seems like a "magic number" that isn't really clear where it comes from. It would be better to set a value to the expiration date inside the testBoletoExpirationDate method to explicit it or compare it to some constant
negative logic
@amihaiemil should be length()
This exposes the unicode workaround to the public.
assertThat(map).doesNotContainKey(new Object());
Shouldn't we instead go to the TabLayout activity here iff we have a selected instance (i.e. you didn't get here from the InstanceSwitcherActivity)?
HttpServletResponse.SC_NOT_FOUND
Is this correct? Based on the definition of the special day entries in the DLMS Blue Book I would expect a long-unsigned value (newUInteger16Data).
I remember this method in one of Anmol's patch as well. Can we move this to some common location, as it would be useful for others as well?
doesn't seem right, should be something like "{\"foo\":0,\"additionalPropertyExampleKey\":\"string\"}"
I like the approach; but I'd like the TLS 1.2 and allowed CipherSuites to be only limited to API 24 (higher API levels might want to use TLS 1.3 for example)
How about making these constants as static variables?
I'd add an always-printed log message here too to make sure it's remembered.
Do we need this?
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
Fix method name with prefix..
ParkingPositionLayer - delete
return a copy of the data to keep DataExtension immutable.
let's call it updateCodeMinings() instead.
The incore merger works in memory without a working tree. Does he need attribute handling?
Do we want a space here before the brackets?
You'd probably dispose your stuff, and call super.dispose() at the end.
>=
Can be simplified to java return itemMaterial == null ? 0 : itemMaterial.getMaxDamage();
There is a lot going on this one line.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
You can also use single quote '[' to avoid putting //$NON-NLS-1$ at the end
Coding best practices: Interface i = new Implementation();
@exper0 no need for the extra indentation here
empty function? also no qualifier (public,private)?
reopen -> open
A miss?
Something minor: You could use ConfigValues.class.getSimpleName() instead of hard-coded class name.
Consider using streams,: return node.getActions().stream() .filter(action -> action.toLowerCase().equals(path)) .findFirst() .orElse(null);
If this logic is need, please find a way to reduce the code duplication. see azkaban.test.Utils#initServiceProvider
This println can probably be removed.
Oops, (start + end) / 2
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Won't fix.
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
No need for super()
Are we not closing file handles now? :)
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
Same here? It is always number or null?
Use InvalidArgumentException instead
It looks like the second check (_params.size() > 0_) can be removed. If the params is not null, params.get() will not fail. After that, we have two cases. If params contain "fullDetails", we will have only two checks instead of three (params.size() is removed). If params does not contain "fullDetails", we will have also only two checks (as in the current implementation, with .size() in place), only that we replaced .size() with .get().
I think most of the other new 'getter' methods can be removed in favor of package-private visibility on the field. Keeping the field access simple, rather than creating all these new methods, will help future code changes by minimizing the call stack one has to follow to understand what is going on. However, I think this one should stay, because it provides access to a non-final field, whereas most of the others are final already. It should be package-private, though, instead of protected, because they don't need access by subclasses.
public?
can't the response be null? if null as return value is legit for non existing snapshot, move the initialize of the VM into the condition.
static.
It would be great to cover the util method with tests.
Should use a constant instead of a raw String
enabled first
events.isEmpty()
I would prefer to use full words. For example directoryAllow.
nitpick. Suggest to use a init factor " new ArrayList<>(batchSize)"
maybe use single quotes to avoid having to escape the enclosed double quotes (applies to the rest too)
As noted above, just put the init code in init() unless there is a reason not to.
this should be like other errors.. create EngineError key and a corresponding message in vdsmerrors.{java/properties} files then throw a EngineException with this key
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
we never use NULL, it is a bad practice in general.
Isn't this very inefficient? It seems that this loop might easily be executed 100 million times in a typical run. Can't we just increase the size in one step?
Maybe it would be good to be consistent with MigrationResource and return the deleted entity in a response here as well.
This seems unnecessary, if you going to return the same thing at the end of the method anyway.
Why we want to fall through into the loading dialog in case of error?
I think this is a typo -> this.high < this.high -> should be -> this.high < other.high ??
@pynicolas Unlike the other getters, this getter does not return a copy (ImmutableSet.copyOf).
here we need to go through Optional.ofNullable(Plaform.getProduct())
suggestName?
How about while (!stateMachine.getCurrentState().equals(STATE_CLOSED))?
I think the CosemDateTimeDto is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
This would add IGNORE_RETURN_VALUES to the provided explicitFlags set if it was not empty, which we can't do. Maybe instead we just create an EnumSet that starts with IGNORE_RETURN_VALUES and add explicitFlags to it and use the resulting EnumSet.
It is here that runtime.matchesFilters(pickle) should be used to select the pickles to run.
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
suggestion if (values.size() > 1) { return IconTheme.JabRefIcons.MULTIPLE_LINKS.getGraphicNode(); } else if (values.size() == 1) { return IconTheme.JabRefIcons.LINK.getGraphicNode(); } else { return null; }  We talked in JabCon2020 a bit about this and we think that it would be better to directly load the icons here instead of introducing a new field URLS in StandardFields in the model package for a ui feature.
Should be final.
Also, this whole method could be shortened to a single line: return (INTERVALS != null) ? filter.getFilteredRecords() : filter.getFilteredBases(); Oh, and another thing: protocol in this codebase is to put spaces after the 'if' and before the braces. Otherwise, you risk incurring the wrath of @nh13.
I missed this one before, but if (!eventString.isEmpty())
Is it one because getAttributes(tu) returns the attribute specifiers, not the attributes themselves?
Use an immutable list builder here? Or does result _need_ to be mutable?
I feel that we normally don't do this in Presto but explicitly create a new object with old parameters.
Why didn't you cache the value?
(ListView)  can be removed
Use the activePlayer object instead of retrieving it again
Do you think it would be useful to log (warn) if this evaluates to false?
In my opinion, we do not need this log. WDYT?
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
can we remove: declare-response, useless-assign and just return the object from the method-call?
Minor readability suggestion suggestion model.addPropertyChangeListener("scriptStatus", ignored->{
Can this method remain private?
Do not make input file names cryptic. Please rename the file to clearly state its purpose.
should do some validation too. For example, if the input schema is non-null, make sure the fieldToClassify exists and is of type String, and the predictionField exists and is of type double
Notice how the constructor is unable to advertise what is going on. We should avoid doing work in constructors.
constant?
I know this isn't supposed to be invoked and I am nitpicking, but should that ever accidentally happen, I'd prefer to either see dummy string returned or an exception with explanation.
RemoveSnapshot may fail on the validate() methoid - so perhaps we should iterate over the disks and free only those who are in LOCKED status.
Please use a bigger max value. We were limited to small integers for VCS for historical reasons, but there's no such limit here.
Should this be onReplicationPutRecord?
I wouldn't change the default.
You can also return true here and return false at the end of method
trace
What does this change do?
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Not needed.
Dianne will tell you to remove this. This is logspam.
I think this method should check only case 'b' and have proper method to explain the problem. All the other case are covered by 'nicActuallyExistsOrReferencesNewBond(..)'.
it would be nice to assert here that the actionBar is displayed. (so if it is not visible, and onActionBar() is called, it already breaks here with the error that the bar isnt there instead of later that eg. the title doesnt match)
I'm not a fan of adding a getSlice method to block. Is there any other way to do this?
Throws AIOOB exception when called with index = line count.
Was this detected by findbugs?
Should these have some kind of validation, e.g., non-negative, from less than to?
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
same thing  java return container != null ? container.accept(this, expressionDefinitionId) : null;
this is confusing, it is called router but actually it is routerUrl.
Here dirName should never be null, and delegate should always be null.
racey single check
Do we want to include the original throwable so it can be shown in stacktrace as "caused by"?
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
static
Integer.toString(length) or String.valueOf(length) seems a little more clear to me.
Is shutdownNow more appropriate (which would interrupt running tasks)?
Is this still needed after removing the download stuff?
better collect all XML-Snippets as constants with substitution marks and use String.format() in order to replace these marks. This will increase code readability (also change for all subsequent XML Snippets)
Do we want to keep the method names like this or give it a more general name?
Redundant brackets suggestion return tryActivateAndGet(e, stack.getItem()) != null;
I'd probably format this to have a : before the actual digest value, just to delineate between the hash type & the value.
You could also use -> Objects.toStringHelper() from guava
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
lowercase for package names.
recordCount++; doesn't work?
java authCardDetails.getAddress() .flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry) .map(NorthAmericaRegion::getAbbreviation) .ifPresent(smartpayTemplateData::setStateOrProvince);
why did you remove this ?
logger says "Unsubscribing"
The position parameter is in NatTable coordinates and could be out of range in the scrollableLayer. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportPosition.column);
Implement this
This should be private unless there are plans to use it outside the class.
Make the fileInfo map immutable.
This is the trouble with cond commands we've talked about...
nitpick ... this should be renamed to simply gammaId, it's not necessarily new.
Include message saying what was wrong if check fails? e.g. including the original ref argument passed in.
assertFalse(...);
It feels like there's a lot of context and state that's being managed here that would be much cleaner to delegate to a composed cacheState object (which would also make it easier to change this later more safely without requiring safely updating 5-6 implementaitons
unnecessary array new: {{true}, {false}} should work here
Totally optional: we could tighten up the code a bit by getting the boolean value for !DeviceUtil.isOnline() and then passing it in as a new param to conditionallyAddPendingClient: void conditionallyAddPendingClient(FeedClient c, boolean cond) { if (cond) pendingClients.add(c); }
@lvydra Please remove 'parameterName.equals(NAME) 'from this. My apologies; I should not have listed 'name' as an invalid key in the JIRA description. I've corrected the JIRA description.
java this.onPostServerTick(this.getMinecraftServerInstance());
nit, Collections.EMPTY_MAP?
It's better to use shift operators here. Instead of java value += (int) Math.pow(2.0, (double) i);  it's better to have java value += 1 << i;  The left-shift operator is equivalent to 2 to the n-th power (2 ^ i == 1 << i), and has the advantage of not requiring conversions to floating-point and back, and also avoids any expensive operations that happen inside Math.pow. The left-shift operator is a single assembly instruction :)
I've seen this a couple of times now, can we use Google Guava's ToStringHelper instead? Probably best addressed in a separate issue/pr.
move this line before above line, After super.cleanup method couldn't do any of the server requests.
Please consider map.computeIfAbsent
Modifying generated code is risky. We should extend the EditParts (with a CustomDurationConstraintLinkEditPart), and instantiate these custom parts in org.eclipse.papyrus.uml.diagram.sequence.providers.CustomEditPartProvider Also, DurationObservationLinkEditPart should be modified in the same way
this could easily be done when creating the repository as well.
Can you move the System.getProperty calls to methods on RoboSettings? We're trying to make that a central place to hold all system properties.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
port is a primitive, so this null check is redundant
You can condense this to DISPLAY.asyncExec(() -> progressBar.setVisible(visible));
Lists.newArrayList(entity.operatorIDs))  What does operatorIDs represents?
> HTTP_API_VERSION [](start = 51, length = 16) also what does the http_api_version mean? :) #Pending
why is this not private?
Should we include the label too?
In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean.
Please check if this method really should be public in a private static final class. The parent method is protected.
Expected value should be first.
Why it's here? Please try to understand what onInstall and onUpdate are doing. If keep as you wrote: it will be a duplication.
I would use something more random here, like RandomStringUtils.randomAlpha(Tv.TEN), for example
I don't get the idea of using an array here...
add requireNonNull for bytes
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
- this.ephemeralCount = new HashMap<>();
This not called from anywhere? Besides this one liner can sit at the host severities for now IMHO
It'll be better to keep this action too in the Constants file.
wouldn't it be preferred to store the value of each type in lower case instead of creating it each time this method invoked ?
Please replace with Objects.equals
The range of valid Long is wider than Integer
I don't like how this method has to use the duplicated string. I'm not sure the check is needed but at a minimum it should probably use the isPasswordHashed() method.
code format
Please use prefered declarative approach - attribute in *.ui.xml
does not need to be public in non-public class
You forgot to add the address to the toString() as you did in the patch on the master branch
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
For non-public methods checkWidget() is not required.
return filterSet.getActionFilterOrder() != null
context.getClassLoader() can return null
I think the attribute "create=true" should not be put in the test case, it is used the very first time to create the database.
We discussed this already, but please remind me: update() is executed, for example, when the user resize the window. Why not to avoid any form of memory allocation in those circumstances, even if it's admittedly small in this case?
Should you call analysisReady(false) here?
You don't need to override this, every Spark 2.x distributions support kafka on kerberos regardless of the value returned by this method.
Thinking we should verify that there are actually 10 active iterations before stopping the client. Same with the reaper timeout below.
Nit: replace the three lines with: assertThat(newValue, is(anyOf(lessThan(previousMaxCellTsPairsToExamine), equalTo(1)))); Same for the other two batch config value asserts.
Please no System.out.* calls. Thank you!
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
couldn't / shouldn't getTenantAsString return the uniqueName instead? As we use it everywhere in the TenantUserManager
use parquet.Ints.checkedCast or you could get a negative value out of this cast. <LINK_0>
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
next() would return null if hasNext() is not called? I don't think Iterator contract makes invoking hasNext() and next() strictly in pairs.
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
you have an empty code line here - just something to remove before you merge.
It's better to log a message no matter compression is enabled or not, it's always easier to search the existence for a message than to find what's missing from thousands of lines.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
please compare to what you had in the past before you removed this class. log.error("Failed to import certificate: {}", e.getMessage());
s/install/enable/ (since there is an install command)
This appears in RawByteBitwiseOperationsCheck.isSecuringByte method, could you move both to a common method in LiteralUtils?
Suggestion: Please change this method to be called isDiskType(DiskStorageType diskStorageType) and use it also for Cinder
exiting, so STDERR
should atleast check o being non-null and instanceof IdentityExtractionFn .
Lowering should be set to true here, so that the elevator isn't holding up unnecessary weight
done for patch3.
In fact this test is not useful, the framework will fail to start if the injection can't be processed.
Same- catch NPE.
Sorry did not get. How AtomicBoolean is different compared to boolean wrt repeated roll possibility. In the past we used to keep the Boolean state in a Map. Now in this object.
Please revert this formatting changes
Same here and above.
this function can be private
use Long.valueOf() instead of new Long() - always for performance reasons
I think in this case we want to revoke (not lose) the partitions no longer in subscription?
How about returning right here and then needing the else cause?
Why do we need String.valueOf?
nit: it seems like we prefer to not put else after return elsewhere in the codebase
uncessary parenthesis and it is usually not a nice practice to reassign a parameter. Please declare a local var to work with.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
The status should never be null, instead it should either throw generic exception (including NotFound if that is what the response from the coordinator indicated).
Maybe use the getStorageId method here?
Should just be world, ToStringHelper automatically formats and uppercase keys look odd.
Actually the underlying objectExpr could have free variables.
throws
It could be - can you create a short script to show the issue and open an issue against the repo that contains it?
To better simulate a failure with incomplete content I would rather do jg.writeFieldName("justfieldname"); jg.flush() so that we're sure the result is invalid.
this and m_ is redundant
There are enough mock objects in here that it's worth using @Mock annotations instead.
simplify this
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Just an FYI, we have a fairly robust date parser included in EndpointUtil because of variability we've encountered in the past <LINK_0>
can you add to Builder as well
Not related to this fix, but can't we get rid of this extra InitializingBean operation and just getSSLContext() directly in the ctor ?
you're testing for silence, but detect method returns true? shouldn't return false?
This call will lead to an NPE if no thing type is found for the thing.
Revert this line?
Package private should always be enough for testing. Use the same package for tests.
Use the enum Dark...
DRY: would use this(username, password, null) instead
The range of valid Long is wider than Integer
bad hashcode.
I wonder if new DataMigrationForSanitizedDataInAdminEmailAttributes().doOperationRemotely() is enough.
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
please move the check to be after canDetachDomain() which validates that the domain exists. We'll need to move also canDetachStorageDomainWithVmsAndDisks() in a separate patch.
Should use the log, maybe a warning.
Return the zone id here instead of returning an empty string.
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
It is still public. Why?
Maybe just return map.computeIfAbsent(x->create())?
studentsWhoRespond -> studentsWhoResponded
Should this line be: subscription += ", product = " + getProduct().getId();
Should be "this" because the theme is different. If we use application context, the pop menu is black while activity them is white, inconsistent behavior. Could you modify the code and perform verification?
Shouldn't the test have some validation step?
task.get() will throw a NoSuchElementException if the task doesn't exist. is that what you want? wouldn't it be better to return an empty string?
s/long/int  public int getMaxSamples() { return maxSamples; }
All of these early returns you do like this need to be switched to if (!=null)'s 1) it's cleaner and 2) it makes code easier to understand and 3) it makes future expansion easier without need to refactor these two lines. Not to mention all you single line ifs need to be converted into two lined one minus the braces.
These effects need their text changed as well
wouldn't it be better to first register the observers and then trigger the action? - in this case up till now I guess not an issue, but I think it also doesn't harm to do it anyways, does it?
Is this stray? Or do you actually set it to test?
You can use getDbFacadeMockInstance() instead of mocking it yourself
Presumably the method getAllGroupsSize in KeycloakUtil was written so that it could be used here?
SpeedController not CustomSpeedController
why ignore the group specified by user
looks like the variable name also needs an update in some of these methods
can super be called first?
I don't think you need this new String
Lazy load this to a field.
Please make a null-ptr check.
Explicit type argument can be replaced with <>.
@Override
maybe just call this.addUpdateTask(operation, key, "") and remove the overload in BoxMetadataUpdateTask
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
Why do we need the scheduler address? It should come from the Hadoop configuration.
Could you please make this an extra bit more specific like -SNAPSHOT? Thanks! :)
Generic type not used, remove.
The operator should be && not ||
A little wasteful when all you need to do is just set the fields and return this...
Hi, @nvazquez. I see a little mistake in you test, you are testing if the method has inserted a tag or not, I think that this test needs to verify if the template inserted in the templateResponse is the same that you has passed in the first param of the method. You can do it checking if each variable in both templates are equals. The same problem in the other tests cases. Ty.
I used to do this a lot, but now i don't think it is right to unwrap. <LINK_0>
this should throw, shouldn't it?
Please add a note why this cant be implemented right now
I think it is not guaranteed that changes to slot are visible within the bulkChecker which uses the mainThreadExecutor to run since the used Set implementation is not thread safe.
does this need to catch all exceptions?
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
remove line
Pull this into a static final variable
no more need for public, I guess
The warning message and the other one is very detailed and more related to transmission of activities. I do not know if it is helpful to mention a sender in the message as these are utility methods. Furthermore even if you see the message in the log file it is not very helpful at all as it does not include the path and you also do not know in what context it did happen (I guess it is the XStream Marshaller when converting activities)
Shouldn't this be >= and not <=?
why hardcode?
I would propose to move the code to separate method of **SeleniumWebDriverHelper** class similar to **waitVisibilityAndGetValue**.
Should only be for the provided keys?
Use type ChargeDTO in return responseEntity instead of ?
This is another behavioral change that I don't want to see in an unrelated PR.
delegate=true style would be just fine.
use a dedicated method hasParameter(tree)
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
No need for else if you return in the previous if
Instead say: synchronized (this) { wait(100); } This way you don't have to wait 100ms during shutdown.
nitpick: should be bindingAdapter
I would ignore empty notifications and would log warning.
Why did you only do this for HealthReportBroadcastService? AnnouncementsBroadcastService uses a similar paradigm.
return flagdown; ?
The only reason this should be null is if the Activity context was used instead, so in that case we should throw an IllegalStateException or RealmException saying that the application context should be used, otherwise all the import logic will fail silently as far as I can tell.
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
Instead of binding to an instance here, you can create the eventBus instance via an @ Provides and @ Named evenBus instance for injection into GuavaApplicationEventPublisher.
You should change the error message here to be about AWS rather than GCR.
final
true?
You should probably test with both pessimistic and optimistic transactions, and pessimistic with both RC and RR isolation levels. Also multi-node tests can reveal more issues than single-node ones, I think (testing both owner and non-owner variant).
I think it would be suitable if some kind of padding is applied between messages, such as a newline
@v-stepanov isn't it changing the behavior? Before this change we used to log 102 but now it's not clear if the status in the response is going to be 102. I think this is a special log for calls to consumption API where we only know the real response status code afterwards.
you can put as a second argument default property like "not found". so it would be: return properties.getProperty(VERSION_ATTRIBUTE_NAME, "not found");
please put each parameter in separate line :)
Hm, you got java doc on the next method, but not here?
This can be refactored to m_isTable = "true".equalsIgnoreCase(table)
should be returnValue && vmDevice == null
Why not make al these Calculate classes private to the method? Creating new ones everytime is a bit useless
Can this be null?
Please make this constructor private to force users to use the builder, thus forcing the validations
Generally with these kinds of constructors you'll end up calling the other constructor directory, passing in null for the ignored param.
Should be protected. Knowledge of link text belongs in Page model classes. A Page class should expose an addDilution() method rather than clickLinkButtonAndGetUrl("Add").
I think you need to call setSize instead, which does things like updating the bounding box.
tableScanSchedulingOrder
minor: could be a function reference instead?
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
Change to: include = true; (@jessehatfield, @meiercaleb) Or should we have a config option for each restriction? (i.e. conf.isInferHasSelf()) It appears that some visitors do have a unique config option while some don't.
you could just do setConfirmWindow(null); like above method
Let's do just one more tweak here. I understand that you need this check in order for anyMatcher to work correctly, however the current solution will break this scenario: java .anyMatcher() .requestMatchers(AnyRequestMatcher.INSTANCE)  While it would be odd for a user to do this, we want to be consistent in our behavior. Since java .anyMatcher() .anyMatcher()  is disallowed, so should the earlier one also be disallowed. It would also break here: java .anyMatcher() .requestMatchers(AnyRequestMatcher.INSTANCE, new UrlPathRequestMatcher("/path"))  I believe the answer lies in adjusting the anyRequest method implementation. If we don't set anyRequestConfigured until it is actually configured, then I believe the extra if check here is unnecessary: java public C anyRequest() { Assert.state(!this.anyRequestConfigured, "Can't configure anyRequest after itself"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; }
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
in some cases lhs/rhs could be null, pls do the null checks appropriately
This needs to choose the target when the ability triggers, not when it resolves. I'd use adjustTargets to do this.
hell no
Can you mark this @Nullable please?
shouldn't you convert the logType.getDuplicateEventsIntervalV value to millis?
This should check the environment variable before returning true.
Catch exception.
Do you have a test that peeks the next sequence number?
this.
This is not equivalent to the old code (was size >1, now it's size >0)
the name of this method is not clear (pun not intended...) because the word 'clear' is usually used when some collection is being emptied. actually looking at the code in the clearAttachments, you are computing the attachments to remove. this makes sense, and is also consistent with the row above 'bondsToRemove.add' but is obscured by the name of clearAttachments. secondly, the last line in the clearAttachments() method is not dependent on the id that is being passed to it. so this line should not be there. it should be here below line 60. then you can rename clearAttachments to calcDestAttachmentsToRemove. this would make the flow symetric, consistent, readable.
does makeFilters need to be called again here? can you just use filters from previously?
is it necessary to encode duration iso standard?
let's update all the includeTextDetails references to includeTextContent
Oh please, no! Don't ship a null object! :cry:
I had copied the following functionality from the MessageListFragment.java: public boolean isAccountExpungeCapable() { try { return (mAccount != null && mAccount.getRemoteStore().isExpungeCapable()); } catch (Exception e) { return false; } }
lambda
I'm not sure if I agree with this change. if we have a case where setValue() is invoked multiple times, I would rather return "prev" than "oldValue".
hashCode and equals are inconsistent.
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 89-90. Do the same for the others.
Can we remove this?
could we log this exception? also should providing invalid config prevent the app from starting rather than defaulting? e.g. setting it to 100) instead of 1000 and having it default to 20 could cause nasty problems?
Rather than return a new arraylist - just return an empty iterable, e.g. return Collections.emptyList();
Should this return the AzureTable?
Check if there is an appropriate constant for "no metakeys" mask.
this is not correct... I would have hoped we have unit tests for this :). This method should return the cause() and not throw it.
Don't you check for array size >=1
filterRowKey should only filter based on the rowkey, here you are looking at specific values. This is most likely called only once per row. I'm guessing the current implementation wouldn't work on SPLICE_TXN, since we'd inspect the latest written cell (COMMITTED or ROLLEDBACK), see that it's not the ACTIVE state and filter it out, which would filter out the whole row.
no-else-return rule: this can be simplified to java if (condition) { return a; } return b;
To always be safe please use context.getApplicationContext()
Maybe instead java /** The filename without any compression extension, or the original filename. * It tests for compression types handled by {@link #openFileEx}. */ static public String filenameNoCompression(String filename) { if ( FilenameUtils.isExtension(filename, extensions) ) { return FilenameUtils.removeExtension(filename); } return filename; }  I believe we have commons-io already in the dependencies list. There's some extra check for null bytes in the extension check... but that's not so important. Just simpler I think.
Are you specifically allowing air itemstacks to be created now? There is a way to validate that the ItemStack itself is empty (hint, look at the fields in this class).
Not doing getClass().getClassLoader() and just leaving it null would default to TCCL. Not sure which one is best.
Is this really needed here and in the next state-change methods?
remove this
Also called twice here.
Missing a unit test to ensure maintainability.
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
Does not compile, but not really important.
Does this work if transactionCallbacks contains multiple callbacks? If previous code causes recursive call, I would think ConcurrentModificationException would be thrown.
"= 0" seems sufficient?
This could just be: return isFeatureEnabled(context, namespace, name, false); which makes it clearer that the 2 methods do the same thing with just a potential difference in the default.
please fix whitespace
Why this change?
This can be static.
is this class going to be created by the user?
Why did you remove this call?
Avoid the intermediate variable and directly assign selfID.
Null-ptr check, please.
can be !isDisabled()
Should we alert the user that an error occurred here?
use this.size()
check for not null
please move the isEmpty methods to the scimSchema
I know it's a legacy, but I'd like to kill that kind of unnecessary methods, like we started to do last year setUpBindings, setUpToolbar, setUpDetails
Use org.apache.commons.collections.CollectionUtils.isEmpty(Collection) - it also returns true for nulls
Use server from server_context.xml
Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase(). I suggest creating a new tearDown() method for performing the rollback.
Instead of copying the list and requiring a (potentially) unsafe cast. I think we could make more use of generics in ClusterManagerCallback.
Is this case possible? bootArgs not empty and oldMacSequence or newMacSequence empty If so, would not it be better to return at line 2131 the variable bootArgs?
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
Include message saying what was wrong if check fails? e.g. including the original ref argument passed in.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Typically we use Map on the left hand side rather than HashMap
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
calling super not needed
return Collections.emptyList();
We shouldn't catch a NPE. We should prevent it from happening. What is resulting in an NPE?
Wrong method name in the error message.
I believe the expectation is that listeners will be configured before the job starts. That is, the resultsSoFar would almost always be zero. If so, it wouldn't be beneficial to check against the maximum in this method. Also, fluent method should never return null because chained calls such as withBatchSize() in this example .onUrisReady(...) .withBatchSize(...) would be guaranteed to produce a null pointer exception.
I would prefer not to use null ... just a empty set and then assert that its not null
checkNotNull(value, "value")
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
Style inconsistency: space after if
nitpick : final Throwable t
I would recommend an else if here to avoid comparing against a string unnecessarily.
Nit: the else is redundant since the if block above returns unconditionally
The log should rather say "Destroyed all file based persistence context" instead of "Destroying..." as the logging happens after deletion was done.
Just a suggestion: Objects#requireNonNull(Object, String)
The check is not necessary, File.mkdirs doesn't attempt to create the directory when one already exists.
no need to specify type on RHS
nit, Collections.EMPTY_MAP?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
do we really have to work with classNames here and couldn't use Class objects directly instead? This smells like dynamic-import again :-(
I don't see where we handle HibernernateException.
Should we add an empty() check for ignore.value() as well, before doing this concatenation because if the user didn't specify any value for value(), then we will end up setting a description which looks like  : my regression which kind of looks odd. So I think we should add an empty check for value before we decide to use it to set descriptions.
It may be cleaner to use Objects.hashCode for a single parameter, and Objects.hash for multiple (see the warning with Objects.hash, though that doesn't appear to matter here).
replace with return this == other;
Why is this needed?
Should be ObjectId, as the mapping cannot be mutable.
I'd split the map() here into two separate phases. First mapping the Entry to an Integer, then sorting the Stream<Integer> and only then mapping the years to IdNamePairs, e.g.  .stream() .filter(e -> e.getValue() > 1) .map(e -> e.getKey()) .sorted() .map(year -> new IdNamePair(String.valueOf(year), null)) .collect(Collectors.toList())
There must be a more succinct way of doing this using streams.
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
remaining time only makes sense if the state is down. In the up case downUntil could be in the past and this could print a negative, misleading value.
there was a NOT ('!') before the check.. i think still relevant, no?
It's a good update
Add the info log back after this line?
@Override
This class seems to have too many responsibilities in it. It looks like that in addition to it being a model, it also has knowledge about how it should be displayed in the generated code. Split these two responsibilities out.
This probably needs to be .asEagerSingleton() as otherwise it may be pruned (nobody will depend on it, it's a leaf)
Not needed?
Please use LOGGER.debug because this error is kind of expected.
Please keep this.cell near the related fields (previousFamily & cell count) below
I believe Role.SERVICEUSER would allow any service user to call this. Regarding rest of our API, you should check for FACILITYADMIN role and you should filter resulting list of facilities to return only those, where user is facility manager. Or to be more correct you should check, if user has READ right on attribute he search by on that facility. If not, do not return the facility.
no need to specify type on RHS
nit: Please include e
you import ByteBuffer, no need to use the full package path
It's not needed to check null, also inside of QueryBy.valueOf has internal check if the item is not one of enum items, exception will be thrown, should be changed to something like:  @JsonCreator public static QueryBy of(String value) { return QueryBy.valueOf(value.toUpperCase()); }
A question: Omitting the map.isEmpty() check is intended? Overrided default method does the check but here only a null check is done.
Seems like this configuration is being created and not used. Does this test pass?
having these getters here means they would be included as json fields. Since they are easily calculated, and not used anywhere else in the code maybe exclude these? (think two extra fields x 3000+ requests all in one json blob)
this("Safety Command")
Hmm, why did we do this? I thought we'd have a try/catch block.
Please format here. And maybe use method reference to simplify: indexToChunkIds.values().stream().map(Pair::getFirst).collect(Collectors.toList())
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
Do we think that overByAmount will actually be a useful/actionable piece of information for users? As opposed to just saying it's too big to upload without specifying by how much?
Replace all 0f with 0 please.
shut down one word; i.e. shutdown
braces style and this expression may be improved:  if (!config.isHigherFitnessValueFitter()) orderDirection = "asc";
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
Why use only w2? Why the right shift? Likely it doesn't really matter.
Maybe this should use makeUnknown instead of getUnknown. I think the difference is that makeUnknown will create a new one, and the new one will have its own insert date and user. I think getUnknown will cause all placeholders to have the same insert date and user.
We don't need that here, null is OK if pretty name was not specified.
You can use StringUtils from the commons.lang3?
failCanDoAction?
static import
The parameter needs to be 1 since the backup model node is one level below the cache
'+' ? use && or ||
We don't know for sure that there is such a field in that specific event. Should use ITmfLostEvent.getNbLostEvents().
I'd use getPathAsString instead of getName to provide unambiguous info.
I'm fairly certain that you could replace all of these with method references. e.g.: .map(this::convert)).
nit: you can merge both lines above as checkNotNull will return the given argument
Let's refactor Topic a bit to be able not to pass anything there. We'll have something like new Topic().withBody("ab") and therefore other fields like title will be generated randomly.
nit: No need to print out organizationDiscoveryIntervalMillis.
why is this public?
mResponses.size() > 0 ?
log exception
No need for this.
wrong error text
why delegating
I would delegate to the new method directly
Local variable could be declared List instead of ArrayList. Is this worth caching?
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
nit, Collections.EMPTY_MAP?
In my personal experience, I've found that it's idiomatic to write this sort of code as either: java // Imperative option Map<String, Object> map = new HashMap<>(); for (int i = 0; i < accessor.size(); i++) { map.put(Integer.toString(i), accessor.get(i)); } return map;  or: java // More functional option return IntStream.range(0, accessor.size()) .collect( toMap( i -> Integer.toString(i), i -> accessor.get(i)));  But as I'm unclear on what the JUnit 5 team think of creating maps the way you've already done it, I'd wait for feedback before changing anything. :)
could we log this exception? also should providing invalid config prevent the app from starting rather than defaulting? e.g. setting it to 100) instead of 1000 and having it default to 20 could cause nasty problems?
See ByteByReference.java
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
@RobberPhex If you make the input a Collection, then you can take a Set as input. You should also consider using a List internally instead of an array. It might make the above simpler.
i think we had talked about swapping the order of these so we can short-circuit?
#close() could probably be called instead of this if statement
add: import org.ovirt.engine.core.common.utils.Pair;
this("Safety Command")
Is this access modification potentially problematic at all? Could other things just start randomly removing screens, by chance or on purpose, or is it badly needed for something?
Can check isBlank()
nit: Root groups cannot be fetched from the database
Why not return getAnnotation(annotationType) != null?
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
This is not a good convention. How about changing internalNext() to be able to return null to indicate there's no more elements?
This line may get logged a lot of times in a production system when s3 select is enabled, no? (when I trace it, it gets called from HiveSplitManager.getSplits()).
remove empty line
threadCount <= 0?
I assume this function must only be called if the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
You can now use [RegistryHelper](<LINK_0> here
CHANGE it to TypeConstants.JAVA_LANG_RECORD
It could return 0, but should be 1 at least... no ?
@dmzaytsev let's inline this
Why to call finish?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I still don't see why we need the 'if..else' here? both cases are the same
We can't filter by closing time?
Should we include organization here too?
Again, I think this should evaluate against the standard special path info, not the stuff for the maven package
Simple for-each?
If we're moving this logic from the DAO to HibernateAccount, we should also move the tests from the DAO to HibernateAccount. Similarly for getSharingScope() and getNotifyByEmail().
Since there are two places using "tree-item", consider replacing it by a constant just like you did on the other classes.
why not with stream API? will be cleaner
not necessary, a boolean is false by default.
Collections.addAll(this.features, features) can be used instead of for loop
Line seems to be having more than 120 characters.
This is only used with the ComputeService implementation. Please remove it.
Does this now call stop asynchronously, rather than previously doing a blocking call? Should we do a .getUnchecked() as well? Or return the task?
Table per namespace, interesting.
Would it make sense to automatically call this method via on-persist/commit hook, depending on the event state?
';' (character; single quotes; otherwise you'll need a NON-NLS again.
The implementation of getMeasurements() makes sure the list is only exposed as unmodifiable list. The code invoking the constructor can still have a modifiable reference to the measurements. Creating a new list containing the measurement values provided would prevent this.
?????
this is already called in BasePageObject so you don't have to call it
It could use StringBuilder instead.
Please use else if. However, I am wondering if the result is always false when o is an instance of DenseMatrix. I've tested this in scala console with a DenseMatrix and a CSCMatrix both of which have the same elements. Can you check this?
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
extract getVmDao to getter
not need for 'this'
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
Please keep this.cell near the related fields (previousFamily & cell count) below
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
There's no concatDeep, I guess..? ;-)
Duplicate in throws clause - [fixed in master](<LINK_0>
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
Should this be in the errors.properties file?
If .close() returns silently on repeated operations, we can drop this check. Otherwise, I would argue moving the debug statement to within this block so we don't output a message when we're actually going to no-op.
It might borderline overkill, but I'm considering if we could avoid the copy here with logic like the following:  if (!groupSubscription.isEmpty()) return groupSubscription; else return subscription;  Basically relying on the the group subscription being a superset of the local subscription when it is defined.
This isn't a Messaging component and from other side using this one within a Messaging component, raising a MessagingException from here, we prevent re-throwing a correct MessagingException with failedMessage context. So, for me simple RuntimeException is enough in this context. WDYT?
can we make this one configurable?
suggestion Assert.notNull(id, "Labelset ID must not be null.");
We don't need this, the ConfigSaved would handle this already.
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
Collections.unmodifableList()?
Should there be a second catch for ClassCastException? is art checked somewhere to verify that it is always a teamWorkFlowArtifact?
this code doesn't seem very safe. If the call to db fails, the class construction might fail, and then it's hard to troubleshoot it, no proper logging, etc. Isn't it better to first get the domain from db, and if it returned OK, pass it to constructor?
nit: I don't think you need fully qualified path name. it can just be CompletableFuture<LedgerEntries>.
This doesn't have to be public. Just use default package access since only thee cache impl in this package has to see it.
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
Inline this
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
while you're at it, you can remove the thises.
how about  java return method.isTestMethod() || method.getTestMethod().isAfterClassConfiguration();
Can you add @NonNull @CheckResult @WorkerThread to these two methods as well?
These look wrong - the end times are being set precisely - so shouldn't the updated value be 1500000?
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
Maybe we can call this markAllUploadingMediaAsFailed() like the EditorFragment so it's clear this has to do with media?
I removed this change ... Use should not place any files in repo, we can come back to this if become very annoying.
having these getters here means they would be included as json fields. Since they are easily calculated, and not used anywhere else in the code maybe exclude these? (think two extra fields x 3000+ requests all in one json blob)
I'm not sure the sorting should be in ArenaImpl. The reason getNonreadyPlayers() returns a List rather than a Set is likely because of its original call site in the notready command, where it is fed to a utility method that stringifies a List. So it's probably past laziness more than anything :P I think it makes more sense to do the sorting at the caller site rather than in here. If nothing else, it reduces the blast radius of the pull request and keeps the changes "collected" in the signs/rendering code.
instead of addAll(), you could just return the free vars from the definition. Same in VarDeclaration
single quote '/' and remove //$NON-NLS-1$
In alignment with valueOf, perhaps name this valueOfType or fromType?
Move the strings into constants.
this.lockVerbs (like below)
"You do not have any tapes"
same thing, while you are cleaning, other thread could store other key.
I suggest encoding the above 4 assertions in a single call: assertEquals(ImmutableMap.of("1", "hazelcast", "2", "phonehome"), map);. In general it is a good practice to check the expected output in one assertion, instead of checking its pieces separately. Also, in these assertEquals() calls the expected and the actual values are mixed up. First should come the expected, then second the actual. Of course it works this way too, but if the assertion fails, then the output becomes confusing if the expected and actual are swapped, so it is useful to always put them in the correct order.
This case should no longer occur, right? In that case I think it should be removed.
You must cancel request on both 2 senders because, for the same registration you could have pending request in queuemode and not queuemode (as binding mode can change) (I agree this Far-fetched but I see no problem to just call cancelPendingRequests on both sender)
Missing types
does this have to be a list or can it be an iterable?
as is in 718
SecurityException?
log()
IMO we should still throw an Exception here after logging the error - failing the deployment seems OK to me, as long as the user can find out _why_ the failure occurred. (If these values aren't specified, **the function itself won't work.**)
Use getSimpleName instead?
Better to return "";.
Will you expose this in JDBC too? ( <LINK_0> )
the whole goal of new values API was to remove casts as much as possible from all the equality methods, this change does not follow that paradigm (this place and all other updated equals methods) is there is any way we can avoid that?
Can this be private, or is there another use case for default attribute outside the builder's call?
Not sure is worth doing this change.
"not" function is already available in StandardFunctionResolution. But I don't mind having it here given it's a test.
WithTasksContext
This should be doable with Allele::basesMatch without converting the allele and the transition base to Strings.
You could instead annotate a method with @ExceptionHandler(NotFoundException.class) and @ResponseStatus(HttpStatus.NOT_FOUND) to return the error page, and then throw a NotFoundException to trigger it, which would result in the proper HTTP status too. This method could go in a separate class annotated with @ControllerAdvice to apply to all controllers, though you'll want to exclude the REST controllers
if credentials is null should not execute mocked push
are you sure we need to use OSString ?
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
I would use log.infoFormat since it is the standard way. Also, I think logging this at info level is too verbose, this sounds more like a debug to me (and if someone wants to monitor this query specifically he can lower it's log level)
if implementations is empty, this method will eventually return an empty (immutable) collection. We should throw an UnavailableImplementationException instead to indicate an invalid state or spi class.
Don't need this keyword here - the rest of this code only uses this when necessary.
bad hashcode.
Are we disallowing zoom controls for a reason? I'm noticing a lot of these calls being made. We should probably standardize on a common function that will set all the settings for maps. Or do we have a common mode of operation?
**USB**
We could omit the second Integer.
I don't see where we handle HibernernateException.
For each?
finalize?
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
Add PageLogging
@dalifreire join this with the previous line
Windup/Discover/Java ?
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
Remove throws Exception
E.g. here we could compare this to Webrequest.REFERRER_UNKNOWN rather than hardcoding the string.
style nit: no braces around single line blocks
I think it would be suitable if some kind of padding is applied between messages, such as a newline
Magic number -> symbolic constant.
please use curly braces even though this is a Oneliner
replacing this with helper method would be great
Messages._Warnings_Armcc_ParserName and so on...
why gone?
Given that this method is already dedicated to the audience claim, this change is redundant. Please rollback
foreach
Let's add a ctor for FeatureFlagBuilder(FeatureFlag f) and then make FeatureFlag immutable.
@ikhvostenkov again json, maybe this part with mocking MemberProfileJson and adding when to it could be moved into single private method that would accept just the filename as a parameter.
can we remove this method and simply have the poolsOfString.take() where this method is called?
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
Don't we have to say that this is uniqueId JDBC?
the put will remove the previous mapping
No need for the double (( and ))
log exception
Why empty string and not null?
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
Shouldn't it be [null, null]?
VoltFile?
Why is it a list of lists, not just a list?
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
It still needs some kind of fingerprint identifier in the message, e.g. just its ID/hash
Using StringUtils here looks like overkill - since you're comparing to a constant, just use "TYPE".equals(fieldName)
this.url = checkNotNull(url, "url");
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
This cannot be null. Guice won't allow the constructor to be called if the reCache arguement is null, as the argument is not marked with @Nullable. Or is this null because of unit tests? If that is the case I would prefer to define a mock cache in the unit test since at runtime we always have the cache.
replace with fType.add(DescriptorType.STRING); the idea with EnumSet is that as you see values you just add() them to the set, without having to care for the current contents. Then when reading you can check things like contains(), or the utility methods like isNumer() proposed above.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Even though it's java there is no reason for trailing spaces
Shouldn't this close the iterator before returning the list?
why was this call webResource.init deleted?
Which type would be assigned in this case?
I think it's customary to add the encoding; UTF-8.. IIRC @psiroky went though the codebase a while ago adding missing encoding... might be worth checking.
If this constructor is to be called only by the builder, remove the public modifier
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing an exception if the property is set, but is not "true" or "false"? Or, at the very least, log a warning.
we could extract extra method for all of this.classes.addAll here instead of repeating this 4 times
It would be easier to instantly see whats going on if there was a method deleteLayersForProvider() and removeProviderFromLayers() which would be called based on the boolean. After the conditional statements you could call deleteDataProvider() that would return the removed provider. Then you could write the response based on that in handleDelete.
Remove wakeup flag from settings, added new state type wait, if parent is in wait state wake it up when child finishes
EINVAL is expected for FileDescriptor.out / FileDescriptor.in. This is only expected to work for descriptors to "regular" files, and won't work if in / out are pipes or sockets (which they are, in some configs. The man-page uses weasel words to say this "EINVAL... or an mmap(2)-like operation is not available for in_fd,".
You should be able to use the diamond operator here, i.e. new ArrayList<>()
Add the info log back after this line?
Minor: use AssertJ org.assertj.core.util.List.list and static import for readability.
Use nullOrBlank() function or test for all - null, empty and space strings.
I'm still scared something stupid not using result = ~~result in your hashCode implementations.. but if you're happy.. then.... you'll be the one scratching your head _if_ the JIRAs start rolling in about V&V going crazy after a while..
This can be replaced with  java return newName.isEmpty();
BufferUtils.byteToInt?
1) /s/executing/Executing 2) I think it will be better to add this log in the buildStoragePoolDomainsMap method so it can be also used for reconstruct and we can get more information about other storage domains statuses.
Oh, right, that was me. Sorry!
Why not check the total number of images returned? What's the benefit of this filtering?
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
I'm not sure what exactly append here :wink:, but it seems to me possible to generate the same synthetic name both if we call this function two times in the same millisecond. Why not use an increment based on Context like with closure and decorators synthetic names?
Should it be background?
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
Only this check might be enough?
It seems that we are missing the resolved name for the getter case. I was thinking that we would need similar property as for the field to store the resolved name or am I missing something?
Qualify with this. Same goes everywhere.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
If the BigDecimal multiplier values were static final class variables, you wouldn't have to "new" them with each conversion, which might be more efficient.
Why not extract assertThat... into separate methods: assertRoutingKeyResolver for example. If the requirement is not fulfilled, a message could be provided to be used for an AxonConfigurationException (I would argue that we could use the same message for both purposes: invoking the build method and validate method).
@cristianoperez thanks! it really sounds better as a default value. I'd only keep a fallback strategy for users that for some reason want a new session to be created. for example:  request.getSession(createNewSession()) //... protected boolean createNewSession(){ return false; }  what do you think?
throws RestApiException not necessary.
Please change to externalSearch =
why ? how could this happen concurrently ? the workspace modification locks should prevents this.
if that previews is showing cleaned-up code, why is this one still here?
I think it's better to return an empty string here, to indicate, that the contact is unknown
please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean());
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
I think you want to call the new method which gives servers based on glusterPeerStatus
Calling System.exit needs to be carefully controlled or it will break embedded usage. "Quitting" an embedded CLI may not mean the user wants the embedding app to exit. On the server side we do this by using a SystemExiter interface, and all "exit" calls use that. We then swap in different impls of the interface depending on how the server is being used. The standard impl that is used when we know the server was started from the command line calls System.exit. Others do not.
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not get into corner cases :) )
grammar nit: 1, not one, and no :
Just use something like ZoneId.of("+08:00")? convertToZoneId should be removed eventually.
shouldn't actual <--> expected be replaced here as well ?
suggestion assertKeyPair(file, null);
I'm not sure about the method name though. Why not "build" like in the state system analysis? Or "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
Maybe this will already be immutable. And a list.
setErrorMessage
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
suggestion throw new UnsupportedOperationException("FileStoreAttributeViews aren't supported.");  Indicating currently isn't needed, let's be more blunt on the exception message.
you should have here setSucceeded(true) IIRC.
Can we throw the explicit exception not generic?
throws APIManagementException
dare to extract a constant which increases visibility for this hard-coded value?
Right now, you are only setting the window to the screen's dimensions. This is not a "truly maximized" window. You may try setting maximized after setting the window's dimensions.
Not necessary to call super(). There is an implicit call to super() with no arguments for all classes that have a parent
why not have the formatting method in UserAgent?
Can we make this method final?
return onCancelled()?
I'm not a big fan of this format. Let's keep things consistent and put curly braces around the throw new CandybeanException
What if there are duplicates in this stream?
Owner metadata is not being set here
Java does not contain the keyword null.
I don't like this arbitrary limit of 400. Instead, I would check whether the index of the last visible line is lineCount. How about: public static boolean isShowingEntireContents(StyledText widget) { if (widget.getTopPixel() != 0) // more efficient shortcut return false; int lastVisiblePixel= computeLastVisiblePixel(widget); int bottom= widget.getLineIndex(lastVisiblePixel); if (bottom + 1 < widget.getLineCount()) { // There's definitely more lines below return false; } // Check whether the last line is fully visible int bottomTopPixel= getLinePixel(widget, bottom); int bottomHeight= computeLineHeight(widget, bottom); return bottomTopPixel + bottomHeight <= lastVisiblePixel; } That should also be much faster since it would at worst compute line heights for the actually visible lines, and it doesn't need any arbitrary magic number.
grammar nit: 1, not one, and no :
I recommend using Collections.emptyMap() instead
nit: can you put "File connector started" instead?
Same as above, please move this line under the SetViewport line and add an empty line after it.
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
It seems that we are no longer required to pass the session Id to the event?
Thanks for adding this!
nit: make this final
It would be great to have braces around.
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
@paulodamaso the braces and return are not needed here
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
This fragment is similar to the one used in generateFeedbackSessionEmailBaseForInstructors so it would be good if you can extract a method to generate this fragment or use some sort of html template to generate this string to reduce the repetition.
This restriction only applies to the event name and parameter name. Parameter values can be any string, long, or double.
If sharding key is /abcde, are these paths expected to pass this check and supposed to use this zkclient: - /abcde_0/xxx - /abcde/abcde-0/xxx
See earlier question.
please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean());
remove line
Please remove, it is no longer needed.
This is a very interesting way of handling this. I'm not quite sure how to feel about it yet, so let's leave it as is and see if it establishes a pattern for general output processing of the Java rules output. If so, keep them all; otherwise I would argue this is probably an expensive way of doing a null check.
The constructor should be made protected so that users can easily make a wrapper for it.
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
Why use a full-name import here? I don't see any conflicts.
to STDERR
Ok, but in the future, you might consider constructing these w/ JSONObject or GSON.
we could factor out a private getBinderForChannel() method given how many times these 2 lines are duplicated:  String transport = this.channelBindingServiceProperties.getBinder(channelName); Binder<MessageChannel> binder = binderFactory.getBinder(transport);
+ desc
Hi @rezita, I think this should be isSHREnabled
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
Similarly, EqualsUtil might be of help here.
Add there an example of valid value res:RESOURCE[:CHILD-RESOURCE1][:CHILD-RESOURCE2]...[:act:ACTION[,ACTION]...]
Could you replace the sole use of Guava's Files in this class with java.nio.file.Files.copy() and then avoid fully-qualified class name?
Use the API method and pass all given ids as ListInstancesOptions.
Would be preferable for this constructor should reuse the new one (i.e. this(name, durableWrites, replication, false)). Should also mark this constructor as deprecated as it looks like existing uses of it were updated to use the new one.
As a matter of symmetry I would expect a getter to return something of the same type as accepted by the corresponding setter, which in this case would be a Map<String, String>. In general I think difficulties in retrieving the correct results and putting them in an easy to use format should be handled by the API client and not by all callers of its methods.
Should we put the check here too?
Since the menu item click has been handled, return true instead here.
Best practice: Handle RuntimeExceptions coming from implementations, suppress and log them. Otherwise one plugin can break all other instances && node replacement flow
- log warning that option is not supported by SNMP
You can build new KillbillPlatformConfigSource(configSource) once.
I thought the compaction mark would be determined by the log unit on actual compaction? does this mean the compaction mark is set on garbage marking?
rename to p, prop, currProperty
why this change? private port can never be null. Public port can though
same as above with the actionBarWrapper
create a buildServingTrucks method or something similar in the TruckEntry class instead of doing it here
mmm, i think this whole method should just always true. an I/O problem and all the other things are different from not being able to handle the request.
delay is already completed.
Would be great if we can check if the envelope.getOffset() is not null.
Pull this into a static final variable
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
Translate this RuntimeException message in English please
throw exception
ctx.close()
optional: consider returning this from setters to support chaining configuration.
UnsupportedOperationException might be more appropriate here.
Please move to a separate "Polishing" PR.
try block.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Better to return "";.
Need to implement
Should remove, and use similar functionality in CoreAuthenticationTestUtils
Why not rely on Optional, rather than introducing another method which could lead to NPEs?
you have lost the cause e
This same as next test in terms of logic, since you're not actually testing the "default" min range is used since a min range is set on the annotation.
where did this go?
Should we keep a reference to the Bundle here?
requireNonNull
please validate ledger id
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
No idea why, but the loaded_template entry on quality gate has not been removed on my box
If ClientCnxn.clientConfig is final then you can replace this by clientConfig.isSaslClientEnabled()
You can use [String.format](<LINK_0>,%20java.lang.Object...)) to make the code more concise.
This check is useless as the customParams can never be null.
Is it possible that this could ever return anything other than UNKNOWN_STATS or usecom.facebook.presto.cost.FilterStatsCalculator#UNKNOWN_FILTER_COEFFICIENT here? I don't expect FilterStatsCalculator can estimate anything useful for spatial join. Are you OK with this? This basically means that CBO will generate more-or-less random plan for queries with spatial join.
X and Y are primitives, so should the %s be %d here?
Something is weird here. The only place where something is added to activeServices is the registerService method, which itself is called in this loop. So my assumption would be that this set is always empty when we get here, resp. the registerServicemethod had already been called for the service in question. What am I missing?
Why not java static Builder builder() {  ?
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
log.trace
This plays the current, not the next station.
Again, I'd default to false - I think 'nothing' makes more sense as false...
Can this be private, or is there another use case for default attribute outside the builder's call?
I'm missing the new field in the toString method.
Should we handle the case where assignMessageId returns Message.NONE ?
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
This can be done through one call to obtainMessage(what, arg1, arg2, obj)
Just use !secondaryIndexes.isEmpty()?
This can never be null given the code in setData above?
This line is probably not needed at this point.
Multi return is forbidden.
I think that with this logic it is possible that: - hyphen become the first char - hyphen become the last char Those cases are forbidden in hostnames.
the toString() isn't needed here as the AgreementType enum will automatically serialise to a string
you should have here setSucceeded(true) IIRC.
This method should be implemented.
The local var is useless, you can remove it.
You catch only NumberFormatException which could be thrown by Long.valueOf, but timeTZOf-> checkRange could throw IllegalArgumentException that is not handled.
the ArrayList of languages to translated could be cleared.
This is using scheduleAtFixedRate but task DirectoryScannerThread never terminates.
Favor creating the exchange from the endpoint, eg endpoint.createExchange(...)
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
If this is just for test validation, why not verify the pojo instances instead of doing the toString conversion?
Without the access modifier this method will be visible inside the package but not by subclasses or classes outside the package. Is this what you want?
suggestion this.authentication = new AuthenticationContext(username, password.toCharArray(), null);
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
UnsupportedOperationException seems reasonable here.
The equals check is brittle, I think it'd be better to do a check against a query context key. Or alternatively, do something like groupBy does, and use mergeResults to modify the query to remove the post-aggregators. Then, everything downstream of mergeResults on the outermost node (typically the broker) will ignore the post-aggregators. That could be done by overriding doRun in the ResultMergeQueryRunner.
copyOf does not necessarilly copy (I know name is misleading). Also we value readability, and old version is way more redable than the new. Finnaly we prefer relying on guava's collection. So I disagree with this commit.
I'm afraid this could spam the logs. I made bad experiences with logging when developing the DOIConsumer. Please reduce the log level to debug.
To prevent code duplication, would it be possible to change the body of this constructor to the following? this(); this.builder = builder;
isErrorIfHostDoesntExist => isNewHost
Should emit list of values, using setDimension(String, String[]). Also the dimension is called "dataSourcesAndDurations", but only data source names are emitted. Also if this change is done, getMetricName() method name will become confusing.
count(*) is more canonical than count(1).
Is this used anywhere?
It's all histograms from now on, and IMO the per-site statistics should be in core, not extended-statistics (for sync backups too).
final URI uri
the storage pool should be set from the quota object, i don't see a reason to send it separately, apply also for update and remove
use this.size()
I think we can remove this line.
final or inline into the call to assertEquals
Use same order as the field declarations.
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
wrap INSTANCE = new IndexClient() in another if (INSTANCE == null) { check - this is known as the double locking technique
Oh please, no! Don't ship a null object! :cry:
This should stay final
Optional.ofNullable could be used?
hope it will works here as well for this class
remove printlns before this is merged
this whole tests needs some cleaning up before we merge it back. i'll look into it
Please change to 0f and 0.000001f. Otherwise assertEquals(double, double, double) will be called.
This error message is kind of confusing. Perhaps replace it with, "Error in accessing DB.".
maybe log an error message here if numConnections ever goes less than zero
Looks like you are making double slashes here...
In order that the test runs successfully is a debugger required or is this some artifact of the test development?
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
I don't think this is atomic.
So this will be used for quantity and duration too or you need separate ones?
avoid this containsKey
Is there a reason why this. is used for calling the setter in all the constructors?
How about setup(Long.MAX_VALUE)? 0ms timeout only works when we use wait(timeout) for checking timeout.
Should also have tests for strong with preceding character content, and following character content. (those are areas where we've had troubles before)
this statement can be removed. No need to set any OutputFormat on the job itself. We'll use the OutputFormat for the specific output (being defined on the next line).
uriHost is already a String. No need to call toString() on it.
Inline please.
The original is not removed, so either there will be duplicates, or the hashcodes will match and trying to add the managed version will do nothing
again - encapsulation
Move this private method below the public analyze* methods?
Please avoid unnecessarily nesting if blocks. This method could be written as: if (getName() == null) { return getPersonId(); } else if (getPersonId() == null) { return getName(); } else if (getName().equals(getPersonId())) { return getName(); } else { return getName() + " <" + getPersonId() + ">"; //$NON-NLS-1$ //$NON-NLS-2$ }
Consider returning a constant
Initial size can be ownConfig.size() rather than +inheritedConfig.size(). And could create copy with with return Collections.unmodifiableMap(Maps.newLinkedHashMap(ownConfig))
you might want to make 10_000_000 a constant
@evacchi I'd vote for creating the output set only when there are outputs. Here the outputSet is always created no matte if there are outputs or not. This will produce an empty <bpmn2:dataOutput> tag in cases were the catching event don't have outputs (there are some of them that doesn't have) or in cases where the process has been saved and the user don't yet completed the event definition. Same happens for the start events that uses the CatchEventPropertyWriter, events like StartConditionalEvent doesn't have outputs. And I believe same reasoning makes sense for the ThrowEventPropertyWriter, there are events like EndNoneEvent or EndTerminateEvent that doesn't have inputs.
typo. 2nd one should be V2
log the exception ?
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
please remove this empty line.
Why?
This should probably be java if (CliLogger.ROOT_LOGGER.isTraceEnabled()) { if(satisfied) { CliLogger.ROOT_LOGGER.accessRequirementSatisfied(toString()); } else { CliLogger.ROOT_LOGGER.accessRequirementNotSatisfied(toString()); } }  The toString() may be expensive.
It turns-out this is not permitted. I now get an IllegalArgumentExcexception, saying high watermark has to be higher than low. I will add a small high watermark buffer, then.
Isn't pattern should be /user(/password|/)?$ ? (add extra $ a the end)
Don't swallow exception here
if getSessionTags print warning - this one should also do so
It's not wrong, but it would be very nice if you could use the logger messages embedded in the _Log_ interface? So here you would have:  log.redisStopping();  Which allows the internationalization team to translate it or redefine the logging level.
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It should only be temporarily turned off to create (or delete) test content.
Be careful when copy paste :). You are printing "bundle started" when stopping also. Another thing is when you have no string manipulations in debug messages, you don't need to check isDebugEnabled(). It is an extra if.
Actually, I'd recommend initializing principals using Collections.singletonList(SimplePrincipal.newInstance(username)). The resulting list is immutable and an efficient implementation.
WithTasksContext
One of our helper classes must/should have a utility method to get a time relative to current time. If not, add one?
The last null is interpreted as a null Flag, not as a null Flag[], and is causing some NPEs in the test suite: <LINK_0>
for consistency with other classes, use Objects.hash()
This should be part of the try-with-resources block.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
should this be 3.5?
pls. use Collections.emptyMap() instead.
entryId is not used, please remove
should the second arg be true here?
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
i'd add "perform"
Don't like catching exception in the constructor. use an init method with @PostConstruct annotation.
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
typo in exception message
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
would be nice to try a few different configs here... like localhost, localhost/, localhost:9999/, localhost:9999, localhost/ .... maybe make the test do foreach(String zk : new String[]{"localhost", "localhost/", etc}
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
Why don't we just set the memory usage with the setGeometry call? It's easy to miss setting the memory usage after setting the geometry.
why not directly constraints.domains().count() == 1 ?
Having users of the method forced to wrap the parameter into Collections.singletonList, I am thinking, why isn't there an overloaded method with , ... BibEntry entry added, which alles Collections.singletonList internally? -- Reasoning: There are more callers than callees, thus make it easy for the callers.
if (TransportMode.HTTP.equals(getTransportMode())
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Can simplify by dealing with the exceptional case first: if (!allowPushOptions) { // Reading push options without a prior setAllowPushOptions(true) // call doesn't make sense. throw new IllegalStateException(); } if (enabledCapabilities == null) { // Push options are not available until receive() has been called. throw new RequestNotYetReadException(); } if (pushOptions == null) { // The client doesn't support push options. Return null to distinguish // this from the case where the client declared support for push // options and sent an empty list of them. return null; } return Collections.unmodifiableList(pushOptions);
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Qualify this.uri
could we print the types here?
have you thought about using the builder pattern to follow the code line in the other projects?
Assertion seems to be missing?
What's the point of adding a copy here?
How about the following to simplify the string construction below: java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME);
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
what is the purpose of this line?
No. Remember what I said about anonymous classes?
Shouldn't appId and SecurityToken values be URL-encoded (or any URL parameters that could potentially contain illegal characters elsewhere in this source file)? I see the default app ID has / and + in them, for example. The appId might be only accidentally working at present.
Move check storage == null inside areSubscribersBehindByMax(). Can you pass a number of blocks that the publisher is ahead of subscribers as a parameter? Currently, it reuses max number of blocks, that in general should include all allocated blocks. In future, back pressure should provide a separate parameter that tells by how many blocks publisher can be ahead. Please also consider renaming areSubscribersBehind to isPublisherAhead.
Shouldn't this be == ?
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
A Repository can be opened through the RepositoryCache or in a standalone way. We cannot change the close method to not close otherwise we will affect the standalone use case. The repository will never be closed because evict will not be called in standalone. I see 2 options here: Repository opened through the repository cache could be wrapped in a class holding the usage counters (useCnt and lastUsed) and overwrite the close method to do the logic done in evict method. The problem with that approach is that wrapping repository in not possible when repository is added to the cache using the register method. For this solution to work, we would need to remove the register method (and break backward compatibility). Another option is when repository are opened through the RepositoryCache, we leak one usage counter(as it was originally implemented) so useCnt=1 would mean that repo is not used but still in cache. In the therminator thread we do: Runnable terminator = new Runnable() { @Override public void run() { try { for (Reference<Repository> ref : cacheMap.values()) { Repository repository = ref.get(); if (repository.useCnt.get() == 1 && (System.currentTimeMillis() - repository.lastUsed.get() > 20000)) { RepositoryCache.unregister(repository); repository.close(); } } } catch (Throwable e) { LOG.error(e.getMessage(), e); } } };
I'd say this will not work in for example this case: - You have a VM on a cluster and pinned to some host - Open the edit VM dialog and change the cluster - The pin to host will stay on the original since the "firstRun" has been called during inicialization phase I'd say a simpler solution would be just to check, if the host you want to be pinned to is present in the list of hosts on this cluster (getModel().getDefaultHosts()). If it is, than continue in this logic. If it is not, set auto assign to true and set the selected item to null.
requireNonNull
I'm assuming this constructor is combining the two maps? If so, didn't we just get the jobCoordinatorZkBasePath from config? Do we need to add it back again?
A sanity check like the one in isFullMajorCompaction() that checks if scope is majc would be nice.
missing @Override declaration.
This is another behavioral change that I don't want to see in an unrelated PR.
To improve, I think .warn is better.
Do not contacte file paths. Use HomeDir.toFile().toPath() and resolve from it.
Sam as in the production code, matching on comp=blocklist seems redundant when matching comp=block?
Copy-paste error? Shouldn't this be "new MergeExample"?
Why is this loop necessary? Don't you just need to click a single element? However, I could be wrong since I'm not 100% sure what is being checked.
where are the exclusive locks, that should prevent taking these locks in case of live storage migration, are taken? neither LiveMigrateDiskCommand nor MoveOrCopyDiskCommand are annotated with @LockIdNameAttribute
You need to remove the client.close() below too since this test class is using @AfterClass for closing client
Feel free to ignore: Do we really want these this there?
Raw type?
this method can be made static
Is there a chance of a NPE? could be getFile() null?
I'm surprised to see this here - it was already removed a while ago. Maybe you're not editing the latest version from develop?
i'd add "perform"
you can use tasksByPriority.entrySet() here
You can use for-each for arrays too, for (String name : names) { !hasEvent(name)
Is ... depends from onTheFly parameter?
inline getInsertIndex and putAtIndex  ++count; int index; if (elements.length < maxSamples) { index = elements.length; } else { index = ThreadLocalRandom.current().nextInt(0, (int) count); } if (index < elements.length) { if (elements.length < maxSamples) { double[] newElements = new double[elements.length + 1]; System.arraycopy(elements, 0, newElements, 0, elements.length); elements = newElements; } elements[index] = element; }
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
this whole method could be a oneLiner: return find(...) != null
Same as above: .getAllOfTypes(new VDSType[] { null });
This looks like a separate fix for some issue (vs. what's in the CHANGES.txt entry), yes? What was the guid check for previously?
What's "c"? Can we unabbreviate it?
Better to return "";.
these trace statements should be removed
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
Can this be private, or is there another use case for default attribute outside the builder's call?
Why using a temporary file for reading the test dataset?
This seems like a good use of ordinal since it's lifetime is expected to match app session.
provider -> buildProvider(provider) -> this::buildProvider
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
this is a little strange. the macro validations for all other params happens inside config.validate. Why not move the check for port inside that method too?
Why did you need to implemente these getSyncObjType and getSyncObjId? Could you explain this a little bit further?
I think that the underlying XMLStream reader has a 'getAttributeValue' method. It receives the namespace and the name of the attribute. If you pass 'null' and the name of the attribute it will return the value of the attribute, which is what we need: <LINK_0>
Since you're already using Guava, consider using [throw Throwables.propagate(ex)](<LINK_0> here instead.
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
That's good to know.
This is breaking the existing conventions about allowing nulls. If we ever receive null inputstream we should throw an error here. To avoid them, we should change the calling site, not these utility methods, which operate under narrow set of constraints. suggestion
debug = Boolean.getBoolean("run.flaky.tests.debug"); does the same thing as what you have here.
The blogsEntry != null check is missing, isn't it?
Guava has Objects.ToStringHelper() to make it nicer.
Let's just fix the OS by default. The default location should be configured by the jclouds *Implicit Location Supplier*. The default hardware is, by default, the smallest one.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Isn't this missing an implementation?
"RuntimeException" I guess this is leftover of copy-pasting from other issue. Please correct here and below.
synchronized block is not needed
default method visibility OK?
We're removing the getActivity() != null check. Is it possible it might cause a problem?
Do you have a test that peeks the next sequence number?
Maybe invoke shutdownNow()?
I think that we should send this event in task action logic Additionally used string constants should be added to task package into appropriate class
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
use {} pattern for LOG statements. for example LOG.info("Starting PYAPEX with {}", StringUtils.join(args,' '));
style nit: we don't use braces around single line blocks
Ok if already stopped? idempotent?
Good note. I think USER_PORTRAIT would be better so it works upside down too
Since earlier commits enhanced serialization to avoid losing multi-types this if can be removed.
I suggest including the uri in the exception message
As mentioned above, why don't we making it a non-static method?
No need for super()
nit: can you put "File connector started" instead?
spaces on empty line
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify (assert) it, then update it to a different value, fetch again and verify the new value.
this.id -> id
Don't really like the return null - maybe throw an exception if no main is defined? Or pretend we have a no-op main method?
<LINK_0>
So... what's the purpose of this...?
IntelliJ IDEA tolds me to remove this unnecessary boxing.
good catch, the missing job name was resulting in quite a few unnamed jobs in the progress view - reported by QE, found out via jstack what it was
Maybe just throw unsupported since this isn't used.
This method doesn't need to return anything. When completed, the connection should be considered 'closed'.
Inside finally?
no public
Exception is never thrown
typo: of -> or
return (splitTime < fTime + fDuration ? new TimeEvent(fEntry, Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fTime)) : null);
A sanity check like the one in isFullMajorCompaction() that checks if scope is majc would be nice.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
I think I'd rather store the instance as a field than to have to loop through the projections with instanceof attempts? You can easily store the EntityInstance during populateWithEntityInstance.
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
oldValue should never be null; otherwise the merge function wouldn't be called. So, just use a putIfAbsent?
method reference
ChannelClosed needs to be added to (though not strictly necessary)
Perhaps a CloudDataNode should have the same support for http2 that AmbryDataNode does, since it corresponds to a VCR which will eventually support http2 transport.
No need to call super() since it currently doesn't extend anything.
I'd rather pass down the auth information to the QueryLifecycle. There's no harm in checking it twice, if it's good enough for Santa Claus then it's good enough for us. Checking it twice should also allow us to get rid of the no-auth path in QueryLifecycle, which would be good. Perhaps a good place to stuff the auth token is the PlannerContext.
I don't think we ever use this method again
t'as besoin du WHERE exists(g.id) ? y'a des groupes sans id ?
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
I'd add a static import for all those UIManager methods to reduce code verbosity.
We might want to add a null check on getActivity() here since the clients of displayNewPage have no idea about Fragment lifecycles.
You could use shortcircuit evaluation to avoid if-else block here:  return node.getChildren().stream().anyMatch(TableWithoutHeaderCheck::isTableHeader) || node.getChildren().stream().filter(child -> !isTable(child)).anyMatch(TableWithoutHeaderCheck::hasHeader);
nit: can we use a Executors.newSingleThreadScheduledExecutor() and .scheduleWithFixedDelay(...) instead? Feel free to ignore, not sure what's the idiomatic way to achieve this.
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
if clusterAdminHost is null, this will get ugly. It should throw not supported exception if clusterAdminHost is not set.
I seem to recall this is not safe. Don't you need to use an iterator to modify the collection while iterating through it?
Can you please remove the non-vm networks from networks? Maybe removeIf would be nice.
not null check would be nice here
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
I think we could have a better abstraction here for the list of possible values for a variable. We could consider this improvement for the next iteration.
This is not the same error message. Frankly, I prefer this one (NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK) since it's more verbose.
Return from method Details at object that you found , and in place check for not null
Better to return "";.
Please change to externalSearch =
do we want to have actual percents? not rates as everything else is in Picard?
public ByteBuffer reset(ByteBuffer input)?
Better not call toList(). That will copy all elements into a list, losing the benefits of lazy loading each page. Not a big deal in the tests, but let's use pagination properly (this also serves as example for users).
response = instead of return?
This adds the caps a second time.
Coding conventions: Let's have the @Override on its own line please
Why exception handling removed ?
defensive copy?
Does it make sense to change this to getInstance(Context c) and merge this with createGlobalInstance?
Please do the List changes in a separate PR. This PR should contain only benchmark changes.
Ok, I see why you want to pass in null. But instead would be better to have a super constructor that takes just class, so if someone calls the other constructor with a null entity instance we can fail fast.
log.info message is too general. When you have multiple bundles this statement may confuse you when trying to troubleshoot OSGi related issues. Instead, your message should ideally be "All required capabilities for web socket service component is available"
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
why not use a constant for that?
The constructors should be package private
That is not necessary anymore as your other PR got merged already.
can we add a message to the result if it is stale request something like result.stale()
I think it should return Array here.
I would suggest using ConverstionPatterns.MAP_REPEATED_NAME here as well.
That can't compile anymore.
to be consistent we should introduce constant for kmodule.xml
why is it necessary super here?
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Please change this to VAR__ACTION__DISABLE
specify array length (based on codecs.size) to optimize. <LINK_0>
style nit: we don't use braces around single line blocks
Restore to original. Also apply to the other similar throws.
It is generally bad form in Java land to modify the fields of another class directly. You should do this via getters and setters. While this introduces boilerplate, it makes for more extensible code: maybe you want to synchronize your setters across threads, maybe you want to cache computations and invalidate them when a setter is called, etc. Most importantly, this is convention: readers of code will not expect for class field mutations to occur outside of that class, and not look for it when they are trying to understand the code.
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
This should be removed - it's absolutely fine for entity data to be empty. It's only during serialization to native format that it should not be empty (ie adding the EntityType field)
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
See if you can change things like this to just return "Invalid response";
public?
> DRONE_TARGET_DIRECTORY it means that the last update cache is stored in the target directory, right? I'm not sure if it is a good approach as every new run of the test suite will require a new request - I had expected it in the ~/.arquillian/drone directory. On the other hand, I have to agree that the probability that you would run out of the limited number of request is very low.... Why you've decided to put it into the target directory?
Should check that the environmentTracker is not null
Remove timer.
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
Make this private and implement a builder?
needs filling in :)
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
can be simplified to  java EnvInjectPluginConfiguration.all().get(EnvInjectPluginConfiguration.class)
Here as well, I think the two calls to this method can supply an element id.
Any pointers why don't we just throw recreate() exceptions as is? Looks like all other places don't care about exception wrapping
we probably don't want return true here, also log message is misleading and maybe we should distinct scenario with stale message from no topic info
suggestion this.dataStoreMap = new IdentityHashMap<>();
how about:  if (Types.getRawType(type).equals(Optional.class)) { if (response.status() == 204) { return Optional.absent(); } else { return Optional.of(delegate.decode(response, getInnerType(type))); } } else { return delegate.decode(response, type); }
Should we log the potential error?
Please place a space b/t if and (. if (variable == null) Please check others as well.
getparentDiagram() will be null.. you have to set the container before calling the method.
Shouldn't the return type be int?
Please remove the protected keyword because this class will never be subclassed.
The one-argument constructor can just be called here instead: this(true)
I am not following here - why do we want this in sync block?
Just remove the try/catch. An exception will fail the test.
Can you move this out of the method and make it private static final char ZIP_SEPARATOR = '/'?
There's no reason to use a mocked File here. If you want to create a file for test and not worry about clean up etc you can use [createTempFile](<LINK_0>,%20java.lang.String,%20java.io.File)).
Can I suggest the following to be more consistent with the other code in this file? It's more or less equivalent to what you have: java return File.createTempFile("swarm-client", ".pid", temporaryFolder.getRoot());  Since this uses a different name each time it's invoked, we'd need to pull it out into a local variable within each test, to be passed to each Swarm client we create.
This directory should probably be defined in a common place so if we want to move it to another location it is a single update
delete
let's do it using lambda approach
use existing constant
I don't see where we handle HibernernateException.
This can lead to NPE, better to swap the check.
How about removing the whole cluster deleteRecursively("/CLUSTER_NAME")?
We should return true here to ensure the menu is displayed.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
Camel can do this automatic in the setProperties(configuration, parameters) you do further below. If you want to set default values then set them on the configuration class instead
Make this protected (and in the @Overriden)
similar issue here. remove validation in client
that seems a wrong junit exception usage. test shouldn't suppress exceptions, it need only configure exception (that is Rule).
It should be this class' responsibility to register listener to AmbryStorageQuotaService. Instead of returning Listener objects, this class should create the object and AmbryStorageQuotaService.registerListener(listener). This will make things simple, as the only responsibility of AmbryStorageQuotaService will be to called listener that are registered by consumers. Also the AmbryStorageQuotaEnforcer doesn't need to do anything if it doesn't want to listen.
I think you should check that this is non-owner connection, don't you?
we probably better to make another MavenArtifactUtils method for this.
You are using Toaster everywhere in this class except for this message. For the sake of consistency, use the same class here as well.
Ah, OK, that would be clearer.
I think the most likely case is that fboName is not the default frame buffer. But it's a very minor issue, so let's leave it as it is.
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
These checks would work better in PartitionHandlingConfigurationBuilder.validate(), logging warnings if the merge policy is ignored. Although I'm not sure the numOwners > 1 check is really needed...
latest from today's discussion: return URL
I would recommend an else if here to avoid comparing against a string unnecessarily.
You could maybe use enclosingClass to save a few hops...
Oh yuck. ;)
you could have this all in one line
This is not a good convention. How about changing internalNext() to be able to return null to indicate there's no more elements?
One more empty catch(){}.
Perhaps a CloudDataNode should have the same support for http2 that AmbryDataNode does, since it corresponds to a VCR which will eventually support http2 transport.
is this toConfigurer needed as a variable?
Would it be better if we add a logic to check whether the actionMode is null or not to prevent resetting the state of toggled items? if (actionMode == null) { beginRemoveLanguageMode(); }
Minor nit : Can we have uniform naming for similar methods? This one should be updateExportedFeedInstance...
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
I don't quite understand why this call is needed. If LazyBlocks are not loaded, the data is not read, hence no stats to update.
I think the SystemReader should server this cache instance. With two static instances, there is a brief interval in which this cache instance will be the old one while the SystemReader instance will already be the new one. Might be simpler if the two methods getSystemConfig() and getUserConfig() were on SystemReader, without this separate class.
This needs to return a completable future, not null
I think its better to if (isCopyPerms()) { execInTX -> save quota copy perms } else { save quota } and remove the check for isCopy... in copyQuota method
new AcceptAllValidator<String>()
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
please decrease log level to trace or better remove statement
Add message to new RuntimeException
SymbolReference is an issue
"This method is not actually very useful and will likely be deprecated in the future."
put method contents into private method with WebElement parameter
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
This one needs to have context so you will need to have a method that takes an Integer object and a Character object.
why do you call this? It will be called anyway by default.
Maybe we can compare the 2 images to check that this is the correct one?
It seems strange to deactivat errorCatch here ...
Instead of removing "bbbb" which is the longest element so won't have trailing spaces, try removing "a" or "c" as it's a better test.
I continue to think that **aifc** should to be here...
do we need to synchronize on 'this' or can we have a lock?
requireNonNull
If we catch all exception here we should at least log something otherwise it will be hard to find the issue if there is a bug.
Why do we return the parents name instead of the name we store a few lines above?
Should this be Block?
suggestion if (DEBUG) Log.d(TAG, "savePlaybackState() called");
nit: either use this. for both assignments here, or for neither of them. Consistency is good :)
(purity alert) This two can be written inline
I think the setMaterializableResourceProperty should handle the materialized scenario itself. This means that this method can simply invoke setMaterializableResourceProperty(ACCOUNT,account); and then, the internal code of setMaterializableResourceProperty will check whether the account is materialized or not and then will relay on setResourceProperty(ACCOUNT,account); internally.
None of this stuff is atomic.
Can summarise to two lines: java WebElement sessionRow = waitForElementPresence(By.id("session" + getEvaluationRowId(courseId, evalName))); verifyElementContainsElement(sessionRow, By.className("session-resend-published-email-for-test"));
It doesn't feel right. Why it is required?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
The result variable should named as result
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
possible NPE
I think your change works. Great. But there are optimisations I would suggest. If you have the array files in hand you have already all information in hand to detect orphans. No need to do again the expensive filesystem calls (the .exists() calls) in the isOrphan method. I would: - I would use the DirectoryStream with a filter for .pack,.index,.bitmap files as Matthias suggested - I would sort the stream to ensure packs come directly before corresponding bitmap/index files. Then it is easy to detect orphan index,bitmap files (if they don't follow directly a corresponding .pack file)
Same argument as with the DeadlineJob.
That's not very clear: if doResolve does return null, it most likely means that the CodeMining doesn't require resolution, so isResolved should be true. The implementation seems erroneous here. This may be caused by resolveFuture == null which can mean 2 different things: either the future wasn't requested yet, or the future was requested and null was returned (ie no resolution required). I believe you need some more details or another state variable in the class to distinguish both cases.
Can we change this line to this(0) and remove the if (port == -1) in the other constructor?
I think it would be enough to check if affectedKeys is not empty, either on the originator or on the owner. After all, the invalidation will be done only if there are requestors for a certain key, and that will only happen on the owners. But that still sounds a bit expensive, couldn't we use the same L1WriteSynchronizer approach as for non-tx caches and invalidate only from the primary owner instead?
It may causes two consecutive calls of onTracksChanged due to MediaPlayer L3008 in the same patch set.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Not sure if you noticed, but you can use a different notation here: suggestion return Optional.of(path).filter(Files::exists);
This test probably doesn't do what you think it does, because it verifies that EXT_ID matches with itself. (Same with several of the subsequent tests.)
you could just do setConfirmWindow(null); like above method
Make this java fail("expected exception");
java if (mapperReference.isUsed() ) { mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ) }
What is the need to make issueArticles nullable? It would be easier to understand this view class if we required it. If that's totally impractical, we should consider having a separate view class to capture the difference.
... && tableName.getTableName().length() > PARTITIONS_TABLE_SUFFIX.length() ?
Spelling
return HConstants.EMPTY_BYTE_ARRAY; ?
You don't need this line because of green 31.
are these setters used anywhere?
Can you elaborate when long type can be nullable?
This method could be static since it does not depend on any local state. Same for hasCoordinatorMoved.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
you can use method getUrlForWiki (so you don't need to add empty string for article path)
nit: we don't usually use final on method. (Also, as a side note: we don't use final for tmp variables)
We can remove the unnecessary AnalyticsTracker qualification from AnalyticsTracker.Stat.QUICK_START_REQUEST_NEGATIVE_TAPPED to produce AnalyticsTracker.track(Stat.QUICK_START_REQUEST_NEGATIVE_TAPPED); for simplicity.
Filters are processed in the order of the filter-mapping definitions. I gave this a try and moved the new filter-mapping to be the last one:  HTTP/1.1 200 OK Date: Mon, 09 Sep 2019 17:23:30 GMT X-Frame-Options: SAMEORIGIN Content-Type: text/html;charset=utf-8 Set-Cookie: JSESSIONID=node0w4cziqnkjair1gkn4ojtsquwi78.node0;Path=/opennms Expires: Thu, 01 Jan 1970 00:00:00 GMT Cache-Control: no-cache Content-Length: 5519 Server: Jetty(9.4.18.v20190429)
This array must be calculated one time only
Use isZKLogAvailable() instead
iirc it's initialized in the ctor, check that it's not empty .
Same - icsCode >= 1
lambda: () -> {}
This will throw redundancy warnings in IntelliJ
Use fluent interface in here
Better to return "";.
Why we update our code with AND while the test case sql is with OR, i kind of confused.
checkNotNull(value, "value")
Can you call CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, symbol) instead?
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
feedback session's course ID -> feedback question?
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
==
Should this be represented as a Duration?
Will need to unregister()
It's not flexible enough. So when you will need to add another requestCode, you will need to add another else if, which isn't a good practice.
A flip != 180 rotation
I believe this should be typeList.size() != 1, isn't it?
Replace imgur.com
Do we want the toString()= in here ?
An empty message is OK.
This constructor should call the more general one with a default value (3 in this case)
I would suggest to use the vector's getter methods to get the entryX and the entryY properties.
You need to check in the set\* methods that the custom attribute name doesn't clash with a common attribute name to prevent users from producing invalid XML. Throw an IllegalArgumentException if so.
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
You should externalize the string
Here it's used only once so it doesn't really matter, but you could have static defines for those, like private static final double NANOSECONDS_IN_SECONDS = ... would also prevent easy mistakes like one zero too many
Use EnumDyeColor.byDyeDamage(stack.getMetadata()) - that's what ItemDye uses. This should fix what @Aaron1011 mentioned
Enforce immutability
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_0>
No, this. when you call methods.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
I would change the text to say "The encryption algorithm is not strong enough."
Looks good to me. Can we do something to identify other occurrences of this issue?
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
why static?
If I understand correctly, the purpose of the patch is to fix a specific problem - failure of migration because of 'refreshCaps' failure to take a lock. It is enough to take a waiting lock inside the ActivateDeactivateVmIntefaceCommand before calling the refresh, instead of locking the host for the whole migration period. You can pass 'lockProperties.withScope(Scope.Execution).withWait(true)' as the 'lockProperties' of the parameters you pass to 'RefreshHost' (the 'RefreshHost' should pass it the 'RefreshCaps').
ah, I forgot that the primary key components are part of system.schema_columnfamilies, not columns, so that wasn't a problem.
How can this test succeed since ACCOUNT_METADATA_PREFIX has mixed-case characters?
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
you should have here setSucceeded(true) IIRC.
Use the set in the class variable directly.
Won't fix.
do we need to use static on this private method? Please update javac doc
suggestion assertThat(got).contains("Description");
FutureUtils.assertNoException missing
These asserts are not testing anything related to the webservices.rest module, they're just calling Obs.getGroupMembers(). You should be doing resource.getGroupMembers(resource.getByUniqueId("..."))
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
avoid having local variable names that have the same name as class variables
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
As you already need to touch this file, I think this empty line could be removed.
you're testing binary branching, i.e. an if. A switch is meant for more branches. java's switch can be linear or can sometimes binary search or a lookup table. Javaslang's is always linear. Please test them properly.
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
inline permissions and then remove redundant this
Please add a check here that would simply return if the color being set is the same as the current foreground color (linkColor).
Similar to the other tests, assert that a feedback response with ID "randomNonExistId" doesn't exist.
same thing, while you are cleaning, other thread could store other key.
As far as I understand, we can get rid of explicit type parameters is such calls
I am not following here - why do we want this in sync block?
Given we're removing the only reference to the presenter.moveDown and the presenter.moveUp, it's important to remove these methods in the presenter as well and the related to code, to finish the clean up.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
Please, reuse your extracted method for checking if a file is an Erlang source file.
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
Based on how it's used, it's more like a listener not callback.
If the first orchestrator throws an exception when closing, the second one will never get closed. Please use a closer instead; see org.hibernate.search.backend.elasticsearch.impl.ElasticsearchBackendImpl#close for an example.
My bad, I meant to say: "to be able to **change** the page source". I will improve this exception message.
@idelcano What is going on here? Take a look at these lines. Too crazy to merge it :)
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
For safety and future-proofing it might be worth including the set of potential answers as a list or enumeration in this class (or elsewhere) and using a count of that set. This seems like invisible/loose coupling to a concept that won't necessarily be clear when updated elsewhere.
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To save changes you need 'Push' rights on " + REF_CONFIG"."
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
Maybe 'cluster.hasRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
Please remove " to access OpenHab"
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
Why can't you just return this.workingDirectory ?
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
Check error code/description
What's the point of adding a copy here?
setErrorMessage
catch IOException and rethrow to avoid wrapping an IOException with an IOException
you are calling stream.addLivePacketListener on the onStreamCreate but not removing it on onStremDestroy.
StringUtils.isBlank() ? Maybe it is an edge case, but the existing logic is not specific about what can be passed to this field (null, bogus blank strings, etc.). So being more protective would not hurt
This implementation is not transitive. null elements should either be ordered first or last.
why do you want to whitelist it at the end?
Since the project already introduced the ValidationResultMatchers class for validity assertion, wouldn't the following will be preferred ? assertThat(result, isValid());
And this one is good, too.
Maybe legacy version of SetDigest can not be cast to HyperLogLog
Nit: "Creating ephemeral nodes..."
Indeed, that is better than my suggestion. Let's do this.
Don't you think there's a need to add a constructor with final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier
Please use CommonUtils.loadResource(). It allows overriding config files by placing them into /etc/sw360
Remove the public modifier.
wait.forElementClickable() should be used before
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
Why not setLocalEditorStatusChangeHandlersEnabled?
@ivandalbosco No need to change order if we don't rely on visitor for finding "try"
Remove this
Debug leftovers? ;-)
Is this parameters really mandatory? I thought its default was false.
Restore visibility of methods in this class to package level when unit tests are moved to jaggr-core
If possible import the model type and use the fully qualified name of the backend type.
This test is wrong, check that the expected exception gets thrown using the expected attribute of the @Test annotation
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
Add Preconditions.checkArgument checks to verify that the passed buffer is not null and that sessionProposedCapacity is greater than zero.
Can we roll this into the parseJobId method and maybe rename that to reflect its purpose of creating a manager from config along with the attribute that its keyed on? E.g. getManagerFor... or getManagerFrom...
Since you log the whole object you can change ending to deleted for {}., since attributes toString() is like Attribute:[content].
No, this. when you call methods.
Integer.parseInt
Good plan.
instead of e -> e there is a Functions.identity()
If we return inside the case clause, we can get rid of the res temporary variable, the breaks and the last return line. switch(format) { case LEGACY: return renderLegacySize(size.longValue()); ... default: throw ... }
Is it possible, that the context is null?
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
Do you think this is non-useful? I figured there would be cases where people would want to test code that behaves differently if the SDK claims to be something really old that we'll never fully emulate.
can it be made in one line?
I'm not sure it's safe to change between fake and non-fake sequences. I'm having trouble working through it in my mind.
java this.onPostServerTick(this.getMinecraftServerInstance());
Consider using == maybe?
I have the feeling that we should be careful and also check for interfaces and annotations (Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE, as both of them are ClassTrees). It would however be pure defensive programming, because I can not manage to write a compiling example.
This also regresses in that it no longer works for multiple repositories.
it cannot be a constant: it needs to be a variable (like timeout) so that it can be changed per test / per class and eventually adapted for EE
@fanifieiev the same above.
Any reason this can't always be used?
Is this intentional? You are forcing the value to 'true' Maybe a simple assignment is clearer
java.lang only required here
should this count be parameterized?
Sorry wrong patch, will fix these
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Logging.
This drops the packet. This shouldn't happen just because it doesn't have the extension. I'd expect the wrapper to handle this logic.
Are you trying to print the set of ids or just the size of the set? (The header doesn't match.)
Can this be private, or is there another use case for default attribute outside the builder's call?
This will return all revisions for a single ID, use RevisionSearcher.search(...) instead of the raw searcher. Also you can use the already opened RevisionSearcher instance via context.service(RevisionSearcher.class).
raiseDiskEvent sounds like an exception. should be something else (the name)
scaledData, thread safety and all
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
what's the intent of this change?
in some cases lhs/rhs could be null, pls do the null checks appropriately
Move to constructor? We already do a defensive copy might as well front-load this work instead.
Was this detected by findbugs?
scheduleTimes --> scheduleTime
rename tempVar
Shouldn't we rather throw UnsupportedOperationException() in this case? Or rather create interface without the support and extend it with interface with these methods?
Extra trailing comma.
addPermissions means you added a permission, but it doesn't mean that no restart is needed... unless I'm missing something here.
cat > \"" + filepath + "\" ... would be preferable to handle paths with spaces.
this removes the entire failure path of the test: The assertion that appending to a nonexistent file raises an error. Why did you make this change?
Don't check these in.
This method looks horrible to me (and to whoever is a sane engineer, I should think).
If position() gives anything other than 0 then this will give a LimitReachedException won't it? Did you not mean capacity - position?
suggestion return Integer.compare(this.score, o.score);
consider saving the value of group 1 and group 2 here rather than the whole matcher
Try using StringUtils.isTruthy(this.path)? <LINK_0>
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Same as above for toString(): <LINK_0>
Please use the full test class name for the controller thread, it's better for log filtering. Also, some local variables would help keep the code to the left.
Move to run() method.
Why do we not use  java final Object[] array = new Object[length];  ?
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Why 2? default-max-chars.csv has a single line so it should have a single set of arguments?
Here you use Double.toString() where a bit lower, line 63, you use ..Factory.convert(..) - might be better to unify.
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
add block
public?
if implementations is empty, this method will eventually return an empty (immutable) collection. We should throw an UnavailableImplementationException instead to indicate an invalid state or spi class.
Wouldn't it be better to wrap and throw as a RuntimeException instead of suppressing with a log message?
Sorry! I meant we don't need to pass the options in!
Not related to the changes from this PR, but now that the ValidatorFactoryImpl is cleaner, I noticed that there are some getter methods that are not coming from any interfaces. Like for example isFailFast(), isTraversableResolverResultCacheEnabled(), getExecutableParameterNameProvider() and maybe others. Hence I wonder if we shouldn't pull then to HibernateValidatorFactory ?
Null pointer...
Could change the return type on method to Collection
this method should be explicit about the encoding that the resource will be decoded as. ( utf-8? ) or the system default? I worry about internationalization issues with this method. we should force utf-8 (unless for some reason we don't want to do that?)
use constants
why public? Are we planning to use it outside of this class?
I think we should putAll() the defaults - a common java developer error is to use get() instead of getProperty() on a Properties object. Only getProperty() looks for the defaults if not found.
Again, logging of passwords might not be what we want
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
What are we doing with e.toString()? Should this be logged?
Not sure there are cases where we want this, but having this overloaded constructor prevents one from using a single argument that would contain spaces. Given the use that is done of this class, I would drop this constructor
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
Shouldn't be a separate config, there's already a fetchThreshold Samza config.
Multiple method(*) methods
The field should be removed as well.
Very helpful
please use a static import for assertNull
nit: could you please perform the release calls in a finally block so the ByteBufs get released even if the assert fails?
I think you need to do separate request to the db to retrieve all cars of this person
getNodeEnd() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails.
this should match with the place token
None of this stuff is atomic.
The super() returns "" on null. Why should we differ?
Why not using entity manager factory to get the metamodel?
Formatting issue
Please externalize these strings.
No need to use ConcurrentMap.
These 2 conditions can be merged into 1 condition
You should be able to use the diamond operator here, i.e. new ArrayList<>()
please create a more specific exception that extends this one.
![MAJOR](<LINK_1> Rename this method name to match the regular expression '^[a-z][a-zA-Z0-9]*$'. [![rule](<LINK_2>](<LINK_0>
There is a double ? sign here
Can be the className null? If not I would maybe rewrite as [1], what do you think? My point is to not nesting expression into try catch, if an exception can not be thrown. [1] java if (ScenarioSimulationSharedUtils.isMap(className)) { return new HashMap(); } else if (SIMPLE_TYPES_LIST.contains(className)) { return null; } else { try { return classLoader.loadClass(className).newInstance(); } catch (Exception e) { throw new IllegalArgumentException("Impossible to instantiate " + className, e); } }
Please, add { and } to the if statement. if (dialog.open() == Window.OK) { ICommand cmd = wizard.getCommand(); //command execution ? } Modifiy the inheritance of the action and add the command execution
You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure
I think in this case we need to init the repo with a url with a slash on the end.
How about introducing EventClass.emptySet() so that it's easier to find places where return empty sets?
If you use a concurrent map you can use: attestationValues.putIfAbsent(value.getHostName(), value);
default method visibility OK?
Consider to replace with "an allowed command".
Missing call to super implementation of onResumeFragments()
I don't think you want to use RealSystem() here; doesn't that really call System.exit()?
this is a query metric I think the metric should be "query/jetty/numOpenConnections"
Why the NetworkAttachmentRowMapper has to be created new, instead of using the old one?
return asyncHttpClientMap.remove(name) != null
Not sure if you wanted to leave this hardcoded?
@fchauveau there is no null handling of source, is this intended ?
Isn't this check done by JNI?
I see you"ve moved 'reportsWebappDeployed' but what about 'retryCount > MAX_RETRY_COUNTS'?
Shouldn't this be wrapped in a try... finally block?
Let's have constructors one near another
Need to add spaces after if, before and after < and after ). Please follow existing code style.
rm
Based on the invocations this method seems to represent a memory footprint related to the column chunk. So, bloom filters should not be counted here either.
I am curious couldn't we just test this by default given that all schemas need to be present in "schema/" directory. we could just load all of them and based on what schema xml reference test that by default. Overriding is still fine for all corner cases but by default it shouldn't be needed.
I think we need file with version 1.4. inside.
Please remove
Can't this NPE as they're Booleans (i.e. objects not primitives)
If we always return 0 or 1 element, would Optional<String> be a better return API? In that case there would not be any confusion that we can have more than one element and it'd be clear we'd have either zero or one.
This line is 128 chars long... this is not compliant to our coding conventions.
this doesn't seem to survive a workspace restart. I'm prompted to allow certificates after I restart eclipse.
should check results here, not just size
This should be ofNullable, right?
Should this also handle the suffix 'es'?
replacing this with helper method would be great
Again, use IOUtils.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I get a NPE here, processModel.tradeManager is null.
We should leave these as assertEquals and just add the MariaDB check since we are not making the global change to assertj on 2.1.x
Same here. Add clarifying parenthesis
i'd mention the actual action used for that.
Could specific exception be used here?
I guess we no longer need store to be of ConcurrentHashMap implementation if we are fully locking it.
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
Missing earlyMessageRejectionPeriod
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
isMatrix()? Also what about the row vector case? I've ran in to bugs in the past with subiRowVector being applied to row vector. May want to make this explicit.
it should be cleanup, no ?
Nit: not needed
Should be size != -1 since -1 is an explicit value. If someone passes a negative value then the behavior is undefined (which is fine).
We might want to add a null check on getActivity() here since the clients of displayNewPage have no idea about Fragment lifecycles.
minor: some of the variables that use this are long and some are Long. I think long will be good everywhere? (since this cannot be null)
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
May as well just return the result of resourceFactory.getResource(..), no?
If we change the default value of getValueAsString we should change this one too.
Is this signum call really needed here? compareTo should already return the correct value.
Preconditions.checkArgument() would be better form.
This method can be static, as all the methods it calls.
You can use StringUtils from the commons.lang3?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Restore the spaces.
this could be Lists.newArrayList(deviceId);
why not delegate.getSystemMemoryUsage()?
I would suggest calling getAmqpPort() here (and in other get*Url methods) to avoid a duplication of this code
Same question
I think try with resources should be used.
nit: this should be "f"
No need to catch the exception here, it was already done in the overload.
rename to breakpointRequest
I think it would be enough to check if affectedKeys is not empty, either on the originator or on the owner. After all, the invalidation will be done only if there are requestors for a certain key, and that will only happen on the owners. But that still sounds a bit expensive, couldn't we use the same L1WriteSynchronizer approach as for non-tx caches and invalidate only from the primary owner instead?
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
I lost track of changes :D. Adjust as needed depending on whether the setUpDefaultPanel has to lose the arg or not.
Wrong log message stating about geronimo which is removed in this PR.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
I just wonder how it may work, because you don't specify the username when you trigger the build... If the check below works, then something is wrong with the matcher
TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every wrap?
other than the previous implementation in subclasses this doesn't create the directory anymore.
Just log in debug the cause of this error. Just in case. I guess it could contribute to the sysadmin.
Fix aliases = aliases = ...
use getAllCount() instead of 5
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
What if this path actually exists on the user's workstation?
Take care! arg.get().toString(). Otherwise you're passing the Optional object.
Asserting inside the sub-thread won't fail the test. Should probably refactor.
this method deserves a description
could we solve this better by overriding send() in the TracingActor? I'd like if all this trace and replay code would be in that class.
Avoid "System.out.println" and replace by a logger if needed
Should this be "shouldReturnEmptyString" instead? If so, there are also a few more occurrences of "shouldBeEmptyString" that will need to be edited.
Hehe, this is exactly the pitfall I pointed out :D If currentTimeMillis + timeout is actuall greater than Long.MAX_VALUE, you will get a overflow and the sum will become negative. Instead you should probably test, if Long.MAX_VALUE - currentTimeMillis() < timeout and if so, throw an error.
The ID is used to restore old files (from an older release) so this must not be changed!
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Use a list to access at index
len is unnecessary variable name
Not really a fan of the null-oriented programming here. Would prefer caller check hasNext and we throw an exception here. However, I'm not sure what would be better.
use keyword "this" in these methods before member names.
if I understand correctly, this will be evaluated first, but if networkIsSet is not valid, it won't be reported. Because of that, I'd rename 'validateRemoveExternalNetwork' so that it provides information that this is provider validation, and then inline this variable. That way this will be evaluated only when preceding validations #115-#119 succeeded.
generated -> generate
There's no concatDeep, I guess..? ;-)
let's use LinkedHashMap
I think it's more neater to not write extra lifespan/maxIdle parameters, but instead to write them where you write lifespan/maxIdle already and just add the possibility to send a new option which defines the granularity of lifespan/maxIdle. Your current solution feels akward since you're adding two new fields and the existing ones are not used. IOW, just add one more flag to the flags parameter here and you're done on the client :)
I don't know, but isn't the class also of interest?
Can this return a List<JsonPatchOperation> instead?
@sebing please put spaces around :
do we want eventually to have a writeTo(ByteBuffer) ?
this class doesn't have tests?
no need for if as 1 - 1 gives 0 to add to cpuCost
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
we can do away with the local variable here @rishabh-997
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
Risk of duplicate transactionId. Resolution of currentTimeMillis is very low.
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
this will generate a lot of log messages if printed every 5ms. We should increase sleep time to a few hundred ms and maybe move this to trace / debug level?
false is the default so you don't have to set it explictly
Interesting approach. I guess I'd have tried to use qualifiers or the CDI alternative mechanism, but this seems the simplest.
static
Log the full exception
Don't put this, it's a "real" warning atm, until we get rid of it ;)
do we want eventually to have a writeTo(ByteBuffer) ?
@AlexDBlack is this normal for transforms? Have we changed anything in the data vec transforms you can think of?
It's a not a big deal, but shouldn't we throw a TechnicalException instead?
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
instead of just putting e.getMessage() as part of the new exception message, I think you should pass the entire e as the second parameter to the constructor of IllegalArgumentException.
This is a clear programming error, right? If so, suggest throwing NPE instead.
Replace 0 with filters.size().
nit: simpler way: use noneMatch instead of ! + anyMatch. btw, it's better we can also update the matches method of PushFilterIntoTableSourceScanRule
is everything in this block (inside this if) not the same as the superclass' behavior? If so please replace with super. getSuiteFilter(klass)
It is shadow copy technically, but all fields are immutable (so there won't be any issue to directly use these fields).
don't think we need to put the pair in the message twice, right after each other. Invalid syntax for key-value pair: %s. It is expected to be...
onLowMemory is public, not protected
Static import the assertTrue?
Please throw exception if ! nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN, please throw UnsupportedOperationException. If ! nameLookupPossibleInAdvance(), but getValueCardinality() returns something non-negative, the code in the hot loop could be optimized, idForNull could be assigned as soon as selector.lookupName(index) returns null for the first time.
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
| size > 0?
This cannot be null. Guice won't allow the constructor to be called if the reCache arguement is null, as the argument is not marked with @Nullable. Or is this null because of unit tests? If that is the case I would prefer to define a mock cache in the unit test since at runtime we always have the cache.
Rebase error - should be used Helper.getCurrentUser.
I think this should be: java setCursor(Cursor.getPredefinedCursor(DEFAULT_CURSOR));
last argument needs to be ImmutableSpongeFlyingData.class.
I would suggest answer.toLowerCase() to make secret answer validation case insensitive.
If the configuration has been set to false and this configuration is removed again, the default value should be used. The current implementation uses the default / true on restart but not if it gets modified. If I am correct you should perhaps use: <code>autoLinks = value == null || !value.toString().equals("false");</code>
Take a look at <LINK_0>
return StatUtils. sum(toDoubleArray(colName)) directly?
delegate can be null. I'd copy the pattern of the code in the other methods like isOverutilized
Shouldn't be more like return getConfig(STACK_DEFINITION_URLS); ? this is always different than null as you call this method, and getConfig(STACK_DEFINITION_URLS) is set with a default empty list.
instead of building loadService in the constructor just a create MutableSupplier (see code in the ltr plugin). Make your QueryBuilders accepts Supplier<LoadService> and call the set method in createComponents when you have everything needed to build your service class. That's not particularly better but it allows to keep dependent services final in your class.
once again, equals/hashcode - does it make sense? please revisit in all value types you created
As Ryan mentioned, you may not want to implement locks like this on static methods. I'm guessing he is checking mappers for null in order to instantiate them only once, as well as set their SimpleDateFormat. Someone else can chime in, but one easy and simple way, while keeping the methods static, is to implement the default constructor with no arguments, then call a new static void method from the constructor called something like setMappers(). Inside setMappers() is where you would instantiate the mapper1 and mapper2 ObjectMapper instances. Then you can get rid of the null checks on the mappers, and instead just return them from their respective static get() methods.
This section of code has <LINK_0> bug. Which is fixed as part of environments API v2 <LINK_1> PR.
You can inline this variable.
should the message include "command _with options_:" + this.options ?
is it better to use name instead of null?
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
Is it safe to set limit for buffer here? I'm not sure. Suggest to get a read-only buffer.
Why can't the implementation of this method be pulled up here?
Make the spHandle human-readable.
Nit: use ImmutableMap.Builder, it's easier to read and modify, as there is no special case for the last item. I only use of() if there is one item. Same goes for the rest of this class (except the usages with exactly one item).
if you want to make this threadsafe synchronize this copy on fValues. synchronized(fValues){return new ArrayList<>(fValues.keySet());}
What do you think about Comparator.naturalOrder() instead of null ?
You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
Could you please use TextUtils#isBlank here instead of "".equals(s)?
Please make this package protected, to avoid the expensive synthetic accessor.
Preferably have one call the other?
I think it would be more correct to mock the DAO to return null.
this will throw timeout if infobox is not visible. use wait.forElementPresent() instead, but you will have to create By variable from that selector
I don't think it should be renamed
It doesn't right to me to always set a specific result when leaving the PreferencesActivity. This could happen in the UserInterfacePreferences fragment when the font size itself changes. You can call set result on a Fragment's host Activity by calling getActivity(). It would also be nice to write a test for the Fragement (probably using Robolectric) to check that it sets the result on it's parent Activity.
Could you please clarify the reason of this change?
same here, remove TooManyLinesInFunctionCheck
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
Is that safe to call when not holding it?
Why remove the timeouts?
These might look a bit tidier as static imports
The methods in here will need to use client.couchDbClient.get(...) etc otherwise these will break when it merges to master because of #133
remove this as this is already done in base class
Can you please use the key aMHOf2rfzUt3fuKkb7DXX8pkBv1AmcBWwwoSfwpt8CMhdUdxXscB4ESOmBPs4NlmYJmFtcSZ3Q5kMxzb. This is a sandbox key that should work (for the build server and for local testing)
I'm a bit perplexed: "dynamicStrict" does not match any field name... I wonder why this works. Anyway... Maybe there should be two different bridges here? It feels a bit strange that the name parameter in configureFieldMetadata is ignored. Same as before: I agree it can work as is, but it's more in case someone copy/pastes this code.
save an iterator by using index loop?
Exception Message like logs shouldn't be internationalize just use // NLS....
This could be a bit tighter as I think it should be called with account-id and the mockSecurityContext could be made to return known values for the api key and method that could be checked too? That might help assure that the correct values are being taken from the security context?
No biggie, but I guess best practice would be to do this(Arrays.asList(columnNames));
This should be in.readBundle(getClass().getClassLoader()) to make the build pass. Since we're just passing in strings right now we don't actually need this, but it'll ensure we're future proof (and make lint happy).
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
Please use getCurrencyBaseLowerCase() and getCurrencyCounterLowerCase() on checkerInfo
Should use Long.class
ImmutableList.of()
it wasn't handled before, but I would also add something like: if(lastColon == -1) { throw new IllegalArgumentException('Invalid endpoint format. Required format is<ip>:<port>.') }
repeated twice
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
@Iprogrammerr Please use IsEquals from hamcrest in these two assertions
dont think a setter type function should return the "this"
@m-g-sonar if the folder creation fails the test will pass.
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
Item dropped should be a hopper
is it sufficient to have this c'tor package private?
Collections.unmodifableList()?
variable named abstractFile does not exist, which prevents pr from building
Is this stream getting closed? Add it to try block just in case: try(InputStream s = minioClient.getObject(m.group("bucket"), m.group("path"))) {
Better use Double.isNaN(double) here. Reads better, IMHO.
It should be new TajoRuntimeException(new InvalidCastException(...).
Fwiw, this "checkNotNull" isn't really testing the validity of the value, just that it's non-null.
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
Use Assert.assertEquals
Why removing failure? It is the failure reason.
Same: performance will tank. Need a small reusable byte[] as instance field. This should be OK, since these methods are already not thread-safe.
These will all break if A or B is null. Recommend using the autogenerated intellij equals + hashcode unless you have a good reason not to
Preconditions.checkArgument() on all non-null arguments to prevent bad config
Call setFocus() on the table control.
Typo: initCardModeButtons()
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
I guess you mean to pass kryo, not to create another Kryo.
This is wrong. getFullPath returns the workspace path (e.g. /org.eclipse.egit.ui/plugin.xml). It should use getLocation(), which returns the file system path.
trace
This will throw MigrationNotFoundException so no need to check it for null.
getServicePolicy shouldn't ever return null. Based on how the Python SDK functions we return a policy object every time. In the case that it is in fact empty ({"factors": [], "minimum_requirements": []}), we return a policy with all the minimum_factors set to false or 0.
But existing rows use null not "" for the parentUuid.
Use isZKLogAvailable() instead
Do we want to use the LOGGER as well? There are other usages in this class where we're using both.
Again, probably out of scope for this PR, but I don't think these andReturn() statements are needed.
I am not sure, but we tend to use the returning values of such methods as plain Lists and then eventually wrap them into ImmutableLists over and over again. So if we can declare the ImmutableList as a type of the returning value, I would do so.
Global listener catch each click. You don't need to log it.
I want to method accessor to be package private :eyes:
Can you add the curly brackets to the if calls.
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this switch case number of lines from 10 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
Maybe [] instead of null in order to avoid NPE or check?
Same question about unit conversion as earlier.
I don't think you want this default. This default setting basically says "If debug mode is enabled (IE: You're on a dev machine), the default for the superuser flag is 'on'". You probably want it to just default to "no"
can be omitted
The parameter can bee removed
again, CoreUtilities.noDebugContext
I think this should be ss.findAllRepositories(streamName)
can we remove this method and simply have the poolsOfString.take() where this method is called?
You can refer resources keys directly from the HTML via <wicket:label key="tooManyUsers"/>. The class for the label can be a simple WebMarkupContainer.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
If our setters in commands are going to fail-fast about single-execution, we should fail-fast here too about a null pointer being passed in for Repository. NPE right away in the constructor rather than deferred: Git git = new Git(null); git.commit().setMessage("Test").call() We should NPE on the first line of that, not the second.
Please have test for null result.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
please move the isEmpty methods to the scimSchema
concat empty str ?
given/ execute/ assert
Optional: can be written in a more compact way: Map<String,String> map = new HashMap<>();
This can be replaced with return mDrawerToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);
return SUPPORTED_INPUT_FORMATS.contains(inputFormat);
Should just store the String[] and for open() and getFileName() you return the first item in the array.
The exception also needs to be modified a bit.
nit:Can you use _pollDurationMs directly and make _enablePollDurationMillisMetric local?
I wonder why we didn't check the class type of obj here. Feel like we are supposed to check as follows:  if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } RemoteReplicaInfo info = (RemoteReplicaInfo) obj; return compareTo(info) == 0;
No need to catch the exception here, it was already done in the overload.
unnecessary change
Should this return 0 or -1?
The code might be more compact. and the while logic not depending on the initial value of "ret". For example: int n; while ( (n = read(oneByteBuf, 0, 1)) == 0); return (n == -1) ? -1 : oneByteBuf[0] & 0xff;
We won't detect if newProperties contains a property that is not in oldProperties. Shouldn't we? Why don't we just do oldProperties.equals(newProperties)?
instanceof check is enough, no need for null checks in this case
getKey can be called only once. No need to call it for both parameters of getAsync.
How big is the overhead to do this check on every log?
Optional
Isn't it easier to reuse AsyncIterablePublisher with a Collections.emptyList?
Same here - please move filter and jobType to the sample
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
close already done in Util.read(..)
Maybe we're going at this the wrong way, and trying too hard. If you call ProjectJoinTransposeRule on a MergeJoin (which requires sorted input), and the Project does not, after being pushed down, give sorted output, then maybe the rule should just abort. Just a thought.
Method body should be: return moduleName.replace('.', '/'); without ending slash, because later this path is used in combination with "/module.xml" string.
There seems to be different order than it should be. Please check it with old message.
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Any worry about case sensitivity wrt to scopes?
we should use URI instead of URL here to be consistent with the other methods. URL also does DNS lookups which can be problematic.
Probably we can move the logic of obtaining the env vars to @PostConstruct to avoid reading env vars on every call
should be using the <> here?
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
I might have been confused, but shouldn't we have a new handleNewSession method that takes a session Id as parameter?
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
Might be worth having a displayName?
Still worth using Map<String, Object> commandParameters = Collections.singletonMap(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
Could you prepend ^ and append $ to pattern to achieve the same whole-string match?
updateAvialability() calls -> updateAvailability(SystemTreeItemType.System, null); Since the reports init is no longer blocking the ui there is no guarantee the system tree selected item is the 'System'. Calling updateAvialability() will update all the tabs (not just the reports) as if the system is selected. In my opinion, you should extract a method in CommonModel to update just the reports availability and call in from here.
nice catch, I just recently wondered about our handling of singleTop
omit?
nit: can be chained onto previous line's assertion
suggestion return stage.thenCompose(ignore -> awaitQuiescence());
You can use ValidationUtils.nonNull for this.
this.currentLocation.get() this may fail, as the currentLocation is not always guaranteed to be set. Check for presence
remove exists variable and just return !tuples.isEmpty();
We should announce support here, as per XEP-0231  3.
use parameterised logging
java this.onPostServerTick(this.getMinecraftServerInstance());
Could you move the channel creation outside, maybe in getNotification(), right after we call getNotificationChannel() ? If someone overrides this method, the creation won't happen
File.separator
s/B/b/
Do you have any reasons of execute SQLs directly instead of executing queries from files as in other tests?
Do we not have access to the version of junit that supports @Test(expected=Exception) ?
Missing 'of'
@exper0 full path HmRsHeader.VALUES_STR
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
nit: import toSet static for consistency with toList (see L46).
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
@guiseco you don't need to check the validity of the position argument here, since it's based on the getCount() that you overrode above.
make this constructor private since all the methods in the class are static.
A bit late now, but these should really be KafkaHeaders constants with prefixes (kafka_*).
This is a partial workaround, but I think it can be made into a more complete solution: Earlier in this file (in the PageTitle constructor), we split the title string and try to detect the namespace of the title. At that point, we can check whether the namespace is really a language code, and then override the "wiki" member of the PageTitle with a new WikiSite that corresponds to the new language. That way, we can truly *support* language prefixes in links. And one more hint: Android provides a function called Locale.getISOLanguages() which returns a list of all possible ISO codes.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
This will NPE if input is null, yet the parameter is marked @Nullable. Should we remove the annotation, or explicitly check for null (e.g. to return null if input is null)?
This can be relaxed to Type<T> instead of RealType<T>, no?
Is there a reason that the GapBuffer is initialized with a buffer size of 1 by default? I know this is a very vague question, but 1 seems like a weird choice to me. It reserves ram in anticipation of future insertions to save computation time, but still only allocates so little buffer space that the array size will have to be increased after one insertion. And if the first action is a deletion, this one additional character of buffer size won't make much of a difference. But I have no experience with gap buffers, so maybe I am missing something (or am overthinking this).
the static modifier could go away
Just a heads up - I tried using this in the server and found some dependency problems. You will need to create an integration test, with some suitable source span data, to try this mechanism out running in the server, just to be sure.
This is less noisy and reads better:  import static org.hamcrest.Matchers.startsWith; ... startsWith(BASE_URL + "/customers/")
Lines 1068-1088 are redundant.
Can this be private, or is there another use case for default attribute outside the builder's call?
This test data is a bit suspicious. createRecord alternately creates mapped and unmapped records, which means some of the records created here will wind up as "mapped/half-unplaced" and others will wind up as "unmapped/half-placed", due to having an alignment start but no reference index. Those are weird states for test data, and its not at all clear from looking at this method whether its intentional. Not that we don't want to test the "aberrant" cases, but we need a cleaner separation between valid test data and invalid.
there's no need to call super.close here
I think it can be logged with WARN as this is situation that we create ourselves and we are aware of it, so it's not really an error.
Perhaps I'm being daft, is this condition backwards? Why set 'played' to false when position is greater than 0? Should it be setting 'new' to false?
Please fix indents and use assertNotNull
all these methods can be private
Here you can change to Matchers.contains as I said previously.
filteredProgrammes is a bad name for this, and as far as I can tell, these should be Episodes, not Programmes by now.
no public
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
Lambda?
equals() is not usefull for enum, == is sufficient.
I think this should be final.
I'm fine on doing this on all server side classes, but in this case for ClassUtils, which is inside core-common module, it's not correct, because that class is also visible to the GWT compiler, and as far as I know it does not emulate the isAssignableFrom method from JRE... That's the reason I remember to do the comparison via classname, which the method is emulated and so we can always compare on js two strings... but feel free to test it guys, if I'm wrong lemme know and I'm agree on this change.
I don't know if you'll take this as good or bad news, but there is no longer need for these uncertainty ranges -- every selection and window range times are now always exactly the expected nanosecond. The method validateRanges() could now take four longs as expected input. For example at line 479, old window was [30,70], we drag 30ns to the left, new window is [60,100].
Usually (especially for loop conditions) I like this style but in this case this is a mask, so if we ever go up to the top bit this becomes broken unexpectedly. Let's use == instead.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Maybe a check here that getLeft() and getRight() have identical schema?
Operation can have InputStreams attached. There's a way to translate that to HTTP, we should figure it out. Or at least throw an exception if there are attachments.
elapsedNanos.
extract actual.getModifiers() to a local variable.
ParameterNameProvider=ClockProvider Or, better yet, let's just move to getUnableToInstantiateException(), I don't think there's much value in having the dedicated versions really.
would be good if you match the expected values in here. I would recommend bringing some of the values you defined in init to here. Those are execution/parameter specific, init should generally be a setup only.
I think there is a race in IndexingService between createIndexes and shutdown where population jobs can be added after IndexPopulationJobController.stop is called. Result will be that we can leak population jobs. It might be that this is guarded for higher up in the stack. But I think this should be guarded for explicitly. Either here or in IndexingService.
This is unreleated
suggestion if (this.currentTask != null) checkAndRethrow();
I am concerned about the addition of buildResult here, since this will cause every single copy to read the data twice for the copy and for the checksum, instead of once as before, which could be expensive when dealing with large files and cause performance regressions.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
timed --> direct
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Also inheriting CauseAction should be useful. Please have a look at NaginatorRetryAction#sceduleBuild. <LINK_0>
Please use diamond operator, you don't have to repeat time a second time. ArrayList<Integer> a1 = new ArrayList<>();
this method deserves a description
StringUtils.isEmptry(XXX) if possible
can be simplified as Objects.equals(name, myPojo.name)
Why do you not return directly the condition value ?
likewise, this one can be static
You need to specify your "When"s before you actually invoke your service in order for the mocks to work, which begs the question as to whether or not this is doing what it should, and if it is needed.
remove when the export button is implemented
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
You can combine these 2 lines into 1
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
This method is in a non-final class, so there could be code out in the wild that override this method, so we cannot change its signature
This seems like it will cause problems for BamReader.queryUnmapped()
remove else
nit: I find this one easier to read  requireNonNull(clientTags, "clientTags is null"); this.clientTags = ImmutableSet.copyOf(clientTags.orElse(ImmutableList.of()));
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
I notice that most of the other models with this method don't use static. Would you mind making it an instance method for consistency? Also, can you see if you can change it to private visibility? I don't think there's any reason to leak this interface out of the package.
suggestion return Optional.of("org.junit.platform");
Here errorMessage needs to have single quotes escaped. The permission error ('You don't have permission to upload media to the site'), for example, causes an error. errorMessage.replaceAll("'", "\\\\'") should do it. We should probably do this everywhere we're sending string literals from Android, since a translated String may contain a single quote even if the default one doesn't.
What is this for? Feels like some unintended checked in code?
throw exception
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
Please use org.ovirt.engine.ui.uicompat.external.StringUtils#isNotEmpty
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
better cache this to avoid multiple db queries
I guess you can use feature here instead of contacting separated values.
Use Optional.fromNullable(marker) instead?
a table without db is not invalid? is it only needed temporarilt - until this whole thing is done?
suggestion && (((BaArmor) part).getType() == getType());
suggestion logger.warn("Could not remove {} with key '{}': {}", element.getClass().getSimpleName(), uid, ex.getMessage(), ex);
Don't need this keyword here - the rest of this code only uses this when necessary.
should this just throw if !hasNonNullValue? We already provide hasNonNullValue, shouldn't the caller inspect that before calling getMaxBytes?
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
throw exception
Should be immutable by making a copy.
Please remove system.out.println and add assertion
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
IIUC, this means we create 2 KubeClients in the JobManager process? Would it be a problem?
It might look better to start the new line from the .show() instead of breaking in the middle of the arguments. Also note that you aren't breaking the lines in other places.
Don't we need to do the caching here?
Should this not be nested-projects?
NIT: Paths.get("src", "hello.rs")
The property cannot really be changed at runtime can it? So why not put it in a static field and avoid the repeated lookups.
Should this link to the course?
Consider to move into constant variable into SAMLConstant
missing @Override declaration.
What is purpose of this method?
"==" to "="
nit, Collections.EMPTY_MAP?
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
Same code as in the method above, factor it out?
& let's not forget about this.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
new ArrayList<>(causes);
Collections.unmodifableList()?
We could just always use the body instead of flipping based on the payload size.
Use HttpServletResponse.SC_METHOD_NOT_ALLOWED instead of hardcoding 405 please.
should be in separate PR i think
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
If we return inside the case clause, we can get rid of the res temporary variable, the breaks and the last return line. switch(format) { case LEGACY: return renderLegacySize(size.longValue()); ... default: throw ... }
What if fileName doesn't have any .?
There should be a corresponding JsonProperty getter for this
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
Why not make this create simple string and then invoke the setAddress(simplestring) , there by not needing the two new methods and logic encapsulated in the setAddress(simplestring)
please extract to a separate method
This too would benefit from the (proposed) ConstraintType.EMPTY enumeration item.
Add a message to the checkNotNull. It helps in debugging. The canonical form is:  java foo = Preconditions.checkNotNull(foo, "foo cannot be null");
Wouldn't we want to call s.beginTransaction() inside the try-block and then add a catch-block to determine if a transaction is active and rollback?
Consider returning a constant
does this method need to be public?
Same thing here. I don't think mProducerContext != null should be a precondition -- setup() may have thrown an exception and we still want to do our best effort to cleanup by allowing super.cleanup(context) to be called.
I'd feel better with this if this method was still protected. Why was it made public in Netty 5?
run -> status
Can you reuse the scan variable? That will save connection time for every request.
These might look a bit tidier as static imports
Constructor should be private. Make a static factory method
This logic would be better: if element is an anchor, check for class, else check for attribute.
Use java.util.Objects.equals().
public
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
For safety and future-proofing it might be worth including the set of potential answers as a list or enumeration in this class (or elsewhere) and using a count of that set. This seems like invisible/loose coupling to a concept that won't necessarily be clear when updated elsewhere.
Should this be one line down after site?
no need to assign the client to a var here since it's only used once; could collapse these 2 lines to 1 instead
This is not testing the frontend.
There is only one form indeed and a Flux read makes no sense but the method can produce a Flux, i.e. Flux.from(readMono(..)), even if it will never have more than one element..
please put each parameter in separate line :)
why rewind?
You should use a variable to store this 5, so that when you want to change it, you only have to change it in one position instead of 3.
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface ?
I've seen this a couple of times now, can we use Google Guava's ToStringHelper instead? Probably best addressed in a separate issue/pr.
if getSessionTags print warning - this one should also do so
getParent() can return null
nit: imageName field can be changed to DockerImageName, to make tests' bodies a little bit smaller
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
does this need to catch all exceptions?
can we use here some simple words like variable, parameter, instead of cryptic lc1?
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
This code duplicates method isSwitchRuleLambda. Should this method be used here?
Should be ClassNotFoundException. Catching all exceptions and disposing them may miss unexpected exceptions.
consider to inline uris
I would change this to if(url == null) { return null; } less indentation, code looks a lot cleaner
Remove this
style-nit; no braces for simple single-statement constrcuts
what if none found? are we sure there is at least one?
why exit here ?
It looks like you are returning an empty ArrayList keys
static import
Shouldn't we throw here?
This should be "isSetReboot". The reason is that we don't even want to call the backend method if the user didn't explicitly provide the value, as the backend method may have side effects (very unlikely in this case).
use instead, please, implements IntegrationEvaluationContextAware
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
typo
Actually as Part of reusability we have added Synchronized block inside TrapReceiverImpl.addToSnmpV3Users and same we are calling here.I hope this serves the cause or If still synchronized is needed even for this block i can update it.Please let me know if its necessary to wrap here as well.
nit, just make this real instead of mocking i.e. () -> FALLBACK_INT
brr... I don't understand this ctor. it should do just this: this(new RqFake(), dispositions). why it's doing something else?
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check !getClassConstantOperand().endsWith("LocalBroadcastManager") can still be present. It will be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
Could we rewrite this method to make more sense like so: java try { Twitter.getInstance(); // Check for initialization } catch (IllegalStateException e) { initialize(context); } signOut();
throws Exception should be avoided. Ditto for next 2 methods.
bad selector
I feel like we should be able to take out a lot of these nullity checks. Let's keep this in mind for a future refactor.
please add call to populate: addLinks(populate(connection))
We should also check the servers which we want to update the hook content is in UP state.
This should be at least a constant, and more probably an instance variable.
I think we need to read stdout and stderr of command here. Otherwise it can never exit.
nit: you can merge both lines above as checkNotNull will return the given argument
suggestion
Instead of using String += otherString, it's more efficient to use a StringBuilder and .append() (especially when in a loop), then return sb.toString() at the end.
Since this method no longer throws an Exception, should that be cleaned up? There may be other methods to which this clean up might also need applying.
As above: private, 100 chars, use error result instead of doOnError.
nit: Maybe more explicit:  Only function definition classes (classes annotated with @ScalarFunction) can define SQL functions via non-static java function. Function set classes can only define SQL functions via static java functions. Thus constructor in function set classes is used to define SQL functions.
Can have a isRef(Expression) and isLit(Expr)
Better use switch-case Throw a new Exception for the default-case.
Just to be safe, and since I intend to delete our @Nullable, can we just put the string "Nullable" instead.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Let's add the partitions parameter to the message as well and verify the expected partitions are revoked.
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
change to List
please extract method : protected GlusterVolumeInfoDao getGlusterVolumeInfoDao() The reason for doing this, is so you will be able to write a test using mockito (and not pockermock / static mocking) for this query.
Speaking of sanity checks, is this: (100 - lastVerified) + 1 OR 100 - (lastVerified + 1)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
"quality_gates" => "quality gates" as it's what is displayed in log for user
If the o1 is diff than null, o1 must equals o2. If the o1 is null, return "o2 is _diff than_ null" ? I think this second part is wrong?
Here you test findByName method. I believe the bootstrap is better to perform not using EventTypeRepository, but just using jdbcTemplate or prepared statement.
Please considert moving this to line 238, and change this to positive condition
Why is this private, when addFiles does the same thing and is public?
These should get saved in a data structure so that repeated calls with the same name return the same map.
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
Make it final static
nit: we could extract this into it own method or extract the message in a constant to avoid duplicating it bellow.
why not just repo?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
Why not just return the condtional?
Not good to use Optional for collections, just return empty collection
This check does not belong here, this method should never be passed a null value...
Doesn't the remove() function return you the UpdateHandler which you want to call onCompleted() on?
Question: in the normal login scenario, reuseSession is called right after setSessionId. As both reuseSession (using getSessionId) & setSessionId are async now, I think we should utilize result callback when doing setSessionId, and only after setSessionId completes (result callback executes), we should proceed with reuseSession. This complicates the current code a bit, I can help with modifications/testing here.
It would be better to move this line to _ensureUserIsWorkspaceOwner_ method because it is part of it. You can name it as _ensureUserIsWorkspaceOwnerByName_
introducing double retrieval from thread local, unnecessary perf hit
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
If I understood correctly that empty result is a "non-standard" path I would invert the if.
Why is it a list of lists, not just a list?
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
This method should also saturate to MIN_VALUE when overflowing on the negative side. In case we trace dinosaurs.
Merge this with the loop above. You can still return false on a ResourceConflictException. Any OrmException should still be logged, though you should change log message to be a little more generic.
I don't think this is correct. This looks like you are trying to use either class or style. It is entirely possible to have both. The style always takes precedent over the class.
- log warning that option is not supported by SNMP
This isn't a Messaging component and from other side using this one within a Messaging component, raising a MessagingException from here, we prevent re-throwing a correct MessagingException with failedMessage context. So, for me simple RuntimeException is enough in this context. WDYT?
Should probably set a field with this value
somewhat confused, if you've specified serviceName you can no longer specify sid meaning that you get screwed over here whenever you call namespace i.e. you go from having a namespace to *not* having a namespace. What are the implications of this in atlas? If anything it feels like getConnectionDataString should return the service name if it is specified, otherwise it returns the sid and that sid is *always* provided OR that if you specify serviceName, then you *need* to specify namespace explicitly when migrating over. Let's chat about this face to face.
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
I think you can plug in the User directly as a method argument. @MatthijsKok figured this out somewhere. Maybe we can even make it a Class field as every method in this Controller needs the User object.
Is there a reason for this to be protected?
This should be the check class.
Can combine the 2 above lines and use the constructor which accepts disk-id
With the recent writer change, I don't think this needs to be exposed any longer.
you should use here acquireLockAsyncTask(), we need to acquire locks only for commands that require to hold them for the entire execution flow (including endAction()).
Should make this ObjectMapper instance static. For this method should use a writer(), for the deserialize case use a reader(). Does the mapper need any configuration to handle empty/null values?
Minor: Use this. consistently in the class.
Remove?
Dangerous to call callbacks under the inner lock.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
I really don't like the user of instanceof. Why not overload the method to recive VDSExceptionBase? In both places this function is used, you already have that information.
is this going to result in a null reference exception? I think you can mock something for this.
It would be useful to have such operation in seleniumWebDriverHelper class: waitAttributeEqualsTo(By element, attributeName, expectedValue)
If the objective is to make sure the caller can't modify the properties after constructing this object then you'll have to create a new map.
Reminds me of containsKey() :smile:
wait.forElementClickable() should be used before
return SUPPORTED_SERDES.contains(serdeName);
wait.forElementClickable() should be used before
use return ... ? ... : ...?
Which type would be assigned in this case?
should either read: "Must set either both SslSocketFactory and TrustManager, or neither" or "Must set either both sslSocketFactory and trustManager, or neither"
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
Should assert on the message contents to make sure it's the right one that got through.
this is confusing, it is called router but actually it is routerUrl.
The classical hack is to implement read() like this: byte[] b = new byte[1]; int n = read(b); return n == 1 ? b[0] & 0xff : -1; Its almost never used and this form is short and easy to read.
Add a condition to the log.
.split("[,]") and trim() to support multiple interfaces within single extension, please. return List<String>
suggestion return Arrays.toString(value);
rename to segment
Simple test is also possible to verify result stat. See #971.
this looks backwards. If (!keepExtensions)?
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void should_fail_if_one_field_or_property_is_set_even_if_another_is_ignored() { // GIVEN Jedi jedi = new Jedi("Kenobi", "blue"); // WHEN expectAssertionError(() -> objects.assertHasAllNullFieldsOrPropertiesExcept(someInfo(), jedi, "name")); // THEN verify(failures).failure(INFO, shouldHaveAllNullFields(jedi, list("lightSaberColor"), list("name"))); }
println should be changed to a logging message
To follow Spring Security conventions, please change Raw password to match the variable name of rawPassword.
can you add @Nullable as method signature
Something else that I missed. I know it's not that important, but we don't have to set the type when creating new objects any more. We can just use the diamond operator new HashSet<>.
The synchronized can be removed.
Same it's 1 field.
Map<TableScanNode, Void> result = new IdentityHashMap<>();
It'd probably be worth logging if is an invalid value rather than silently ignoring the input value.
I don't see the point for a wiki page, if the wiki page did not changed then why could we need to invalidate the cache ?
We should include a resolution step here: enable auth or change your rules (or something strange happened)
Might this field connectClientTsApiFolder  ever be a null? it's created in CTOR and has a final.
Why have a result if the only one you care about is allow? Cancelable exists for boolean things.
lambda?
Does it makes sense to return a boolean here(indicating it the application had shutdown within the timeout). Returning void on a timeout doesn't convey if the application had shutdown within the timeout or not.
This is throwing a StackOverflowException if invoked. Should probably be sendNow(event)
This effectively turns the flag to "false" but now we have an instance variable that is null even though the child fragment might still be included in the FragmentManager. That's a confusing state to have the variable in and maybe we should work on removing the child fragment (right here or elsewhere, on child fragment's work finish perhaps).
Better to return "";.
Change this variable declaration to something with meaning in the context. map is unclear here
Can use constant for "4". More importantly: if the blob is not already encrypted, the config flag "requireEncryption" is true, and cryptoService is null, upload should be skipped. (You'll see some of this logic when you merge with master.)
typo
wouldn't this fail if pattern was null?
change to IAdaptable
FYI, magic number 2 can be replaced by constant ComponentContainer.COMPONENTS_IN_EMPTY_COMPONENT_CONTAINER
This is not correct, let's discuss f2f about it
why null check here? ... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution.)
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
This seem to be asserting callback failure. Consider making a helper method.
Better to return "";.
Missing the substitutions for the {}'s. suggestion LOG.error("Failed to parse value of system property {}='{}' to an integer. Using default value.", sysProp, val);
could we refactor the above into a setUp() method and not having to repeat for each test
This will create 0 connections. Didn't you mean < ?
@sundaramrajendran Yes, I see the bug now. Thanks! This said, I think ConfigParser needs a few more changes. 1. We should not call readConfigFileContents in any constructor. 2. We should wait to call readConfigFileContents on the first invocation of parse 3. setConfigFile should return the ConfigParser instance to make it more like a builder. E.g. - ConfigParser.setConfigFile(file).parse().getInt(key) 4. Subsequent calls to setConfigFile should not change the static value of configFile once parse has also been called.
I would change the 'by ourselves' into 'synchronously'
Why don't we remove Consumer from the consumersByQueue as well, like we do that in the handleCancel()?
simplify this to  return getVarArgIndex() > -1;
> this [](start = 8, length = 4) no this. please
I added method in Utils for that
Where is this being called from? It's part of the public API, no? If anyone has pinpointManager.getAnalyticsClient().setCampaignAttributes(...) in their code base, this would be a breaking change. Like for the other method, you could _add_ this method, and have it pass to an @Deprecated public void setCampaignAttributes(....).
OK to return the empty set - the JavaValue is a value, thus no variables inside.
I think buildBigtable*Settings should just return built settings and you can the InstanceAdmin one return null if the emulator is enabled
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for ? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well ?
Could you please change this to use only one access to the map?
need to calculate logprob directly.
can be java public Seq<E> getErrors()
Please keep annotations on separate line :-) I suggest to use Java 7 utils for easier computation: if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } ValidationResult that = (ValidationResult) o; return Objects.equals(success, that.success) && Objects.equals(reasons, that.reasons);
ChannelClosed needs to be added to (though not strictly necessary)
use Log instead of System.out
Better to return "";.
Why is it a list of lists, not just a list?
It would be nicer/easier to debug if you extract the numbers with this regex: "^(\\d+)\\.(\\d+)\\.(\\d+)" Then do a comparison separately. java int result = ComparisonChain.start() .compare(1, Integer.parse(matcher.group(1)) .compare(14, Integer.parse(matcher.group(2)) .compare(0, Integer.parse(matcher.group(3)) .result(); assertTrue(result <= 0, "Expected BigtableVersion.getVersion() to be at least 1.14.0")
And here. needs some validation.
Let's inline this: return doGetInputFieldsForPMMLStream(modelInfo.getPmml());
newMappings is not used. You can avoid all this synchronization by atomically replacing channelMappings with newMappings.
I would suggest calling getAmqpPort() here (and in other get*Url methods) to avoid a duplication of this code
please use try with resources as in ConfigurationHolder
suggestion if (keyedStateBackend instanceof CheckpointListener) {  Since the instanceof operator always returns false for null, there is no need to have an additional null check.
since "acceptedType" is of type list i would suggest to rename it to "acceptedTypes"
write nullable on the same line or don't write it
style nit: we don't use braces around single line blocks
You may want to make the default smaller - like 0.01.
done for patch3.
What do you think about if (paths != null && !StringUtils.isBlank(sourceText))?
More efficient: getDB().getRecPtr(record + DEFAULTVAL) != 0
move 0 to private constant as you use it in many lines, it will be easier to change it in the future if needed
you'd want to use StringUtils.isBlank() not just the empty string
- log warning that option is not supported by SNMP
if you write new code please use java formatting
no need to declare the unchecked exception here.
cid -> dialog, gp -> geopoint.
Should this maybe return RecordStore.DEFAULT_TTL (-1 --> use MapConfig's default) instead of 0 (--> infinite max idle)?
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
Delete this - it was just there during debugging.
nit: now that we are passing in the processingMode, we could potentially use this check as a helper function as:  private boolean0 eosEnabled() { processingMode == EXACTLY_ONCE_ALPHA || processingMode == EXACTLY_ONCE_BETA; }
You can do criteria.add(Restrictions.eq("experiment.ndExperimentId", experimentId)) I think
We don't need to merge internalExchangeInfo and exchangeInfo. Remove the merge from WebserviceProxy, ExchangeManagerHelper and all related code.
what if we have a mount with one single volume? Following the current implementation we may assign an unnecessary capacity ratio to it. We only need to calculate and assign the ratio for volumes sharing the same mount with others.
This variable name doesn't seem meaningful?
should probably check the app name does not have any chars that are not allowed in a zookeeper node name
Why the unparse SQL is different ?
Same- catch NPE.
Simple test is also possible to verify result stat. See #971.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
why not using the super constructor? super(nodeId, nodeLabel)?
Did you format the diff with helix-style? @BeforeClass should take up a line to itself.
I think we should create a defensive copy of the Map
I don't think you want to keep this print in here and the rethrow as a cause
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Consider writing a header for backward/forward compatibility.
Readability is concern here, lets keep it as it is.
We could probably use getItem() method here, for consistency.
Same issue as above.
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
Could you add support for setting from console too since that would work with the 4/6 arg version?
populate with meaningful data. Version should fit to artifacts versions automatically Licence: <LINK_0>
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
If the format is null then we need to check for the translation type first. Anything not a text translation type has a format of markdown. If the type is text then if the project id is obs the format is markdown, otherwise the format is usfm. We cannot completely depend on the resource type here because a REGULAR type can be either obs or a non-gateway language translation of a Bible project. > NOTE: In the android app we don't directly support translating to a ulb or udb resource type. However, the desktop app _does_ support this. Therefore android provides just enough support so we can import a translation from the desktop app without breaking.
Unless I'm missing something, testFinished(class) == testStarted(class) (either a test starts and finishes, or it never starts). Can we just have one method (perhaps named wasRun)?
This will destroy performance. We cannot allocate a new byte array with every short read. You could use an instance field buffer of sufficient size to avoid the issue.
>byte[] [](start = 11, length = 6) DecryptResult
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
Please use curly braces for conditionals
instead of comparing topicPartition object, why not compare topic and partitionId?
Since this is a String, perhaps you could use Collections.nCopies
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
does this need to catch all exceptions?
copyOf does not necessarilly copy (I know name is misleading). Also we value readability, and old version is way more redable than the new. Finnaly we prefer relying on guava's collection. So I disagree with this commit.
Pay attention that most methods of this class return the null as String, but this method returns "null" as String.
no checking flow when user sets grace period in the action
You could save a few lines by moving the return null into the default case instead of break.
This may be a bit performance-intense, so a prior Material check would be very adequate here.
Probably it should just return false
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _getCurrentContext()_ once and store the result in a _context_ variable). As a side note - in this and the following cases, the number of lines to change (and detected as changed by git) would be much lesser, and so the overall impact.
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
The bytes can only be cached if the backing buffer isn't reused. If it is reused, then the backing buffer might change and cachedBytes could be stale.
use ShellIsAvailable
I'm not sure how anyone can create a class where isTTransport is true?
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
I think this method should check only case 'b' and have proper method to explain the problem. All the other case are covered by 'nicActuallyExistsOrReferencesNewBond(..)'.
not use this to reference class members
Another place where the name should probably be updated
Please, don't reload the text in onResume(). Do it in onCreateView() or onActivityCreated(); onPause() and onResume() may be called when other windows partially hide the fragment (such as the menu showing apps to open the file outside of ownCloud) even though it stays visible.
public PostsListPage and return this for chaining purpose
You could add a text here to show what the output means. You probably know, but me running this benchmark, I'd need something more verbose ;-)
suggestion "A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.");
Not sure, why not use @NotNull?
Calling System.exit needs to be carefully controlled or it will break embedded usage. "Quitting" an embedded CLI may not mean the user wants the embedding app to exit. On the server side we do this by using a SystemExiter interface, and all "exit" calls use that. We then swap in different impls of the interface depending on how the server is being used. The standard impl that is used when we know the server was started from the command line calls System.exit. Others do not.
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
return toStream(ele, eles).collect(Collector.toSet());
I continue to think that **aifc** should to be here...
will never be true, because of Objects.toString(null) == "null"
These Overrides are generally on separate lines (I don't think our styles are set up correctly but check the rest of this file)
also include the test's source path, you can find it in test.getSources() This will help the developer to locate the TEST_MAPPING file.
I think isDisposed should also be checked here, right?
Please remove an excessive space character.
why are you changing this line ?
EmptyConfig.INSTANCE?
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter filter = filters[mid]; int c = methodName.compareTo(filter.methodName); if (c == 0) c = className.compareTo(filter.className); if (c == 0) { return true; } else if (c < 0) { high = mid; } else { low = mid + 1; } }
The proper way is arguments[arguments.length - 1] instead of arguments[0].
Collections.unmodifableList()?
Is a table alias of length 0 really a thing requiring special casing to drop the apparently unprefixed '.' ?
There's an inherent race here, if the following sequence occurs: 1. Thread A: getRealmIdentityForUpdate 2. Thread A: removeFromCache 3. Thread B: getRealmIdentity 4. Thread A: modify credentials 5. Thread B: authenticate with wrong credentials, which are cached forever The entry should only be removed from the cache *after* modifications occur, i.e. ModifiableRealmIdentity has to be wrapped as far as I can tell.
Maybe legacy version of SetDigest can not be cast to HyperLogLog
Why not declare GLOBAL_ID as a long?
You don't need this line because of green 31.
Could have @VisibleForTesting annotation. Also could public be removed?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
it's better to do this(clazz.getName()) here and get rid of this DEFAULT_LEVEL constant, being used only once
This code can be extracted to a general "run & check" method
Why do you use a new array to do iteration? If it is to avoid possible ConcurrentModificationException in multi-thread use case, a synchronized block would be more adapted.
Missing a unit test to ensure maintainability.
Same as above for toString(): <LINK_0>
suggest you want raw.split(":",2) here so that the value can contain colons.
Turn this into one or more helper methods. The simplest thing to do would be to have something that returns and List<String> or Iterable<String>. Then you could use standard Hamcrest matchers to assertThat the list does or does not contain the expected outputs. Alternatively, you could make higher level helpers such as assertSleepCount(expectedNumThrottles) and so on. Or even assertCount("Sleeping", 0) would be okay. But for more complex scenarios, you might need to check the order and count of messages. Your call on the specifics, just need something a little easier to read.
that's invalid anyway, isn't it? what's the meaning of CLUSTER_DEFAULT on cluster, you can never set it. autodetect==null, and then only concrete values are allowed
isValidValue() anc isNumeric() could be abstract on the enum, and therefore each instance could have its own implementation. Arguably, it could be nicer code, avoiding these monster ifs and the potential bug when a new type is added without updating the ifs Although I could also see how that kind of code could be considered worse, due to all the @Overrides. :-) So just something to consider.
we should use getAndSet(null) here to release the reference as well.
This whole check is fundamentally wrong. We should return all facilities for PERUNADMIN/PERUNOBSERVER and filter response only for FACILITYADMIN.
Why do you use 3-argument constructor here?
Is there a reason this is package private? On a fluent builder this feels odd...
Why this change?
you can check the cache file exists (check line 147, which checks the output report), and you can check the output for the cache warning to not be present
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
Alternatively you could have a static constant Set<String> and do a contains(). It would go nicely when we can use a Set.of.
private static final int FIVE = 5
Is there any case when we don't have config?
:question: do you need to do line 187 (final SolrClient c = client;)?
is this value hardcoded?
selectedElement for better readability
I would suggest naming this variable as 'serversArr' instead of 'temp'
This should be constructed using a private SecurityAction, since it requires EXEC permissions (see the CI failure)
yeah
It seems asymmetric to allow returning a null Integer for getMaxConcurrency, but setMaxConcurrency only allows a primitive int which cannot be null. Is it meaningful for the max concurrency to be null? If so, how do you clear the max concurrency?
add sandbox
@ivandalbosco Is it possible to have invalid line? and as a consequence a parsing issue on file level?
@ekondrashev move this assignment to line 103 above.
either change the method name to refreshMetadataDevicesInfoIfNeeded or better yet add the if condition here.
This should be log.error. Don't know why other statements here use log.warn
Given the other changes, I wonder if the handler is needed at all or whether just need a way to disable it. If keeping it, I wonder if onReceived(Map<String, Object>) and onProcess(Map<String, Object>), and then all _received_timestamp and highWatermark logic could move into the handler.
Normally we would do this to prevent accidental bugs to trigger the wrong failure:  private RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder() try { builder.rxFactory(null) } catch (IllegalArgumentException e { //... }
The flag is being set to true always, the previous statement does the right thing - Did you leave this by mistake?
@essobedo once used variable can be inline
Unnecessary call to super()
I would use method reference as per below suggestion String[] nodeIds = logs.stream().map(NodeInstanceDesc::getNodeId).toArray(String[]::new);
Do we have to use the configurator for fetching 'MaxVmsInPool' value? A lot of configuration values are fetched in 'VmModelBehaviorBase' (e.g. GetMaxNumOfVmSockets) - try to retrieve it once 'PoolModelBehaviorBase' if it's not too cumbersome.
All of this can be replaced with an ExecutorService
this assumes that field.getRegister() is the same string as the fieldName. it might fail specifically for the registry field which links to the public-body register, not to the (non-existent) registry register
Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap
Is payeeIdL a typo or intentional?
Check if KEY_MEASUREMENT_FILTER_ID for specific measurement filter is present in request parameters. If present set value from request parameters, otherwise don't set...
should check that there are exactly 2 items in the array, and throw an IllegalArgumentException if there are not, with a descriptive message.
Use ClientLogger for throwing exceptions
I wonder if this change would result array allocation and extra cpu/memory consumption issues
Should this executor specify the Looper too?
Wdyt about using a java 8 method to check lists ?  public boolean isRowSorted(List<String> info) { return info.equals(info.stream().sorted().collect(Collectors.toList())); }
You could also use -> Objects.toStringHelper() from guava
Same as above: could use searchPacksAgain
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
there are multiple uses of these values in different tests would be nice if you could move them to constants with a descriptive name. especially height and width because they are always the same
nit: use List rather than ArrayList
just remove the fileSize from here... and that's the only change you will need.
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Missing null check on sampleClass
Is this a programming error? Should it throw an exception? There is a similar case above.
add reload
This does not take a message, it takes the id of the resource that is missing. Here I would just use the no-arg constructor.
invert this.  java if (List.class.isAssignableFrom(target.getClassType())) { return multiInstantiator.instantiate(target, parameters); } return conver....
if tags are displayed in a list, better use onData to get hold of it
Replace with logger
can you remove this try/catch? it could cause the sample app to get in a weird state
else if (SecurityUtils.isHadoopWebSecurityEnabled())
once applied changing the class signature, this casting can be avoided. Update should be done in VdsUpdateRunTimeInfo.getVmInfo where creating the command instance.
we should probably check in the canExecute whether we reached the end of the list
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
Do we want a test case that you can create an element with any revision?
The Exception is never thrown.
LOG.info("endpoint : {} , timeout : {}, connected successfully", endpoint, timeout);
Those two should be equals (and even ==) rather than going through FQN
Sorry did not get. How AtomicBoolean is different compared to boolean wrt repeated roll possibility. In the past we used to keep the Boolean state in a Map. Now in this object.
Again small thing, but "the existing file" sounds better IMHO.
For completeness it would make sense to also do a java assertEquals(dt.getZonedDateTime(), sdt.getZonedDateTime());
getStorageDomain is the TARGET domain - you should get the SOURCE domain according to the storageDomainId parameter passed.
Please add java doc
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
Where in the code updates the connectionIdToRequestInFlight queue when a request gets timed out?
AnnotatedTypes.getIteratedType is not longer called. The Checker Framework still compiles if I delete it. I think it should be removed.
It must never be null
This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was a reason it was an instance var that was mutable.
This should not use the --metadata parameter since that is used for object metadata. We should probably use a different parameter like, --datapolicy-id or something like that.
Here merge gets too complicated. More readable solution would be: map.computeIfAbsent(year, k -> new HashSet<>()).add(geoAreaCode);
new byte[fields.length][] is sufficient because you initialize the second dimension in the loop below and if fields are empty (empty array) then the initialization fails because the size is Integer.MIN_VALUE + 1 which is -2147483648 (-2^31 + 1)
misspelled. plus why are we leaving the first character capitalized?
emphasized instead of emphasised
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
Do you think we can continue with the exceptions refactoring you started in repository level and throw these exceptions to controller level catching them with exception handling mechanism?
final! :)
Please log a more descriptive message here. Remember e.getMessage() may be null. This should probably says something like "Search for owningCollection with UUID = [parsed uuid] resulted in an error"
Looking at <LINK_0> Do you really want to swallow "Error" ?
This is too broad and is swallowing exceptions that need to be propagated.
Hard-coded string here. Also, it would be good to write the error to the AppLog.
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
If you check for Collection wouldn't it be better to work on the collection interface (and perhaps create a new list) instead of rely that the collection will always be a list on this place (if it is the case, then use instanceof List.
Are these files typically named the same across multiple data sources?
@ikhvostenkov please name it just json
are we sure about this? :)
We should mutualize a hasTag (probably in stats)
Can be replaced with call to computeIfAbsent.
Why not just pass in only the message?
no need to declare the variable before using it..
This looks suspicious: call to Optional.get without .ifPresent. You can avoid having those misleading Optional-s, if you replace .collect(groupingBy(...)) with .collect(toMap(SortExpressionContext::getSortExpression, c->c, SortExpressionExtractor::merge).
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
This line can go with the playerCamera line below.
from L257~262, you can use Strings.repeat
This message is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message
Looking at the usages better throw in this case.
TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every wrap?
Is this related to metrics? Or something else?
This line now exists in the else statement as well [here](<LINK_0> I don't think this isOnline check is helpful. Because of that we have a hell of indentation here. I think shouldn't have getAsync from model 2 times. What we can do is that, we can first try to get it online, if that is unsuccesful, we can try to get from the cache, if that fails, we can use setIsloading(false)
You can just use Arrays.asList directly, e.g., final List<String> strings = Arrays.asList(...
Do we need to do that ? I'm wondering because we are opening the door to a new way to retain channels: - Is there a use case where the server life is shorter than the application life ? - If so, should we just shutdown event loops to force channels to be closed ? - Is this related at all to the OOM since this is only doing anything when the server is closed ?
For each?
Can you replace IDs with names in this log message?
This API is only reliable when the notifier is known a priori to be of the 'expectedClass' type. Usually we just check whether notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED The getFeatureID API is usually only employed for notifiers that aren't Objects, such as Resources and ResourceSets.
We shouldn't expect this to be an Expression. Fix the test rather than having it handled here.
In general, we should probably be moving away from client-side validation where possible.
Please use logger instead of e.printStackTrace()
you should use enum here instead of string. I think that the best solution will be creating new AbstractClass. DhisDataValueStatusResponse and DhisStatusResponse should extend this new class and then you can use here getStatus method
I think this is meant to be moved within the if (executor.inEventLoop()) { block below?
Just use a ListItemReader instead of that odd one off
Embed the caught exception in the newly thrown exception
any chance group 2 could be null?
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
prefer  String operation = isFile ? SASTokenProvider.CREATEFILE_OPERATION : SASTokenProvider.MKDIR_OPERATION;
IOException will be thrown if MappingMetaData is not valid json, right? (populateColumns doesn't throw, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think?
Big +1 to this change. Should never silently fall back to plaintext when there's an issue using the user-declared crypto. That said, I'm not sure the CryptoModule should even be configurable. It's too tightly coupled with crypto code outside of the module. I think maybe only the ciphers and crypto parameters should be configurable.
You will probably need to change this auth and the accept type when completing teh request verification in the mock tests.
We shouldn't wait for the a bundle to become active. If a dependency exists from plug-in A to B, then B will be always active before A. If it's not the case, than further investigation is needed.
entry could be final?
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, Charset.defaultCharset())?
why exit here ?
Same exception text adjustment suggestion as above.
metric?
I think you can use Objects.equals() here, we don't need to create CuKualiDecimalUtils
maybe use variable or pass in as parameters instead of using magic numbers.
use Java8 stream anyMatch() instead of this loop.
I have mixed feelings about this. On one hand, this won't interfere with a conventional callback. On the other, it seems like really bad practice to start Fragment C from Fragment B and manipulate it from Fragment A or Activity. I would prefer we don't support this callback pattern. Is there another way we could fix this?
I'm not sure if it is needed - wouldn't the command status be set to FAILED in this case?
[minor] ImmutableList.<Segment>of should also work and avoid the cast
.toString() invocation is redudant here.
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
Do we need to remove the reservations here if the member is no longer the replica after rollback, same as for record stores?
format as final String[] array. Rename to errorMessage if possible
Maybe add the reason as:  LOG.debug(" EXCEPTION THROWN ", e);
This method sums over the second and third dimension.
I think this will actually end up re-allocating when the second object is added to the hash map since capacity will be beyond threshold.
iteration over the entrySet is faster
Shouldn't we throw an exception here ?
here as well  java private void getSearchItems() { Preferences preferences = getPreferences(); ArrayList<Suggestion> suggestions = new ArrayList<>(); for (String recent : preferences.getRecentSearches()) { suggestions.add(new Suggestion(recent, HISTORY)); } mSuggestionAdapter.updateItems(suggestions); }
invoking combinations of close and releases here looks strange
Thanks for adding these. Issue: Should specify which is null.
What about Arrays.equals? Also possibly an intrinsic in JDK9.
Log the error cases.
Why not assign value when declaring: one line ?
Is this going to be always not null entry.getContent() ? Could this throw NPE ?
Lines 56-71 shouldn't be indented while they are inside if statement from in line 55?
Please assume usage of org.drools.workbench.screens.guided.rule.client.util.ModelFieldUtil.modelField method
I think it is better to use static import here
Just an FYI for future - You can use this method for this: <LINK_0>
why not this String nodeSourcePoliceClass = StaticPolicy.getClass().getName() ?
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Why change to "unacceptable value"? Should we say specifically say "Request has a null value for header"?
I prefer to keep the static import.
Avoid hard coding the path, use Environment.getExternalStorageDirectory() and the local path as a string resource.
same for this handler. depend on tunnel, not on the entitlement
If container is IWorkspaceRoot the scheduling rule must be WorkspaceRoot.
Is this the right abstraction level to throw RestApiExceptions? RestApiExceptions make sense when this is called in the context of the REST API, but not when called from other places like from the ChangeInserter.
wouldn't all start times be invalid then?
want to use try-with-resource instead?
I think it should be non-null, since people have come to expect that for granularity: all. It would probably break stuff for it to be null.
NACK. this undoes #1272
Not being able to set the timer due to an unknown exception is a critical error, so it is ok for it to crash the app and open the bug report screen. So this whole piece should be converted into: updateTimer(this);
You can't simply cast here (I learned this the hard way; the framework can return just about anthing here). Check the returned object for instanceof IStructuredSelection and simply return null otherwise.
minor: you can return Collections.emptyList() instead
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
nit: for src code readability & more explicit error message java Preconditions.checkNotNull(p.getParent(), "Path for page %s can not be root", pageId); Files.createDirectories(p.getParent());
what if valuelist is empty? should you check for that?
nit: put with the previous line
Space after cast (several occurrences in this file).
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.
Replace with a createParallelGroup (and add scanOnlyInScopeCheckBox and scanFuzzerMessagesCheckBox). Same for the vertical group but with a createSequentialGroup.
No need for a null check here, instanceof would allow both the class and null check as one.
This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an error to the caller instead of ignoring and continue?
This comes from when we pull the body out the camel exchange right? If somebody sends in the wrong type, the exception message does not seem accurate.
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
Check if byte[] b is null.
The cast is not needed
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
I would use "w" level in case of unsuccessful deletion
final
typo
check if volume is null and log and return.
Wasn't there the intention to exclude information_schemas and pg_* schemas from the result? I think in this class would be the appropriate place to filter the returned list.
This setting should not be enabled by default since headers may be C++-specific and not protected by #ifdef __cplusplus
I do not really like this intervention, especially if it is not necessary to implement the test. We are getting quite whiteboxy here...
It seems that the following does the same thing with super.unparse(...).
This annotation should probably stay, and again for parse below
Put ITEM in front of OTHER_FUNCTION
typo in log message for word connection
static final String
PMD/Sonarqube: Avoid concatenating characters as strings in StringBuffer.append
This is missing maxTotalRows
If disabled, we should not the forceRefresh attribute nor the representationToForceRefresh list.
Add a check here to verify that the serialDataReceived method was not called.
I think this exception should be about a @ResultHandler annotation, is that's what's being verified in the MessageHandlerInterceptorDefinition#wrapHandler method.
BUG? you log the error but continue processing the invalid sequence number... what will happen? See call to m_gapTracker.truncate below using the invalid value.
To go up before the first "for" to avoid to call this code several times.
If there's a failure and rollback, the ongoing migration flag will be true until a relaunch, right? Does that mean that if the failure was caused by something that can be fixed, the user will need to also kill the app and relaunch for the migration to run? If so, that doesn't feel right to me.
Sorry, already removed this :flushed:
We need to keep the throw exception as we are not changing the existing behavior
please remove alias setting (should be encapsulated in addManagedDevice
Tool tips can be slightly more detailed. Sometimes just a one word may not be enough.
The hashCode() and equals() implementations depend on the current position in each payload's ByteBuffer. The implementations can also process the same payload bytes as it recurses through the child packets. The payload should be processed only when there is no more child packet, and it should process the whole payload regardless of current position.
Inserting line breaks in log entries can cause pains when reading the logs. Can we remove the \n?
Did OSCORE specify to use ACK (and not RST) even if the message processing caused an error?
is this supposed to be deadlineMs - System.currentTimeMillis()?
you're synchronized on shutdownGracefully. Is it possible we are active at this check, but then become inactive ungracefully? I'm assuming that is also synchronized? I see that the handshake case is covered below in the else{}
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
And why would you do that to begin with?
Looks like there is a copy/paste error here, and this should be indexFileChannel.
If the Deserializer is named, Deserializer. The Serializer should be call Serializer!
contributionList can never be null
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
you can move this line out of the loop
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
Local variable could be declared List instead of ArrayList. Is this worth caching?
Can we rename this.policies to this.customerPolicies? This method is hard to follow with two different lists called "policies"
Is this method only used in unit tests? If so, is it possible to move it to the unit test source code tree?
newMappings is not used. You can avoid all this synchronization by atomically replacing channelMappings with newMappings.
I assume this fetches VLAN devices properly, i.e. if the iSCSI bond only uses eth0.101, this won't return eth0 right?
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
![MAJOR](<LINK_1> 'Severity: MAJOR') Either re-interrupt this method or rethrow the "InterruptedException". [![rule](<LINK_2>](<LINK_0>
should this be altered to use the 2 parameter version?
Default action is missing. Should not it returns requestFailed(null);?
@Override should be on line above. Checkstyle/formatter config?
The point I was trying to make is that you know this data in the constructor. You can do this logic in the constructor and simply return a copy of the binary data. Before, you were iterating through the Iterable of BinaryData each time, creating a new List object and then throwing it away to get the first item before copying it.
Maybe break out of for loop once we detect optional index, to avoid unnecessary compute cycles?
why replacing lockKey by lockKey? shouldn't be lockValue by lockValue?
![Codacy](<LINK_0> Issue found: [These nested if statements could be combined](<LINK_1>
I think it is better to throw exception
Given that the Ant task already checks for the existence of installUtility, shoudn't we just combine the logic from lines 97 to 105 like this:  // If we have the kernal JAR and the product jsons exist, then we use the kernel. Otherwise just use installUtility. if (getMapBasedInstallKernelJar() != null && !downloadedJsons.isEmpty()) // do the installation using the kernel else // call installUtility
before with the other this?
Should be Localized in Android framework.
We have another NPE here
I need to hit ARROW-DOWN twice to get something selected if there's no selection yet. Perhaps select the first item then?
Is this the right abstraction level to throw RestApiExceptions? RestApiExceptions make sense when this is called in the context of the REST API, but not when called from other places like from the ChangeInserter.
same question here, do we account for the colo with single replica?
suggestion Preconditions .checkArgument(numExpressions <= 2 && numExpressions >= 1, "DistinctCountHLL expects 1 or 2 arguments, got: %s", numExpressions);
As far as I can see, the boolean is not used anywhere, so maybe it could be dropped in favor of void?
validate arguments before returning new rule
This seems like a significant refactoring - why? Can we do it as a separate change or is it required for the java8 migration?
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
You might want to store the view as a field in your class if used multiple time. findViewById has a non negligible cost.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
objectRefs.get().acquireReference(object) -> objectRefs.get().releaseReference(object) I think you want to decrease the reference count here?
not necessary to add "due to"
You could combine this into the for loop conditional using && and removing the negation.
This looks like a good candidate for doing ImmutableMap.of(Maps.transformEntries(...)).
@inverno We have 2 times "Second argument" :)
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
i18n
Could use a mocked Model to avoid the need to tidy up.
This will work poorly if there is a lot of small groups (e.g: we will flush small pages and constantly resetAggregationBuilder). Additional condition here should be that aggregationBuilder accumulated enough groups.
Should these define the default value? If so, then addDefaults shouldn't be needed, right?
log with a message
Please use diamond operator, you don't have to repeat time a second time. ArrayList<Integer> a1 = new ArrayList<>();
Why using empty string as first argument?
Does this do anything outside of test mode?
this method is only intended to validate the ItemType. Configuration validation should be executed in processBindingConfiguration()
I think this is a bit overly complicated as we can only copy the file if we find it (e.g. fileToExport is not empty). Moreover, please show a warning in case it is empty.
Can you explain me once again, why we store timestamp directly in ProducerRecord and still also serialize it? Seems redundant.
I think we can just go with the  @ContextConfiguration @RunWith(SpringRunner.class) @DirtiesContext  and avoid extra loads for the the same config in each test method. I that case the outbound-gateway-parser-config.xml should be renamed to the MongoDbOutboundGatewayParserTests-context.xml
Shouldn't this check be at the top of this method. Should we ignore working copies all the time?
I'm missing the new field in the toString method.
TextComponentTranslation allows ITextComponents to be passed to it, so the user's name should remain as an ITextComponent.
DefaultStainCategoryService calculates whether to add the 's' or not, could this one too?
wrong order
Why do I get the itching feeling that we should to seconds--; here?
With this Cluster mode for spark may not work. Though it may not be needed since the spark-interpreter itself is launched in a new pod. Usually driver memory might require changes as per application being run.
that class would be better with a builder, though I wouldn't ask changing it now
nit - I'd suggest creating a new variable called requestedFields instead of creating the HashSet in-line. Something like Set<String> requestedFields = new HashSet<String>(attributeOrder). The result is the same, but it helps keep the code readable for others.
Change LIKE to =
add java doc what does it return?
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
I think it might be nicer to register an anonymous inner class here instead of having this expose the PathChildrenCacheListener interface. Once someone gets one of these objects from the getter above, should they be able to register it with Curator?
why?
This should be outside of the for loop, as there may be more than one set of temporary properties. Code: Ideally the logic from onClusterProvisionStarted should be extracted to a parametrized method, and called with different states from here and from that method.
Could you check for null or empty? Via StringUtils.isBlank
This whole block can be simplified, no? You're effectively checking for negative health twice now.
![MAJOR](<LINK_0> 'Severity: MAJOR') Extract this nested try block into a separate method. [![rule](<LINK_1>](<LINK_2>
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
why not check for null?
Typo
System.out.println ?! Is this the only option ? Isn't possible to use some logging library instead ?
nit: If we make this method synchronized, then this synchronized statement is unnecessary.
Try to use CollectionUtils.isEmpty instead
wrapping
This check is probably redundant if we sanity check if netId == WifiConfiguration.INVALID_NETWORK_ID and return false at the very beginning of this method. In WifiStateMachine#handleSupplicantStateChange we already have: // Network id is only valid when we start connecting if (SupplicantState.isConnecting(state)) { mWifiInfo.setNetworkId(lookupFrameworkNetworkId(stateChangeResult.networkId)); } else { mWifiInfo.setNetworkId(WifiConfiguration.INVALID_NETWORK_ID); }
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
You need to calculate the righ margin to account for the width
why did you change to final here? should be outside of the scope of the patch.
can you change name of this list because 'l' says nothing to me
Again, constants would be nice for readability.
Just inline the variable here.
Replace by Map<String, String> result = new HashMap<>(map.size());
I really like you are using HashCodeBuilder above. Why not use EqualsBuilder here (this would require to implement hashCode and equals in Provider too)?
Call Strings2.toStringAndClose.
You can simplify this a little like this: ColumnContextMenuItem<T> removedItem = items.remove(column); if (removedItem != null) { container.remove(item); } if the item didn't exist in the map, calling remove will return null.
Could you check for null or empty? Via StringUtils.isBlank
replace "ROW FORMAT " + s + " " with format(...) ?
Typo? What does this do? If partitionCapacity is null, this would throw a NullPointerException.
And this one is good, too.
constant or lineseparator from system?
Cannot render banner ad. -> Cannot render interstitial ad. AdMob console -> AdMob UI. Please apply this across all messages.
Let's be a bit more specific here: ("No FBO is associated with URI '" + arguments[0] + "'")
These can't be thrown anymore?
nit: Suggest renaming iterations and its getter as well here
Shouldn't we add the Transmit options field here?
No.
Can you use getUnchecked here to avoid execption swallowing?
Technically it's the connector (jr://file vs. jr://file-csv) that differentiates between the two. I think this is ok, though.
This method should also synchronize on 'drivers'.
"is handled as if"?
I think we should remove ObjectTriples... Originally, I created it as a Map. Perhaps we can modify ObjectTriplesIterator to TopicIterator that returns a Topic object when .next() is called.
With those 2 lines, you'll instantiate a new FilterInputStream whenever this method is asked. Instead, the generated filtered inputstream must be stored as a field and returned if already existing.
Can you use MediaType.PLAIN_TEXT_UTF_8 instead?
This doesn't seem to ever be set to anything else?
missing the byte order: pcapPacketHeader.order(fByteOrder);
object -> function?
Is this effectively adding the external context? Is it guaranteed that the external context will not be returned from request.getRequestURI() already? (otherwise, the external context will be in there twice).
maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?
Why new String?
I think it would be clearer inside the previous 'if' clause. I.e. if (action.isSetLease()) { ... if (action.getLease().isSetStorageDomain()) {
Per @sopel39 sueggestion: replace inner and outer loop to make better use of CPU vectorization.
Let's take this out as the user can already do jwt -> jwt.claim("scope", Arrays.asList(scopes))
I would use stronger wording after the last comma, like "which usually leads to bad query performance." (Additionally, I'm not a native speaker either, but I believe you either need a "that" after "Despite" or use some other word, for example "Although".)
If you add condition hint to card then you can improve card's usability for users. Search for example: * .addHint(new ConditionHint(LudevicNecroAlchemistCondition.instance, "Player other than you lost life this turn"))); How to add: 1. Extract checkTrigger code to Condition object; 2. Use that condition in checkTrigger; 3. Add condition hint to ability. You can use same condition hints in your another PR (#6430).
style nit: no braces, more occurrences below
I believe this call is useless when we have 150 instances
Please add null check for volume.getAsyncTask()
Never. The thread sleeps in L454 until all remote sub operations are finished. We can unlock before handling result.
Here is another one.
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through here.
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
if (f.isCancelled()) {...} else if (f.error() != null) {...} else {...}
With the requireNonNull, the null check would be redundant... I think...
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
Why should we need this logic? The logic, including the null check and duplicate check have implemented in org.apache.dubbo.config.context.ConfigManager#setApplication. Why should be added it again? So as the other change in this file.
@dkayiwa Are there any visits without patients? Should this not fail with an error?
Do we really want this to be public?
@tarilabs I usually like to check that the ServiceResponse succeeded before doing any other assertions. It helps to quickly narrow down environment issues when the test suddenly starts failing for no apparent reason.
you can mutialize this code
Have you considered using Regex with groups to parse the string. This would prevent some method calls and be shorter. Especially since the pattern is always the same - only the values differ.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
It's redundant if makeRequest is used to send request.
This won't log the error. We want to use the public void error(String msg, Throwable t); overload, so we need to change e.getMessage() -> e
doc
what if WebFaultException caused by absence of permissions to execute this query?..., i'd suggest using runQuery() and analysing return-value instead.
assertEquals takes the actual result as the first parameter, but the expected result goes first here (the result is the same, but just to be consistent with the API of this method). Let's rename correctList -> expected and testList -> actual, and we can do assertEquals(actual, expected).
IStateEx or IArgumentEx.
shouldn't we use Builder here. coz, no one outside the package will have access to constructor.
suggestion filtered = StringUtils.replaceEach(input, searchList.toArray(new String[0]), replacementList.toArray(new String[0]));
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
externalize string ?
why did we use cast here? can we change it to -1L?
One of the need for acceptSession() API was to show user that it can fail. if session does not get accepted they need to do something? Either go to next session or have some code to log message about it.
It seems like the number classes in java 1.8 have BYTES size constants (like Integer.BYTES). We could consider using these here.
Please define s1 as final, it causes build failure!
why 'scriptClass'? this should be something more generic like eg. 'pluginClass'
why not this String nodeSourcePoliceClass = StaticPolicy.getClass().getName() ?
Please use try-with-resource for OperationContext creation
why not instanceof ?
How about adding the toLowerCase() here and then it wont be needed later?
Shouldn't those line be removed?
checkList ? u mean errors ?
Why return null?
Don't need to call deleteOnExit
i'm really not sure why this is hard-coded for TextView?
Rubbish
int mapSize
What is the purpose of cumulative after this change? When is map cleared?
As far as I understand, we can get rid of explicit type parameters is such calls
assertThat(build.getConsole(), containsString(customWorkspace))
Create the tool section between the layer and the first mapping. Then pass it as parameter of each createXXxMappingYYY method and in those methods, you will have the possibility to create a creation tool correpsonding to each mapping, link it to the mapping and add it to the tool section. ContainerMapping -> ContainerCreationDescirption EdgeMapping -> EdgeCreationDescription NodeMapping -> NodeCreationDescription
Why is it better to use more than one scope to test?
What about this else case. Here also scheduling fails but we are not showing any error?.
Add the command that is being executed to the log
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Could be a try-with-resources.
1 -> numInputChannels ?
(implementer's choice) - we don't check for -1 here, it'd be ideal to encode this in the type system
Missing final
Consider to use negative condition here, so it will just return false when the super CDA will return false. Also use the formatter on the if condition (add space between the if and the call to super)
suggestion Assert.notEmpty(query.getIds(), "No Ids defined for Query");
Simpler would be to call this method from the overridden initialize() method from this class. That way you will not need the templateValidate() method in the upper class at all.
can you also test the case with begin > end?
All configuration attributes should be taken from the model, not the widgets.
Isn't a LinkedList better if we don't know the size (to reduce reallocations and copies)?
I would have put it after the createAnnotationAndAddSubscription call.
fos can be inside try ()
Do you need all those empty lines, its a bit confusing to read
Remove this check after merging #139 to develop and synchronizing this PR with develop.
Need to use parameterized logging instead of string concatenation. This should also be a warning and not an error.
I see that this was the behavior before this change, but is it intentional that this method just logs an error message, but still completes successfully when the bucket name is invalid?
Good spot! We could actually do this: java authCardDetails.getAddress().map(AddressEntity::new).ifPresent(addressEntity -> { //   });
Can't you create a function that will create Observable from current operation and apply scheduler? Will save 2 lines in each operation. Same is applicable for Completable and Single, I believe :)
assertThat(entries).hasSize(3); the same for several occurances below
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think we'd want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
Shouldn't we use empty list here ?
replace with persistCommandIfNeeded
Is Itemizing (or promoting parts of) request option, to limit to applicable ones?
Exception is never thrown
Do we need String.format here? Seems like String concat would be fine.
Use FileHelper.safeClose(rs);
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
If this is only for testing, use stream api
Variable naming. Be consistent across the entire codebase. why sc? sock or socket?
error message should be changed to reference actual problem of "not a leap year". See existing implementations.
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue(), "%") which basically does exactly the same.
I would suggest we add one more console operator that would receive POJOs. Most downstream operators expect a POJO hence having it in example would be good.
if(!(o instanceof LegalInformationComplete)) is better, will not break the equals contract in case of inheritance.
Rename this local variable to gid as well, like the overall renaming you have done for lrecId.
why not null as value?
Do you want these to throw a ValueExprEvaluationException in order to follow the Function interface contract?
overall the commit is very good, but this method might be misleading - it doesn't set anything if the field belongs to a probe.
I would consider cleaning this up using JSONObject -- since this JSON is currently pretty simple and this is only test code I wouldn't let this stop ship. That said, I'd much prefer to see something like the following  JSONObject json = new JSONObject(); json.putString("id_token", TEST_IDTOKEN); json.putString("access_token", "blah blah"); ... return json.toString();
This should be replacable by switch (solverStatus.get()), as all the actual state mutation happens in solvingTerminated()/solver.terminateEarly() as I've suggested above.
since we did not advance so the event is not thrown away really.
Mind renaming this to just requestOptions, as we removed the includeResponse flag?
spacing
We should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED.
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
They are mutually exclusive? Or is that a micro optimization?
start
there is no separator between the versions. would you mind replacing this with : for (int i = 0 ; i < versionSet.size() ; i++) { sb.append(version.toString()); if (i < versionSet.size() - 1) { sb.append(','); } } return sb.toString(); In addition, it seems that this will become common around, maybe it should be pulled into new class, say VersionUtils ? (the class could be added next time there is a need for this).
It can be written as return restTemplate.postForObject(verificationUrl, request , JsonNode.class).path("success").asBoolean()
You don't want to use an exception that extends MyNakadiRuntimeException1?
Is there a need to move from getters to fields here?
Is it worth moving the reporting out of the synchronized block (though I wouldn't expect convention on that span)?
use arrays.copy? or system.copy?
Use logging instead of e.printStackTrace()
Typo: reassigned
It would be helpful to indicate what is invalid about the name. Is it the underscore at the start?
You can use CollectionUtils.toImmutableList
Spacing is wrong, Ctrl+Shift+F this part
@bxf12315 Set<String> set = Collections.singleton("Extra");, also instead of "set" it could be named after set of what it actually represents (for better readability of the code), so e.g. in this case Set<String> headers... or something like that.
Here should be NOT_INCLUDE_DEFAULTS
need to add them here
This should check the endorsedBy field I guess, since that is what is displayed in endorsed responses.
why not process all files?
Put ITEM in front of OTHER_FUNCTION
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
This should be log.error. Don't know why other statements here use log.warn
highlight this and extract maybe into a method that return bool
suggestion throw new RuntimeException(String.format("Failed to parse geometry from bytes: %s", BytesUtils.toHexString(argumentValues[i])));
Minor: same as in other number check, WDYT about checking for the decimal point?
If the store is already started, I think we should return true. Same for stop (return true if the store is already stopped and don't try to stop again)
Use constant
why not set serverCnxnClassCtr to NIOServerCnxn by default to avoid looking up the right constructor every time we want to create a new connection (a bit of a hot path)?
setText in both cases (null defaults to empty and the append is not required, is being called as set).
Suggestion: "--active and --inactive options are mutually exclusive."
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
Let's move System.currentTimeMillis() somewhere to one source, as sharding logic is dependant of time and we may need some accuracy tweaks for it in future or whatever.
Trying to follow this. The check above has failed, so this is handling the transactional case, which means we should be in the abortable or fatal error states. If we are aborting and we can bump the epoch, then sequence numbers will be reset after receiving the InitProducerId response. If we cannot bump the epoch, does it make sense to reset sequence numbers here? It should be for the partition that raised the UNKNOWN_PRODUCER_ID error, but how about the rest?
Let's move this line below, just before the requiresFBO line.
formatting
Need to parse currency separately to notional schedule, with notional schedule parsed in parseRateCalculationLeg. As it stands, you've made notional mandatory for parsing KnownAmountSwapLeg which isn't true.
Should we consider other measurement units, like kg?
There is no need to mock api calls to implement this test.
this should move to the applyUserChanges method
please verify response on remove()
It feels to me that there is much code duplication between this and DateTime.truncate
This block could be shortened if using Ordering.nullsFirst()
This variable is very badly name if it's supposed to be the serializedUserReference.
also these *xx things should be constants.
create a member for ClusterServiceModel
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then it will add another *. We shouldn't add the slash if it already ends with *
format as final String[] array. Rename to errorMessage if possible
It's advisable to start variable names with lower case
This can't be moved, the sleep above needs to happen after the call.
You can simplify the if-else block to Java if (path == null) { return other.path == null; } else { return path.equals(other.path); }
brokersResult.brokerResult looks a bit unclear. Please consider renaming to something like addResult, registerResult
The status are not unique so it pointless to have assertions for those fields, instead you need to compare the database id to ensure it matches the expected.
why exit here ?
We already checked post != null above.
Please rename this to eObjectMatchEngineFactory or something closer to the real use.
nit: can be final Vector<URL> resources = new Vector<>();
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Is there a need for an exp claim, and do we also need to account for time skew?
typo
Could not this run through without asserting if the Converter is never called?
I don't think this optimization of repacing .equals by '=' is correct. I suspect there are cases with dynamic metamodels where we won't have the same instance of feature on each side of a comparison...
Ok, this is what I don't quite get. Why is this feature being removed here?
/s/else/elseif
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
- disabledFg Color variable should be created only when needed. i.e. after below condition is met: if (foreground!= null) {
ImmutableSet<String> itemUris = StreamSupport.stream(items.spliterator(), false) .map(Item::getCanonicalUri) .collect(MoreCollectors.toImmurableSet());
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
@Serranya same here. See above.
why not use UNSPECIFIED_ALTERNATE_ALLELE_STRING here?
Would it be better to do something like this instead of catch(. . ):  finally { if (!ackCallback.isAcknowledged()) { AckUtils.autoNack(ackCallback); } . . .
suggest rename to innerHadoopShardSpecLookup - "hadoopy" is easy to mistake for "hadoop" when someone is reading this code
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
looks like directory separator is missing here
nit: We should verify the results are not recorded here as well.
What's the chagne here, just whitespace?
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
try-with-resources for FileReader
velocity..
Nit: Could you use Isolate.MAX_PRIORITY to make it clearer what the value is?
![MAJOR](<LINK_1> The Cyclomatic Complexity of this method "restartInErrorTask" is 13 which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_3> ![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: org.ow2.proactive.scheduler.common.exception.UnknownJobException, org.ow2.proactive.scheduler.common.exception.UnknownTaskException [![rule](<LINK_2>](<LINK_0>
K **is** comparable because K extends Comparable<? super K>. We can't use natural comparator here. I believe this is correct fix:  java final Comparator<Tuple2<K, V>> comparator = new EntryComparator<>((Comparator<? super K> & Serializable) K::compareTo); RedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty(comparator);
We should add some log to the validation process
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
This magic number needs to be a named constant somewhere.
Remove stack traces
Preconditions.checkArgument() on all non-null arguments to prevent bad config
Unsigned types are not used in the current implementation. So, you can omit them.
nit: Same here. Leave the checks in the switch and do the assignment at the end: this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
This can be optimized to a simple messages.get() if the underlying Collection is a Set.
We don't really need to create a new deserializer for each request.
Don't catch bare Exception
why is there a sound on sendString - it will be mostly user initiated. Am i missing something?
Please replace with a singleton
This won't generalize. I think you need a method to get a feature ID programmatically.
Don't need a line break here as well.
baseId +diagram
this noopSubscription seems used in many places, create a single one and reuse?
I am assuming nestedActivity is already defined elsewhere in the project
GitHubSCMNavigator. suggestion NamedArrayList.select(all, Messages.GitHubSCMNavigator_withinRepository(), NamedArrayList.anyOf(NamedArrayList.withAnnotation(Discovery.class),NamedArrayList.withAnnotation(Selection.class)),
whole block indented one extra
Its better to cleanup the Archived message on a server restart. Call deleteElapsedArchivedMessage() method if we find any archived message.
The amount of duplicated logic we're amassing is concerning. This is going to be painful from a maintenance standpoint.
A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge
There must be a more succinct way of doing this using streams.
Why do we have to check read scopes when we commit cursor ?
Does this need to be a left join or would JOIN FETCH be sufficient? I don't think there would be an entry in this table if the association wasn't there.
> "org.hibernate.javax.persistence", "hibernate-jpa-2.1-api", "1.0.2.Final" Good candidates for constants
I'm not sure, but there might be a problem when destinationGroup == null if you try to check authz for VO/Group admin role. In such case you should probably check only VO manager role (on movingGroup).
You should check for entries: - exisiting in HEAD but missing in index (files where you already executed 'git rm' but have not comitted that) - symbolic links - submodules Even if we don't support all the bells and whistles of native git's ls-files we should not silently ignore links and submodules.
@Override
double check that the group is still here
I'm assuming we can't use something from Joda because there are sometimes stupid dates? otherwise ISODateTimeFormat.basicDate() should work.
Any better naming?
did you want to remove this throws IOException as well?
I think we should not be hardcoding the type here again, and instead use IndexableClaimedTask.TYPE or similar
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
Sync on the _instanceMonitorMap while you are reading the map.
"error".equalsIgnoreCase(...)
@prateekm and I were chatting, proposed that having a different grouper - AllSspToAllTaskGrouper would be cleaner for this scenario. That way, we don't muddle the existing Grouper implementation.
Args need to be included in operation.
Here it is going to depend on the resilience strategy ... so hard to say. I would drop the operation result assertion though.
Removing test because you can not fix it is usually bad idea
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
getSourceVmFromDb can return null..
can you add some docs around this method.
Can we name this something other than it? Even i would be better to me than it.
How does it sound: _Response for the key may have arrived earlier from another server_?
I am not familiar with the script cache stuff, but this will delazify the cache contents and hold it all into memory. Is this okay?
Use .setBoolean() method.
Unfortunately, this cast doesn't work. Even if it did, not all the returned columns are longs (the AVG ends up as a double). From my fairly rudimentary knowledge of JPA, mapping the results of a query to a POJO without involving an entity or a bunch of XML is a bit of a pain. Using a native query makes it more so. However, your query is not actually beyond the capabilities of JPQL, so we can use plain createQuery. Something like this should allow us to get a PerformanceReportEntity object out:  SELECT NEW uk.gov.pay.connector.model.domain.report.PerformanceReportEntity(COUNT(c.amount), SUM(c.amount), AVG(c.amount)) FROM ChargeEntity c WHERE c.status = :status  But perhaps someone with a better grasp of JPA than me may be able to offer a better suggestion.
It's not necessarily a build script - only if the resource is a file.
@mykelalvis please, rename to server. s is meaningless :)
please format query
Unsigned types are not used in the current implementation. So, you can omit them.
I think this can be called multiple times in the current design, which might cause bad things to happen. Potentially this should only return files that are not already in the queued files set?
Can you report a span and verify that both senders and reporters were actually called?
I'd extract this into a method isUnset(Diff) as well. Don't we have util methods for determining whether it is an unset? They seem to be very generic and maybe should go there, if we haven't them yet.
Which are the callers of this method? Are there any side-effects if an empty array is returned at this place?
example (with an a)
please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method if there is too much condition
What is the purpose of this logic? From the xml file I can tell that the 0210 thing has this channel, so why do you have this check and addition logic here?
This seems like it should handle the exceptionsl ike the RuntimeException block from above. Why make the distinction here?
Did this convert it to a Callable or a Runnable? I believe this is why it wasn't inlined before.
TransportException is not just a wrapper for other exceptions, so where it is thrown and it's (sub)class is important, just pass it as the new cause.
Again, needs a more descriptive error message please. In this instance we likely need to log something like "Could not create Item in Collection with UUID=[uuid]"
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
If someone calls offset.reset() (topN does this sometimes) then this will be wrong. I think you need some logic to detect the offset going backwards, and resetting the iterator in that case.
Use TreeMap to keep the order.
nit: you could skip this announcement if details.location was already same as location.
Could there be a case where savedInstanceState would not be null? If yes, how would we handle that case?
You can remove the surrounding brackets.
This should be using parameter.requiresCast() which is the logic the original method uses.
This won't do anything since metacard is a mock.
Why are you suppressing exception here? Let the runtime exception bubble up. This is changing the behavior of the wrapped processor.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Same thing, using this method here may cause the getLinePixel method to return erroneous result, which may cause regressions in customers (I think code minings actually use this method extensively to compute where to draw for instance)
Move this to after ePackage.getNsUri() check?
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
getBigtableWriteThrottleMs() returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableWriteThrottleMs() ValueProvider into a "true" or "false" for the google.bigtable.buffered.mutator.throttling.enable value
RuntimeException will be sufficient
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
The context type is a 'type', not a 'mode'
you should also do withRepresentationProperty(DS_ID)
I think in this case we want to revoke (not lose) the partitions no longer in subscription?
You're better off pokemon-catching these.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I would prefer usage of docker exec instead of DockerProcess. In that case it won't be presented in list of processes, and you won't need workaround in 100-102 lines of DockerProcess.
nit : It seems only the anonymousResult needs to be a field in the class, rest can be removed ? In case you meant this class to be used in JSON serde, please add @JsonProperty annotations to the fields and create their getter methods.
This null check should only be applied to the loadProfileImage() call. The profileImage variable should be assigned regardless, as the whole point of it is to store the image for when the view is initialized.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
"due to".
context.getEntityType().equals(EntityType.FEED.name()) should do.
We are aborting refresh by breaking out of the loop and basically, we are done refreshing master stubs. Better to log this at ERROR?
There's a typo here, it should be no authenticator jar files.
What kind of exceptions are we expecting here? Shouldn't the queue be forcibly cleared if drain throws an exception so that later invariants (isEmpty) are still true?
Integer.SIZE here as well
suggestion Preconditions.notBlank(path, () -> "File [" + path + "] must not be null or blank");
change variable to something more meaningful
I don't think it's necessary to create a set here since it accepts collections and then tries to figure out the fastest way to check them.
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
Please avoid unnecessarily nesting if blocks. This method could be written as: if (getName() == null) { return getPersonId(); } else if (getPersonId() == null) { return getName(); } else if (getName().equals(getPersonId())) { return getName(); } else { return getName() + " <" + getPersonId() + ">"; //$NON-NLS-1$ //$NON-NLS-2$ }
Given that the Ant task already checks for the existence of installUtility, shoudn't we just combine the logic from lines 97 to 105 like this:  // If we have the kernal JAR and the product jsons exist, then we use the kernel. Otherwise just use installUtility. if (getMapBasedInstallKernelJar() != null && !downloadedJsons.isEmpty()) // do the installation using the kernel else // call installUtility
format as final String[] array. Rename to errorMessage if possible
add a message containing both values, in case it ever fails
why is it adding null?
mark this method private as this is only used in this class.
I am wondering should we use a ConcurrentLinkedQueue here instead? It is a collection that provides duplicates but in a non blocking fashion.
nit: instead of the boolean here, would be better to use an enum (would make the test clearer) or two methods runSslConnectionTestWithoutClientAuth, etc.
I would be more defensive here. I would check if the num of containers returned by getContainers() is > 0 and if the value returned by getImage() is nullOrEmpty
The same here than for PreviewImageFragment.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
One more times(1).
Could throw IllegalArgumentException instead.
Can we perform an early return here if mUseTimer is false?
We need to enforce TCP connect timeout and read timeout, apply reasonable defaults, and make the timeouts configurable.
Can you use a more relevant variable name?
I feel like we should preserve the current behavior, and the verbatim behavior should be turned on manually with some option.
Why do you need to add dates to the list? Why do not to use reminders list size? Does Realm have count function?
Cosmetic: Braces on a new line, please. :)
Also mention that they will be ignored
Typically we use Map on the left hand side rather than HashMap
I think isEmpty() is more preferable to this construct.
i don't think they are all supposed to be uppercase. in fact, i think in the wiki the acceptable values are: -beta -alpha -RC -RC2 - same as the three above but with a version appended
1. Change Exception to exact exception you get 2. throw the exception after log or don't catch it here
assertEquals(org.apache.log4j.Level.ERROR, event.getLevel());
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
Both lines dealing with the provider should be moved together, following the usual pattern: if (x != null) { x.dispose(); } x = null;
let's call it updateCodeMinings() instead.
Can this be private, or is there another use case for default attribute outside the builder's call?
I mean that setBytes(1, null, 0, 1), setBytes(1, null, 1, 0), etc. should throw some exception (NPE or other) instead of returning 0 to indicate a problem.
Could you correct the error message while we're changing stuff around here.
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
Can we move this above cGroupsCpuResourceHandler.prestart()?
"Entity" + id
I would have this test within the flow from yield method in fact, so the algorithm is pretty straightforward and the method to compute flow from yield will only do so if required... (and return an emtpy list otherwise). (In fact if I'm correct you actually don't need that test at all...)
Is this still needed if the value gets overwritten in the next line?
Isn't this problematic, since the byte-array may not be a string, and it may not even be decodeable as a string, so this could throw.
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
Add another OS to the set, just to verify that only the right ones are ignored.
Like above, using the absolute path should accomplish this properly
This could still be helpful right? Or maybe the reverse logic. Maybe left should be the shorter one?
I can see why this is necessary, with the change a few lines above from 'indexOf(".")' to 'lastIndexOf(".")'. However, there are two things I don't like about it: * what about, say, "model.profile.profile.di" ? (granted, unlikely, but handled by the previous version of this code) * more seriously, this hard-codes an extension that is defined in a <diagramCategory> contributed by some plug-in on the org.eclipse.papyrus.infra.core.papyrusDiagram extension point. Other plug-ins can define additional extensions that aren't enumerated, here. Rather than hard-coding this, we should look up the extensions that need to be trimmed off in the DiagramCategoryRegistry
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
maybe name this, offset-before-start.zst?
Would it be too nitpicky to question why there is an intermediate rolls variable? dice.getRolls() is just as descriptive and it's only used a couple times below. Removing intermediate variables is often a good thing, one less thing for a maintainer to keep on their mental stack when reading code. At this point when reading the method, there are 3 variables in scope, soon to be a 4th one, leaves little room for much else!
@tsurdilo take a look at org.jbpm.kie.services.impl.CommonUtils.getAuthenticatedUserRoles(IdentityProvider) that does some additional logic in case roles are empty list. There is an issue with some dbs handling empty list as part of in clause
space before {
It would be nice to create constants for these props in AccumuloProps class.
Logging.
Try to truncate some of these constructors. Add a \n to break up the parameters.
change this to node.isPartial()
@maria-farooq we should provide a description to the log message
Single pass is needed here.
I think for contacts it would be better to use Number: instead of Id:. Otherwise it looks good!
I would prefer the format to use id next to the entity type, like  log.info("{} removed attribute {} from member {} in group {}",...
why?
If you ever make this public this _ will break the JavaBeans specification.
This is ugly, see my notes in the token code.
f.isFile() is better since it checks if .project isn't a directory accidentally.
sb.length() > 1, please
you can move the declaration to the initialization.
Not really.
this will go to the char after '[', is that OK?
Since Rx is optional, would be great if you add a check, I've added this in Hawk.java but that can be moved to utils and used here as well.  java private static void checkRx() { if (!Utils.hasRxJavaOnClasspath()) { throw new NoClassDefFoundError("RxJava is not on classpath, " + "make sure that you have it in your dependencies"); } }
Yes this makes things less racy. Why not use a CAS loop here to make even less racy (especially as we have a volatile field updater available)? Might be overkill I grant.
should be named resource
Including ip.toString() in the log message does not make sense here - it's a DynamicLookupInjectionPoint instance with no meaningful info.
Sorry, but I don't think this is right: IMO the new eventually calls should be exactly where the sleepThread calls were
Import this.
You can do this a lot cleaner with .post(Entity.entity(mandateConnectorRequest, MediaType.APPLICATION_JSONTYPE);
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
why did we remove the optimization here?
ExtensionNamespaces.LBAAS to be consistent with the alias name.
final is unnecessary here
Could you please add clear message for case when assert failed?
Use unadj.stream() ...
this should be a while loop. while(it.hasNext()). Common variable name for iterator is iter or even itr.
use Arrays.fill instead for loops
You need to also store the lastStartTime: long lastStartTime = prevFullState == null ? -1 : prevFullState.get(statusQuark).getStartTime(); Also, lastEndTime can change for the same attribute while it's being build and below...
Let's be more explicit, to clarify that that noDictionary is being overwritten by aggregateMetrics for the column.
Use " List<String>" instead of ArrayList<String> in declaration.
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below the line 187 and remove this check.
Could this be  return reportingCurrency.getCurrency().flatMap(function.naturalCurrency(target));
I think fallback should be project.getDisplayName().
just use context as sync obj.
Would it be appropriate to add some logger.warn() statements to these two IFs, to make more explicit what's happening, both here in the code and at runtime?
Please mind if I ask, but what would happen if the request reaches this line?
FIXME: Don't cast getActivity(), use an interface.
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
Sadly checkstyle isn't as strict as I would like. We could probably do a custom regex for it.
return (this.sslContextDependency != null) ? this.sslContextDependency.register(builder) : builder; :)
This is very odd; not the sort of thing you should catch. Can this be prevented?
The existing return output.repeat(2, (long) getN()); should be replaced by:  try(MemoryWorkspace ws = workspaceMgr.notifyScopeBorrowed(ArrayType.ACTIVATIONS)) { return output.repeat(2, (long) getN()); }  We don't want this to be detached instead.
Remove this line too because the variable "configuration" will become useless.
markDuplicatesWithRemovingDuplicatesIntegrationTest and secondarySupplementaryUnmappedWithRemovingDuplicatesIntegrationTest are exactly the same. The contents of the test should be pulled out into its own test and the two separate data providers should be one line methods that call the abstracted test.
When assumption fails it emits an exception that is ignored by the runner (effectively, later part of this test method is not executed)?
in all these OseeArgumentException constructors, you don't need to use String.format, it does that for you.
Logging statements can happen outside of the lock.
parameters.putIfAbsent(parameterKey, new ArrayList<>()); List<String> cheServiceParameters = parameters.get(parameterKey);  May be rewritten in Java 8 style  List<String> cheServiceParameters = parameters.computeIfAbsent(parameterKey, (key) -> new ArrayList<>());
camelCase
uuuf... each of the Class instance is probably serialized to a FQCN-long representation, that's easily 50 bytes. With 2 classes and 2 wrappers, this is 200 bytes per command. Isn't there a better way?
please extract as constant
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
I think you might want "icsCode >= 1". ICS means "Inherited Certification Status" (i think?) and it is not a boolean but a count of the number of times something has been inherited... so it can be larger than 1.
The 'when' can be dropped from the log statement.
Can be replaced with method reference.
Shouldn't it be MAX_BROWSER_NAME_LENGHT - 3? Or, if you want to save 2 chars, try using an ellipsis:   (\u2026)
Do these need to check itemToBind?
i think something is wrong here, when host moves to up this command is called, status shouldnt be non operational, also the reason, so this always returns true?
This is probably not the right example. This specific problem goes away when you use the Right R class here. Can you modify this change to repro your case i.e have another module refer to the resource in its main code and this module invokes that piece of code in it's test?
Generics on the right side are redundant since Java7
should be singular, VTIDSection. It's not like in French (ex. un magasin de souliers vs a shoe store).
I would rename the original createAuthConfig() to a private method with a distinguished name to clarify that this should be the single entry point.
Food for thought: When the user clicks Back after visiting a random article from here, do we want to show the same random results she saw before leaving this fragment? or should it be a new set of random results?
Can these be declared at class level and used for both methods?
I would create a private static checkArgument method for these checks
Can you call this maxIterations, as the actual number is rather determined by the termination criterion?
Maybe we could also add _seq_no or so to the RETURNING clause here. As that is one of the use cases we want to enable
TimeUnit is easier to read than the SystemTime constants: timeToLive = SystemTime.getInstance().milliseconds() + TimeUnit.HOURS.toMillis(1); I had to read your code twice to pin down that TTL is creationTime + one hour. With TimeUnit, its one read to understand.
Can we use a immutable Vavr map instead?
Please move listener to desired mode
Use StringUtils.isNotBlank instead.
I think It's needed to convert to milliseconds.
@mariebawanan I think the proper fix for this is to remove the duplicates in variables VariableTypeList instead of just filtering out the duplicates here.
Returning a class instance _or_ a null? This calls for an [Optional](<LINK_0>!
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the command.
final IPath pathString = Path.fromOSString(path); is needed and pathString needs to be passed to the createLink() method below. That's why the Unit test fails.
The more appropriate thing to do here is Log this message
ERR_DELETE_ERROR, add if there isn't one already
"Encryption failed"
only one element? maybe try to use singleton set
should be callback.readFromCache and getFirstPageGroups(bridge)
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
In this case, we should show the API Status message to the user
Not necessary. The web plugin should be bound in the Gerrit-HttpModule.
While I applaud the use of format, this syntax may lead readers to think the value of add.size() is the argument to size. How about "add.size == %d != %d == distances.size" ?
The reason why ReachabilityChecker supports reusing an existing RevWalk (instead of maintaining our own), presumably, is so that we can save on object parsing. So I think it's less flexible if we set this here - the caller should be setting it if they know that they want it.
method.getMethod() is already clear. You don't need to extract this method. Please get back to method.getMethod()
You also need to update the text of the menu button here.
Would it be the same to say lemmasList.addAll(keyValues) here?
IMHO it's better to explain proposal of setup debug id here to prevent occasional removal in future, like the follow: > do not remove debug id; it's needed for selenium tests
Does the segment delete need upgraded locks?
suggestion return new PgClassTable.Entry( OidHash.relationOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name(), info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
Nit: No need for final variables.
on the catch, let's add a servere logger
I think we should prefer a setter here rather than member variable access.
Could use sl4j parameterized log statement. suggestion log.info("Looking for matching filesystem for {} from options {}", exportDir, tableDirs);
So did you remove the null checks?
rename this to checkCompleteContext please
Missing opening "(" before getDescription().
There are enough mock objects in here that it's worth using @Mock annotations instead.
Why not just pass in only the message?
The cast is not needed
This sometimes leads to IllegalStateExceptions. That's why I switched to startforegroundservice recently > The startService() method now throws an IllegalStateException if an app targeting Android 8.0 tries to use that method in a situation when it isn't permitted to create background services. > <LINK_0>
Collections.singletonMap() ?
Perhaps also desirable to call track(Node, Credentials). (For BindingStep, just inject a Node; for SecretBuildWrapper, use the method on AbstractBuild IIRC.) @stephenc any guidance?
don't wrap at .
move to start, no need to loop if tree is not checkable
same as others: log should have Exception as arg
It might be better to use Collections.emptyMap() instead of new HashMap()
Sad times, but I don't think we can easily work around this.
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
This line is redundant.
Nit: this is duplicated at line 48, I would get rid of this line.
Use type.getObjectValue to print the indeterminate in the error message to help user debugging: java throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "map key cannot be indeterminate: " + mapType.getvalueType.getObjectValue(session, keyBlock, i));
There seems to be a convention established to update these metrics. For e.g. replicationMetrics.updateMetadataRequestTime(metadataRequestTime, isRemoteColo, isSSLEnabled, remoteDatacenterName); Is it possible to follow the same kind of convention here (updating via a function)?
Maybe mix multiple timezones? The idea really is to trigger a failure, so let's not make it easy for tests to pass... In particular, I would use local date/times that are not ordered, but become ordered when you take into account the time zones.
This should have the data source name in the message and add the actual identifier as metadata on the alert. The messages are what turn into the email subjects... Also, after the alert happens, this is going to fall out of the if statement and do other things. Are we sure that those other things are what we want it to do?
Is it a conscious decision to throw an unchecked here?
hint: can we merge all these three "if" clauses? The same goes to equals method. You can break lines before "||" for better view.
why if is here?
We shouldn't ignore an invalid enum value.
Why are you not using your UsbSerialDeviceInformationGenerator?
I would have moved this line after this.killNodeImpl(node, host); to be sure that a node is deleted and forgotten only if the runtime on the remote node has been really killed, otherwise the information at the Scheduler level may be wrong. Same apply for other infrastructures.
typo _start_ -> _stop_
It would be better to strictly align these variable names with the method names. Since there are methods of both Resource and ResourceInfo, I would suggest to also include the class name. E.g., - resourceSetResourceInformationMethod - resourceInformationGetNameMethod
Since Preference changes may occur due to outside stimulus, we should bail if getActivity() is null here.
Where is selector.close(). It is not in NonBlockingConnectionManager::close() (which is where I think it should be).
well, the probability is very low, I know, but shouldn't be >= ? in terms of readability I would prefer to have if (fetchTime.compareTo(vmManager.getLastUpdateDate()) > 0){... } else {.. } - but that's subjective I guess, so for your consideration
So you have default settingsfor userId and NetworkAccessPointId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
The check item.getUrl() != null is not needed.
Why is it required to do it for every event type in the subscription?
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
Well, if we know the Exception so its not really "unknown" :-)
looping with a char is kind of weird?
typo
docPossibleAncestors and revPossibleAncestors?
This test against methodName seems to come too late. For efficiency, it could occur after the assignment and before the reassignment. More importantly, can methodName ever be "<init>"? If the method is <init>, wouldn't node have to be a ConstructorInvocationNode? Also, the reassignment could occur within the receiver != null test.
I wonder if we're getting to a point where we should have an isComplete method on our entities to check this kind of thing without needing this kind of code in a number of places.
nit: it would be more efficient to keep a local variable with the count, and update the meter at the end. i don't have a great sense for how expensive that getMeter call is, but i assume it has to access a couple maps
The more I think about this, the less it makes sense to me. Specifically in the end of end-of-form navigation or register from case list (entity list <action>'s) you could add the session frame  m_0 case_id_one case_id_two  to the session, and have two menu declarations you are jumping to, each with an entry:  m_0 e_1 - case_id_one - case_id_two m_0 e_2 - case_id_two - case_id_one  and e_1 and e_2 should both meet this check. If you visited the m_0 form directly, you'd expect to need to choose e_1 or e_2 first, because their order of selecting id's is different (and they may have different filters), but once you've chosen both id's, semantically both forms should accept the two.
Typo: Organization
maybe, it would be better to inline that actual following way:  java Matchers.containsString( new StringBuilder() .append("<a>") .append(System.lineSeparator()) .append("<b/>") .append(System.lineSeparator()) .append("</a>") .toString() );  what do you think?
The purpose of this test is to throw inside the onError block. I don't understand why you removed the IAE
please replase MojoExecutionException for a new generic DeploymentExecutionException
> When we do have an error though (please see the Travis log or pull it locally) or a simplification (e.g. the Character constructor), we should definitely take advantage of Java 9's wisdom. true
You don't need this line because of green 31.
I think it would be better to have two asserts, one for each metrics file....that way when something breaks it's easier to understand where the probem is
All lines between beginning of this method (and all others) and this one should become the setup fixture (@Before). Then, for the methods that require a writer or loader, you could just reference the CacheManagerBuilder field, and append .using(...) as needed.
@xpdavid is this the right thing to do?
This is completely redundant as the Listener which calls this method already checks if it is cancelled. Also missing brackets.
nit: we should use a config for this value, maybe we can update it in next pr.
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
rename to automationContext
code dup. would be better to move it to private saveInternal()
Mmmh, I'm not sure to follow you here. What is bothering me is having two times the same message on the same tree (so a duplicate of Location). So why considering the kind of the tree and only the message value? It's probably way simpler to rely on equality of locations to filter out, with a LinkedHashSet for instance.
why not null?
Hmm. do we log tags? Probably a good idea but C Git doesn't.
Nit: Since you're not using the in variable, you could builder the isr in one step
To be super clear, wdyt about renaming mTryAgainButton to better match its new functionality?
EditedStyleItem item = (value instanceof EditedStyleItem) ? (EditedStyleItem) value : null;
is logics correct here?
Oh yuck. ;)
only if name changes?
Not relevant for this PR, but I'm curious: why is the TrustAllX509TrustManager necessary?
Redundant replicationSpec.isInReplicationScope().
Should we log a warning or throw an exception in the else of this if? I don't think we want to just quietly ignore a put call...
It looks like you are returning an empty ArrayList keys
this is not ok to schedule tasks using only delay from received header: - we should validate if value is within reasonable boundries (0, maxMessageBackoff) - we should discard message if retry-after is after message TTL to respect TTL policy
Let's make this log string follow the JSON format as well for consistency.
/s/else/elseif
All of this can be replaced with an ExecutorService
Mid return may worsen readability
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs)
why use domain id from parameters and not from storage object from method parameter?
Can you make this show a useful message back to the plugin?
This change looks unrelated to fluids? Seems like it belongs on a separate PR ;P
you have lost the cause e
Stick to java naming convention - variable starts with lowercase.
Probably should use combineDegree - 1 instead of hard-coded 1 here?
You may want to use assertEquals directly?
it might be worth having this as a constant with a quick explanation for why it is needed (emulator's deletes are not instantaneous).
Is this wanted functionality? Making a new list will mean that this won't refer to same object anymore, which was what was done in the original situation.
debug/trace/remove?
Why the single quotes (')?
why not use File.createTempFile() ?
throw something if sqlCompatible
This cannot be removed. The scheduled task needs to be saved.
optional nit: this is still confusing for me, maybe it could be reworded as suggestion Unable to determine max direct memory size. If druid.processing.buffer.sizeBytes is explicitly set then make sure to set -XX:MaxDirectMemorySize to at least "druid.processing.buffer.sizeBytes * (druid.processing.numMergeBuffers[%,d] + druid.processing.numThreads[%,d] + 1)" or else set it to at least 25% of maximum jvm heap size.
One of 2 things should occur here: - Opt A) throw the exception ( add it to method signature ); not the generic Exception, but the IOException one - Opt B) set file to null, so it ends up getting returned as a null object, rather than a corrupted one If none of the above occur, and in a scenario where some exception takes please, the person leveraging this method would never know of it, and rely that the returned File object is a solid one.
I think this might lead to unused space on the right, when one of the columns has a higher preferred width than it's maximum (because you don't redistribute the difference among the other columns).
This could be null, we should probably handle this if the JIRA api changes again
Remove this check after merging #139 to develop and synchronizing this PR with develop.
add the exception to the newly created exception
this should be outside the loop? Otherwise it will only check for the first brick in the list
Name it folder, or reuse doc maybe? domain is misleading.
Here you are setting activity argument to a presenter but the presenter is only presentation logic and a presenter should not know anything about Android Framework
Hard-coded. What if we add another format in the future?
This just follows what's done elsewhere in this file but we should make these more efficient and not read the entire model, which could be huge in a domain. It seems like this could be done with 2 reads, a non-recursive read of the root to get the host name (which will be available even without recursing), and then a read of the server config resources under that host.
We should never have to do a full permissions cache flush. Think about customers who have 1000's of sites with 1000's pages. This is too broad.
If you don't return here, this will run only after current repl dump execution? What is the order of execution in the current case?
This is sync can cause performance problems because it acquires locks inside the sync block and its the same sync as startCheckerThread() which every thread calls. Therefore it makes threads wait on each other unnecessarily, when they should be able to proceed independently if working on different keys. This is fixed in the changes I made in lbschanno/accumulo#3
Since it is major websocket endpoint it should be logged as error
suggestion if (reader.relationshipDirection() == Direction.INCOMING) {
Can be written shorter as while (cursor.moveToNext()) {   }
it looks like createMergeConflictInfo() always shows the warning, then adding the warning should be an implementation detail of createMergeConflictInfor() and the mergeResult needs to be passed to it as a parameter
Isn't the devfile detached from the JPA session when it leaves this method anyway? Why do we need to create a copy of it?
make this one final maybe? there should never be a reason to override this
Not directly related to this PR. But at some point, we need to update <LINK_3> <LINK_0> They say " It is the average amount of time it took for ack or fail to be called". But the latency is only calculated on ack not on fail. The original code <LINK_1> is implemented the same. I believe this is a mistake introduced in <LINK_2>
Instead of calling this, please move the progress bar further down in the layout xml file.
Local variable could be declared List instead of ArrayList. Is this worth caching?
Not needed to test emptiness, it's contained in condition below
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Have you intentionally omitted index check?
Better use Assert.fail
Is this expected to be just single udnerscore? Bbecause other chars are replaced by double underscore..
System.clearProperty can be used instead.
I think this would be clearer though more verbose:  final Schema inputSchema = getChild().getSchema(); final Schema groupingSchema = inputSchema.getSubSchema(gfields); Schema aggSchema = Schema.EMPTY_SCHEMA; for (final AggregatorFactory factory : factories) { aggSchema = Schema.merge(aggSchema, factory.generateSchema(inputSchema)); } return Schema.merge(groupingSchema, aggSchema);
Why not throw a NuxeoException here?
I think this line is too long. Did you apply the formatting rules?
Same here? if (e.widget != widget) { return; // Not for us. } Though I wonder how that could ever occur.
Please consider adding the following Preconditions.checkArgument checks: * alias is not blank * cert is not blank * privateKey is not blank
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
Nit: maybe use different keys for the two tables here.
Can you add the user to the logParameters as well please (there is a .user(String email) on the log builder so no need to do addParameter. Can you do this in all places where you added the new field (all places where it's already logging something)
suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {
rename to child or childElement
StringBuffer is so 1900-ish. and adding the ", " is I think cleaner if you add it conditionally
You can highly improve the performance of this line by calling the Vm.isCreated() method. Check issue #188 for details. suggestion if(broker0.equals(vm.getBroker()) && vm.isCreated()) {
You can use Collections.singleton.
We should go with a single histogram tracking tag count, since every ReportPointHandlerImpl can handle only one atom type anyway. Having separate histograms for points and histograms is not useful - we would have impossible combinations like ~proxy.histograms.2878.pointTagCount.p99, or ~proxy.points.2878.histogramTagCount.p99, which would always be 0s and waste pps.
Can you do a more precise check? Comparing the string with exactly what you expect? You should check a specific blob as well, not just the first one (not sure you'll have a deterministic order).
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like:  if(!AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(user)) && !AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(specificUser))) { .. }
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
It would be better if we would show the user some message as toast as well!
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessorRegistry().getQuickAssistProcessors(...))
Instead of hardcoding path, can you check if Files.createTempDirectory() works?
Other places in MISO use owner to refer to a user, but it's used here to refer to the associated QC-able thing. What do you think about changing the field name on the DTO from owner to entity to match the QC model?
We could probably share the Iterable Iterator part with unnest by making the iteratorsPerColumn a parameter.
The first three should be required.
It's probably safer to use EntityList.createEntityByName(String, World)
Please extract a constant, StringUtils may be a good place for it.
Remove this?
make all local vars final if possible
Can you explain what problem this is solving? The jira does not tel much about leases.
Should we have an isAnonymous method that we can call here to make this clearer?
Can this be private, or is there another use case for default attribute outside the builder's call?
Since the varargs parameter of String.format(...) is of type Object for which toString() will be called if non-null, it's a bit safer to do the following in case the key schema or value schema are null: suggestion return String.format("<SchemaPair: %s, %s>", keySchema, valueSchema);
is caching disabled for descending queries ? this doesn't seem to be correct.
Extra new line.
suggestion // STS endpoint usually points to MinIO endpoint in case of MinIO final String stsEndpoint = "http://sts-host:sts-port/";
A question about the purpose of doing this -1 test. I do not understand how this -1 works in Socket InputStream. I would expect that int read = in.read( buffer ) will block read until we get something from InputStream, unless an exception is thrown. However if we get an exception, we will never get to this if.
Can't we do that in the EnvironementInitializationFilter to avoid adding this top all the sites?
The interceptors must not try to access the TM transaction via the thread-local, only via the invocation context. So it's safe to suspend the TM transaction before calling invokeAsync.
can this be part of new module as InputSource seems to replacement for firehose related interfaces ?
Fully-qualified class name not needed.
nit: this doesn't have to be done in this PR, but how about making JsonIterator a CloseableIterator? It already implements Iterator and Closeable so it would be pretty simple.
missing final
Maybe use this.value instead of getValue() here (and also on similar occurancaes)? Similar to AbstractSingleCatalogData.
Hmmm this test depends on the ResponseStatusFromPayloadHttpCommandExecutorService fixing the response code. Even if the _real_ provider returns a 500, I'd just configure a 404 response to make sure the API works, without coupling it to that class. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status is properly fixed and that should be enough.
Lets use VectorUtils.of(...).
style nit: no braces, more occurrences below
According to the docs[0], this should be called from onCreate()... But how are you supposed to get the MapView before onCreateView()? [0] "You must call this method from the parent's Activity.onCreate(Bundle) or Fragment.onCreate(Bundle)." <LINK_0>
Write this as a for-i loop.  for (int i = 0; i < newPositionCount; i++) { int position = positions.get(i); ... }
final missing
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
I am not 100% convinced if this would be a trace info. We probably won't need this information to debug the internal work flow, but whenever this information is needed, there should be some error (or complaint from users). So from logging perspective, it more looks like an error.
This variable isn't needed. You can still do return contentRepoService.getRepoObjectMetadata(manuscriptVersion); inside the try-block.
the type of hotplugSupportOsIdVersionMap can be reduced to Map in this context.
nit: import toSet static for consistency with toList (see L46).
All attributes s values were -> All attributes values were
Another lambda-ing opportunity:  source_.withSaveFilesBeforeCommand(() -> { server_.startBuild(type, subType, new SimpleRequestCallback<Boolean>() { @Override public void onResponseReceived(Boolean response) { } @Override public void onError(ServerError error) { super.onError(error); workbenchContext_.setBuildInProgress(false); } }); }, () -> {}, "Build");
you might want to return a specific validation error. Something like, "Slave host name is required" "Slave volumes is required"
suggestion
Initialize this map. With an empty map.
This is a bug. please change one version to timeo.
Possibly should check the entire screen stack.
_nitpick_: Indentation is pretty far for the anonymous class definition.
Could lines 154 - 170 be checked once outside the loop? It doesnt seem like they would change based on the sync path?
avoid using java 1.8 methods, reimplement with StringUtil
Do you need to use the "text" constant?
This test against AccessDecisionManager might be better to do in the AuthorizationManagerAdapter's constructor.
why not null as value?
try-with-resource ensures the second is closed even if closing the first one fails:  try (MessageProducer closeProducer = producer) { session.close(); }  (Later Java supports try (producer) { session.close(); } without the dummy var.)
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
same here. however I'm not sure if you can update tags on version. AFAIK version should be immutable and be result of write operations. Does updating/setting tags bump blob version? (updating metadata does that)
Better to return empty collection rather than throw exception.
should this be synchronized?
This NOT_USED constant (which isn't even a constant) seems a bit silly, and makes thinks less clear, not more. The pattern isn't even used consistently throughout the test - sometimes just null is used. Probably makes more sense to use null in all cases.
System.clearProperty can be used instead.
please fix the whitespace. You just need to return the options here.
Don't we want to check if it's a 401 first?
I don't like to define code as a String. This looks quite ugly and hard to maintain. Is there another way to set this?
I'd like to see what the format of the output is for JFlat. We may have specific requirements around how the JSON is flattened - so would also be good to see the customization options.
In what scenario would we have a Container in the map without a message?
use compare - that is every version implementation implemented.
Replace SizeOf.sizeOf. You statically imported it.
Theoretically it would save a memory allocation and garbage collection to just return value;. Maybe Hotspot will optimise this in practice. Same in the other file.
not so readable. looks like good candidates for parametrization
why not use the logger for this?
I would explicitly write throws NumberFormatException here.
You have two placeholders in the stream but only one argument, is this intentional?
You compare disk id to image id, which is not the same thing.
can this be class field?
int rowCount = model.getSize(); Then the code in if block can be shared.
Ravi, if you just initialize this with false before the creation of the tasks then your fix will be perfect.
should be executeIgnoredModules
now that the expected value is updated, is the replace all still needed?
rename to delta
We should set connection and socket timeouts here. By default there are no timeouts, so in case of network problems this may hang forever, which is pretty long. ;-)
Why?
I noticed that you use this on many places, shouldn't this be NPE instead of IAE?
Use already defined Constants
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end
java list.sort(Comparator.comparingDouble(ForgeTimings::getAverageTimings).reversed());
yuk! a System.out! Either remove or use a slf4j logger here
rename softCacheCreated to softCacheCreatedNs
Please replace all tabs with spaces and indent consistently.
You can move this if statement into mintLog()
I would probably split this up and check the token type prior to getting and checking for credentials. It's a personal preference, though.
You need to pass the auth option along when doing the resolving, also consider the options in the call
missing dot!
Can you please also make this block contribute the the dynamicRegistration map?
We have too many nested try/catch/finally blocks here mixed with throws statements. Could we simplify this?
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
"passed" instead of "passes"
check for isDestroyed().
The cursor iteration block can use a try-catch-log-finally, so we can see errors if read fails.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
if it isn't too much change, lets get rid of SecurityServiceCallback
What about giving a meaningful name to the thread and making it a daemon thread?
Rename the variable to agentStatusReport
NIT: File has a constructor with two params for this kind of usage: java new File(j.jenkins.getRootDir(), "config.xml");  should be equivalent FWIW
This should be fine on the previous line.
use Map interface instead
final
We should either use DataSize for these or add the appropriate unit in the log message.
This actually brings up an interesting question. If user wants to store the point with column lat, lng as double, is it possible to create an index for them?
Sorry for being picky - but this too can take in a status code (404 in this case as it is NOT_FOUND) instead of HttpFailureException.class, right? This will make the tests more accurate.
yuk! a System.out! Either remove or use a slf4j logger here
I would put the "magic number" into a static var.
Please move this logic here: <LINK_0>
See if you can simplify this.
Nit: missing blank.
suggestion .filter(AudienceRestrictionType.class::isInstance) .map(AudienceRestrictionType.class::cast)
better Exception
redundant check (466), consider changing
You can use Version.v4_0 constant. Also, space between "if" and "(".
the steps 35, 36 and 38 are not neccesary
In your @Test, you can use @Test(expected=IllegalStateException.class) and _not_ do the try/catch within the method. This is cleaner and more appropriate :)
which exception are you avoiding?
toString() is not overriden in GridClientClusterState. I think it's better to use here state.state().toString()
return this ?
instead of calling String.trim() multiple times here use map(), e.g.  Files.lines(p).map(String::trim).forEach(...)  You could also filter there too, e.g. .map(...).filter(s -> !s.isEmpty()).forEach()
can be shortened URI ssoRevokeURI = ssoRevokeUrl != null ? SsoUtils.buildUrl(ssoRevokeUrl) : ssoToken != null ? soUtils.buildSsoRevokeUrl(url, ssoToken) : null;
nit: do you need AuthMethodPickerActivity.this or could it be just this?
Same as above here: use .isEmpty() rather than .equals for the empty checks.
This won't do anything since metacard is a mock.
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write:  MockBattleState.builder() .attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))) .defendingUnit(givenUnit()) .defendingUnit(givenUnitIsAir()) .build();
Since we're invalidating the entire dataset in the adapter (a few lines below), which will cause all the views to be redrawn, do we really need to do this here?
Can these be declared at class level and used for both methods?
A warn as well. I am not even sure we need the stacktrace here
This method can be private
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
In the previous section this is a warning and the default password is used. Why is it different here? Also if the error is "SEVERE" we probably shouldn't just log it and continue on.
This isn't needed since we are in try-with-resources. This can go into the while loop
You need to specify your "When"s before you actually invoke your service in order for the mocks to work, which begs the question as to whether or not this is doing what it should, and if it is needed.
NPE for: <LINK_0>
I continue to think that **aifc** should to be here...
Don't you think that set in a static field will be simpler?
suggestion .thenCompose((ignore) -> registerTaskExecutor(tmResourceId, taskExecutorGateway))
If the test fails, unsetColoring would not be called. Could presumably affect other tests.
again about redundant things - else block here and above is not needed,
log me?
Wouldn't asString(...) be the way to convert to a String representation? Also I thought I saw this identical method implementation in another class, was it AbstractNumericProperty? Are we on Java 8 yet? Could interface default methods help reduce duplication? Sorry I don't have a robust mental visual of the interface and class hierarchies yet, so not quite sure if this is even a practical/useful suggestion.
Yeah, I think it makes sense. IIRC, netty swallows the throwable silently, so it's difficult to figure out what's wrong.
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
Could you add a system property check for Linux? See line 448.
char querySeparator = '?'; if (request.isRegistrationWorkflowOptionSpecified()) { href += querySeparator + "registrationWorkflowEnabled=" + request.isRegistrationWorkflowEnabled(); querySeparator = '&'; } if (request.isPasswordFormatSpecified()) { href += querySeparator + "passwordFormat=" + request.getPasswordFormat(); }
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
This ID is not the chargeId suggestion logger.info("Offered payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), charge.getExternalId());
we're always calling cancel here instead of close() for the normal case.
after the loop, we should check that the iterator is done?
See earlier question.
We should write a real test cases for dropping connections.
If the error happen that early, can you map the error in early phase before mapping page result?
Please replace empty string with a proper error message
suggestion boolean notInGraphAtAll = candidatesForDeletion.isEmpty();
> public abstract class ExecutionStrategy { this super(); call doesn't need to be here
you don't need validator here. you already have the errors (getErrors()), just use it. and remove validator dependency. no more cyclic dependency ;)
Thanks for letting know, I have no objections, just let me know when I should have a look again.
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
remove as below logic didn't use mTransportMgr? also, I prefer use mTransportMgr.getAvailableTransport than mDcTracker as latter initialized once and not get updated if availabletransport changes.
Move this if block after all if blocks.
I think this is dangerous, because it makes a resources that's not loaded yet accessible by other threads, that will try and use it with the assumption that it is fully loaded.
Please don't remove this mechanism for changing the color. Here we make sure that changes of the colours modify the individual views, e.g. night mode switches to day mode.
Second parameter of Status is the pluginId. Why to pass path here?
typo on empty.
What about using something less specific here like Map?
String.valueOf(...)? Or TBH, I'm pretty sure the compiler does this for you if you just inline everything like so: java return "PageKey{" + "StartAfter=" + mStartAfter.getId() + ", EndBefore=" + mEndBefore.getId() + '}';
Why do we use iterators? I know the base class does, but why in the first place?
Only need to create one Admin for this whole method, not two per data table. Docs say they're lightweight, but no need to churn.
Why <=0
Delete the if statement.
I don't think this can return null. We should probably add an external annotation.
I'd just pass e, so the stack trace also gets logged.
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check for the presence in the list of the low-level permission like WriteProperties which are the ones actually checked by code in AbstractSession.
You can replace this by: java return input.entrySet().stream.collect(Collectors.toMap(entry -> entry.getKey(), entry-> base64StringToSerializable(entry.getValue())));
this can be moved to localize() method
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
AbstractSnomedRefSetImporter.createComponent(String) already initializes the UUID property (probably also applies to core components, not just the reference set members). It could be removed from all classes implementing applyRow.
just wondering why do we need to cast it to Symbol here?
Avoid adding more dependencies/additions to using Preconditions as we're moving away from Guava explicitly in several aspects. Also, needs an error message instead of just a random IllegalStateException.
"0"?
Anything we can assert here?
4 spaces
why this null check ?
"Gerrit does not currently support generating diff output for this kind of change."
no need to write "VmHandler::" in the log, the logger already write the class name (also for the other logging below)
should these be logged at error? Specifically I'm thinking about exceptions where one node is unreachable so the delegate could throw
log and throw
allowing flight is different from the player flying, I think you meant capabilities.isFlying instead.
you can simply use Predicates.notNull()
can it be package private?
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
Need a process.destroy() here before throwing the IOException, so the cleanup can happen.
We could avoid cloning here? (The message is not modified by the view?)
Don't do this. This is the same O(n^2) bug you are trying to fix here, just in a different kind of Block. Ditto for getRegionSizeInBytes implementation of this Block.
remove "public"
Why do we need extra comma here?
Can we have some meaningful messages to accompany the tests please?
As before, I'd say this is an InvalidConfigurationException since the UnsupportedCommOperationException is thrown when the configuration of the port is invalid (serialPort.setSerialPortParams(baudRate, dataBits, stopBits, parity);). We need to add this exception it to the method header.
do you want a fail() in here?
prev is never reset so If an escaped backslash is found subsequent unescaped won't be deleted: For instance pattern "a\\b\c" should match "a\bc" but won't because unescaped backslash removal will stop after encountering first escaped backslash
If this property is set, shouldn't the classpath have been updated before? I'm not sure why we need this code.
Need to add the else clause which fetches the Hibernate-persisted Project and replaces its updateable values with the passed-in project.
Could you also test what happens when the data isn't Base64-url-safe-encoded, with labels, collision with an existing secret, etc?
I think this is incorrect - we shouldn't be placing files for variants of the same blueprint in the same directory. Can we add a pre-install command to create run.dir earlier than would otherwise happen?
Update log messages to refer to timer instead of commit, here and elsewhere in this class.
No need for try-with-resources
my experience with redis, is that listing keys by pattern can take a long time. This could be a problem, since we don't want those operations to lock up the query side. Is there a way to issue asynchronous operations with jedis, or we might want to create a separate threadpool to queue up those operations.
You can merge this conditions with the other wildcard trees
Should we create the file always in home directory? Shouldnt we create under /home/ovirt-engine or somewhere else ?
Should look into having a ConnectionStringParser class in Azure Core, I've been seeing this functionality in a lot of places.
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
minor: you can return Collections.emptyList() instead
Let's avoid null and rework to empty string
< 0 doesn't seem like a great overflow check, maybe be more explicit?
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
Space after comma.
Those looked like good tests? Why remove them? Hash collision?
we never use NULL, it is a bad practice in general.
This sounds pretty dev-like. Let's either make this an email address, or turn it into something like When defined: >Hi First Last! When undefined: >Hi! Should be easy to implement and avoids the awkward "Hi User"
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
This should probably be removed
You cannot use Java7 feature otherwise the build fails. I think it's the same for GWT source code, isn't it ?
new HashSet<> is not needed; oldAssignmentNames is only used for exclusion from a set, let alone the returned assignments are always unique anyways (read straight from ZooKeeper). oldAssignmentNames  can be a List<String or even Collection<String>.
No need for the null checks, primitive types cannot be nulls.
Any possibility of the module string being group:artifact:extension:classifier:version or group:artifact:extension:version? i.e., do we require custom modules to adhere to the 'exec' convention?
I think most of the callers of normalize() convert the String you return to a BytesRef. So maybe it would be better to drop the extra utf8ToString() call and make this method return a BytesRef directly?
Worth to check but don't we support slashes in namespace? If so this would probably break with double slash if zk barks of it.
prev is never reset so If an escaped backslash is found subsequent unescaped won't be deleted: For instance pattern "a\\b\c" should match "a\bc" but won't because unescaped backslash removal will stop after encountering first escaped backslash
@szczepiq What is tested here? I can't see an assertion.
;
Let's move this line with the FBO-related state change. Just double-check if it needs to be before/after setupConditions();
i don't know if this is something we want to do here, but it would be good to log the network id and the boolean too. then we will know if a particular network is enabled, who is to blame.. or after one is disabled, why the rest are also disabled.
Probably should use combineDegree - 1 instead of hard-coded 1 here?
Null-check
Why would we want to silently fail here? Why not throw an exception on any update operations to tombstoned relation metadata?
throw new VerifyException()
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
I think that this method deserves to be protected and tested.
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldUpdateReadOnly() is being called.
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
List instead of ArrayList maybe?
You would need to error out or S3 service to error out, not to delete with Set()
What is the use case for calling findFirst() here? I understand the motivation for its use below for the embargo.
Should this throw? It seems like a serious error if there is no info for the table and any further processing can only compound the issues.
Although Java allows this, It will really help code readability and future refactoring if we need, if you could avoid accessing these internal variables outside.
I think the logic should be more like:  if (context.isRoot()) { fetch root object } else { if (field is attribute) { fetch attribute } else { fetch relationship } }
assertThat( query ).assertThat( query ) ?
Let's wait for the logging changes to be merged, and fix this one accordingly?
move a line below so you can use append
This can be wrapped into another function for clarity purposes.
no need to handle failure (rollback, log, etc..)?
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
might be removed?
same here as well - on failure to stop vdo service, activate and move host to original status
use Arrays.asList(...) for short lists.
@cvrebert don't we need to stop the container in finally block? What if some method will produce unexpected exception?
Typically we use Map on the left hand side rather than HashMap
Add this logic into the certificatemanagerserviceImpl class.
please log in error
Use an interface instead of a concrete class. Same below. Space is missing before "else".
Is the order for entrySet guaranteed to be the same every time its called? I know it will for HashMaps, but I'm not sure about other Map implementations.
Can this be made private?
I think the old code (using default on the switch) is better.
Missing final
I think we should externalize the mapping (reading/writing) of the data into one of Spring's strategies. Then user's can inject their own strategies.
Set this only if session details not null??
Suppose there are two interfaces:  public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.impl.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { }  so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a Format, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
Can we also have a test for LUCENE -> NATIVE -> LUCENE
Suggest adding an assert that the only task name in the list corresponds to the last invocation of setTaskName(...).
this and m_ is redundant
common format
If instead throwing an exception when policyParameters[3] == null you log the error. I think it will return a NullPointerException when you do credentials = (byte[]) policyParameters[3].
It is probably worth noting that in order for this to match the service name needs to be set in server.xml:  xml <Service name="Catalina">  It would be nice if we could auto-detect the set of tomcat services that are available in jmx as users picking a different name has bitten us many times. Unfortunately, because of the way it is modeled I think this would require a full scan of jmx and then looking for something with the right sub-properties on the ObjectName.
should be singular, VTIDSection. It's not like in French (ex. un magasin de souliers vs a shoe store).
use arrays.copy? or system.copy?
Could we simplify the 2 lines above as if (FileKey.resolve(gitDirOf(name), fs) != null) {
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
"expection" -> "exception"
@Sami32 You removed result.append(", Sample Frequency: ").append(getSampleFrequency()).append(" Hz"); - I disagree. Remember that even though you already have the sample frequency from DLNAMediaAudio they are separate values and one can be used one place and another another place. We should see both values when debugging, if they are different that would be a bug.
This log ends with a period, the corresponding does not, they can be unified. Perhaps these messages could be more "parsable" visually. What do you think of the following? [Signal(id)] Created consumer for {}. [Signal(id)] Deleting consumer for {}. (and so on)
Just do getAndSet(null). Then shutdown the returned value.
I think here you can do something like steps.stream().findFirst().orElse(null); If findActions receives null, return a Collections.emptyList();
Same nesting questions
allMatch returns true for empty stream, so separate test for emptiness is not necessary
I think more readable would be something like  assertThat(correlationId).matches("my-project/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
This piece of code to create an Authenticator is duplicated 4 times, but it's not relevant to the test. Can we make the test cases shorter so that we can see easily the differences between them?
I would throw instead of just logging it.
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
can you change this impl to be addJobProperties(job.getConfiguration()) ?
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
This line is redundant.
My checkstyle is exploding with "magic numbers" here. You could easily use the constants from the Items themselves here I think. And if not, please make these numbers constant fields in the test. <review,testing,logic
use multi-catch ?
this isn't needed anymore after the logging changes made to the app, can just use the normal logger from LoggerFactory.getLogger(ScriptTransform.class)
NIT better to use Collections.emptyList() to avoid new objects
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.
This is potential performance killer, but I don't have better idea how to address this. So I assume we need to live with that. Fortunately there will be thousands of groups at most (not millions) and it is just about admin requests, so hopefully it is ok. IMO in general, it is probably better to have pagination approach, which doesn't require counts. Something, which always returns the token for next page? Although this approach also has limitations (EG. it is not easily possible to move to the exact page like "Go directly to page 50" etc), and there are probably other limitations. But maybe something to consider in the design of new REST API (CC @pedroigor ). Sorry for hijack the PR :)
instanceof has some performance concern when you are using jre6(jre7 maybe)
This is where the if statement should be for checking the property for allowing for corrected times.
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Use the whole path IPv4.Availability.PUBLIC
> return true if the listener wants to override the default behavior of clearing the text field and dismissing it, false otherwise. I think this should be true since we're handling it? You may also want to clear the listener here and in onDestroyActionMode() when searchView is nonnull.
Oh yuck. ;)
I don't think refreshing here is sufficient. The way I understand it, if the job is sleeping, cancel() will not call cancelling() and the refresh won't happen.
Change this to == and I'll merge it.
add java doc explaining the packageName is used for finding the package and if it is not found it is created. method name should be reflect this. Maybe this should be split up into separate fucntions
Why do we want to assert here?
you need to first trim input otherwise this doesn't match if input starts with whitespace
if (
What about caching the list? AFAIK this method will be called multiple times on the same connection.
Comparing the classes of both objects here make the instanceof call obsolete. You either go for getClass() or instanceof considering both having slightly different semantics but both having the same outcome if getClass().equals(obj.getClass()) applies. I did some further research in that matter: I haven't found any evidence that JobManagerProcessSpec and TaskManagerProcessSpec are ever used in the same context. This makes the case of equals being non-symmetric when dealing with subclasses kind of theoretical. But if you want to reduce the risk of this coming up later on I see two possible approaches: 1. Check the equality of both instance's classes (Keep in mind to add a null check for obj in that case). 2. You move the equals(Object) implementation into JobProcessMemorySpec and make it final. In that case, you can keep using instanceof.
This should be indented and/or parenthesis around the body of the for loop. Also the pair should be appended not concatenated to a string and then appended. builder.append("CompleteTransactionTasks: ").append(pair); The output of this will be a bit strange because there are no separators between the different completion strings. Maybe append a comma and space or something between the task strings.
Try to call propagateFailure(returnValue) instead
This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.
Seeing this essentially duplicates the load code above, I feel there must be a more elegant solution to this - something that just retriggers loading of all the existing observable's data...
this is a good initiative. why are you checking the start time, it could be a valid use case to say everything after Marc-Andre's birthday. So start time = [removed] and end time = eternity
what is the reason of this change ? I think you should revert to "this" instead of null
This is apparently out of date.
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Local variable could be declared List instead of ArrayList. Is this worth caching?
after saving can you broadcast, so as all other users on same note gets this save update ?
necessary?
What are these annotations ?
This cannot be removed. The scheduled task needs to be saved.
Let's log this error as a warning, instead of as verbose
Logging.
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
@Suseika how about to check PsAll.enter() returns Identity from 3-rd Pass?
minor: no need for final?
This causes a reverse DNS lookup - definitely what we do *not* want.
"belonging" -> "which belong"
Include the maximum page? "Page %s is greater than %s."?
also assert the cause attributes
The return type is a bit hard to use; Could we provide a higher-level API like DataSet instead?
context.getEntityType().equals(EntityType.FEED.name()) should do.
Um, surely 1.6.6 is closer to 1.6.5 than it is to 1.6.
Are you sure that you should add this file, too?
sounds nice! so users are not overwhelmed with hints. Shall we also add a change log entry for both this and schema hints?
HQL/JP-QL
{} for blocks
This is not needed. In super.tearDown(), all the replaced stuffs are restored automatically.
what if the acl is not found? we should skip metadata update in this case and return false?
Message should probably be sent before actually unloading chunks. :)
Why do we need an explicit boolean primitive? .... using i.getRepeatable() does the trick
Could you please assign the URL to a local variable before opening the connection? This helps while debugging problems.
Please remove the protected keyword because this class will never be subclassed.
the default shouldn't be hardcoded.
This branch can be simplified: java final String[] split = ListSplitter.split("\"", true, removeBrackets(value)); for (String val : split) { result.add(val.trim()); }  or shortened java Arrays.stream(ListSplitter.split("\"", true, removeBrackets(value))) .forEach(enumItem -> result.add(enumItem.trim()));
Why do you need this cast? Is it because ScreenLoadCallback implements both interfaces and its picking the wrong return type for the old style RPC call? If that is the issue maybe add a 3rd method addOldCallback() that calls the old type add() version so the compiler can't guess wrong for a ScreenLoadCallback?
is there a reason for StringBuffer instead of StringBuilder?
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
this setter is no longer relevant, recompile the project so will be generated new setters/getters according to schema change
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
resolvedImges can't be null otherwise the next for loop would fail with an NPE. Actually I would either put this into an extra method which returns early in this case or put this into an if-else with the following loop.
can we please avoid copy & pasting the test ? Just extract a common method which is called once with "docker" and once with "registry" from each individual test. Helpful would be also a test that ensures that "docker" has precedence over "registry" to keep the default behaviour.
I would dump this iterable into a variable just for clarity. It looks more than a tad clunky in-lined...
Would you mind improving this test to use executeFile() instead of executeString()?
System.out.println("...... and path id (optional).......
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
This could use some refactoring too.
it would fit easily one line
I believe it will be nicer to just generate a String containing either an 'On instance of...' or 'Of class: ...' and add that to the message.
LOG.error by default prints in a newline (So no necessity to add one at the beginning of message). Please change it at other places as well.
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
nit: what about java nulls[i] = i % 7 == 0  ?
I'm surprised that getRequestParameter does not return an Optional :)
Unneeded empty line here.
This noneMatch(notVisited) seems rather convoluted for no practical reason : wouldn't a Collections.disjoint be enough in our case ? and/or maybe Guava Sets.intersection (maybe applicable to sets only) ? Ideally encapsulated in a "visitedAllParents" method ?
toTraceId already returns a string, on need to call format()
getSchema parses the schema if its not null. however we should parse only if its not a macro right ? should we support macro for schema field ?
Not worth debugging for this QS
OCFile now has a method getRemoteParentPath that may replace this block. Let's take advantage of it :)
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
do we need this composite? we have already the border composite
do you need to add CRC here?
Spaces after commas
Why not just call the constructor here like it was called before (new DeviceMessageMetadata(metadata))?
This (And other filters) need their type as well. The reason being we could have a TagValueRegexp with a filter like .* and a FieldRegexp filter with the same filter and want them to hash to something different. For this and other regex filters, you can omit the pattern from equals and hash as those are just compiled versions of the filter field. It's ok not to use the parsed version even if someone puts a space in front or back.
Would you also add an IS_NULL filter here?
There is no need to do check for null, right? I mean you could just write something like return "SslSession(alpn=" + alpn +...
You don't need it in every Exception since you have a finally clause that will get executed at the end.
Can you factor out psInfoFactory.get(db, pId).getAuthor() into a variable? I think it would be better than to have it in 3 places now.
This should be a triggered ability of the enchantment, not a trigger gained by the creature
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
Somewhat counterintuitively, I don't think this specific call actually should be app restricted. If the case model changes, it should invalidate caches around that case model regardless of which app produced them.
If createdByUid == null or user not exists, skip this settings and continue without seting role.
this is not vdsm, should be another configuration or setting within database, but we kill this code anyway, so not that important.
There is a singleton for OK Status: Status.OK_STATUS
Can we do new CsvReader(inputPath) and do the conf/fs creation in the constructor?
@aertoria Can you change all the variable names in test method to not have _1
why would this be required again?
Same question about maintaining type information.
Please use a try-with-resources block here
Can we make an enum or consts for these result strings?
Nit: I would dispense with the elses since you return in the ifs.
@vmaletta I think ep should not be there. Maybe a merge issue, could you please check?
have a default constructor with reasonable default values
style nit: missing braces, since a while we use braces around single line blocks, change this only for new or modified code
I think it is better for performance to get the member first, check if it is not null and perform deserialization. Also safer.
assert return value
I understand the need, however, we must be careful when working with paths which come not from Java. /var/tmp may not exist, it may exist but be not writable, we may or may not have permissions to create it if it does not exist. Linux sysadmins may want to use some other directory instead, which is not possible when the value is hardcoded. Also, I doubt that os.name is always exactly (lowercased) linux when running on Linux. Perhaps, it makes more sense to check if such directory exists and is writable and use it in case of success, otherwise just use the default temporary file directory.
This is a nit, but (at least here in the PR) the white space looks a little off (looks like one if was indented by tabs, the other by spaces, or similar) Also, I'd add curly-braces to the nested ifs (for consistency), or express them as ternary conditionals
s/uninitilized/null
Using targetClass.getFields() here gives you the public ones (incl. those declared on parent classes). That removes the need for checking the public modifier later on. Did you know that you can check the modifiers using: Modifiers.isPublic(field.getModifiers())?
This is wrong map, one from change info and not one from revision info, that you need. The right one would be the code that you have removed: RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { NativeMap<ActionInfo> actionMap = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo> create(); }
Can we add more context to this log statement as well?
This code is almost a duplicate of getIncrementedSegment(), could be extracted to a method.
Not strictly necessary, since the .get() will throw if there's no extracted content.
You can chain this like  java return ImmutableList.<String>builder() .addAll(currentSeeds) .addAll(newSeeds) .addAll(oldSeeds) .build();
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_0>
can be removed now
should we at least assert that it's a well-formatted timestamp?
super.init() method never throw an exception.
empty hashmap.
Instead of creating a couple of extra Timestamp objects, move this as the first line in your if statement and just return true, like this:  if(divBy > 1) { return true; // As in this case, we've already got the correct value in ptr }  Also, another good optimization would be to check the last four bytes being non zero without creating a Timestamp object. You could do this like this:  int nanos = PDataType.INTEGER.getCodec().decodeInt(ptr.getBuffer(), ptr.getOffset()+PDataType.LONG.getMaxLength());
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
As you know it's a method symbol from getting it the methodTree, why testing it again? Is it to cover the case of unknown symbol? If it's the case, I would prefer to test it by using !methodSymbol.isUnknown(). Moreover, this case is not covered by your test cases. The same remarks apply to the overridee below.
is incorrectly formed.
If you see opportunity it would be great if you could refactor the methods with many parameters.
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in the grand scope of things but it fits the error message better.
Calling fail() throws an AssertionError, so you'll get a confusing error message if we ever get here. When testing code that should throw an AssertionError it's best to use this pattern:  try { callThatShouldThrowAssertionError(); } catch (AssertionError expected) { // optional: make assertions on expected here return; } fail("Expected AssertionError to be thrown");
Add default to the switch
nit: The mocked environment creates 3 nodes (by default) that you can use so you don't have to create them. You can get them with env.getCluster().nodeById(..).
this method is written in a 'single return point' way, i'd rather use it (means set returanValue to false instead of return here) or refactor the method to have multiple return points. please, if you choose to refactor, have it in a separate patch from the change this patch is doing.
Isn't this the number of mappers? Can the reducer get it instead and compare with it?
Minor: Maybe extract local variable with the size. Will be more understandable.
"e" is an exception. Per definition. :)
Missing null check on sampleClass
Null check required?
Same observation as WCS and WFS tests
isEmpty
This error message is not very useful. How about "no matching files for folder with regex: " + regex.
I think lowercase l should also be considered
Modern Java does not need StringBuilder any more. Simply use += to build a regular string, this is fast. It may even be possible to use StringUtils on an array of longs, but I'm not sure about this.
Should this use a try { } finally? Otherwise other Throwables leak.
This should be EntityNotFoundException#byName instead of EntityNotFoundException#byId
Is this better than Assert.assertEquals?
If the response data contains apiName, does it mean that api is deleted?
This looks like different logic. You only have one serial read. putChar also writes two bytes into the buffer. This seems weird in the first place. We could maybe jut write:  return ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).put( new byte[]{serial.read(), serial.read()}).getShort(0);
setGameState( BOT_VS_PLAYER ). make final int
maybe mention the field type?
The same here than for PreviewImageFragment.
You can just early return by checking leader == null.
Should this one be turned into Throwable as well?
this whole thing can be replaced with Stream.of( args ) .filter( StringUtils::isNotEmpty ) .toArray( String[]::new ) right?
If you are in Java 8, it is nicer to use .then.
Maybe a wider exception would be better idea here if anything rather than sql exception happens. Since we don't deal with the exception itself.
Test for last four digits as well?
Please use a [StringBuilder](<LINK_0> instead.
Let's use request body rather than request params for this. You can use getAndValidateRequestBody method with List<String> or String[] as the type.
please rename to performOpenMoreOptions
I think we can remove this line.
Should just return properties.get(), the containsKey() call is redundant.
can you compute difference and then use in if condition?
@tbarsballe has gone through and done a QA run to ensure closed writers return hasNext(): false (rather than thrown an IOException). Lets stick with that for consistency (principle of least surprise)
return id list
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
Nit: Map on the LHS. It doesn't matter a huge amount, but I'm curious why you've used ImmutableMap elsewhere and not here.
You can probably use EntityPredicates.id(), which gives back Function<Identifiable, String> (rather than just for entities).
remove the unnecessary space, catch throwable
invoking combinations of close and releases here looks strange
Should we also have the same tests for the email template?
suggestion server.getFileStreams().forEach(UncheckedFiles::closeInputStream);
do you think debug is enough to report this problem? I would use warn.
Second parameter of Status is the pluginId. Why to pass path here?
you can use Schema's isNullable and getNonNullable methods to help out here.
Type casting should be avoided and seems indicative of a problem with the model. Why are you not passing the configuration via the constructor?.
channel.close().sync();
if it existed in containers, is it not sufficient?
NaN if outputRowCount is 0
why do you need retries on stop but not start?
delete all private setter and just set the meta object. For the getter take the values out of the meta object. Much less lines of code
This may introduce NPE if a resource is not in the resourceTimestamps
since we use instance variables for most part to construct BlobId, may be you can introduce a privateMethod which takes in non-instance variables and version to construct BlobId is the specified version
parser.teardown() call should be part of finished() call of TestWatcher
The countdown latch is not decreased so waitForInitialization hangs.
Why not in combination with above do this: setValue(value, false);
why couldn't we return results before the analysis is completed?
please show the new line within the text: ( " --%s%n" + " %s%n" + "%n" ),
We shouldn't use 'String(keyTable[i])' here because sb.append(Object arg) is doing 'String.valueOf(arg), so it already has a null-safe Object-to-String conversion.
android.R.id.text1 Change this.
Why bcast when it can be sent to Admins only? Ops could use it to spam.
You can use Layout.INVALID_CLUSTER_ID
You can do this without an Iterator:  for (Map.Entry<String, String> entry : rawQueryParams.entrySet()) {
I wonder if it might be better to only check the time if we've yielded... unless we're spinning really a lot, it shouldn't delay thread termination (which is really what this is primarily for) by too much. OTOH, it's possible that nanoTime() is effectively acting like an onSpinWait() in this case; the total time spent spinning will be probably significantly higher than on the version of the loop without this call... something to think about anyway.
Shouldn't the exception bubble up in these cases? Fail fast fail hard!
move it to be aside of deleteFolder
The check is not necessary, File.mkdirs doesn't attempt to create the directory when one already exists.
As said in previous review: Add here a condition on isSequenceElement, the below code is unnecessary if isSequenceElement == false
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
This can be skipped before we even test isGitRepository().
static import?
We better not have the supported/unsupported versions hard coded here. Please check whether discard is supported using the FeatureSupported class.
href.indexOf('.') == -1 is a pretty unreliable test for a file extension (folders can contain a dot)
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the setNegativeButton method call will lead to the same effect (closes the Dialog), probably adding some clarity to the code as well
Since it now is a closeable and java 7; I think we should use the "try with resource" form instead.
Hm, why is the caching logic here and not in the mixin definition?
I don't think we need this catch - this is handled by the boolean return value.
id is the unique element in a HTML page. Therefore, there is not need to have a chain to locate it. Check if there are similar case in your PR.
Should these be assertions?
Neither here, nor in the interface, does it say as to how much data is read into the buffer. Let us be clear: unlike other similar apis, it is not "read as much or till EOF", but "read exactly buffer.remaining() or throw".
Space before and after ()
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class.
This returns InputStream no? We need to read and convert the value to string. We can add a helper to do this: String readContent(HTTPResponse r) { BufferedReader reader = new BufferedReader(new InputStreamReader(r.getContent())); return reader.lines().collect(Collectors.joining()); }
same as others: log should have Exception as arg
suggestion throw new IllegalStateException("The JDK Throwable does not provide a detailMessage.", e);
We could omit the second Integer.
Can we add a log message with the iteration number, size of workload, and computationSpeed before each iteration? This could help authors debug their optimizers. (Since the computationSpeed doesn't change, we could log that once, on initialization if preferred.) Maybe we can even log this once on start and once on exit?
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
This (the whole method) could keep the same indentation char.
suggestion sourceFile.tryDownload().ifPresent(handle -> handleArchiveExtraction(process, handle, shouldOverwriteExisting, targetDirectory));
s/vdsGroupId/clusterId
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
I would prefer to see this logic broken up into a couple of lines, it is a bit hard to parse. As well, then you could avoid the need to create the empty set to pass in for the other getProducts(page) call.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
redundant else
Delete try/catches. An exception always fails the test case.
Having the SWT.Read_only gives the text with context menu items {undo, cut, copy, paste, delete, select all , right to left reading order, show unicode control char , insert unicode control char, open IME, Reconversion} Since our objective is only copy can we restrict the text selection context menu to select all and copy ?
Any reason why not to add this as const as well?
Hmm, this should probably act like the column is a string column full of nulls. The rationale is that the classic Druid behavior is that when you filter on a column that doesn't support filtering, it acts as if the column is full of nulls. So that'd be consistent with behavior in 0.9.1.1 and prior. This could be done by calling predicateFactory.makeStringPredicate() and checking if it applies to null or not, then using that to make a BooleanValueMatcher.
I think that using containsOnly could hide the fact that duplicates are not preserved. Inspecting the variable load.getParticipants() I get this: > 0 = {Programmer@4134} "Programmer{nick='fax4ever'}" 1 = {Programmer@4135} "Programmer{nick='phone4induction'}" 2 = {Programmer@4136} "Programmer{nick='telegraph4eternity'}" I think that duplicates are lost even in a @OneToMany. Aren't they?
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously)
optional nit: this is still confusing for me, maybe it could be reworded as suggestion Unable to determine max direct memory size. If druid.processing.buffer.sizeBytes is explicitly set then make sure to set -XX:MaxDirectMemorySize to at least "druid.processing.buffer.sizeBytes * (druid.processing.numMergeBuffers[%,d] + druid.processing.numThreads[%,d] + 1)" or else set it to at least 25% of maximum jvm heap size.
Remove stack traces
Probably don't need package name here
That's true It's fine then.
If the test fails, unsetColoring would not be called. Could presumably affect other tests.
suggestion .thenCompose((ignore) -> registerTaskExecutor(tmResourceId, taskExecutorGateway))
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
wouldn't it need to sort the list in this case, too? (I wonder if using a self-sorting list here would not be the better solution.)
Use the pre-existing localized string R.string.multimedia_editor_popup_cloze, and definitely follow up on the "TODO" by using a static constant value instead of a magic number.
Class name is not needed when calling method on same class.
Why is this not a if condition
suggestion setValue(relativePos / rectangle.width);
At this point, too, an AtomicReference does not bring any added value compared to a volatile variable.
Use CharacterEncoder.getSafeText()
db.components().insertComponent
Can be replaced with this.constructLockKey()
I think the order of the checks here is relevant to minimize the work. We should check "firstParent" first, then SEEN and then parsing the headers if needed.
ugh again ..
Arrays.fill(filler, '0');
I don't understand why you don't use the sonarUsersGroupId and have simply the query:  "SELECT u.id " + "FROM users u " + "WHERE u.active=? AND NOT EXISTS " + "(SELECT 1 FROM groups_users gu " + "WHERE gu.user_id=u.id and gu.group_id=?)"
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
Could we add something like: if(System.getProperty(PROP_UUID) != null) { return System.getProperty(PROP_UUID); } Then product creators can disable by setting the property to whatever value they want.
why is the lower bound 0? Should it not be at least 1?
Let's explicitly check whether numBlockOwnershipByEvalIdForWorker contains workerId. Same for storeServerMetrics().
My guess is that you'll probably want to extract out the class portion of the metric name unless we're just doing blind search replace of s/remotingN/remotingN+1/g across the project each release
One of the original issue raised was regarding this permission check; since its going to run in the caller's app space (and not across an IPC) its not really guaranteeing that the permission check occurs validly. You'd need to do the actual sending of the intent from Telephony so that it can do the permission check there.
Would it make more sense for these error messages to end in periods since there aren't any related messages added after them?
We should not use Optional
you can use wizardPage.finish(TimePeriod.getCustom(2500));
@vparfonov maybe starts with <username>- ?
Missed it at previous review. Question - why via getVmDao()? and not via VmStaticDao()?
This test appears to be duplicated.
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
extra space
check for null before adding it
provide style as parameter to above methods
optional: if you look at my PR you'll notice I made a type of Task that uses the type system to force you to handle merge exceptions at all call sites. Since you are pretty constantly doing instanceof checks on the exceptions for these operations you may want to consider something like that.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
ligically i'd say addVmToDb ends here, and from here is images handling
Can you use inline returns carriesUnmergableSack() ? ... : ... please?
In general, we should probably be moving away from client-side validation where possible.
Code style
Rather than signaling this condition via an exception, maybe a better approach would be to have a globally unique instance that signals a hole.
You need to send cookie here.
It'd be nice to use a constant for this, e.g., NO_ENCODED_LENGTH?
Here an exception should be thrown if we have a conflict
The logic in this function isn't entirely correct. The standard specifies the type of the init-capture in terms of the 'auto' type deduction rules, so let's reuse the 'auto' type deduction logic. If we factor out the logic in this 'else' branch [1] into a helper function getAutoInitClauseForDeclarator() that takes a declarator and returns an ICPPASTInitializerClause, we can compute the type as follows: IASTDeclarator declarator = capture.getDeclarator(); ICPPASTInitializerClause initClause = getAutoInitClauseForDeclarator(declarator); if (initClause == null) { return ProblemType.CANNOT_DEDUCE_AUTO_TYPE; } return createAutoType(initClause.getEvaluation(), null, declarator); [1] <LINK_0>
We shouldn't catch a NPE. We should prevent it from happening. What is resulting in an NPE?
Why aren't you using 'createNic(..);
I think you need to do this and the next line in a finally
Don't forget to delete this
We required braces for single-line if statements.
Style-nit: Parens aren't necessary around the conditional.
suggestion public void onTabLoaded() {
I think this can be truststorePasswordAlias instead of the string?
Could be final?
These tests should also check the name and url are showing up correctly in the TaskData.
I think the granularity should be 1 seconds instead of 5 seconds here.
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
The selectSQL method is called for normal data extraction, there is already a separate method to handle visitors, the problem is that one of the various wrappers between GeoServer and the datastore is not passing down the visitor and thus breaks the optimization.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Yes indeed, fast copy/past
Can you also verify the error message? This way, the reader can easily tell what kind of error this test cases tries to check.
please put the ".dst" into the Constants.
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set a boolean and then reset the interrupt flag after we are outside of the while loop.
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
How about using try catch instead of if else?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
The exception message doesn't reflection reality:  "no query or collectionCallback is specified"
This test fails today but should pass in the future once ARC is implemented. So I would replace it with a test checking that we do not try to switch a count based resource to a memory based one.
You can use assertFalse for these.
node.getDistributionType() == SpatialJoinNode.DistributionType.REPLICATED
should reset interrupted status with Thread.currentThread().interrupt()
This should be getModified.
Can add  Utils.nonNull(segmentsFile); Utils.regularReadableUserFile(segmentsFile);  here.
you don't need to collect inside getMachineNames if you stream it again on next line. Just return Stream or maybe getMachineNames is not necessary here and just inline it. If you want to split the long stream chain I would maybe do something like  Stream<String> machinesInPod = containers.stream().map(c -> Names.machineName(podMeta, c)); return machinesInPod .map(....
Using logging would be definitely better, and maybe the exception should be rather rethrown (even if wrapped into RuntimeException)
you can just use a primitive long here
We can move this audit log to the common method. As this is common code for all ACL requests. auditAcl(OzoneObj ozoneObj, OzoneAcl ozoneAcl, OMAction omAction, Exception exception)
Why delete this line?
Can this be private, or is there another use case for default attribute outside the builder's call?
I assume the 0xffff is to deal with the down casting from long to int and making sure that it's a valid positive value?
setBounds(Bounds rect) has protected access in BasePropertyWriter and that's why jenkins fail (it is not possible to compile this PR). Will check the code, but I need Full downstream build to test this PR properly.
I think better to use string concatination, as info log level this might called lot many time and string concatination has better performance the String.format. Another place where place I could think we can make more use of make logging, if present the file full path instead of file object.
No need for else here.
This test method has no asserts to verify the results of the send statement operation. How does it verify that the send statement operation succeeded rather than simply not failing.
I think this is the condition for !editable, i.e., readOnly.
_sigh_ we need a better logging strategy.
please replase MojoExecutionException for a new generic DeploymentExecutionException
Let's make commit on each 100 nodes e.g. (it costs effectively nothing) but may prevent write buffer overflow when running with extremely low mem (write buf size is e.g. 1M). It could be also more effective to make commit on FastSyncDBWriter thread since it can cause DB flush synchronously
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations.size()).isEqualTo(1);  =>  assertThat(violations).hasSize(1);
With the new out-factored structure, hopefully we can get rid of the "backreference" to the workbench here.
This seems like a good place to use our LocaleUtils class instead.
you could use filter + ifPresent
We can use defined constants for project natures at org.wso2.developerstudio.eclipse.platform.core.utils.Constants class
I feel that these services are kind of "hidden" in the registry implementation here. In ORM there is StandardSessionFactoryServiceInitiators apparently for a similar purpose. Maybe it wold be more transparent to do it similarly? Or could these entries be registered in the integrator instead?
isOverrideLuns() operate on the value, so basically you stil have NPE here when OverrideLuns is NULL, do: model.getStorage().isSetOverrideLuns() ? model.getStorage().isOverrideLuns() : false;
minor: no need for final?
mapper.readTree(new String(Base64.getDecoder().decode(params[2]), UTF_8))
add style as parameter to above 2 methods
I suggest to resolve these two references separately, you can have two methods: Optional<Image> aboutImage Optional<AboutItem> aboutItem after that the code should be less complex
Much simpler version:  return ( symbolTables.get( program.context().source() ) != null && symbolTables.get( program.context().source() ).symbol( name ).isPresent() ) || ( symbolTables.get( context.source() ) != null && symbolTables.get( context.source() ).symbol( name ).isPresent() );
This should be ops().run(net.imagej.ops.Ops.Image.Equation.class, out, in). That way if someone writes another specialized CoordinatesEquation op, it could also be matched.
spacing
this.fileStates.remove(absolutePath); is correct.
Maybe change DEFAULT_PUBLISH_TIMEOUT to DEFAULT_PUSH_TIMEOUT?
I think this lines are not required, but never mind.
Replace by Map<String, String> result = new HashMap<>(map.size());
Use the enum Dark...
Use ConfigUtils:isBetaFlavour
It's written nowhere, but I'd prefer to have curly brackets even for single line.
Met List:  @Override public boolean inputIsConnected(int index) { return index < inputs.size() && inputs.get(index).isFullyConnected(); }
Please include clientTelemetryEnabled in toString() API
formatting
the connections collection is never used so this change is superfluous.
shall we do the same for empty string ?
To be more efficient you can use TreeIterator.prune to skip subelements
Should this be CF_METRICS_METADATA_NAME ?
do you need to add CRC here?
This is a great optimization. Should this point to first character in the ASCII table ? Also lets verify that this for UTF-8 encoding as well.
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
Does this update instance or return a new copy? Because if it's the latter then a new instance needs created for every invocation of this method. We only create the converters once but call them many times.
Change to return Response.ok().build();
Where do you use this assignment to the local variable 'authorizedUser'?
I would add cache=true/false as a parameter.
Is that really possible here given that the button is not disposed?
Would it be better to use:  java if (thing == null) { continue; }  If there are two factories that could create the thing, you will return "null" here and do not try to use the other factory.
it might make sense to provide a recordDiscarded(int) instead of this silly loop. (and above)
nit: merge with previous line seems no longer than 80
We shouldn't expect this to be an Expression. Fix the test rather than having it handled here.
Please add curly braces around blocks after conditions
this should probably fail on receiving interrupt
can this be called from multiple threads? If yes then there is a concurrency issue. fParameterProviders needs to be handle thread safe in this class.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
newWindow is false in this case only (the perspective stack has a selected element). You'll need to calculate this even if there's forcedPerspectiveId set.
Why iv.removeValue(i, this) and not iv.removeValue(i, aCause)?
is there a reason you don't just return this here?
can this mask be precomputed in the plan?
Can just use diamond operator on RHS
Apparently this method returns false when the wait time is exceeded. The old implementation was just buggy. It completed the future anyway and lied to the caller the indexing was done. The new implementation avoids this, but makes the caller potentially wait 2x the timeout. When waitForGeneration returns false the method should throw TimeoutException.
why?
What about doing one thing at a time?  java View frame = Views.findById(this, R.id.login_icon_frame_layout); frame.setBackground(new BubblyDrawable(getContext()));
I would have put it after the createAnnotationAndAddSubscription call.
Why not in combination with above do this: setValue(value, false);
In lines 41 and 42 you're using o.get("port").isString().stringValue(). Pay attention that method JSONObject#get not as simple as it may seem. I think it would be nice to move o.get("port").isString().stringValue() to the local variable. Also it would made these two lines much more simpler for reading. WDYT?
Change Object to String
Do we need to check if manager is null? If not, maybe we should remove geofence manager check?
Have you checked that the test fails if the this assertion fails?
addAll or stream?
It looks like right now when a connector is made diagnostics aware, There is a lot of boiler plate the connector needs to do to parse out commands and parameters. We could consider creating a library or utils that helps diagnostic aware connectors to reduce this boiler plate. We don't need to do this right now. Something to consider for future enhancements.
Conventional header capitalisation, please.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
please add vm id for the log messages in this method
so it records stopped time only if all workspaces are stopped? Shouldn't it be all user's workspaces?
wrong code format
not even e.getMessage() ?
Result.SUCCESS
optional nit: File::getName
Please include clientTelemetryEnabled in toString() API
Why 0,8 if all we are setting is 7?
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
If we have optimized cardinality(filter(array_agg(orderkey), x -> x < 3)), would optimizing cardinality(filter(array_agg(orderkey), x -> x < 3)) = 2 be an overkill? =2 seems to be very low cost operations. Also, it might make sense to add some benchmark similar to BenchmarkArrayFilter, or even do a comparison run from Tpch query runner and add the result as part of commit message.
What do you think about Comparator.naturalOrder() instead of null ?
TextComponentTranslation allows ITextComponents to be passed to it, so the user's name should remain as an ITextComponent.
nit, Collections.EMPTY_MAP?
I'm not sure it is a good idea to include this in the equals - two accounts are equal by virtue of their properties - not on their snapshot versions, correct?
this else seems redundant
This line causes an endless load on linux when a node has zero children.
Should we only assign the external ID if it changes?
This should be done inside checkIfImageDiskCanBeAdded(VM). If the disk is a direct LUN, getStorageDomain().getStorageType() will thrown an NPE.
No space between STARTS and WITH??
The value for this test in the develop branch is the correct value. Changing to this value is a bug.
unrelated change
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
java assertEquals("Unexpected failure code", ERROR_SUCCESS, result);  Try to provide as much information about the failure - in this case, not only that it has failed but also why.
Why is this needed?
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
Same question. value is not annotated @Nullable
> isAssignableFrom fails because the classloaders used between the two classes is different I don't understand, this is with a built-in policy implementation right? How can two types that belong to the same JAR get loaded by different classloaders? Regarding Dynamic-ImportPackage: *, as far as I understand this is the nuclear option, so I still see a value in allowing users to pass their classloader to the builder.
Here, source and dest should be specified as @NonNull, it would avoid the null check below, and won't throw an exception if the compareTo method is called with null as dest.
this doesn't looks good at all :( let's log the exception using Logger.warn().
should(times(1)) is the same as should()
here schema is always not null
You never close the BufferedReader, this will create a ResourceLeak, wrap it in a try with resource statement  try (BufferedReader br = new BufferedReader){ .... }
This only runs on Gtk3. How about trying to set this to not run on gtk2 instead? would this work on cocoa/win32?
Use context.getCapabilityServiceTarget().addCapability(...) if possible.
this should just be type != Schema.Type.STRING (you can compare directly for enums). It is not valid for it to be an array. If it is, it means the field is an array of arrays.
no System.gc() before/after?
still for DAO
If it got deprecated in Gtk3.10, then it should still work between Gtk3 to <Gtk3.10. You may wanna put this around a version check instead perhaps?
Is the purpose of this to show the user the REPL prompt again?
You can use StringUtils#defaultIfEmpty instead of the ternary expression.
I think you could avoid the GSON dep by just calling  java inspect(launchEnv, objectId, "{{.Config.Volumes}}")  or something along these lines.
Would it be possible to fix workspace object as soon as possible in the chain, so we would avoid ifs like this in the code later?
Maybe just inline this into the for loop that walks over the caches in getCaches(), and fold getCaches into this method. There isn't a lot left and you remove a completely unnecessary intermediate O(n log n) TreeMap insertion step.
the definition can move to the else block
Throwing an IllegalArgumentException could be confusing since it's not the arguments passed to the invoked method causing the problem. Maybe throw new InvokerInvocationException(ex) or  throw new InvokerInvocationException( new AccessControlException("Illegal access to method" + cachedMethod.getName(), ex) )
what if the account id, container id is 1? I think its probably better to do something like "current id + 1" so you are sure it is different
assertEquals
Local variable could be declared List instead of ArrayList. Is this worth caching?
calling Thread.isAlive() seems like a bad sign. I don't think fixing "query engine source single" or equivalent should be considered out of scope here
We can validate only if validation is running?
I like the way you change it (very smart) however I think this change is a very good candidate to create an unit test to test previous code working against new code.
what if extension does not return VALID_TO? I guess you have null pointer exception.
reference would be concatenated w/o a separator. Is this intended?
These parameters are too complicated and redundant: baseURL and baseURL + id
I think we should also allow here a comparison with a String (fullId) and Metdata (map)
can we have test case for this method? Like pass in a list of scopes and see if it returns the right DC
Gson doesn't run on these versions so I don't see any reason to include them.
There is no need to generate mvn(groupId:artifactId) requires. RPM depgenerator handles it itself.
next time you can leverage switch case for ENUM
1. You could just make calculated limit a field that you set in the constructor instead of reading it here. 2. If you don't do that, I would make it final here. 3. Would it make sense to have a lower default value, like 100? All of these are trivial and probably not necessary.
Do we need two debug logs here?
Instead of removing "bbbb" which is the longest element so won't have trailing spaces, try removing "a" or "c" as it's a better test.
Ugh. Why do we have updatePresenceStatusForXmppProvider(pps) and updatePresenceStatusForXmppProviders() that implement the same logic twice? :/ I know that's not related to the PR, so I don't expect you to fix it
Perhaps put sendError(ex); after the branch (since it is the last statement in each "leg" of the branch.
Check if value is null.
I feel like this test and the above test have switched titles.
The SerializerException is completely unrelated to the operation codecs - you should throw something else
this can be an info
what's the difference between checkAuthAttributesAreValid and areAllAuthorizationsForResourceValid? I thought that the plan was to replace the former by the later, right? Since areAllAuthorizationsForResourceValid can perform all of the work that checkAuthAttributesAreValid performs. And in fact checkAuthAttributesAreValid only makes a number of calls to isAuthorizationAttributeValid. I think it may be the source of potential security breaches if we maintain both methods and a user ends up thinking that it's safe to only call isAuthorizationAttributeValid when in fact, areAllAuthorizationsForResourceValid should be also called. Please, correct me if I missed something.
why not make "update" a constant too?
we can set variable directly here.
Can even use Iterables.filter(locations, SshMachineLocation.class), given that it's only passed to an Iterables method afterwards. That would save the subsequent casting as well.
let's just remove this function
There is actually yet another error here: this should be java int start = Util.toIntUnsigned(getValue(ir));
you need to check that keyValueSeparator is not -1 (ie no = in the line)
remove
You might want to store the view as a field in your class if used multiple time. findViewById has a non negligible cost.
wait.forElementVisible returns WebElement, so you can assign the value to avatar here and then remove the line below completely
no need to define this variable that early, move ruleIndexer.indexRuleDefinitions(disabledTemplateAndCustomRuleKeys); after dbSession.commit(); and get rid of the ugly variable initialized to null closing the connection is not that important. The correct code would pass it to ruleIndexer.indexRuleDefinitions anyway (or it wouldn't really be closed so that a single SQL session is used by HTTP request)
OperationException
I prefer the createMock because it is more strict. Can we just add consumer.host(), consumer.port() in the mocked consumer object?
Don't make this an ImmutableSet when the builder gets converted to a FetchHints it will take care of that
Message seems to be unused. Remove this line?
we don't use braces around singe line blocks
you are really testing everything !!!
what if result is empty?
Not necessary to call getType here.
Can you please add a WARN log stating an attempt to stop the driver when it was null.
Local variable could be declared List instead of ArrayList. Is this worth caching?
You don't need this line because of green 31.
Is there a particular reason to make the rect a single pixel shorter and narrower than the graphics object? It causes a black border to appear on the right and bottom sides of the display, which doesn't affect the test fidelity but also seems unrelated to the functionality being tested.
See my question above regarding using mocks.
put an empty line after
Use IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST here (also in other places).
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> escape), we should avoid @Nullable parameter in the constructor.
Condition seems unnecessary since INT4 is returned any way.
We are using assertj for assertion, please use this instead:  import static org.assertj.core.api.Assertions.assertThat;   assertThat(logger.isErrorEnabled()).isTrue()
needs to consider customAttributes?
L112 and L114 conflict. And validatedNumaMap doesn't seem to be used anywhere
Clean up in a finally.
can you pull this from a static string?
don't make getDetails return null, instead return an empty hashmap.
This is not required since you are checking for null in view
Why not just define the new question index as -1 like what we do in JS file instructorFeedbackEdit.js.  javascript const NEW_QUESTION = -1;
It it better to throw unchecked exception than simply print error because if error occurs then variable 'm' will be null and NullPointerException will be thrown later (line 16). try { m = MessageDigest.getInstance("MD5"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); //use logger instead throw new RuntimeException("No Such Algorithm: MD5"); }
here we need to use instead this pattern: java java.net.SocketAddress addr; if (channel.hasAttr(REMOTE_ADDRESS_OVERRIDE)) { Attribute< java.net.SocketAddress> attr = channel.hasAttr(REMOTE_ADDRESS_OVERRIDE); addr = attr.get(); } else { addr = chctx.channel().remoteAddress(); }  Calling attr(key) while it is not set will have the side effect to create the attribute. Attributes cannot be removed.
"put(key, val)" will take extra lock that you don't need.
Please construct it, passing in the file?
In this block, you could avoid doing two conversions(String -> int, int -> String), and use directly the String value returned by execDmc.getThreadId()? That way this code will be ready to handle the "new" thread ids without change.
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Would like to see a check that these docIds are correct.
Throw a NullPointerException if address value is null.
That's what I wanted to check with you on irc: we don't want the typeId here, but the metric Id (the string like MT~feed~resource~etc. I don't remember exactly the pattern)
I think we can remove this or downgrade to trace as we already log right before sending.
== false is a bit silly :)
Do we need to show the gluster volume mapped to the storage domain ?
Should we put the check here too?
instead of path separator create new path to make it generic
try using stream api for filtering
should isShutDown be volatile?
if (sigatureAlgorithm == null) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);
Cloning after calling getEyeLocation is unnecessary
add this selector to UI mapping at the beginning
ImmutableSet.copyOf() would probably read better here.
use lambda syntax
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
Google Java style always uses braces for if and while statements
style nit, put the { up with the if clause
please don't swallow exceptions. Re-throw up the chain.
Note that there's nothing wrong with leaving logging in to help debug problems later. Loggers can be enabled/disabled while the program is running. If calculating the arguments are expensive, prefix with if (logger.isInfoEnabled()) "
can we refactor to reduce copy-paste with fromList?
URL Decode would be necessary for parameter name and value
Magic numbers here and in the line below
This is incorrect. If ps is null, you'd still need to close fos. You need to rearrange the try block to acknowledge the existence of two resources - nesting is the usual approach.
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Sometimes we overload the createExchange method on endpoint to take in parameters so we can create the exchange that is specific of this component, eg the code below can be part of the createExchange(a, b) method
Nit, I don't think this error message is appropriate. I remembered @lei-xia reviewed this in the previous ticket, this path invalidation is not an error in the server. So keeping info (or warn) may be good enough.
Why delete this line?
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
why exit here ?
You moved this method only to another method, but is it really correct? If the scheme is http the default port is 80, so all is fine. If the scheme is https the default port should be 443 and so uri.getPort() should be checked to be 443. Okay, this only affect the strange situation if someone runs https on port 80, so we should perhaps never run into. But shouldn't it be fixed?
You may want to extract attribute.getAttributes() into something, so as to not repeat the call a few more times.
Two thoughts here, both 'nice to have' (it's also ok the way it is). 1) Since you're already cleaning up, maybe it's unnecessary to hold _result as an instance variable? 2) Perhaps fenceNode() should already return FenceOperationResult and not FenceStatusReturnForXmlRpc?
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
This IMHO introduces a rather surprising piece of global state into the translation. What about extracting a relativeTo(namespace) method that returns the appropriate Function?
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
It should call getNameTextField().discardAllEdits(); instead.
"Finish calculating assignment." Usually, we don't like pasting code details in the log. Consider what if we change the method name in the future?
Can you move the Config to ConfigKey instead?
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
please apply formatting
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Let's add DataWord.ONE predefined value
Also mention that they will be ignored
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Extra newline
RU compatibility?
- this should delegate to call two functions above. - also, here name would be a bit confusing from displayName. Maybe @rongrong could provide suggestion.
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as  PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL)  as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
I'd rather put all there magic strings into constants
Why this change? Do we still need the doPrivileged?
This should be atomic - looks like it was broken by INT-2856. There is a small timing hole where there's no recipients, or an incomplete list.
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java .put(TESTER_NAMES, testnames.stream() .map(ProjectTesterImpl::maybeQuote) .collect(Collectors.joining(",")));
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
Extract the 75 to a constant, it is used in more places.
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs, ...)?
Same here.. Should it be a utility?
This also happens when enabling legacy token options in the security configuration, and seems therefore inappropriate for a warning.
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
should it be endsWith instead? .class can be in any part of the string
Logic is pretty broken. Let's make it in sync with naming, i.e. we should call decrypt only if isEncrypted. so inside get method do: if (isEncrypted(...)) { value = decrypt(value, CRYPTO_PATTERN); } and remove your 180-182 if lines...
There are some project types that are not AbstractProject like Build Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstractProject that causes problems in these scenarios but those should be fixed as time goes on (hopefully) and maybe we could try to avoid those problems here. Can we find a better class or interface to check for that also has getTriggers?
i think on update we should use null as "don't touch device setting" (if its there leave it, if not don't create)
Unhandled
Are we able to test this method ? Same for updateStateOfReplicas  method.
Use getBackend() instead
if this is called on edit, then this check will fail.
what happens when inputSchema is null? Also, to reduce indentation, we prefer:  if (inputSchema == null) { return; } // Rest of the logic ...
nit: no need for else clause here
I don't think you need this since state ids are supposed to be unique.
This change does not seem to be related to the bug being addressed.
Move the namespace to a common place and a constant
We need to be careful here because we're adding a node to the parent node outside of any synchronization block, which could cause problems.
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>() );
I think lowercase l should also be considered
invokeAll on an empty list returns null. So you may want to handle that
should you be checking for variable == null ? for clarity's and performance's (slightly) sake even if it might be logically correct and checked in getVariablesByRegex()
change method signature to return interface List as opposed to a concrete class
Doesn't this result in two calls to loadEnv (the other in checkConfiguration)?
format as final String[] array. Rename to errorMessage if possible
this variable is unused
segmentStoreStatus
Catching JsonProcessingException here will encompass JsonMappingException and JsonParseException. Or catch both explicitly.
I would prefer to use same code as in method getProjectRelease  final Set<String> releaseIds = project.getReleaseIdToUsage().keySet(); for (string releaseId : releaseIds) { ...
instead of transport!=null, could we use globalConfiguration.isClustered() ? when reading the line, it seems like we are avoiding a null pointer exception (like protecting) for an eventual transport null instead of something that explains that indeed it needs to be clustered to check it's a coordinator
Should we add some warning message here, in case of ClassCastException ?
Definitely use parameterized logging here instead of string concatenation, because otherwise this method will be generating garbage objects on every call!
You don't want to move them all to hamcrest?
not using mapNames and mapAge?
I would throw instead of just logging it.
This can be private, I think
rename toRefresh
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
here too we could use getClass().getSimpleName()
This will run every minute while Jenkins is connected to Gerrit, I don't think that is good, nor what you intended.
log should say store is not initialized.
you dont need this line You can simply do Metrics.newHistogram in the line below
why do the values "true", "yes" and "1" equal true?
Replace with retVal = wish1.getIndex().compareTo(wish2.getIndex());
Here have to be 1 self link
We can use private here.
I think we can just move this out of the done loading listener, which would keep the table in scope
rename to column
Log as _error_ or _warn_?
This should be log.error. Don't know why other statements here use log.warn
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
Please don't print stack trace like that. Either log it properly or ignore if the information is useless.
Translate this log message in English please
Wrong method name in log message.
Should perhaps make this protected (or package protected) since it's only used internally?
String.format?
This should go before this.starts.next() as if this.starts.next() is empty, it will throw FastNoSuchElementException and the previous iterator would not have been closed.
@vilchik-elena what if parent is a parenthesised expression?
I would prefer it if you could save all settings (soundeffect and soundtrack) in the settings object, not the main object <review
*style*. same line
right.getHighValue()?
cache?
Optional.map
Is the old method, <code>updateFeedbackQuestion</code> still used in the code?
I think only calling setVisible is fine here. We don't need to also toggle "enabled" if you also omit the enabled flag in the menu xml.
This won't work... now your just breaking builds without proper checkout. Please make it throw AbortException.
Instead of performing the candidate search in the get() function above, you could do it in this function and avoid the double control lookup for each candidate. And since this method returns all the info needed to return projects and project.Namekeys, the get() function could then call this one instead of this one calling get().
There are a couple of copy-paste lines here and there, could you please refactor it a little bit? e.g. extract the reader.readEvents-reader.commit loops to a method. The assertion part (listFiles, checking the count, removing from the expectedLeftFiles, checking the emptiness of it) might be possible to extract too, to improve the readability of the code. (e.g. void assertExpectedLeftFiles(String... expectedFileNames))
Yes, what Tor said: Please add a dispose() in LayoutCanvasViewer and chain the dispose methods.
nit, Collections.EMPTY_MAP?
I think we should close the StringReader after unmarshaling.
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
Already adding network incompatible change, might be a good idea to encode more boolean flags into byte[], potentially also giving a way to add future changes. It's small amount of data so probably not really worth it as an optimization, but it would allow to add 5 new flags later while still allowing new clients to join old servers.
I think we should create a defensive copy of the Map
Minor: use AssertJ org.assertj.core.util.List.list and static import for readability.
I know this doesn't really change from how it used to work but not all ListValue implementations have constant time random access - FilteredListValue hasn't. So it would be more efficient - at least in that case - to use the iterator instead.
I've been meaning to ask you if there's a class I can actually instantiate, thank you!
You should update this as well. This should require the MODIFY_SESSION privilege.
well, of course I can read the code and understand, but - still, maybe enum is better.
Extract if conditions into named structures (variables or functions), like isThread, ... ? (Especially the last one is difficult to comprehend)
Can you use LOG.debug("CSS parser error: {}", exception.getMessage());
instead of creating a new StringBuilder object, you could maybe do something like: text.append("Date: ").append(date.toString())); (you might need "\nDate: " depending on what the line situation is)
Missed one
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
are we guaranteed that this mapping is the only thing stored in the metadatastore?
Add a check for the number of warnings
these 2 for loops should be replaced by a single entryset iteration
The entire emails is the join link?
typo "host address"
Does this one need to be changed to '...' too?
What if workspace is not running at the moment? It doesn't mean that workspace is restarting at the moment, or language server will be restarted as well, do it?
Immutable?
I am just not 100% sure why the conversion to BigInteger is needed here.
As it's a nullable field, null protection would be good just in case: if (occurrence.isValidated() != null && occurrence.isValidated() != validated)
Why are you checking the members inside the compute block? I smell race conditions since the membership change does not have to lock this map.
I'm not a fan of this solution - it creates an additional coupling between the different commands. How about the following approach - we should only update the status if the image is on a DATA domain: [pseudo code] StorageDomain sd = getStorageDomainDao().get(image.getStorageDoaminIds().get(0); if (sd.getStorageDomainType().isData()) { // update status to illegal... }
It seems like we can add two storage domains at the same time
This is actually adding functionality, since in 3.0 only system-disk is bootable. I think method should have an oldAPI flag, and in such a case break on the first system-disk and skip non-system disks.
Should this be a write lock because we might delete the page if there is not enough space?
Should be final
Iterator could return multiple items erroneously and pass.
& is not correct need to use &&. if data[0]==null then data[0].equals(Boolean.TRUE) will through a null pointer
Not sure why we allow null for the event list when the monitor gets cancelled, but not for the link list?
If we remove the null check, will it results in NPE? (Line 74)
Sure, you are right. This saves a stat call. Done
I see, what I'm more pointing to is that we are testing multiple/all aspects of firingGroups per test rather than testing on behavior at a time. For example, it's considered a best practice for tests to have only one reason for why they would fail. If for example the firing group size were to change *or* if the displayName were to change, then this test would fail. At a more concrete level, isolating the behaviors makes it easier to see which parameters control which outputs. Hence I'm suggesting to pivot the tests to group and isolate the tests that verify display name, size, etc.. and do so independently.
Nit: I think the mask is unnecessary, when you cast to byte the higher-order bytes will be discarded. suggestion out[i] = (byte) (msb >> ((7 - i) * 8));
can we also have a test that validates the case when we have a none-string field in span_ctx? (Validation should fail in this case)
why you need this? isn't there is the same code below? For local typedefs?
btw, do we need try catch around destroyProcess?
I like that we create the operator here as now we push further down the runtime-related stuff. In the future we could have a translator that gives, for example, not an operator but sth else.
This also blocks the ui thread. You could use ModalContext.run() instead.
rulesList will never be null, widget#getVisibility always returns a list instance.
This variable name doesn't seem meaningful?
I don't think you need to flush() and clear(). Considering this init is specific to the test method, I would have moved it to the test method and would remove this setUp() altogether.
This looks suspicious: call to Optional.get without .ifPresent. You can avoid having those misleading Optional-s, if you replace .collect(groupingBy(...)) with .collect(toMap(SortExpressionContext::getSortExpression, c->c, SortExpressionExtractor::merge).
This causes the warning Plate is a raw type. References to generic type Plate<T,S> should be parameterized.
Why not just have the property be a JSON array of strings?
I think this should have its own integration test as this is nth_value specific stuff only
Move both to variables for consistency.
testStr1 is not used in the test case anywhere.
Is there a reason why these are called "value1" and "value2" instead of more meaningful names?
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Add a break to this if? Then, this condition is not needed.
Try:  java final List<PoolBagEntry> bag = connectionBag.values(STATE_NOT_IN_USE); int removable = bag.size() - config.getMinimumIdle(); for (PoolBagEntry bagEntry : bag) { if (connectionBag.reserve(bagEntry)) { if (bagEntry.evicted) { closeConnection(bagEntry, "(connection evicted)"); removable--; } else if (removable > 0 && idleTimeout > 0L && clockSource.elapsedMillis(bagEntry.lastAccess, now) > idleTimeout){ closeConnection(bagEntry, "(connection passed idleTimeout)"); removable--; } else { connectionBag.unreserve(bagEntry); } } }
This could be combined with the previous line.
Why create a separate Kryo instance for every partition?
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Map
It is the perfect case for a try-with-resources.
Can the filteredHeaderNames be put into a case insensitive TreeSet? Then this nested loop could be converted to a contains.
See objection to "standard neo4j.conf file" above
should just be inside try block
this line is gone, why?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Typo: attemp_t_ToUpdate
redundant ";" character
nit: we don't do this (argument alignment) throughout the project, any reason to start with this method?
This won't work on blockdevice. Take a look at how the StoreMigrator does it.
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgWithFreshAcsrfToken, instead of getTokens and getTokenValue)
Can you separate it into two lines as because of the condition in check style plugin i.e. you can't put more than 100 characters in one line, the build is failing.
Number of rows of input does not change since we don't allow reshaping of layers. Thus, checking the number of columns is enough.
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
this should be moved out of the try/catch at all filters
log statementId as well?
I don't see clusterId being used in sync-job. Is this required?
You should access the attribute directly
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to put fileInfo into both write cache and read cache. And we need to increment refCount by 2 because we put that FileInfo into both read cache and write cache
inline this variable.
seems like we would like this log message for all exceptions no? can move this to mutlicatch as well.
isUnauthorized 401
@CheckForNull
doesn't Files.walkTree work here? or does that have a problem with this being inside a jar?
You can use assertEquals here as well.
Variable name should probably be change to bundle or subscriptionBundle since this is not a subscription object.
This is very odd; not the sort of thing you should catch. Can this be prevented?
This is super minor (coding style): let's add a single space character between the , and new. You can perform this automatically by selecting the line (better select this single line only) and use "Code -> Reformat Code" from AndroidStudio's menu. Thanks!
NIT: are we sure we don't want to call it 'compatVersion'? :-) also in subsequent patches I think the one letter adds more clarity :-)
You should have this loop also under the childStart loop
It's too bad we have to resort to regex for this, is this format considered fairly stable and unlikely to change in the response?
Debug still needed?
This needs to not have the sunburst text, check out Skyrider Elf
> I feel like site_id here makes more sense just because the only use of it is for the network calls. If it's used for network calls, it's not "local". Local_id was used for blogs/sites because we can have a mixture of self hosted and wordpress.com sites, so we can't use the id provided by a network response. Will this be used for wpcom sites only?
why public?
I thought that we did not need to have this mapping in the compute engine
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request);
Does it really make sense to have a plugin with multiple secure-stores ? What would be the rationale behind it ?
Does this do anything outside of test mode?
I would rather use a constant such as com.splicemachine.primitives.Bytes.UTF8_CHARSET
suggestion LOGGER.trace("The service with name [{}] is not found in the cache, try to find it from [{}]",
Should there be a check to make sure the asset is non-null before modifying it?
Shouldn't this code run even if mHasWifi is false?
after this line, call collector.getOrThrowException() to stop execution if there are problems.
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
There are a few other mocks higher up in this method. This can be moved to be with them.
These strings are not meant to be translated, so move it to ApplicationConstants instead.
no need for StringUtils, modules.keySet() will work nicely :)
You can move the inner loop out of the outer loop so that you dont have to set all the fields for each split. That way you will be able to reuse the builder
Shouldn't this menu reflect either hide or show? Or does this one menu apply to the entire MTrimBar?
I think Local.ROOT is probably a better choice.
These first two test methods are identical except for the slice creation, and can be replaced with a single method and a data provider.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
I think we should avoid printing stack traces and make the app crash... Could we setup an error activity or handle the error as transparent?
suggestion if (containsHtml(text) && qualifiesAsConvertedList(text)) {
Do we have enough examples for same that will show violations for all the items you added in this input? None of the other inputs changed in violations, which makes me think we may not have enough examples.
No need for this step, just use this.attachmentList directly.
"don't add another exchange"
I noticed that this change affects also getRequestURI method. It is mentioned also in the analysis. We should probably extend test coverage also for this method too.
suggestion long requestOffset = buffer.offset; CollectCoordinationResponse<T> response; try { response = sendRequest(buffer.version, requestOffset); } catch (Exception e) { LOG.warn("An exception occurs when fetching query results", e); sleepBeforeRetry(); continue; } // the response will contain data (if any) starting exactly from requested offset buffer.dealWithResponse(response, requestOffset);
Please use ""
is this left by mistake ?
Avoid variable names like event1
As in DateWidget you don't need this variable just return binding.getRoot() at the bottom
Add Override annotation
Ditto about interfaces
I almost settled for this solution as well, but then I tested Win7 at 125% and got {120, 120}. On GTK at 125%, I get {96, 96}. What this implementation effectively does at 100% and 200% is to return DPIUtil#DPI_ZOOM_100 (which is 96) as x coordinate. But at 125%, DPIUtil effectively uses a deviceZoom of 100%, which explains the different results. I'm undecided at this point whether we should change Win32 or GTK, but the two need to return the same at 125%.
Should maybe be "SocketException has occurred"
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
Why would hdfsHost not be set? That should come from the mini cluster config.
An empty loop can be written as while (vcfReader.read() != null);
Why change the initial size of the selectedProjects? It used to be projects.size(), now it's request.getSelectedProjects().size().
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
The only reason you had to override next(), expose pendingObjects, and duplicate all of this code was for this r.has(BOUNDARY) test? Any way we can skip that flag test on the commit?
Is this a safety check? Whats the case where this would be null?
pass in the metric registry
Make this a debug log. if (log.isDebugEnabled) ...
Why is it a list of lists, not just a list?
Is this really what you want? If you get an exception, you'll be returning null for a query on a record that exists, but that can't be parsed.
RocksPageStore will be in a bad state after restore then initialize.
You could also use -> Objects.toStringHelper() from guava
This should probably go to System.err, as goes e.printStackTrace()
Why reverse the logic? I thought we normally write termination condition first, before recursion.
Local variable could be declared List instead of ArrayList. Is this worth caching?
why not this String nodeSourcePoliceClass = StaticPolicy.getClass().getName() ?
This code is an exact copy paste of the code just 20 lines above, can we avoid this :fearful: ?
These aren't equivalent. The StringUtils version checks for null and "" in one call.
It is probably not necessary to use a mock here. One of the fixture in ServerFixtures should work just as well.
You don't need this restriction and createAlias calls, I think you should have one restriction in place of the 2 lines above like this: Restrictions.eq("m.patient", new Patient(1)) Alternatively you can load the patient by the patientId first and use the loaded patient object in place of of new Patient(1)
why not just use packages as its name
Add a check for the number of warnings
Why don't you use formatCurrentTimeForId() here like the line 217 below? Likewise for the line 115. We can pass the time as a parameter to that function for general cases rather than just current time only.
better Exception
You're still taking the performance hit here, as you're walking the iterator and storing the sourceId in a variable _only_ to be used in the debug. Instead... java if (LOGGER.isDebugEnabled()) { LOGGER.debug( "subscription is a site-based subscription starting with site id {}", sourceIds.iterator().next()); }
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
check if you can use fluent api to add the storm tag
Same as above, either introduce a local variable or just use getCompiledScript() in the expression, but don't reassign the volatile field.
No need to check whether this is zero. The for loop won't iterate. (I see you did so for a Log warning, but I don't think it should be a warning, the user can simply detect the empty array.)
Isn't it better to user iterator().next() instead of creating ArrayList from Collection? getQueryReturnValue().setReturnValue(users.iterator().next());
ArchitectureType.forValue(rs.getInt("architecture")
If you create a new HttpClient' all the time and start it, doesn't it need to be stopped again?
what do you think about instead logging it where the other log statements go here? <LINK_0> I don't think passing a listener down to the publisher is great as its mixing two concepts, the listener has nothing to do with it
It is danger to use equality tests with floating point values. Is it correct usage here?
Excuse me, I want confirm with you about "A suggestion for a follow on change would be to add any permissions only projects as candidates even if they are not yet parents since that is likely their sole purpose: to become parents." here can I understand "to add any permissions only projects as candidates " as to delete Line 54?
Don't use default shell, dialog has one.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
let's change this if to - if (Guid.isNullOrEmpty(storagePoolId) || !FeatureSupported.refreshLunSupported(DbFacade.getInstance() .getStoragePoolDao() .get(storagePoolId) .getCompatibilityVersion()))) end eliminate the else cluse from line 105.
extract into method?
per the style in rest of this file, add a space after "if": s/if(/if (/ and same for similar if statements below
I think the order of entries in these maps are undetermined. You probably want to sort both the expected and actual to ensure this does not randomly break in the future.
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
this can be done simpler using a sorted stream of param entries to produce output string
initialize with US_EAST_1 than null and remove else part.
pls log the "else" cause of this if
if there is unhandled exception it will cause that opengrok will need to be restarted, isn't it better to check for Exception or Throwable?
We need to test the regular constructor without a custom serializer.
@dkayiwa Are there any visits without patients? Should this not fail with an error?
In the error message userid should be null instead of case_id ? Also in the jira issue, seems like owner_id was not defined while from the error stack it seems like userid is getting set to null. So I am a bit confused what exactly is happening.
Any possibility of the module string being group:artifact:extension:classifier:version or group:artifact:extension:version? i.e., do we require custom modules to adhere to the 'exec' convention?
Technically this is doing needless byte to char conversion. E.g. were it a multi-byte encoding, then decoding is not worthwhile. My original thinking on HeadHandler was to have the principal buffering at the byte-level. E.g. a BufferedReader(InputStreamReader, /*tiny*/200) atop a BufferedInputStream. Then when all the needed readLine() calls are done to just read() and discard from the BufferedInputStream - probably not a byte at a time but with say a very small byte[1024] buffer. (Using readLine() here would defeat the goal of avoiding needless heap allocation.)
Rubbish
Again, on purpose to avoid the array list
I am missing why we're offering to delete a test when the user clicks on rerun
This handler is not used at all, please remove it.
delete on exit?
no need for the "this"
Is there possibility to use here some more specific exception ot it must be catch all?
import it directly -> import static org.carlspring.strongbox.net.MediaType.APPLICATION_X_GZIP_VALUE;
Well, you could make BeanAttributesConfiguratorImpl.qualifiers and types package-private and use something like:  throw BeanLogger.LOG.noCallbackSpecifiedForCustomBean("Configurator [types: " + Formats.formatTypes(attributes.types) + ", qualifiers: " + Formats.formatAnnotations(attributes.qualifiers) + "]");  Hm, BeanAttributesConfiguratorImpl.types should be final - pls add this change too.
why wrap the shoSelectInstanceDialog result in a Set?
Remove all the sharedpreferences here instead of using clearToken() method. When one logs out, the application should clear all the saved 'SharedPreference values'. clearToken() will only save a blank passcode value and all the remaining sharedpreferences will remain intact. You can save the Instance Domain to make it convenient for the other users to login but it is already handled in LoginActivity.
We won't detect if newProperties contains a property that is not in oldProperties. Shouldn't we? Why don't we just do oldProperties.equals(newProperties)?
I'm not sure that's correct: what about code like alias\foo\bar?
This looks fine, but we should be consistent with how we are exposing parameters from our libraries. I would vote for either: a) Exposing all parameters with the names that they have in the underlying Java classes, so that people know what to expect, or b) Same as (a), but always exposing certain properties with standard names (eg. startDate, endDate, location). With this in mind, I would favor simply exposing all parameters as they are named, modifying only onOrAfter=startDate and onOrBefore=endDate and locationList=location @djazayeri did you have other visions for these libraries and how they expose parameters?
Same issue with usage of WRITEOPENW as in RemoteSageFile class.
What do you think changing the name to memory. We do not know whether it is in kilobytes?
This builds the set on each lookup. It should be built once and then used.
strange, what fails? what is <jsp-file> you are using?
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
no longer necessary, after changes in xml.
ParseUtils.isQuoted would be good for this.
it is better to extract these endings into some list and iterate over it, it will be more readable
Don't forget to delete this
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the value anymore.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
What do you think about putting this in a class constant instead to improve visibility/maintainability?
Does it?
Do we need to distinguish StreamsException and KafkaException (StreamsException is a KafkaException and both are fatal)? Actually similar question about KafkaException and Exception? The different error messages don't seems to provide much value?
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been merged and the DifferenceState. It seems very likely that setting the DifferenceState to a proper value (either MERGED or DISCARDED) would allow us to not use the MergeMode in the UI to compute the icon to use on a merged diff. I want to take the time to consider all that fully.
Do we need to do another lookup here? We have the consumer already, is there a reason we're not just translating it straight away?
Whats the meaning of catching an exception just to rethrow it under a different class?
if you use "android.R.string.ok" there is no need for changing the strings.xml file
is this needed for the test?
You don't need the extra \n when using println
space after if
why not null as value?
Hm. I guess it would be a weird case (some variants with names, others without in the master playlist), but it would be strange if we ended up exposing some tracks with indices for names and other tracks with actual names. How would you feel about: No name: Integer.toString(index) With name: Integer.toString(index) + ':' + name The same will apply for the TODO in the WebmExtractor, where I would guess some tracks having names and others not having them may be more likely.
Should this be try with resources? I don't see the reader closed
There's no point to else here...
Again, constants would be nice for readability.
You could replace lines 933 to 945 as follows to make use of short-circuit evaluation:  if (file.isFile() && ((suffix == null) || (file.getName().toLowerCase().endsWith("." + suffix)))) { files.add(file); } else if (file.isDirectory()) { listFiles(file, files, suffix); }
Can be possibly moved to shouldShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place.
This step is same for standalone as well as domain ;-)
nit - for me creating ke is unneeded. Create the exception directly as the argument
Maybe "[No preview available for contentType]"?
docPossibleAncestors and revPossibleAncestors?
Everywhere in this file please use getAncestor() instead of getFirstAncestorOrNull() where possible. getFirstAncestorOrNull() is designed for multiple values types.
use rewrite than getVisitor
The duration variable should be qualified with the this keyword.
shouldn't we have an array of configs (just like the others)?
The other formats are actual formats (HTML or MD) whereas simple is just plain-text. Maybe instead of simple, it could be txt or text for plain-text?
let's call it updateCodeMinings() instead.
It would be sufficient to check lower-left and upper-right corners.  checkLatitude(envelope.getYMin()); checkLatitude(envelope.getYMax()); checkLongitude(envelope.getXMin()); checkLongitude(envelope.getXMax());
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down to selectReadReplica?
Same as above, maybe I misunderstand something
May I suggest a pre-check for getParameterCount() == paramTypes.length in order to avoid possible allocations coming from getParameterTypes()?
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
I believe that setters normally return the type/value they just set as well.
please include the VM's ID as well
This causes a compiler warning, please either suppress it or remove the exception throw entirely. Warnings in snippets cause noise during the build process so we can't submit patches that introduce them.
Just a thought, will it be better if we make a getCopy method and make the copy-constructor private? Something like:  java public FeedbackQuestionAttributes getCopy() { return new FeedbackQuestionAttributes(this); } private FeedbackQuestionAttributes(FeedbackQuestionAttributes other) { // as per this method }
Wondering what happens if shutdown takes forever. If we did add a timeout, what would happen then?
isnt segmentsMapToFind? (not Maps)
Maybe I missed something but could we implement this like that ? java if (certificateTypes == null return setIdentity(privateKey, certificateChain, null) else return setIdentity(privateKey, certificateChain, Arrays.asList(certificateTypes))
![BLOCKER](<LINK_1> Close this "FileOutputStream". [![rule](<LINK_0>](<LINK_2>
please change to 10
Instead of comparing type and value for equals, do this:  return type.isComparableTo(other.type) && type.compareTo(value, other.value, other.type) == 0;  This will ensure that a CHAR type of 'AAA' will equal a VARCHAR type of 'AAA' and a DECIMAL type with a value of 5.0 will equal an INTEGER type with a value of 5.
Might as well call delegateFirehoseFactory as firehoseFactory from the start. The renaming isn't doing much useful anymore.
Instead of returning here based on course access, we should make setHasOptionsMenu() dependent on it like: setHasOptionsMenu(courseData.getCourse().getCoursewareAccess().hasAccess())
If we're no longer using a translator to translate the owner, then the owner translation should move outside of the if(translator != null) block. And since there are no other entities being translated by a translator, then that block can be removed completely.
let's change this to look like try { return objectMapper.readValue(jsonString, type); } catch(JsonParseException | JsonMappingException | IOException e) { throw new RestMappingException("Error maping jsonString to " + type + ". jsonString = " + jsonString, e); } that way we pass the exception to the RestMappingException constructor and get information about what kind of exception occurred.
Could you remove Error message from log message and give to logger the exception ?
I don't understand what this line is trying to do.
I would change this. If the caller passes in a trace token that starts with {, but it doesn't parse as json, then I would just call registerRequestToken() using the raw string value. That way we continue to pass along the trace token that was passed in to us. Creating a new request token when we were given one doesn't seem right.
put some context to wrapper exception.
Will journal be null ever?
nit: add braces.
Pass null as a listener, it will dismiss the dialog.
Can we inject this feature directly ?
I think here we could just us a file-handler just the configuration is less complex and slight less overhead as there is no WriteHandler.preWrite() invoked. Really not a big deal though.
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
The PROPER solution would be to make getContainerItem NOT return null, as Null ItemStacks are not valid anymore in 1.11
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
same thing here, it doesn't need to suddenly start working after the first experiment, plus is this test strictly necessary, considering it's subsumed by attemptsExperimentAgainAfterEnoughTimeHasElapsed
just use context as synch obj
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
Replace this with The number you have entered (<Number>) is too small, it must be at least 0
token.toString() will not print token.decodeIdentifier().getUser()) which may be useful in debugging. UserGroupInformation.getCurrentUser().addToken(token) ignores null tokens. Better to log and skip when token is null like below instead of changing the current log statements.  for (Token<? extends TokenIdentifier> token : allTokens) { try { if(token == null) { LOG.debug("Ignoring null token"); continue; } LOG.debug("Current user: {}", UserGroupInformation.getCurrentUser()); LOG.debug("Token from credential: {} / {}", token.toString(), token.decodeIdentifier().getUser()); UserGroupInformation.getCurrentUser().addToken(token); LOG.info("Added delegation tokens to UGI."); } catch (IOException e) { LOG.error("Exception while trying to add tokens to ugi", e); } }
For some reason, getString() has priority in AOSP so it can skip the resources. suggestion numberOfNamesInList.setText(numberOfNamesInList.getContext().
This is not an integration test, you're working with a mock version of Github. This test method belongs to another class (and another ticket)
Here I have 4 connections and the dialog shows 4 lines with <unknown> as a label.
does this work if we have two accounts on different servers but the same username?
Typo; Should be authentication in lower case.
I don't understand here: why do you need this change here? it doesn't seem to be necessary.
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
LGTM in general. There might be performance/less memory consumption gain by declaring Color pixelColor outside of the loops and then just updating it, however I'm not sure about it - maybe it is optimization that JVM is able to do itself. Not a merge blocker in my opinion.
Is this what we want here? If so we should have it as a Log method then.
This will always be false? What did you mean?
how often is this method called? Why not cache this computation like you did the others?
How about in-lining o1 and o2 since they are not reused?
I would rather get rid of RuleSetAdapter because: * it assumes that rules in RuleSet have particular semantics (e.g: only one rule matches) * it wraps and executes rules in a different way than during actual optimization * it doesn't allow to test how rules interact (e.g: trait rules before other rewrite rules) * it only allows to test rule set which are grouped in RuleSet, but we might want to test not grouped rules (e.g: trait rules and rewrites). * it is a work around RuleAssert limitation of testing singular rule. I would rather test multiple rules explicitly in RuleAssert with assertions.
Platform.exit()
THIS!!! THIS IS THE PROBLEM!!!! Look, it needs to be Integer.parseInt
This would be better as:  java if (projectsAdded.add(targetProjName)) { IProject targetProj = ... }  That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate contains check.
Usually tryLock shall return a boolean instead of throwing exceptions.
You can remove this line. It is probably just for debugging.
Perhaps 'Not unpacking {file name}... 'would be better - this gives the impression that there are no unpacked variables in the file - but this may not be the case - config could be overriding this.
docPossibleAncestors and revPossibleAncestors?
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
else throw an exception with a descriptive message about whats wrong.
Shall we use 'isValidCacheRequest' like method name, as this is a boolean operation. When reading the method, it does not look right. It feels like if request is valid 'return'. it should be like if(isValid()){ }else{ returnl }
I'm not certain what the correct thing to do here. If there are multiple groups in flight and the outer observable is unsubscribed, do we want to unsubscribe the open groups, enqueue onCompleted elements on them but let them run, or something else? Window has this anomaly as well where the unsubscribed outer may never deliver an onCompleted on the inner windows and thus they stall.
Need to revert this code. Should always have id and subsystems
Strange... the JDT UI settings in our projects should remove trailing whitespace. Please remove.
looks like you missed these
@cuenyad use factor variable
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
style nit: no braces around single line blocks
I can't remember why it needed this? And I get paranoid about it since I spent months tweaking the multi server configurations to not break.
Could you check for null or empty? Via StringUtils.isBlank
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
I think you want to pass in the errorListener to super
Logic is meant to be a facade class. As such, you should put a method deleteAllStudentsInCourse in StudentsLogic and have this method call that one instead.
Please write a method ProcessService.getNumberOfChildren(process) which is calling the ProcessDAO to count on database
rename 'listeners'
Why it is named by testLoadYamlFileFromDirectory ? Does it mean it will include all .flow files in the directory?
These seem like class constants.
Do we need this? The java doc for "yield" says, its rarely appropriate and used for testing or debugging.
Doing it this way will not update the actual Pod spec. I think we need to add this in createOpenShiftDeployment()  PodSpec podSpec = new PodSpecBuilder() .withContainers(container) .withVolumes(getVolumesFrom(volumes, workspaceID)) .withTerminationGracePeriodSeconds(OPENSHIFT_POD_TERMINATION_GRACE_PERIOD) .build();
"SocketServer time spent on write per key"?
NPE when req == null
You can use CollectionUtils.toImmutableList
'e' is not logged
huh?
might be safer to use a constant for "cookie".
Please refactor DbFacade.getInstance().getLunDao() to a method...
When does this method throw TckRepositoryException?
hostsPerTable.get might be null if beginCreateTable but finishInsert didn't. There is a race condition here I think
It seems like we can add two storage domains at the same time
Calling cancel method like this will not actually cancel the task. You have to do this through task driver.
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
Better to return Optional.empty()
There's a utility class for this. Check out DisplayUtils.dpToPx()
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
It may be easier to use [GenericJson](<LINK_0> java GenericJson genericJson = new GenericJson(); genericJson.setFactory(OAuth2Utils.JSON_FACTORY); String content = genericJson .set("foo", "bar") .set("asdf", "qwer") .toString();
InterruptedIOException
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
It looks like we create new mappers very frequently. Is that supposed to be the typical use pattern for Jackson? Does creating these have any kind of cost? Can they be re-used?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
This needs to be the last line of this method.
Perhaps we should add 1 or 2 more cases with reordering the scalars a bit and gather some more confidence regarding the assumptions on the ordering of the arrays. What about select b, b.id, a, a.id from EntityB b left join b.a a?
This can be collapsed to a single line.
move this up, than you can use it in the if as well.
Nice, i was wondering if this would work for overloaded methods and it appears it does (i.e. findSliceInvoker1 is defined if a previous findSliceInvoker exists.
Logic is pretty broken. Let's make it in sync with naming, i.e. we should call decrypt only if isEncrypted. so inside get method do: if (isEncrypted(...)) { value = decrypt(value, CRYPTO_PATTERN); } and remove your 180-182 if lines...
That's wrong. Please see org.intellij.erlang.psi.ErlangSpecFun#getReference and isReferenceTo() method.
unnestChannelInputBlock -> newInputBlock
Can this be private, or is there another use case for default attribute outside the builder's call?
input and expected output should be copied to test's input folder.
I'd consider writing a helper like this to remove boilerplate:  private <T> List<T> nullToEmpty(List<T> list) { if (list == null) { return Collections.emptyList(); } else { return new ArrayList<>(list); } }  and then call it in constructor like this.mavenOuput = nullToEmpty(mavenOutput);
This can only happen if the ref disappeared after the caller resolved it. I think it is okay to return Collections.emptySet() in that case.
Remove this :)
this won't work. in the immense majority of cases, the declaration of the parent method won't be in the same file, and so you won't have access to the modifier.
I don't think these are still necessary, because of the catch block on line 1053.
This method sums over the second and third dimension.
I think CDA is not the place to set values
Have a look at <LINK_0>
Timestamps within the last hour are rounded to "0 hr. ago". I personally prefer showing "X min. ago" for those cases and "A moment ago" or "Just now" for timestamps within the last minute.
nit: would case switch be better?
can we add this. in front of setting these fields
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 21 to at most 20. [![rule](<LINK_2>](<LINK_0>
What are the conditions under which this branch can happen? Can't we say that there must be a SharedSlot when this method is called? Making this stricter could allow us to catch other programming errors faster.
"authentication timeout"
String.valueOf
Please re-format this method in your IDE, I suggest using the Eclipse code formatter located at config/engine-code-format.xml (If you're using IntelliJ IDEA, you can install the "Eclipse Code Formatter" plugin.)
you need to check for null case
order of operands
I think I prefer spaces before "leap-day" and "year-day", but not too important. Wikipedia has all words capitalized (and no hyphen before "Day", either), so you may want to check some of the original references.
Protect against an empty url? (If url is blank, this will throw IndexOutOfBounds.)
fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)
I think we can remove this line.
Doesn't this return an int? So you can't orElse?
Don't return, just do a continue so other modules can still add their state systems as children.
Move this binding to StorageModule.
I feel like there should be a better way to do this...
Could you, please, explain, why verification the command palette had been removed?
Formatting issues
you miss the "&& mouseOver"
Looks like spurious changes with no changed behaviour in this file. Necessary?
nit: for src code readability & more explicit error message java Preconditions.checkNotNull(p.getParent(), "Path for page %s can not be root", pageId); Files.createDirectories(p.getParent());
I think the unmodifiableMap should stay in getRoutes().
Please use "something <operator> null" convention
Again, these should not pass validateInputs()
Use UTF-8.
Update labels to go with method names. Alternately, call super.toString for super attributes
can you add some docs around this method.
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Missing braces
Hmm, I'd reformat to make it more readable: if (host.isInFenceFlow() && (host.getStatus() == VDSStatus.Down || host.getStatus() == VDSStatus.Reboot)) {
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
repeated ...
Delete try/catches. An exception always fails the test case.
if a column was missing, should we ever match it in this case? fn.apply(value) looks a little bit unusual as value is really an element from the Range of the function and not Domain. may be it should be...  return new BooleanValueMatcher(false);  @xvrl ?
Is this really more readable? (IMHO it's not)
Can we pass the string separator instead of configuration to avoid unnecessary Configuration.get() for each RPC?
Actually, in what way does this change relate to adding a new status command? Because this change affects all other CLI commands perhaps it deserve its own separate commit. Anyway, just making sure this change landed here voluntarily and not as a result of mingling with another context...
I would use else if here
deviceIdentifcation => deviceIdentification
from L257~262, you can use Strings.repeat
This should be a triggered ability of the enchantment, not a trigger gained by the creature
this class doesn't have tests?
ah, I forgot that the primary key components are part of system.schema_columnfamilies, not columns, so that wasn't a problem.
Can't we create many arrays with this change if there are high partition counts? Maybe we should calculate the size upfront.
Should go into @ After method to make sure it clears authorizations even if an assert statement fails.
datum.toString() seems suspicious
The fail()method throws AssertionError which is an Exception. Either use ExpectedException or change your catch clause to catch the exact exception you are expecting
what if storageDomainDR.getJobId() != null, won't we need to use storageDomainDR.getGeoRepSessionId and storageDomainDR.getStorageDomainId instead of getParameters().getGeoRepSessionId() and getParameters().getStorageDomainId()
This turned out great, I think it's really easy to understand exactly how we get retries to work properly with this code.
This can't be true, as Math.min() would return max if nsz would be > maz. :-) I think you really meant to write: if (buf.length == valid) { if (buf.length == max) throw When buf.length == valid we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == valid) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw ...
Can this be private, or is there another use case for default attribute outside the builder's call?
How did you convince your IDE that primaryIP is definitely not null here?
We have the two letter codes here only for backward compatibility and changing it will break it. I suggest we remove the two letter code for Japanese.
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
detach?
Please dont use this {0} , and use String.format instead.
Could you check for null or empty? Via StringUtils.isBlank
Immutable?
I think this is overkill with memory allocation. We can revert back to the model we had in 0.6 and used a thread safe data structure here.
subMonitor.newChild with 1 tick
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
If this is never going to happen, why modify this to be less chatty?
extract this rethrowing to a new method
This should have the data source name in the message and add the actual identifier as metadata on the alert. The messages are what turn into the email subjects... Also, after the alert happens, this is going to fall out of the if statement and do other things. Are we sure that those other things are what we want it to do?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner:  Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri()[0], "Config server URI is undefined.");
braces seem unnecessary
nit: can replace both checks with CellUtil.matchingColumn
Minor ( ): Consider removing the cast to NoteEditorActivity for this case, it is not needed, isn't it?
Add newline before return.
would be nice to have the message in the exception here because this will also show up on health check potentially, and that only shows the direct message iirc. IOTW I don't think "Could not process request." is more telling than the cause.getMessage()
Are you sure this won't cause MC to access parts of ChunkCache that aren't there? It's reasonable to expect it to get blocks from outside of the range between target and current position to get around some obstacles.
No need to use a separate xLogAxis variable (especially as it's a local variable, so there is no multi-threading danger whatsoever). Also change the original code to avoid unnecessary instantiation: NumberAxis xAxis; if (!...) { xAxis = new NumberAxis(xAxisLabel); } else { xAxis = new LogarithmicAxis(...) ... }
new byte[0] is kind of ugly. Maybe another method that doesn't take it?
Extra space after synchronized.
nit: "Raptor page writer max buffer size."
Can't we use ITypeMarshalBuffer.BASIC_TYPE | shiftedKind | ITypeMarshalBuffer.LAST_FLAG and not write kind separately?
Do you want to make the check that portFields is of size 2?
Seems this should not be public. Why providing such internal structure is needed?
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can use.
Why do you wait?
Put these three blocks into a helper maybe.
Should it be numJsonBytes?
This line is now unnecessary because disposedOperators is updated in disposeAllOperators before throwing an exception.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
jsonRow != null? So what will be happen when jsonRow is null?
Better: append this unconditionally, and only append the other part based on the condition.
This cast will fail on any primitive array. e.g.,  java new int[] { 1, 2, 3 };
Please don't introduce labels, as I removed them in anoher pull request because sonarcloud complains about them (and not just sonarcloud)
I wonder if that would better to rename to fromSupplier(). And yeah... remove that from(Supplier) altogether. Breaking change, agreed, but no choice. I will find this explicit casting style more annoying than removed method. WDYT?
If you want you could build the whole string directly as: String s = bids.stream().map(snapshot::getBundle).map(this::represent).collect(Collectors.joining());
not sure why this switch case is required - just use whatever is passed in?
Hi Tolis, would you mind to move the code below to another class?
Package private constructor, rather than just public?
Should we really be returning an empty map of properties? If this happens, isn't it a system internal error? How about throwing an exception?
Are we using lamda notation in this project?
this check is again done in getTaskCategory(..) and is redundant.
Spacing
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
Remove conditional + exception. Uniqueness is guaranteed here.
The only reason you had to override next(), expose pendingObjects, and duplicate all of this code was for this r.has(BOUNDARY) test? Any way we can skip that flag test on the commit?
I think this is a bit overly complicated as we can only copy the file if we find it (e.g. fileToExport is not empty). Moreover, please show a warning in case it is empty.
Don't catch bare Exception
s/createPolygon()/createMultiPolygon()
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
This doesn't look right. Should be:  result = services.get(result.getId(), k -> this.serviceRegistry.findServiceById(id, clazz));  Also, don't forget to check the result to make sure it's has the correct type based on clazz
Since the subject isn't initialized until the callback returns. Won't this most likely lose the race and cause an NPE? I think this could be solved by making an AMLoginInfoTask subclass that provides latching mechanisms like AMSubject and Subject. So the code here would look something like (super approximately): LoginInfo info = new LoginInfo(); info.execute(); info.await(); assertThat(info.result(), ...); // Even more approximate if (info.legacyAuth()) { Subject subject = new Subject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); } else { AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); }
use of raw class, should be new ConcurrentHashMap<Long, Boolean>()
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason. It's safest to simply return in that case.
can you make the name more explicit? array doesn't indicate anything.
should cleanup be in finally block?
You also need to transform for the attribute for old version 2.1.0. I recommend looking for usage of ChainedTransformationDescriptionBuilder to make it easier to add transformers in one place going forward.
Even if it's very unlikely in this context, you could test whether the getViewer() return null or not (the return contract is "the EditPartViewer or null") before calling deselectAll()
Runtime Exception
This method can be left blank-will not be called for a block-scoped step anyway, unless it is doing something between returning from start and the BodyInvoker.start.
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
Nit : you don't need this local, you could just inline the member in the next line. (it doesn't matter)
This is unrelated to the current PR, but seeing -argument looks strange from a UNIX perspective, where usually we use two dashes for long args and one for the short version (e.g. -v, --version). Could we change this to suggestion "--push-endpoint", cheWebsocketEndpoint, "--runtime-id", String.format( "%s:%s:%s", runtimeId.getWorkspaceId(), MoreObjects.firstNonNull(runtimeId.getEnvName(), ""), runtimeId.getOwnerId()), "--cacert", certProvisioner.isConfigured() ? certProvisioner.getCertPath() : "", "--registry-address", Strings.nullToEmpty(pluginRegistryUrl)));
I'd prefer to remove/deprecate AsyncTracer in favor of proper APIs to support what we want to measure. <LINK_0>
Please use diamond operator, you don't have to repeat time a second time. ArrayList<Integer> a1 = new ArrayList<>();
It would be more Java-idiomatic to not modify the input variables (they're actually often declared final)
should the SortExpressionExtractor be renamed as well?
Should stay consistent with the rest of the params. java public VideoDecoder( final EventPublisher eventPublisher, final VideoDecoderConfig config, final String broadcast ) { ...
This if condition is already covered by the one below.
In general, I think we should start the tasks that need to be started, and then stop the tasks that are supposed to be stopped. The other way around could potentially introduce latency.
If someone tries to add a plugin which already exists, should we overwrite it? Naively, I would vote yes. (Though I suppose you could remove it and readd it, otherwise-but then there are two separate events.) And actually it might cause problems/skew if the PluginIndex was overwritten with a new version of a class, but the SingletonServices ignored that new version and kept the old one, no?
This has to be cleaned up.
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit in memory a VSM via hard to read and duplicated logic. Simply craft a VSM with the 8 possible combinations and make the test simply call validation on it. * The test does not cover all the cases.
nit: Doesn't matter much because these are just examples, but I think it would be more clear to use the methods on the options builder instead of using an opaque properties object, like Option.Builder optionsBuilder = new Options.Builder().server(Options.DEFAULT_URL);
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Remove this call to "wait" or move it into a "while" loop. [![rule](<LINK_2>](<LINK_0>
Check null case?
please put in a separate method or rename this support method accordingly
skipOnly is named terribly wrong. However as long as it means "continue search only when", you should _not_ modify this if.
Shown on the UI so should be i18n aware.
- Does Consul take docker client as a parameter?
Could you please move this message to the ThingStatusDetail of the updateStatus call below? This way users will see it in the UI directly.
Why not directly call a canDeleteInstance(input) ?
I think this check if not necessary and next check device for null be enough .
Shouldn't have printStackTrace() in production code switch to logging.
No big deal but think readTree accepts JsonParser too.
@vmaletta I think ep should not be there. Maybe a merge issue, could you please check?
we should check mMediaUpoadHandler != null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Looks like this now should be withing if (result && this.fullStatsEnabled) as well.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
unnecessary linebreak
IIRC anonymous users will crash here because they have no user account to get the prefs from.
Should we expose it users?
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still improve readability of the code. What do you think?
Do you think it would be better to find a way of doing this without sorting a collection on every call?
Not really that big of a deal, but a group matching seems safer. If for what ever reason this property changes to something like 11.0.0_02 this would return 0. Below is essentially what is used for determining the version for domains.  private static int getMajorJavaVersion() { int major = 8; String version = WildFlySecurityManager.getPropertyPrivileged("java.specification.version", null); if (version != null) { Matcher matcher = Pattern.compile("^(?:1\\.)?(\\d+)$").matcher(version); if (matcher.find()) { major = Integer.valueOf(matcher.group(1)); } } return major; }
This seems defensive also, and it's also just a sample in a test. If the underlying method the handler invocation returns isn't expected to return null, then we shouldn't check for null and we should let the NPE happen.
maybe use dnsServerAddress.isEmpty()
flowName is not necessary as an additional method argument since it can be obtained from azkabanFlow.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
There's another potential issue I just noticed. The following code is only invoked within the launchDaemon() method, and not from launch() method: * <LINK_0> So can you please try using supervisor.launchDaemon() instead of just supervisor.launch()?
return flagdown; ?
_cough_ You might want to remove the println. ;) FYI, you don't need to create a new PR, just make a commit to your branch.
Any insights of this change? If the inetAddr isUnresolved, shall we just fail the bookie, because: - if it is a fresh bookie, the address '127.0.0.1' that it announces is wrong. - if it is a bookie already registered, the address will be different from the ip in the cookie. I am not sure why do we need this change here.
unecessary test : less is more.
1. The code that tracks memSize needs to not run when the resource profiling is not enabled. 2. You don't seem to handle mutation of the strings. What happens when the string is replaced?
I believe we added a guard class to the sdk that will do this exact check.
Why the sub string ?
nit: remove this extra line
Should be the responsibility of service/requestman layer after Hibernatization
There needs to be an optional API that can accommodate a user supplying a seed other than assuming the DEFAULT_UPDATE_SEED. Otherwise, the resulting Jaccard would be garbage if the original Tuple sketches were created with a different seed.
Does it actually fail if the expansion path is not recognized? In a normal situation I know it fails silently, returning the query results as nothing happened, so it wouldn't fail. But as it's wrapped in this VrapRequestDecorator maybe it's checking it against the RAML specification?
what's the point of doing this?
Create new lists rather than assigning them.
can be assigned inline in class member definition
just use an EnumRenderer in the view instead of localization in the model (and modify Enums.properties...)
This should be List or Strings
might want to change this to checkButton.setText(Strings.isValid(checkBoxMessage) ? checkBoxMessage : "<NONE>");
We could just always use the body instead of flipping based on the payload size.
Codacy found an issue: [Use explicit scoping instead of the default package private level](<LINK_0>
can we also include a test where we set includeInsights to be true?
This looks rather scary here: I would think you'd want the return type of #processUpdate to indicate whether there was an event that should cause everything to be reset?
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
I think this should be after oos.writeObject(o);, in case there is buffered data. In any case, before obtaining the byte[] result.
prj is not a good name for variable
We should change that test, it makes it cumbersome to implement rules in parallel.
This isn't really great, as startAngles could be empty.
nit: final modifier for unmodifiable variable.
modify it as it was implemented in ENG-10264
What are the possibilities of a null return value here? I guess such a case depends on how clients define ParameterUpdater, but is it okay to let that happen? Just out of curiosity, but this seems more of an entire EM question.
Hm, I think this should probably fall back somehow in its current form, or throw a much more explicit error if it fails. Before we had a guaranteed no-error, since the array was fetched from ID resource. Now it could get removed and our error message would be incredibly vague. Especially since this can now fail due to a change in commcare-core that is quite invisible to the end-user here.
this doesn't look like new code... was it reinstated after a merge or something?
Cloning after calling getEyeLocation is unnecessary
If the test fails, unsetColoring would not be called. Could presumably affect other tests.
What is the reason for the longer version? EDIT: ok, did no see it was from hibernate. You could use String.join from Java 8 though.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
I think you may be able to .put the added PartitionData into sessionPartitions up front, and capture the value returned by the .put, as it will return the previous value. If the previous value was null, then we add to added, if it was not null we add it to altered. This will save us the additional containsKey check.
This seems sneaky
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
Having execute{Head,Get,Post,Put,Delete} are just wrappers to execute() for convenience and readability across APIs Spreading the logic of type checking will lead to confusion in future and its not a good idea.
Why is this hardcoded to 4 threads? Should there be an option to control this?
suggestion
Didn't we talk about reusing the code of SyncAllHostNetworksCommand? Maybe we can have a util for 'getUnSyncNetworkAttachmentsByHost'.
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
This can be small D double
boolean strict = Boolean.getBoolean("nuxeo.start.strict")
checkNotNull
s/Started/Starting
This statement is the wrong way around, you are checking for the opposite, so remove the negations here. Also the armor item and the SlimefunItem need to be swapped too.
Why do we want to return here ? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fPostListenersByPartId.get(listenerPartId)
you can append "twice()" to the expect
Swap the equals condition.
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should check its own overflows.
I think that if JsonObject and JsonArray implement it, we need to remove them from this list as well
I Don't like this at all: the superclass is now doing different things based on the subclass. Prefer: factor out into an abstract method where each subclass does their own thing.
no need to specify type on RHS
I would prefer a bit more OO way, something like: new KeyValue(key, value). append(new KeyValue(key2, val2)) ... .toString Than the KeyValue would be an inner class which looks like this: class KeyValue { private String html; public KeyValue(String key, String value) { html = "<b>" + key + "</b>" + value; } public KeyValue append(KeyValue other) { html += "<br />" + other.toString(); return this; } public String toString() { return html; } } BTW there is no real need to worry about StringBuilder vs "+" in the GWT since it anyway compiles to JS and it is hard to tell which way is faster (in some versions of some browser the StringBuilder, in some the "+" but the difference in this small amount of concats is not significant...)
Incorrect grammar for "is correct include"? Either "is correctly including..." or a semi-colon before "include"?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
One cannot assume the request object in the context to be always of type of HttpUriRequest. It would be safer to use the generic HttpRequest type here. Otherwise everything looks good to me.
doesn't the node need to be closed?
Pass "e" into the LOG call and remove the explicit call to print the stack trace. (Avoid calling e.printStackTrace();)
assertFalse(...);
I would like ot be extra safe here and it becomes smth like OS.GTK3 && !OS.isX11. This way I would be confident it would not have effect on X11.
Check what happens with an empty file: Looks like on replay, both openFile() and closeFile() calls are skipped since there are no recovery entries for that file.
I'd instantiate the ProducerArbiter before parent and supply it to SwitchIfEmptySubscriber and child, saving on this 'relaying' allocation. (Remark, our life would be much easier if we could implement Producer in Subscriber, but since request() is protected final, it is unoverridable :( )
This should be an @Override of implemenatioin super type..
InsertOrUpdateObject?
close streams
java this(parent, batchSize, supplier, excludedKeys, topologyId); this.currentTarget = Objects.requireNonNull(specificTarget);
There must be a more succinct way of doing this using streams.
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F1, return fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
try using getOrCompute instead. Besides delaying creation of the collection to the moment where a key actually wasn't found, it also stored the result in the map, making it somewhat faster for consecutive invocations.
Should be moved into a private method that makes the above find() more readable.
Why not just LogKitten.ex(e)?
shouldn't required be true here?
minor: Not sure if there is like a single pattern we want to advocate. inlining versus having OutputStreams being pre-declared. If so, would be nice to use them consistently.
should not error if docker doesn't exist?
Should we return emptyMap if we are SUSPENDED as well?
Why are you using a Queue here? And then by extension a LinkedList?
These asserts are unreachable
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
remove "public"
IIRC patchTable can be null if a user directly jumps to this screen without coming through the web UI. (Consider copying and pasting the URL of a side by side page into email then clicking the link to open a new browser window.) So we need to handle patchTable being null here and assume diffSideA is null.
BUGBUG: Should be checking whether the shard contains the start position, not the entire event.
Should be outside the if
Should stay consistent with the rest of the params. java public VideoDecoder( final EventPublisher eventPublisher, final VideoDecoderConfig config, final String broadcast ) { ...
This block only compares AttributeAccessItem objects to themselves. It should compare them to the AttributeAccessItemDto objects from the corresponding indexes of attributeAccessItemDtoList.
There are a few checkstyle errors left:  [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./core/src/main/java/de/danoeh/antennapod/core/preferences/UserPreferences.java:1064:51: WhitespaceAround: '{' is not preceded with whitespace. [WhitespaceAround]
any reason we are using System.exit(0) do you see a hang without this?
I propose to change it to:  Map<String, String> metadata = new HashMap<>(); metadata.putAll(clusterConfig.metadata()); metadata.putAll(Microservices.metadata(servicesConfig)); clusterConfig.metadata(metadata);
It's probably best to have more descriptive names for these. "running," "direction," and "open" would be fine.
nit formatting space between methods
no need to specify type on RHS
avoid increasing visibility?!
This will loop forever if the user sets a negative size.
It seems there exists a ProActive property that could, perhaps, be reused: PAProperties#getFileEncoding. However, after a quick look, I am not sure that setting file encoding is required. We define encoding at JVM startup to UTF-8, thus default encoding is UTF-8. Then, if charset is no set when creating an InputStreamReader, default encoding is used.
This should go in a finally block in case an exception is thrown, right?
Minor: Please add whitespace before the final argument.
why is this necessary? Is the tab sometimes hidden?
on each user modification your method will be called and gather+process all the text inside the editor.. Try your modification with huge file.
The default toString on the List doesn't do the same thing?
4.2
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
Please refactor to different methods
Why is it a list of lists, not just a list?
Can be replaced with ImmutableList.of().reverse().
Use fire(event); for all EventHandler based events
rename to childItem
Please create a temporary directory and remove it in @AfterClass.
The stream() is not necessary here.
handle null case (same for rest below)
I'd break this up as java StringBuilder sb = new StringBuilder() .append(formatExpression(column.getName(), parameters)) .append(" ").append(column.getType());
the build() call is not necessary here
since you are awaiting termination otherwise, seems like this should either be an isTerminated() check or you should do an awaitTermination() anyway in the else. Let me know if my understanding about the ExecutorService interface is wrong.
if (trace) ...
Is there any value in asserting that these commands come in the right order? Although the implementation is a List I guess it protects against changes to duplicate checking or something doing an insertion into the wrong place in future. Maybe something like: if (latch.getCount() == 2){ latch.countDown() } else { fail("Wrong order")} for start and similarly with a 1 count for the stop event. WDYT?
void observe(@Observes Object event, Foo foo) has no observed qualifiers so it would NOT be recognized as a container lifecycle event - that's not correct. Also org.jboss.weld.tests.extensions.validation.WildcardObserverTest accidentally passes (the deployment fails with "_org.jboss.weld.exceptions.IllegalArgumentException: WELD-001456: Argument resolvedBean must not be null_").
s/any(List.class)/anyList/
should it return the record count?
it's a minor thing but you can avoid the duplication here by changing this to suggestion {"pass_queryname.sam", 0},  And use Paths.get(TEST_FILES_DIR, input) below.
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
Would be good to add one final assertion that the folder created exists at a non-transactional uri after the tx closes, so just make sure that a non-tx client can get a 200 response at the obj uri
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
something could go wrong here, it would be nice to be consistent and not return null but string array of size 0 like on the other functions (in other classes)
You have chose a policy=static for the reference, so it cannot be null.
Maybe just have one TextView for parcelExtra like the other samples? parcelText.setText(String.valueOf(parcelExtra));
You can replace this by: java return input.entrySet().stream.collect(Collectors.toMap(entry -> entry.getKey(), entry-> base64StringToSerializable(entry.getValue())));
It might be better off to calculate all this on initialization of the clustermap. these are never going to change and recalculating them every minute is not useful.
Maybe use a somewhat more descriptive variable name rather than 'x' :)
CREFormatException, not CRECastException
this still needed?
1) what do you want to test between line 65 to line 69? why not write it in a loop? what is the difference between line 67 and other lines? 2) you might consider verifying the mock BookieClient on how many times it is called?
i18n
nit: put input.getId() in new line, and also other calls to addOperatorToStreamGraph.
Please change to "clear tokens from local token cache for the user".
Why is this needed?
Add a message to checkState so that it's easier to debug if we ever hit it.
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right?  1 2337032 rs1129171 C T,<NON_REF> 480.77 . BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,13,13
Can we move the path to ApplicationUtils class?
@cvrebert can we move this up?
do we need to sleep(1000) here? can we make this test sequence more deterministic rather than depending on time, to reduce flakiness?
How about return Objects.hashCode(message, Integer.valueOf(desiredCaretPosition)); ?
can be replaced by:  acp.getOrCreateACL().add(new ACE("Administrator", "Everything", true)); acp.getOrCreateACL().add(new ACE(USERNAME, "Read", true));  and the code section will be  ACP acp = new ACPImpl(); acp.getOrCreateACL().add(new ACE("Administrator", "Everything", true)); acp.getOrCreateACL().add(new ACE(USERNAME, "Read", true)); doc.setACP(acp, false);
This if/else could be replaced with:  getHistoryWriterFromElementType(ElementType.getTypeFromElement(element));
This is fine, but even better would be to also catch any ToolError (e.g. a typechecking error) and print the error message on standard error.
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say "-option=value arg". And it doesn't take into account the -- that stops option parsing.
:o
OCFile now has a method getRemoteParentPath that may replace this block. Let's take advantage of it :)
- this.ephemeralCount = new HashMap<>();
code formatter missing? At least there should be a space before the curly bracket and you have a lot of tabs in here...
Why not use Thread.isInterrupted() ? I know we had that discussion already, but my memory need to be refreshed.
I think it is better to return an empty collection instead of null.
Check if this test of relation is also in BlImpl part. If not, move it there.
Could use forEach here too, otherwise we're not really gaining anything from using a lambda
in calculateQualifiedVersion(), there are other ways to set the qualifier which are not being validated. rather pull this out into a dedicated validateQualifer method and call it after qualifier was determined.
Since you are returning inside the if-blocks, the elses are redundant and can be omitted.
Do you have an opinion either way about (in the future, not now, let's just get this done already) rewriting this and any similar lines to Optional.ofNullable(property).map(prop -> new TypedValue(prop.getQualifiedType(), prop.get(obj)))?
should go to stdout, well, I would have put the stdin/stdout/stderr in context by core, but not that important for now. and again, all this can be acquire from the parser, so if we add new fields it will be available to all. all you need to do is print parser.getUsage().replace().replace().replace()...
Catch SkipException in separate catch clause
1. _1 suffix almost everywhere means that error code has one parameter. Use different names for exceptions. They are also expected to be self-descriptive. 2. Vendor-specific codes can't start with '0', '1', '2', '3', '4', 'A', 'B', 'C', 'D', 'E', 'F', 'G', or 'H'. Don't use 42S here, add some plain 90*** codes instead.
What if client is null?
Please extract to a method and call it after you verified this is an image disk
Can we use already-defined constants for the following three strings?
Just a style thing, but would it read more easily if the "exit case" were more explicit? I.e.  if (updatedInstance != null) { return updatedInstance; } instanceApi.delete(instance.getId()); InstancePredicates.awaitDeleted(instanceApi).apply(instance); ...
why do we need to check this? I believe we can directly remove
relevant non-logging code change here ^^^
The second parameter should be "addResourceSelfServiceGroup".
Minor improvement: BindingMap is a map so it's bigger than the one slot binding. This is slightly better when not returning the score:  public Binding apply(TextHit hit) { if (score == null) return BindingFactory.binding(binding, match, hit.getNode()) ; BindingMap bmap = BindingFactory.create(binding); bmap.add(match, hit.getNode()); bmap.add(score, NodeFactoryExtra.floatToNode(hit.getScore())); return bmap ; }
PercentType is a DecimalType and for DecimalType calling toString() is the right thing.
agreed that this block should be removed
Why are you using supplyAsync here? createFromInitializingJob should be non-blocking.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Since this block is repeated in above, shall we move it to a separate private method?
I don't think you can guarantee the order of the findAll results, maybe add a sort by columnLong?
You should access the attribute directly
i++ is generally the convention unless you explicitly need to preincrement.
.take(limit) is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
Why is a Double treated at a uint64_t? Shouldn't this be treated as a float instead?
Don't use final here.
You never close the BufferedReader, this will create a ResourceLeak, wrap it in a try with resource statement  try (BufferedReader br = new BufferedReader){ .... }
Probably need a better message here :)
final
format this as:  a -> a .globalGrouping() ...
Again, constants would be nice for readability.
same here as well - on failure to stop vdo service, activate and move host to original status
I don't think this is the right test... you should do something like if (superclass instanceof ParameterizedType)
That snippet is basically the same as the other. Maybe we can move it to a single place?
buffer size 1, why?
remove this... openFileInput(fileName) should be sufficient and using an Application context is often an anti-pattern
The AllCleanRule should do the work of lines 158..159, so you can skip this code.
Can you add the other flag values as well?
Minor thing: "referer != null"
can this use increment util?
minor: this v == null check is unnecessary.
Do we want to turn this on by default in elide-standalone, or did you mean to wrap this in an if block?
spacing
Why is this wrapped to IOException? You can wrap it to another OperationException. @honza-kasik , @rhatlapa WDYT?
please review code formatting
Needs to shut down the scheduler.
minor: no need for final?
return StringUtils.isNotBlank(value) && value.equals("true");
countVal is not necessary. you can use state.setSumC(State.getSumC() + count) directly.
Recommend changing this method to use the reference name exclusively. Eg.,  if ( SAMRecord.NO_ALIGNMENT_REFERENCE_NAME.equals(rec.getReferenceName()) ) { return record(null, 0); } else { return record(rec.getReferenceName(), rec.getAlignmentStart()); }
Immutable?
nit: just simplify to throws Exception
Space between if and ( Space between ) and {
why not null as value?
Could you check for null or empty? Via StringUtils.isBlank
Why this get deleted? Your code depends on this function?
ping
typo!
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
notification? i think that makes it more clear what is happening than notice
overflow = ((xl ^ yl) & (xl ^ zl)) < 0;
Why put at i-1? Wouldn't it be more natural to use i?
check return value
Could you check for null or empty? Via StringUtils.isBlank
i would refractor this method to if (!contentLengthManuallySet) { response.setContentLength(calculateContentLnegth(this.body)); } and create a new method with "calculateContentLnegth".
no need for empty default, you can use it to throw a viable exception or log a message
you control all the source here, I think it's fair to assume non null + you have Preconditions.checkNotNull
I assume these tests will never run on Windows, right?
Looks correct. I think you can just do result[1] |= shard() << 6; since bytes in an array by default are zero.
Should this be removed or moved to debug level?
Should this be a new Exception class?
The initialization of length needs to be done only once and not all the time getClonedStream() is called. If we would like to handle file length changes it does not work (IIRC) as the file size could change also after the file input stream has been created. So, I think this line could be moved above after file = new File(outputFile); Or is it because you don't want to handle FileNotFoundException twice? But reset the size all the time... Hm WDYT?
is this line useless?
Maybe more of a dashboard question, but I had thought that we made a distinction between errorClass and exceptionClass in the wording, but that doesn't seem to be the case. I'd be interested to hear the reasoning behind renaming this, as in my mind an Error in Java is not something that is recoverable
if we fail here we have a stale VM version in hand. we should roleback
final
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
We probably could return a shared instance for this as well?
So we are now failing here for all external groups? What if I want to retrieve the name of an external group by GET /groups/<uuid-of-external-group>/name ? Is this not possible anymore?
Assertj has a fluent API. You have to do assertThat(events.size()).isEqulTo(1);
No tests to cover this method! :open_mouth:
We can use the getTitleView function here instead.
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
Typically we use Map on the left hand side rather than HashMap
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
minX
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
You should re-raise an exception here or let the one above be raised. Applications are getting the wrong result in case of an error, 0. And it's certainly expected that wmic ... works 100% of the time.
Yikes. I didn't see this before. Is it in master?! We shouldn't unwrap ExecutionException like this. It makes it look like the exception happened in this thread, rather than in the other thread. For example, if the other thread was interrupted then ExecutionException.getCause() will return an InterruptedException. Rethrowing the cause make it look like _this_ thread is being interrupted (and looks like the interrupt is being handled incorrectly, because it is just caught and wrapped without marking this thread as Thread.interrupt().
you should probably check Item.Configure here
Can we move that check up to the start of executeInternal() ? E.g. we can obtain the configuration there and add it as an argument to this method. Its much clearer to skip execution early if needed.
Does it really need to be 'public static'? Is this method used from somewhere outside?
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
Check args?
Preconditions.checkNotNull(is, "Input stream required to create temp file for %s*%s", prefix, suffix);
should check results here, not just size
Could this be merged with what we have from line 85?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further logic since no further information is provided (e.g. type or format).
So now, with #615, if the prepare phase is failing, the node won't be restarted because the Nomad transaction is not applied. So status quo ;-)
This is bytecode equivalent to using the for-each syntax on an array.
Remove this check after merging #139 to develop and synchronizing this PR with develop.
The above code is only used when the Realm is defined at the Context level. That isn't what is required here. The role mappings need to be checked for the current Context irrespective of where the Realm is defined. Something like: Context context = (Context) wrapper.getParent(); A similar change would also need to be made to UserDatabaseRealm and potentially other sub-classes. Consider moving this to Wrapper.findSecurityReference. i.e. Look up Wrapper references first and if none found try the Context.
try-with-resources for FileReader
java buf.get(bytes, i, bytes.length)
I understand that this is quick and simple fix, but as experience shows we can't rely on the system clock: no guarantee that CPU will get access to the target process exactly after this timeout. In the end we are going to have sporadic test failures. The best way to sleep with short period and check the state of the component we would like to assert afterward. If you have some argument to proceed with this simple sleep, let me know here. Thanks
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
I still don't understand why the key cannot be the session id
We need to check if it actually has bootstrapProperties, otherwise this would cause Array index out of range
Seems applied to both RUNNING and SUSPENDED?
why public when all the other are protected.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I think you could remove unnecessary brackets around path
Let's not modify HadoopUtils. Instead, if hadoopConfDir is not null, set ConfigConstants.PATH_HADOOP_CONFIG in the Configuration instance.
AFAIK all jdbc objects can by handled with a try-with-resource
Why do you have to check for null here?
How about in-lining o1 and o2 since they are not reused?
Using something like this might simplify this code a bit UriComponentsBuilder.fromUriString(request.getRequestURI()).build().getQueryParams();
Can you not use a for-each loop here?  for (JsonElement jsonEle: doc.getAsJsonArray()){ // stuff }
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
Could you please log the transaction ID here, instead of the entire transaction?
should the message include "command _with options_:" + this.options ?
Did you mean to make it a constant?
needs a space b/w if and (. also with braces needs newlines
Same here with not needing the local variable.
Shouldn't you be getting this option in a way similar to this?  java SharedPreferences prefs = context.getSharedPreferences(PushPlugin.COM_ADOBE_PHONEGAP_PUSH, Context.MODE_PRIVATE); boolean force_show = prefs.getBoolean(FORCE_SHOW, false);  Accessing FORCE_SHOW directly is only targeting the String defined in PushConstants, and a String is always true'ish, thus making it not an option to decide on.
Consider to do this only once in the onInit(). Even if it is void method call, it is still a CPU tick on every single incoming message.
There's way too much try/catch in here. Check out try-with-resources (Java 1.7+) or Google Guava's [Closer](<LINK_0> A cleaner approach is having a try/catch with an inner try/finally (closing the resources) block. The try/catch could then wrap any checked exception within a RedisException.
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list assets at font path" so it's less ambiguous, it's not really failing to load fonts if you get me!
Nitpick: might be better to use constants for these.
This seems unnecessary. What advantage is there here versus before ? Both guarantee the order is respected.
pesky booleans
Move this line down. We don't need to instantiate a new object if it's not an IContainer.
Yes that's right, but code-wise if the current restore consumer only contains partitions of standby tasks then the updatedAssignment.removeAll(closedTaskChangelogs); below would be a no-op since the updatedAssignment would not contain any of the closedTaskChangelogs (well, unless we assign the active and the standby of the same task to the same thread, which is even worse).
I think Local.ROOT is probably a better choice.
please use only existing constants. LATENCY_SEC is what you are looking for :)
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-local. Also please annotate @VisibleForTesting
not that critical , but why not for (Entry<String,object> entry: tasksMa.entrySet() ) instead of using iterator?
You don't want to use an exception that extends MyNakadiRuntimeException1?
Same as above, try to simplify this by adding meaningful local variables.
You should determine if you need a regression model in the scheduler
What if there was a previous symbols list that was empty?
Please don't extract that into other methods, it makes the tests hard to read. Either you multiply the test classes, each one of them having only one test method and one setup, or you use classes with many test methods but then, each test method must be readable at a glance and not rely on other methods located elsewhere, because it makes the intention of the test unclear.
This would be better as a logger.warn, since logger.error is reserved for messages that affect system stability.
I think we could only just set the StrictMode in Application.
@hibooboo2 Did you hit this code and verify that it outputs what you expect? I don't think it is going to. I think the string needs to be a formatted string with {} where you want to do variable replacement.
Not sure what Select2Common -> SuggestConstants has to do with the rest of the changes.
nice! Thank you.
Note that using builder.setNegativeButton(R.string.cancel, null); here will accomplish the same thing.
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
rename to callgraph...
Hm, we could use == as well for comparison, as we don't have custom equals() implementation for model classes. (IIRC, most of GWTP infra code working with models just compares references.) Current code change is OK too.
The default should be updated to return 8 parameters to the test
<field name>_COLUMN
Please only log at debug or trace
Just stuff all this logic in "getAllowedCategories" so you have no if statement here. Then the case statement just has return pickRandomInsightCategory(getAllowedCategories(marketingInsightPool, marketingSeenCategories),random);
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
- store
Second parameter of Status is the pluginId. Why to pass path here?
yuk! a System.out! Either remove or use a slf4j logger here
let's change the order in the ctor - its clearer when the source is before the dest :)
BoostSourceEffect has to be removed.
why do you need to clear sortedSessionSet and add chsenSessions again ?
Could you prepare a test case that covers this? The thenComparing method doesn't modify the state of comparator but returns a new one instead making this line a dead code
May we detail the logger message a lit like > error in registering flow trigger <PojrectName_FlowName> in Quartz,
what about : this.myField ? This isField method should probably return the referenced symbol.
Why not update it in setZoomRatioInternal()? Is it because of float rounding error?
these 3 lines are common in closeXXX() and can be moved to close()
This code should use instead entrySet
please dont remove explicit initialization
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
In general, we should probably be moving away from client-side validation where possible.
Replaceable with Iterators.transform()
Is numDuplicated missing here?
Can this be private, or is there another use case for default attribute outside the builder's call?
Can you replace IDs with names in this log message?
I would substitute:  if (lx == x) sb.append(lx); else sb.append(x);  with:  sb.append(lx == x ? lx : x);  or add the missing {}.
check is unnecessary
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base will be left empty.
Why change the name the property? Accident due to mass refactor/rename with IDE?
Is it possible that this method is called from different threads, e.g. when synchronization is requested synchronously after the job has just been scheduled? If so, should check the result of calling add() and abort the synchronization if one is already in progress?
Extract notification to own method notify...
use ConcurrentUtils.withLock()
There must be a more succinct way of doing this using streams.
You can use a foreach loop of the form for(BibEntry entry : entries).
There is a lot happening here. It would be nice to break this up into multiple statements to improve the readability. Something like this: java ClientRegistration clientRegistration = context.getClientRegistration(); boolean isClientCredentials = AuthorizationGrantType.CLIENT_CREDENTIALS .equals(clientRegistration.getAuthorizationGrantType()); if (!isClientCredentials) { return null; } OAuth2AuthorizedClient authorizedClient = context.getAuthorizedClient(); if (!shouldRequestToken(authorizedClient)) { return null; }
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
I wonder if we should have a static method somewhere getAbsoluteUrl(String) and call that instead, making the code ever so slightly higher level. Config.APP_URL + is a lower level operation and I don't like that it is being repeated in many places.
I'd suggest parsing the week from "MMM" to "MMMM" even in this case. TalkBack is smart in English and it reads automatically the full month name, however it works only with some languages (doesn't work with Czech).
nit: you may also want to check !forceCloseInit.get()
Might be better to throw the Exception instead of swallowing it. I'd write something like: java public static String getFileExtension(File file) throws Exception { return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase(); }  This new method might deserve also some unit test in FsCrawlerUtilTest.
Same as above, using GeoWebCacheExtensions.getProperty would allow more options to set a property.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
we tend to like initialization like this: final A a; if (cond) { a = something; } else { a = null; } This make very clear when a is set to null;
With this change Weld will only suggest a bean matched by type only if the injection point requires specific Qualifier and a bean exists with the same type and no qualifiers. If you change the getBeans() call and add AnyLiteral then Weld will also suggest other combinations such as injection point with no qualifiers plus a bean with a qualifier.
Can we avoid this switch/case block?
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
Suggest adding "break handlePayload" here too
See above about title, file_name, and content being required parameters.
I have question about this config. Will this determine the serverfactory for ambry-frontend and ambry-server?
For null values, we just do not supply those properties in the autoGenerationOption
Also include the values here?
Nitpick: We can do the if else together here :)
I think all of the stuff that modifies the response needs to happen outside of the thread after start is called. Otherwise, the method will have already returned, so I'm not sure what would even happen if you modify the response.
I noticed in some other command line classes, the total run times are recorded. Is it worth doing it here?
Arguments should be switched.
Do we need two debug logs here?
If we expect an exception here (i.e. i see it's meant to be ignored) should the test fail() if the request succeeds?
suggestion final Deque<Integer> ccStack = new ArrayDeque<>(numVertex);
Actually, would you please have this still error? It likely represents a programmer error if the application is handing a null Collection to this method. I'd instead suggest something like: suggestion Assert.notNull(userAuthorities, "userAuthorities cannot be null");
this code cam be shared across process/subprocess property writers, isn't it? In some helper method or abstraction works for me...
It seems like we shouldn't need to override this, since it should work the same for all columns.
suggestion assertThat(filter.beforeRequestMessage).contains("/hotel");  This is analogous to the aforementioned .startsWith() change. Please apply to all affected methods.
We should implement filterOnlyAllowedAttributes() method to perform authorization check on list of RichUserExtSource as we have for groups and members. It will be part of Bl layers and called from here. Also, I don't know if we have authorization check on ues attributes. I believe, that right now they are accessible only to perun admin, and will need to configure it on each instance on deployment.
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
we just log, update metric and move ahead with next iteration?
Let's also do a null check on evidence as well
if one of them is null, the result is true? This means that they overlap?
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
It is a bad practice to print stack trace instead of logging or processing exception
This code also does not respect devices in single-SIM mode (i.e. phoneCount == 1) where there are both pSIM and eSIM slots, but only one can be active at a time. This case still needs to be accounted for using the old logic.
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
I believe this should appear below the isAdded() check
so do not resolve groups and no recursive as you going to search it anyway.
category
shouldn't need the throws declaration?
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
it also need to be checked that token not expired at the beginning and expired only when expected time passed.
it is non-standard. and the dialog should be modal, taking up the ui, so the user can't interact with the button anyway while it is open. so i don't see any value in disabling the button while the dialog is open. we usually only disable buttons during an rpc, where we are waiting for the server to respond and the rest of the ui is still live.
maybe it's better to tag them with the status so that we can break them up that way?
Can you write this conditional expression in the complete syntax ?
return Collections.emptyList();
@cyberone no need for Mockito.times(1)
extra ;?
What if the string doesn't end with a " or '? You'll strip the last character.
might be more logical to swap the order of the two lines above (install java, download tarball, unpack tarball)
Needs to be inside try to make sure cleanup happens
In this case I don't think it matters, but I think in general as we write new tests with operations we shouldn't use the constants. It's mainly a regression check to ensure the operation names don't change in the constant value.... ...though I should probably bring this up on wildfly-dev and not this PR :)
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
Just seen this... Would it be more convenient for this method to be named assertPredicate? The current name seems to mean that it will perform arbitrary assertions...
Is this a minimal reproducible example? Frankly speaking, it is really hard to follow the code, and it is sad it is the most trivial example in the PR. I would prefer to have a simple example that makes it clear what the rule produces.
Why time this... noop?
the name numRetries is a bit confusing; could we rename it to numRemainingRetries?
This should probably be done using a progress dialog instead of showing the entire activity as loading. You can do that by extending ProgressDialogTask in the FollowUserTask class
Shouldn't it be true ? (legacy SQL used for old jobs)
Can use java 8 paths.
why are you 'just' getting the host messenger?
same here, we might want to move some of the common memcached / redis cache code to druid-processing and reuse it.
We have a removeConfiguration so let's not allow null value here?
The type should be included in the context.
Use " List<String>" instead of ArrayList<String> in declaration.
Glad to see that with this change, one can now navigate the (java) code and notice the different icons the button can display. Previously, one of the cases was set vie the xml layout file.
nit: missing newline
To make this more bulletproof, can we use the variant of waitFor() that takes no arguments? The Jenkins test harness puts a timeout on each test, so if the code under test has failed, the test would eventually time out. In contrast, this approach has an implicit assumption that the CI system will be running at a particular speed, and I'm not sure that we can rely on the Jenkins project's CI system to have any particular performance guarantees.
do you really mean "master cluster"
suggestion + "the generics incorrectly, a class cast exception could be raised during processing, but the "
I think Local.ROOT is probably a better choice.
Does not compile, but not really important.
Can we short circuit here as well and return false instead of having it go through the path of validating offsets?
ID is a unique element in a page and therefore you don't need a chain.
no need for this change now
use Arrays.fill instead for loops
going to assume a potential illegal argument exception here, too, if adSpaceName=""
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
@pveentjer One potential reason why we may observe worse latencies is that registration of selection key is blocking operation. Typically, all calls to selector methods are wrapped in a synchronized block. So registration of a new selection key could be treated as a call to blocking queue. E.g. this is what happens in Linux in JDK 11 [1]. Before the change we did concurrent queue + wakeup, now we do blocking queue + wakeup. Most probably we need to have some throttling mechanism, which will prevent a call to the selector if the write operation is already scheduled. E.g. AtomicBoolean. WDYT? [1] <LINK_0>
Add newline before return.
right.getHighValue()?
Duplicated _for_ loop could be extract as a private method to factorize the code.
Creation date and last modified date should not need to be set here since the database sets them. You may need to mark them as insertable = false, updatable = false in the entity.
Findbugs reports this, as you ignore the result of read(). Please add it to findbugsExcludeFile.xml to ignore it (or you can use return value to check if the read was successful here, not necessary though).
nit: remove trim on both lines above.
I think it would be nicer if we removed the intermediate OptimizeTableAnalyzedStatement and instead directly build the request classes. WDYT?
Can we please mock the Future?
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
Pass null as a listener, it will dismiss the dialog.
The builder is from HDFS. It is NOT a pb. It has pbs in it?
Your find by ID method should be doing the same logic. SERVICE_SHORTNAME is the old way of registering a transformer and SERVICE_ID is the new way. You should be able to remove the find by filter after doing this.
When would the offsets be unsorted? Is this more of a precaution or is it common? Is it again the small file optimization?
Shouldn't we add this only in case of async actions? Maybe check if action.isAsync() == true, in addition to jobId != null check.
Setting the style isn't needed for this component as this is the default already.
Given that the Ant task already checks for the existence of installUtility, shoudn't we just combine the logic from lines 97 to 105 like this:  // If we have the kernal JAR and the product jsons exist, then we use the kernel. Otherwise just use installUtility. if (getMapBasedInstallKernelJar() != null && !downloadedJsons.isEmpty()) // do the installation using the kernel else // call installUtility
I have only several problems with this class: 1. We have AbstractSurefireMojo here. 2. We know what provider is being executed. What about to add a boolean to this method isPlatformPrvicer or enum instead of using null-checks in if ( junitJupiterApi != null && junitJupiterEngine == null ). 3. Why we do not align the versions of junit-platform-launcher dependency of our provider in classpath according to user's dependency version as well?
Use of this.getClass().getName
set it to the appOptions by default. If it's still null, set it to a new instance.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Doesn't seem possible, if the topology id matches. OTOH I'd rather retry based on ownership than on topology id...
You catch only NumberFormatException which could be thrown by Long.valueOf, but timeTZOf-> checkRange could throw IllegalArgumentException that is not handled.
In several tools, we're using "jopt" for argument parsing. Perhaps you want to introduce it here as well?
The UserStorage SPI needs to be backwards compatible. It means that UserStorage providers developed in the previous Keycloak versions must still work with the newest version without any changes needed in their sources. So the BackwardsCompatibilityUserStorage provider should still work without this change needed... The similar will be good for other user storage providers - will be nice if no changes are required in them
Can you make these 5 seconds a constant like the other timeouts?
null check?
Not mandatory but we could save some duplication by refactoring these tests
This is no longer needed if MVs dont support indexes.
As a reply to your TODO in line #126- Seems that your code ("moveMacsFromOldMacPoolToNewOne();") should be moved to line 92. And should be in the same transaction with "getStoragePoolDao().updatePartial(getStoragePool());". Line 91 includes the update of the dc mac pool. So in case of a failure (crashing of the engine for example) after the mac pool update and before moving the macs to the new pool, the dc will be in inconsistent state and needs to be reverted.
The blank lines before and after method bodies are quite strange. We don't have rules about that but it seems inconsistent to me. It could be valuable to have feedback from others.
This is pretty inefficient, the way you would normally do this in JGit is: while (baseUrl.charAt(baseUrl.length() - 1) == '/') baseUrl = baseUrl.substring(0, baseUrl.length() - 1);
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
Could also do:  ApiDate lastSeen = Optional.ofNullable(r.getLastseen()).map(ApiDate::new).orElse(null);
Return the provider object using new instead of using Class.forName(...) as we have only one provider per module.
final
since getTerminalAtIndex can return null there should probably be a null check here (realize that it's vanishingly unlikely given the current contents of the panel!)
This method need not be static
Curly braces in the same line of if statement. Add spaces between variables and operands, such as cursor != null
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
Let's remove the BsmAdminPageEditWindow(String) constructor.
As I have mentioned previously, Item/Build is nonexistent. The Java constant is Item.BUILD. The permission as displayed in the UI is Job/Build.
do we need this composite? we have already the border composite
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
why is this necessary?
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
If we arrive here the statusCallback is notified already in the DownloadBatch.batchCannotContinue method, right?
Should this get a trailing newline too?
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
ambry does not support PUTs. You should do the same thing you did in AdminBlobStorageService here.
foreach loop, append the comma always and then resize the stringbuilder => shorter, clearer code, and more efficient :)
why? just don't set _vds, and if _vds is null then do not enforce. I think we talked about this. Always use the engine interfaces.
Asserts.succeedsEventually(new Runnable() { public void run() {assertEquals(x[0], 1); } }); will avoid waiting 5000ms when 1ms might have done.
cleanup this temp dir afterwards
handle the case when splits[1] is empty?
Couple of things here: (a) we can use Preconditions.checkArgument/checkState - less verbose (b) When throwing exceptions, I think it's good practice to include useful information. What dimension? What's the shape of the array? Without that, I need a debugger to get that information, which adds a lot of time required to fix it...
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
Debug has to be detected first otherwise we'll always take the INFO branch.
a bit of NPE's will happen inside of combine on the first exception
I'd avoid introducing new term target  partitionData[i].ensurePositionsCapacity(page.getPositionCount()); partitionData[i].resetPositionCount();
Should be Reflections.getAllInterfaces(Class) to get interfaces on superclass and so forth. Returns a List<Class<?>> instead of an array, but should be OK.
why final variable? :-)
folder.listFiles() will return empty array if no files in the directory. We do not need to do a null check here since testFolderPath must be path to a directory
Any specific reason we are handling 2 tables in a single file? This might throw off some people. Also, if we are making the separation, wouldn't it be better to do it in FluxC? I haven't thought about this too much, so I am actually asking and not suggesting :)
suggestion && (((BaArmor) part).getType() == getType());
This might be cleaner with a stream, something like:  Optional<IVolumeSource> vol = podSpecVolumes.stream() .filter(v->v.getName().equals(volumeMount.getName())) .findFirst(); assertTrue("Expected to find secret volume in pod spec", vol.isPresent());
Should we make this intermediate commit point *configurable*? I'm hoping committing every 10,000 is a sane default, but just wondering out loud if it's worth making this a configuration setting.
_cough_ You might want to remove the println. ;) FYI, you don't need to create a new PR, just make a commit to your branch.
There is a better way so that a new Arrays.asList wrapper won't be allocated. java.util.Collections.addAll();
Remove the * 2
