Is this order guaranteed, ie ls-refs before fetch?
These are magic numbers for zoom level. Pull out 12 and 13 as MIN and MAX zoom level constants.
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
Here is also that unusual check.
Please remove an excessive space character.
wait, am I missing something, or would encrypted passwords no longer work with this change? The password used to be  password = new PropertiesLoader().parseValue(password);
hmm can we just use: java executorService = MoreExecutors.listeningDecorator( Executors.newSingleThreadExecutor());  ?
rename the method to createResourceIdAttributeStatements
why not public?
in 3.0, the external tables are created inside warehouse directory. context.warehouse.getDefaultTablePath .. takes if the table is external or not as a parameter.
Actually the underlying objectExpr could have free variables.
ERR_DELETE_ERROR, add if there isn't one already
map - confusing name
in what scenario path list will be empty with copy error set to true ?
We try to avoid returning null to express absence. Could this method be refactored to return an Optional<URI>?
I am unclear on the extensibility of the code in future. Will we add more selectors and cascade them in future, for example versionBasedSelector/Pruner?
check to make sure notificationUUID is not null
nit: might be clearer as: return involvedTables.stream().anyMatch(this::isValidationNecessary)
I'm slightly worried about doing the shorten here. It may start to come up ambiguous against other branches. We won't expand a shortened name like "review" to "refs/notes/review" because RefDatabase doesn't consider the "refs/notes/" namespace as one of the search prefixes. This should be a different method, maybe in the NoteMap class?
Seems like there's a spacing issue here, two spaces instead of 4.
this is a test... better to use Assume.assumeThat(j.jenkins.servletContext, Matchers.isInstance(ContextHandler.Context.class)); as that way if you run the tests on another servlet container they will be skipped rather than fail
This is not correct. The link is inserted in the user json object so "self" must refer to the user href. Suggestion: return a LinkBuilder here and use the method .withRel("confirmMobileNumber") in the UserResourceAssembler.
Should this be part of VM's equals()?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
public void fireEvent(GwtEvent<?> event) seems a bit redundant now. Is there a web bindery replacement for HasHandlers?
this.redisTemplate
Maybe IOException since it's supported here?
I think that it would be better if the result message used "Space" instead of "OrganizationalUnit". What do you think?
i just started to merge this and i think that change might have been an artifact from your rebase at some point as i see that style in tp34. sorry about making you change that. i will probably go back and add that change to tp33 after this merge is done.
Should this be String.valueOf or is cnn the way to go?
This is different than the one in InputPortInfo. Why? Should they? If not, you might wanna extract this code to a static method in PortInfo and call it from both this method and the one in InputPortInfo.
Why synchronised here? The previous code already synchronized and also checked if it is ready and the queue is empty.
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
According to which rules do we throw and InvalidSyntax or an IllegalArgument or an IllegalState exception. Sry, but this looks quite randomized to me
Possible copy/paste bug in the order by clause.
Was seconds an intentional omission here?
Hash code
assertThat(violations.isEmpty()).as("Violations are not empty!").isTrue();  =>  assertThat(violations).isEmpty();
no need to create a set here..
Maybe it's just me, but I would find a simple if-else clause more readable.
fail
null or empty list?
just return "" instead of new String()
we should check that the last character is also a quote. We should factor out the logic with MessageTypeParser.Tokenizer.getName()
What's the scenario in which in could be null at this point? if the file doesn't exist, getInputStream will throw a FileNotFoundException per FileResource.java. Maybe add a catch with FileNotFoundException? Then, you could get rid of the null check, yes?
to connect to secure nimbus
Oscars began in 1928 seems leftover because of copy/paste
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
OperationFailedException never thrown and it can be removed
Question: in the normal login scenario, reuseSession is called right after setSessionId. As both reuseSession (using getSessionId) & setSessionId are async now, I think we should utilize result callback when doing setSessionId, and only after setSessionId completes (result callback executes), we should proceed with reuseSession. This complicates the current code a bit, I can help with modifications/testing here.
May be you do not need another submonitor conversion here?
i would split this line into two for better readability. also gameUser.getAchievements() could be puted to variable
@Serranya The same here. See above.
can be refactored into commcare task
minor, is it method scope for Visible For Testing? If not please change it to private.
I think it might be easier to create a list and compare that?
I don't see why the newMonitor methods need to be synchronised.
We need to change the method names to be more descriptive.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
We shouldn't ignore an invalid enum value.
SyncNetworkParametersBuilder contains those logic in labelAdded() & labelChanged() perhaps it could be reused ?
Use StringBuilder please.
@Nadahar Isn't "**oga**" already there ?
SetAdministrativeStatus should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
doing += on a Long object causes boxing every time. It'd be better to have sum be a "long", and return Long.valueOf(sum) at the end. Or simply return a long in this method.
This could be null, we should probably handle this if the JIRA api changes again
do you need to select et_name here?
More accurate error message
defensive copy?
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
It should be possible to drop the DefaultDataSourceProvider Service interface and simply replace with with serviceLoader.onlyOne(DataSourceProvider.class, JndiDataSourceProvider.class). That will use JndiDataSourceProvider if no other DataSourceProvider is found
Actually this is largely unnecessary for RecyclerView adapters since it has lifecycle callbacks for when it is attached/detached. The reason this (ugly) code is part of RealmBaseAdapter is because standard ListView adapters do not have these callbacks so we are forced to use weak change listeners. Also the change listeners on our collections actually have better granularity currently. I would remove this code completely and just use realmResults.addChangeListener(listener) instead.
final
minor: don't need this. qualifiers
There should be an I18n used for this.
Add a message. Without it, you just get a NullPointerException with no message. ie. "'containerName' cannot be null." Same with another usages of this.
Seems like the previous tests should also assert on the length?
An create on-demand Direct Debit payment request should always have an agreement ID
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Why do we register onDestroy?
can just be hash.hashcode()
This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though running == false. I think the only safe place to do the check is after creating the spliterator.
Is this really sufficient to test your WCheckBoxWebElement? One check box is sufficient if it is exposed through a getter so the tests can set properties on it.
We should validate that's non-null (to fail sooner).
Should not this method create a copy of the set just as getStages()?
reset compensation?
@magicDGS Sorry, I didn't notice this before, but this would probably be cleaner as a try-with-resources instead of a try/finally, could you change it?
how about  java return method.isTestMethod() || method.getTestMethod().isAfterClassConfiguration();
Do we want to expose this to researchers? I don't think they have any need or reason to be looking at uploads
When do you ever use the above service? And if you do, is it more than once?
+ desc
Map
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
StorageException is a runtime exception, no need to catch and rethrow it (several occurrences).
> ClientConfiguration doesn't have an addHeaderDelegate() method. Are you saying that we should add one? I don't say that we should add one. But I see these advantages of this approach: * easier adding of HeaderDelegate to client * we don't provide access to all ResteasyProviderFactory methods, but just to the one method, that is really needed (addHeaderDelegate) I currently doesn't see any disadvantage of this approach. Do you see some? WDYT?
No need to use ConcurrentMap.
Can this method return void instead? I feel it's a bit funny to return the same thing we just provided as input.
Not really that big of a deal, but a group matching seems safer. If for what ever reason this property changes to something like 11.0.0_02 this would return 0. Below is essentially what is used for determining the version for domains.  private static int getMajorJavaVersion() { int major = 8; String version = WildFlySecurityManager.getPropertyPrivileged("java.specification.version", null); if (version != null) { Matcher matcher = Pattern.compile("^(?:1\\.)?(\\d+)$").matcher(version); if (matcher.find()) { major = Integer.valueOf(matcher.group(1)); } } return major; }
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
We still need to start with the "Network Interfaces:" header here.
Should this method be final?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Why is this not singleton?
Constructors can call other constructors in Java, so this should also work:  this(name, signature, ImmutableList.of())
you can just return false here, even better : return trace instanceof TmfExperiment && super.canExecute(trace);
what else? any warning or exception should be there?
Unknown file name and known line number? Should that be an error?
suggestion if (server == null || server.getUrl() == null)) { return this; } if (servers == null) { servers = createList(); } for (Server existingServer : getServers()) { // If a server with the same URL is found, merge them if (server.getUrl().equals(existingServer.getUrl())) { ModelUtils.merge(server, existingServer, true); return this; } } // If a server with the same URL doesn't exist, create it servers.add(server);  reduces complexity
We don't need to minus LOCAL_TZ offset for TimestampData, the millis is already an epoch milliseconds.
isn't the currentRow the instance of RowBuilder which was just added?
Wouldn't it be better to do this in the constructor and have a final variable with it?
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
should the message include "command _with options_:" + this.options ?
Could change to ProcessInstance.STATE_ACTIVE ?
Do a detection.  if (e instanceof RuntimeException) { throw (RuntimeException) e; } else { throw new RuntimeException(e) }
we should also check for n <= 0 here
should this be in a finally block to release in the case where an exception occurs?
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
<LINK_0>
Overdid: "foo" is String already :smile:
Here return getName + '=' + formatNumber(getValue(), base); // trailing space it would be nicer.
Use MethodType.DERIVATIVE.getCode() and MethodType.MAINTENANCE.getCode()
Please use the URLUtil methods here as well.
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Can we adhere to the coding style of this file and not have multiple return statements?
do we need to check for nulls here?
kind of curious what these magic numbers are
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
This null check should be done in line 274
Same here: include context in the log message (e.g. which instance we were connect to)?
Can be private, I think
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
I think the granularity should be 1 seconds instead of 5 seconds here.
should have public modifier, for consistency.
OpenToHalfOpenAutoTransitioner.scheduleAutoTransitionToHalfOpen() should be invoked in the Constructor of OpenState.
This check needs to be done in hasMore(), not nextRow(). hasMore() can block, nextRow technically cannot and just because there is another from hasMore() doesn't mean that it will be within the minTime.
Please close client at the end.
This is nice to see. We should have done this to begin with.
When you're using a local variable that shares a name with a class or instance variable, try to be explicit as to which you're referencing by using this.inputStream (or similar as appropriate). As an aside, the instance variable is never set, so this check will never succeed.
Seems redundant to have both static factories and public constructors in the public API. Especially when there's multiple overloads such as in some of the other processors. Can we choose one and expose only it?
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
If a filter is applied directly to the TimeGraphControl, the listeners won't be notified. In that case, perhaps the TimeGraphViewer should be the sole owner of the listener list, and the one to fire the events. Otherwise, the TimeGraphControl should fire the events when addFilter() or removeFilter() is called.
Same as above - log or throw the weird state.
To be safe, should check gerritTrigger.getJob() != null first.
Isn't nextInt(0, n) the same as nextInt(n)?
Why new? There does not seem to be anything "old" here.
Let's please have this throw an exception if a null predicate is given. Something like: java if (allowedHostnames == null) { throw new IllegalArgumentException("allowedHostnames cannot be null"); }
Add final keyword.
log and throw anti patttern
also check this
Assert.notNull(expiry,..) checking might make sense here
we should not throw an exception here, simply ignore
<LINK_0>
Fixed. Passing style as argument for setUpDepthFillLayers() and setUpDepthNumberSymbolLayer()
Whoops, this needs to be the other way round (the first block is for ExecutionException and the second is for InterruptedException)!
:bomb: this is not a solution. hashCode() can be equal for two different objects. Do it using the four fields.
Could you add an assertion on one of the associated props? Just to be sure...
I'm starting to question whether this is a good idea. Generally we shouldn't use it but I understand I left it in my previous PR. Will investigate.
This method is only called by popAndRedirectMessage() right? Would it be better to move the logic into the upper class?
@apc999 This needs to be public or reflection will not work
Any reason in particular that it shouldn't give the effect to players?
It looks like drain is expected to throw an exception. If I am right then you missed to call fail just after drain to make sure that drain thrown exception. Alternatively you could use: org.testng.Assert#assertThrows or  org.testng.Assert#expectThrows
submit?
Don't use printStackTrace() and instead write to the logger using log.error("<Appropriate message>",e);
can this just be collapsed into a single writeAndFlush() call?
please add new HelpTag and HashName (as in StorageListModel)
suggestion processInstanceIds.forEach(processInstanceId -> {  You dont need to use _.stream_ to access _forEach_
This should check to make sure that notificationUUID is not null before attempting to delete it.
Noooooo!!!! this needs to be configurable. At least the admin password needs to come from the pom, or any installation of Quadriga will always have an admin account admin/admin. SECURITY (to channel Abhijith...) ;)
can be replaced by List.of
Per IRL, I meant to say uploadApiBase. This is fine too, but unrelated.
the default one should be fine, isn't it?
Please add a check Objects.requireNonNull(supplier, "supplier is null");
don't catch, but instead allow the ExceptionMapper to handle it
You can look at using a joiner: <LINK_0>, which will join this iterable of string
don't forget default case
Please log this exception, maybe with a WARN level
Add requireNonNull
Question: If tablename is not null, in that case is m_index defined (from constructor definition it looks that it will be)? Not sure how this function is intended to be used but if this is for debugging/information thn might be useful to return m_index value along with it
Worth initializing to raw.length+32, to save in-line expansion when writing out the byte array?
You need to check in the set\* methods that the custom attribute name doesn't clash with a common attribute name to prevent users from producing invalid XML. Throw an IllegalArgumentException if so.
nit: style wants newline
Do you need the fully qualified class name here?
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Why we removed final?
I suggest you reset colorPreviewImages to null after that.
Likewise don't need the if statement since the optional value will return empty.
Since I'm suggesting creating the Response with the input stream this could simple return it now
Maybe remove the .method("POST") here as you are calling it on create() method
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
brokerRunning.getConnectionFactory() instead? I also think if that would be useful to expose CachingConnectionFactory from the BrokerRunning directly to avoid such a bean altogether.
static import sizeOf (also in other stream readers)
No need to use UriBuilder
No need to cast, a ServiceProvider has the method you need
I would not call the leaderContender under the lock because of the risk of introducing potential deadlocks.
Asserting the actual message isn't a good idea because this could be localised or message changed which would break the test.
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
you can actually use the returned boolean value to nullify astroDiscoveryJob and print the log.
This isn't needed. Actually I think that one constructor is enough, put everything here: super(ClusterFeature.class, ...); this.clusterId = clusterId; Also consider using Guid instead of String for the type of the "clusterId" field. The caller of this constructor will probably have converted it already.
agentDisconnect also sets this state.
ImmutableSet.copyOf(Iterables.filter(...)) ?
Can this happen ?
Same here, using a process containing a user task would allow to check the variable valued after the connector execution.
Mid return may worsen readability
else is rendudant
ditto, here and in other places.
assertThat(element).hasTotalSize(6)
having wallClock = 4 for atlasTs = 4 is potentially confusing (ditto below with 6/6).
Because there is only one argument, we can pass workerMetrics instead of an object array.
how can a clusterName be null?
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
shouldn't this be: donorRepository.findDonorByDonorNumber(donorNumber,true); since we're including deleted donors
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
Mappers can be stored in static final variables instead of rebuilding these each time.
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
since we have done the same logic in multiple places, shall we move this logic to some common place, like mappingUtils?
please add setSoftLimitInterval() setter and use it.
@fanifieiev Let's put this in a constant.
retrieve
Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.
Code for this method could probably be taken out into a separate method - with a Consumer parameter for the particular view method call - and reused in the next few methods.
Needs to consider the new custom fields.
it would be nice to assert here that the actionBar is displayed. (so if it is not visible, and onActionBar() is called, it already breaks here with the error that the bar isnt there instead of later that eg. the title doesnt match)
@agentgonzo I don't think there is a need to keep this synchronized anymore is there?
What is the reason for appending 1 to the variable name?
user.get() can return null
are these setters used anywhere?
Duplicate in both createSubject and createEvidenceSubject methods. Consider to refactoring into helper method.
Shouldn't this be a field so we don't have to create one each time
On START_DATE, the discount factor for start date should be 1.
What made you to wrap, when you still use a simple long afterwards?
can be String::valueOf
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
Get the service registration reference and unregister within the deactivate method
Let's re-word this to a forced shutdown
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
getUsage(...) expects a localization key.
Our standard convention is to prefix with this for instance members - return this.context
How do you know that tableName is not, itself, an SQL injection attack?
You get it right. Per code conventions, I like to see brackets around if and else clauses.
Can be rewritten with Arrays.asList().
Should probably be declared final.
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Similar
Please remove this line
In the original code, we throw a runtime exception if the native snappy is not found. Should we follow?  throw new RuntimeException("native snappy library not available: " + "SnappyCompressor has not been loaded.");
Use braces for all if statements. Alternatively you can use one-liners, but braces are typically preferred.
I think this should be > 0 since a value list item of 1=One does not work.
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
Needs to be in finally - we might get interrupted.
Redundant with the e.getMessage? May be something like "Wrong class path: e.getMessage"?
I don't understand why do we need to call hasNext() here? we can just use this.iterator.next() and let it throw if there is nothing left
Adding this to a field is good manner.
This is another behavioral change that I don't want to see in an unrelated PR.
There is a slight chance that this View will be destroyed when this callback is reached. Therefore this should be protected by a check for isAttachedToWindow().
Maybe diving to deep into the state machine pattern but to me it would feel more consistent to have all these methods use a switch. In my head that makes it easy to skim through and see what states the method cares about and what it does in the default case.
To make the tests more resilient to future changes, please pick values that are unlikely to ever be the actual defaults. For example 234MB and 11MB.
Removing the interceptors removes logging.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Use this.key
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
return data.stream().mapToInt(CurveParameterSize::getParameterCount).sum();
No big deal, but if you modify anyway, you can add a break here.
I'd recommend using <LINK_0>
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
If this fails, it would be good to include "security.refresh-period" somewhere in the exc msg
Simply return the id. It's either a ticket id, or a JWT. Right?
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
Optional makes the JS API less intuitive and cumbersome. Hence let's remove Optional.
fos can be inside try ()
We don't need super here
For loop?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Just return the if case statement
Do you have time for this? We talked about it on Slack.
how often is this method called? Why not cache this computation like you did the others?
this can also be .map
Should this refer to a platform-relative constant?
Change to use this.jsonAsString.hashCode().
Could you update this method to include "AbfsPerfInfo" introduced by HADOOP-16612?
This looks like testDataFormat(COMPONENT); Please see other tests for sample
You should use assertNull.
"No provider is registered for the service '" + service.getName() + "'", service" (this is the current errore message). Shouldn't this thrown a ProvisioningException ?
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
Likewise.
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
You may simplify:  actionsFactory.createAction(seleniumWebDriver) .keyDown(CONTROL).sendKeys("/").keyUp(CONTROL).perform();
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
Is it possible to get rid of this?
We can do disruptor().setDefaultHandler().handleExceptionsWith(), so, maybe, not "mixing", but something like "callToDefaultExceptionHandler is not supported and useless after exceptionHandler has overridden by EventHandler specific ExceptionHandler using handleExceptionWith()"
use "1.0".equals(version) to avoid possible NPE
should we also lower down maxConnectionsPerDestination ?
merge else if?
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
no!
Removed -> NotRemoved?
since its always called with true, would it make sense to have a kill() method instead?
Adding this to a field is good manner.
And BTW all Eclipse resource implementations are immutable so you cannot alter the hashcode in any way.
Instead of loading the classes here, why. not just iterate over compiledObjects.values()
FileNotFoundException is a subclass of IOException
Do you mind extracting 5 into a constant with a name like BANK_ID to improve readability?
This shouldn't be needed as StatementClient.close() should be idempotent
"plugins" could be replaced with ConfigConstants.DEFAULT_FLINK_PLUGINS_DIRS.
there is no need to convert to map. can we directly print headers ?
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
I guess this could be public as well? Might be handy in certain places, so one don't need to get the binder separatly.
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
Could we prefer a proper logger instead of System.x - we already have a logback.xml in the module.
Take a look at how shouldChangesRequireResponseDeletion is called. Do you need cast operation here?
You can remove the inheritance from translator and make this method static. So you won't need to create any instances of EnumTranslator.
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
Request.State.OPEN
should be named resource
This needs to be changed to support locked stream syntax now.
Should we not assertOpen _before_ we readValue?
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
can we check for value equality and not reference? equals. thx!
It's safer to call getProperty("replicatorFactor", DEFAULT_REP_FACTOR). You should validate the arguments as well.
This code can be called from RefreshVdcOptionCache() method too, instead of it being written there also.
It is possible to write this and preserve types (e.g. avoid SuppressWarnings). I'm pretty sure it can also be written using generics (vs Object) but didn't have a chance to finish that.  public static Object[][] cartesianProduct(Object[][]... dataProviders) { List<List<List<Object>>> lists = Arrays.stream(dataProviders) .map(Main::nestedArraysToNestedLists) .collect(Collectors.toList()); final List<List<List<Object>>> product = Lists.cartesianProduct(lists); final List<List<Object>> mergeProduct = product.stream() .map(list -> { List<Object> result = new ArrayList<>(); list.forEach(result::addAll); return result; }).collect(Collectors.toList()); return nestedListsToNestedArrays(mergeProduct); } /** * @param dataProvider a nested Object array * @return an equivalent nested List */ public static<T> List<List<T>> nestedArraysToNestedLists(T[][] dataProvider) { return Arrays.stream(dataProvider) .map(Arrays::asList) .collect(Collectors.toList()); } /** * @param lists a nested List * @return an equivalent nested array */ public static Object[][] nestedListsToNestedArrays(List<List<Object>> lists) { return lists.stream().map(List::toArray).toArray(Object[][]::new); }
why change the readability status here?
How about:  int size = Math.min(b.height, b.width); setMinimumSize(new Dimension(s, s)); setPreferredSize(new Dimension(s, s)); setMaximumSize(new Dimension(s, s));
Please add the 'can not recover' back? It clearly tells why we must abort the region server.
given/ execute/ assert
Not worth debugging for this QS
Might make sense to use a RowMutation here and have the PutAdapter take a MutationApi interface
This does not have to be deprecated because a new method was added. Also, do you want the method to be removed in the future? Starting with Java 9, two parameters were added to the deprecated annotation since and forRemoval. The default for forRemoval is false. If deprecating, it may also be good explicitly set these. Not sure if my syntax is correct below, I have not used these yet. suggestion @Deprecated(since="2.1.0",forRemoval=false)  Personally, I don't think the method needs to be deprecated.
Thanks for this clean-up throughout the code! I should probably start enforcing fcrepo4 code style rules sooner rather than later...
I think configurable makes sense
If it is meant to only check syntax, do we need to return model? I'd rather have it return true/false.
any particular reason why this method doesn't require an IJavaProject ?
I'd make these constants, just to make it clearer.
given that specificity of this SV is exception type I would add the exceptionType in this.
This function **always** returns null. It appears to be an error.
Can you change to static variable ?
if you want to make this threadsafe synchronize this copy on fValues. synchronized(fValues){return new ArrayList<>(fValues.keySet());}
I'd still prefer to have the operation for generating the 'key' for a muted topic to be a separate function, or even embed it into the Message object. for example:  mutedTopics.add(message.concatStreamAndTopic()); ... // in Message.java private String concatStreamAndTopic() { return getStream().getId() + getSubject(); }
This is now hard to read since it combines two multiline expressions. Please break it up into separate expressions and use suitable variables for each value.
instanceof Dataset is redundant
Why is this necessary?
nit: public abstract void
There is no need to set the local scope reference to null, but if you prefer...
This should return 1 if the time difference between start and end is > 0 (in any unit), to ensure we never round something to nothing.
if you don't specify the **this.user = null**, it will be null when the class is instantianciated, so this line is redundant
Is there a reason to set the variable in the constructor as well?
nit: Same here. Leave the checks in the switch and do the assignment at the end: this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
should this assert happen after the call to start()?
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
I would prefer if you use String.format here. Also, have hyou thought of log.debug the stacktrace?
Use Enums.getIfPresent like in the previous enum or change that one, but make the code consistent using the same pattern when addressing the same thing.
Shouldn't be here a warning log and in else branch the actual code - setNotificationService(notificationService.get()); ?
not checking the value? maybe create an OptionalMatcher that checks the Class and the value
Assert.notNull since shouldFilter will throw otherwise
you can use standard java NotSupportedException
I think injectionTarget.getClass() does not make sense here. It will be better to simply pass the IT instance. And the same probably applies to extension. Also I think it would be better to log both the original and the new value for all ProcessX events, e.g. something like: ProcessInjectionTarget.setInjectionTarget() called by {0}: {1} replaced by {2}. What do you think?
You may also want a test case for a search value that is non-blank but invalid.
Can be reduced to throws IOException.
Should we add null check?
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Are our current http log files in UTC or CEST?
In my testing on Linux I see another SWT.Selection between MouseDown and MouseDoubleClick?
isn't it simpler to just do: return _minDelayMs + (long)((_maxDelayMs - _minDelayMs) * RANDOM.nextDouble())?
I can see that the method body was already synchronised. Can you instead remove the outer if (serviceContext == null)? Because i see it duplicated in the inner block.
pls use formatter
move this line before above line, After super.cleanup method couldn't do any of the server requests.
You should use ThreadContext.putAll() here.
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
Maybe let the stop() method throw the exception instead of catching and printing?
Do you need a fail() here?
Is it OK to swallow this entirely?
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
This method should be invoked before sending the message for processing in the doReceive() method and not here.
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
need to remove this print or convert it to log stmt
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
Can you please compare something else than integers (String will be ok)? Silly code change in assert method can break its logic but pass this test because both index and value are 2 :)
This needs an @Override annotation.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Nitpick: startingCounter?
There is no need to check the VIEW right, EDIT is enough.
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
Use same order as the field declarations.
rename to contribution
Why do we have this constructor?
Need to implement
Use same order as the field declarations.
This asserThat will do nothing - you need to add something like isTrue()
Can reuse site here.
Also, there's no zero comparison covered?
rename to contribution
Is username case sensitive?
what happens if remove() fails (throws an exception)?
Add this qualifier: this.data
Do not use e.printStackTrace(). Log the exception. > this.logger.severe( e.getMessage()); > this.logger.finest( Utils.writeException( e ));
Now this method does not do as it's named...
Wouldn't it be better to not mock this ? This way we will test filtering. In ACUnitTestBase you have method to create Patient, so you can build a list and see if the filtering returns proper list.
We could cover it with some tests.
only EE product can have runtime lineage
Check the env variable before returning true.
You don't need this, but if you do keep it in it needs to set standardOutOrig before you call System.setOut - otherwise you are just getting a reference to the value you just set.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Let's use this method on overloading.
You can use GenericMath.DBL_EPSILON here.
I'm surprised the server doesn't already do this.
This is the same as downloadBatchMap.containsKey(completedDownloadBatch.downloadBatchId())
test will success in old versions
Encapsulation
Instead of repeating the addition assign it to a value on the stack.
Move the logic to configAccessor.
A good opportunity to not hardcode the port here, but rather use findFreePort()
There is no call to this method outside TableManager, shouldn't we change it to private?
you can remove this
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
all these methods can be private
Please explain this change and why users need this method public? @romani What is your thoughts? Why isn't writer final? I don't see a reason why users would swap output streams in the middle of execution.
We're on Java 8, so: IntStream.range(start, start+length).toArray()
Hm, my understanding has been that the base implementation should look like: Java if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE); }
Stack overflow? :)
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
Same here, no need a transaction
Detail: FROM capitalized.
Could you please use DecisionTableInputType.XLSX
ZERO_ADDRESS
This check is unnecessary. context can never be null for a properly constructed object.
why not use the passed in editorInput
return tags;
Why this debug log is removed? Not sure, if it's there for any security issues.
It doesn't feel right. Why it is required?
All of these createTable and deleteTable methods should throw UnsupportedOperation permanently; table creation/deletion is outside the scope of async-kiji.
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
Don't do double assignment, and no need for "return at end of method", and the case indexNames.length == 0 is already dealt with by String.join, so just do: return indexNames == null ? "" : String.join(",", indexNames);
either use AssertJ or have the assert text provided details on the cause of failure (i.e. the provider name). Goal: a failure on a jenkins run must provide enough information to enable someone to work out what failed
name could be more descriptive
Returning a class instance _or_ a null? This calls for an [Optional](<LINK_0>!
this check is not needed.
getContentLength() [is nullable](<LINK_0>, so we would either need a checkNotNull or some null handling here.
There is a genuine risk that multiple sources will try to set the lookup at the same time ? Just wondering since now this will synchronize ALL access to storing attributes to the vaadin servlet context, not just the lookup. Just wondering if synchronization access go through another API, but then again also the getAttribute is already synchronized. So probably this is fine and I'm just thinking out loud.
include retry template and do  return retryTemplate.execute(x -> remoteTokenServices.readAccessToken(accessToken));
If it's a malformed URL, then it's an illegal argument to the method, rather than an illegal state.
Better to return Query<?> than to let shenanigans like this get past the compiler:  Type type = int.class; String result = handle.createQuery("...").mapTo(type).findOnly();
Added because?
Since you're already using Guava, consider using [throw Throwables.propagate(ex)](<LINK_0> here instead.
seems like synchonized is not needed here, given increment/decrement already protect
I think this would be clearer though more verbose:  final Schema inputSchema = getChild().getSchema(); final Schema groupingSchema = inputSchema.getSubSchema(gfields); Schema aggSchema = Schema.EMPTY_SCHEMA; for (final AggregatorFactory factory : factories) { aggSchema = Schema.merge(aggSchema, factory.generateSchema(inputSchema)); } return Schema.merge(groupingSchema, aggSchema);
Check if value is null.
Since these are run as tasks, do we also want to add the check to confirm the context is still active?
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree)  return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
status == Status.STATUS_COMMITTED
How does this work for (ridiculous) timezones with 30 or 45 minute offsets form UTC?
Why not just mark the whole method as synchronized?
please leave it that way - it's intentionally referencing the deprecated version.
final
Pretty minor but would you mind adding some parentheses around the arithmetic? :) Is it possible to have a divide by zero error?
Is it required for the upgrade?
minor: don't need this. qualifiers
The two methods above are the same except for the first line...perhaps reuse the code instead?
I would insist in having all methods that use a CT* parameter to be annotated as @Internal when they are not private.
Seems like the previous tests should also assert on the length?
You can change the 28 case to a default case, and remove this.
please avoid one-letter vars. In java its very hard to follow code if it has obfuscated variables
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
We don't need to use System.out.println() here. These two lines should be assertTrue("Expecting: " + expected + ", got: " + e, e.getMessage().contains(expected));.
please create a more specific exception that extends this one.
nit: put {} around if statement.
should this count be parameterized?
return queryId
style nit: we don't use braces around single line blocks
Apply changes similar to setVisibility.
A message might be helpful
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
although this makes the API some how compatible again, it is semantically wrong. GlobalConfigFiles.get().getConfigs(); just returns the global configuration files and none in any folders. So I don't think this is a good idea. The same applies to all the other methods...
maybe dataStore variable name instead of people?
Did you intentionally ignore the patientProgram parameter?
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
I know I did not mention it in the initial review but TransactionImple.getTransaction() can do a lot of work so I think you need to cache the result in a local variable in order to avoid the second call to getTransaction.
Okay, but now the label provider is null. What then? We will get NPEs in the places where the getLabelProvider() is called.
can use org.apache.commons.lang3.StringUtils.isNotEmpty(value.textValue()) ??
assuming this was for debugging, should remove.
This updates all gauges when any of these gauge is visited. It'll be better to override getValue() instead, and only calculate the percentile for the gauge currently being visited.
Is it better to initialize latch to CountDownLatch(0) instead of null? Also initialize it in line 45, when latch is declared?
Padding should probably be extracted in a separate method. (I could also argue that getting the int value could be another method, but I sense that there might be some opposition there).
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Please format this as:  command.stream() .map((String s) -> "\"" + s + "\"") .collect(Collectors.toList());
missing field qualifier
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
can you set this to warning level instead of error (Timber.w) - just trying to avoid too much non-fatal stuff in the error logs
[minor] What is the notNull() for? Does operatingSystemsAvailable possible contain null elements? And just to check I'm understanding the logic correctly here: the image ID can be a substring of the the ID of an OperatingSystem, and that is what we are looking?
Something like this.
The only problem with this approach is that Nested views may appear as a search result even if there is TopLevel view with such name. And as a user I would expect them to have higher priority. Maybe it worth checking all TopLevel views first. I would also vote for making a parameterizable method View getView(String name, boolean recursive) and maybe changing only the API calls which are really related to search. Otherwise it it hard to predict the impact of the defaukt behavior change
suggestion throw new IOException(MESSAGE, (Exception) DummyClassLoader.apply(TestCallable.class));
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
See also DefaultDockerClientConfig::dockerConfigPath field
simplify to () -> isLoaded()? Can it just be this::isLoaded? I'm not sure what the interchangeability of bound method references and lambdas is like.
ConfigurationException?
Since we know we're in ConnectStoragePoolVDSCommand, is the getCommandName() really necessary? also, remove the "to" - "Failed in VdsCommand %1, error = %2$s"
same here - call the constructor with 4 args
Same here.. we should not have these checks here.
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
Should return ReadOnlyArray.
ImageData for current image needs to be updated in the array?
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
I think only one impassable entity should be allowed on a Square. Exception otherwise.
why do you do the substring if you are using contains?
static import joining
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
nit: Change 2147483647 to 0x7fffffff  for easier understanding.
Fixed in next patch set: - Made private. - Added dummy serialVersionUID to prevent Eclipse warning.
Here you could extract a private method for all of them which takes the type as parameter.
is logics correct here?
The error message doesn't match the actual behaviour.
can move ListVersionView object construction in ViewFactory? this will replace publicBodiesConfiguration dependency by ViewFactory to make it consistent with other resources.
Since this a string, safer to use StringUtils.isBlank
Missing space after if
That is not clear, why do we have "Save" is not adding alarm item is enough? Actually, it is saved in Realm but not scheduled in Alarm manager?
Please keep this.cell near the related fields (previousFamily & cell count) below
This message should be included in our Log class (with a parameter for the service name and a @Cause, you have tons of examples in the code). The message should also probably be something like "An error occurred while loading an instance of service <service class>.".
Move this else if just after the } above
This should be in getCache(): private synchronized Map<String, User> getCache() { if (cache == null) { cache = new HashMap<String, User>(); for (User user: getAll()) { cache.put(user.getUserId(), user); if (eventService != null) { eventService.fireEvent(new EventUserUpdate(user)); } } } return cache; }
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
Why do you not return directly the value of condition ?
Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?
this.
In assertEquals, the expected value comes first. suggestion assertEquals(1, mtlsKeyStore.size());
The super constructor throws an IAE, so why not mark this one, that the IAE could be thrown? Wouldn't it be helpful for the caller of the constructor to know that this runtime exception could be thrown?
merge else if?
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
Let's make sure that no project uses this resolver. If there is a project using this resolver, let's throw an exception and tell the user, he can't remove the resolver because it's used.
Should be a constant.
It seems you have to choose between @sputnikci and @codecov-io complaining :p Could we open a @codecov-io issue instead of making the code uglier?
I want to method accessor to be package private :eyes:
Add log.info "connecting to ATSD at host:port"
Avoid ByteSource in API. byte[] is ok here
70-75: extract method (see following methods)
Collections.EMPTY_LIST;
Either hasNumberOfValues ? numberOfValues : 0 or add verify(hasNumberOfValues)
Current code doesn't detect port 8080 is used by my local EAP. The only way it works for me is if it's implemented as  java try (Socket socket = new Socket("localhost", port)){ return true; } catch (IOException e) { return false; }
Please add curly braces around the next statement.
Unfortunately, you cannot delete this method. This is how we initialize our Indices when they are created via reflection in the AccumuloRyaDAO.
rename
Why empty? It supports ALL streams!
we never use NULL, it is a bad practice in general.
Worth including an entitlements check, because the return values could contain passwords retrieved from brooklyn.properties. For example, something like:  if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) { throw WebResourceUtils.unauthorized("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user()); }
@ivandalbosco No need to change order if we don't rely on visitor for finding "try"
Please add ioe to the exception.
Please remove.
This doesn't honor the contract of an iterator's remove. In fact, i'm not sure you can support this atomically with only a single file.
Static string constants
"profile" should probably not be part of the quotes?
Should have a space after add
context.PROCESSING_MODE => OperatorContext.PROCESSING_MODE (to get rid of "The static field Context.OperatorContext.PROCESSING_MODE should be accessed in a static way")
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
And BTW all Eclipse resource implementations are immutable so you cannot alter the hashcode in any way.
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
collect to a set that can preserve order?
Statement can be rewritten inline.
CheckReturnValue?
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Optional.map
validators aren't supposed to return booleans, but ValidationResults.
If the argument selection is a NodeSelection then the method brakes it's contract and doesn't create a new instance. I'd remove the if statement.
Restore to original. Also apply to the other similar throws.
I couldn't understand the need to get templates config and set it back again, is this required?
Add not-null check here.
here for example could be remotePath.resolve(source.getName()) if pathPrefix was a java.nio.path.Path
why ConfigurableApplicationContext, not ApplicationContext?
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
Should be hardcoded as EnumSet.class, not getErasedType(containerType)
Stack overflow? :)
Add reasonable toString() method, returning null doesn't seem as proper way.
please also add the GUID which is important.
Why are we recycling buffers at the end, on close and not on the fly? It can mean GBs of extra (unnecessary) memory usage if we keep all unconsumed buffers from different channels. The ownership of the buffers returned from the iterator should belong to the caller of next() method.
Wow, these are some pretty intricate tests. I've had a look and it _seems_ right, will have a closer look again before we merge
Just thrown an Exception.
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_1>
I'd prefer wrapping it with String.valueOf() or call toString() if it's same, but this is simpler so OK to me.
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
I think entry.getFields().stream().anyMatch(fields::contains) is slightly better performance wise (as disjoint needs to check if *all* elements of fields are not contained in entry.getFields())
Can you avoid duplicate code here? (PreferenceManager.getDefaultSharedPreferences)
Nitpick: the instanceof check is redundant here.
EchoParametersDao.getEchoParameters() already returns a list.
As mentioned in <LINK_0>, I would claim that setting the status ONLINE is many cases a bug. In the example of the hue binding, the handler determines the correct status in onLightStateChanged. So either we do not set a state here at all and wait for the next update (triggered through the regular polling) or we set it to UNKNOWN for the time being. Same should be checked for the other bindings.
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
directly return "" is better
If this patch gets pushed: <LINK_0> Then you could use NetworkHelper.managementNetwork method and save a couple or repeating lines :)
No need to copy here (the class will store an immutable list)
Maybe checking with STRING isn't quite enough here. I could imagine a lot of Hive users using the more specific VARCHAR column type.
we never use NULL, it is a bad practice in general.
Maybe use this.value instead of getValue() here (and also on similar occurancaes)? Similar to AbstractSingleCatalogData.
Thanks for adding the eq() here, good catch
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
I don't think this will do what we want though, because new DatabaseConnection("database1") will try to load the db's properties from the yaml. We need that connection to be lazily instantiated.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
secretLabels = Arrays.stream(labels) .map(l -> l.split("=", 2)) .collect(Collectors.toMap(p -> p[0], p -> p.length == 1 ? "" : p[1]));  ?
suggestion private MockClientState getMockClientWithPreviousCaughtUpTasks(final Set<TaskId> statefulActiveTasks) {
should be VOT.Storage
Be careful of nullable fields!
Would be clearer to use a variable for the initializer instead of calling this method 4 times.
This variable name is misleading. These bounds are _not_ verified at the time this call is made - they are the candidates you want to verify. In the previous model it was correct (because that's where you start the query from).
Couple more static imports here?
You can make this file File
Assert.notNull() ?
How about narrowing it to ClassNotFoundException and fail with other exceptions?
Can StringUtils.fromUtf8 be used?
Revert this
Generic type not used, remove.
Why are you looping here? Can you give a use-case?
please remove TODO and printStackTrace() and use proper logging instead
Can this be private, or is there another use case for default attribute outside the builder's call?
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
setSelection takes an ISelection, no need to cast what you get from the viewer. you also do not need a local variable
I am still in favor of removing this static. I don't think its necessary. I think if tserver wants to keep one instance, then it should keep a reference to it. All the current static stuff we have is troublesome and we would like to move away from it. Could rename this method to newInstance if you drop the static.
No need to call file.toString() -> FileWriter can take File in the constructor as well.
Recently someone told me that booleans are hard to maintain because you don't immediately see what the true /false really means. You could use Order.ASCENDING and Order.DESCENDING here instead.
Should we return here?
Is this supposed to be <code>return "Bump"</code>?
@akolodziejski please use hamcrest matchers. They are much nicer. You would write something like assertThat(patientIdentifiers, containsInAnyOrder(hasIdentifier("101"), hasIdentifier("101-6"))); where hasIdentifier returns your own matcher. Let me know if you have any questions.
null? why not just a () -> {} ?
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
Single or double pipe?
nit: we can add a validation that if streamTask != null then stateMgr.taskType() == ACTIVE.
what does compare and hascode mean for datanode if they have different ssl ports?
When mixing hashcodes don't just add values together. Use Objects.hashCode(commit, otherCommit, submitType, contentMerge)
Currently we don't have PERUNOBSERVER role assignable by config to specific credentials (unlike perun admin). This mean, we will always have User, related to this role. So anywhere, check on SELF (without specifying user or where passed user is only own) will let PERUNOBSERVER pass too. Only if it would filter result, we would have to separate them. What do you think @stavamichal @licehammer @martin-kuba ? Will we need PERUNOBSERVER role for accounts without User in Perun or not ? I suppose not, it is always safer to have account with contact info etc.
persistent result set is available for JDBC driver as well. Why are we casting the resultset to InMemoryQueryResult?
Are the changes to HelixPropertyStoreFactory going into this PR?
inline?
Use strings.xml
static imports
does this have to be a list or can it be an iterable?
getCurrentVariables() => currentVariables
just return directly, no need for packageName variable
for create session would geoRepSessionId exist in parameters? and there would be no session in db, right?
What do you think about changing to stripContextPath(request)? So stripContextPath ask for contextPath and requestURI internally.
extension can't be empty or /
Unnecessary cast.
Remove this line.
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
This won't invoke the additional interceptors, is that okay?
Use Objects.equals() to handle nulls concisely.
@since 9.3 originSystemProps.put(key, System.setProperty(key, newValue));
Could it be constant? Looks a bit cryptic
Hey @oguzkocer , should this array include VIEWERS_TABLE as well?
why not list.stream().forEach?
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
I see that BCECPrivateKey.getS() and BCECPrivateKey.getD() return the same value. Here both of them are used, is it intentionally? I'm also wondering if this is the same matter which just has different names in different interfaces or there is a subtlety?
Can we show that this method is not supposed to be used directly by consumers of this class by making the method protected?
maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.
nit: this might look nicer if we collapse the config-building to one line each
I'm iffy on having this here. This is partially because we let the status update handler write to pending tasks, and partially because it means we are reusing a pending task id. Generally we let the SingularityScheduler do all of the work of creating a pending task to keep responsibility for those types of operations separate. We actually removed bits from the status update handler a little while back so that it would avoid mutating the pending task queue. Instead I'd suggest using requestManager to add to the pending request queue. This will let the scheduler do it's normal thing and rebuild a full new pending task with new unique ID from that pending request
if we continue with this convention, please init to true also here
This is a good approach IMO.
- static import - why is having no delegates an error?
wha would it take to implement this for JPA? bit uncomfortable to have new methods only for particular type ...
Rather than calling run here, make run() call out to a no-args method like this: java public void onClick(View view) { // ... if (id == R.id.button_done) { nextWithEmailAndPassword(); } // ... } // ... @Override public void run() { nextWithEmailAndPassword(); } private voidNextWithEmailAndPassword() { next(mEmail, mPasswordField.getText().toString()); }
Before go through the loop make sure that position and symbol parameters are not null.
What does the magic number 2 mean?
Do this check before the for(), because if this.notificationConfiguration.isEnabled() or this.notificationConfiguration.areEmailsEnabled() are false, you don't event need to load the descriptors and so on...
Idem this could be handled with an Optional...
just inline this. ex. if configuration.getPercentage() is mutable config, make a final copy. This code is simple enough that it can be inlined, and there's no reason to require an allocation or another type to do this math.
Call I18N.getString(String) (there are no parameters in the resource messages).
You may want to use ConcurrentHashMap for thread safety when adding classloaders into this map.
It'd be nice to clean this up a bit and have a single constructor.
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
Instead of FileHandler, you should use the PropertyConfigurationLayout to save it to a FileWriter.
A better builder instantiation pattern would be having the Builder constructor private and have a static builder() method in the outer class. The usage pattern is like:  java RestStreamClient.builder(host, port).create();
hasAnnotatedAllParameters is already checked in the super class, right?
What happens to relative links? Protocol-relative URLs? Tests don't cover those.
I think that CSSDOMSemanticElemntHelper should be an Singleton.
should check if viewer is disposed at some point
I can't believe I let this line of code get in. Terrible.
I'd need to check, but this might fail in when poolId is null or empty. If so we need to wrap this (and other lookups in similar methods) in a null or empty check.
as above for cache
return id;
super.init() method never throw an exception.
Does it make sense to cache the result?
Same as above: I think it is clear enough without the id variable same for below too
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
Check command and status null.
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
nit: not typesafe, as above.
null != settings
You could use BigInteger.ONE instead.
this.
I think we should set isBound = false here. onServiceDisconnected is not called when the client is unbound normally. According to the docs, onServiceDisconnected is only called when the process hosting the service is killed/crashed.
Should be here ac.stateChangingCheck(); @zlamalp?
We should not swallow exceptions without at least logging the exception.
this doesnt do anything
we should add the logical types' schemas here
You could just use Closeables2.closeQuietly(azureBlob);
The original version is more precise?
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
Should it be logged at the error level?
I think the <zookeeper> argument comes after the other arguments. Also, it'd be good to add one more example with your -d flag.
should atleast check o being non-null and instanceof IdentityExtractionFn .
Can we please add limit to the exception message? So it will be much easier to see the problem!
If it is a mock user, better to call it "mockUser" or so so that there is no assumptions it is something real
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
You could add a package-info.java file to the package
@inverno Why public?
can we use sysprop or something for url?
use 'L'
If our setters in commands are going to fail-fast about single-execution, we should fail-fast here too about a null pointer being passed in for Repository. NPE right away in the constructor rather than deferred: Git git = new Git(null); git.commit().setMessage("Test").call() We should NPE on the first line of that, not the second.
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
Why we return AsyncClient here?
Not sure about coding style, but I wouldn't use an else here ("else after return").
lets return empty string "" to avoid hypothetical NPE in future code.
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
Perhaps consider a constant for "NOTIFY" as it is repeated various times.
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void ...) This avoids extra sync objects (and saves one level of indentation!)
@weisebrazil all indentations should be 4 spaces, not 8.
is this something like /system/tasks ?
why not use @Inject ?
Doesn't look like we need such an assertion at all.  if (index != null && container.has(index)) { return typedValue(container.get(index)); }  So, we are good to deal with whatever JsonNode we get. Looks like the previous Jackson version was different, but now it is a bit easier to avoid extra checks.
Style-nit: Spaces around operators (=, !=, etc.)
Too few IMO, but :man_shrugging:
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
Same here too, seek, read and continue with read, verify in the second read, we are reading continuing data or not?
what about location ? we do not need LocationSerializer ?
Used to be fileSystem.deleteFileOrThrow underneath.
isn't it true by default?
I know I did not mention it in the initial review but TransactionImple.getTransaction() can do a lot of work so I think you need to cache the result in a local variable in order to avoid the second call to getTransaction.
I believe this method should be getServerMetricConf()
This is a local variable, should be camelCase not fCamelCase
Sort of believe We should have MetricManager in parameter given this case.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
I don't think this is needed.
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikiPage object/browser info.
since you are changing this, I would use:  return addressNum == that.addressNum && Objects.equals(name, that.name);
Check if byte[] b is null.
This will return an immutable map. Use new HashMap<> instead.
Same as above, this looks like an error.
I agree with your point. Good catch. I want Ravi to review as well.
events can't be null
we don't need to change the Creation classes.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
should be edit
don't return null, we can either return an Optional or fail with a ClassNotFound with a clear message that neither of the two classes was available for cleanup.
The difference of ProcName and StringClassDetails is? The targetServer should add to toStringClassDetails?
This won't work with generic builders I think.
Possibly the better option (not requiring waitForSQSContainerToStart) would be to use different waiting strategy (reference: <LINK_1> java .withExposedPorts(80) .waitingFor(Wait.forHttp("/"));  withe the port exposed by sqs and end the endpoint pointing to the queue we're interested in (<LINK_0>
If the Repo fails and is later run again, would this cause it to fail?
How about applying this method inside convertColor to avoid duplication and to make sure the same input sanitation is applied? Looks like in all cases color.trim() is desired before calling convertColor anyway.
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Why U don't want to consider id in equals and hashCode ?
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
DoubleMath.isMathematicalInteger?
Should be public.
For consistency, I would also make it so passing -1 results in a nullValue
What if we requested 100 events, only 30 showed up in the timeout period, and the next work item wants 10? This logic will add another 10 credits (making it 80 credits) even though we don't need to add more credits to the link.
why is the first parameter a LayerCommand if we only need the resulting Layer?
This might also seem like a good case for an executor listener, that could be used to listen to the submitted job ids, but that's maybe a future change.
true=>false
Can we either use assertEquals or assertThat. assertTrue or assertFalse are not ideal when they fail, as the usual error messages not telling you what exactly is wrong, whereas the others at least tell you something like actual true, expected false.
Can we please have this variable initialized to an empty array so that we can avoid a null check to be done ?
@paulodamaso the braces and return are not needed here
We only set thisReadSequence and mateReadSequence in the ReadHead, right? Why don't we have set(long uuid) for those kmers which aren't ReadHead?
should this throw an exception? [the same for all the other similar cases]
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
Null comparisons can be replaced by UtilMethods.isSet(object)
Shouldn't the key() and value() method also be renamed? Same in async client too.  return setSetting(new ConfigurationSetting().setKey(key).setValue(value), Context.NONE).getValue();
Same as above. this is deprecated and should no longer be used.
reuse getAcceptableTokens()
Replacing "\" does not require regular expression, use replace("\\", "\\\\\\\\") or replace("\\", "\\x5C") instead of replaceAll().
Typo: "visibiltiy" -> "visibility".
For increasing stability "wait" is better to use than "Assert":  waitUrlStartsWith(testRepo.getHtmlUrl()); } private void waitUrlStartsWith(String expectedUrlPart){ seleniumWebDriverHelper.waitSuccessCondition(driver -> seleniumWebDriver.getCurrentUrl().startsWith(expectedUrlPart)); }
could this hide bugs? Would it make sense to throw an exception or simply remove the check? Also because 0x0 is a valid code point this makes this return value a bit ambiguous. I'd be in favor of just accessing the array and let the JVM throw an error if this is possible.
Hum seems we are already setting this listener
trivial: you can remove the isDebugEnabled wrapper
@qeesung: nit you can merge the above 2 lines
remove 'driver' parameter (yes, a know you didn't write this line, but please change it :) )
It's better to restore settings back. java prev = erlangSettings.SPACE_AROUND_ARROW; try { erlangSettings.SPACE_AROUND_ARROW = true; doTest(); } finally { erlangSettings.SPACE_AROUND_ARROW = prev; }
use execute i mentioned above
Looks like both XmlTest and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
We don't need to make this change, do we? Let's try to minimize the changes to the existing code.
Oh yuck. ;)
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
Item dropped should be a hopper
I would check getQosOverridden().getIsChangeable() instead of (!getIsToSync().getIsChangable() || getIsToSync().getEntity()) but as you wish...
Why do we use iterators? I know the base class does, but why in the first place?
Why the change? This is going to cause a memory leak if the SaveSmartLock fragment is rotated since it's a setRetainInstance(true).
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Is this an exceptional condition?
This also seems kinda pointless and a bit brittle. Just return resource.
If createParams should always have commonParams and commonServerParams, why not just define it that way to start with? And I think you could make the collection a static final variable at the class level.
@cvrebert maybe MkIssueEvents.class.cast(?
Remove useless assert
Exception isn't thrown by consumer.close(), it should be removed.
why needs this method to be static?
Could you replace the magic number 128 by a constant?
Is it an exceptional case for ConfigLoaderFactory to not be present here?
This line isn't happening anymore, right?
make byte-ray.new a constant and use here.
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
- shorten to assertJtsEnvelope("MULTIPOLYGON EMPTY", new Envelope()); - ditto other tests
can't we just store filename = String.format("%s.%s", filenameBase, "values"); and not have makeFilename called in multiple places?
Please catch GroupResourceMismatchException from conversion method here and wrap it to ConsistencyErrorException. Because on input, there is no group and we retrieve groups assigned to resource - hence from the same VO and there shouldn't happen any Group-Resource mismatch.
- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
I am a bit confused that this check will be called on almost every line of code.
Collections.singletonList
Is there a need to have log.debug within transaction scope?
Can make this into a singleton as we have with UNSET.
nit: Perhaps you should show the user how to parse the JSON?
Same thing here, I don't think reset should stop component. What is the difference between these two lines and runtime.getComponentManager().restart(true); ?
Please keep this.cell near the related fields (previousFamily & cell count) below
suggestion mapper.orElseGet(ObjectMapper::new).convertValue(this, new TypeReference<Map<String, String>>(){});
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Curious why we want the IBAN implementation detail in the name if we no longer have the createRecipient method?
Can you add getId() and mark id() as deprecated?
not all listener
@erikdw MESOS_SANDBOX is set by Mesos correct? Wondering if we should override System.getenv("MESOS_SANDBOX") with logdir only if storm.log.dir is configured?
You missed a check on the type of classes
You can replace this getArrayProperty().length check with a call to configurationService.hasProperty(). That's the recommended way to determine if a property exists in our configuration.
This can be java return valueOf(value.toUpperCase(ENGLISH));
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
Maybe for cases like this where the list is only consumed once it would make sense to add a mapLazy that is based on something like this: java static class LazyMapList<I, O> extends AbstractList<O> { private final List<I> list; private final Function<? super I, ? extends O> mapper; public LazyMapList(List<I> list, Function<? super I, ? extends O> mapper) { this.list = list; this.mapper = mapper; } @Override public O get(int index) { return mapper.apply(list.get(index)); } @Override public int size() { return list.size(); } }
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Ideally, we should avoid using getProperties(), so the code that does this should be factored out. getMimeType() in SparkStreamingPlugin is exactly what we want, so should convert it to utility code.
Are consecutive reloads necessary or will be one reload at the end sufficient?
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
I realize it's a first cut, but I wonder if we should map some basic headers (method, path (uri), Accept) ??
remote this
It makes sense for this method to be boolean. I am not sure we should be throwing an exception here. The caller can decide that based on the return value.
I'd like to see our Throwables.throwingOnlyUnchecked used here
I would retain the existing indexOf body to to avoid indirection in the most common case.
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.
Static fields should be accessed statically rather than through an instance: Person.PRONOUN_HISHER
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
How about distributionMap.compute instead of distributtionMap.put ?
objectId
Default should be false
Need to check those variables are initialized or not to avoid NPE.
This method is no longer waiting for the refresh operation to complete. Not sure if that is important for the test flow or not.
@komaz maybe for now we can just return empty iterable, there is no need to react so strongly about missing implementation.
should return false if the validation fails
This method seem to return just two states - boolean would be much suitable here and in the DRL rule when this method is called, we can penalize directly by -1 for each task that does not accept the assigned user.
Please use a constant for 194 (like MAXIMUM_STRING_LENGTH)
looking at the gson code base, remove also could return null if element not exists hence we might want to guard aganist NPE here as well.
seems that this really needs a companion method isVararg() and maybe even throw if not vararg
I would prefer to use String.valueOf(value)
Can you extract a constant whilst we're at it?
remoteVolumeName passed twice. I feel remoteHost to be passed as second arg
Can you just change the return type of this method?
Just want to double check that the following null check is correct:  if (mScrollDirectionListener != null) { mDetector.onTouchEvent(event); }  I think yes, since mDetector is always not null, and it fires updates on mScrollDirectionListener.
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
Have you considered skipping the line above by having something like Queue<ControllerAction> result = new ArrayDeque(queuedActions);
This should follow the normal exception handling path and let the caller handle the printing of the exception.
Please move such updates to separate commit of the same PR, as it is not related to issue
Please use assertThat (result, failsWith(NAME_OF_FAILURE))
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
Multi return is forbidden.
Why did we make this public?
please move the isEmpty methods to the scimSchema
could be simplified: Collections.addAll(refsSpecs, specs);
Formatting issues. Please use appropriate spaces between string literals.
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Minor: From what I can tell, this is only used in one place (JobNodeConfigurationGenerator). Since this is fairly simple now, would prefer removing this class and inlining the generate method there.
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
Is it necessary to call this again?
Argument name
This will trigger for thread exists also. We should make sure we are dealing with a process using: if (event.getDMContext() instanceof IContainerDMContext)
Would it be better if we add a logic to check whether the actionMode is null or not to prevent resetting the state of toggled items? if (actionMode == null) { beginRemoveLanguageMode(); }
should this be else if?
Let's avoid raw types, please.
This can produce a different module name than what's actually produced by the compilation in the case of sanitisation. Instead, it should just return the precomputed modulePath like so: return ExplicitBuildTargetSourcePath.of(getBuildTarget(), modulePath);
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
Is there a particular reason to make the rect a single pixel shorter and narrower than the graphics object? It causes a black border to appear on the right and bottom sides of the display, which doesn't affect the test fidelity but also seems unrelated to the functionality being tested.
Remove "TestAggregateIdFactory" as this method is already static-imported
make this synchronized.
use as loopvar?
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
Please add a java Objects.requireNonNull(computation, "computation is null");
Should this method be final?
Program to interface, not to implementation - please change return type to Map<String, Object>
We could call: java checkNotNull("command", command);  :-)
Can we have a thread name here?
must be package local
suggestion connectionFactoryList.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
I believe this should be zero
Should we be 310-ing it up in here?
use ShellIsAvailable
DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now
Is a public setter necessary? Can the abstraction be the CentralRepositoryAccount instance itself, rather than the primitive?
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
This method doesn't need to return anything. When completed, the connection should be considered 'closed'.
We need to check offset + length <= arr.length?
It seems strange to test for null in this test, since it is testing the happy path. Can you create a FilterStub?
Please copy args here too
I would use the canonical name here, to avoid having two classes marked as equal but have a different hashCode
just return directly, no need for packageName variable
can be delegated as: putByteProperty(key(key), value)
suggestion public @Nullable ImageIcon getImageIcon() {
On iOS I chose to not ignore this error since it makes the data structure useless and should require some action from the API consumer.
Did you consider returning a File rather than a String here? It looks like you are only using the result in the context of a file, so it might be cleaner to make the File at this point.
Visibility missing. Synchronized comes before static Why return an Iterable here? It would be better just to return a List<TerminatlInfoView>
space
initialize() or schedule()
Why introduce a variable here?
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
Please add this.
Use the ClientLogger logAndThrow API whenever you are throwing an exception.
This should say "OffsetTime".
Why not just pass null into method? Or is this for clarity?
what's the intent of this change?
Huh? :-)
although its nice to use java8 optionals. sometimes its easier to read old fashioned if null checks.
![MAJOR](<LINK_0> Make "isSAM" a "static" method. [![rule](<LINK_1>](<LINK_2>
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
Why are you calling toArray instead of calling the constructor directly?
I think you want to do this in the reverse order
Since the runner is in the same package as the factory I don't see why it should be a String ?
Remember to revert this file, it should know about the transport class.
setErrorMessage
userPointModel != null && StringUtils.isBlank(userPointModel.getChannel())
Unsure this addition is useful.
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
filter could still be null when this line is reached - we should check it isn't null
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
nit: this should be "f"
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
we could avoid some concatenate as it's always starting with "MachineLogMessageImpl{machine=''" or maybe MachineLogMessageImpl should use class.getName so refactoring will rename automatically the toString
isInfoDebug
I feel like this switch statement should be part of the RetentionPolicyMgr
rename
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need anything to be added to DB.
But we have already clicked the button in the command before, haven't it?
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
I'd rather use Money here.
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Redundant parentheses.
Add the original ClassNotFoundException as cause.
why this double usage of URL? Wouldnt be using URI instead of URL be fully sufficient? (URL is known to have severe flaws and should be avoided if possible)
can you make all of these as just Query and not org.hibernate.Query?
a little better to have the Set as final and create it in the constructor, and clear it here.
This method should return RemoteCache<K, V>.
remove the this.
This is another behavioral change that I don't want to see in an unrelated PR.
I think you could use MorePredicates.transformingPredicate(TermporalField.toValueFunction(), IS_PRIMARY_IMAGE) here.
This should be created once for mini... it shouldn't really ever fail, since it's always providing its own configuration file... that it created.
Unsure this addition is useful.
Remove all "null" cases. There is a default case for that.
if it's mildly unexpected but fine to continue without, should be Timber.w I think. Unimportant in the grand scheme, but just want to either have a good debate on or harmonize on log levels. I consider 'e' to be things where you need to bomb out of an activity entirely, almost completely unrecoverable but not quite a crash.
replace with ReferenceCountUtil.release(msg)
is the server name mandatory still ?
replacing this with helper method would be great
why is this public?
Try to avoid using string concatenation, use printf-like instead, like we do in the rest of the code: javaBuffer.addLine( "%s %s = get();", mainTypeReference.getText(), parameterName );
This method is only used in the scope of this class, so you don't need a public setter for it. You can use the private field directly.
If you are using synchronization to control access to the session data, than I would suggest reverting the map type to a simple HashMap and synchronizing around the map as opposed to this whenever you read, put, remove, or alter it.
Since we put a log in the app deployment time stating authorizer is null, there is no need for this log.
Should be externalized.
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
use log's parameter here
hmm, why don't you verify the type ?
Why not using getStoragePoolId() instead fetching it from the disk
this is 3.3 feature, not 3.2
suggestion template = getKubernetesCloud().getTemplateByName(getPodTemplateName());
Can this be private, or is there another use case for default attribute outside the builder's call?
I question if the synchronization here is correct. I'd like to walk through it with you to understand it better
Why not assigning this value in the field declaration?
It's beeter to used int type.
Wondering what's the benefit of catching java.lang.Exceptions for EventListener.handleEvent() when handleEvent doesn't declare a throw in its signature:  public interface EventListener { public void handleEvent(Event event); }  Should we make it more specific to catch java.lang.RuntimeException? Since there is no throw in the signature, we don't lose on any functionality, and it makes the intention clearer in the code itself.
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
Would be a good spot for warn log entry, since the old value of this.address would remain unchanged on exception.
it needs to be protected against concurrent modification
why not replace these two lines with return (getState(key) == State.SET)
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
throw e will never be executed.
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
We need configuration property persistence-manager-remove-count: 1000
not a big deal, but you can use getClass().getSimpleName() instead of hard-coding the class's name. That way sub-classes that don't add fields can reuse it.
Everywhere we call entity.getClass - we need to use the EntityDictionary.getTYpe instead.
Why are you changing to patient 7 here too?
Log debug - not info.
Resources is itself part of Guava, and is marked @Beta. Why not use GuavaCompatibility.class.getClassLoader()?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
I think a special case should be made for an anonymous principal, to disallow the API in such a case.
What if we have only private static boolean isIncluded(String[] groups, Collection<String> includedGroups, Collection<String> excludedGroups) instead of 2 methods?
I think on reason to wrap into isDebugEnabled() since we don't do any logic with argument to log.
this imply hostedEngineVm may be null. shouldn't other flows consider the same ?
I think that "close" should be in finally block, just in case.
Please, use text "Project owner login" (Name was fixed after sending this pool request) thank you.
This can be made static
Should we keep "basic" here?
clickGallery is not the name of the method
"ws" and "wss" must be defined as constants.
UnknownHostException can be removed
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
I don't know, but isn't the class also of interest?
It's better to use static import here to improve readability of code.
please fix
shouldn't print the stack trace from the test
should be setSucceeded(true)
Why don't we make inDegrees to ConcurrentHashMap also?
Can you replace IDs with names in this log message?
check formatting
Why protected and not private?
You shouldn't depend on the expected value passed by the developer - you should go by MaskValidator.getInstance().isMaskFormatValid(mask).
add Reporter.log(String.format("<br>INFO&nbsp;&nbsp; - Accepted alert <b>%s</b>", alert.getMessage());
No need for the instanciation, right?  webView.getSettings().setJavaScriptEnabled(true);
Could this and the above constructor be changed to use the below contructor? e.g.:  public Region(){ this(null, 1, Integer.MAX_VALUE); }
This could be simplified via StringUtils.stringToInt().
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
Why is containerHeartBeatMissSet.contains() call necessary?
Another %n?
Maybe check for if name ends with ':' so we don't do a double one?
want to change this logging also while you are here
one is missing here
Rename -> CosmosDbFactory to CosmosFactory
tokenizer.skipString() I guess. No need to convert Utf8 to String here, just use the stream.skip().
return a copy please
Why does the handler require a zkUtils reference itself? Same for the other one.
Should this do something along the lines of if (optional.isPresent()) throw new IllegalStateException(); in case it accidentally gets used with > 1 value ?
Do we not want this test to run with segmented true and false?
i wonder if using Pattern.compile() as a static member to hold the compiled expression is more efficient.
I see you didn't change the assertions
I do not like createExtension modify the entry... I think it should be: entry.setExtension(createExtension(entry)) there is no reason to load the module here and not within function... also, I am unsure the function of createExtension is worth a separate function but not that important. the activateEntries.put()... should be after initialization is success as last action, this will enable you to skip extensions that fail initialization. you should catch exceptions within the loop, to allow proper initialization without faulty extensions.
there are some concerns in this file. I can see you are doing some defensive code, but possibly there are ways to do this in less code. for example, if your before and after blocks did the defense, the delegation methods would not need to.
Just an observation... might it be more cool to return Collections.emptySet()?... if we have the option to reduce null usage we should do so... imho helps in the long run... but - I may be wrong...
I think you need a null check here similar to the getViewIndexId. If the view index was created by an old client it won't have the VIEW_INDEX_ID_DATA_TYPE and you can assume its a short.
No, I mean take the Log.e() near the return null;.
Code will be clear if we use static import of **Asser.assertTrue** here.
We should first check to see if this is closed, and if so simply return.
would be nice to save index.getColumn(column) so we don't have to do the lookup twice if it's non-null.
To avoid the magic number, let's use HttpStatus.TOO_MANY_REQUESTS_429 here.
suggestion driver.get("http://host.testcontainers.internal:" + port + "/foo");
restore empty line.
this line can be removed (variable end not used)
As IOUtils has been imported why not just use IOUtils.closeQuietly()?
please rebase, arik removed the lock in a different patch.
"valid times" should probably be "setup time" or just "setup"
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
It makes sense to introduce ICPPNodeFactory.newLiteralExpression(int, String, , char[] numericCompilerSuffixes) method, use it in GNUCPPSourceParser, and get rid of the setNumericCompilerSuffixes method.
Integer.valueOf
you could throw a RuntimeException to have a better simulation.
why needs this method to be static?
I think it's better to use RqHeaders.Smart#single() here (and all methods below)
I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.
prefer == instead of !=: instance.rootWorkflowId == null ? instance.id : instance.rootWorkflowId
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
For this value, we should do something closer to what ProductDTO does. Leave the building of the URL to the actual entity so we don't have two implementations of it floating around. We should also update Pool to be nicer about generating it so we either generate a valid URL or nothing at all (see Product for an example)
getter
"line"
please check here isSetPmProxies() otherwise you can get NPE
Great idea! Can we use Locale.ROOT instead, though?
Good catch :-D
Unnecessary parentheses (and an extra line break).
Please consider adding a Preconditions.checkArgument to check that base64EncodedKeyContent is not blank.
Put these two assignments in order so it's clearer
This is a copy&paste failure: the class should be TextViewerTest.class
Also wondering why? and how this is related to ASM 6?
Ok, I see .. the clone function is for returned values from the CacheUtil. So no duplication within the cache (which uses the more primitive constructors)
what about location ? we do not need LocationSerializer ?
@sbespalov : Unless you intended this for debugging purposes, I think it sounds like a reasonable suggestion.
Name in log message needs updated
does it make sense to send 2 versions of the verb to different hosts in the data center? (if one is older than 3.3 and other is 3.3) i think you should use storage pool compatibility to be consistent with all hosts in the storage pool.
This looks like testDataFormat(COMPONENT); Please see other tests for sample
But why do we handle 400 differently than all other errors?
Is this method really needed? It's similar to make init public
I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
The params are so nicely aligned above, how about here and below ;) ?
This looks the same as the V1 version except for the Class of the version. I think you can just use a template here As an example <LINK_0>
Is this method really needed? It's similar to make init public
I am a little worried about the performance of this change here. getTypes can be used quite frequently, each time we will make a copy of existing types. Also changing viewof to copy will change the behavior. Many optimizer rule just call getTypes once and assign it to a member variable, newly added variable in the optimization rule will be missing in the copied TypeProvider. Can we change the TypeProvider to store only Map<String, Type> as well? It looks like we don't need to use Symbol there as well. The only other place copied the whole TypeProvider is areExpressionsEquivalent method. I am not sure if we need to convert the variable to input there though. I think variable name is unique already in TypeProvider, so I am not sure translate it to integer will help much in canonicalize the expression.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Why not this::refresh ?
As written before - not that critical but consider set (just to ensure nobody will be making a mistake of adding twice the same UUID - i mean, if they do add , you still should have only one copy).
Icky. Can't you pass it in the ctor instead?
Use this.key
Same as above, let's not instantiate the FBO within process and let's try to use BindFBO in initialize() instead of this bind() line.
throw exception
Does this truly need to be done in arjunaCore or could it be guarded in XTS alone? It is fine if it is an arjunaCore issue and we should code to fix it but I need to see an arjunacore test case that shows this or reasoning it can't be sole change in XTS
why not use the MessageLevel type?
Please consider to extract to a different method (like isInternalManagedDisk)
There's an Assert.assertNonNull that can be used
suggestion return (original == null) ? null : original.toUpperCase(Locale.ROOT);
you can use return (luceneQuery.startsWith("query_"))?luceneQuery.replace( "query_", StringPool.BLANK): luceneQuery; it is just a style, up to you
the resource list will change during resolution if additional resources have been loaded. In this case a concurrent modification exception is thrown. I nevertheless accept the change and fix the bug by replacing the loop with EcoreUtil.resolveAll(rs); This handles the room file as well. Should that cause any problem?
It should return ReadOnlyDictionary not ReadOnlyDictionaryInterface. Also IIRC, ReadOnlyDictionaryInterface is internal for Java.
@rui-castro why don't you keep skipsOnStream as it was?
Does the first part of this statement make sense anymore or must everything be explicitly _marked_ shareable now?
Isn't it also important that adType was async and method was top?
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
Can this be in the layout?
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
This should stay final
Minor: Would it be better to consolidate all of these "get" tests into a single test so all of the test is in a single place?
Do you forgot to compare items and label?
retain the else condition which is there in the original code. This sets the hilighting of today's date in calendar
Remove the call to this();
should the interface not the implementation suggestion public List<String> getTopics() {
Since you are using this value outside this class, you should define it as a static value in this cl;ass and use it in the other package, i.e. "FixupTableDefaultHandles. These values should also be non nls
@ivandalbosco Why not using noneMatch?
It looks like that this catch block is in a dead code path. Because startLogReplicationRuntime will catch all exceptions and input an event to FSM. Remove elements in an iteration over values also dangerous. > If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined.
It should be "Then that player shuffles their library", the oracle text in the spoiler file is outdated. I've been dragging my feet on updating all of it.
if OUTPUT is non-null, assert that it is writeable.
tokenizer.skipString() I guess. No need to convert Utf8 to String here, just use the stream.skip().
As I already said - this should be an immutable set cached in a private static final field.
Wait, this is worse than the previous version. What happened to the assertEquals()?
no checking flow when user sets grace period in the action
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
We might want to consider calling the new method from this one so we don't duplicate code isPublishDateInTheFuture(dateCreated, new Date()) wdyt?
No need to override this or the following method if you are not going to handle commands or updates.
I would prefer to use String.valueOf(value)
wrong formatting - every parameter should be in new line
Perhaps the FileChannelSink should be one per factory, not one per channel?
use new Guid(String) - this literal can't be null
I am not sure if we want to return null here
"http.url" is the current name, when query parameters are present (which I think this is..)
This does not verify the order. (The iteration order over expectedMap is undefined).
Make it static
Same here, making methods protected allows users to override them.
The last null is interpreted as a null Flag, not as a null Flag[], and is causing some NPEs in the test suite: <LINK_0>
Same here, this method return void because we don't want to have nuxeo-java-client outside this class.
This plays the current, not the next station.
This println can probably be removed.
@antonini you can use Matchers.allOf() to combine these two assertions and get rid of one-time variable head
This is not clean. If this method now returns an absolute path, you should also change the method name from "getName()" to "getAbsolutePath()". Also, you will need to change the messages. With your change, the FSOperation_ConfirmFolderReplaceMessage would now say "This folder already contains a folder named /foo/bar/target/file" . Which is not accurate. Instead, the message should now say something like "Folder '/foo/bar/target/file' already exists. Do you want to...' Or you could change the code even more, to say "Follder /foo/bar/target" already contains a folder named "file". Do you want to..." Please make sure that you test the workflow, and validate that your final message makes sense.
You should put default tenant here if it is single-tenant cluster, similar to addTable() You may extract this part into a helper method
does this need to catch all exceptions?
These two could be simplified to assertNull.
return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM) if it needs to be modifiable - add new ArrayList<>(...)
I'm seeing MySQL use an error code like this: 533 throw SQLError.createSQLException("Unable to unwrap to " 534 + iface.toString(), SQLError.SQL_STATE_ILLEGAL_ARGUMENT, this.exceptionInterceptor);
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
use getDiskVmElementDao(), please apply to all the dao calls in that class
This is my favourite part of this PR
all services are closeable, so use IOUtil.cleanupWithLogger() & let it handle null checks and exceptions
Shouldn't this code run even if mHasWifi is false?
Sorry I don't quite understand the check. How do you know if the outgage mode is turned on in the AuthenticationResult class iteself? If it's not turned on, why we're checking extended expires on?
Since the menu item click has been handled, return true instead here.
Just curious but why didn't you stick with just using the context passed in the constructor, I think this is the better approach since the resources you get may be context dependent.
Can c be null?
Similar change as first(count).
pls use querydsl instead (already in master)
protected static ConfigurablePageObject getPageObject(Jenkins jenkins) { return jenkins.getVersion().isOlderThan(new VersionNumber("2")) ? new JenkinsConfig(jenkins) : new GlobalToolConfig(jenkins); } ConfigurablePageObject configPage = getPageObject(jenkins); boolean onConfigPage = jenkins.getCurrentUrl().equals(configPage.getConfigUrl());
IOException comes from API signature, so there's nothing we can do there. You can add a release() with the LightblueException.
Did we want to have this normalize the path also by returning the normalized version from Path?
I think this log is no longer in use.
Hm, I think this should probably fall back somehow in its current form, or throw a much more explicit error if it fails. Before we had a guaranteed no-error, since the array was fetched from ID resource. Now it could get removed and our error message would be incredibly vague. Especially since this can now fail due to a change in commcare-core that is quite invisible to the end-user here.
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
This makes it possible for cacheManager to be null. References to cacheManager presume non-nullness.
We can push this further up by having these helper methods return the function we build in each of these methods, will help increase readability.
other places use "error" lower case
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
Sorry, just because it is deprecated doesn't mean we can remove the test for it. We must ensure it continues to work until it is removed.
Will this ever be ok? Not quite sure why this just wouldn't throw a SessionUnavailableException as part of the method signature
assertion for channel kind should be added.
should this call SQLUtil. sanitizeCondition instead?
This must be supported.
@vkdrn Thanks for contributing!! Would you mind to add all attributes in toString method too?
You can use CollectionUtils.toImmutableList
Same here when trying to save the context without specifying the script (or when trying to import the context).
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
Import org.apache.hadoop.conf.Configuration please.
By right, soft deletion should not result in InvalidParametersException
remove line
This seems wrong, it should be rawField( absoluteFieldPath, Object.class ). And tests do not fail, so you're missing a test here.
any special characters to block in webhook name?
we need good docs here
Please keep this.cell near the related fields (previousFamily & cell count) below
You are creating new list each time, why not just forEach(resourceResolversInTryWithResources ::add) instead of collect(Collectors.toList());
You could use ReflectionUtils#getTypeClass(Type), I had forgotten about this method.
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Adding this to a field is good manner.
instead of duplicating this would it be less error prone to have a common interpreter test java file to define this?
What if type is not Class type?
why not use org.ovirt.engine.core.bll.storage.StorageHelperBase#connectStorageToDomainByVdsId ?
style nit: we don't use curly braces around single line blocks
Please have a look at org.jboss.as.controller.operations.common.Util.createEmptyOperation.
Why not public access?
Can make this into a singleton as we have with UNSET.
We should still render as before, change the text size of the button based on the text_size attribute if present
Suggest create local variable Role role = null and use only one return.
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), CANCELLING, EMPTY_VALUE);
can this be part of new module as InputSource seems to replacement for firehose related interfaces ?
Then I wonder if this is the correct behaviour in the case of garbage being returned. Isn't the contract to retry in the case of invalid reads?
Shouldn't the test be synchronized as in Http1xClientConnection.java?
incorrect.
@vilchik-elena Charset.defaultCharset() should be replaced with a given charset.
suggestion if (rowIdx >= rows.size() && requested > 0)
There's a assertEquals(String message, long expected, long actual) method, so we could do something like this: java assertEquals("Check same instance is re-used", gridLayer, control.getGridLayer());
Could you use a format string here:  log.warn("Zookeeper can't be reached, retrying (retryCount = %s out of %s)...", retryCount, this.getN());
cc @highker on these removal
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
That is not clear, why do we have "Save" is not adding alarm item is enough? Actually, it is saved in Realm but not scheduled in Alarm manager?
This will silently ignore the exception. Should be throw Throwables.propagate(e);.
this mapping should happen via public enum and not via mapping backend enum to string
It seems that the following does the same thing with super.unparse(...).
Always called with (null, null) - so method and URI is never taken into account?
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
why not simply add tcall the error.. we don't need a special logger here.
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
a default value in the middle of the arguments (one c'tor being A, B, C, D, E, the other A, B, D, E) looks strange.
Why you do not call it in finally block as before?
is this needed?
I thought I already implemented this for the MavenArtifactGenerator...?
suggestion assertKeyPair(file, null);
Binary output length can also be calculated.
Can this just return 0 if length == 0?
Can header name and value be null?
Not sure whether this will work, If it does, do you think it makes sense to just clear out the offsets for the partitions that got reassigned, This way we will still have checkpoint state for the partitions that didn't get reassigned?
Instead you could check this.groupingSets.isEmpty()
Imho , some style inconsistency. On one hand you have a final char for delimeter, on the other hand you append hte literal '=' (no final char for it) why?
when you are on it: add braces
Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP
return optional.isPresent() ? Stream.of(optional.get()) : Stream.empty();
Add reasonable toString() method, returning null doesn't seem as proper way.
we can refactor this if and the one below into more compact code by checking nonnullable using ternary operator
Why not Set<DependencyMaterialConfig>? Stops casts at places it's used.
Add the original ClassNotFoundException as cause.
@HDouss how about TimeUnit.MILLISECONDS.sleep(this.delay)? makes it clear we are using ms
Isn't a HTTP Status 404 just enough? Do we really need to write a json message as well?
Same as in Alientype2.java (add type of alien)
Shouldn't this also test an Array that is empty, i.e []? Instead of a String that is empty, ""? Also, I am wondering about multi-dimensional arrays which is kinda the point of deepToString... If the array contains other arrays as elements, the string representation contains their contents and so on. <LINK_0>
See if this can be done in one line. ... ? ... : ...
maybe sth like content.avro.deserialization? so in the future we might add content.json.* metrics, it would be weird to have .json as root metric
When would this exception be thrown / can it be caused by user input? If so I would prefer a checked exception here (even if it's a DevfileException or something) since unchecked means more to think about.
why do you need config temp variable?
cosmetic: move the catch line to prevous line following }
Should this be two separate tests, since it's two separate conditions with two separate asserts? Also, is there an associated negative path test (i.e., testing the behavior when passing in a random String or a null value)?
you should probably cast to a string or call toString also could be shortened to return (String) get( key );
minor nit: can we check mSavingContentProgressDialog == null and only create a new ProgressDialog in such case? something like this:  if (mSavingContentProgressDialog == null) { mSavingContentProgressDialog = new ProgressDialog(getActivity()); mSavingContentProgressDialog.setCancelable(false); mSavingContentProgressDialog.setIndeterminate(true); mSavingContentProgressDialog.setMessage(getActivity().getString(R.string.long_post_dlg_saving)); } mSavingContentProgressDialog.show();
I think this isn't necessary here since getStatistics() doesn't need the configuration
Missing @ Override
Its probably a matter of preference, but you can just do return getDelayTime(ingestTime) > TRACKER_DELAYED_METRICS_MILLIS
commit currently checks these locks, so I'd expect two refreshes. Can we confirm the call explicitly after the get and commit calls?
that should be inside an else clause, no?
move it before synchronized
Why does next have to be invoked here?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Too lax imho, should be .equals("org.apache.commons.logging.impl.Jdk14Logger")
Actually the underlying objectExpr could have free variables.
return authentication.getUser(username);
this seems like it should be a try() with resources
The title should be HTML escaped here if it's going into an HTML constant (which is presumed safe)
@fchauveau there is no null handling of source, is this intended ?
Revert this.
Should this return 0 or -1?
Does this need to be public? Please do not introduce new public members without cause.
We can do without final here since the whole class is final.
here too, can this be done with computeIfAbsent?
getTotalTimeout makes more sense.
Does a straight comparison work here? NaN isn't usually equal to itself.
The new term and self vote still have to be persisted before transitioning to leader, i.e  raft.setTerm(raft.getTerm() + 1); raft.setLastVotedFor(raft.getCluster().getMember().memberId());  Without this the raft is in an invalid state, that is also why the test are currently failing on this branch.
IllegalArgumentException for consistency, needs 2 _arguments_
Should this be delegating to a different method than encodeLink, above?
Looks like approach proposed in line 92 would help here too. The less code duplication, the better :)
Nitpicking: would have been more compact with a constructor KeysSupplier(Collection<Object>, boolean).
Using the error message in the metric could get really messy. These are arbitrary strings, and could be very long. For Error, we're using the error code-a _very_ different thing, since these are well known, and short. The exception type name is enough for Exceptions.
Might as well add a comma
complexSlug is not used in this context.
I think that if there is more than one stereotype on the annotation (which is allowed), then this will override the variable and you will only inspect one of them which is incorrect.
Yep, what Leo says is what I meant.
change variable to something more meaningful
![MAJOR](<LINK_0> 'Severity: MAJOR') Update this method so that its implementation is not identical to "getParent1" on line 135. [![rule](<LINK_1>](<LINK_2>
Should we reduce the scope and do an earlier return if bulkOptions is null?
shall we add some message here?
@vkuchyn didn't get, why these 2 lines are still here? I thought they were added to cover "happy path", no? If yes, they should be removed
Remember to revert this file, it should know about the transport class.
no need to break long strings... check-style has an exception for lines that are just strings
Just seen this... Would it be more convenient for this method to be named assertPredicate? The current name seems to mean that it will perform arbitrary assertions...
To clean up properly, please place the Builder in a try-with-resource block java try (Builder b = new Builder()) { // test }
Code style: Always use curly brackets, and space after if.
/dataset/commons-lang/ will not pass the CI test since this repo is present just on your local machine right now and hence an error will be thrown on the CI server. Make it repogit4testv0 maybe.
This is not thread-safe, right? Someone can increment the _pendingCount after this block and have you tryExecuteLoop() again.
This line isn't happening anymore, right?
this method can be made static
static import DataSize.Unit
Remove log statement. Let's consolidate logging into fewer (more complete log statements).
This should return the PDataType for an element of the array
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
I would change the message to: "The resume() method was called more times than pause()."
nonexisting are two words. So, nonexisting -> nonExisting
Hmmm. The process() method should be as lean as possible. This calls for a DisableMaterial() class to be used as default instance, in which the process method is just shaderManager.disableShader();
Entry transformer can be static value, no need to create new on each call
This code could also be written like the following, and then maybe the map in the superclass does not need to be made visible. java for(CacheType ct : CacheType.values()) { //not sure if values() is the correct enum method name ((LruBlockCache) getBlockCache(ct)).shutdown(); }
I don't have strong preference here. - Shall protected or package-private enough here? - Or, on the other hand, with these two methods made to the public, we can avoid several test codes using INSTANCE_DN_KEY and RESOURCE_DN_KEY directly. Not a must in this PR, though.
Never call onNext while holding a lock.
do you need to check for nulls on paymentWorksNewVendorDetailDTO and paymentWorksNewVendorDetailDTO.getRequesting_company()?
Ah, this on-obvious to me: why do you switch the zone to UTF?
Should this method be final?
As above, assertions the wrong way around?
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
I'd suggest simplifying this block to (and for the similar cases below):  return super.getConfiguration(igniteInstanceName) .setIncludeEventTypes(EventType.EVTS_ALL);
this can also be made a static method.
minor: can remove this and directly initialize it at line 41
Likewise..
Lists.newArrayList
nit: this is a filter function, might be better to use filter replicaIds.stream().filter(r -> replicaAndState.get(r) == state && (dcName == null || r.getDataNodeId().getDatacenterName().equals(dcName))).collect(Collections.toList());
Need to implement
In the page, projects are sorted by a comparator, so that projects.get(0) may look as a randomly chosen project. The same problem was solved in NewApplicationWizardModel.getDefaultProject() by applying the comparator.
how about using String.format - it's much cleaner than string concatenation and you don't have to worry about "
I couldn't understand the need to get templates config and set it back again, is this required?
@fanifieiev it isn't the correct way to calculate hashCode. Please, look the others Cactoos classes to know how can do it.
Please replace the following 2 lines with return failCanDoAction(VdcBllMessages.HOT_PLUG_IS_NOT_SUPPORTED);
Can be simplified to: java results.stream().anyMatch(entry -> value.getK1().equals(entry.getKey()) && value.getK2().equals(entry.getValue()))
Instead of assign and return, just return the last statement.
Since State is an enum, we should use == here.
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
Let's static import the assertions inside org.junit.Assert so we don't need to prefix them with Assert.
maybe some kind of separator would be nice here?
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Who uses CR as a line delimiter nowadays?
I don't understand why localMediaId is a string in several places when it should be an int, but as long as it's being passed around as a string we need to play it safe and catch any potential NumberFormatException if it fails to be parsed as an int. The simplest way to do that is use StringUtils.stringToInt().
Minor: since locateMember has been renamed to locateMainArtifact, maybe downloadMember should be renamed, too?
I thought we had agreed that to preserve idempotence the local operator would always overwrite any existing view definition?
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
It's a good update
Let's avoid raw types, please.
Use nbrDim instead of min.length here
defensive copy?
you could use: prefix.ifPresent(prefix -> if (isBogon(prefix.toString())) ...
Can make this into a singleton as we have with UNSET.
This can be replaced with  java return newName.isEmpty();
It's nice to have expression lambdas, but using node.findFirstToken(TokenTypes.IDENT) results in evaluating the same node twice. Assign to a local variable.
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
be backwards compatible
These catch code blocks seem to be very repetitive, should they be factored out into a utility function/lambda?
(Rather than a bunch of IF statements, you could do this all as one return statement w/ && for above.)
Use a constant for this path.
Why setting Token or MID imply sent = false ?
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
This one seems too broad
Recommend to use ToStringBuilder
See below (return copy)
The last assert is different from the first 2
Is there a more specific exception that can be caught?
Another place where the name should probably be updated
Should make a differentiation of the name and id.
suggestion thrown.expect(containsCause(new ValidationException("Option 'csv.quote-character' must be a Character.")));
Detail: FROM capitalized.
Seems like debug code.
Why is this necessary?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
This should be >
like line 63 but this is setFeature, so should be removed?
it'd be nice if we could use polymorphic deserialization, but i thinkthat is a bigger change
why is it adding null?
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
nit: maybe replace } with a blank line? There is no such code style in druid. The same for the { and } below.
Can you pull this out into a property?
There are quite some AccessResultCodes beside SUCCESS. If the result is included with the exception this could provide useful information about what exactly went wrong.
This asserThat will do nothing - you need to add something like isTrue()
Mark as static.
Use '<' for character-based searching.
suggestion assertNull(r.jenkins.getNode("foo"));  since it is not otherwise obvious that the node's name did not change somewhere in here.
I have noticed a few occurrences of catch (Exception e). According to <LINK_0> we should catch the most specific type we can. Can we catch more specific exceptions here?
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
Use assertEquals
you've defined constants for these keys in another class. Why not make them public and use those constants here, instead of using the string?
To be safe you should read the bytes before assigning into data: byte[] d = new byte[len]; IO.readFully(in, d, 0, len); data = d;
return Collections.emptySet(); ? BTW, it seems that class DummyGroupMapping is never used now, do we need scrubbed it off?
Add stack trace to exception.
declared exception isn't thrown
use StringBuilder instead. StringBuffer is thread safe (and slower)
We may also want to cancel our subscription.
It's easiest to initiate the field directly, and I'm not sure it's needed, the primitive should be false by default
please remove or decrease log level to TRACE
should only append if gtidStr is not null
Why is csrf disabled in general?
Why are you keeping the conversion-less method?
shouldn't you close this stream? Use a try with resources?
I'm updating this PR since I would like to merge it before tagging the next release. Thanks for the fix btw!
Better to use immutable ValidationResult
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
Same thing about calculateInvocationTime
Don't log here. Exception is re-thrown with all relevant information and mutations could be verbose.
These tests might be a bit brittle since they depend on how the writer is verifying the existence of the header. If the tests did: java String value = new String("value"); this.response.setHeader(CONTENT_SECURITY_POLICY_HEADER, value); this.writer.writeHeaders(this.request, this.response); assertThat(this.response.getHeader(CONTENT_SECURITY_POLICY_HEADER)).isSameAs(value);  Then it would verify regardless of the way the writer implemented the check.
@gaurabdg interesting approach, but can we store this depth inside object to avoid unnecessary calculations
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
etc. for the rest
If VM's custom compatibility version is set, cluster's compatibility version is ignored. That means we don't need to display any warning, because nothing was changed for the VM.
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
Best to leave super() to avoid empty block complaint from Sonar.
Can restore Path installDir = Files.createDirectory(tempDir.resolve("install")); too, e.g.: Java Path installDir = Files.createDirectory(tempDir.resolve("install")); Path xmlDir = Files.createDirectory(installDir.resolve("xml")); Files.createFile(xmlDir.resolve("log4j.properties")); zapInstallDir = installDir.toAbsolutePath().toString();
nit: throughout this test suite, the WKT strings are not consistent. For example, there are LineString, MULTILineString, MULTILINESTRING, etc. Would you take a pass and make them all align. Perhaps, uppercase all the WKT type prefixes? 'POLYGON...', 'POINT...', 'LINESTRING...'
I think you can use freezing instead of pausing to have the player automatically save the playing state.
Lets use super.cleanUpUsingRest() here
What does the constant mean?
toMap() should return only JSON based object. I think getObject() can return non JSON based objects.
Do we need this to be public?
Should this not be by.css as well?
Added code to print an error message and exit.
probably also worth to rename callback to ruleManager.
I think can just indent 8 spaces from [t]his
a workspaceitem should be returned
Just a small micro-optimization here: If you swap the ItemSetting and the Material check, then this statement may execute just a tiny bit quicker as Enum comparisons are sped up by the compiler. Other than that this is looking good to go!
I suppose there is nothing wrong with this, but there is no need either, is there? (other cases of the same marked with ditto3)
Could you maybe look if this could be removed? I mean the new DefaultVariableNameFunction().apply(this). It's already handled in the other constructor.
Shouldn't this be < instead? if the end of the time range of this request is before the time range that has been updated in the traceRangeUpdated signal handler?
From PR it appears that you want to display a different error if the plugin is not loaded vs when the plugin doesn't implement plugin-settings. If that's the case, there are more straightforward ways of finding if the plugin has been loaded up instead of iterating over all each extension everytime. Its very easy to track that kind of information in DefaultPluginManager and ask it for it.
I think would be better to follow other components on how to set configurations, meaning that to configuration properties mutable and let Camel do the job of binding the parameters via setProperties(configuration, parameters);.
You should test for both instructor and student?
Is it possible to get rid of this?
BaseForm class provides a constant value for this faces-redirect=true. Please use this constant.
can u extract a final constant with a readable name out of "<[ ]*/[ ]*%s[ ]*>" ?
lastFlush is never updated. Am I missing something? Also I wonder if we should update MessageFlushPredicate.shouldFlush() for this new lastFlush argument as well.
This should be written this way. We also have to keep the code readable.
File. createTempFile takes prefix / suffix, not dir / Filename. That makes this confusing at first glance.
move 5 and 1000 to variables. Its used in so many places
static ?
Do we really need to check anything here? Surely the enterprise edition supports all constraints?
I see this method does something similar to execute minus the optional processing with the rowProcessor
Add a checkNotNull check here.
Map
You want to use assertEquals instead?
this mapping should happen via public enum and not via mapping backend enum to string
calling endAction here is dangerous, I don't think we have it anywhere else. it is problematic because the execute phase was not finished and there is all the infra in CommandBase that handles it. Please call endSuccessfully directly instead (and need to verify that the 'log' method is called)
nodeID could be null
Maybe move it to "buildIoTune" method, where the cache is actually used. That way when the method is called there is no chance of it falling on null cache.
Again, I think this should evaluate against the standard special path info, not the stuff for the maven package
Can we make this a list since it should be sorted.
call it processHeartbeat, as it does more than a check
~1 minute & ~3 minutes respectively?
naming s
Style issue: @Override shuld be on line above the method declaration
Should return the empty list, not null
We are setting this unconditionally, not just for "FOR UPDATE" statements. Is it possible to restrict it?
Add the @ConstructorProperties annotation here and in all other domain objects, for consistency?
isConnected = false;
Hmm, why did we do this? I thought we'd have a try/catch block.
"Cleaning all in memory locks"
Will * <LINK_0> * <LINK_1> work as well?
Per our discussion, we need to delete any removed custom data properties before saving the account and its custom data changes.
tracef
nit: this definition looks really awkward
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
events.isEmpty()
throws TaskException is part of the interface, did you mean to remove it?
Let's make this private and introduce two factory methods known(String, UUID) and empty()
pattern should be constant, so as not to compile it every time.
Should all users be able to delete?
Could you change your code so that super.getHandler() is called only once?
Use the immutable value cache
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
I would tend to make the first two Preconditions.checkState (they're not arguments to this function) and the latter two as is. Also, put the field name in the call (like Objects.requireNonNull(schema "schema");) in order to give some insight into the problem without looking at the source?
Is it better to initialize latch to CountDownLatch(0) instead of null? Also initialize it in line 45, when latch is declared?
I think this method can be final with addition of extra "hook" (overridable) method to register handlers: public final void setEventBus(EventBus eventBus) { this.eventBus = eventBus; if (eventBus != null) { registerHandlers(); } else { unregisterHandlers(); } } /** * Override this method to register custom event handlers as necessary. */ protected void registerHandlers() { // No-op, override as necessary }
I know I did not mention it in the initial review but TransactionImple.getTransaction() can do a lot of work so I think you need to cache the result in a local variable in order to avoid the second call to getTransaction.
Does the output stream need to be closed?
Presumably the method getAllGroupsSize in KeycloakUtil was written so that it could be used here?
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
just for consistency, can we use final int?
rename to f
Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.
we don't need to change the Creation classes.
don't we want to remove the place holder in case of failure?
I think you want to call the new method which gives servers based on glusterPeerStatus
Spelling
call notFound
is there a reason why this method isn't implemented?
Collections.singletonList
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Can we define a final CONSTANT for the MD5 ?
Stream closing?
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
It is file, not url. how about "file cannot be null"? that would be a completed sentence
add this.endpoint.setBaseUri(baseUri) ?
does this have to be a list or can it be an iterable?
Why not just "else"? Also, please add a space between if and (. There should also be a space between { and else
Let validate throw exception instead of throwing same ErrorCode for all validation failures
add brackets to make this expression more easy to understand
better use a ? b : c here
Could we please use <LINK_0> ?
Not an exception
If you used try-with-resources, you would not need IOUtils at all:  try(ByteArrayInputStream input = new ByteArrayInputStream(data)) { ... }
As I suggested in another patch, we should consider having a version for persistAsyncTaskPlaceHolder with one argument (parentCommand) which by default uses a DEFAULT_TASK_KEY. Same goes for getTaskIdForTaskKey - we should have a "getTaskIdMethod". This is not mandatory, it's a suggestion.
contains() would read more naturally here, is the performance gain here sufficient to justify not using it?
why? for debugging purposes? sure, but don't keep it in testsuite by default it just messes up with CI servers
How about returning the old MessageBufferOutput instance here?
this method should be changed to private
might be useful to print it, no?
If the Deserializer is named, Deserializer. The Serializer should be call Serializer!
How do locations look like in Azure? These looks more like Regions? I mean, zones in providers are usually in the form: northeurope-1, northeurope2, etc.
are these setters used anywhere?
isn't there dupContext() method in CommandBase ?
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
listeners are not notified?
I would rather choose to have a while loop to implement this rather than a recursive call (call stack can grow quite big unecessarily because of this call depending on the level of nesting of the file) and moreover, I believe a while loop would be more readable.
This seems unused.
this can be 'long' instead of 'Long'
You need to check that conceptUuid is not null and blank
Please use style instead of getStyle(), as this is more consistent with the rest of the code base. I.e.: if ((style & SWT.HORIZONTAL) != 0)
And then else if this
![MAJOR](<LINK_1> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_2>](<LINK_0>
@ekondrashev Same here, let's declare Exception being thrown.
-1 since the interpreter is only used with JMX now.
Does your custom inline parser not need to know about delimiterProcessors etc? I think the create method should get a InlineParserContext (similar to HtmlNodeRendererContext), that looks like this: java interface InlineParserContext { Map<Character, DelimiterProcessor> getDelimiterProcessors(); }  (The other two, specialCharacters and delimiterCharacters can be derived from the delimiter processors and are just an optimization, so don't need to be on the interface.)
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
if (!selectedItemList.isEmpty()) { selectedItems = selectedItemList.stream().filter(o -> o instanceof Integer || o instanceof Long).map(o -> (Long) o).collect(Collectors.toList()); if (selectedItems.isEmpty()) { return null; } }
Why not public access?
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage?
Should we add null check?
there's formatting issues here
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
These APIs aren't great since the method has no effect when called after controls were constructed. We use that in other places as well but so it seems okay but it's better to either fail when this is called after control creation or dynamically update the UI.
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
Maybe IOException since it's supported here?
What do you think about removing all the "set" prefixes from the fluent API?
This wouldn't take the precision into account so if the other method would return a fully qualified host name, this would always return that instead of a substring of it.
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "getComponentId"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
Yes, it shouldn't be cached in memory.
Version 3 I think ?
what if quota object is set?
Not related to the changes from this PR, but now that the ValidatorFactoryImpl is cleaner, I noticed that there are some getter methods that are not coming from any interfaces. Like for example isFailFast(), isTraversableResolverResultCacheEnabled(), getExecutableParameterNameProvider() and maybe others. Hence I wonder if we shouldn't pull then to HibernateValidatorFactory ?
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Does it have to be public? Couldn't it be package visible only?
isTrue()
We're still violating encapsulation principles here. We don't want to modify the collection and assume that's going to be retained. We should be building up the content and then throwing a new collection at the DTO, or figuring out a way to return the addContent method back to the OpenAPI DTOs.
lets cache interruptor instance. If JIT leaves double de-reference inside the loop - its bad
Users get very scared of WARNING messages, especially vague ones. Consider adding whether things will continue on or not and removing the first sentence.
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
What about items and label?
I'd make this return long and rename to getTotalPendingBytes so we don't have to keep going back and forth.
Be careful of nullable fields!
Wouldn't it be better to redirect the user to wondergem root in this case? I seems to me that this triggers a user being logged out instantly.
Shouldn't this just return true? I thought force meant unconditionally use RESTbase.
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
This is better way to fix SwipeRefreshLayout issue.  private View getScrollTarget(View target) { return mScrollTargetCallback != null ? mScrollTargetCallback.callback(target) : getSupportedScrollTarget(target); } private View getSupportedScrollTarget(View target) { if (target instanceof SwipeRefreshLayout && ((SwipeRefreshLayout) target).getChildCount() > 0) { SwipeRefreshLayout parent = (SwipeRefreshLayout) target; View child; int n = parent.getChildCount(); for (int i = 0; i < n; i++) { child = parent.getChildAt(i); if (child instanceof NestedScrollView || child instanceof RecyclerView) { return child; } } return ((SwipeRefreshLayout) target).getChildAt(0); } return target; }
I really never understood why these aren't Math.min'd
This doesn't check all fields. Use the super.equals() to check the parent class's fields and, if that returns true, then check this class's additions ((volumeSize).
mobile tests will be executed on chrome, so please use scrollAndClick()
Shouldn't we return "super.getCell()" here?
java boolean result = false; final DetailAST parent = colonAst.getParent(); if (parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT) { result = true; } return result;  ----> java final DetailAST parent = colonAst.getParent(); return parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT;
ofNullable maybe, no?
again - encapsulation
The error message doesn't match the actual behaviour.
Could we get a deadlock now in some cases? #reset holds a lock for the outer ProxyWhitelist, and when this is called it will also acquire the lock for the delegate ProxyWhitelist. Do we know that the locks will always be acquired in the same order? I would be surprised if there are cyclic references between instances of ProxyWhitelist, so my guess is that it should be fine, but it would be good for someone to confirm.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Same here for doing empty check instead of non null check.
does setBrickPosition do something different than brickPosition in all other brick tests? if not, please rename to brickPosition
Perhaps it doesn't mean that rows are really identical to each other, but only that they have the same place in sorting order or I'm missing something? If this method will be used wider someday this may lead to usage of old values with NUMERIC, VARCHAR_IGNORECASE, TIMESTAMP WITH TIME ZONE, or may be some other data type that has distinct values with compareTo( ) == 0.
lambda?
I have some concerns about this. 1. Wouldn't this make crashlytics run in debug mode as well? The old Crashlytics didn't "ignore" things in debug, but we definitely don't want them reported. That was why it was in the if...else in LoggerStarter. 2. The reason for crash logging to be initialized in LoggerStarter is b/c if the content provider is accessed through a Context which is not ours (like if we export our data), then our Application does not get launched so crashes would not get reported to us. LoggerStarter is initialized in the content provider, which circumvents this limitation. 3. Does this create a Twitter singleton that we keep around for the lifetime of our app? If so, that seems like a waste of memory since we only use it for the login stuff and even then only for vendors who actually use twitter.
Check if inputStream is null.
To be consistent with the rest of the Essentials codebase, I suggest reverting this back to not using a fully qualified package name.
Might this be clearer as: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return capabilityLimitMap.getOrDefault(capability, UNLIMITED_STORAGE_AMT_IN_MB); } else { return capabilityLimitMap.get(capability); }  This captures the logic of subscription licenses having unlimited offheap by default quite succinctly I think.
Should this be marked as deprecated as it is in Page?
SINGLE_THREAD_FOR_AUTOBATCHER?
Can this be within the if statement above?
This is unnecessary
Why result size is not checked here?
"Cleaning all in memory locks"
the ConnectorTopology.NONE is one of the supported connectors of the this component. So i don't understand this filter here.
this
Why is this necessary?
Thinking out loud: - This method is doing almost everything we need: it creates a CompletableFuture that is completed if the callback is called (send success/failure). - The only missing bit is canceling future after timeout elapses if future.isDone() is false, which can be accomplished with a ScheduledExecutorService. I know this is exactly what CompletableFutureUtils.failAfter() is doing but I think the logic over there is more than what's absolutely necessary; we don't really need the other CompletableFuture failAfter() creates or the additional logic in within(). We can just cancel this same future if it isn't done when timeout elapses. java scheduler.schedule(() -> { if (!future.isDone()) { future.cancel(); } }, _sendTimeout, TimeUnit.MILLISECONDS);  - future.cancel() causes a java.util.concurrent.CancellationException to be thrown, which means we don't have to construct a TimeoutException ourselves because a CancellationException can only mean we cancelled it after the timeout elapsed. This seems like something this method can do with a private executor service. I am not sure we really need a utils class just for this purpose.
Maybe we should cache the BluetoothManager in onCreate instead of the BluetoothAdapter. Or both.
It probably makes sense to set up a timer to get some metrics about the download times. Similar to: <LINK_0>
this lambda will alway return true if at least one representation is present in the resource. That is also the case in aird resource. we should get the first element in getContents() and next check that is element is instance of DRepresentation
copy/paste
this constructor feels wrong now... I think it should be a Module and a Definition and then the constructor calls getCombinedGrammar.
I know the method is invoked only from 'plugToExternalNetwork', but to make it complete I would check 'getNetwork' is not 'null' and 'is external'.
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
No need for getInstance(), the container can be passed
throw new RuntimeException("Node removal failure: there is no '"+nodeUri+"' in the render graph!");
Can use EntityPredicates.attributeEqualTo(Startable.SERVICE_UP, true) Note that will also avoid the strange NPE that you might hit if there is a router with SERVICE_UP attribute still equal to null.
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
no qualifier?
The error message should be more detailed. How about The supervisor task[taskId] didn't create any sub tasks. Was it executed in the parallel mode?
break the line
please use org.apache.commons.lang.StringUtils IsBlank()
style nit: we don't use curly braces around single line statements
Application context isn't required, we should be giving it the fragment's.
Use .substring(1) so that we don't have to allocate a new String instance.
List<Throwable> list = new ArrayList<>();
The core version doesn't actually process capabilities, but I can't think of a reason it shouldn't. A JIRA should probably be filed to enable it. Also we should process the attributes too.
Is this correct? Based on the definition of the special day entries in the DLMS Blue Book I would expect a long-unsigned value (newUInteger16Data).
Please close the stream in finally block.
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
Consider using something like this: fail("expected ApiException");
Move String values used more then once to a constant.
Label should be reporting.parameter.onOrAfter
nit: you could also move all the setUpServerChannel() calls
Use subtract to implement intersect?
Map
false is the default so you don't have to set it explictly
please use NotImplementedException()
suggestion assertThat(got).contains("Description");
All these are going to be invokes every minute. These may be expensive for a cluster that has many resources.
HashMap should be good here I think.
use getOrDefault()
nit: Will be useful to add a log line before Line 77 to indicate that the shutdown has been invoked on this scheduler instance.
'em.persist(member);' should be enough, you only need to wrap the EntityManager when needing to access methods which are not exposed on the JPA API.
I also can't understand it, but now result is always empty. will try to debug it.
can be private? or at least package protected access?
Apply SLAP principle here: extract this block to a private method, no matter how simple it is.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Use the solution in the large Overall/Manage PR instead, please.
Assert.notNull()
Since we are improving this code anyway, I think we should switch to using [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, since lowercasing a string is not always the same for non-ascii characters.
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
Use Iterators.transform from Guava?
10 is a magic number here, please extract it into a TIMEOUT constant
Doesn't this also trigger on Byte, Short and Long rather than Integer?
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
Assert.notNull() ?
You are creating new list each time, why not just forEach(resourceResolversInTryWithResources ::add) instead of collect(Collectors.toList());
Not sure this is right unless it's only supposed to work on *nix.
You don't need to make a variable here since you're not using it again. You could just do <code>new PhoneNumber("21234567890").getNumber()</code> :)
Looks like the ListRejectAttributeChecker could be used here instead.
I think we should have the same condition as we have in getMergedCellsCount: java cell.getMergedCellCount() == 0 && currentIndex >= 0
Are there any const that can be used instead of duplicating strings like this?
This Exception is never thrown. It may be that while developing, you had a change here that required the throws clause, but it isn't need in the proposed patch. I would have expected that would have reviewed your own change before proposing it here, and that you have removed this change.
Possible NPE, miInfo.getFile() is not guaranteed in current implementation to return anything in particular, so may return null or empty string.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
This needs to use justOrEmpty as the response value can be null which is an illegal value in a Reactor stream.
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
You should use the annotations field here too, not the wrapped reference.
Please log the bundle ID here.
Same here, would be better to leave it on the previous line
Should this return Flux.error instead of throwing?
Why can't you just return value here?
they both disposing the same trace. Keep the second call
Are result and errorMessage not applicable for workflows?
something is wong with the indentation, please fix.
Do we need to delete task mode mapping wherever this is being called? In general, would it make sense to get/put/delete them together as a complex value?
output.append("STATE").append(currentState.toString()).toString?
You could do the same thing by doing @Test(expected = BluefloodServiceStarterException.class) I would say checking for exit code equals -1 is not that important to do.
This should be delegated to the DAnalysisSessionService. As it is, there is a risk of inconsistent behavior: DAnalysisSelector sel1 = ...; DAnalysisSelector sel2 = ...; session.setAnalysisSelector(sel1); assertSame(sel1, session.getAnalysisSelector()); assertSame(sel1, session.getServices().getAnalysisSelector()); assertSame(session.getAnalysisSelector(), session.getServices().getAnalysisSelector()); session.getServices().setAnalysisSelector(sel2); assertSame(sel2, session.getAnalysisSelector()); // FAIL assertSame(sel1, session.getServices().getAnalysisSelector()); // PASS assertSame(session.getAnalysisSelector(), session.getServices().getAnalysisSelector()); // FAIL
Should those hashcodes be hardcoded ? They depend on HashCodeBuilder.toHashCode() implementation.
I am not following here - why do we want this in sync block?
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
Can you please add a WARN log stating an attempt to stop the driver when it was null.
Better to organise this in a double empty try-with-resources idiom: java try (Closeable ignore = level1; Closeable ignore2 = level2) { // Just for closing }  To delegate boilerplate exception and suppression handling to the Java construct. If it appears unnatural, you could extract this in a utility method, e. g. called  void closeBoth(Closeable, Closeable) throws IOException
not 100% sure, but this breaks binary compatibility, right?
Might be worth having a displayName?
Even if core.worktree wasn't set in the configuration file, it might have been set by the caller of Repository. We have like 8 forms of our constructor that takes various arguments... one of those is the work tree path, which could have come from an environment variable.
For loop?
Should we also have the same tests for the email template?
Now in addition to clearing indexes, we do this:  clearMapStore(); clearLockStore(); clearIndexedData(true);  Here we clear the lock store even though it might not yet have been collected by the LockService. I'm not sure if this is ok.
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
Consider adding a BusyIndicatorView for this call.
We need to get out of the habit of returning null when bad things happen. It's a SUPER bad practice. ANd it leads to exactly this kind of defensive null checking that clutters up code is distracting.
After thread sleep, I think need to continue the loop. Otherwise, consume messages from the consumer. Code snippet for if condition be as follows: if (wrapper.waitForReplay) { Thread.sleep(100); continue; }
Add reasonable toString() method, returning null doesn't seem as proper way.
return Status.BACKUP_FINISHED.equals(status) || Status.RESTORE_FINISHED.equals(status);
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
No key for encryption? ;-)
This can be a stream - filter - collect expression.
I don't think sleeping makes much sense here, either return immediately or throw an UnsupportedOperationException.
use ShellIsAvailable
throws
Maybe we should use ordinal and values()[offset] instead of writing the entire name? And actually do you find the Externalizer for enums, are they worth it still?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
URL Encode
The concern with this change is that it would be a breaking change for anyone currently relying upon the existing behavior. What is your use case?
you could use a newly added utility to get the color based on the state color to avoid "white on yellow": Color stateColor = gc.getBackground(); gc.setForeground(Utils.getDistinctColor(stateColor.getRGB()));
I find it more readable as: if (vmCustomCompatibilityVersion != null) { return vmCustomCompatibilityVersion; } if (vdsGroupCompatibilityVersion != null) { return vdsGroupCompatibilityVersion; } return defaultVersion; please consider
can you simply call onEditorOpened()?
change to List
Why is it public?
This is less noisy and reads better:  import static org.hamcrest.Matchers.startsWith; ... startsWith(BASE_URL + "/customers/")
Why are you blocking here? this should be async throughout.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Can't we just set without compare?
This retry loop could be pushed down into the doFateOperation implementation, to get it closer to the RPC. That way, if you add a new enum type to TableOperationExceptionType, you can check it before it is wrapped. This also prevents the thrift types from spreading too far away from the RPC code. Something like the following in doFateOperation would work: java boolean retry = false; do { try { // ... do fate RPC calls here } catch (ThriftTableOperationException e) { switch (e.getType()) { // ... existing code case BULK_WHILE_CONCURRENTLY_MERGING_SO_RETRY: // pick a better name for the enum // log msg retry = true; break; // ... existing code } } } while(retry);
is this the right check?
unnecessary array new: {{true}, {false}} should work here
Overly complex. Just say: Repository repo = repoManager.openRepository(...); try { ... } finally { repo.close(); }
Map.put already returns the previous value, so this can be simplified.  public int setExtraData(int index, Vector3i pos, int value) { extendExtraDataTo(index); Integer prevValue = extraData.get(index).put(pos, value); return (prevValue != null) ? prevValue : 0; }
can directly return without storing in valType local variable
suggestion return Objects.equals(this.getName(), actionParameter.getName());  The reason for this suggestion in general is that it handles nulls properly, e.g. if this.getName() returns null the previous implementation would crash
suggestion timer = getMetrics().timer("file-read");
Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
please use: runVdsCommand(VDSCommandType.UpdateVmDynamicData,..) so it will be sync'd with monitoring updates
This should be false right? since the ordering does not change the hash.
!isEmpty ?
Should we add return here?
Is there any particular reason why you split of the callbacks from runSynchronousPart()? You still seem to call them together in every location
Only very few parts of this function is tested, I think thats why codecov bails out. Are all these checks really needed? Specifically, the check for class equality will cause problems in case someone subclasses Package, right? Also the last two statements can just be written as return name.equals(that.name); To avoid a branch that would otherwise need to be tested.
This class has Constructor and getter/setter which are never used.
Remove final please.
Could we extract this logic into a separate class? I'm worried that the BuildView is doing quite a few things already.
Here we want to extract the tumor alt allele _fraction_ from the genotype field, not the population allele _frequency_ from the INFO field, right?
Inside the class, do not use setter to set value, simply use assign(contestId = null).
Shouldn't we return the interfac IBinarySourceBuilder instead of the concrete class here?
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Please do not use magic number here - actually, you can use http error codes for this or at least a constant.
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Should use ToStringBuilder.
Use this(...)
please move to static field. suggestion return "PROCESS DEFINITIONS";
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
Nit: Why public?
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we can say "don't do that."
Does this cope with the case "The previous session ended in a crash. In other words, one session can only have 1 crash at most." in the project definition? Should we also check if there have been unhandled errors?
This is unnecessary, its called via canFillFluidType() in super.fill().
If this is just for test validation, why not verify the pojo instances instead of doing the toString conversion?
This this isn't needed. Generally, we only use the this keyword where it makes code unambiguous.
This is actually the session request body, not the cookie body.
ServerSocket implements AutoClosable, so try (ServerSocket s = ...) {} might be stylistically better?
catch IOException and rethrow to avoid wrapping an IOException with an IOException
code style
Could use Objects.hash()
add it to finally? Otherwise ZIP stream may be corrupted if cf.open() or copy fail
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
What about the previous mImageReader instance ? It should be closed when detached .
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
I would like ot be extra safe here and it becomes smth like OS.GTK3 && !OS.isX11. This way I would be confident it would not have effect on X11.
You can remove the super();.
not insecure - but no need to clutter the workspace. use [WorkspaceList.tmpDir(workspace)](<LINK_0> If you can not bump a version to that write a helper that does the same thing.
consider saving the value of group 1 and group 2 here rather than the whole matcher
Why static?
but this doesnt solve the issue, even if the events are disabled in the config eventsRefresher will be created because it will pass the first 'if' statement (above) why not adding the check for events to the line above?
Fully-qualified class name not needed.
Safer to check if entry already exists for the given table. If yes, re-use else put new one.
"" + x.doubleValue() - is this the most elegant way to get a String from a double...? And if it is a usecase to instantiate a QuantityType without passing a unit, might we want to add a constructor for double as well)?
Style-nit: We don't put {} around a single statement.
How about checking numberOfEntries != 0 instead?
hmm for node based traversal the traversal id is the node id so I think getTraversalId makes sense (more general) ? But yes, let's replace the edge parameter with the adj node id.
This is only valid because the empty version is defined as "0.0.0". But AFAIK it could have been "0" as well. So I'd rather use a "0.0.0" (or "1.0.0") constant here.
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
I don't understand why we are looking at a VARIABLE_DEF? Shouldn't everything in the start of the enum be the ENUM_CONSTANT_DEF? If we hit a variable def, that means we are going past the end ; for the list of enumerations.
brokerRunning.getConnectionFactory() instead? I also think if that would be useful to expose CachingConnectionFactory from the BrokerRunning directly to avoid such a bean altogether.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
here it should use super.getHostId(). It's obviously the same thing now, but if we ever change how TmfTrace defines its host ID, then clock-less CTF traces should follow.
checking at least the important fields like chromosome and position and alleles would be nice. just in case we are returning an object will all fields as null. Applies to the other test class too.
decrease to DEBUG
Its best to just do one atomic "test" per method in this class. I'd probably break this up into - testAssignVariable - testAssignVariableMultipleAssignment - testAssignVariableNotDefined Also note that junit has some built-in exception checkers <LINK_0>
Is null the right thing to do here as the default or should we do something like throw new UnsuportedOperationException()?
I think it is unnecessary to use synchronized here
Why is this removed?
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
Does it add an error message?
Declare as final static..
Same here, this can be boolean
This should check whether the id is already registered. This should also define a locale for the lowercase method.
should we also rename this.blockSize to be this.rowGroupSize ?
unrelated: this can do 'super(msg, cause)' now that we require Java 7.
Is there a reason to not make it protected ?
rename to signature
We could create a new ChatMessage with messageData and remote
Please put the hardcoded string in the strings.xml file and call from there.
this line was probably copied from somewhere else but I think the message could be improved, for eg Charge with charge_external_id={} was updated from <old status> to <new status>
you should mock external components, not the one you are testing
Sorry to be a pain, but we should use uk.gov.pay.logging.LoggingKeys.PROVIDER here, similar to how <LINK_0> does it.
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
There are cases were other versions might show up in the future, so this behavior could be confusing. While I like the idea of having static defaults available, it would probably be a good idea to allow any string as the version.
Is this reload really necessary?
Why isn't this protected like in the master patch?
you return Mockito.mock(SlackUtil.class) if there isn't any customization going on
Wouldn't we want to call s.beginTransaction() inside the try-block and then add a catch-block to determine if a transaction is active and rollback?
Subscribing to METHOD is only introducing confusion, and cause problem with the rule. Subscribing to METHOD_INVOCATION should be enough. When hitting a method invocation, you can then look into the map if something exist for that symbol. If it's not the case, retrieve the parameters names and add a new entry on the map. Then you check for parameter names.
We know it is Host. please use proper type.
I'm missing the new field in the toString method.
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
ArrayList should be constructed with fixed capacity.
Any shot of breaking this up a bit so that someone can understand what we're looking for?
Is there a reason for not using the MoreObjects.ToStringHelper instead?
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Isn't it possible to extends this one instead of creating a new constructor?
missed to implement
This can be replaced with  java return newName.isEmpty();
try ... catch with resources would be cleaner
Can you make it synchronized?
suggestion .parse(StringUtils.isBlank(metadataLanguage) ? metadataLanguage : "en");
Remove log statement. Let's consolidate logging into fewer (more complete log statements).
use a constant
Will the volumeId not be set in the constructor from parameters?
I think we should remove a pair of parens:  mSession = new Session.Builder(this, mApiKey, mSessionId).build();
Make this method static - it doesn't access any object state.
Too broad a catch. IndexOutOfBoundsException should be enough.
judgment.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgment.getJudges()
suggestion super(() -> name);
FileNotFoundException is a subclass of IOException
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
wha would it take to implement this for JPA? bit uncomfortable to have new methods only for particular type ...
It seems compareAccountMetadata method does an exhaustive check periodically. Any specific reason to do a sampling check?
i think this might need to encdoe the name and bitmap type too.
This must be supported.
I advise inflating the ExpandableListView from a layout so you can apply the styling there, instead of hard-coding style values into the setListAppearance method. Then, you could get rid of the Utils.getPixelFromDips() function too.
When using a byte[] buffer, I believe we need to capture the returned byte count because it will likely be less than the full array on the last read. As in: int byteCount = 0; while ((byteCount = in.read(byteArray)) != -1) { out.write(byteArray, 0, byteCount); }
static is missing
Static import the assertion methods
Could get rid of lines 439-441 and make this map.put(contig, ++val);
Should we be reusing the walk we've already setup? Why create a new pool of revision objects when we can just reuse the one we already have? On the other hand, a walker could dispose of object bodies, and a reset and reuse might confuse the caller because the bodies are gone. That's actually a bug in RevWalk that we should probably address and fix there rather than forcing an entire new pool to be created for a second invocation. Likewise, RevWalk discards the starting commits when it resets. We probably should allow those to be retained somehow, so the same walk can be executed again without needing to maintain our own copy of the starting points (RevWalk calls them "roots" inside of itself.) Finally, RevWalk's implementation of Iterable is probably wrong. It only works once. Creating a 2nd Iterator fails. So we probably should fix RevWalk first so its iterator() method resets the walk and starts it over again.
Throw the proper exception if something is not supported: - NullPointerException if status == null or command == null. - IllegalArgumentException if frameID < 0 or if frameID > 255.
Same as above for otherNonCodedConceptUuid
we need to reset this property in a @Before block
java case "trackingOff": default: return TRACKING_OFF;
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
MemStore is used for tests, so we need to implement this function.
add this selector to UI mapping at the beginning
You don't need to call .getValue() here, since the method neither does anything with the value, nor does it return it. You can invoke the API and leave it at that.
Shouldn't options be Immutable?
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
How would you feel about using more descriptive column names? For example, day(shipdate) as ship_day and month(shipdate) as ship_month? These 2 will give you values within TINYINT range and will have meaningful names that are easy to understand.
I would separate the message that should be logged as info from the exception that should be logged as debug as we don't want to pollute the log with a stacktrace at all times.
hope you know the diff between ceilingKey() and higherKey() and you are using higherKey intentionally
Inconsistent Upper and Lower case in description
Now the commit action is not enabled when I select a non-project resource. The method getRepositories does only work for projects.
This should not be registered on an HC.
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
You can use is = InventoryUtil.itemOrEmpty(is)
are spaces OK in namespace strings?
Missing StringUtils.isNotNullOrEmpty() check
I believe we should use ThreadPoolExecutor#shutdownNow() to stop all actively executing tasks and the waiting tasks as well.
Maybe wrap in an immutable map.
Why not make implement Closeable rather than this private close?
+ desc
You may be able to use something like org.eclipse.tycho.p2.tools.impl.Activator.createProvisioningAgent(tmpDir).getService(IMetadataRepositoryManager.SERVICE_NAME).loadRepository(repository, new NullProgressMonitor()).getReferences() to check whether repository references are properly added.
{ }
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
nit, Collections.EMPTY_MAP?
nit: orElse("null") is clearer.
This will throw redundancy warnings in IntelliJ
suggestion this.licenseKey = licenseKey;
Please change the line 38 to also use EnumMap<> for consistency.
Same here with Throwable.
Must be with this. Also how about addAdvices(Advice... advices) ?
please reuse the constant
see below re: spaces
@dmzaytsev ThreadInfo can read currentThread in Ctor, no need to pass static
Mike spotted you're changing the formatting of private keys from "Utils.HEX.encode(getPrivKey().toByteArray())" to "getPrivKey().toString(16)". What's the reason? On StackExchange I read .toString(16) is stripping leading zeros. I'd personally prefer to at least keep bytes intact.
please import java.util instead of explicitly writing here
Simple for-each?
Would be better to move this resolution to the afterPropertiesSet() if we can't inject an errorChannel from the @Configuration level.
also use a map here (this is likely to be extended I guess)
One minor suggestion. Make this a private final variable, and create the runnable once. Then return the variable instead. The outcome is the same, with the advantage of not creating an object every tick.
Missing final
This produces a warning because new GenericType(...) is never null. Which is actually the symptom of a bug: token.getComponentType() can be null, this must be handled. I'm fixing it directly.
should probably be named m
how can a clusterName be null?
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
Don't forget to update this
No, need for close here as you use try-with-resource?
please move list initialization to where it is used.
Is it possible to get rid of this?
we can actually print the unexpected key type here
nit: public abstract void
Same here regarding the messages.
Either call getComputedValue(buffer, ...) here or remove the second signature of getComputedValue since I don't see it used anywhere.
Absolute or just path?
Can we compute this lazily only once hashCode is called, then cache it in an instance field?
Replace method body by return any(input.getRefines(), instanceOf(MultiplicityElementChange.class)); and add the static import of Iterables.any
I'm not a reviewer but FYI  CredentialModel.PASSWORD.equals(credentialType) in that order can't throw a null pointer exception, usually always the constants first because equals accept "null" but null don't have equals function.
local variable e is never used.
Doesn't this mean you'll have a single reporter for the whole life of the worker (and a single reporter means a single task I think?) I thought it had been talked about having a new task every hour or similar?
This is bytecode equivalent to using the for-each syntax on an array.
There is no need for creating a new storageManager instance; getStorageManager() returns an instance valid for all the synchronization process.
could we just initialize targetgroups = new HashSet<>() at the top of the file?
Don't rely on the JRE platform encoding here. Use a specific encoding, like Constants.encodeASCII(). This also applies to the other getBytes calls below.
Aren't there any test methods that require compatibility?
lowercase for package names.
Why not just replace Platform with Job? Same below.
please leave it that way - it's intentionally referencing the deprecated version.
"This method is not actually very useful and will likely be deprecated in the future."
Missing generics
Please throw NullPointerException instead (also, use braces for the if statement)
Could be a try-with-resources.
If we are going to loop over these, no need to make it another variable. Doing it this way will end up setting an extra variable that will be unused. Can add the list instead as another getter and loop over it in the template functions to avoid duplication/unused vars
Should this equalsIgnoreCase() be changed to equals() as well?
@lmontrieux Wow... Strange. I think in this manner you need to add addional {} to log message.
I don't see why is isConnectionSetup() necessary. Shared in SharedPubSubWebSocket client means it is shareable and must support concurrency. It should be the responsibility of SharedPubSubWebSocket to ensure that its state is properly managed and if setup() can't be called concurrently, enforce it.
We should configure the layer name here and not in the factory. See org.eclipse.sirius.diagram.description.impl.DescriptionFactoryImpl.createLayer()
deserialize can return null.
Quelques lignes plus bas: User mockedUser = mock(User.class); when(mockedUser.getEmail()).thenReturn(email); when(mockedUser.getPassword()).thenReturn(password);
Is the sort field used at all? I see it being set but don't see it used anywhere.
UOE instead of ISE (x3)
Is this an error condition or just timing? When will it happen?
This & the other switch removals should be reverted, performance tests show that this isn't any more efficient. The change also increases memory usage, making this a net negative change.
Make private Disposable disposable = null and add a null check here, just to be sure.
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
Could you make this package protected? We are not exposing JSONs anywhere in the SDK
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Is this used? If not, make private.
in here I think default filter is an attribute of the filter itself. You should continue using just _loadSavedFilters_ and that would set the default filter automatically.
Once 'httpAuthenticationFactorySupplier' is final, you know you've validated it in the constructor and you don't have to do it here. And that means the try/catch can be removed.
Would be nice to have something here to check for duplicate schema names. I don't think the base Calcite class does.
@jomarko Are you sure about removing that line? I remember times ago I put it there for some reason, not sure if it is still needed; anyway, the point at that time was that if ScenarioGridCell.editingMode is "true", the editing does not start. When you press "enter" or anyway end editing, the "flush" method gets invoked, and after that the cell must be editable again.
extract private method boolean waitForOperator(Operator operator, Duration timeout):  try { operator.isBlocked().get(timeout.toMillis(), TimeUnit.MILLISECONDS); return true; } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException("interrupted", e); } catch (ExecutionException e) { throw new RuntimeException(e.getCause()); } catch (TimeoutException expected) { return false; }  and build assertions around this method
I think the following would also fix the leak and will not call the removeAction twice in any code path java @Override public void addDestroyAction(UUID registrationId, Callable<Boolean> removeAction) { synchronized (removeListenerActions) { if (destroyed) { callRemoveAction(removeAction); } else { removeListenerActions.put(registrationId, removeAction); } } }
redundant this qualifier
Why not use Binary.copy?
I don't think the process deploy should fail in the case of temp file deletion fail
Please use @BeforeMethod(alwaysRun = true) insted of init() inside of test body
space before trailing {
more than 120.
Need to remove codec from here too, right?
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
you don't need the variable. you can inline
I think that CSSDOMSemanticElemntHelper should be an Singleton.
Unsure this addition is useful.
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
this triggers a findbugs error since it blindly casts and assumes non-null
FYI All instances of HardSoftLongScore.ofHard(1L) may be replaced by HardSoftLongScore.ONE_HARD,
Why do we need to first slice and then also duplicate ?
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified label, and he selects "yes" on this option?
does this need to catch all exceptions?
This line appears to be obsolete ?
Optional: this could be done without the index variable: for (int i = 0; i < emailPick.getItemCount(); i++) { if (value.equalsIgnoreCase(emailPick.getValue(i))) { return i; } } return -1
use the interface here
I don't think the logic is necessary. We can have the default visibility as GONE.
Please bring the braces back.
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
Another place where we could note that the boolean is unused.
This does not verify the order. (The iteration order over expectedMap is undefined).
Shall we move this to a common method.
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
wouldn't it be cool if it uses itself getMembers(Predicate) here?
We can use the createResponseEntity() helper method like you did below.
We can't do this - breaking change for anyone that has subclassed and implemented destroy(). I suggest we use // NOSONAR TODO: remove throws in 5.2, which removing it from our subclasses.
Technically we could return value at the end sich we return null if it is null. (i.e. you don't need to keep the compiler happy)  if (value == null) { env.flop(String.format("%s within %d ms", errorMsg, timeoutMillis)); } return value;
why changing it to static?
Shouldn't this be wrapped in a try... finally block?
Locale.getDefault().getDisplayVariant() works for me but getScript() returns an empty string.
How about remove the property, rather than set it.
can we use sysprop or something for url?
if an empty set of permissions was passed in does this work as expected? (permissionsDisplayName would be an empty string) - so would the error message be correct?
I think this will still not do what we need. :( MaterialUrl does not remove the password. HgUrlArgument does. It needs to be used in combination.
Is this change related to supporting commit validation by plugins?
The message is missing.
In order to simplify the code and as we are doing this for start and create we could add a method hasProcessDefinitionIdOrKey directly in ProcessInstanceBuilder so that your condition becomes: if(processInstanceBuilder.hasProcessDefinitionIdOrKey()) What do you think?
Size + speed - size = speed
You might want to use the more ugly path.toUri().toString() because the path.toString() tends to drop the scheme.
@ekondrashev Too much indentation for lines 61-64, move them back four spaces.
you might want to make 10_000_000 a constant
What happens with an empty string as a value?
Usually for this it's reasonable to have a hasMessageContaining(...) to make sure the exception is what you want it to be.
nit: you can merge both lines above as checkNotNull will return the given argument
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
Can you make all of the accessors final?
You don't need this null-check, the getJavaElement method already does that.
This error message is kind of confusing. Perhaps replace it with, "Error in accessing DB.".
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i = ...; if (i == -1) { return false; } mRoutes.remove(i); return true;
~~The tests are not covering the bug that you fixed. I can change back this line and your tests still pass successfully~~ nvm, i realised my mistake.
Probably we should log the exception here (debug or trace), just to help with troubleshooting
dont do this but let the exception be propagated back up so we can have a better error reporting about not possible to generate jacoco report due to .... Also these methods can be static methods
This has nothing to do here. You're invoking blocking code during plugin activation and wasting this instance
I think Oleg meant that this code only takes into account AbstractProjects, it doesn't take into account, for example, FreeStyleProjects.
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
this _could_ be shortened to Optional.ofNullable(jmxServer).map(JMXServer::getPort);
I think curly braces are missing and the formatting is wrong in the subsequent if (one step too indented)?
We shouldn't use class names in JSON serialization. These are serialized permanently in the file metastore and thus can't rely on current implementation details like the Java class name. It's probably also a security hole. Anytime you see a remote exploit for Java and wonder how that could possibly happen, it's some deserialization feature involving class names. Since we only have a small, fixed set of classes, using @JsonSubTypes with logical type names should work.
- new String(byte[]) without specifying a charset is dangerous. Although the default charset is supposed to be UTF-8 on Android, I would feel more comfortable specifying the charset explicitly. - JSONTokener is superfluous as JSONObject can construct itself from a String.
Would be better to move this resolution to the afterPropertiesSet() if we can't inject an errorChannel from the @Configuration level.
Why absent?
suggestion
Isn't errPct already a percentage? No need to multiply by 100?
it looks like you have to adjust this one to your recent changes -> see pr build on travis.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
Why not check the flag directly on symbol then ?
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
this.
Please remove the maverick ";"
I prefer flatMap for this. It sucks they left out Optional.stream() in Java 8 java return FACTORIES.stream() .flatMap(factory -> JdbiStreams.toStream( factory.build(expectedType, value, config))) .findFirst();
same here - result should be null
edit? We already have public <T> T configure(Callable<T> body), did not noticed when this sneaked in... Anyway, if you need different signature please stick with the name configure.
How about just context since we have it?
The @SuppressWarnings can be avoided via: suggestion return convert(sourceType.cast(source));
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
This method was meant to stay internal. I know that from the perspective as the author of this class. It's re-used as part of other computations, it is not intended to be used by the UI.
Switch the order of getting the mean and filtering:  java segments.stream().mapToDouble(ACNVModeledSegment::getSegmentMeanInCRSpace) .filter(x -> Math.abs(x - 1) < 0.1)
Check for null
You can use e.ordinal() instead of e.value, and remove the value field.
Logging using standard output
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Do we need to limit this to .in/.win for Makefile as we did before?
Logging and throw is imho an anti-pattern since the caller will most likely log an exception that he catches.
You don't need a local variable el, you can just do return TransitionTest.this
Can replace with forEach.
Should this be protected, or do we really want to allow to call it outside this class?
Looks like these two typeTextIntoEditor commands can be united into the single command:  editor.typeTextIntoEditor("\n\nobject = MyClass()\nprint(object.");
use: import static org.hamcrest.CoreMatchers.instanceOf; ... assertNotNull(result); assertThat(result, instanceOf(ClassName.class));
Wouldn't have been possible to override the afterFromProto in the ForwardNatRule class, adding there any initialization code as needed?
Can just return this overloaded method's result rather than requesting the record twice.
The this. in getters are unnecessary too.
onLowMemory is public, not protected
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
Capitalize Thrift (or remove the word)
Use try-with-resources, to make the code more concise and to ensure that the reader is closed even if an exception is thrown.
ImmutableList.of
why public? Are we planning to use it outside of this class?
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
I think we should replace our new ArrayList<>(...) constructs with List.copyOf(...) especially when the list is immutable.
should this count be parameterized?
Would a constant Long.BYTES fit here?
List#isEmpty()
if (!(value instanceof Object[]))
There is already a string defined with the name dialog_action_ok
This should be moved below the LogContext.checkAccess().
I don't think we should call abortWorkItem here as the work item most likely won't be there as it failed to execute.
suggestion return Optional.of("org.junit.platform");
This changes logic paths for SSLD devices as well. Some time ago an UnregisteredDeviceException was thrown when a device was not _activated_. The change in behavior to throw an InactiveDeviceException in such cases has been discussed with @kevinsmeets. Now with the check on whether a device is _active_ the logic for throwing any exception does not take _activated_ into account. Updating and keeping a proper value (and meaning) for all these status fields (here isActive and isActivated) has to be clear (and tested) across all domains.
should this say throws PatternSyntaxException ?
extract as constant?
All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);
about this API... for Cedric's VM, I just had to implement something that may change some style value for specific events. I'd like to just be able to update one style value, but the returned style map is read-only and for just cause! You could add a method Map<String, Object> getSpecificEventStyle(event) that would return only the difference and this method would merge the 2 maps if not empty. This one can be final.
Could be protected instead (and it could be defined before the nested class).
ContainerUtil#getFirstItem
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
I don't know what has been @sjka intentions and I agree that this could be removed... ... but didn't we have a discussion in another topic where you / Kai argued that we cannot rely on correct usage WRT to the nullness annotations for code that is called by third party ones (e.g. binding developers etc.)? So, if we don't trust non ESH framework developers that he uses annotations classes correctly, isn't that exactly what you want?
Please verify the returned can-do-action message is VdcBllMessages.GLUSTER_TASKS_NOT_SUPPORTED_FOR_CLUSTER_LEVEL
Just for consistency, please use final boolean actual
my sense of beauty tells me that this code should look like the following:  guard(); try { verifyReadOnlyModeSupport(); ctx.state().changeGlobalState(readOnly).get(); } ...  Perhaps, verifyReadOnlyModeSupport should be a part of ctx.state().changeGlobalState(readOnly) method, I am not sure here.
What's up with this last one? Should it be in the finally block?
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Does this method need to be synchronized?
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
You're conflicting with #631 :-O Shall I go pull some PR's?
suggestion return !root.getParameters().isEmpty();
I would prefer to use String.valueOf(value)
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
Why do we need those lines? Unit tests are still green if I remove them.
I found this code called so many times during app execution. What are your thoughts about using a pre-compiled regexp to split the strings? private static Pattern languageSplitter = Pattern.compile("_"); and then use it with String[] opts = languageSplitter.split(languageCode, 0); Do you think that this will improve performance?
This is not needed anymore... now you can just return id
Well, it'll work but, as I understand, it will hide an error if there is. I think the issue is in other place. Agree?
I agree hashCode() and equals() should be done same way, it should be changed for PackageMaterial as well
if service is not present it should throw error? same question to the other methods
Create your own session to make the property to be true.
I believe the conditional above will need braces otherwise this is considered outside of the block and will always execute, which may not have been your intent due to the indentation. If you did want it to always execute, you should update the indentation to reflect that.
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, NON_CANCELLING, EMPTY_VALUE);
should probably test for null delimiter and either ignore or preferably interpret null as "no delimiter" (the empty String)
nit: consider testing st_centroid on a non-polygon shape ditto other methods which apply to a restricted set of shape types
you can refactor this in a different patch to make less noise
I don't see the point of having a cancel action in a subtab.
we should log a warning here so that users who have wrong permissions on ~/.gitconfig by mistake have a chance to detect the problem
Shouldn't this be !=?
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
I'd have thought "Case Management" was more akin to PROCESS than MODEL
Should be originalContent.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
This will throw redundancy warnings in IntelliJ
Consider using i18n for this title.
null case should never happen, since a chapter indicator must be there, please remove this.
ObjectMapper is fully thread safe, we can have it as a single static variable inside this transformer class (also because we do not configure it differently per method usage)
Pass the FeedbackQuestionAttributes inside the UI template class and use.  feedbackQuestion.getQuestionDetails().getQuestionSpecificEditFormHtml(qnNumber);  > ---- Polymorphism :D
We should either make sure that we use registerSticky() to receive the last posted status during initialization (and also ensure that the initial state is always posted during app initialization), or we should call this explicitly from onViewCreated() or some other callback for Fragment initialization.
Well, what happen then if user still use the deprecated method? we need to be backward compatible, right?
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Don't call row.getDimension(dimension) twice. Please extract a small class, don't inline. It's unreadable.
For consistency, this should come from the Builder
Please remove printing to stdout
use static import.
Use StringUtils.isNotEmpty instead
this can be replaced by getGroups().forEach(group -> cache.flushGroup(group));
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
this should be private static function.
Why is this returning null?
This class seems to have too many responsibilities in it. It looks like that in addition to it being a model, it also has knowledge about how it should be displayed in the generated code. Split these two responsibilities out.
I'm pretty sure BasePanel also has already the dialogServie object
Get the service registration reference and unregister within the deactivate method
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
This line could merge with the next line, making the next line return new UID(requireNonNull(v));
declare throws please
I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.
You can remove this since hasNext will call checkInvariants
warn maybe? and not sure if we want the exception. maybe just the message?
can we avoid passing null here? and introduce constant like IndexOrder.NONE for that instead?
no need to change at here, because it is only for Date type
does this need to be calculated on the fly each time or can we save the iterable?
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
IMHO, for things like variable naming, local consistency is arguably more important than global consistency, so naming this e is best. If we make a global change, I would prefer to rename variables of type Throwable to e
Why is there a fromByteArray method? Why not call the constructor directly?
What does the above line mean?
... two non-equal objects can have the same hashCode! :(
I'd guess that findbugs (the reason for the build breakage) is complaining about the unsynchronized access to diskLruCache here.
We'll probably need to move this return out of the catch-block if we're going ahead with this. I'm guessing currently we get an NPE that blows up, so the change makes sense in general.
Not sure if this is supposed to be a Long instead of long?
Why should we need this logic? The logic, including the null check and duplicate check have implemented in org.apache.dubbo.config.context.ConfigManager#setApplication. Why should be added it again? So as the other change in this file.
What do you think about keeping "<LINK_0>" in class variable also?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA()));
can be inlined
please leave it that way - it's intentionally referencing the deprecated version.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Forgot to set set concept on this order
You may use FileUtils.contentEquals instead.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Why there are things that are irrelevant to this PR? Although we need sanitise field here.
Seems this can be simplified to just call super.clusterConfig and then invoke jmxStatistics.enable().
Can we stick to just probes? So name it scheduleProbes?
Shouldn't we add the Transmit options field here?
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
could shorten this to  java return numInFlight < parallelism && replicaIterator.hasNext()
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
Should this return getDefault(); instead, so have the default specified in fewer places?
This could all be replaced by java return ExtensionList.lookupSingleton(OldDataMonitor.class);
nit: I'd make a constant for foo-test-invalid.json too
Isn't this a bit dangerous? If we're in a network without dns "Unknown" will be all over the place?
Why is this check necessary?
suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task));
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
I think the underlying registry/restClient will return SchemaRegistryClientException instead of SchemaNotFoundException in this case.
maybe just call this.addUpdateTask(operation, key, "") and remove the overload in BoxMetadataUpdateTask
It's better to introduce Pull.STATE_OPEN and Pull.STATE_CLOSED and use them
Should be "InstaPost" actually.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
Shouldn't these methods be on the ResourceCollection?
suggestion blobSoftRef = (BlobSoftRef) field.get(accessPath.apply(descriptor.getReferenceInstance()));
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
This should be synchronized for reliablity as there is no AtomicReference.
using Arrays.asList create a fixed sized list, so doing later getTo().add(something) will throw an exception.
It is the same in this line, leave a blanck space before "+"
Extra space after synchronized.
The same Arrays.stream() can be applied here as well.
Wrong event name and bi value is getting passed here. It should be **VIDEOS_UNIT_DELETE**
Why wasn't this left as-is? I'm fine with it, but it just didn't follow the pattern of the rest of the PR.
Please update this string to say "developer mode" instead of "debug build".
this method is useless. Can you send a patch to remove it so all the code that needs uuid will simply use UUID class?
Is this ever actually reached? It seems to me we only have a lambda declarator associated with CPPImplicitFunctions, and CPPImplicitFunction overrides isConstexpr().
This will throw redundancy warnings in IntelliJ
Minor thing: please use "something <operator> null" convention.
I think in this case is best ignore sonarCloud. Not sure who's reponsible for the sonarCloud rules, but in this case I'd just ignore.
please decrease or remove this statement
This should make a defensive copy of the list.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
Should be externalized.
please remove or decrease log level to TRACE
> It's a 32 bit signed integer, so any value of retries exceeding 31 will cause the value to overflow. Yeah you're right on-I was raising a question around the implementation of the back-off in general. (EDIT to add quote)
For DTLSConnector this is configurable. I do not know whether you have given configuration of the TLS connector much thought yet ...
Might be worth having a displayName?
I think this can be set by spring application.properties without creating bean explictly.
I guess this will overflow maximum instructions per method before FIELDS_PER_CLASS is reached? Again, I wonder if it would be good to generate multiple companion classes.
looks like you don't need these three variables at all. Just use this at line 41?  java List<String> boardNames = TestController.getUI().getPanelControl().getAllBoardNames();  You can probably follow it up with this (not sure)  java assertEquals(boardNames, Arrays.asList(new String[]{SAMPLE_BOARD})
Should also include context and suspend
Should use the log, maybe a warning.
I believe the Sanitizer call is not needed here.
We may need to put this behind the flag, especially if we want to back-port it to older GCS connector versions. We can enable it by default in master branch though.
How this else block is possible?
why is the first parameter a LayerCommand if we only need the resulting Layer?
Position position position.position. Hmm maybe there's a better name for some of these :thinking: Just thinking aloud, not the end of the world :+1:
better to set it to the default and log a warning
why callback is null
Unnecessary, booleans default to false.
Minor inconsistency: Return type is Boolean and not primitive boolean
This fails for me, I get 25 visible rows. I don't think you can be sure how many rows and columns are visible, we only set a fixed size for the Shell. Then how many cells fit depends on the OS and graphical toolkit (probably due to different system font sizes). So we also have to be careful that whatever cell we interact with is always within visible bounds. For example in this file we use up to row 14, we don't know exactly how many rows are visible but it has to be at least 14...
here originally TASK_ID was being passed, now null
nit: public static void But public here is irrelevant. Its only as visible as the inner class, which is package access. You can skip the public keyword.
I'd like to see our Throwables.throwingOnlyUnchecked used here
what about putting this in the default: case of the switch (switches without default, you know...)
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
I haven't investigated what exactly this does, but it looks a bit weird. I can understand if by default the logging level should not be DEBUG or so, but I would definitely like to see errors and probably also warnings by default (i.e. without having to investigate how to change this manually). Please disregard if I missed something.
We can replace this with: return date.getTime() / TimeUnit.DAYS.toMillis(1);
It worth to check which mocks were executed. Use when(modelMapper).should()....
Sort of believe We should have MetricManager in parameter given this case.
add a message in case it ever fails
> "When providing an 'async-rest-template'... Correct? To properly reflect the reality.
public void fireEvent(GwtEvent<?> event) seems a bit redundant now. Is there a web bindery replacement for HasHandlers?
I don't think this is correct for nested object structures. Suppose we have the following class structure:  java public class Person { private String name; private Address address; } public class Address { private String city; private String zip; }  Translating this to JavaScript/JSON should look like this if both, Person and Address use the JsonToStringStyle for their equals method:  JavaScript { "name": "Peter", "address": { "city": "New York", "zip": "10026" } }  If we apply this fix, the result will look like this:  JavaScript { "name": "Peter", "address": "{ "city": "New York", "zip": "10026" }" }  Note the additional double quotes around the address object.
You can make this a bit cleaner by calling data.isData() and data.isHole().
similar as for migration service ... throw the not found exception from within the service
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
can this be readSafely instead of readBuffer so that read uses readSafely
Missing final
Better to create a new set, rather than update the super set. The super set might (and should, I think) be immutable.
Can be static.
Unfortunately that will not work in the BATCH mode we will introduce shortly. In BATCH mode the currentMainOutput will ignore all watermarks. At the same time we should still emit MAX_WATERMARK in the BATCH mode.
Since we never try to recover from the error later on it would be best to let exceptions be thrown from the init(). That way the ActionHandler is not available for use by the frontend and we don't need to check if the services are initialized correctly for every request on preProcess().
Is there any other ID we have in relation to an envelope? Why do we need a longer name in this context?
Indeed, that is better than my suggestion. Let's do this.
Gson doesn't run on these versions so I don't see any reason to include them.
Bad variable name! Variable names should be clear enough. Rename it.
That 3rd one is a weird condition: I cannot add an attribute "0" (the tid) as a subattribute of "0" (the cpu) it throws this exception. Since the asserts did do nothing, I never noticed before.
Hey @mjsax . Sorry, but I didn't follow this change. How does this test pass when it expects the value to be 7, but it's now 3?
If the store is already started, I think we should return true. Same for stop (return true if the store is already stopped and don't try to stop again)
these should be 2 separate tests
@manstis I don't understand the Range details, just suspicious to me why we do not return result of selectHeaderMerged.
Is that down-cast required?
This should be obtained from the i18n file in case there is a language specific reference. The solution should actually provide some guidance, this CS could be added to the references.
ConnectivityManager should not be modified on this issue, please merge with <LINK_0> branch again that has this changes and resolve conflicts
vus always has lastEdit?
I think what we want to use here is base64url without padding (defined in RFC 4648). General base64 uses / character. = in base64 is padding which is OK to remove. You can build this variant of Base64 using Guava: java import com.google.common.io.BaseEncoding; BaseEncoding.base64Url().omitPadding().encode(projectName.getBytes(UTF_8));
This should be synchronized
does eventTypeService.get throw other exceptions?
Would it be helpful for debugging purpose to log out a statement when this method is called. This way, we can easily tell from the log.
suggestion bean.setSourceList(new ArrayList<>());
The onInsertRow*(..) methods differ only in the index on the last line.. Might be better to extract the common code.
You can call this.setTimestamp(timestamp) from here.
remove when the export button is implemented
No need for super()
java "MetadataImpl{name='" + name + "'}";  would be simpler
remove !
Not sure this is right unless it's only supposed to work on *nix.
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
I don't see any problem with prohibiting x-site backup to/from a LOCAL cache, but I'm not that familiar with x-site configuration and I don't know if it's possible to do that validation.
What do you think of adding some errorMsg in the page if a user without ADMIN permission tries to access this page?
And ATMOS ?
pls format (>120 chars)
Looks like this toString() got generated before the tags field was added :P
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
.event() is might be better
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
Could use java.lang.Character.MAX_RADIX
suggestion
The aforementioned "never return null" rule would be good for all the string getters here.
@Before / @After could overwrite System.out :-P
id is only used once; simplify to just return <expr> "" + x is more concise than Long.toString(x)
The this. in getters are unnecessary too.
duplicate logic in getPrivateKeyAlias method().
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
You don't really need to return this;. It doesn't really make sense for any verification method to have a return value. P.S I know the others have, and I'm quite itching to fix them :p
String can be externalized.
No need of this. Its marked as @NotNull.
IntelliJ says the type parameters are not needed
Please, express if it is permanent or random in error message:  Known permanent failure <LINK_1>
please use Assertion class
Uhhh I think this uses the local default filesystem to resolve that filename, which isn't necessarily what you want.
Won't fix.
don't return null, return an error page
Worth including an entitlements check, because the return values could contain passwords retrieved from brooklyn.properties. For example, something like:  if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) { throw WebResourceUtils.unauthorized("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user()); }
MessageQueue.RegisterBankAccount_EventMessage
From @blickly I think this should be Fingerprint2
should we close the connection before throwing the exception or connection close is going to be handled some place else?
Am explanation would be nice
Use UTF-8 Charset here and the getBytes(Charset) implementation (it doesn't throw an exception). This use depends on the default system encoder and if it were to change it'll be trouble.
should this filter out null resources? (ie. bad paths)
What about testing with ALTER FUNCTION sin ... instead?
Minor: Maybe remove the type bound if it's not used?
The error message doesn't match the actual behaviour.
just minor thing, but all these methods are duplicating code... probably you can create a common function that takes the shape and a Function<Bounds, Double> and does the different null checks etc, and then the methods xOfShape, yOfShape etc would be refactored by using as a second argument the function (bounds) -> bounds.getX(), and so on...
So, would the PII information be provided as plain text? If so, isn't that a security concern?
Same here, better in the constant class.
suggestion return Objects.equals(caseRoles, other.caseRoles) && Objects.equals(caseFileVariables, other.caseFileVariables);
I would prefer to avoid any dependency from UriComponentsBuilder on UrlPathHelper. The latter is more of a Servlet API specific component while the former is more general. Even if the re-use in this case doesn't touch on anything Servlet specific, it seems very minor and not worth the gain.
You should determine if you need a regression model in the scheduler
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
This branch is not needed
Tag @leeyimin here, I'm not too familiar with sanitization so I'm not sure if this is okay.
nit: suggestion log.error("User [%s] had role [%s], but role object was not found.", user.getName(), roleName);
How about: "Cannot estimate the memory requirements of a devfile-based workspace {}. The memory limits may not be applied correctly."
nit: put {} around if statement.
You can also use IO.close(bb) as IO.close will not throw any exception.
"0"?
In accordance with similar changes maybe better to use Optional?
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
I would change this to if(url == null) { return null; } less indentation, code looks a lot cleaner
Do we want to make the change inside mkAssignments(String scratchTopoId) so we can count errors during the rebalance command as well?
These should refer to constants rather than the string literals.
We can give some more time, like 30 seconds.
Why not just use fixture?
We need to throw a BriefcaseException here. Returning null doesn't make sense in a ValueObject
isRemote(command.getKey()) instead of false
Should be "InstaPost" actually.
I think this could be a lambda (if you're editing it anyway).
Can we get the root class as a generic parameter of the aggregate class or, more straightforward, the repository class? If we can, we won't need to accept it as a constructor parameter.
Why you are using diffrent methods here? 1 . new Date(onsetDate.getTime()) 2. (Date) endDate.clone() Better to keep the consistency among the code, and provide your feedback why did you select that among others.
This is a private class used for tracking, won't change super fields, time is the only changing variable here, so only need to hash time here.
Continuation of the comme?t on line #242 - Please notice 'messageLabel' and 'externalLabel' doesn't have representation in the model. The fields you're manipulating in 'onPhysicalNetworkChange()' do have, so please move this logic to the model.
should we log a warn in an else block here saying that the task failed to describe the table? It's hard to follow "absence of logs" when these connectors are typically running against a large number of tables.
Why it's "EXTERNALVIEW"?
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
remove local variable
could you provide a test for option(null) also, I'm not sure how that should behave differently from some (I guess it should represent a none intuitively)
I'd add a guard to prevent surprises if (db.isBare()) { return null; }
No use checking if the list contains() before remove(), let's avoid double iterations.
This is not necessary. It is done in the RestResourceController, indeed the value here retrieved is not returned
revert this
Since this is a String, perhaps you could use Collections.nCopies
remove this extra line
@fanifieiev the same above.
no reason to explicitly set to null, its default behavior
Probably this should return 0 when doubles[index] == null && NullHandling.replaceWithDefault() == true? Otherwise it probably should throw an exception.
Can you reduce the nesting depth here?
Maybe pull this into a static method that pgm.Archive can invoke without having a BundleContext. Then we don't need to maintain this list in two places.
code format
Agree with you. We will probably test this on different level.
I think it is unnecessary to use synchronized here
Same here. Simple call to filter() is more readable
You don't need to change this method signature. I would leave this method private
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
I would change is back to 50 for consistency with CDT.
nit, Collections.EMPTY_MAP?
I think its safe to inline this var
would it be better to use isNotBlank here?
100 seconds is 1 order of magnitude more. It seems a lot. Would doubling to 20s be enough? Or could we instead use org.jboss.as.test.shared.TimeoutUtil#adjust to adjust the time of this test?
static
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
Please use Java's local variable type-inference var where possible
I think these will crash if there isn't an app successfully seated yet. Usually good to wrap these reporting helpers in a try/catch so that we guarantee we get the report
this two things are special afair cc @lanwen
40?
Why doesn't the following method fit this test suite?  public static TestCommandFactory newInstance(Class<?> testClass)
This can now be deleted.
add this (also below)
I suggest dropping the "final". It is not required and I personally dislike this style. Unnecessary code should be avoided.
Please chain the method calls: java return new URIBuilder(BASIC_SEARCH_URL)) .addParameter("query", query) .addParameter("sort", "score") .build() .toURL();
I believe this is the cause of your failures as you are setting up a Java17 project which will be called TestSetup17project or something like that.
analysisMetadata.setOrganizationsEnabled is already called on line 117 and it really does not belong to a method called toOrganization which really should be static
Maybe use an uppercase in the text: 'Thread sleep was interrupted'.
I see 3 proposals: A) Leave as is (bad idea, fromUniquePair(..., Joiners.filtering(...)) doesn't work for CS-D and CS-B) B) Put lessThan() before filtering() - Is it a regression for Bavet? does this break any of the existing Bavet working examples? C) Like B), but add Bavet syntactic sugar to support filtering() to avoid any regressions of B.
Why do we return the parents name instead of the name we store a few lines above?
Now that you've implemented the reporting functionality, this log statement can be removed.
Hmmm. You sure you want UNKNOWN here? IIRC, UNKNOWN is what should be there if the job has been deployed but the agent has yet to act on it. Though it may be that by the time verifyHealthy is called that if the agent hasn't acted, it's probably time to call things off.
you should also check that log contains GIT_COMMIT is
why is this return null??
just one more thing. Can we add a metric here to track this issue?
WTF is lala
Should remove, and use similar functionality in CoreAuthenticationTestUtils
I think we have some constraints regarding the target URI? (e.g., exactly one? at most one?)
Make secrets an immutable list if present.
There seems to be an output change here: original: Base32.encode("a".getBytes()) => "ME" new: Base32.encode("a".getBytes()) => "ME======" We might need omitPadding() to ensure this is an exact drop in replacement.
This should always be read from the configs.
on failure we should try and delete the disk we added, see the current handling in the task handlers.
How about reverting negation?
These calls are very hard to understand. It can be more clear like this: return (Pair<StorageDomainStatic, Guid>) runVdsCommand( VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters( getVds().getId(), getStorageDomain().getId())) .getReturnValue();
That's weird. How will you fetch the conversion error from the outside?
This is redundant.
@vzool one more printStackTrace ?
would be helpful to record the date/time here as well.
There is no need to recheck equality if isExceptionIdentifierUsed is already true
Unnecessary call to super
this should go to super.reset(), shouldn't it?
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
Should be "InstaPost" actually.
Please remove the maverick ";"
Consider getting this value once, and save it, instead of calling it twice.
The link member should be removed and this line may be replaced with:  java return this.baseStyleGuideLink + this.name;
![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: java.io.IOException, java.util.concurrent.TimeoutException, org.osgp.adapter.protocol.dlms.exceptions.ProtocolAdapterException [![rule](<LINK_2>](<LINK_0>
Will this always be this value?
another log that can be removed (I know it's not part of your commit, but please do it anyway).
Should one of the following happen in case contentType passed is null? - throw an exception, or - set this.contentType = null
why 40 as a limit?
this does the same thing as createTransactionalBatch(). why do we need to have both as public? If createTransactionalBatch is the public method then this one should be package private.
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
You want to use FormField.getFirstValue() here and everywhere below.
You can change immplicit before and rever the change after waiting
I don't really like using null as a sentinel if we can avoid it (since it's nice to be able to use empty objects to avoid crashes around null references). And I don't think the server makes any guarantees about whether children is nil or just the empty list.
we don't need it here as it already called in super method.
Please use P.lazy(u -> f.f(a)
BbUserUnassigned is about a user, while we speak of a Project aggregate. So probably this is BbAssigneeRemoved.
suggestion ((WordPress) requireActivity().getApplication()).component().inject(this);  This getActivity() can be requireActivity().
I think the granularity should be 1 seconds instead of 5 seconds here.
"your _thing handler_" doesn't make sense then, right?
I fail to see the difference to the previous test. Is there any?
Shouldn't this be set to true as daemon threads do not prevent the JVM from exiting when the program finishes.
Perhaps we could avoid obtaining mBoundedWidth both here and in the next constructor by simply calling this(context, attrs, 0); here?
You can use mapToLong here and then sum()
The orchestrator will pass down a connected client (i.e. it will have a layout ready) when it creates a workflow, why is this needed?
+ desc
This and other setters don't have to be public, could be private.
This is not correct, orderGroup and sortWeight need to be copied too, this should stay unchanged instead you update Order.copy to copy over these fields too
click should not be in this method.
WDYT about wrapping the returned map into a special access updating wrapper? In that case we will avoid double iteration while sending results to the client, for instance.
this whole thing can be replaced with Stream.of( args ) .filter( StringUtils::isNotEmpty ) .toArray( String[]::new ) right?
Do we really need 10M ? Isn't 1MB or 500K enough for the sake of the test?
I thought this was to be debug to prevent unwanted data from appearing in the log.
this c'tor implies the entity is immutable. Please let have same assumption for SubjectEntity class and introduce a c'tor there which expect both entityType and entityId and use it here instead of the setters.
probably worth using a linkedlist here as well, although I doubt allocating 10 ints makes much difference though compared to other stuff we do
I know I'm being a bit petty, but reading this and taking a while to realize its a variable starting with capital letter triggered me a bit :D
Same as previous PR review: Sonar Lint should complain if you don't at least log the exception
Need to add @ConditionalOnEnabledEndpoint("filters").
This code to get the feature is used here and in the remove method. I'd suggest to create a new BackendClusterFeatureHelper class and put this code there. Then you can call it from these methos. Look at BackendDataCenterHelper for example.
thanks for renaming these vars to reflect _output_ stats :) looks like you missed one var here-- inputStats should be outputStats.
hmm, really not sure about a cache. The aspects are not necessarily "immutable" for a given event. Calling resolve at one point may not yield the same result as calling it later, so I don't think we should cache them. Every class that calls .resolve() could only call it once and "cache" its value though. About possibly merging the two methods: If we look at the use case here, for example the classes using a TmfCpuAspect, basically what they all do comes back to: "Go through all the aspects of this trace, find me a TmfCpuAspect that returns a valid non-null value, gimme this value". Couldn't we have one utility method that does just that? It could even be specific to a TmfCpuAspect (and derived classes) too!
Could you use hamcrest matchers please? Thx
This should be able to remove a membership that matches the patient, if there is multiple for the same patient then you can ignore it
return ?
How is this expression different from "this"?
Why don't instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
getActionType().getActionGroup() can be used (once it will have to correct action group:))
This is just completely broken. I think I meant to do if (filterConfig != null) in the first place.
code formatting is still inconsistent with rest of the code. This isn't the only line.
@komaz maybe for now we can just return empty iterable, there is no need to react so strongly about missing implementation.
The object passed as the last parameter of MethodRule.apply() needs to be the test instance, not the test class. The only way to get it is to have the caller pass in the test instance into the TestRuleAdapter constructor.
Can't we throw here something more meaningful? Where are you using this query? how does it feel in this case?
Maybe better to return null
?? why this and the following ones could be left empty?
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Do you hate static imports? :)
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
We should use the spring.application.name boot property instead of the applicationContext.getId.
I would say use a flag  @garrettjonesgoogle thoughts?
Now it's <code>@CheckForNull</code>
Similarly
"No provider is registered for the service '" + service.getName() + "'", service" (this is the current errore message). Shouldn't this thrown a ProvisioningException ?
Same here. Consider just propagating the current exception.
I would say use a flag  @garrettjonesgoogle thoughts?
typo in method name
We don't use the statisticsAwareService anymore.
since this happens before canDoAction, getVdsGroup() can be null
use getDiskVmElementDao(), please apply to all the dao calls in that class
throw exception
You're not making defensive copies of the Set, how do you know that it's immutable?
Shouldn't we specify the encoding here?
should this be public? It seems like an implementation detail of the config file format.
Should the context be passed in?
I think we should depend on the fact that this is an instance of EmptyByteBuf... just check it's not readable and release it
We need to have a backup plan here if type isn't a TypeVariable.
Reason should be optional.
only not null check?maybe it's better to check at least once a value with reachedStateDate != lastUpdateDate
Part of this method throws IllegalArgumentException and another part returns the error message. Please make all branches throw an exception.
As I see that in the other method, the parameter is also in the log. Consider adding pinDescription into the log?
we don't need to change the Creation classes.
I guess we will also need a matching input type strategy such that the validation can work properly.
Verify you can delete stale segments in the scenario of bug #16009
Could this method be implemented with return addToByteCount(super.read());
This should return a BitSet.
+ desc
nitpick: don't need keyword public
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
Change to unmodifiableSet if we switch to a set. suggestion return Collections.unmodifiableList(tags);
nit: For list with just one element, I think we could just make it in one line (unless it's too long..)
Why to return false in this case? I don't expect this to happen, but if the cfg is deleted (by deleting the refs/meta/config branch) then the default submit type applies which could be different than the submit type that was set in the old config. This is why I think it should rather return true here?
Redundant else.
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
When will the write mode be DIRECT_TO_TARGET_EXISTING_DIRECTORY after the change?
Not that it matters but it would be "sourceFile"
One more thing, if we consider the part between the [] to be the event name (that an eventual UST-JUL-TC parser could eventually even interpret as the event name (and same thing with fields, everything separated by '=' could be assigned to a fieldname+value)) then we should use a consistent naming pattern. UST events usually use names_with_underscores, but that's very C-ish. Since we're in Java, should we use CapitalziedCamelCase for event names?
Can you have an @After method that unbinds this connection. This is more reliable.
I am reading the class again again and I think we do not need sourceColumnIndex to be class variable. I think we can keep its scope just in the for loop. Then I think the only usage of sourceColumnIndex can be replaced by columnIndex.
Hii @ribhavsharma, this extra brace over here is causing the build to fail, kindly correct it :)
please move it to resourceManager.resetVmAttributes
this.
getCells() can never be null
new HashMap(delegates) - don't keep a reference to the caller's map - he might change it.
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
Why are you calling toArray instead of calling the constructor directly?
I'm not sure if we should have a reference in every exception to the CircuitBreaker instance. I would prefer if we just add the name to the CallNotPermittedException as a field.
Might be worth checking that the script extension is actually loaded, and that getExtScript returns non-null.
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
SonarLint is going complain about String concat
use Long.valueOf() instead of new Long() - always for performance reasons
Any reason not to use return type Collection<Report> here, then return reports.values()?
This whole block can be replaced with functional style Java, as per example given in Epdq.
Should close this even if lineIterator fails to close.
Same here, add deprecation flag.
System.clearProperty can be used instead.
Have you tried this with an existing stream with applications deployed? I wonder if we can use the explicit streams/logs/{streamName} endpoint for this.
A flip != 180 rotation
could we change to List<Properties> or is this API fixed?
Why are you assigning 0 to numElementOnPage, as you assign some value again in the next line?
alias is count but the function is sum
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
let's update all the includeTextDetails references to includeTextContent
- [x] What does this do since this is not building Java? Is this just copied from another project that this code is based on?
Cosmetic: Our loggers across the codebase are lowercase. Could you please change this? Thanks! :)
suggestion Validate.notNull(dialect, "Unable to create instance of class: %s", dialectClass);
UnsupportedOperationException (same with others)
possible exception
I'd say "block end cannot be before block start"
Definitely use parameterized logging here instead of string concatenation, because otherwise this method will be generating garbage objects on every call!
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
I don't see a reason to return an Iterable here instead of the more specific return type Set. The result is very small and a lazy evaluation is not necessary (which could justify returning an Iterable). Returning Iterable instead of a more specific type unnecessarily limits what the caller can do with the return result.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Add PageLogging
I think you mean "Liquid Glass"
Similarly use the Java 7 template
why not use getVmDeviceByVmIdAndType ?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Nit: Unnecessary extra level of indentation.
Activity state util check before starting any of this, maybe?
Can be simplified using Hamcrest.
This allows null values, though that may be fine.
Does this work? There is no import for the builder nor the DefaultMetaData.
We also need to override that in NestedUDTMapper and EnumMapper (using an enum as partition key, though unlikely, is possible).
This binding is redundant if the AutoscaleParserModule already adds it. Remove it from here?
Please keep the indentation consistent.
The return type should be IEclipsePreferences so as not to expose an internal implementation in a public API. Curiously, I don't get a warning here, only in EMFCompareRCPPlugin. Don't know why, but must be changed anyway.
Add reasonable toString() method, returning null doesn't seem as proper way.
Pager builder can be replaced by Pager.single().
We're just swallowing this?
I think it's nice to do checkNotNull(item, "item") so the NPE message says what was null. Otherwise one has to go to the source code line to check what was causing the NPE.
Lol! I just realized this message has always been incorrect. If a user's rule is configured as: xml <rule name="MyRule" language="java" minimumLanguageVersion="8"> <!-- Java 8 rule! -->  We are printing something such as: > Unknown minimum Language Version 8 for Language 'java' for Rule MyRule; supported Language Versions are: java 1.3, java 1.4, java 1.5, java 1.6, java 1.7, java 1.8, java 9,   So, a user would understand, that instead of 8, they should write java 1.8 as: xml <rule name="MyRule" language="java" minimumLanguageVersion="java 1.8">  which would not be valid. We should probably just do: java language.getVersions().stream().map(LanguageVersion::getVersion).collect(Collectors.joining(", ")));  to produce: > Unknown minimum Language Version 8 for Language 'java' for Rule MyRule; supported Language Versions are: 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 9,
nit: remove this extra line
This would be safer if rewrite it in the following style: java return getMetadata() == null ? null : getMetadata().getName();
waitUntilContainerStarted is executed by .start(), no need to do it here
there is already some escape method/utility/lib so take a look if this can be reused here
Need to add if (capacity != null) capacity.incrementAndGet(); here.
just return "" instead of new String()
rename to clusters
I think we have a race here with close.  T1 check assertOpen T2 close() T1 factory.apply( slot )
I think this solves the problem, but why aren't we removing the processor field from this object? If it's dangerous to reuse it, and the one stored here isn't necessarily the one used elsewhere, then surely we shouldn't store it for later access?
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
Could use a StringReader instead of a ByteArrayInputStream here.
Looks like we need only keys of the map, not the whole map.
What is this log statement for, exactly? Seems like a trace?
nit: You could have a private method that takes a preparedStatement and invokes executeQuery() on it. That way you can also put the metrics logic in that method.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Can we just check that the customProperties is not null?
isFiltered()?
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
Files.asCharSource(file, UTF8).read()
This can be made final
Note that I asked one of the authors of the "one sql to rule them all" paper. The only reason that they use wstart and wend was because of the layout for a paper. I got suggestion to use window_start and window_end. I also believe in a JIRA or an email (sorry I cannot recall which one it is) we agreed to switch to window_start and window_end. So I will suggest we keep window_start and window_end, which can be understood easier than wstart/wend.
why ConfigurableApplicationContext, not ApplicationContext?
This needs to be synchronized because of fSources
Should call the equivalent for Chrome. It should also check that Chrome (and Firefox?) is really available (and return or not in testBrowsers).
Nit: this could be: absoluteUri(DHCPV6_HOSTS, clientId)
If the expectation is that this always get built from Bugsnag.buildReport we should remove the public here to make this package protected. This will enforce the API usage which will make it easier to maintain and refactor in the future.
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
Avoid the use of swtDefaults(). fillDefaults() and explicit alignment makes the layout logic easier for others to read. applyTo() is preferred over create(...) when attaching to a control since it's easy to generate a ClassCastException if you mistype this and omit the ".create()". The applyTo version is also shorter. Change this to: GridDataFactory.fillDefaults().align(SWT.BEGINNING, SWT.CENTER).applyTo(l);
good multi-thread catch
Embedded headers will never work with native encoding/decoding - so I suspect we can do away with the separate setting for native deserialization.
Just use inCoreLimit here. Don't convert units to MiBs.
as this is not handled (it will always return null), I think it would be better to return a UnsupportedOperationException or to handle it (but it will take some time : db, rest mappings)
This method doesn't need to return anything. When completed, the connection should be considered 'closed'.
This and line 59 can be a global variable to clean up tests a bit
@fanifieiev the same above.
Can use Objects.requireNonNull instead.
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
this.type == address.type, do we need it?
Do we really want to sleep for 1 sec? Also, with a constant sleep time it is possible that one thread gets starved of locks, if other threads keep jumping in. Might be worth sleeping for a random amount of time, say between 50 and 300 ms. Also, you're not converting time to ns here.
NoSuchElementException is more accurate
Why iv.removeValue(i, this) and not iv.removeValue(i, aCause)?
This code repeats in multiple places. Until we replace Slice, please keep the code in SliceUtil or another central place.
this shouldn't have been here either, format is required.
Is there a reason not to initialize this where it's declared?
nit: the return true; statement could be moved inside the try block.
I don't know what to do about it right now, but I would be a lot more comfortable if the Model lifetime was connected to the PsiElement lifetime. In my ideal world, the models are just a veneer over the PSI. That's not to say it's the _right_ way to do it -- just a gut feeling. I worry that local caches in the model can become out of date as the PSI changes (the user types, and/or refactoring). Maybe my concern is unwarranted. Do your concerns match mine?
Should be "InstaPost" actually.
These local variables can be final.
Consider using i18n for this title.
I don't see you overriding this in your Bounded implementation, why make this protected?
The incore merger works in memory without a working tree. Does he need attribute handling?
In this case we ALSO want to include the "if it keeps happening, talk to the person who asked you to collect data" message. I think just concatenating the two with a space would be fine (and concat does the right thing with LTR languages, I believe)
There's no need to compute the error message in the general case when there's no failure, so please move this (duplicating if needed) a few lines down to where it's actually needed.
unused result variable. We could remove that I guess.
Use hasToString assert
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
You almost got me right now. :-) There is no need to test the injection point. You only inject instances of this interceptor to the injection points where it should do its work anyway. Because of that it is unnecessary to provide and check the injection point. Just delete this method and the field and constructor parameter and change java private void invoke(IMethodInvocation invocation) throws Throwable {  to java @Override public void intercept(IMethodInvocation invocation) throws Throwable {  and you should be fine. :-)
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
Unreachable code. The button is only visible if the user is signed in and the action is defined.
For loop?
IF EXISTS should be reflected in unparse
Same here. It's more readable when part of deserializeValue
You no longer need to pass 'driver' object
This assertion could be removed as it seems to test the Java type system rather than our code
Should there be a ITimeLineEvent interface?
This validation provider still uses JSR-346 string in problem's message.
Follow the same order of argument definition. Always add requireNonNull unless we are sure it is not needed (@Inject) or the value can be null (usually annotate by @Nullable).
no need to say "public" here, it is always public in an interface. "static" is important though.
Collections.emptyList()
can potentially return null if both are. is that ok ?
Use ServerUtils.isMainThread() etc.
why not public?
The exception possibly thrown here should be caught - there are no known cases of non-integer values being used here but JsonToken.NUMBER is not guaranteed to be an integer. The minimum handling should be to still send the report, though the maximal handling could be to create an internal report for it.
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I think adapter should have Adaptive banner implementation.
Optional: this could be done without the index variable: for (int i = 0; i < emailPick.getItemCount(); i++) { if (value.equalsIgnoreCase(emailPick.getValue(i))) { return i; } } return -1
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
you can use containsKey()
If the values are empty, shouldn't we return true rather than false?
this is the exact context of the AbstractJpaDao.em() - shouldn't it be only the responsibility of the interceptor to set the entity manager to the dao ?
be a good citizen and call System.exit too :wink:
We should add a check to make sure the end time is not in the future by comparing it with the current time.
same logging here as in perform next operation
The AppCommand is supposed to notify the desktop when its state changes. This happens here: <LINK_0>
Could you replace Arrays.asList by Collections.singletonList ?
defensive copy?
the return here may be either Version or VersionOrdinal, do we want to upcast or downcast to ensure returning a single type? Doesn't appear to be a problem currently though
Gary, it must be opposite:  public interface Closeable extends AutoCloseable {
return checkAndRequestPermissions(activity, EnumSet.of(type));
It is preferred to use the getResource method for tests instead of regular relative paths due to potential issues with the classpath.
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
I think we could add a final here: suggestion final HTMLElement element = typeSelect.getElement();
It would be much better if you declare ActivityScenario variable globally and initialize it before the start of the test inside another method named setup which should be annotated by Before keyword.
return queryId
return optional.isPresent() ? Stream.of(optional.get()) : Stream.empty();
Remove throws Exception
Should be- setTitle(text.asString()) not setText.
Is it required to have doScan(...) both for producer and consumer?
Multiple method(*) methods
K **is** comparable because K extends Comparable<? super K>. We can't use natural comparator here. I believe this is correct fix:  java final Comparator<Tuple2<K, V>> comparator = new EntryComparator<>((Comparator<? super K> & Serializable) K::compareTo); RedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty(comparator);
nicer to have a method IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
@Suseika how about to check PsAll.enter() returns Identity from 3-rd Pass?
please move setText and icon into OpenPluginDependenciesAction and remove it from PluginsView
The empty string in the constructor is redundant.
Should add a method calculateSettlementDate on ResolvedCdsIndex that takes the valuation date and reference data. Like calculateSettlementDateFromValuation on ResolvedCapitalIndexedBond.
Preferably have one call the other?
on each user modification your method will be called and gather+process all the text inside the editor.. Try your modification with huge file.
A LinkedList is better since you don't seem to access specific indexes anyways.
nit: missing space after if
tiny bit more efficient:  private List<ColumnWriter> getLeafWriters(GroupColumnIO group) { List<ColumnWriter>() writers = groupToLeafWriter.get(group); if (writers == null) { writers = new ArrayList<ColumnWriter>(); groupToLeafWriter.put(group, writers); } return writers; }
Can we move this isAdded() check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
Please String.format() this.
We should use IdentifiedElementQuery.getLabel Do not forget: * @not-generated
return array == null || array.length == 0
Maybe add || delegate.isNull()
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
This is the same as isSMimeEncrypted except for checking for a different value of Content-Type, so you should create a common method that takes APPLICATION_PKCS7_MIME or MULTIPART_ENCRYPTED as a parameter
It would be slightly better to check that project is opened first instead of letting it throw CoreException in hasNature().
this shoud be executed here only if the operation is "copy" (which is possible only for template disks now, is the disk profile even relevant for template disks?). for a "move" scenario it should be validated on MoveDisksCommand
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Could you also add a check for static explain whether the table BIG is the picked as the left table of the cross join? Thanks!
Doesn't DroolsAbstractBiConstraintStream have getAPattern()? If Tri's have getAPattern(), getBPattern() and getCPattern() then Bi's must have getAPattern(), getBPattern() - but not getLeftPattern() and getRightPattern() and Uni's getAPattern() and one day Quads will have getAPattern(), getBPattern() getCPattern() and getDPattern()
I don't think this check is relevant
please move the isEmpty methods to the scimSchema
Why we declare full path when you created the method getResourcePath to make this simple? Lets change this to use the new method.
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
... and below.
The string should have SystemPurposeComplianceStatusDTO instead.
Curious why login logic has been changed here also.
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
Is there an alternative to SHA1PRNG? SHA-1 is considered insecure.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
I would replace " " with ' ' since there is only one character.
You might as well use <LINK_0>
Use _Objects.hashCode(name)_ instead of _(name != null ? name.hashCode() : 0)_ And the same for other similar code
Please use CanDoActionAssertUtils.
Spuild we ise IDType here instead?
we don't need to change the Creation classes.
Multiple threads can call updateAlarm at the same time, so we need to make sure that the usage of the outstandingAlarms map is thread safe.
The synchronized block needs to include this read from the map: - Thread 1 reads eventNameToListenerMap, gets null - Thread 2 reads eventNameToListenerMap, gets null - Thread 1 enters critical section, creates new HashSet containing listener 1 and stores in eventNameToListenerMap - Thread 2 enters critical section, creates new HashSet containing listener 2 and stores in eventNameToListenerMap Listener 1 has been lost.
Let's keep this config. Use URI dataDirectory as the only source of truth to determine the FS: 1. In FileSystemModule, Use dataDirectory.getScheme() to decide what FS module to install. Local file should be configured as "file:///raptor" (<LINK_0> 2. Get the value of dataDirectory and convert it into Path baseLocation. Use it everywhere. Ideally we should avoid using File as much as possible.
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
I would go with if-else as this is NPE vulnerable. But if you want to use a switch-case then please add a null check before it and return if he selectedProtocol is null.
Can make this into a singleton as we have with UNSET.
I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?
You shouldn't need to specify it. I guess that Kubernetes API is the default mode.
instead of != null here, you could do a instanceof ISegmentGenerationListener. There shouldn't be any ClassCastException, but this way, you would avoid any such error
Do you think we need sync control on all the map operations here?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
suggestion var service = getCandidateServicesToMatch(serviceId)
This doesn't work as it should (and neither does the old code). If I create the following rules: Owner +1 refs/* Devs Owner +1 refs/tags/qa/* QA Submit +1 refs/heads/* Project Owners Unfortunately the group QA has Submit rights on refs/heads/*. The problem is we aren't filtering the RefRight to only the refs/* lines.
sorry... forgot... if multi value we need to create a collection.
Unnecessary whitespace.
You want g.add(null, checkBox) and put the display name onto the CheckBox widget. This way it shows [x] Foo instead of Foo [x] and users get a bigger click target (the label text) to mash with the mouse.
Similarly here, exec. should not be necessary.
connector belongs to Constants again
Need to take a copy of the context to isolate it from changes to the global context that may come later. It should be, current style:  this.context = ARQ.getContext.copy() ;
I think the ServerTaskRegistry should not be obtained here, but it should be injected by the runner during construction. Also, a cache is optional paramater in the TaskContext and you should not rely on its presence here. Because of a current limitation in the DefaultExecutorService, it is not possible to have a distexec without a distributed cache, but @wburns is adding a new implementation which changes this.
I presume you want to have all those line in .gitattributes? I think you need to do a single writeTrashFile with the four lines: writeTrashFile(".gitattributes", "[[]] bar\n" + "[\\[]] bar2\n" + ... );
I can't remember, is there some protection to make sure names are unique
Aren't we also prioritizing savepoint barriers here? Or are they guarded by using NO_ALIGNMENT_TIME_OUT on creation?
The bit is either set or not, so != 0 is a faster test here.
There could be other cases where STDIN is referenced and an issue should be raised
This will throw redundancy warnings in IntelliJ
It is preferred to use the getResource method for tests instead of regular relative paths due to potential issues with the classpath.
Ternary ? true : false. ;)
Again, use IOUtils.
It shouldn't be an error. We have warn log tracking in many places now, so would pick up if this was frequent.
You can just do Slimefun.getLogger()
Why are you putting the annotation on the same line as the method name. Normally all annotations are on their own line
please change Preconditions to static import.
Please keep this.cell near the related fields (previousFamily & cell count) below
package-private? Only used by AbstractJmxRegistration
you don't need this function, you can use constructor directly
The image attribute is not supposed to be the text of the node. I'd rather keep it separate (the previous @Text attribute was fine). A practical reason for that is in the future, other languages may have a way to get the text of their node, in which case that wouldn't be fetched with getImage, for compatibility, but probably with a getText method, or getSourceCode like in #1728. Also we *may* deprecate or otherwise put getImage out of use as soon as 7.0, given its contract is super loose.
use same language as above "cannot be null". dont express the same thing in different ways to the user. be consistent
no need to check for null again...
This makes me very sad since it brings back bad memories of us trying to make super calls happy. How about we move the diff callback creation to the options builder and let devs overwrite it if needed?
This is never returned.
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Should this be above "isColorTeamMatch"? For example, on line #755.
Maybe extract locating the Visualization.Factory into another method as it is used in getVisualizationInternal as well?
WTF is lala
better to cast to string instead of using toString() .
return a new linkedhasmap here I would say
should add some context in the exception message here
Maybe return an empty map instead?
This means TestHiveClientInMemoryMetastore won't run the statistics tests. Do we implement this in a later commit?
ClientLogger.logAndThrow all exceptions. Please search for all cases because soon Shawn will check in his CheckStyle rule and it will break the build.
unnecessary
I also can't understand it, but now result is always empty. will try to debug it.
Did you think about using [appendQueryStringToURL](tests/blob/master/src/test/java/com/wikia/webdriver/common/core/url/UrlBuilder.java#L71) method for appending URL params to URL?
It isn't possible for ctx to ever be null here is it? Also checking whether ctx.patternInitializerList() is null should probably also be done before line 175 as well.
Hmm...while at first look this looks ok, I think we should 'harden' it a little bit to prevent cases of leaving compensation context uncleared in the DB. I'd suggest doing the following: boolean clearCompensation = true; try { endSuccessfully(); } catch (Exception e) { clearCompensation = false; } finally { if (clearCompensation) { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand(); } } else { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { compensate(); } } The code can be improved, but this is the direction to go to reduce leaving compensation trace in case of a failure during the end action.
This should return a builder with the current options set.
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
check notNull?
You actually don't need a whole Project Object becaus you only work with lists of project, please change the functionality to only work with lists, by now
Same here when trying to save the context without specifying the script (or when trying to import the context).
why not factor out this code ? It's repeated in quite a few places.
Style issue: @Override shuld be on line above the method declaration
LOG_WARN should be the first argument
This is kept for backward compatibility, we need this when users upgrade from 0.6.2 to newer versions
Hm. This would prevent the player from disabling flight if they aren't allowed to fly in the first place. This packet could also contain other information than just flight status, so returning here would break that. I think the logic should look something like this: 1. If the flying flag is the same as the current flight status, don't do anything. 2. If the flying flag is different, and i. The flying flag is set to *true*, and the player is allowed to fly, then fire the event ii. The flying flag is set to *false*, fire the event 3. Check if the event is cancelled. If i. the event is cancelled, send the abilities to the player and return (sync) ii. the event is not cancelled, call the setFlying method
this method should be refactored to use the new attach(ServoListener) .. rather here is is calling addListener in this method.
you can use your find method here also
I think this can return null if there is no timeout. From what I see, a null SocketConfig is supported and what occurs normally (if you have no customizations).
Does this really work? That validate method i think expects non hashed passwords, probably you shouldn't validate this, the ticket says changePassword methods. I also think these should delegate to the changePassword method that validates the password to centralize the code
can we change a return type to int ?
Either hasNumberOfValues ? numberOfValues : 0 or add verify(hasNumberOfValues)
Using == for object comparison? :)
Seems for me this would be enough:  java Query query = Query.query(Criteria.where("_id").is(key)); query.fields().include("value"); return (String) template.findOne(query, Map.class, collectionName).get("value");
should it be escaped, just in case if header values contain comma?
You are opening a stream but closing it inside a other method. Is this a good way? Would it not be proper way to open and close a stream inside the same method?
s/any(List.class)/anyList()
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
this used to bail after this call if it wasn't the root, does returning v. not returning from onCreate() in that case affect anything?
We can't use the concrete HashMap.of here because it is an abstract Map test, the base for _all_ Map implementations. Please use the methods empty, of and ofAll which are implemented by all AbstractMapTest implementations.
Mock this also.
Is the super class implementation not working?
I prefer to keep the static import.
unmodifiableList(...) is unnecessary.
The method can be static, and the "standard" implementation is: return PlatformUI.getWorkbench().getDisplay().getCurrent() != null;
oo fancy!
I'd suggest simplifying this block to (and for the similar cases below):  return super.getConfiguration(igniteInstanceName) .setIncludeEventTypes(EventType.EVTS_ALL);
Math.max
This doesn't seem right to me. What if this view is in a context where its parent doesn't have MarginLayoutParams? It is still highlightable, no, just perhaps not with this new margin highlighting?
Probably we should check here for the class loader of the exception class, if it's the class loader hosting the test cases it should be GuardianException, otherwise we should transfer the exception using com.hazelcast.test.starter.Utils#transferThrowable.
use getGuid(rs, "disk_id")
null check
plase fatcor out that hardocded path segment
X and Y are primitives, so should the %s be %d here?
final
Remove else statement here. It's unnecessarily
UnsupportedOperationException seems reasonable here.
suggestion return new CheckConstraint<>(name, mapper.apply(expression), expressionStr);
actually, MessageContent could have this as a static method.
You can replace the qualified name with import
Then OpenShiftPreferencePage and OpenShiftCorePreferenceInitializer cannot use that method, they need 'pure' search for default in $PATH.
With the new out-factored structure, hopefully we can get rid of the "backreference" to the workbench here.
Remove?
if you use a second client instance and do this remote operation, the test can be easily duplicated by non-java clients as well.
I think lowercase l should also be considered
don't need getName() just this.oldSelectedVersion.notEquals(newSelectedVersion)
Every time we change a JSON test using JSONPath a cute kitten is born.
Isn't this constant and shared across all producers? Then can't it be static?
Use faster methods, should not use data processors when possible.
We may not need this method and can use gatewayResponse.getError().map(s -> s.getMessage()) instead in CardCaptureMessageProcess
nice meter
selectedElement for better readability
assert name != null;
No need to call stream() here.
I noticed only now this fact: don't we have a rule to forbid the usage of "Assert.xxxx" and force the usage of import static "org.junit.Assert.fail" ?
You can use getFieldValue(Long.class, getLayout().fieldLen()) here and then null check to be safer.
is this needed for the test?
seems worth throwing an exception if the file isn't found, no?
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
Maybe we should compare contents of JSON objects instead of their String serialized form because such a comparison is sensitive to field ordering and white symbols... Any modern object mapper should be able to do that. With that being said there is a library dedicated just for this: <LINK_0>
Could be just package accessible, just for tests.
are spaces OK in namespace strings?
You don't really need a null check here, using "auto".equals(objectValue) is enough, if true return objectValue.toString(), otherwise continue on to normRangeValue. This can be important in case we decide to handle null values differently, and then we won't have to fix it in both places.
Remove the if check and simply return getFirstElement
I think the granularity should be 1 seconds instead of 5 seconds here.
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
You need to check that conceptUuid is not null and blank
Either set type here or on initialization
Maybe the number of 5 should be a setting?
Please use English.
I think the setter would be a more appropriate place for this defensive logic.
We have a feature called "rolling upgrade" which means that at a certain point, a cluster may consist of members of different minor versions, one minor version apart. In another words, this operation and all other objects that are serialised and deserialised may be sent and received by members of different versions. In the case when this object was sent by a 4.0 member and received by a 4.1 member, this may cause an exception. This is why we have to introduce additional safeguards. It starts by adding the Versioned interface to this class. After that, you can add checks in the writeInternal and readInternal methods, like: java @Override protected void writeInternal(ObjectDataOutput out) throws IOException { super.writeInternal(out); out.writeObject(mapEntries); if (out.getVersion().isGreaterOrEqual(Versions.V4_1)) { out.writeBoolean(triggerMapLoader); } } @Override protected void readInternal(ObjectDataInput in) throws IOException { super.readInternal(in); mapEntries = in.readObject(); if (in.getVersion().isGreaterOrEqual(Versions.V4_1)) { triggerMapLoader = in.readBoolean(); } else { // old behaviour triggerMapLoader = true; } }  Same goes for PutAllPartitionAwareOperationFactory .
Can't we tell spring which bean to use?
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
explain a bit more in the message please
Should it be logged at the error level?
Remove final.
explicit real ref?
suggestion if (rowIdx >= rows.size() && requested > 0)
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
Can use Objects.requireNonNull instead.
This equals implementation should include attributes from the Command super class.
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
No need to call super() since it currently doesn't extend anything.
We should not generate the watermark if the source uses PunctuatedWatermarkGenerator.
May as well reduce the visibility of the method if it's only exposed for testing.
This doesn't need to be "re", as it's just evaluating stuff once, not twice.
it would be great to preserve the boolean flag that toggled between new GooglePromptReceiver() and new LocalServerReceiver() somewhere - the java-client needs that one
add call to validateParameters() method and list the mandatory parameters.
Should all the VoltDBL* relations assert the presence of the VoltDBLRel.VOLTDB_LOGICAL in the input trait set like VoltDBCalc does?
I think the underlying registry/restClient will return SchemaRegistryClientException instead of SchemaNotFoundException in this case.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
The string needs to be made translatable in a messages.properties file
This local variable appears to be shadowing the field variable
null? why not just a () -> {} ?
We could remove this switch by using an enum and having each part of the enum a value (-2, -1, etc.) that returns the proper ImageDescriptor. This would simplify this function to: return CommonImages.getImage(ReviewsImages.valueOf(reviewsScore.toString()))
I don't think isBootstrapped should be a flag. The 'bootstrap' method is a misnomer, it should be called 'refresh' or something. It's meant to be called multiple times, once before each use, to get the latest stream state.
<3 Better, but formatting :)
negative logic
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Why not use null instead of ""?
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
To always be safe please use context.getApplicationContext()
Should be outside the if
Good idea. Will do.
There are different ServiceId objects with the same serviceId field? e.g. that contain different aliases?
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
Why don't we make inDegrees to ConcurrentHashMap also?
app = getApplication(appNameOrId) if (app == null) { app = getApplicationByName(appNameOrId) } To avoid calling getApplication and getApplicationByName twice.
So simple! I like it!
You've overridden this method but dropped the @Nullable annotation.
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
Minor: can we check if the number contains the decimal point instead?
Likewise..
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
can you add mountPath here
If you"ll use generics you won't need this cast.
It looks like that this catch block is in a dead code path. Because startLogReplicationRuntime will catch all exceptions and input an event to FSM. Remove elements in an iteration over values also dangerous. > If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined.
Don't you need a super.setUp() call here?
Why was this removed?
Replace by Objects.requireNotNull()
add the Throwable t as the cause of this exception
To follow the conventions of Spring Security, please change to "webClient cannot be null".
canConnect( server.address(), clientGroup ) can be extracted to a no-params method
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Instead of using the context class loader, use the class loader of the first aggregate factory provided.
This is not an issue specific to this patch. But I think the class hierarchy needs some adjustment. Currently: PipelinePlacementPolicy<-SCMCommonPolicy<-ContainerPlacementPolicy Should we change to have the SCMCommonPolicy as the base for both PipelinePlacementPolicy and ContainerPlacementPolicy, if there are common pieces between PipelinePlaceMent and ContainerPlacement, we can move them to them to SCMCommonPolicy.
Why do we need it here?
add () to group && conditions for clarity
We definitely need more details about what is invalid about the configuration (e.g. which keys are missing)?
Please create a single instance as a constant and reuse it
Assert values
Please create a separate subclass for test mode if it is really needed.
Looks like everything in the append(...) can fit one line.
Should use the log, maybe a warning.
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
wouldn't it be more flexible to allow to set the authenticated flag instead of always returning true in the MockEndpoint?
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this issue.
Why depend on all DiscoveryServices and not require extended services to register specifically under that interface? Ok, this might be breaking, but as ExtendedDiscoveryService does not even extend DiscoveryService, this simply feels wrong here.
Same here, you need to check that retireable fields are not null and null after
nit: should the last 3 lines be a separate test?
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
Why not "return argList.toArray(new String[argList.size()]);" so the String array with the appropriate length is preallocated?
We should move the naming of the threads to common configuration as well. It is just easier from debugging point of view and production support can easily make sense as well.
Not sure why this needs to be a shared/pluggable CoordinatorService. Looks like this is just some utils for working with ZK?
nit: maybe call them flattenDictionaryBlock and flattenRunLengthEncodedBlock?
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Could you add some log message here? It is not good practice to ignore exception
This is not necessary, the client is already created in the parent
Better to add checkNotNull for the arguments.
The reason for the NPE in doStopJobExecution(org.springframework.xd.shell.command.JobCommandTests) comes from here:  final String startTimeAsString = this.configuration.getLocalTime(jobExecutionInfoResource.getJobExecution().getStartTime());  The JobExecution startTime can be null.
I think you need to assert that the return value is 0.
replace the if with checkIndex(toIndex)
Do not close the buffer (see #5400)
that can be null? This means all the locks above can throw NPE? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIZATION. Please either make sure they are never null or use different objects for synchronization.
should this count be parameterized?
Maybe we should start using java.rmi.server.UID instead.
check NPE and make SITE as a Constant
this line doesn't do anything
Noticed txnIds is passed like List->Iter->NewList->Iter->NewList to several methods. This model have several copies. Instead, can we pass the same list (txnIds) all the way down to build openTxnMessage?
I wonder if it is better to pass the admin label here in getSystemAdmins()?
s/vmId, null, deviceEnabled/vmId, deviceType, null, deviceEnabled
to avoid a crash on orientation change in tablets we should add: if (handler != null && runnable != null) { handler.removeCallbacks(runnable); }
Can't we use COMPONENT_NAME here?
When the view is closed you need to stop the build thread
This should be: if (info.status() == Status.MERGED) {
this could all be one line i.e: return criteria.list() > 0
suggestion LOG.warn("listOffsets request failed.", e);  Thanks! (minor suggestion to make the log message more typical)
no if (initialized) check and exception if already initialized?
oic, didn't realize. Thanks for clarifying :)
Removing test because you can not fix it is usually bad idea
defensive copy?
I meant  try (InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(resourceName)) {
This supplier can be Suppliers.ofInstance(config).
Can you not use a for-each loop here?  for (JsonElement jsonEle: doc.getAsJsonArray()){ // stuff }
I think this should be: java setCursor(Cursor.getPredefinedCursor(DEFAULT_CURSOR));
Declared but unused.
Do we need this? All it does is assert that the message is equal
I haven't tested it, but I don't think this will compile.
This is not appropriately thread safe. Whenever you require synchronization you must make sure all atomic operations are performed under the lock. In this case, it would be possible for two threads to race associating the same async pretty printer with the request id and both would report that the key was not already there and then both would attempt to add it. This is solved in one of two ways here: a) use a different locking object and synchronize on it for the entire method body or b) take advantage of the fact that put returns the old value if it was present and throw if it returns non-null.
externalize
Could use this::updatePartionInfo
Local variable: no final needed. Is your IDE configured differently that checkstyle?
Maybe just setVisible(false)? I believe setting the value and the indeterminate properties won't have any effect here...
Why not use assertNull and assertNotNull?
was the system.out meant to be removed?
null checks?
The cast is not necessary, we are not using generics for nothing ;-)
this doesn't belong here
unused variable
log or throw. Don't do both.
This method could be put to parent class and called in each test class. Or some ResourcesUtil class can be created that will contain handling various resources. Or KieUtil can be used.
Can use curSelectedIndex.orElse(-1) + 1 here.
Send this exception to the log.
[FindBugs] WARNING: SA: Self assignment of field KafkaSingleThreadedMessageReceiver.subscription in pl.allegro.tech.hermes.consumers.consumer.receiver.kafka.KafkaSingleThreadedMessageReceiver.update(Subscription)
Does this work if transactionCallbacks contains multiple callbacks? If previous code causes recursive call, I would think ConcurrentModificationException would be thrown.
This local variable appears to be shadowing the field variable
It's always used with join(), so I wouldn't return CompletionStage here.
You used a lot of "Success", maybe try to replace them with a static final string.
Instead of printing a stack trace to standard error, why not throw a SlimFixtureException with message that date can not be parsed and e as cause?
Replace it with the ArrayUtils#isEmpty.
Why not in combination with above do this: setValue(value, false);
I think we don't need to create a table for this test. Just call the procedure and see if it fails.
Please remove System.out
What happens, if the onsetDate is null?
from withLabels name, I would assume to use only given labels. However, this adds given labels to existing ones. There is very similar method withAnnotations that behaves differently. What do you think to rename this to somethink like addLabels? Or is there even a reason why to putAll instead of replace everything?
unneeded check
Could you use one check of CoreUtil.isNullOrEmpty() here?
remove the public
consider saving the value of group 1 and group 2 here rather than the whole matcher
It is up to developer how to do it this check, but here we can avoid creating a list by using allMatch.
Consider assigning some of these expressions to local variables to reduce nesting.
I think this is the same as this.newValue = newValue; ??
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Maybe use message "Config job.name is missing" ?
Is it Novoda style to have this Exception in a new line? If not, could be better to have it in the same line.
Preferably have one call the other?
assertFalse(...);
Please keep this.cell near the related fields (previousFamily & cell count) below
Assuming this is noting completion of initialization, perhaps "Finished initialization."
Make sure you have a mutable details field here.
can you please also add method ok(TimePeriod waitForJobs). TimePeriod.LONG may not be enough for all cases
Should you attempt Path.toFile() here?
I believe that the BackendUserResource.getUserByNameAndDomain method is only called from here. Can we check if it is reasonable to move that code to this class? And then, instead of implementing it with 'performGet' we can implement it with 'getEntity', and check if the result is nil instead of generating and then ignoring the exception.
Since we're tracking this event after the user taps the next button and only when the email is valid, maybe we shouldn't call it "email filled", as it may be misinterpreted as the user just filling in the email input. Does that make sense to you? To be honest, I'm not even sure why we need this event. What's the idea here?
Style-nit: We don't put {} around a single statement.
I'm not convinced we need this extra complexity. Could we just call logger.error("", runtimeException) without changing level or modifying any of the other code?
You don't need the else statement here. You can remove it leaving the LOG statement and the code will be exactly the same.
"creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating the aliases here
This change should be made also for DiskListModel
you can make it public for not to use generateArtifact(packageId, packageVersion, 0) method calls below
stream & collect
this.
pvk should not be visible. Please remove it.
We still need to call to deactivateParticipants()
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
nit: could you collapse all of these into fewer lines?
Isn't this condition inverted? Juno and Kepler are the only versions for which we can *not* support the dynamic tabbar.
if you remove the property, why aren't you removing this method as well?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
@jjl014 User id is optional, unlike client id and session id, which are required for user info
This is really expensive to do every time.
capturePageScreenshot is more appropriate - capturePage could have a lot of different meanings
Instead of sleep, what about replacing with CountDownLatch? We can unblock through the code rather than depending on the timing schedule.
Is it safe to let the else case fall through? Perhaps the entry display type should be the first thing checked in the method and return immediately if it's not DISPLAY.
Gson doesn't run on these versions so I don't see any reason to include them.
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
Could this method be implemented with return addToByteCount(super.read());
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
You could remove "verify that the" from the logging description.
Ran into a spark bug a few days ago where a shutdown hook firing during a "clean" shutdown causes problems. This method actually needs synchronized or else a shutdown hook fired from a SIGTERM won't wait for runCallbacks() to finish
Formatting issue
Should use the log, maybe a warning.
That was exactly what I want.
I am wondering whether it wouldn't make sense to move the resolution logic out of the TaskManagerLocation class in order to make more like a simple data transfer object. For example, we could have a method fromUnresolvedLocation(UnresolvedTaskManagerLocation, ResolutionMode) which either resolves the hostname or not depending on ResolutionMode. As a second step we could think about whether we want to support laziness. If this is the case, then we could provide a Supplier<String> fqdnHostNameSupplier which we call to give us the fqdn hostname and then store it in some field. Separating the TaskManagerLocation from the way it is resolved might simplify the individual classes a bit.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
IOException?
The code can be simplified to rely on autoboxing.
See the Headers class.
The TimeBudget should have been created before the call to ConnectionFactory.connect(), otherwise you are just timing getting the lease, but the budget is supposed to cover the whole connection. Ideally there would be a way of passing the TimeBudget into the ConnectionFactory.connect(), but as it is the first call, it can manage its own TimeBudget.
I'd add a get from the DB here, to make it was really updated there.
needs 2 _arguments_, plural
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
Interface can be used here.
We can give some more time, like 30 seconds.
@erdemedeiros we should stick to only tasks that we as an authenticated users can see. That is what the default findAllByWebQuerydsl() should do. We should add the check in the getTaskById() method to make sure that the user making the request is allowed to see the task. Does it make sense?
Cosmetic: Please, change this to lowercase: suggestion logger.error("Before execute failed for [{}]", r, e);
can you use the onSuccess / onFailure lambdas to improve the test ?
We could use resource delegates instead, right?
can we use CSS?
"amount of columns was typed: " + columns
Same here, a constant can be used instead.
Any reason for doing the instanceof check in add but not subtract?
new ArrayList<>();
You are not supposed to access usernameEditText.getText() from the network thread. Capture the username and password into final String variables right before scheduling the action.
Remove the public modifier from the constructor and remove the null check.
Take a look at <LINK_0>
LinkedHashMap? Does it matter here? I'm not sure it does (on mobile).
What if it's absent? In my account it may be absent, for example
Just do this at the root of the database every time so you're sure nothing else is happening: mref.getRoot().removeValue()
It should validate that the siteNode is not null otherwise it will fail later (and seems to break the panel).
should this be more strict ? i.e. require at least one character inside the parens ?
If it's an application component, you should get it using Application.getComponent(). Makes things less confusing.
Can you also capture stats on the hit ratio, load time and total weight.
Why did you add the round braces?
This should not be static. The choice of whether to use BMX should be per apache server, not per agent.
nit: you can do mLGNames = Sets.newHashSet();
Use ImmutableDataCachingUtil.getValue(ImmutableSpongeValue.class, Keys.IS_SNEAKING, this.value, false); instead so that the value can be cached.
No need for null check.
Maybe use the orElseThrow method of the Optional here
What is the deal with the type converter?
Assert not required if field is final
On reflection, I suspect that this was done for backwards-compatibility reasons, since overriding and delegating to base would be a behavior change whereas this change is only a performance optimization.
checkOne can be used or is unused?
Use Iterators.transform from Guava?
Then this one could become java return ImOption.apply((Focus) getValue()).map(f -> f.getStringValue()).getOrNull();
It seems like you are expecting a certain exception here. Can it be made more specific than "Exception"?
We probably want to hold on to a reference of the mapping context ( MappingContext<? extends ElasticsearchPersistentEntity<?>, ElasticsearchPersistentProperty> mappingContext) in the instance.
It shouldn't be there. ProfileView should be shown in onActivityCreated of relevant activities in which we have to make it appear.
Nit: would you like to say "flow pause requested by user"? It's not given that it will be paused at this point, right?
Think using switch just adds noise here  return this == PERIOD_END ? period.getEndDate() : period.getStartDate();  is simpler whilst there are just the 2 possible values
please remove this statement or enhance it to something more context/meaningful
pvk should not be visible. Please remove it.
This should check that repository is not null.
This isn't a job. Please rename the object to match what the object actually is.
This can be defined as Lambda
Return value of the method is never used.
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
inline
Should you call analysisReady(false) here?
This isn't the listener I was worried about. This should be fine, as the main tab model is probably destructed soon after its view. What I worried about was the systemTree listener, because the system tree stays there and will keep trying to send events to the disk main tab view (which will not exist anymore). So basically, I think instead all is required is CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent().removeListener(systemTreeChangedEventListener).
containsExactly oder isEqualTo verwenden
Sorry, I missed this completely on my first review. Having a public class but a package-private constructor is slightly problematic from an API point of view. As it allows everyone to see the class, but not to use it. I'd suggest to make it public or the whole class package-private...but I'd need to do some more thinking about that one, so I'd go with public.
Use try-with-resources so you don't need to manually close the session.
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
please use try with resources as in ConfigurationHolder
There is an INVALID_NAME type you can use instead of OTHER. (Same for the NAMESPACE validation method).
Missing <>, this is a raw type.
This line is too long, I'd suggest to use some local variables, it helps with step by step debugging as well.
Listener which does nothing, looks weird for me. Is it okay?
Change to just the remove call -- the contains key call is unnecessary (as remove will do that check anyway)
ExceptionResponse is not a ValidResponse, so the validResponses field name is no longer accurate.
nit: redundant
This is bytecode equivalent to using the for-each syntax on an array.
s.a.
secretLabels = Arrays.stream(labels) .map(l -> l.split("=", 2)) .collect(Collectors.toMap(p -> p[0], p -> p.length == 1 ? "" : p[1]));  ?
assertThat(topic).isNotEmpty();
Remove public. Also let's reformat all the ctor to our latest code style.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
What if the storage domain was inactive and you moved it to maintenance and failed.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
A more robust assertion would be to check that the list _contains_ the created Lan. Just to avoid race conditions if at some point we create something else in this datacenter.
Lambda could be replaced by the method reference Attribute::getAttributeName
possible NPE
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Arrays.asList?
why Object?
this could be done by a stream right? Like types = list.stream().map(e -> e.getName()).Collect(Collectors.toList())?
This makes more sense as it's forcing the consumer to think about the empty case.
This setting should be in the initiateDriver method.
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
Have you intentionally omitted index check?
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
Shall we use the constant - APILifeCycleState.PROTOTYPED.getState() here?
antipattern: using getBytes without character encoding
Add Pagelogging
this doesn't look like it needs to be public
Would be good to move this contstant to this file and name it something like WIDGET_ANSWER_STANDARD_MARGIN_MODIFIER.
userRepository and modelMapper invocations are not verified
what's the motivation, why you need to update the layout? FD is in charge of doing it, not sure if it safe to update the layout here
this needs to be called for all configs
use namespace instead of DEFAULT
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
I think this should be in GerritGlobalModule, which requires moving this type to the gerrit-server package. But if we ever support editing permissions over SSH (which git-store enables!) we need to run this logic in a context where the gerrit-http code might not be visible.
This is redundant.
Shouldn't this be wrapped in a try... finally block?
Why this check? This method will not get called unless performRuntime is called, and performRuntime has no such check.
Won't fix.
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
Think we should also look at remaining() - it can be efficient to use slice, in which case the buffer doesn't go to the end of the array.
Extract the "USER_ID" to a constant and make it more unique. The HttpSession can be accessed "everywhere" in a servlet container. For example: "org.everit.jira.timetracker.plugin.user.id.hash".
Missing generics
configuration should be injected, not read from system properties in the constructor.
Why not <code>return ExitStatus.COMPLETED</code>?
(Alt) Can we move the skip condition to the testSetup method just above.
nit: these patterns can be made private static final and reused.
@overquota Should not #close do #closeConnection and #shutdown do #shutdownConnection?
Add __TS("content: hide filter") also
Did we want to have this normalize the path also by returning the normalized version from Path?
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
Should we check that provided viewer has type ITextViewerExtension4?
we should also check for n <= 0 here
Might be able to get away with protected
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
@lautarobock Same here, let's declare throws Exception
Maybe you can use .putAll(map) method to simplify this code.
trace
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
Indeed, that is better than my suggestion. Let's do this.
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Isn't "Access Denied" a constant in ResponseStatusFromPayloadHttpCommandExecutorService?
There is already logging for that in the EncryptionUtils.encrypt catch block
I don't really see a need for constructing a File object with the path to an URL here, just split it yourself
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Use equals - there is no guarantee that it's the same Guid instance.
2xx
Might be worth having a displayName?
I think you need to do this and the next line in a finally
shouldn't this be done.setValue(true)?
This will produce a Number Constructor FindBugs warning. Please use Integer.valueOf(0)
Why do you need to return the metadata? You are updating the own object, it should be part of the method getMetadata if you want to obtain this data after an update on it.
This should stay final
this is typically done by having a LoadSpec implementation that wires up the json config to the puller (see io.druid.storage.azure.AzureLoadSpec for a good example)
This is not correct.  select distinct a, b*2, c from (select a, b, c from foo order by a, b, c limit 100) t;
The only change I think we should make here is use our Util.UTF_8 constant for consistency.
@paulodamaso the braces and return are not needed here
ARRAY_ELEMENT_DELIMITER is also a single character in CsvValidator.
throw CucumberException and give the user a clue what was wrong and what he needs to do.
RuntimeException?
Please keep this.cell near the related fields (previousFamily & cell count) below
extract variable
You can put the whole ability text here instead of calling the super but if you don't you should add a comma after "steps"
Sorry for not providing all the details. Please propagate the methods to the TargetNodeComponent as it was done for isPerSyscallEventsSupported(). The methods of TraceProviderGroup will just query the parent.
Maybe, debug would be more appropriate then?
I thought this line is wrong until I realize that you changed what done means. I would add a second variable, and make done a local variable in handleException. I would also prefer that handleException be inlined due to the tight logic relation with run.
Do we need the empty constructor?
Catch exception.
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
partitions.length is final, because partitions is final, so this doesn't need the lock. Are you adding this to get a code analysis tool happy?
The condition should be replaced with !TextUtils.isEmpty(assignmentId)
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
Maybe type.value.equalsIgnoreCase vs. just lowercasing ?
Remove a nesting level by inverting this if-statement.
is the VM null too perhaps? maybe just move the condition from line 63 up?
Rather than put this in every test, you can just put it once in the setup() method.
I don't think args can ever be null, can it?
remove double a valid from test & implementation
Can we move this isAdded() check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
autoboxing
feedDisplay is a strange name. I had to look at the xml file to find out what it actually is. How do you feel about feedDisplayContainer? I know it was like that before and the guidelines we have come up with say that it is not necessary. How do you feel about this? Should we update the guidelines?
use .getUuid instead of getArtId, which will go away
Looks like we have unnecessary parenthesis here.
Please add a space after (Class<E>).
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
This seems like a significant refactoring - why? Can we do it as a separate change or is it required for the java8 migration?
If there's an overload the result should be (overload is noexcept) && (arg1 is noexcept) && (arg2 is noexcept).
for readability, consider extracting it to a method..
Why do you need "this." ?
It would be nice to have these new methods unit tested. Also String#replaceFirst is calling Pattern.compile internally. Based on how often we're expected to call this method, wouldn't it make sense to pre-compile the pattern in private static final field of this class?
And when isTryStatementResource is static, this one can be static as well.
Because the length (the second parameter) is always null navigation did not work and Quick Outline was basically useless. I provided a simple fix in commit d90ea00390076f38d982d68df1adb37623698b2e which selects the entire first line of an element: <img width="680" alt="screen shot 2016-08-11 at 4 21 53 pm" src="<LINK_0>"> @ghillairet please review update my fix and update if needed.
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Wouldn't we want to unify these names and pick either onReady or onDataChanged? Other than that, LGTM!
should call tx.close() not tx.commit() I suppose this it where unit test w/ EasyMock would be good.. could verify that tx.close was called on a mock transaction
If we returned a proper object here, we could have a constant placeholder such as EmptyExpression or so.
This branch is not needed
This method is used only in one place, so it could be removed, and the logic centralized here.
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Is there a reason not to import java.util.UUID? e.g a conflict with a similarly named class?
I didn't know the string "null" would become an actual null!
do we really need to return true/false from this method? is the contract here that you should always call beginTracking() and then endTracking(), or do you only call endTracking() if beginTracking() returned true?
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
suggestion if (castSource.toLowerCase().startsWith(clobReturningFunctions[i])) {
This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.
Please extract this string
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
I didn't even realize that we have logic in otj-server that also copies conserved headers to responses, apart from what already happens in otj-conservedheaders. Would the be any way to consolidate this logic in one place?
Could you keep it as it were? Thx
You could just call the other ctor
The SSLContext should be exposed for configuration so users can set the keystore, truststore, protocol, etc. TLSUtils has some examples for doing that, used by SSLContextProvider for the internal HTTP client
If you really want the o option in the query string to work here you need to setup an @Option() annotation above to have it be parsed and passed to the GroupJson.
This code repeats in multiple places. Until we replace Slice, please keep the code in SliceUtil or another central place.
it would be better to reuse:  <LINK_0>  to construct PagePosition iterator.
I think you mean (d<=0)
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
It would be preferable for the PutHammer to keep putting data until the main test method has verified that rehash has completed instead of using a fixed-size loop
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
enum is not the place for this. Move it to VoltDB
This method should be private unless there are plans to use it elsewhere.
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "createExecutor" a "static" method. [![rule](<LINK_2>](<LINK_0>
could just return null by default
The first if is superfluous. instanceof is always false for null, therefore a null value bypasses the instanceof checks and returns null from the end of the method already.
this "return;" statement is of no use.
uncessary call to super. No need to visit further.
This line is still backwards. Please don't use "Yoda conditions".
name should also be checked.
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
this constructor feels wrong now... I think it should be a Module and a Definition and then the constructor calls getCombinedGrammar.
Just do this at the root of the database every time so you're sure nothing else is happening: mref.getRoot().removeValue()
We'd want to use Collections.unmodifiableList() here also with null check
EndOfStreamException is never thrown in this method, as far as I can see.
nit: you can do mLGNames = Sets.newHashSet();
Same as above, why not use try with resources?
this can also be .map
You should see it from the side of the user, not of the implementation
can't this be defined as a List<DiskImage> ?
The date string format should probably be a protected static constant. Also do we need the temporary variable? (This method is called many times a tick.)
>byte[] [](start = 11, length = 6) DecryptResult
Shouldn't isPolled be false irrespective of whether it is a poller partition or not?
Is there a reason why the equals method is not fully implemented? It's returning false for separate object instances that contain the same description and value, but it should return true. Your IDE should be able to generate it for you.
instanceof
Files.write is deprecated. Please use Files.asCharSink: suggestion Files.asCharSink(toFile, Charsets.UTF_8).write(moduleInfoJson);
this variable assignment may be a 1-liner, but I don't insist.
shouldn't be setDaemon(true)
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
this can be private static because it doesn't depend on any member variables from what I can see.
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
What is the purpose of "jobId" when it's never used in the method? (also applies to the two following methods)
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
Gson doesn't run on these versions so I don't see any reason to include them.
Please move new instances to field's declaration. Change these 2 lines to clear.
nit: public static void But public here is irrelevant. Its only as visible as the inner class, which is package access. You can skip the public keyword.
No need for super()
I don't know, but isn't the class also of interest?
Not sure if you wanted to leave this hardcoded?
run already called tally, so do you need to call it again?
The WFLY-1069 stuff should tie into this.
You could seed the array with dataSize
For loop?
- This method shouldn't be public, instead make it default. - Add a space between method-name and braces.
Right, the transactionManager.shutdown() call is redundant with the if () block below.
I think its better to rename the function deleteResultsByID to deleteResultsCollection. It should take Collection<AsyncQuery> as an argument. All of the iterator logic can be then moved to the function implementation. The reason being in our database interpretation we have to delete each row one by one but for a filesystem-based, we can delete multiple at the same time.
was the system.out meant to be removed?
We can shorten this condition: java (StringUtils.nonEmpty(value) && constraintType == null)  FQN for StringUtils is org.kie.workbench.common.stunner.core.util.StringUtils
Again, use IOUtils.
Change this to PDataType.VARBINARY, as that's what the evaluate method returns.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
This method recursively calls itself, which will result in stackoverflow. Is that ok?
Can make this into a singleton as we have with UNSET.
we need hostName only to log error. Please call it there.
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
I see this method does something similar to execute minus the optional processing with the rowProcessor
although the runBllAction was introduced in earlier patch, i fill the sequence of this method is not clear: you perform runBllAction() and somehow the current command status is updated. I think referring the return value of the command here will be clearer to understand.
I think we probably want to validate that userAgent is a valid form
I think the CosemDateTimeDto is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
Just curious: why checking 'isClosed' ? Can't we call 'close' multiple times?
Erm, well there's no need to map launcher to itself suggestion return model.getLauncher();
Should be static
Very nitpicky, I'm not sure if we gain much by verifying the parameters of this test, we could make this more flexible by just asserting that any arg is passed to connect blocking.
This is not enough. Look at the method DecoratorAdapterFactory#dispose(). You have to iterate on the values of the map and dispose them propery
new ArrayList<>()
!droplets.isEmpty()?
you need to * actually verify the data * assert that the source file is stil there
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
Simpler: ArrayList<T> result = new ArrayList<>(collection);
Please implement equals() method either. This will remove the potential problem when working with collections.
A create card payment request should always have a return URL, so I don't think this should return an optional
This should have an ensureProperFile(false) at the beginning...and actually all read methods, even non-absolute ones need that in case they are called when the current file is at EOF.
These empty implementations can be removed I guess
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
Which exception do you ignore here? Is it DuplicatedStorageException ?
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
CopyOnWriteArrayList would be a better alternative as it provides optimized functionality for thread-safety and good for maintaining list of listeners that will be updated occasionally
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Possible NPE if the interface doesn't exist.
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
Why negated? couldn't you just flip the branches?
These line is proof you don't need QuotaConsumptionParametersWrapper
Maybe more informative like so:  "Unable to get build host, skipping " + BUILD_HOST + " value..."  ?
Should the name of the thread be maxwell-kafka-producer-worker instead?
I see this method does something similar to execute minus the optional processing with the rowProcessor
Should we use pushInlineDeployments here ?
remove tabs
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
Please String.format() this.
toString() formatting.
null checks on key and state are redundand
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
Nit please alphabetise.
For consistency, I would also make it so passing -1 results in a nullValue
We cannot just delete package name from each class. It's required to test that a check supports fully-qualified names. In this exact case probably it's better to move this class to new line
Why is this call needed for getting the skill level? Isn't the team's skill level stored already so the calculation isn't necessary?
Maybe check if batch update exception has nested SQLTransientConnectionException?
Suggest throw new RE(e, "Unable to get scaling status from [%s]", coordinator)
Why would you not start with "BigInteger value = BigInteger.valueOf(0);", and leave out the null check inside the for loop? If this is because null should be returned for an empty bitStringValue, that maybe should come first.
This doesn't look thread-safe.
style: unnecessary blank line
synchronized is harmless but superfluous here
This means that get method tests use the test subject's own get method to generate reference data. Should pull the user directly via Hibernate (sessionFactory) instead
Should allowedValues be considered for object equality?
Changing the region should also invalidate the client like above.
_verify
createElementNS(...)?
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply);  (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
Please replace all the occurrences of AbstractTree.this. Indeed, the code style we are using does not recommend to add this as a prefix of a function call when the function is in the current object.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Would a reset or init method on reader help?
@exper0 no need for the extra indentation here
I really feel like there should be a descriptor in the name, e.g. getQueueUrl(), getBlobUrl, etc. Thoughts?
we should validate (and the feature support check) it in the validate() method.
why is this return null??
Please change to externalSearch =
I don't think it is right to return always return true for two different AuthorizationContext instances.
logging here is redundant, since we throw the exception
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
I am not quite sure whether we still have race condition here. abortCheckpointOnBarrier might be called from CheckpointBarrierUnaligner after triggering checkpoint into mailbox. After aborting, we did not remove the checkpoint action from mailbox, so the checkpoint might still happen afterwards. So how to guarantee that #getAndRemoveWriteResult would never be called after aborting?
static (same for isMap).
Please use Yoda DateTime.now().getMillis() for a timestamp
final missing. Same for the other ones.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
This method should be static and need not pass this as an argument to the constructor.
I ask myself if SUBSIZED can be omitted here because there is at most one element in a single-valued type. It cannot be splitted anymore. But wait... Java 9 added Optional.stream(). I will ask jshell: java jshell> Optional.of(1).stream().spliterator().characteristics() & Spliterator.SUBSIZED $3 ==> 16384  Ok, we need SUBSIZED :)
This is very fragile, and will break when we add new storage type. Better check for the storage types (block or file?). Also, this change is possible only when creating volumes with vdsm supporting deferred preallocation, or it may cause very bad performance regression when creating big raw images. This is probably not the place to do these checks, we probably need to modify the code creating new volumes, or the code creating and copying volumes.
also here. if true.remove(element) returns the same instance, we may test with == instead of size and length
since there is an exception being thrown, there is no need to log an error. Otherwise, there will be double logging.
should have a space before null.
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
suggestion
why not peek()?
remove this
Same here. Get files with fileNameFilter and if it returns non-empty array, throw exception.
My expectation here is by the time the code is JITted the JVM will be able to predict ConverterHolder#getBestConverter() is both monomorphic and returns the same value for every invocation. There will be a bit of extra code to typecheck and branch (and de-opt) if the prediction fails, but I believe the branches will have the right prediction hints. The generated code will have the same performance characteristics as previous. If this is a concern, a jmh-based microbenchmark could confirm.
The this. in getters are unnecessary too.
my understanding of the initial interface was that this method was for returning the token-stored-on-disk, if any but in general, I don't think you need locking here.
can't you just return null ?
In this 2 lines, the Utils methods are not doing much more than what BouncyCastle is able to do itself. I would suggest replacing them with our own loadPrivateKey and loadPublicKey so that we can use the KeyFactory.getInstance(String algorithm, Provider provider) instead of the KeyFactory.getInstance(String algorithm, String providername) used by the library .
Possible to log only one debug line here?
isUnauthorized 403
@idelcano I think that OrgUnit Preference should be remove only for myanmar but not for Lao and Cambodia
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output, plainOldUserSchemaResource,PlainOldUser.class); avroItemWriter.setEmbedHeader(false);  Why should I provide a Schema if I can set embedHeader to false? For the reader, we can read PlainOldUsers from an avro file not containing a schema without providing a schema. In the same way, we should be able to write PlainOldUsers to an avro file without embedding any schema. In that case, why is the schema mandatory? To be specific, having a mandatory schema and an option to not embed it is confusing to me.
else if?
What happens if saving to a file fails? Memory will have been updated making it work for now and upon restart, the system wouldn't work anymore ...
Why do we return the parents name instead of the name we store a few lines above?
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
Not all announcement activity is public. I think there might need to be a separate manager method to have the right permissions. There are specially written queries in one of the DAOs to get only appropriate announcement activity because it was a pain. Anonymous users should be able to see activity for public announcements and logged-in users should be able to see all announcement activity.
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
I think this can be called multiple times in the current design, which might cause bad things to happen. Potentially this should only return files that are not already in the queued files set?
"Modifier 'private' is redundant for enum constructors"
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, so no action needed.. just for you to know
Adding this to a field is good manner.
Why public?
This is easier to read as: return type.getClass().isArray() || isList(type);
duplicate assert
consider changing "alt text" to "link text" in the markup, since "alt text" could easily be confused with HTML "alt" attribute.
Are we sure WDateField is the only input element which has a div wrapper? It may be safer to limit in some other way too - such as a check on the outer element's class attribute containing wc-datefield. I am pretty sure a WDateField in a readOnly state is wrapped in a time element and a WPartialDateField in read-only state is wrapped in a span element (the div for editable WDateField is only necessary because of the need for a calendar in the polyfill). Therefore this will fail if trying to get the component in a read-only state and the other input extensions do allow getting read-only components.
OperandTypes.VARIADIC indicates a parameter list with varying length. But it looks like JSON_TYPE is designed for processing a single input value. Is OperandTypes.ANY enough for that?
We have special constant for Maven PType ID: <LINK_0>
This also seems kinda pointless and a bit brittle. Just return resource.
Objects.hashCode could have been used here
I think this should be stripe_account_id ? as per PP-4302
replace with ReferenceCountUtil.release(msg)
isn't it always 1 or 2 arguments?
...the sysfs ~~; message~~ : {}
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Why are we configuring drawer in this activity. This activity shouldn't have it.
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
latest from today's discussion: return URL
Did you mean to remove this println?
this("Safety Command")
please update - should we keep this or format to remove ====
Any idea what this wait is for?
install button was not visible\* :dancer:
It feels like this logic should be refactored into a utility function since we have multiple copies of it. I generally also prefer to wrap compound clauses in parentheses to clarify that the second & third components are paired:  java if(ignoreHiddenFiles && (System.getProperty("os.name").contains("Windows") && Files.readAttributes(dir, DosFileAttributes.class).isHidden())){
No, no. Remove this logic (that checks whether the provider exists).
add this (also below)
This might throw exception
You could do a contains here like you do with the ACCEPTED_ENTRY_PIDS.
how does a MockHelixPropertyStore know that it for a certain path?
Deleted @NotImplemented return getCellTypeEnum().getCode();
I think we should try to be in the case where we have violations. Otherwise, it's difficult to see if anything is working at all.
We need to synchronize this with #322 @simon04 can you keep track of this change in you PR, depending on what we merge first.
Should you attempt Path.toFile() here?
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
Better: '|'
May be its safer to assert that it exists before and then assert that is doesn't after delete.
Use saveDetails() instead of multiple addDetail() so that it is transaction consistent
Actually _all_ components have a distributable flag, so you shouldn't filter on analyzers here.
You can safely remove the file.exists()(implicitly done by isFile
The theory behind CompositeName is that each segment is meant to represent a name within a namespace, so it's supposed to be able to support having a single segment that is a name-within-a-schema (e.g. "foo/bar/baz") which is used to navigate to a single naming store. That said, I will extrapolate that this change means that the naming server is not coping with parsing a name out of a CompositeName component, which is definitely a bug, but one that we can't really grapple with because legacy servers will always have this bug. So, I think the solution should be to introduce a new method, e.g. toDecomposedCompositeName or something like that, which creates a CompositeName where each name segment is equal to the name segment in the source name. Connecting to (at minimum) the legacy server should always use this method of conversion, while we still maintain the method which converts a Name to a single-element CompositeName as before. WDYT?
This should incorporate the standard clock skew accommodation: <LINK_0>
Could this and the next logger statement be reduced to debug?
Fully-qualified class name not needed.
We'd better not fail here and just return null.
Could you put the code that's a duplicate of lines 721-728 (setting the callback) in a method, and call that method from both locations? I could see having the duplicate code causing headaches down the road, of someone changing the code in lines 721-728 and then trying to figure out why the behavior isn't changing.
i18n too
Cache the call here and above.
If we do not write options unconditionally, we will not validate them on the server-side. Consider a user who submits IndexConfig{type=HASH, bitmapOptions=<not null object>}. This is an invalid config, but how do we know what was his real intention - to create a hash index or a bitmap index? I would rather read/write the object as is, and throw an exception on invalid config, rather than ignoring invalid state silently.
A defensive copy of the list would be safer IMO
We could remove this switch by using an enum and having each part of the enum a value (-2, -1, etc.) that returns the proper ImageDescriptor. This would simplify this function to: return CommonImages.getImage(ReviewsImages.valueOf(reviewsScore.toString()))
It might make sense to have this support the usual search using PaginationFilter.parse, but I'm indifferent.
Can you reduce the nesting depth here?
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
I think we can use a pooled bytebuf
change message and status code
Should return type CorsConfigurer<HttpSecurity>
Add check on null
The relaxedTrust should not be negated, we want to use all cipher suites when relaxedTrust is true.
Simple for-each?
here you can get the token from the 'querystring' and issue an initial HELO message
I see that address.getHostString() can return null, at least in theory (although it seems to be a pathological case). Do we want to defensively prevent against NPEs here?
Use target's class loader instead.
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
It is confusing to have unrelated asserts in one test method, please split those into separate tests.
Why not use Collections.singletonList ?
This method is only used in test code?
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
This try-catch can be moved to the @Test annotation as well.
CalDavConfig has no super class (except of java.lang.Object). Do we need a super() here?
In all the other nodes, all the constructors call the most specific constructor to avoid constructor spaghetti. That would mean the this-call gets "null" at the end for example.
HTTP_HEADER_CSP
This query returns no data. Is this intentional? If so, perhaps, use assertQueryReturnsEmptyResult.
ins't KEY2STRING_MAPPER missing?
you can return List<? extends GonamedElement> and don't cast definittions
Since this is a legacy record, deleteHorizonMs is never going to be set. It seems we can avoid loading the full batch? Ditto in isDeleteHorizonSet below.
You forgot this!
We have a numeric pattern in PatternUtils, would be best to use that here to avoid formatting issues.
Should be Multibranch not workflow specific type
Please move such code to UI abstraction.
here for example could be remotePath.resolve(source.getName()) if pathPrefix was a java.nio.path.Path
no nede to re-parse, use one parser result always.
Run formatter
Please use Optional.ofNullable()
This is a weird place to add a listener.
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this switch case number of lines from 10 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
Shouldn't that be List<ClientEntity>?
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
This will throw redundancy warnings in IntelliJ
Does it really need to be 'public static'? Is this method used from somewhere outside?
not really needed to verify it
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
I do not think that it is part of the responsibility of the validator - what is the benefit of moving the check to the validator?
This looks like testDataFormat(COMPONENT); Please see other tests for sample
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
We should at least resolve the Type at construction, so that exceptions are thrown as early as possible. The qualifier lookup can still happen in the build method though, and satisfy the purpose of this refactor.
I missed at the last review, but could we put this return true in else?
Need to use parameterized logging instead of string concatenation. This should also be a warning and not an error.
You can check with something like StringUtils.isBlank(getName()) since all the getters will return a value, specifically in this case it will return an emptystring which is bad given name is essentially the identity.
This is bytecode equivalent to using the for-each syntax on an array.
This does not need to be changed.
Replace with specific exception types.
this is unused.
Please add braces surrounding the for loop block. Otherwise this is confusing to read.
Same here, you need to check that retireable fields are not null and null after
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
The this. in getters are unnecessary too.
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
LOG.error("Failed to getattr {}: ", path, e)
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
Would this be a good place for some debug logging?
why is this if statement inside the function but checking whether snapshots are allowed is not? basically if it's not of type IMAGE then snapshots are not allowed so I'm not sure why we'd even get here (looks like the 'if' is redundant unless AllowSnapshot doesn't report correctly). In addition, personally I dislike a function with all code inside an 'if' statement. Also the name does not reflect what it does this way (it only updates if ...)
Again, just return the boolean value.
I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.
Could we log in the constructor rather than here? getBinding() can be called many times over the lifetime of the EvalBinding, so we'd just be getting many warnings for the same instance of the problem.
Integer.toString?
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
Wouldn't it be better to use the transitionMap to group by from state?
Use parameterized logging instead of string concatenation.
could this be static?
suggestion this.className = requireNonNull(className);
We could merge this, but that would cause all extenders of this class which are not LineContentAnnotation or LineHeaderAnnotation to not be clickable. So that could be perceived as a functional regression by those. Is this a big issue in your opinion? I am personally fine with it, as this is very new code and I don't think it has much adopters beyond those who are already following, and that even current adopters do work on the CodeMining layer more than on the annotation one. That said, do you think we could figure out an implementation that would work in basic cases, such as x >= fx && y >= fY && y <= fY + fViewer.getTextWidget().getLineHeight(position.getOffset()) && x <= fx + gc.stringExtent(getText()); ?
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
Thoughts on changing this from using withContext and a String constant in Storage Common to making this a helper method in Storage Common?
The Exception is never thrown.
This is a great optimization. Should this point to first character in the ASCII table ? Also lets verify that this for UTF-8 encoding as well.
You can put VALUE_1 directly to the assert.
this.
Consider to use an ImmutableList here
This means clockHand will be hot at initialization time. Intended?
* CME? * Isn't that exactly what remove() does? Removing on equals()...
Run-on sentence; does not explain WHY user should use other api. Preferred: "This method is deprecated and may be removed at any time. Please use ..."
You should add a convenience method that takes in an IReducer and wraps it in ReducedMetric
Check if buffer us null.
consider change to return validate(validator.isDomainExistAndActive()) && validate(validator.isDataDomain())
I guess this could blow up...
I assume that's eyeball & plug? I can't make out the plug part it just seems like a black blob. If it can be made more clear then great, at the same time I realize this isn't a gfx design project so go ahead with it, we can always replace it later I guess...
You might want to move this into a shared helper method for other tests which need a temp file with random data.
any clue on how this number was chosen? Is it an absolute or relative value? I think we should preserve the existing behavior by default, since most production deployments are constantly adding new data anyway, in which case it doesn't necessarily make sense to stop rebalancing. Also, even a small number may cause very large clusters to completely stop rebalancing because the incremental improvement is typically very small.
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
This line isn't needed. It's already tested elsewhere to be working.
I recommend this approach instead: java @VisibleForTesting Subject cacheAndReturnSubject(ServerSession session) throws SecurityServiceException { UPAuthenticationToken usernamePasswordToken = new UPAuthenticationToken(session.getUsername(), session.getPassword()); try { return AccessController.doPrivileged( (PrivilegedExceptionAction<Subject>) () -> securityManager.getSubject(usernamePasswordToken)); } catch (PrivilegedActionException e) { if (e.getCause() instanceof SecurityServiceException) { throw (SecurityServiceException) e.getCause(); } throw new SecurityServiceException(e.getCause()); } }
I have recently created AssertionUtil a class that provides shortcut to test assertion error, you can replace assertThatExceptionOfType(AssertionError.class).isThrownBy by assertThatAssertionErrorIsThrownBy.
Same issue here, double delete user.
We're on Java 8, so: IntStream.range(start, start+length).toArray()
This is called in the init method. Why is it needed again here?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Should be able to do a multi-id query using something like criteria.add(Restrictions.in("groupId", groupIds)) Current method allows for nulls to be included in the returned list too I think
Is this still required? Seems like we might want to prefer exploding instead suggestion this.packageName = Objects.requireNonNull(packageName, "packageName == null")
Would be nice to check different lengths and empty.
Objects.requireNonNull(buf)
Implement this
Empty catch again? :) AssertJ or suppress will work better for us I think.
we could add an assertNotNull here to detet as soon as possible potential problems
put lock() before try
remove extra empty line.
rename to pack
so this will produce invalid output. if we have highest ID 0 then we will return 0 as first valid id. this should be an Optional<Long> and the return look like:  return highest.isPresent() ? highest.get() + 1 : 0;  also we might have a test for this method to be sure we don't break it in the future
This seems a bit profligate... and the stream construction around a spliterator seems a bit unusual.
If I understand this right, the state machine cleans itself up after it disconnects?
ValueNodeList.comparable() is only used here, I'd rather make it always return a boolean and explicitly raise an exception here (instead of adding the extra boolean parameter), to me it's surprising that comparable() would raise an exception instead of returning true/false
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
progress.split(1) ? Interestingly, the counts seem to off quite frequently. Here only 2 of 3 ticks are consumed. I wonder if that was intentional?
name.substring(ext) is equivalent and shorter to write.
No shallow copy as it was the case before?
Does this need to be public?
I'm in favor of just using the iterator and remove during the iteration..that's unneeded.
When is it not identifier? And does this cover things like new OuterClass.InnerClass() or new package.Class().
Be careful, this method is probably used by core plugins
I think it would be OK not to throw an exception here; if someone has a description and a line number, that's fine. And then we could again just rename setLineNumber to withLineNumber. If we do throw an exception here it should be ConfigException.BugOrBroken, but I think it's simplest to just not throw one.
still relevant?
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
remove this too if it is not used.
Since RuntimeEnvironment is shared between all runs of tests, usually I have noticed a reversion of original settings - e.g. env.setHistoryEnabled(originalIsHistoryEnabled) in @AfterClass. I see tests passing but wonder if it should be done anyway for correctness.
This can be private again.
This method should be static and need not pass this as an argument to the constructor.
Why have you added this line here? This will automatically choose first local address and then switch to remote address if the ping to local address fails. Adding this dissolves the purpose of having Local and Remote mode explicitly.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
Use CommonImages.getImage to prevent memory leak.
constructModel already called merge up there.
application.size() -> application.isEmpty()
Same here: should be Branding, not ProductBranding
Tokens are somewhat sensitive. Don't think we want to print them.
Instead of checking for action!= null, i'd suggest to simply change the order of equals, e.g. return ACTION_PROVISION_MANAGED_PROFILE.equals(action) || ACTION_PROVISION_MANAGED_USER.equals(action);
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
We might use a NavigableSet instead if a TreeSet is used, I assume.
Should we set a boolean like: boolean successfullyProcessed = updateAgencies(); successfullyProcessed &= updateProposals(); successfullyProcessed &= updateAwards(); return successfullyProcessed;
Can you please add the name of the VM to the message, so that message will be more informative...
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
java @Rule public TemporaryFolder tmp = new TemporaryFolder();
can wrap and unwrap be called simultaneously by two threads, if not here you really need one pair of byte buffers
we don't need to change the Creation classes.
The upgrade method should run all changesets from liquibase-master.xml...
Why initialize this to a new OkHttpClient instance that is not being used?
This should have stayed camel case
Consider switching this to List<Object> instead of the unspecified List type.
In cases like this I would expect it to throw an exception instead of returning null. For error handling it's okay to diverge a bit from the canonical data (I believe they're trying to remove most error cases from the canonical data for this reason) since it can vary a lot from language to language how you'd want to handle invalid input. In my opinion it's better to throw an exception in Java than to return null since that forces to user to deal with the error instead of relying on them checking if the output is null :)
Need to implement
1. We cannot use 0 here (even though it makes sense) because internally, Concourse uses it as a special code to refer to the present state. I'd suggest using -1. 2. When you return the Timestamp use fromMicros instead of calling new Timestamp. Even though we aren't doing it now, in the future we may do object pooling for Timestamp objects, so its best to funnel everything through one static factory in case anything changes. I realize I didn't do that for the other static factories, but that was bad programming my part :(
Is there any specific reason of choosing NoSuchElementException over NPE?
This is a reason why I got 2 receivers.. The variant information is added to PushMessageInformation in the MetricCollector#updateExistingMetric: <LINK_0> Since it is already added in the NotificationDispatcher, it re-adds "existing" variant metric. By removing this line it starts to work correctly
Can the processor name be null?
I think this should be pushed higher in patch chain.
why is this public?
@fanifieiev the same above.
The fact an AvroMessage contains json bytes is super confusing.
intentional to remove the shutdownClientOnClose?
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
Should be pulled up to AbstractItem.doCheckNewName-it is not specific to Job.
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
Lets keep these methods internal for now (package accessible).
OK so StringBuilder(null) NPEs. Why are we calling format on something with a null tip? Why are we formatting that string as "null~5" when we know its not a valid reference name?
Check error code/description
Check first that target is not null.
Should the first parameter not be getTaskServerLogsByTag?
I guess I am a little uncomfortable with the use of checked exceptions here. This exception goes down through the request manager and (I think) tells us whether a user is admin OR SequencerServiceRecord that is being sent through is null. Since we don't attempt to recover and exceptions get logged anyways we have really done nothing useful with this exception. Here are some other ideas... ###### Options include: - Not throwing the exceptions in the first place and just doing the logging. - Throwing _RuntimeException_ instead so you don't have to bother catching and you get the logging for free. - Attempting some sort of recovery if this exception is caught (forward to 404 / 400 page). Personally I'm all about checking the inputs in the API before they ever make it to request manager. I think they call it _sanitizing your inputs_. That way you don't even try to save if things don't look right, you can just redirect to a friendly "Nope 404 / 400" page. It's a better user experience I think.
Scm api has rules on the placement of annotations for methods
Does the output stream need to be closed?
On my computer 1 ms is not enough. The test fail sometime.
![MINOR](<LINK_2> 'Severity: MINOR') Missing curly brace. [![rule](<LINK_1>](<LINK_0> ![MINOR](<LINK_2> 'Severity: MINOR') At most one statement is allowed per line, but 2 statements were found on this line. [![rule](<LINK_1>](<LINK_3>
This is obviously faster, but how do you prove the runtime performance gain outweighs the memory overhead of adding inward edges?
return ?
input is not @Nullable, remove annotation or add null check.
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
>byte[] [](start = 11, length = 6) DecryptResult
Exposing PojoProperties (an internal class) to API
This shouldn't declare throws Exception.
This is getting long, wrap wrap the arguments
The constructor already does this logic. Could this just be this.metadata = metadata?
Please annotate DruidServerMetadata.getName() as @Nullable. Please use Objects.equals(), or regenerate equals and hashCode using intelliJ
They are all TimeEvent instances in current implementation so TRANSPARENT can never be returned (it should for filler 'multiple' events)
Minor: move init to the beginning after the constructor
nit: This reads weirdly, since I assumed this was an enum and we were marking the CAS as successful. Given that we already branched on casResult.successful above, maybe this is clearer as false?
Let's refactor Topic a bit to be able not to pass anything there. We'll have something like new Topic().withBody("ab") and therefore other fields like title will be generated randomly.
You can use CollectionUtils.toImmutableList
We could the variable declaration and just use return decoratorClass.getConstructor().newInstance();
this should be catch (Throwable t)
It's possible that you should return relDataType here, if it is not null. I'd also rename the field relDataType to rowType, because it represents the schema of each row.
Use readAsString(...) instead
I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.
studentsWhoRespond -> studentsWhoResponded
Why not IllegalArgumentException?
Again since the validation is done in the UI, I think you can go directly to writing the GB response
I think this is unnecessary => "profile =" + this.profile is sufficient.
Same here, add deprecation flag.
you can make the same optimizations here as you did with the other ones: Meter meter = (Meter) checkCache(classSimpleName, fullMetricName).orElse(_metricRegistry.meter(fullMetricName)); and then remove the "if (meter == null)" check
Shouldn't this be transactional?
No need for super()
You don't need to start the execution plan for parameter validation scenarios
I think the chart viewer should be responsible for its own presentation provider. The tree viewer could ask the chart viewer for a series appearance directly, perhaps through the ITreeViewerInterface? (could be renamed ICounterChartViewer).
Should be a constant.
same here, I think it should be Files.createTempFile
Returning the first chunk of the stream before "\A" [implementation] and returning the entire stream contents [interface] don't seem to be in sync.
What's the purpose of this line? I don't see any difference if the url is correct or incorrect. It just clicks on the Verify button and then continues with clicking on OK. It would be nice to preserve the verification result. For example you can return it as String result.
add "this" qualifier
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Since a SAML Attribute map can have multiple values, the type here should be Map<String, List<Object>>.
I think you should also have if (c == null || c.length < 7) return; or else we'll hav an NPE
Please keep the getter and setter closer.
The ListenerList implementation already takes care of this. Remove the "contains" test.
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
We could omit the second Integer.
Please refactor to different methods
Any reason why this cant be unloaded?
Hmm, is this missing the .incrementVersion() call?
can't we use optional?
Can you throw ElasticProfileNotFoundException() if existing profile is null? the remove function below can be successfully run when null is passed to it, but the user won't know that nothing has changed.
Collections.emptyList()
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
No key for encryption? ;-)
you can inline the non null checks with assignment, e.g. this.packageName = checkNotNull(packageName)
Should it be logged at the error level?
Do we need a new BufferManager on every snapshotApply? or could we just reset?
When the result of Math.pow is 15.9999999999999999, numberBuckets will become 15.
please rename both variables: sortFilterCmd and updateFilterApplicationCmd
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName());
This test probably doesn't do what you think it does, because it verifies that EXT_ID matches with itself. (Same with several of the subsequent tests.)
Should make a differentiation of the name and id.
super.init() method never throw an exception.
Let's add a ctor for FeatureFlagBuilder(FeatureFlag f) and then make FeatureFlag immutable.
instead of thowing we could return an empty list
This can now become package private and be annotated as @VisibleForTesting I think.
Perhaps use mkdirs?
You shouldn't call onXXX methods while holding a lock.
could use a better error message like "Failed checkForChrashes call" also could dump the stack with a line "e.printStackTrace();"
This logic could also be moved into the Dependencies class.
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
Don't expose the whole list. Either a single getter getLocation(int), or an Iterable, or both if needed. And even when using Iterable, you also have to be careful for concurrent accesses. But in this case, elements are added to the array in loadXml(), which is called by the constructor. Which means that once this method becomes accessible (after the constructor has run), it should not be modifier afterwards. In fact, you know what would be clean? Putting the loadXml() stuff right in the constructor, and saving the fields themselves as unmodifiableList/Map's. Then you can expose an Iterable view, but don't have to worry about locking anywhere. Also, you often use List, when in fact the only operation to do is to iterate on them. If the order is not important you should use Set/HashSet (or TreeSet if you store Integers/Longs), it would be more performant.
Doesn't matter much, but we should throw IndexOutOfBoundsException("index=" + index). The operation doesn't have a missing implementation - it's implemented, but there's no valid index it can be called with. Same in EmptyRowBatch.getRow()
we can remove the status variable by calling "return deleteEndpoint(endpointName);"
verify(fragmentMap.containsKey(id), "fragment id not in map: %s", id);
types --> type
Extra space after synchronized.
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
Instead of defaultWriteObject, just handle it all yourself: oos.writeInt(hash); T object = this.object; byte[] buf = this.buf; if (object == null) { oos.writeInt(buf.length); oos.write(buf); } else { oos.writeInt(codec.sizeof(object)); CodedOutputStream cos = CodedOutputStream.newInstance(out); codec.encode(object, cos); cos.flush(); }
Don't you want to test PUT and expect OK here?
HiViATFShouldRequestForMEGAAdUnitVAST -> HiViBTFShouldRequestForMEGAAdUnitVAST IMHO :smile_cat:
style nit: we don't use braces around single line blocks
Why ignore the epoch/cluster id check?
should be called resources
For loop?
We don't align on columns.
Why do we return the parents name instead of the name we store a few lines above?
Collections.singletonList
Please rename this layout file as well removing _new_api.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Extraneous 'a'
filters method argument should be passed to isMessageInLogFile as an argument
I think we should make this default value as -1, util we have benchmarks show 500 is in general good for most of applications.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Can we revert this constructor argument change for classes that don't implement ResultBearing?
The orchestrator will pass down a connected client (i.e. it will have a layout ready) when it creates a workflow, why is this needed?
in case of switching, in my opinion it's better to us etry/finnally like that:  switchToIFrame(); try { waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); return new ArticlePageObject(driver); }finally { switchOutOfIFrame(); }  it's clearer in reading
@kujtimiihoxha Why not just "X-Netbout-Alias: %s" ?
since we're going to remove the vm anyway, this can be replaced with: if (startingVms.remove(vmId) && log.isDebugEnabled()) right?
Can use your new method TimeHelper#parseLocalDateTime?
I think we should remove a pair of parens:  mSession = new Session.Builder(this, mApiKey, mSessionId).build();
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
Let's make sure that no project uses this resolver. If there is a project using this resolver, let's throw an exception and tell the user, he can't remove the resolver because it's used.
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
Single if can be used here too
I do not understand why is this template, I expect: public void put(VdcParameter param, Object value)
Could you make this method protected? This will allow override it when needed
same issue
please replase MojoExecutionException for a new generic DeploymentExecutionException
Do the suggested changes before getting @lejolly to review.
I think the indentation is still a bit wrong here?
assert name != null;
brackets or nothing.
why do we want to correlate cinder and managed block storage?
you can fail inside of try block instead after db.execute then you do not need to have return statement inside your catch block; also you can use ExpectedException rule
Is it necessary to remove this setLocation on the child? I think this may cause a regression when docking directly from the palette.
Use this(...)
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
suggestion
wrong message
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
![MAJOR](<LINK_1> Make "applicableWithUncheckedConversion" a "static" method. [![rule](<LINK_2>](<LINK_0>
1. I wonder if this class can instead be made an util / or a function. 2. Should we return an Immutable collection or a copy here? That way, external callers don't mutate the map, and this class is immune to those changes.
same suggestion about static comparator
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
Not sure if vm can be null, it is already locked.
An IllegalArgumentException refers to a wrong parameter. I think an UnsupportedOperationException is a better choice here.
This is the only place that add entry to the pool, is it the only way to fill the pool?
remove extra line
An exception without any messages or stack traces.
I think this will fail if the new size is smaller than the current one. Could be checked with an assert (private methods).
No need to define "throws IllegalArgumentException" in function. It extends RuntimeException. public List<String> getAvailableSearchFields(String opac) {
weird indent (and some others @Overrides and throws)
Coding conventions: Let's have the @Override on its own line please
Declared exception from update method can be removed as well as this try-catch block.
public constructor in private class should be package level constructor.
Please, move this test to createTable.sql. SCRIPT TABLE TEST1 output is not too big and I don't see any reason to use custom checks for presence of substrings.
I believe that many AsyncKTR's can share a single HBaseClient, so it should be 'owned' by the Kiji instead of being shut down here. Let me know if this isn't a clear explanation.
Does this need to be public? It seems to me this would only be useful to call from subclasses, so it could be protected. Shouldn't we make it final in a 1st iteration or do you have use-cases that need to override it?
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
The version check should come before the call to loadTemplates().
the part where the pmwVendor fields are updated could probably be extracted in a separate method
blocking calls inside the SDK are not good. they can cause deadlock, perf hit, etc. We are not doing blocking calls anywhere else.
Consider a case where user entered a single quote ' in streamName, then the sql query can give a syntax error and the app will crash. I think it'd be better if we use ? in sql query and provide [arguments](<LINK_0>,%20java.lang.String...)) in queryRaw.
Remove extra empty line
You could also use path.endsWith("/")
Should be "InstaPost" actually.
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
This is another behavioral change that I don't want to see in an unrelated PR.
You already log an error if JNDI lookup fails, as part of getAuditLogger() -- do we need this else statement?
Perhaps create a named constant for the interval since it's in the asserts for several of the new tests
This is redundant in Mockito 2
ObjectUtils.objectsEqual(a, b) may help here.
Hm, I suggest to extract timer-specific code in updateController method into a separate method, for example: private void updateController() { this.controller = modelProvider.getModel(); } private void updateModelTimer() { // rest of code from original updateController method } If I read this correctly, we need to execute timer-specific code (i.e. updateModelTimer method) on each refresh rate change via GUI (i.e. setCurrentRefreshRate method).
Why not <code>return ExitStatus.COMPLETED</code>?
We could probably use getItem() method here, for consistency.
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
remove or assert ;-)
duplicate assert
Exception propagation. No need for subsequent return null
We definitely need more details about what is invalid about the configuration (e.g. which keys are missing)?
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
If you create a new HttpClient' all the time and start it, doesn't it need to be stopped again?
Why don't you pass the message in the annotation?
Please add ? and % as well
Why the change? This does the same thing as the original code.
suggestion assertEquals(1, IOExceptionOnOnlineListener.onOnlineCount);  I suggest following the existing pattern in this file and calling the assert() methods directly. Then the new import also wouldn't be needed.
I dont think you need the RocketMQ version number in the name here.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Please catch specific exception(InterruptedException) not generic.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
nullity check here too :)
I'm more for json and something like {status: 500, message: <message>}
may be try-with-resources?
not related to your changes, but it looks like this field is not used anymore.
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
return HConstants.EMPTY_BYTE_ARRAY; ?
This is wrong. We still need to use the folder name for equality checks.
Iterate the return value, no variable needed.
Should there be a ITimeLineEvent interface?
This this. should no longer be necessary here - could you please remove it?
We should just check for >= ICS instead?
should the interface not the implementation suggestion public List<String> getTopics() {
I don't see any change that is related to elapsed-time, why is this change needed?
result -> results
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
these setters should not be public
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
wouldn't it be better to return List<File> here ?
I think you can make the ResourceLoader a static class variable as creating an ResourceLoader can be expensive.
I would suggest reverting the isSytemLibrary field back
Why fakeThread
Please revert if possible
once again, equals/hashcode - does it make sense? please revisit in all value types you created
How do you know that tableName is not, itself, an SQL injection attack?
Overdid: if null, return null :smile: From other side it can't be null. See ctor:  Assert.notNull(inputChannel, "inputChannel must not be null");
remove this line
Why only adding it to the active window and page?
That does not seem right ;-)
It would be good to use constants instead of hard coded property names. Maybe you could use KFSPropertyConstants.BUILDING_NAME constant instead of "buildingName" or add new constants to CuCamsConstants.java
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Redundant with the e.getMessage? May be something like "Wrong class path: e.getMessage"?
please extract as separate commit
We may not need this method and can use gatewayResponse.getError().map(s -> s.getMessage()) instead in CardCaptureMessageProcess
It would be better to move this debug message to RepositoryStreamSupport#doClose or RepositoryStreamSupport#close
Have you looked at class HashCodeBuilder from the commons lang library (that we use)? It helps you build a hashcode, and its append() method supports null so it does not require any explicit testing. It should let you do something like (untested):  java return new HashCodeBuilder().append(uri).append(title).append(description).build();
for me it's too long. Maybe Result.wrap() ?
Not needed, delete.
instead of e -> e there is a Functions.identity()
setIsBatHanging(!awake) for same reason as above
suggestion return this.connectionPool.getNumWaiters();
Should also be externalized
Can we move this isAdded() check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
Ternary if?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
I haven't looked at messages.properties, but this seems like an odd message code. (Other?)
Logging.
s/possitive/positive/
Please remove an excessive space character.
this method should be defined in Menu interface
use an overridable getOperationTimeout() method instead
Similarly use the Java 7 template
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
I prefer flatMap for this. It sucks they left out Optional.stream() in Java 8 java return FACTORIES.stream() .flatMap(factory -> JdbiStreams.toStream( factory.build(expectedType, value, config))) .findFirst();
can use without "== true"
i think we should have a else here so we dont print the cwd if the user has enabled the help option.
Why not initialize them at construction time instead of lazily on request?
Why returning an unmodifiable map? The returned map is a new instance generated in this method. There should be no other reference to it except for what returned from this method. Returning a modifiable map would also save us from converting back to a modifiable map in getTaskManagerLabels and getConfigMapLabels.
Remove
why is this return null??
extra line
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
Just pass null as a parameter without variable (here and below)
this...
if those lists are intended to be empty list (and not be modified by the client) the always return Collections.emptyList()
Should mark @Nullable here.
protected static ConfigurablePageObject getPageObject(Jenkins jenkins) { return jenkins.getVersion().isOlderThan(new VersionNumber("2")) ? new JenkinsConfig(jenkins) : new GlobalToolConfig(jenkins); } ConfigurablePageObject configPage = getPageObject(jenkins); boolean onConfigPage = jenkins.getCurrentUrl().equals(configPage.getConfigUrl());
just inline this. ex. if configuration.getPercentage() is mutable config, make a final copy. This code is simple enough that it can be inlined, and there's no reason to require an allocation or another type to do this math.
I would not create anonymous class here to only add the item. It can be done with less and more "standard" code.
Is this change related to updating apache velocity?
From the wiki: Its fuse lasts 40 redstone ticks (4 seconds/80 game ticks) if activated by redstone or fire, or a random number between 10 to 30 game ticks (.5 to 1.5 seconds) if it's destroyed by an explosion. In other words, right here the number of ticks needs to somehow be passed down to the explosion objects (setFuseTicks). My recommendation is to add an overloaded method to explodeBlock that accepts a boolean: blownUp (name is just a suggestion). If that boolean is true, this 'random' tick count is applied, otherwise the standard is used. I would almost go as far to say that the boolean should further propagate to the explosion object that holds the fuse ticks so that magic numbers aren't all over the place.
I would change this test to ensure that the default columns are present, not in a specific position. so, something like: assertThat(cursor.getColumnIndex(COLUMN_ID), is(not(-1)))
what about:  SELECT x, array_agg(y FILTER y > 1 ORDER BY y), count(*) FROM (...); SELECT x, array_agg(DISTINCT y ORDER BY y), count(*) FROM (...);  ?
What is the purpose of cleanup? Clearly mention in java doc.
It can be null?
Can you try swapping below two lines in DefaultBlockWorker::stop() instead of this logic?  // Stop heart-beat executors and clients. mResourceCloser.close(); // Stop the base. (closes executors.) super.stop();
"%setup -q -n %{name}-%{version}" is the same as "%setup -q"
Why is this file changing? I'm concerned that changing domain objects will have far-reaching effects. As well, there's no id that this.id can be set to in this method
events.isEmpty()
return !sniDomains.isEmpty();
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
No tabs please.
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Consider limiting the number of characters to 32, since there are no HTML entities with more characters than that and it would help to avoid false-positive matches. <LINK_0>
why is it adding null?
Remove this by returning null above.
Internally Druid treats nulls and empty strings as similar values. So I think one workaround here is to do dimValue == null ? "" : dimValue Druid's handling of nulls and empty strings could definitely be better though.
unneeded else
can use Ds3DocSpecEmptyImpl here
You can write it directly notNull(subscriber).isApplicable(project); (Same with other places, with static imports)
json.toString().isEmpty can be very expensive. Just null check is ok
copy.setFromOriginal(this); -- should use this here ?
Refactor getRoles() and getPermissionTypes() to return the array and construct the response object here since methods don't really need the root as param.
spacing, code style
synchronized can be removed.
Change the second part of || to an assert (verify).
You could simply use getVdsGroup() if you extend VdsCommand
No if check needed, just always set the reference to null.
40?
This is another behavioral change that I don't want to see in an unrelated PR.
why is this public now?
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
Why do you have to check for null here?
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
post-content__title
What is a public goal of this getter? I'd prefer do not expose them at all to avoid undesired mutation. I understand the point for expression comparison, but it seems for me we have to encapsulte equals logic to the Recipient class. I think it doesn't hurt to have an extra GC from the removeRecipient(String channelName, String selector). Or from other side we should check the type of MessageSelector to get access to its expressionString
Are we sure we want to automatically purge the target directory here? Maybe we should say that the target directory has to be empty and fail if it is not.
Same remark about the constant
how about to move line 439-441 to be before line 435 - not because of performance but to make it more clear that in this case we don't need the cluster version
I'm not a lover of passing nulls to methods or constructors.. would another constructor without the contextId be better?
I think it is better to throw exception
This may not be thread safe if only one sender is instantiated. We probably only want one sender or at least only one httpclient.
That sounds right to me, although I'm not actually that clear on what this method does. What does the restore field that's being built here represent?
getGeometry call here is redundant, because OGCGeometry.createFromEsriGeometry(new Point(x, y), null) can't return anything other than point. Perhaps, remove it.
if at all possible let's try to avoid introducing more mess:)
socket might be null if an exception was thrown in sendToSocket catch clause.
Should be a SamzaException with a message, not NPE.
Can you re-route this to the new API ? Then we avoid duplicating this code.
These "duplicate" entries should no longer be required afaik, because @AddonDependency now adds an implicit dependency. Try it out.
I'm not sure I like the way it would work. You mean that before every request, I would have to call "login"? Doesn't sound very user friendly.
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
@prondzyn you can return numberth element of the collection
as long as it's the same event id that's fine i guess, though i don't really see a problem with using just one. but i don't mind
Call I18N.getString(String) (there are no parameters in the resource messages).
Single letter parameter names make code harder to read. I would go back to something like grainDefinition.
this seems to ignore the boolean removeVolumes parameter to the method
@aunyks you should make expected a Set to begin with so you don't have to convert the return value of the describe method to an array
nit: rename _lookahead to _lookAheadDays
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
should we have an early exit if the trace is the same? I am asking, I don't know
we can just call repeat(" ", n)?
It's not needed to check null, also inside of QueryBy.valueOf has internal check if the item is not one of enum items, exception will be thrown, should be changed to something like:  @JsonCreator public static QueryBy of(String value) { return QueryBy.valueOf(value.toUpperCase()); }
This conflicts with the commit message - either Uninitiazlied is OK, in which case the commit message should reflect it, or it isn't, in which case the check should be removed.
nit: I prefer the other ordering for <= or ==, it's easier for me to read "n is greater than or equal to 0" than it is "0 is less than or equal to n".
lun disks removal can't fail actually in the execute part, as it's a simple removal from the db..but i don't mind having it for the future in case we'll add ops that might fail.
String#split() is considered harmful. Use Guava's Splitter.on(";").omitEmptyString().trimResults() instead.
Same as above LOG statement.
tracef
You can use the string overload when TypeCriteria is exact match.
I think we need to specify the locale Locale.ENGLISH for SimpleDateFormat, to avoid a default system locale. Example failing to parse (simulating a German system locale): new SimpleDateFormat("dd-MMM-yyyy", Locale.GERMANY).parse("1-May-1994");
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
OpenToHalfOpenAutoTransitioner.scheduleAutoTransitionToHalfOpen() should be invoked in the Constructor of OpenState.
suggestion final List<String> lines = Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8);
ArrayList.remove() internally moves the positions of remaining elements and this will happen for every row in this case which could be expensive. Since parsedInputRows won't be large in general, I suggest to use an iterator on the list instead of modifying the list. java public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; }
this does not handle the case where actual is not null but expected is, which leads to a NPE, this case should be unit tested.
Minor thing, I'd prefer using getSessionId() instead of accessing "restApiSessionId" field directly here, for example: String sessionId = getSessionId(); if (sessionId != null) { requestBuilder.setHeader(SESSION_ID_HEADER, sessionId); }
seems to be like this should be before the vm is unlocked in super.endVmCommand();
InputColumn is a raw type. References to generic type InputColumn<E> should be parameterized.
Maybe we could have a method telling whether the repository is registered? In this way, the API would be much more consistent. TherepositoryFor is very strict and assumes the repository *is* registered, but there is no way to tell whether it is. So I would fill this gap instead of duplicating the API call with a very small lexical difference.
getter
what will happen after I will add new elements to enum?
nit, would 'bombarindUnits' be a more descriptive name here? Perhaps even consider inlining it to avoid the intermediate variable?
np: s/LocalApplicationRunner/RemoteApplicationRunner
Which method throw exception? why change assertThatCode -> assertThatThrownBy?
Can we inject this feature directly ?
Should be "InstaPost" actually.
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
Does this always run on the same thread? If not, it would appear we could lose the reference to a held wifi lock.
Can you make all of the accessors final?
This is causing a compile error. The REMOTE_USER cannot be found.
You can change the 28 case to a default case, and remove this.
huh this is creative, I've never thought to use an executor like this before
The WFLY-1069 stuff should tie into this.
use { } around if body
Maybe you could split this assertion int two?
You should be able to write @Test(expected = WriterException.class) and then the body of the test is just the line that causes the exception.
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
I don't think we use final for functions in our code base
You may want to change this to checking if enum constants has content, since there can exist both enum constants and elements within a type. At least within the Java generation, I discussed it with Ryan and he determined that when both exist within the same type, the elements are actually descriptive of internal variables that are not related to code generation. Therefore, if both exist, generate an enum. Not sure if its the same for the C generated code
This is a String so use final String id = THREAD_ID.get(thread) ; and then you don't need to do the cast on the next line.
can we bring it to config level
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Since leap-day/year-day aren't part of any actual month, you need to return the zero range
If leafCount is still 1, how could it be two rack groups?
what if key is null. I don't see any tests for this. What's the reasoning for shallow copy of the map? This changes the result and possibly impacts people who assumed it would not be a shallow copy.
For loop?
I'm not convinced by all these _URN suffix. An urn is basically a string. And any IDE can tell you its type if really necessary. I'd remove them all.
Why empty? It supports ALL streams!
I think you can use By.cssSelector("#" + elementId + "." + targetClass)
This should not be changed, you should only be changing search methods
I don't think it is right to return always return true for two different AuthorizationContext instances.
Should this be in line with YEdit's spaces-per-tab preference?
no need to break lines here?
just inline this in the enum? java public enum Category { CONFIGURATION(Messages._ManagementLink_Category_CONFIGURATION()), SECURITY(Messages._ManagementLink_Category_SECURITY()); //..... private Localizable label; Category(Localizable label) { this.label = label); } public Sting getLabel() { return label.toString(); } }
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
I think that it would be better if the result message used "Space" instead of "OrganizationalUnit". What do you think?
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
The method implements synchronization via  lock API, the synchronized seems redundant.
inline
Should null check, anytime you encounter a boxed value you always have to null check.
This can still return HistoryReferencesTable.
If user have used our listener in most common way (ethereum.addListener(new EthereumListenerAdapter(){})) he will get strange exception here, I guess.
isn't the currentRow the instance of RowBuilder which was just added?
you should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use org.apache.commons.lang.StringUtils.equals
Sorry, I suppose I wasn't clear. I meant that using == below would mean this check for null 'eref' and returning an unexecutable command would then not be necessary and could be removed. The idea being that perhaps the superclass would be able to do something useful (for example, look for a suitable reference and try again). So, let's remove this null check and see how that works.
you don't need use replaceAll, because above you used normalizeJson
method reference here as well -> anywhere we are calling a static method can be replaced by a method reference
Why is this method parameterized?
Should be "InstaPost" actually.
return listAllConsumers(props).stream().filter(consumer -> getConsumerTopics(props, consumer).contains(topic)).collect(Collectors.toList())
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
We should exit early if this.discardChannel is not null, no need to store this local variable in that case.
Should this method be public?
Please use interfaces where possible.
@xupyprmv are you sure that we should use anything related to ec2?
Second condition is unnecessary (checked in while loop below)
Should getDataProvider() only be called once in the method? And should itemIdentifier.equals() be used because it can't be null?
should we return false or null?
Static import
Could you explain the contract here in a docstring? If two arrays are different lengths why are they equal if they have the same content up to the length of the smaller array?
Have you tried this with an existing stream with applications deployed? I wonder if we can use the explicit streams/logs/{streamName} endpoint for this.
I'm not sure I like the fact we're creating 2-3 Lists and Maps everytime the "get" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register, so that the get can simply return the map directly (wrapped into a Collections.unmodifiableMap of course) ?
as with the others, need to "remember" the first via, not the last.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
all these methods can be private
Shouldn't this maybe be a threadsafe list?
- [x] I know you're just copying what I did, but then again I was copying the tutorial, so that doesn't make it good. It seems like we could just call ElixirFileType.INSTANCE.getDefaultExtension and ElixirFileType.SCRIPT.getDefaultExtension, leading to  java public void createFileTypes(@NotNull FileTypeConsumer fileTypeConsumer) { fileTypeConsumer.consume(ElixirFileType.INSTANCE, ElixirFileType.INSTANCE.getDefaultExtension()); fileTypeConsumer.consume(ElixirFileType.SCRIPT, ElixirFileType.SCRIPT.getDefaultExtension()); }
Use Logger.
Please follow the style guide in CONTRIBUTING.md to add this to field access. You can turn on > save action .
The configProvider is still required, isn't it? If so, we should still have Objects.requireNonNull(...) as a NotNull check.
This too would benefit from the (proposed) ConstraintType.EMPTY enumeration item.
I'm not sure we want this to work with Type directly or instead use Class here.
Does it make sense here to overwrite cookies with same name (i.e. check using name if already in list and overwrite rather than allowing multiple cookies with the same name)?
Do we have to serialize the state in Operator? I think the caller class would be a better place to serialize it.
same as for AddAddress here
I think in this class it is possible.
I think that we should send this event in task action logic Additionally used string constants should be added to task package into appropriate class
nit: space after 'if'
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
Would prefer to store the quark as a member of this class and keep the getThreadQuark method.
Guice best practices: make this constructor visible only at package level.
This is the topology at the time of submission, not the latest one, which is what you want right?. The latest one can be gotten from the current physicalPlan.getTopology(), but even that one doesn't contain updates to the config (e.g. parallelism) since creation. If that's needed see UpdateTopologyMaster.
does it make sense to add column features to the enabled features on a table? You also add features twice, eg the hideShow from tableconfig and the hideshow from columnconfig?
Its more efficient to ask the block directly if it is air, rather than the world.
please add populate() call before addLinks()
if ... return map.get else return null
no need for the manual check (especially for the unannotated parameter).
Initialize to immutable if present.
we can replace that with findAny/findFirst as we don't really need to know those vms
Should this include all the other fields a well?
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
remove semicolon
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Remove "()", (input) ==> input
Shall we change this to "Unable to resolve the hostname of the ....". there are few other places as well with same error message.
This should not use the --metadata parameter since that is used for object metadata. We should probably use a different parameter like, --datapolicy-id or something like that.
No need to have a final local var, please use an Immutable List from guava and please build it looping through the stack as it will involves less iterations than constructing a new list and slicing it.
Please add ? and % as well
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
We probably should log and rethrow this exception, correct?
We can use item.isPresent() as the argument directly.
Can we make these configurable now instead of deferring this?
you're testing for silence, but detect method returns true? shouldn't return false?
There's a Map-specific assertion class:  assertThat(results.get(0)).containsEntry("name", "eric");
Doesn't this duplicate the nonNull check?
Typo here. should be service_type
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so that it can be overloaded, can we do that too?
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
This method should return RemoteCache<K, V>.
Why not  java logging.setLevel(loggerName, Level.valueOf(newLevel.toUpperCase(Locale.US)));
Should be a constant of Run rather than RunQC
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
Should use the log, maybe a warning.
can you add blobId to the msg.
Ipv4 has the following code - "bootProtocol == null) ? Ipv4BootProtocol.NONE : bootProtocol;" Why didn't you adopted the same code here?
Can we point users to some kind of regex about how to specify these options, or what the valid values are? I don't entirely understand the format based on the docs and usage string here.
Is this an acceptable value for all metrics? Any way we can distinguish between a legitimate 0 value versus the case where metrics was not found?
can we use BeforeClass annotation?
Kinda nitpicking here but if you have addCacheEntryListenerConfiguration then add removeCacheEntryListenerConfiguration just to be nice and symmetric...
Shouldn't it be -1? No element in topicCounts map means this topic's count is zero, right?
!showButtons
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
Just "groupName".
refreshJob field should also be set to null on dispose.
What is the purpose of this conditional?
Why the change to AssertionError?
I think that deathdateEstimated was only added in 1.11.x, it should not be known in the context of 1.10.x compatibility.
I think in this case is best ignore sonarCloud. Not sure who's reponsible for the sonarCloud rules, but in this case I'd just ignore.
Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.
Cache file name string
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
@ccustine After this line, I would also indicate the service type for the provider: properties.setProperty(SERVICE_TYPE, ServiceType.BLOCK_STORAGE);
The default toString on the List doesn't do the same thing?
Can you return creationDate.clone since Date is mutable?
should the Builder constructors be private as they seem to be hidden behind the of methods?
if credentials is null should not execute mocked push
Optional should be used in interfaces. Use null as internal value.
Shouldn't a cast to int be enough?
suggestion 749, // CWE-749: Exposed Dangerous Method or Function  Or maybe: CWE-676: Use of Potentially Dangerous Function ?
Could delegate to base class instead, super.scan(msg, originalParam);
This logic is not correct since it would stop at the first '\r' in "// blah \r blah \r\n".
can the selection be null?
inspection is the only client of this method, move the method to inspection
Favor creating the exchange from the endpoint, eg endpoint.createExchange(...)
Why is it public?
Let's avoid changes in the classes not directly targeted by this pull request.
This should be protected and not public. @okulikov, can you go through your changes and change the access modifiers of all modified methods to be as limited as possible?
Would be a tad simpler to do: for (List<ITmfEvent> list : tbl.values()) { count += list.size(); }
There is no need for null checking in this case - second condition is enough
Why leave the burden of capturing the exception to the user?
Can we use BinaryUtils#resolveClass instead of making this method public?
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
Can we please add limit to the exception message? So it will be much easier to see the problem!
testType can be null, so it would be best to invert the equals() check as so: java if ("buckets".equals(testType)) {
If quality is an int, we don't need the check.
Same as above. If you don't have a valid publisher throw exception
if at all possible let's try to avoid introducing more mess:)
Remove the InterruptedException from the signature.
Why not reuse the ObjectInserter that you already have as a field?
Use parameterized logging instead of string concatenation.
Change log level to debug
Same here, but check the max cook time instead.
Not related to this change but this should be spelled "Cancelled" to be consistent with method "isCancelled" of ProgressMonitor.
element can be invalid at this point. Also you don't check what element it is. E.g. in case of batch inspection mode that was run on injected text, you'll get a file here as an element, I don't think you want to replace file with ""
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Worth including an entitlements check, because the return values could contain passwords retrieved from brooklyn.properties. For example, something like:  if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) { throw WebResourceUtils.unauthorized("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user()); }
"cwl" should be DescriptorLanguage.CWL.getShortName()
This is a bit too strong. You should perform the verification of the true and false expressions only if the type of the expression is Optional. With the current state, the following code will trigger an issue, and it has nothing to do with optional and is perfectly valid:  public Optional<String> bar(booleab b) { Object myObject = b ? null : new Object(); return Optional.empty(); }  With the following, it should work:  if (conditionalExpression.symbolType().is(OPTIONAL)) { checkNull(conditionalExpression.trueExpression()); checkNull(conditionalExpression.falseExpression()); }
Since you already kept the routingTable, is it still necessary to keep them as private fields?
Can we add a throws declaration to an existing public API, even if it's deprecated? We just reverted a change [1] because adding throws broke backwards compatibility. [1] <LINK_0>
avoid using \n, I remember windows contributors having tests failing because of such usage.
Recently, @yingsu00 removed all of the uses of the related form of getUnsetBits to not have an isNull vector. Her change had a good effect on memory pressure, and in some cases increased performance. I suggest we use the pattern she introduced in this new code.
Perhaps consider a constant for "NOTIFY" as it is repeated various times.
Small style nit: We don't use braces around simple statements.
@xpdavid is this the right thing to do?
Please move this check into the null check bellow, since we are already checking if this.key == null.
Please make the constructor private (see Invalid).
With the AtomicReference, we could remove the synchronization and just close the previous value we get from the getAndSet(V) method.
s/A submitted/The submitted/ s/task/event/ Also, is it possible to add some info here? perhaps the event's type or something like that?
The constructor should be made protected so that users can easily make a wrapper for it.
final
> implementation in load balancer module and interface def in query server module Correct. > Then load the implementation in queryserver module via service loader from loadbalancer module Yup > How do make query server dependent on load balancer module when load balancer has a dependency on queryserver. Is there any plugin to load the jars from loadbalancer into queryserver target This is what ServiceLoader solves. Perhaps you do not understand how ServiceLoader works? At compile time, PQS only knows about the interface. At runtime, both the interface and the implementation are present. ServiceLoader provides the implementation of the interface (based on the runtime classpath).
You don't need a transaction here
This is super silly. Never do this and read about java string pool. Just hit java string pool in google and you will see a lot of articles.
delete() should be executed from within the future so it doesn't through right away.
Why not call put in this class for atomacy?
Could you add a check to filterSteps.get to make sure it doesn't return a null? Something like this: Preconditions.checkNotNull(filterSteps.get()) Our code analysis check is complaining about that
> isAssignableFrom fails because the classloaders used between the two classes is different I don't understand, this is with a built-in policy implementation right? How can two types that belong to the same JAR get loaded by different classloaders? Regarding Dynamic-ImportPackage: *, as far as I understand this is the nuclear option, so I still see a value in allowing users to pass their classloader to the builder.
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of the url.
Be aware that if you update version.hashCode to take build into account that now this will no longer be correct since this doesn't compare with version.equals.
Mike spotted you're changing the formatting of private keys from "Utils.HEX.encode(getPrivKey().toByteArray())" to "getPrivKey().toString(16)". What's the reason? On StackExchange I read .toString(16) is stripping leading zeros. I'd personally prefer to at least keep bytes intact.
suggestion return !root.getParameters().isEmpty();
Under some conditions I'm running here into an StackOverflowError: java.lang.StackOverflowError: null at com.google.gwt.user.client.ui.TreeItem.getChildCount(TreeItem.java:371) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:538) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:528) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:310) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) ... One scenario in which I'm getting this error is when I filter for projects having the parent 'parent2' while having the following project structure: -- All Projects -- -> parent1 -> parent2 -> (project1, project2, project3)
IllegalStateException
I don't see any problem with prohibiting x-site backup to/from a LOCAL cache, but I'm not that familiar with x-site configuration and I don't know if it's possible to do that validation.
See identifiedElementQuery.getLabel()
Same as above, why not use try with resources?
String.valueOf() shouldn't be used to display integers since it doesn't consider the user's locale. Use i18n.number() instead.
BTW I think only the patch to getIconFileName is needed (cf. core/src/main/resources/lib/hudson/actions.jelly).  git ls-files -z | xargs -0 grep -lZ -- \\\(conFile\\\|rl\\\)Name\\\(\\\)\ \\\?\[\!\=\]\=\ \\\?null | xargs -0 ls -l
We'd better fail here instead of silently returning null?
@dalifreire let's get rid once time used variable
I believe the preferred method is to do one cache.get(nodeId) and then check to see if that result is null. I believe containsKey should be avoided.
The code of the CompositeReconcilerStrategy constructor should be used here, and in case there's only a single reconciler strategy, it should be returned directly.
Shouldn't you verify the mac is not null to avoid NPE? 'ImportVmFromConfigurationCommand' has this check.
I'm not sure silent catch is good as after that url is null and it will create exceptions
maybe get enclosing element before the loop ? or this operation is not very expensive ? Something like:  TypeElement methodEnclosingType = getEnclosingTypeElement( currentMethod ); for (...){ .... if ( elementUtils.overrides( currentMethod, (ExecutableElement) element, methodEnclosingType ) ) {
This correctly cycles back through the pager when the Back button is pressed. However, when the first position is reached, the Back button has no effect (i.e. the dialog should close when Back is pressed). To handle the final Back case, you could add an else here and say the following: else { super.onBackPressed(); }
you should check only snapshots of this specific vm
Shouldn't this be at line 134 ? Replacing .getClass() check instead of obj == null check ? Like in User object ? I know it will return false for null anyway, but this will also return false if you compare Member and RichMember which we wanted to be comparable. In User object you just continue with params comparison when you compare User and Candidate or RichUser. I believe implementation should be at least equivalent in both Member and User objects.
throws
Lets not catch the exception and just let the original exception propagate unto main.
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
Maybe check for if name ends with ':' so we don't do a double one?
Isn't this logic backwards. You want to return true if it exists so it should be Tribble.indexFile(vcf).exists() || Tribble.tabixIndexFile(vcf).exists()?
This is check in the overriden enqueue method. I think this check is extra here.
perhaps if not has permission?
"isSearching" should be a class level string
I guess that if "columnToBeSortedOn" is null (sorting is turned off), we should not write to a temp file. We should write to the final file directly. So maybe let's rename the "_tempFile" variable and call it something a la "_targetFile". And initialize it according to the null check.
Could use '/' and ']' to avoid the need for extra NON-NLS
Please use lowercase as it refers to the argument: disposables is null.
probably best to use getIntInRange() here too to avoid negatives (I think I didn't know that the function existed when I first wrote this).
@NielsCharlier consider refactoring this to use Java 7 try-with-resources.
should this have a ,  to match the rest of the pattern?
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
entryId is not used, please remove
minor: this not required anywhere.
requireNonNullElse is better
Might be worth having a displayName?
I think this should be stripe_account_id ? as per PP-4302
*ws* is being removed automatically at the pre-destroy step. Instead, of that, we need to try removal of workspaces with name **MIN_WORKSPACE_NAME** and **MAX_WORKSPACE_NAME** which could probably remain after the test execution in case of failure.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
I'll check later, but should this be doesUserHaveCollectionAccess?
cast to busimpl should not be needed. getClientId is on the ClientMessageBus interface, no?
Let's use seleniumWebDriverHelper here
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void bitreserveClientWithTokenShouldSetTokenAndRestAdapter
Not sure, do we really mean to pass null as the idToken to the new instance here or should we use the provided idToken parameter instead? I think that Scenario No1 fails to complete the account connection because of this.
public static? Is that keyword ordering important in this codebase?
please, also check at least elements count
why this was changed here and not in the master?
Throw exception instead of logging it
I think ideally we would also extract IngestionEndpoint from the connection string and not expose endpoint() directly
do we also want to check cleanup of key B 3 if it were in the map?
null is not handled in the callers
Use readAsString(...) instead
You'd still want to tear it down. How about using a straight-forward if-else ?
if else would be better.
Is this needed?
log()
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
won't there be an NPE if upServer is null?
Shouldn't this be a field so we don't have to create one each time
While we're renaming, might as well remove that extra _.
Core.ID
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
I've got a fix in a PR that [removes the watchManager](<LINK_0>, so let's just make sure that doesn't get squashed by this :)
Also you missed similar fix in the lockInterruptibly() and tryLock()
@jackyq2015 best to wrap things like this with URL encode as a best practice.
you should account form previous page too
Rename to "finishRefAndObjSections" or something since it may be closing the index block section or index.
dont think a setter type function should return the "this"
Can't we instead of that peculiar disable/enableClose return here a wrapper with the empty close() impl and invoke delegate.close() in that releaseConnection() above? Something similar we have in the Spring Kafka: <LINK_0>
What if type is not Class type?
simplify this to  return getVarArgIndex() > -1;
This is a very costly operation finding the event size every time, can't we do any other optimizations
Could you please replace event.getTarget with a variable to make it clearer
You can use StringUtils from the commons.lang3?
please change this to getById
Please add at least of project in order to check that the result is empty because it return an empty list
No tests to cover this method! :open_mouth:
Is this the most typical case? I would have thought most chunks aren't null and such I'd suggest flipping the if/else block.
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
Do you mean s.length() > len?
> 0
what is this supposed to do?
I still think you should throw an exception if name is null
@marchof I'm wondering why in case of invalid command exit code is still zero?  $ java -jar jacococli.jar test $ echo $? 0
Should throw at construction time instead.
This cannot work.
Not related to this fix, but can't we get rid of this extra InitializingBean operation and just getSSLContext() directly in the ctor ?
Try using StringUtils.isTruthy(this.path)? <LINK_0>
SCAN_MBUS_CHANNELS
this can be static (most likely will need to be)
Can use Objects.equals here
just need log.warn("msg {}", ex.getLocalizedMessage(),ex);
Why are we removing the call to hsync()? hflush() doesn't guarantee that data has been written to stable storage.
Exception again
instead, can you put this.previousStop = (previousStop == null) ? "" : previousStop; in the constructor of LexicographicTopNMetricSpec and here , replace line#191 by this.previousStop = super.getPreviousStop() ?
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
This can be dangerous because if someone supplies microsecond resolution it will be 0 ms, thus will trigger an exception. You should rather use getDuration().
Here you should also use the assert, since the else branch also only throws an IAE.
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
remove tabs
Perhaps we could look into making the deserializer more flexible with respect to encoding issues (just like it can be configured to accept unescaped tabs)? I have not checked if it is possible though.
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
Add the original ClassNotFoundException as cause.
The constraint here should be on the consumer key, since on the old job the TARGET_TYPE is a consumer, and TARGET_ID the consumer uuid.
can you pull this from a static string?
return Platform.getOS().equals(Platform.WS_WIN32)
It seems this variable is not used, can it be deleted?
why change the readability status here?
This method publicly exposes a field that is otherwise lock-guarded. Would be good to avoid that, or at least not in the production scope. You can do the following: - pass this directly to the constructor of SortMergeSubpartitionReader - reduce visibility to package-private and annotate it as @VisibleForTesting.
Let's only use DsfDebugOptions... as mentioned above
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
extract method
I think it should be return executeCommand.execute(action, resultCallback); else you lose the "good" DispatchRequest in the process.
do we want to keep this non-null if there is an issue with dispose? Basically, should we set it to null in finally or here?
Remove this if statement and let the code below handle the null case. It will nicely print out the existing repository names in case of nullOrEmpty.
I think the return type should be IborFutureTemplate as AbsoluteIborFutureTemplate is package-private.
Use FileUtils.mkdirs
+ desc
you import ByteBuffer, no need to use the full package path
Collections.unmodifableList()?
It looks like this makes it case insensitive if it's otherwise an exact match, but case sensitive if matching a subtype, which is really an odd thing to do.
please just define on the next row.
It's hard to see why one would care about having a stored value that's not current, and indeed it seems that this method is only used in ImmutableComputableGraph::statusToString, which is never used.
Is the check for trailing Path.SEPARATOR necessary ? We just got the IntroTheme.ATT_ID property which is not supposed to have a trailing Path.SEPARATOR, no ?
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during the git clone or other editor that changed the encoding. On my clone :  $ file src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest.java: UTF-8 Unicode c program text
Looks like its only usage is in the CommandBus.Builder, so let's hide it from the public API.
Same here: should be Branding, not ProductBranding
This method might be the one in public.
You can make this file File
use an overridable getOperationTimeout() method instead
can jsonAsString ever be null, seems like you create a PhoenixJson object you it will always have be from a string
Is this really correct? ASCII characters would include all 128 defined ASCII characters, but the actual limits are smaller: <LINK_0> Perhaps this message should just spell out the requirements exactly: A letter or number, followed by letters, numbers, dashes, dots and underscores (underscores are not listed in the whitelist, but anything else is replaced by an underscore, making the underscore implicitly allowed). Maximum length is 63 characters.
If any of the parts are null we'll end up with different strings for id nothing missing -> name/tag/instance/taskhost if tag is null for whatever reason now string is name/instance/taskhost.
getClients(this, null, null)
Seems redundant to have both static factories and public constructors in the public API. Especially when there's multiple overloads such as in some of the other processors. Can we choose one and expose only it?
return columns.stream() .map(HiveColumnHandle::getName) .collect(Collectors.joining(","));
don't need to throw exceptions - just return null.
I'm not sure it should be public from start. I have a rule to make public as less methods as I can. When you declare some method as public you must not remove/rename/change arguments of this method. So better to declare it less visibility unless you are sure it should be public
Since you now have ConcurrentHashMap, you could cimply do return patternDateTimeFormatterCache.computeIfAbsent(pattern, DateTimeFormat::forPattern)
An IllegalArgumentException refers to a wrong parameter. I think an UnsupportedOperationException is a better choice here.
UnknownHostException not necessary here
This does not reflect the tryLock(long time, TimeUnit unit) contract. We may obtain the local lock but should wait for the result from DB exactly during the desired time. Or even better for the time which is left after the local tryLock. Can transaction timeout help us here ?
You don't need to set the Id here as it's done in the setup() method (but does no harm and makes the test clearer!)
exception does not need to be caught.
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within addToResponseBody()?
One concern that I have is whether this method is only used for the determining the next billing period start date. I want to make sure it does not inadvertently affect offer parts of the application.
this view is using the same context. what about if you use the context from itemView.getContext() instead of passing a new parameter?
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here.
you could just do setConfirmWindow(null); like above method
Are we guaranteed that tokenString and tokens will always be not null when the extractStringFromTokens method is called? If not, then while (tk.hasMoreTokens()) wil throuw a NPE. Reference: <LINK_0>,%20java.lang.String)
Style-nit: no brackets around single-line blocks
Seems like this condition is "No table manager found"? Should this log be on a null check for tableManager.getTable?
Remove extra empty line
What if we don't want to set it? How does the UI know that this has happened?
Check isDebugEnabled()?
@lorobode Can you update these setters to use builder pattern and return LinkedContact object.
Can we take the code that is in ensureCredential today and pull it into the constructor now? It's the only place we call it now and it will simplify things.
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
if mockTime was incremented by exactly the time required to trigger the operation timed out error, why would we need a loop?
Shouldn't this be log.trace?
@Nullable but actually, why allow null here?
Please use [ExpectedException](<LINK_0> You can look at the [phone-number tests](<LINK_1> for an example of how it's used
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return the status of #cachedVds ?
You can use ExpressionUtils.methodName(mit) for that.
Shouldn't the super.onXX() be the last call?
It always convert rows to BinaryRowData for comparing. Could we additionally compare the RowData directly when checkClass is true?
should we have Objects.requireNonNull in these?
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
This remove will not occur if the group or store removal fails and the scheduled future is already "spent". We need to reschedule in that event. Same delay?
Nitpick: windowId > Stateless.WindowId
looks like duplicate code, can it be refactored so it's not in multiple places?
This function no longer needs to be protected. It should be private.
Shouldn't this be wrapped in a try... finally block?
I don't think we want to automatically announce support for spoiler messages. The XEP is pretty clear that if a spoiler message is received the content must only be displayed upon user's request. But this can not, or only with to much effort, be guranteed on the library level. I think we should remove the automatic announcement of spoiler messages and instead provide a method the user explicitly has to invoke in order to announce support for spoiler messages. As beneficial result, the whole automatic manager initialization boilerplate code can go away
@Happy-Neko Let's call this from, [avoid compound names](<LINK_0>
why cloneContextAndDetachFromParent()? that means that under the tasks tab the child commands won't appear under the create snapshot for vm.
replace with: Mono.when()
So before this change, it would make sense to return the reference to the stopped service, since it wasn't part of the API that we supported re-initializing the ErraiService. But if we are going to allow that, maybe we should be checking isInitialized() here, instead of just service != null?
catch throwable in activate method
Should this be put in the try block so that the exceptions it throws are wrapped?
Could remove the else
throw NoSuchEntryException to keep it consistent with asyncReadLastEntry.
A ternary statement is fine here.
add null information
what about:  SELECT x, array_agg(y FILTER y > 1 ORDER BY y), count(*) FROM (...); SELECT x, array_agg(DISTINCT y ORDER BY y), count(*) FROM (...);  ?
This is a change of behavior. Some tests might not require all nodes to be up and trying to enforce that here seems like a stricter check. The earlier check createKVS can succeed if we have quorum too. We can perhaps have a classRule in the test classes to disableAutoCompaction if thats the first thing to do? Does this nodetool command require the node to be up first?
Is this if needed since there is no else for it?
Provider.class is very general, could end up returning providers of other types. Simplest solution (if we want to pull in injectors registered by other sources) is to track Injector.class - or we could create our own interface that extends Provider<Injector> that other people could use.
style nit: no braces around single line
i'm not sure i would put possibly deleted. i would suggest leaving that part off, or, since we can determine that, figure it out and then put it if applicable.
Please add ? and % as well
Maybe IOException since it's supported here?
This should be written this way. We also have to keep the code readable.
As a nit, should have a null guard here.
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
why synchronized?
This should really not be public.
Does this action exist in material_select? It should, but need to make sure.
Great tests. I'd suggest using nio (Files.copy and Paths), rather than bringing in the dependency in the org.codehaus.plexus util, that is available now, but is not listed explicitly in the project dependencies. For simple things like these it's almost always better to use standard java library stuff in tests.
I prefer to leave this as package-private to avoid a synthetic accessor.
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
you should do the ImmutableList.copyOf() at the constructor, and here just return the list directly. This will ensure that the constrcutor's caller cannot modify the list stored in this class.
Nullness of this is already tested in computeHashCode().
missing a final
Don't need to start at zero every time, keep a static var holding the last returned value. A from-scratch search will need to be done every launch which avoids any issues with uninstalled mods.
Well it would be the more correct thing to do if we didn't know how the viewer was implemented, but in practice both method implementations are identical in TableViewer and they return the same control.
For me it looks very strange that for initialising collections we use two different approaches within 5-line method :) (Guava and java.util.Collections) I would prefer to have homogenous approach (at least within the same method) doesn't really matter which one.
We should use other method, this ends up creating an AccessControlScannerThread unnecessarily.
Could refactor this to something like the following, this would reuse code in super class. java @Override CompletableFuture<Boolean> getMainOp(CommitData cd) { return super.getMainOp(cd).thenApply(b-> { Preconditions.checkArgument(b); //expect this to always be true.. was not sure about adding this but decided its good to make few assumptions about the super method cd.commitObserver.committed(); return true; }); }  I was trying to make this shorter by using thenRun() but the void return type threw me off.
i think, passed collections cannot be null. Can we put a null check?
No need to log here.
I would prefer  return this.archiveId == null ? TestNameTransformer.getTransformedName(getFullName()) : TestNameTransformer.getTransformedName(getFullName()) + "[" + this.archiveId + "]";  or an equivalent. We should not be allocating a StringBuilder for the verbatim case
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
can you pull this from a static string?
You change some methods signatures/arguments into _*NameCount*_ but these methods still containing _Segments_ wording
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Uneeded spaces
Maybe, but I like simple and dumb unit test, this test checks that the service is started and well initialized, we don't need to test that on all tests. I don't see cases where a Before something is useful to understand failure in this case.
possible exception
I think I mentioned that: there should be a new test regarding validation of this attribute in ElasticsearchSchemaAttributeValidationIT. Unless I missed it, there isn't any?
Same thing as above, let's split out a config for this.
Do you forgot to compare items and label?
Index could return a List<Question> instead of List<Long>, right? The less logic we have on the controller, better
Don't block the merge on this, but these three System.out should probably be handled via logging
If you would like to do lazy initialization for the singleton, then you will need to be careful about concurrent calls to getInstance. This class doesn't need lazy initialization, so you could just initialize directly when declaring the static variable. Then, you won't have to worry about concurrent calls.
We always use brackets, even if the if only has one statement. Same goes for the else clause below.
This class is still beta--I would be OK just making this method non-static and using the registry
Instead of changing the method that is getting called, the missing one in search query can be added here and it seems the updateDomain method in managementserviceimpl is not in use. It can be removed
new ArrayList<>(Arrays.asList( should just be Arrays.asList(. you may have to do a Ctrl F and replace all.
Can you handle parse error here?
Why not public access?
Still why do you need to make separate subscription for each separate RemoteServiceInstance and keep separate future map for each service instance. Single future map and subscription would be totally enough for the whole system.
Find / replace mistake
Changes this to: return newKeyExpression( colKeyExpr.getDatum(), colKeyExpr.getPosition(), // This will cause the IN expression to be removed from the where clause and // processing to continue for subsequent row key columns Collections.<Expression>singletonList(node), // I actually don't think this is used anymore, so I'll remove after I pull your change in. // Instead, the above extract node list is used where this was before. But this is now // an equality check instead of a filter between the min and max in the list list. true, ranges, node.getChildren().get(0)); 0
Should not it be [less than 20](<LINK_0> ?
key.setDataId(event.getId()); -> key.setDataId(event.getDataId()); This issue was the culprit for failing on itest profile. I am going to test the cluster profile to check if everything is green also.
Maybe make it protected instead?
Above three lines are duplicated.
Once we start using placeholders, the getString() API can actually support it via additional parameters; it's pretty cool. suggestion String dialogContent = getString(R.string.confirm_deletion_message, " \"" + listName + "\");
It would be nice if we didn't return mutable copy of metadata here
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, (0xff & (hostAddress >> 8)), ... }; try { inetAddress = InetAddress.getByAddress(addressBytes); } catch(UnknownHostException e) { return null; }
i think it's slightly better to add one more argument in AzkabanFlow constructor called type, and let builder handle the default parameter passing.
We should probably log something if there's no provider. This might save someone some debugging time
The same as with previous - make it final, don't check for null (reduce amount of lines)
nit: remove else {}, throw exception after if block.
Consider to do this only once in the onInit(). Even if it is void method call, it is still a CPU tick on every single incoming message.
change to charge_created_successfully
I'm not sure why you remove hidden cards here.
make function synchronized. Res: done with syncronized block
Strange parentheses here ( selected), maybe this was a cast before?
Please don't use System.out in production code ;)
Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it. Maybe a link to general information about Validate Requirement Changes so that we could add other things as needed. An this would just be one of them.
Please put entry.getKey() in a local variable.
Better to add the exception as the second argument
As we have ALL, I think you can just add only ALL here.
![MAJOR](<LINK_1> 'Severity: MAJOR') Call "tagName.isPresent()" before accessing the value. [![rule](<LINK_2>](<LINK_0>
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
please fix the whitespace. You just need to return the options here.
We might use a NavigableSet instead if a TreeSet is used, I assume.
This inevitably is linear. What about key-ing tasks contexts by their ID (maybe as a separate structure in this class)? Or persisting returned value in UpdateSystemMemory?
Could this be a static field?
just use a raw string here no need for String.format
we don't need to check other == null here, the next condition check covers it.
KernelMemoryAnalysisModule
consider merging both lines
Will * <LINK_0> * <LINK_1> work as well?
I hate 'this'.
It looks like this makes it case insensitive if it's otherwise an exact match, but case sensitive if matching a subtype, which is really an odd thing to do.
IMO should be reverted; see discussion below.
This can be simplified to return this.cmd.hasOption(optionName));
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
suggestion throw new UnsupportedOperationException();
why not use super? like: return String.format("%s, volumeId=%s", super.toString(), diskImage.getId())
Swapping the order of parameters would be more consistant with the standard method this replaces/wraps, ResourceSet.getResource(URI).
This will silently ignore the exception. Should be throw Throwables.propagate(e);.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Why do we need double logging here? One when logException is called and later in 101-102.
I think keyStore and keyStorePassword should be used here for replication ClusterA -> ClusterB (or both sides can use both keystore and truststore if mutual authentication is enabled)
better to have fail(); in the onSuccess()?
This assertion is probably not buying us anything
final Set<Type> majorTypes = EnumSet.noneOf(Type.class);
You can make use of early returns here to reduce nesting, e.g. java if (userInfo.isAdmin) { return; } if (!userInfo.isInstructor) { throw new UnauthorizedAccessException(...); } // everything else
Is it really filter name?
Cache this value.
This should return T.
Should this throw IllegalStateException? Seems like bug case.
Missing super() call?
You should be able to delete the try-catch here.
I don't think we need to observe on any particular thread
You're not checking the mediatype here. At this point, do we just have to assume that jax-rs has called the above method and is giving us something sensible?
remote this
Why is this change needed? if so should the deprecated method not call this one.
bad hashcode.
The return type should be IEclipsePreferences so as not to expose an internal implementation in a public API. Curiously, I don't get a warning here, only in EMFCompareRCPPlugin. Don't know why, but must be changed anyway.
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
I don't think replacing the bus and dispatcher proxies is a good idea. There could be references to the old proxies that are held by other classes. Like this proxy, you will probably want to reset these bus/dispatcher proxies and close the same instances again.
Use java.util.Objects.equals().
This method doesn't clone the extra components nor the formatting
equals!
This log will be shown pretty often..
why have extra lists on heap?
we never use NULL, it is a bad practice in general.
How is this expression different from "this"?
Throw an unsupported operation exception here.
Generics on the right side are redundant since Java7
Could probably replace these hasSize+contains calls with containsExactly, but nbd, this is what the existing code had.
Maybe consider moving this if statement where you call the method instead of inside it
Please move to a separate "Polishing" PR.
Typo: The file already EXITS :) I would also be more explicit in the message: "The file already exists and the columns selected do not match the existing records"
extract as constant?
Maybe make this "Initializing monitor for..." to distinguish between the init() and configure() method below.
n["+fTimeArray.length+"]("+min()+'\u2025'+max()+')';
can we use BeforeClass annotation?
Run formatter
Probably we should log the exception here (debug or trace), just to help with troubleshooting
Could there be value in adding a warning statement if we detect current being 1000ms less than last? That could indicate a clock drift, which might be worth logging (although we wouldn't want to spam it(.
These two assertions should probably be their own tests, testNullPath and testNullPathWithRoot respectively.
This might cause null pointer. Consider using Objects.requireNonNull wrapper.
Would you also add an IS_NULL filter here?
Hi @diegolovison , I think the message here should be not stopped but: Pattern.compile(".*\\[org\\.jboss\\.as\\].*started \\(with errors\\) in.*"); (at least this is how it was before Gustavo's changes) Would be great if you will fix that too. Then I will rebase the PR as I am facing this issue too.
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
Why exception is logged and thrown? Any reason?
This should return a builder with the current options set.
optional: This message doesn't look so great --- isn't it a valid ref name, but just a missing ref? We can avoid the test being too prescriptive by making the matching less exact (e.g. by checking that the message contains the ref name). Alternatively, a followup change could improve the message.
These should be inline - not required for testing
catch IOException and rethrow to avoid wrapping an IOException with an IOException
nit: space between if and (
dimFilter is non-null, so could be simplified unless you want to stick to "as IntelliJ generated" form.
add "this" qualifier
Is this necessary? If I remove the update line everything seems still to work.
It should probably return ISegmentStoreProvider
Should return ReadOnlyArray.
please change this to simply return Objects.hash(...) to keep the boilerplate/LOC down
Shouldn't a cast to int be enough?
Not your change - we should actually set this to the saved stdOut - ideally saved around L85 (now L97) System.out
Please use MiddlewareRequestException and add the message in mw_messages_es.properties
suggestion return Framework.getService(FileManager.class).isUnicityEnabled();
we shouldn't need the ?test param any more
This should invoke the other constructor so that taskData can be marked as final.
remove mRoles
This does eventually emit the CompositeException. Is this consciously wanting to handle each error individually instead of only via the composite?
suggestion + "'><label id='labelId' someattribute property-binding='[[foo]]' "
Better to throw an IOException.
check it like this - disk,getDiskStorageType() == DiskStorageType.IMAGE
You can replace the screen position click with TestUtils.toggleNavigationDrawer().
new ArrayList<>(causes);
TrackType parameter not needed.
throw UncheckedIOException(e)?
please make sure you are rebased. this method was renamed on Feb 11.
So, this method now looks a bit odd: it invokes just obtainConnection() independently of this.isSingleUse(). I can guess that synchronized(this) makes sense in case of !this.isSingleUse(), but how about to move the synchronized(this) to concreate implementation of AbstractClientConnectionFactory#obtainConnection() ? From other side it looks like we should use ReadWriteLock around theConnection. Let me know your opinion and I'll push polishing
Don't you mean lessThan(second.getLowerBound())?
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
Please add a space after (Class<E>).
never null
this constructor feels wrong now... I think it should be a Module and a Definition and then the constructor calls getCombinedGrammar.
return authentication.getUser(username);
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
If the ping cannot be sent, would it maybe mean the connection is already closed? Would we also want users to submit bug reports whenever this happens? I suspect we may want to no-op if the ping cannot be sent.
We can use bit-operators here to test for the bits in the permission bitmask :) Executable is 0b001 = 1 Writable is 0b010 = 2 Readable is 0b100 = 4 So we can replace this with: java return permission & 4;
reduce to debug
Also add: - plugin_type - this will be needed if we have more than one driver installed, and if we ever attempt to do automatic host install
This must be implemented.
setReadTimeout and setConnecTimeout accept values in milliseconds, you're putting seconds there as I can see. :)
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
You can change the 28 case to a default case, and remove this.
You can make the return type here more specific so that you don't to cast to SchedulerTask elsewhere
Apply try catch to this line only
I think it should be NegativeLocationFilter (like the class name), as there is another class called NegativeNodeLocationFilter
Why is this if needed?
Question: What would the returned URL look like for a local JAR? Could you give some examples here?
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
This can simply return NON_APPLICATION and isApplicationType() can be removed. The methods will always return false.
Don't you need a super.setUp() call here?
Why do you include the size of the binding set as part of the hash code?
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
This should be ISE. Also, it would be better to check the exception message as well. Please refer to AppenderatorDriverFailTest as an example.
More user-friendly to say "', only Switch, Number, Dimmer, Rollershutter and String items are allowed - please check your *.items configuration"
maybe getReturningItems, the clause suffix is not really informative.
This is unsafe, since attributeType is protected and can be set to null, but the contract is to return supplier only on non null values. This must be rewritten to check for the null value first.
Do we really want to sleep for 1 sec? Also, with a constant sleep time it is possible that one thread gets starved of locks, if other threads keep jumping in. Might be worth sleeping for a random amount of time, say between 50 and 300 ms. Also, you're not converting time to ns here.
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
Instead of making this string concatenation every time, do it once in the constructor and cache it to the field.
script services must cope with nullable values. layoutExists is not nullable thus please keep the null check additonaly before the layoutExists check.
Perhaps you can remove the temporary variable entirely and use map to make this method a one-liner?
change
So that is getting a thread that is local so as to get the classloader?
looks like we're only updating the timer metric if it's a writeAround cache. I'm not sure if we should do that - metrics should be updated regardless since you're measuring the time it took for the "delete" operation right?
No need for super()
nit, Collections.EMPTY_MAP?
isSecure() return true if "coaps is used and false if "coap" is used. The naming is not so good with the OSCORE addition (so maybe we need to rename it but later.) So in this case isOSCORE should not impact isSecure()
We can get rid of the above variable
Is it just my tired eyes or is this backwards?
Please use -'getExistingNicsBusinessEntityMap()' instead of directly- 'existingNicsBusinessEntityMap'.
This commit appears to duplicate changes from the #430. Is this intentional? Which branch do these changes belong on? They should only be on one or the other. Please amend one of the branches to fix this.
you should add isAfterOrEqual and so on
Given the other changes, I wonder if the handler is needed at all or whether just need a way to disable it. If keeping it, I wonder if onReceived(Map<String, Object>) and onProcess(Map<String, Object>), and then all _received_timestamp and highWatermark logic could move into the handler.
This is always non-null. load() throws an AggregateNotFoundException when an aggregate can't be found.
This will delete all queries in the application.
And get in the end to check that there is nothing in the collection on the matter.
Just use Collections.addAll(...) ?
suggestion
Can be private, I think
This method is a good idea! I know I'm nitpicking, but may I suggest to skip the contains() call and just do a get() and if null, then return defaultValue? This will skip at least one MultiMap call.
throws IOException can be removed
Use Widgets.isAccessible(shell)
Wrap up in a SamzaException or add separate catch blocks for general exceptions and SamzaExceptions if you'd like them to be treated differently
Instead of allowing null for additionalClasses, I think it would be better to use an empty collection, and mark the parameter NonNull (or use ParametersAreNonnullByDefault). I suppose we need com.google.code.findbugs:jsr305 on the classpath (scope: provided).
You could add a check(String sqlQuery, java.util.List<Row> expectedResult) to FileSystemITCaseBase.
You can write this in a more compact form by reusing the return value of StringBuffer methods, e.g.,  String string = new StringBuffer() .append(method).append("\n") .append(endpoint).append("\n") ... .build()  And actually this is equivalent to just using + for concatenation.
This empty is unnecessary, I believe :)
What is the reason for appending 1 to the variable name?
why have you delete metricName (metric id) from hashCode ?
Suggestion: maybe call these encrypt64CharacterKey and encrypt32CharacterKey or something instead of encrypt and oldEncrypt; the latter doesn't provide a lot of insight into the difference, and will just need to get renamed again if/when we change the algorithm again.
final missing. Same for the other ones.
Actually _all_ components have a distributable flag, so you shouldn't filter on analyzers here.
I would suggest create method for computing that selector and instead of replacing strings we can use string concatenation like: String.format("div.autocomplete div[title=\"%s\"]", toolName); Or we can use that inline here.
decrease to TRACE level
Looks like it should be s/location/expiryQueueSize/
Any particular reason that you published an EventStatus instead of publishing an EventOutput directly? Remember that pumpEvent exists.
Best to avoid logging any passwords, some end users will actually audit log files to ensure no passwords are logged.
Check for equality of error code
we should not declare to throw generic Exception
Again, use IOUtils.
Optional
Not sure if there is any chance that a trigger has no context or context=null. In that case, this will throw a NPE. wdyt?
nicer to have a method IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
Have you intentionally omitted index check?
As setInstalledLineNumber, this should also set RESET_INSTALLED_LOCATION
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'm not sure how I feel about the use of null here. If the keys can ever propagate back up to the blocks layer, this could cause issues. I would recommend giving the key a name like "distance" or something similar for consistency with the other sensors that report values.
Aren't just 3 asterisk enough? :-)
Should we sort the fields (an other validation targets)? The reason is that you might have two assertion failure and being deterministic might help. (as we might not need to be deterministic in compiled output order)
If possible, generally please make all values final. It is one of the main rules to achieve functional programs.
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
What about hashcode and equals, should they need to be regenerated with the new boolean
lowercase for package names.
nit: Unsupported
nit: Unsupported
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
defensive copy?
Seems doing all these potentially long-running operations as synchronized leaves a good chance for deadlock. Not sure how waitUntilAllOperationsAreDone ever completes if it's not empty, since you wouldn't be able to call operationComplete(), no?
+ desc
Is this a reason to have separate if statement instead of while (!shutdown)?
It's not public, it can be changed. We need to have it backward compatible for one minor version. If this is to be released as 3.9.4-c1, MC 3.9.x and MC 3.10.x needs to be able to work with this. You can add extra fields which we will use in an upcoming MC 3.10.x release. Removing the field needs to be delayed until HZ 3.11 where we can adjust the codebase to not expect the field.
java String desanitizedCourseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(obj1.course.getName()); String desanitizedCourseName2 = SanitizationHelper.desanitizeIfHtmlSanitized(obj2.course.getName()); return desanitizedCourseName1.compareTo(desanitizedCourseName2);
Reading an Config object and then writing it again should not alter the XML. This code will do that. This is better: if (subSingleCount == null) { subSingleCount = inheritedConfig.getSubSingleCount(); } But there's a ConfigUtils.method to do that for you. Don't do defaulting in the inherit() method, do it in locally in the build methods (so it doesn't change the global fields of a config class.
If you are going to do this do you need to @sychronize? If not indicate it is not threadsafe...
consider renaming this to detectLanguageBatchWithResponse to be consistent
it doesn't work for multi reference + complete tests please.
Unneeded parenthesis. You probably can one-line this method anyway :)
change to IAdaptable
now that we have some permissions in common in ImportVmCommand and ImportVmFromExternalProviderCommand, we should probably move the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to ImportVmCommand and have the permission check on the destination cluster only in ImportVmCommandBase as it is common to all import commands, what do you think?
won't this throw a runtime exception if the other object isn't a Page?
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
Can't we do this once at the start, since we always enable(true)?
I think the granularity should be 1 seconds instead of 5 seconds here.
I don't think we should do this. Perhaps as a fallback if getCanonicalName is empty? It's a change of format so it's a breaking change. Or perhaps we could adapt the test? I haven't looked in details yet so thinking out loud.
Should we put the check here too?
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
can you make those no-arg constructor private?
Since listener execution order isn't guaranteed, do we want to validate this this way or just .contains() each of the values?
this does seem to cover some people who might have a legit reason. but some do "gc/runFinalization/gc".
generate hashcode again, it doesnt account for caseSensitive.
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
~~The tests are not covering the bug that you fixed. I can change back this line and your tests still pass successfully~~ nvm, i realised my mistake.
I think we have to make as BlockingQueue and use its poll(timeout) to block the testing thread for the message from the async internals. There is no guarantee that all tests are going to be direct and sync. WDYT?
Can you revert this and pass the configuration to the construction of FolderMonitor instead.
int[] props would make everyone including the style checker much happier
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
Why do we return the parents name instead of the name we store a few lines above?
suggestion Objects.equals(value, other.value);
Please change this to  java return new ArrayList<>(failures);
@olenagerasimova it should be appendText(this.text(item)), this.itext may point to wrong value, if text(item) != this.itext
/** * Gson objects are very heavy. The app should ideally be using just one instance of it instead of creating new instances everywhere. * @return returns a singleton Gson instance */ @Provides @Singleton public Gson provideGson() { return GsonUtil.getDefaultGson(); }  It would be handy if we could not create Gsons here though I don't know how this class is instantiated by room
I would suggest making this method synchronized
The ListenerList implementation already takes care of this. Remove the "contains" test.
A good opportunity to not hardcode the port here, but rather use findFreePort()
negative logic
I think this is cleaner  public long size() { return writeOutBytes; }
Delegating to type would be better here, and would work when this Binary is used for Decimal.
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
Same here - you need to close the stream
close does an implicit flush
Should you check if there are some files you should still delete, in case this error happens?
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
note when rebasing that i added the following here to handle missing data:  if (data.numHetsInSegment(segmentIndex) == 0) { return Double.NaN; }
Should be outside the if
Operation operation = snapshotTable(snapshotName, tableName); if (operation.isDone()) { return; }
make sure all the if/else if cases in encode() are covered, e.g. '\t' is missing.
Minor: you can decrease the visibility modifier for some methods here and change some methods to be static.
why?
You want g.add(null, checkBox) and put the display name onto the CheckBox widget. This way it shows [x] Foo instead of Foo [x] and users get a bigger click target (the label text) to mash with the mouse.
It is confusing to have unrelated asserts in one test method, please split those into separate tests.
Why not check isEmpty()?
should this be named getRelativeDestinationFolder then? But the way it's used in ImportHandler.java is not relative so it looks like it's the field that needs to be renamed.
@pefernan here the message should be: logger.warn("Unable to parse value of " + KieServerConstants.KIE_SERVER_MODE + " = " + modeParam + "; supported values are 'DEVELOPMENT' or 'PRODUCTION'. Falling back to 'DEVELOPMENT' mode.");
This method can be private.
Mock this also.
same here (using getNode)
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Curious: why need to track closed in DriverSplitRunnerFactory?
The last assert is different from the first 2
<LINK_0> Let me know if you have any issues managing or adding items to the project
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Coding best practices: Interface i = new Implementation();
You can define private static final int DEFAULT_WORKER_COUNT = 4..
@fchauveau there is no null handling of source, is this intended ?
Is there a reason you chose _system_name environment variable instead of the os.name system property as described in the [Java properties](<LINK_0> tutorial?
I believe it would be more understandable to do the following:  // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
Override
Should this try to create a URI with the old logic when it's null for retro compatibility ?
This is effectively your synchronization barrier? After fetch(...) returns, you are guaranteed that the value will be populated in the cache, assuming the writer is utilizing the same cache. Am I understanding this correctly?
Here one could advertise the existing Hints.GEOMETRY_CLIP, so that the StreamingRenderer instantiates the clipping collection only when needed.
Help me understand why lazySet is safe to use here. It seems we want to have visibility of this value when we next read, but my understanding of lazySet is that it does not guarantee that.
socket might be null if an exception was thrown in sendToSocket catch clause.
new HashMap<>() will do
s/Kills/Kill
This injects mutable internal state. A copy is needed.
id is not creatable
Does TYPICAL_LOG_MESSAGE need to be a local variable? You can hard-code /typicalLogMessage.json here if only used once.
Should be a space after ,.
What if the key is negative?
Assuming the change to ConcurrentHashMap.  JSONObject json = new JSONObject(mVars); return json.length() > 0 ? json.toString() : null;  There is also a race condition issue this fixes (we have not noticed yet). After passing the == 0 check, the map can still be emptied before we copy it. So then we would return an empty String instead of a null String.
Can make this into a singleton as we have with UNSET.
What if fileName doesn't have any .?
remove the explicit initialization?
Can you replace the above 2 lines with for (Token token : tokenStream.getTokens()) { please?
Use logging instead of this.
This should be at least a constant, and more probably an instance variable.
Per our conversation, please check for the exact type.
Remove unnecessary this
what if provider == null?
It's not wrong, but it would be very nice if you could use the logger messages embedded in the _Log_ interface? So here you would have:  log.redisStopping();  Which allows the internationalization team to translate it or redefine the logging level.
It may be cleaner to use Objects.hashCode for a single parameter, and Objects.hash for multiple (see the warning with Objects.hash, though that doesn't appear to matter here).
return only if the provider is an AnalysisModule?
So there's a bit of a elegant hack to doing this: You can redirect to do the same as the original method, and then override this injection method in VillagerEntityMixin to do all this logic that otherwise you'd be doing. I do this with WorldMixin_Tracker and ServerWorldMixin_Tracker to do extra logic only on server worlds for injections that are in the subclass.
I suggest adding getDiskDAO(), the same way you have getSnapshotsDAO()
This should also be synchronized
Should this be similar to other parts of the API where if connection == null get call get Connection and if not we use the instance?
Work is generic, so add <?> at least
not related to this PR but wondering if returning null or an Optional.empty() in case of corrupted data shouldn't be better.
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
The this. in getters are unnecessary too.
This does not cause performance issues? <LINK_0>
This method should be private in visibility.
To be safe, should check gerritTrigger.getJob() != null first.
So this allows an env prop to enable a feature (in spite of whatever is found in the meta-inf files) but it does not allow for disabling a feature. Is this asymmetry intended? I find it quite confusing. I'd imagine it would be less confusing if env props (if present) would act as an override for both true and false values.
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
suggestion bannedColumns.add(COL_ID_ACTIONS);
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
neither of these need to be a concurrent data structure. if you just make them a regular list like a linkedlist, the variable will be local, not subject to comodification.
This also needs to be synchronized
reminder to change this to ConcurrentHashMap.
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <- remains unchanged logger.info("Not skipping file: {} ", source); <- just before the return false and let's drop the first looking into file...
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
The implementation of this method will never return a null element. I think the annotation is an overweight of the method. IMHO it is better to update java doc to said the method returns not null value instead of adding a runtime check on every method call.
It would be better to also check that the function is unary.
This kind of verbage is full of some dangerous assumptions about the nature of the language involved. If we were in a right-to-left language this would be really confusing to put together. Two options that might help: 1) Use the localization keys to do the construction, IE: Localization.get("cancelling.title", new String[] {titleText}) where cancelling.title=Cancelling: ${0} or something similar. Alternatively, you could only use the message view for the cancel message (although I'd put the "..." in the message itself for the same reason)
Please add a space after (Class<E>).
I would suggest exposing the max length from the validator and using it here so we ensure they do not vary independently
extra space.
singular
IIRC the previous contract was to return an empty list and not null?, see method above
Throw an unsupported operation exception here.
this field name is confusing since the parameter passed to the constructor is a File but this is a PackFileName, maybe better packFileName
There is no need to call super explicitly. Same applies to other constructors.
recipeFileContentProvider param is missing in java doc. DevfileRecipeFormatException is not desribed in @throws section
How about make "filter" to a constant(KEY_FILTER) in NotificationListFragment, since it's an argument key and many place need to use it. typo it may cause bug in other place.
This test checks topic creation. Why do you call replyTopicStubs?
Consider using == maybe?
Maybe we should also deny requests while recovering after a shutdown
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
Could this and the above constructor be changed to use the below contructor? e.g.:  public Region(){ this(null, 1, Integer.MAX_VALUE); }
When you extend the abstract class that you use here, you shouldn't need to override these methods. Is there some special reason for doing that? I worry that any new method addition will be forgotten here and would rather that we just used the abstract class'es methods.
Did you take a look at this? <LINK_0>
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
missing @since 4.5 for new API method
@dmzaytsev let's extract this into a private final String variable.
Calling setProgress() with intermediate values shouldn't be necessary.
You can make this method private
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
Add a constant for this
why we need to check if peerLeaderReplicasByPartition contains partitionName? I feel it's unnecessary.
return (id == null ? 0 : id.hashCode());
Can we create a variant of getValue(Class<T> type, String key, T defaultValue) that will handle the NoSuchElementException instead of having to handle the exception in all the getXXX methods?
please also add the GUID which is important.
What is the purpose of cleanup? Clearly mention in java doc.
Detail: I would rename this method to "attemptToChooseTableFromPrioritisedList" to make this sort of bug a little clearer.
See also DefaultDockerClientConfig::dockerConfigPath field
What is the purpose of catching this exception. If this thread is interrupted it sounds more like an IllegalState somehow?
The first three should be required.
Instead of obtaining the Authentication, please use the SecurityContext so that the original SecurityContext is used (this ensures that if a custom SecurityContext was established it is used later on as well)
Missing types
Why are you creating an instance of the class to perform the conversion? Why not just use a static method. This seems like it's creating an unnecessary object.
Cannot we simply use equals twice instead of relying on reflectionEquals? ;) Or if underlying Table does not have proper equals implemented it there instead of hacking it here?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
why this change?
Are we going to support VARIANT type? As I know We're handling variant as String in schema.
Still this can be a static message as all messages are defined in the beginning of this file
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
please move calculateScope(ast) inside expression to speedup a little bit performance, scope calculation is not always required.
Should we break the for-loop early if the condition is not met?
Is there a more specific exception that can be caught?
I prefer "Error while waiting for the task to be started.", the exception should inform if it's a timeout, etc.
Does not compile, but not really important.
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
Why public?
if the stdouts are irrelevant let's remove them
By composition, do we need this?
If it is a mock user, better to call it "mockUser" or so so that there is no assumptions it is something real
maybe ensure that this falls later than endTime, to not query the same interval multiple times? i.e. case where fLastQuery + fResolution <= endTime
Any reason to use an unmodifiable list as the list is already a newly created one?
avoid using \n, I remember windows contributors having tests failing because of such usage.
any special characters to block in webhook name?
could be made static
what is wrong with this implementation is that it will fail only once, on the first class. and in order to catch the next one you should run JUnit again. Instead, would be much better to do:  java MatcherAssert.assertThat( Iterables.filter( classpath.allTypes(), new Predicate<Class<?>>() { // filter it out if it's one of the types we want to exclude } ), Matchers.everyItem( new CustomMatcher<Class<?>>("annotated type") { // .. } ) );
There no whitespace around <=. Also - good to enclose blocks of that that if/else in {}.
!block.isIn(BlockTags.LOGS)
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
wrong formatting - every parameter should be in new line
This is a breaking change.
Why not pass the paymentAccount and avoid the extra lookup and null check in paymentAccountManager.removePaymentAccount?
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
labelX should be x + ...
nit: this is Optional.ofNullable(metricName.safeTags().get(ADMN.TAG_CURRENT_SUSPECTED_LEADER)).filter(x -> x.equals(String.valueOf(currentLeader)).isPresent(); though I'll leave this as personal preference
This is standard procedure in our existing registries. :+1:
Can call the method directly, instead of using reflection. return FieldValidator.getPopulatedEmptyStringErrorMessage(...);
you added synchronized to the method here, wanted?
Use isZKLogAvailable() instead
I get changing all the UNSAVED_ID constants to primitive, but why change getters to Long object when the field is still a primitive? It just necessitates a lot of boxing/unboxing
Where does the 5 come from? I feel like we should just throw an exception here.
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
This is redundant.
I'm not sure we need this. II would prefer to let the logic of collecting exceptions hidden in the visitor. Why not directly handling this case in the MethodInvocationVisitor then? You can perfectly give the symbol of the current methodTree as parameter of the MethodInvocationVisitor constructor, so you don't lose the info from where you are calling. At the end of the visit, you could then simply add thrown exception from the default super constructor, if super has not been called and it's really a constructor.
this method can be static
Please use a [StringBuilder](<LINK_0> instead.
here too, or just log the error
Are you sure that String.format is one of the effective ways to concatenate three strings together?
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
Pass the FeedbackQuestionAttributes inside the UI template class and use.  feedbackQuestion.getQuestionDetails().getQuestionSpecificEditFormHtml(qnNumber);  > ---- Polymorphism :D
are these setters used anywhere?
Make constants
Use StringBuilder instead. Also, you can use ToStringHelper in guava.
The problem should be somewhere else :-)
What's the point of adding a copy here?
This line will always evaluate to false as we are comparing ExitCode with String?
I think 15, 11, and 4542278 should be named constants.
it'd be more robust to explicitly build the cache key, rather than embedding the toString of a List.
run -> status
Use Guava Streams.stream(myStream) instead of StreamSupport.stream(myStream.spliterator(), false)
Mike spotted you're changing the formatting of private keys from "Utils.HEX.encode(getPrivKey().toByteArray())" to "getPrivKey().toString(16)". What's the reason? On StackExchange I read .toString(16) is stripping leading zeros. I'd personally prefer to at least keep bytes intact.
A couple of things to try: 1. Add some debug logging to tell you what the actual size of the element is here (i.e. just its offsetHeight/offsetWidth). The most common cause of this sort of behavior is elements trying to compute their size when they are either not visible or not attached to the DOM. 2. In cases where you need to wait for the browser to finish a layout pass before picking up layout properties, the idiomatic thing to do is to use Scheduler.get().scheduleDeferred(), which schedules work to happen on the next event loop (something like a timer at 0ms).
Instead of converting the Path to a String, we should just return the Path object and have the callers use that instead. That way no one should have to deal with file separators and can use existing Path methods.
Is not safer to use Locale.US instead of ENGLISH ?
There is indeed a behavioral change, the previous code was trying to lookup the files using the resource loader even if the string representation had no scheme, this one does not. The following change fixes the specific build failure. suggestion return uri.getScheme() == null || "file".equalsIgnoreCase(uri.getScheme());  I've verified this change makes for a successful build (with all extensions included, -Prelease):  [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 06:12 min (Wall Clock) [INFO] Finished at: 2020-05-06T15:36:28+02:00 [INFO] ------------------------------------------------------------------------
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully backoff when an application wants to manually configure a value. What that means here is that if the application has configured any algorithms, then the auto-fetch doesn't get run.
We have thread executors. It is important it must use these. Also this solution uses up a thread permanently which goes agaisnt some of the thread modelling. Look maybe to use schedule thread executor
If you have the guard above, you don't need this.
ms <= 0? Thread.sleep(0) may or may not be a scheduling yield. Its undefined in the platform docs.
Return from method Details at object that you found , and in place check for not null
[Checkstyle] INFO: '200' is a magic number.
I know this is a bit strange but here I will not really change this. Historically this was used to know if we should use unsecured(coap) endpoint or secured(coaps) endpoint. So maybe the right name is "isCoaps" ? But anyway I read the code again and maybe this does not make so much sense now, so it would be more wise to not touch it for now.
Can be replaced with streams java List<CharSequence> titles = titleList.stream() .filter(titleProp -> fieldApprover.approve(titleProp.getDataInfo())) .map(StructuredProperty::getValue) .collect(Collectors.toList());
You could use the list collector directly.
Possible candidate for bind() if that method is created.
Ah, interesting...delete would fail if a key with KEYPAIR_NAME did not exist?
This part of the patch should be in the VCS-specific commit.
info might be too noisy. Let's make this debug.
can this return emptyMap? and just be another clause of the if below?
Please update the exception message to say KieModule too?
ExecutorConfiguration(Optional.absent(), Optional.absent(), Optional.absent());
Why should the caller have to provide the RestResponseChannel here? Given the RestRequest you would (or should) know what the RestResponseChannel is, wouldn't you? Why put the burden on the caller and allow for mistakes to be made?
nit: String.format may allow this read better ? (opinion)
Since the event is really a resource rather than a model, it would make sense to me for this to return the event resource instead. You can get back to the model in other places if needed by calling .getModel() on the resource.
We can be more explicit. There are only two protocols so we can compare with XML. We are comparing enums so we can use equals here.
Why is this removed?
Do you care that this doesn't account for: <LINK_0> Is "Other Info" included in the docs?
Annotations on different line
Well, what happen then if user still use the deprecated method? we need to be backward compatible, right?
other methods like this put name first, then id. switch for consistency
nodeID could be null
Maybe we can improve the message further by checking if null == operation and show a different message in case it is. Something generic (like Unable to complete operation on "event-type-name" + reason. What do you think?
BoundingBoxUtil checks to see if box is null, and if it is it just uses "pos". So you don't need the null check, and can replace this with  java public AxisAlignedBB getRenderBoundingBox() { return BoundingBoxUtil.makeFrom(getPos(), box); }  and it won't ever throw an NPE.
you can do return (!StringExtensions.IsNullOrBlank(brokerVersion) && AuthenticationConstants.Broker.BROKER_PROTOCOL_VERSION.equalsIgnoreCase(brokerVersion)); #Closed
Can't this be further improved to just Arrays.asList(values)?
You should use a consistent method naming paradigm within your class. I think this is the only setter that says "set" on the start. Either have all of them say set, or none of them. This might also be a good opportunity to change "rya prefix" to "rya instance name" since the prefix is Accumulo specific.
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
Are we sure newValue is always non null?
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
missing onDestroy suggestion @Override protected void onDestroy() { super.onDestroy(); mMapView.dispose(); }
Nit: Have you considered using a ternary here? Avoiding intermediate variables is often a good thing.
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
I believe there is no need to re-register the listener on each entity assignment since field setDnsConfiguration is final. And thus clearing listeners can be omited.
Could be inlined here by using test()
reset compensation?
Better, but use logger.logAndThrow(new ...)
config.intervalFunction isn't used anymore in RetryImpl. If set only IntervalFunction, I think code should be like following java config.intervalBiFunction = Optional.ofNullable(intervalBiFunction) .orElse(IntervalBiFunction.ofIntervalFunction(intervalFunction));
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
remove OnWiki
Let's file a follow up issue to replace rpcService.getExecutor with a proper ioExecutor.
Don't make this public, instead. use. TableDefinition.id().
@marchof I'd prefer to name local variable invisibleAnnotations or even better runtimeInvisibleAnnotations instead of just list
protected static ConfigurablePageObject getPageObject(Jenkins jenkins) { return jenkins.getVersion().isOlderThan(new VersionNumber("2")) ? new JenkinsConfig(jenkins) : new GlobalToolConfig(jenkins); } ConfigurablePageObject configPage = getPageObject(jenkins); boolean onConfigPage = jenkins.getCurrentUrl().equals(configPage.getConfigUrl());
You can use StringUtils#defaultIfEmpty instead of the ternary expression.
suggestion this.clazz = Objects.requireNonNull(clazz);
If the reader is reused, open will be called again but this reader will never read unless you reset the "read finished". I think this applies also to the other reader.
This log message is not always correct. What about missing toClass class?
if (variableSet == null) {
assertNull
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Why do we have to reset it here? Is it because the standard, GZIP compression is not supported? How hard is it to simply support it?
uncessary call to super. No need to visit further.
Just "Kafka".
i don't think redeclaring the type on the right side is needed.
may be we should assert on get() > 0
There is only one Object.class, so it is clear when == is uesd
Nice, included the row.
i would use a LinkedList here instead. i can't find anything saying ArrayLists sort faster and then you do not need to specify an initial size.
I think "$exists operator requires operand to be either true or false" a better error message.
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
code format
We can add a checkNotNull here.
Why does this need to be made public?
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
If you just retain the below line, the API contract for createInstance can be regular:  UserDTO user = userEntity == null ? null : UserDTO.createInstance(userEntity);
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
Semicolon is not needed here
API breakage errors. You should declare another method and mark for deprecation this one.
I feel the isNotEmpty() check is not needed here. The for loop will take care of this case.
Maybe add assertFalse(realm.isFrozen());
'coordinate' is a single word. Also calling toString from a constructor could lead to unexpected information being displayed, because the object might be partially constructed at that point. It would be preferable to show the negative coordinate instead.
This is one of the reasons I didn't create a PR yet; not sure what the answer is yet but was going to explore it (possibly using ApplicationContextInitializer and creating ContainerMetadata earlier). Earlier (current master) we had a static method being called to publish the container started event from a context (static so SingleNodeApplication could also call it), but that definitely needs to change. We need a bean, with a managed lifecycle.
The generated body needs to be verified too
Is there a reason we need the executeInternal() method, given we could just use execute() in the executeToX methods?
IntelliJ IDEA tolds me to remove this unnecessary boxing.
I think we can just call clear() on mItemsSelected, and by doing so we can also make it final.
Please use builder.xxx(...) instead of new ....
Since this is not an exposed interface it is OK to change the signature. But, I'm curious to know that any other project or users depending on the revision number.
Can't we assign value to localChannelId at the constructor directly?
doc
Work is generic, so add <?> at least
Change to commit();
return a boolean esp. given the semantics of the update operation if there is an existing node of the same name that is not the provided node instance
Doesn't Datanucleus advise against using id in hash?
Why not just simply "command.setVM(vm)"?
Nit: VirtualConsole. prefix is unnecessary (here and elsewhere)
\+ unset MDC?
same question
putIfAbsent or use synchronized block
Those two should be equals (and even ==) rather than going through FQN
Why need to catch to simply rethrow?
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Extra ", "
The method actually determines if the given processorNode is a duplicate of any of the existing nodes. The action we take on duplicate is stopping the processors. Can you please update the doc?
Should be given/calculated
Please include an error message here. (Probably a "WTF?!" message if it should never happen.)
we used to [call](<LINK_0> validationService.isProjectNameValid(...) Has the validation of project names changed?
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
same opinion here :) (though break logic here seems correct)
this method should be changed to private
revert this string
This does not work like you think. setFireInfo sets the fire info for all forestry hives because all forestry hives have the same block instance. You have to implement the methodsgetFlammability, getFireSpreadSpeed and isFlammable in the class of the hive block.
can't you use constants.empty() here as well?
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
synchronized block is not needed
Did you run your test? Does it work with Github account? I don't think it does, since you're creating one gist and deleting another one.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Can throw exception when created with no args constructor
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Please check also left content, in order to be sure that left model has not been modified.Please verify all other tests that present the same problem.
Isn't there some standard way to dump a stack trace?
:bomb: this is not a solution. hashCode() can be equal for two different objects. Do it using the four fields.
beginBlock should close the paragraph that was created in assertOpenBlock(), if there is one currently open. Note that it should not close *all* paragraph blocks, only the one that was implicitly created.
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
This makes this nullable. If you think this will never return null, then you may want to throw an exception NullPointerException. But if it can be null (like the trace is not set yet or something?) Then make this method @Nullable and do a null-check when you call it.
Is there a reason not to import java.util.UUID? e.g a conflict with a similarly named class?
This is the only place that add entry to the pool, is it the only way to fill the pool?
Should we do an Assert.assertTrue on the return value of verify()?
add "this" qualifier
Can be simplified to AutomaticProvisioningStatus.ENABLED.equals(getAutomaticProvisioning());
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
Throw an unsupported operation exception here.
Collections.emptyList()
omit: Initialing...
the return type should be M
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
SyncNetworkParametersBuilder contains those logic in labelAdded() & labelChanged() perhaps it could be reused ?
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
Take the limit (50) as a parameter, this will be useful for later
These two lines probably can be combined into one.
I'd rename this variable to memberValue.
Maybe it would be better to move it to localization
you could be more specific and check instance of Function0 maybe?
Check if credential and registryUrl are null before creating the Deserializer.
Use Objects.equals() to handle nulls concisely.
while I think it makes sense to check this if we are calling it E from, E to, wouldn't the constructor be a better place to enforce this? In the 2D query patch, Genevieve suggested not enforcing it in the constructor and using min/max instead.
Please remove this invocation. Right now, the test would pass even without your ExtensionBeanDeployer modification. If you remove the invocation, the test would fail without the modification. Otherwise looks good now.
add this (also below)
Why not use name as the key in CACHED_ENCRYPTION_KEYS?
A regular integer will do fine. The connection handler is single threaded.
Order of expected and actual values is wrong.
Could throw IllegalArgumentException instead.
use ShellIsAvailable
I'm thinking the constructor should be public as well so that applications can use it in their own authentication providers.
Should we return an explicit IStatus.ERROR instead? * It would avoid potential NPEs on the client side. * It would make it clear that this method should not have been called on an ResourceStrategy which explicity says it does not handle this method.
remove
maybe we need something more generic to handle forwarding of events?
and doing the instanceof check here instead (trace instanceof TmfExperiment)?
is this key unique enough if there are multiple fields with the same type, either in the same class or in class parents?
float?
!getCustomTopicNames().isEmpty()
no static
Need to pass xmlEnvironment as second argument to XmlStringBuilder.
Down below we throw BadRequestException. Here we throw IllegalArgumentException. Let's be consistent.
TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - started)?
should the interface not the implementation suggestion public List<String> getTopics() {
@ivandalbosco is it possible to refactor these 6 lines?
flatMap that stuff
suggestion EMPTY_VALUE);
should it be an error condition or log something if both the invoice number and the customer payment number are both blank?
Should add a method calculateSettlementDate on ResolvedCdsIndex that takes the valuation date and reference data. Like calculateSettlementDateFromValuation on ResolvedCapitalIndexedBond.
return dto
I believe you should move this to inside the executor below. First, it will help deal with concurrency. Second, and more important, it will allow to fetch the latest model when the time expires, instead of being stuck using a potentially old model whenever the timer expires, since we use the model available at the creation of the timer, not at each run of it. Note that the old code used to "re-fetch" the model inside updateLoads(), so each time it was called.
You can push this directly to the frame so you don't have to pop it manually.
This needs to be run-aware
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
why is this noncompliant?
For me it looks very strange that for initialising collections we use two different approaches within 5-line method :) (Guava and java.util.Collections) I would prefer to have homogenous approach (at least within the same method) doesn't really matter which one.
This is not thread-safe, right? Someone can increment the _pendingCount after this block and have you tryExecuteLoop() again.
Well, not necessarily on your own, but if us two don't understand why this works like it does, it means that this part of code needs fixing and probably git blame is your friend on the quest to reach the author :D
This converter does not have any effect
calling this command will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVds command
This is a public API, so let's not change it here. If you need a ConfigEntry with synonyms for the test, create a static method in ConfigTest that will make it. That will keep the change confined to the test code.
Would it make sense to add this method to ResourceManager interface ?
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
We usually want the config default specified in properties file, there is no need to provide a default in java code.
s/executed/execute/g or maybe even simplify this to "An exception was thrown by a Executor"
Discovered in another PR we've been doing this backwards - it needs to be assertNotNull(msg, value) to work correctly.
I think you can avoid the ternary statement here by checking if (this.world == null) instead, and returning this.world.get() at the end.
This variable is useless. Please just use return in your if/  branches.
Is this the same as getDelegate().getPage(context, id) ? Sometimes getDelegate() is used and sometimes super.
the workspaceitem needs to be deleted
minor, is it method scope for Visible For Testing? If not please change it to private.
does it need to consider Windows?
Maybe "dequeue" is not the best choice of method name here. It suggests something about queues, but the actions taken use a repository, so I would think "load" or "find" would better describe what happens.
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
should rather be named currentContextClassloader
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
This should have a static logger method with a code
please replace this line with: return StringUtils.defaultString(result); or the two lines with: return StringUtils.defaultString(getMessageOrNull(logType));
Put in on the same line:  HiveType hiveType = hiveColumnHandle == null ? null : hiveColumnHandle.getHiveType(); return Optional.of(new RichColumnDescriptor(columnIO.getColumnDescriptor(), columnIO.getType().asPrimitiveType(), hiveType));
lets include e.getMessage() to be consistent with other plugins.
i'm surprised this passes checkstyle
This needs to return compressedMessage.clone(). We clone it so that code that calls getCompressedMessage() can't mutate the message text (as arrays are inherently mutable), and all of the Message classes should be immutable.
How are splits handled? this should take split start and end into account?
return if already destroyed
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
please replase MojoExecutionException for a new generic DeploymentExecutionException
Missing @Override
Not enough to test that ToString returns a non null value, we should check the actual value as well. We need similar test for testSmsMessage_EmptyBuilder() testGetBuilder() and testGetBuilder()_EmptyMessage()
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
I think this log message makes more sense in the ctor than here. Since users are immutable you'd want this logged once when a malformed user is created, not every time you access its key.
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
This is a breaking change.
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
ArrayList should be constructed with fixed capacity.
final?
nit: Only plan parameter is used. I don't think you need to check anything but plan with the requireNonNull.
would this work? (also removing the import) suggestion .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice);
can be inlined into a single return line
you need call addColorSettingsListener on the new instance.
Please keep this.cell near the related fields (previousFamily & cell count) below
Note: This is not always true. We use 'utf8mb4_bin' for mysql and 'Latin1_General_100_BIN2' for SqlServer, because we need case sensitiveness on various places. The unit tests of ebean will run here at foconis also against a database with these settings. This means, the tests will fail here. What do you suggest? - can you change your mysql/sqlserver test setup to use a case sensitive collation? - can we introduce a flag (Systemproperty), so that I can run the tests against a case sensitve version of mysql/sqlserver? There are some special things to pay attention, if you change the collation/charset: - the maximum index length on mysql is 767 bytes, this means ~191 chars on 4-byte UTF-8 charsets - setting the collation on sqlserver to case sensitive, means also that the columns are case sensitive, I had to modify some tests for this. (I can diff the code and create a PR for this, if you want)
Non-standard equals?
Seems the output name cache should be reset here, not below.
I believe that this is the same as Objects.hash(readName, pairStatus);
Should be "!= 0" instead of "> 0"
please update - should we keep this or format to remove ====
We do not unpack it for all the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to byte is needed here.
You may use org.bonitasoft.studio.model.process.builders.ConnectorBuilder. You can then write a one-liner for your test: assertTrue(onFinishFilter.select(viewer, null, aConnector().onEvent(ConnectorEvent.ON_FINISH.name()).build()));
why not an empty map?
Argument name
Redundant casting.
Collectors.toList()?
I have some concerns about this. 1. Wouldn't this make crashlytics run in debug mode as well? The old Crashlytics didn't "ignore" things in debug, but we definitely don't want them reported. That was why it was in the if...else in LoggerStarter. 2. The reason for crash logging to be initialized in LoggerStarter is b/c if the content provider is accessed through a Context which is not ours (like if we export our data), then our Application does not get launched so crashes would not get reported to us. LoggerStarter is initialized in the content provider, which circumvents this limitation. 3. Does this create a Twitter singleton that we keep around for the lifetime of our app? If so, that seems like a waste of memory since we only use it for the login stuff and even then only for vendors who actually use twitter.
What is the reasoning for this logic? Specifically the desiredID < 5.
Please check the result here and break if false , since all values are with AND , there is no point to continue if we got false
Should use the log, maybe a warning.
Possible ClassCastException, since there is no check that the loaded resource is a view.
This was renamed to PARTITIONED
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
unnecessary change
Why not: java if (val instanceof Double && Math.abs((Double) val) <= 1.0e-131) { return ZERO; } return val;
Maybe use the getStorageId method here?
Why this change?
Is this supposed to be <code>return "Bump"</code>?
Consider the CollectionUtils.isEmpty(this.applicationDefinitions) instead
mfsu instead of mfe?
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (long) tileCount.
Why is this throwing Exception? Should usually not throw anything.
test will success in old versions
I don't think we need this assumeTrue. Docker API has had build params since 1.18 <LINK_0>
As noted above, just put the init code in init() unless there is a reason not to.
missing check that vm exists.. (getVm() != null)
Should the shadow not store this value and the one above in variables and provide setters for them, rather than just always returning false? The same goes for all values actually... Would be better to provide setters for them.
I don't see anyone calling this explicitly. Should the removal of Paths.build(Paths.CONTAINERS, id) happen as the ephemeral node removal?
So what's buggy about the CopyOnWriteArraySet?
Isn't this superflous? Why not let Files.createDirectory directlry throw the excption?
you could be more specific and check instance of Function0 maybe?
Unnecessary parentheses (and an extra line break).
don't you need to increment the index to avoid infinite looping? how do you avoid having seriesName, and seriesName(0)?
You added this to the ctor's signature, but forgot to save it in a data member.
spacing here looks off
rename this to hostSpecification and then you can use host as the foreach var.
Format
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
Have you intentionally omitted index check?
Okay, but already done implicit.
missing curly brackets.
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
toList() should return only JSON object. I understand that getObject(i) can return CBL Array() or CBL Dictionary() ?
I think you mean (d<=0)
If we are always dealing with character-based payloads (and maybe we aren't) then logging the decoded version of the payload in a toString() would probably be more useful than the raw byte array
Again, don't clone a new event. In the new code change, the "else" will only be executed in very very small time windows. You have proved that when the sender is shutdown, the eventProcessor will be kept. So enqueue will not go to the "else". We will never worry about the tmpDroppedEvents become too big.
lambda
The number should be canonicalized before retrieving the contact, using Utils.canonicalizeNumber(number, username)
I am not seeing this assigned anywhere. Is this needed?
Shouldn't we avoid to have U+0000 or any other chars not valid for table name in the name? I think we should update TestHelper.getRandomString(int) to exclude U+0000 at least.
Might consider using a [SimpleConfig](<LINK_0> here. Won't make a huge difference with the class as-is, but will make it easier to make changes in the future if we ever want to expand on the configurability of this predicate.
Static import
Is synchronized needed here? workflowDefinitions is already a synchronizedMap.
This no longer needs to be public, that was only for MergeOp.
to remove, just use new ArrayList<>() in the constructor, two lines below
new Double is redundant here
I know this is pre-existing, but getQuery has a bunch of other usages that refers to the query text. I would rename one or the other.
inline permissions and then remove redundant this
use same type for instanceof and force casting
We should add a log message to indicate that we're going to block while waiting for a service to be available.
Collections.singletonList
Again, this is too much specific logic that this component does not need to know about. It should only depend on Prefs.showEditMenuOptionIndicator().
We probably need something based on version rather than on whether the default token cache is being used. If we want to test versions of ADAL that do not contain common cache... for example.
same here. we don't need to set explicitly for blob not found cases.
I think we can revert this change already since AnonymousQueue is now Base64 by default.
Why is the call to trim() necessary? If it's necessary, I would move it to the client.
This change may cause the lock not to be released in some cases. With this change, in case of a failure VdsManager is responsible for releasing the lock. The VdsManager releases the lock only in case it catches an immediate exception. In case of a time-out or other SetupNetworks vdsm failure, the lock will never be unlocked.
Is it a good idea to give access to the view directly to the page? Wouldn't it be better to have an inner class for the sheet page to access the contents?
will this remain package private once we have the next PR as well? Or will it be a private one?
in case closing one grouper throws ex, we would still want to close the remaining ?
Mid return may worsen readability
What we are waiting here on?
remove this method. you dont reuse the variables anyway.
qry -> query
Do update all the places where you can now just use typicalBundle, instead of getting it again.
Is it okay to remove this?
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
Maybe the simpler:  return Objects.hash(podSpec, podMeta);  or maybe not, because that involves an instantiation of an array under the hood. On the other hand, it leaves less room for error. :smile:
I think we should return a dto here and do the marshalling of the response in the IL as we do with other responses.
Is it really necessary to set prototype scope for EVERY Provider ? I do believe it can kill some logic if some bean of Provider.class should have singleton scope (in custom code for example).
Does this cope with the case "The previous session ended in a crash. In other words, one session can only have 1 crash at most." in the project definition? Should we also check if there have been unhandled errors?
I think it is confusing to put this above instead of in doCreateProject (right before the RPC call). If there ends up being another way to trigger the create (via keyboard...), it will be missed, or have to be duplicated.
Again, perhaps I don't understand the Java API, but IIUC client.flush(...) is explicitly telling ES to flush all memory associated with an index to storage, and that ES tries to do this automatically. If we have to do this, then commit() is definitely the place to do it. But is it really required? Do we want to force a flush to get the durability of the write to disk?
This is another one that might cause problems. @lbergelson you've done a lot of refactoring to pull interval/region-like methods out into a single class; do you see changing Interval.equals() to not accept subclasses?
Could we call and return the argument(GraphQLArgument.Builder builder) overload that's defined below?
Should remove, and use similar functionality in CoreAuthenticationTestUtils
Looks simple enough. Are we OK with exposing those objects though? One could iterate and modify the readers individually. Just making sure...
nit: I would extract webDriverContainer.getContainerInfo().getMounts() variable :)
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
log should say store is not initialized.
nit: We have this logic in a couple other places. Maybe sufficient cause to turn it into a method?
Hello~ The classes in jars in extensions directory are loaded by URLClassloader, but the KafkaProducer here use the appClassLoader to load classes in org.apache.kafka.common.config.ConfigDef parseType() and this lead to org.apache.kafka.common.config.ConfigException. That is the problem I got. I found some code in KafkaIndexTask, in method newConsumer() such as:  ClassLoader currCtxCl = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); // ignore some code ... }finally { Thread.currentThread().setContextClassLoader(currCtxCl); }  This can solve the my problem. May I ask have you encounter this problem?
Wouldn't it be better to rename mPostsList to something like mQueuedPostsList now that this PR makes a clearer distinction between something being currently uploaded as opposed to something being in a _queue_ to upload?
@Nullable public
It would be nice if the default value of a "1000" was in a constant, and maybe you want to set the default to zero in case you pass "false" as an argument for the detectColumnTypes property.
Changes this to: return newKeyExpression( colKeyExpr.getDatum(), colKeyExpr.getPosition(), // This will cause the IN expression to be removed from the where clause and // processing to continue for subsequent row key columns Collections.<Expression>singletonList(node), // I actually don't think this is used anymore, so I'll remove after I pull your change in. // Instead, the above extract node list is used where this was before. But this is now // an equality check instead of a filter between the min and max in the list list. true, ranges, node.getChildren().get(0)); 0
i remember that month number should be 11
add "this" qualifier
This may not be thread safe if only one sender is instantiated. We probably only want one sender or at least only one httpclient.
It may be worth expanding this to include say: + "who also have 'Push' rights on " + GitRepositoryManager.REF_CONFIG
how can a clusterName be null?
enclose if and else within { } even if it's a single line
new Boolean avoid the constant pool -- putting unnecessary pressure on the garbage collector. Please use Boolean.valueOf instead.
Wouldn't it make sense to call setImage here? Or do we have different semantics in that method and this one?
I'd rather toLowerCase() is applied after substring(), not before.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
final is useless here. Also, consider this.  java try { callback.onSuccess(sessionStore.read(AuthEndpoints.NAME).getAccessToken()); } catch (Exception e) { callback.onFailure(e); }
Same here, return ImmutableSet.of(this.modelResultStream, this.rootResultStream);
should this be wrapped in a try-catch, so that we can do ServiceStateLogic.setExpectedState(this, Lifecycle.ON_FIRE);? For example, see DynamicClusterImpl.stop() and AbstractApplication.stop().
Can be made package local
You could add a package-info.java file to the package
assertFalse(...);
toString() output probably should not be dependent on the timestamp preference settings
Btw, this is why I suggested you just create a specialized Executor, so you don't need to do this manually everywhere.
"data" is already a plural noun.
I don't see where we handle HibernernateException.
Any reason for using toString instead of getId these two lines? I prefer getId as it's more explicit.
As a nit, should have a null guard here.
space line
Possible NPE, miInfo.getFile() is not guaranteed in current implementation to return anything in particular, so may return null or empty string.
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
I think Guava has MapSplitter for this purpose.
Why propagate and not simply Thread.currentThread().interrupt()
This won't make subclasses' updatePhysics cancelable. To do that, you have to create another empty method, call it at the end of updatePhysics, and make subclasses override that method instead of overriding updatePhysics.
Although AsyncClient is deprecated retrieving event loop has some additional checks. Could you please check AsyncClient.findEventLoop?
All of the above getters/setters should be removed. Only the editorState getter/setter should be exposed and any other class that wants to modify the state should go through editor state getter/setter
In addition to methods, we could also cover functions and anonymous functions. That's what we do for [JavaScript](<LINK_0>
Why does it need any change?
Maybe worth removing the call to Objects.equals() here too, as both child and parent can not be null.
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this anonymous inner class a lambda [![rule](<LINK_1>](<LINK_2>
please validate ledger id
ohh.. actually we should default to 443 if https!
Formatting (extra {})
remove this.
(nit) suggestion .computeIfAbsent(partitionId, k -> new PartitionUpsertMetadataManager(_tableName, k, _serverMetrics));
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
typo: perfrom -> perform
Please make "global_timeout_config" a constant.
Remove braces
getAccountRequestCount.addAndGet(1)
The message is misleading. It will crash the process. But actually that's fine, it should, if such a severe issue is detected.
please use a capital 'U' in 'Touse' to make it more readable :)
This method causes several build warning.
It is possible for this to return null if no matching Activity is found, e.g. if one has no browsers install or no browsers set as default (not sure if this will happen). In such case we should do a null check and return null. Also can you put a space after ,? Thanks!
@antonini please name it user
The writes in this method should be done under a lock, right? But I'm not sure that all execution paths do acquire this lock. Should we add synchronized (buffers) or checkState(Thread.holdsLock)?
I'd use << 3 to match MemoryAddressHash
Let's have constructors one near another
We should throw an exception here too, saying the cluster is invalid.
wrap with Collections.unmodifiableMap() ?
The space here is also inconsistent with the rest of EssX.
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Move this check into getPropertyValue(String key, String name, int index), gut this method and have it just call the other one.
same as before, why not simply if (input instanceof EditPart && ((EditPart) input).getModel() instanceof Resource)
is there a version with more parameter than 3? If not i would use == 3 rather than >=.
result can never be null, we don't need this != null here
In tests we can just declare that these methods and the test methods "throw IOException" rather than catching and wrapping them, and just get rid of the catch clause.
Consider an overflow check here. @Nashatyrev proposed a good and simple solution for such cases <LINK_0>
Please use PathUtils.validatePath to make sure that the path is valid before accepting it.
Not atomic. Two threads can reach line 100.
do not expose the list directly
IMHO we should remove the empty line in front of a closing bracket.
static import QUERY_THEN_FETCH
probably this is an exceptional situation
In this case that you read all files into memory, there is no difference between using this and using File.listFiles()... Just saying... Something like the following? :) for ( File file : new TreeSet( Arrays.asList( dir.listFiles( new FileFilter() { public boolean accept(File pathname) { return pathname.getName().endsWith('.properties'); } } ) ) ) ) { loadFile(file); }
You can replace by: this((GraphicalEditPart) editPartBot.part());
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
assertThat(c.getParentCount()).is(2);
I'm not sure about coding OS-specific-ness. Is this the sufficient condition for all OS? 1. Does SWTBot has any users on SunOS/Solaris? Will the statemask be correct if someone uses GTK on Solaris ? It will be risky unless we test it. 2. See Util.isLinux() implementation in org.eclipse.jface.util package. It considers 'motif' also as Linux, along with 'gtk'. It seems SWT supports motif. It may be out-dated. Do we need to consider motif? Since 2-3 years we have been discovering some differences in SWT behaviors on win, linux, mac during our SWTBot reviews. There will be limitations to support each such difference. But then there will be inconsistency if we support such difference at some places. What is the best approach for swtbot?
You should have moved it here.
Should this be onReplicationPutRecord?
Same thing than for the agent: no default value.
Need to use UUIDs instead, for performance. Nit: can be final.
This Exception is never thrown. It may be that while developing, you had a change here that required the throws clause, but it isn't need in the proposed patch. I would have expected that would have reviewed your own change before proposing it here, and that you have removed this change.
Replace 'commit' with 'committed'
negative logic
does this need mUseReservedSpace? Also affects equals() and toString().
Throw an unsupported operation exception here.
assertThat(map).doesNotContainKey(new Object());
According to my own tests, using values-night allows you to omit this (in multiple places)
HttpServletResponse.SC_NOT_FOUND
Same here about being consistent with the underscore.
I think you can make the ResourceLoader a static class variable as creating an ResourceLoader can be expensive.
No biggie, but for Java 8 this could be: java final Path file = dest.toPath().resolve(fname); writer = Files.newBufferedWriter(file, UTF_8);
I like the approach; but I'd like the TLS 1.2 and allowed CipherSuites to be only limited to API 24 (higher API levels might want to use TLS 1.3 for example)
How about making these constants as static variables?
It's probably better to extract a constant for "object".
Do we need this?
final?
Fix method name with prefix..
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I think adapter should have Adaptive banner implementation.
Just return data.
please, talk with Matthew. I think we trying to use Objects.requireNotNull() instead of NonNulUtils.checkNotNUll()
The incore merger works in memory without a working tree. Does he need attribute handling?
Duplicate getAbsoluteFile()
You'd probably dispose your stuff, and call super.dispose() at the end.
Doesn't this duplicate the nonNull check?
Can be simplified to java return itemMaterial == null ? 0 : itemMaterial.getMaxDamage();
There is a lot going on this one line.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Should use ToStringBuilder.
should this count be parameterized?
new HashMap(delegates) - don't keep a reference to the caller's map - he might change it.
This shouldn't declare throws Exception.
Use logger?
Our code needs to be compatible with Java 8. List.of() was brought in Java 9. Can you please refactor the code to be Java 8 compatible?
This is a bit of an odd definition: Technically: "hello world" is a proper regex. You probably want on top of this to test, Pattern.compile(optionValue) to ensure the regex is properly formed
suggestion return Objects.equals(this.getName(), actionParameter.getName());  The reason for this suggestion in general is that it handles nulls properly, e.g. if this.getName() returns null the previous implementation would crash
Why not use the type safe InvalidMdbFinalClass.class.getName() rather than a hard coded string?
This should be 3.6, even if the "quota mode" concept was available sinnce 3.2.
Make these Locatable.
Why do you need caching of the originating _serviceLoader_ ?
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
It seems wrong to me that we invert what was set and then let the action set it back. :P How about we just take the option as is and then do compareModeAction.setChecked(compareMode)?
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
No need for super()
Are we not closing file handles now? :)
a workspaceitem should be returned
Same here? It is always number or null?
Use InvalidArgumentException instead
I don't think we need the Integer.valueOf() boxing since startId is an int.
Should make a differentiation of the name and id.
Shouldn't this be public? Also, if we need the getter methods (and I don't think we do) could we put them right after the setter methods?
can't the response be null? if null as return value is legit for non existing snapshot, move the initialize of the VM into the condition.
why not use File#getName() for the name?
It would be great to cover the util method with tests.
Should use a constant instead of a raw String
Should be "InstaPost" actually.
events.isEmpty()
I would prefer to use full words. For example directoryAllow.
[minor] IllegalArgException?
I think can just use the @FindBy defined at the top instead of findElement() againt
This should probably throw if the value is null.
Does this work return new String(content, charset.name())?
COuld we reuse <LINK_0> ?
why is it adding null?
why do you call this? It will be called anyway by default.
I think this one could be private
This seems unnecessary, if you going to return the same thing at the end of the method anyway.
If Java doesn't have built-in libraries for this, may be use an external library such as jodatime or natty?
Should include other properties to break ties here
Actually the underlying objectExpr could have free variables.
here we need to go through Optional.ofNullable(Plaform.getProduct())
suggestName?
How about while (!stateMachine.getCurrentState().equals(STATE_CLOSED))?
I think the CosemDateTimeDto is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
Use the enum for valid values.
This would add IGNORE_RETURN_VALUES to the provided explicitFlags set if it was not empty, which we can't do. Maybe instead we just create an EnumSet that starts with IGNORE_RETURN_VALUES and add explicitFlags to it and use the resulting EnumSet.
this for is exactly the same in all the array tests, let's move it to a private method
break the line
final List<T> sorted = ...
Should be final.
I think there is some findbugs issue with not using {} not sure.
why the newArrayList? Iterables.filter already returns an iterable.
It would be ideal to clear and repopulate the LibraryType table in the V9000 test data migration. Then it's easier to test against an exact controlled number of LibraryTypes, rather than making the tests more lenient. Same with LibrarySelectionType below
Getting all of the parent valuemaps and merging them all just to get a single property feels a bit heavy. Within the loop couldn't we simply call resource.getValueMap().get(propertyName, declaredType) and then break; if a non-null value is found? That way we dont even look at higher resources in the tree than necessary when the property is at the lower levels, and we dont have to bother merging a bunch of maps. Thoughts?
why not  why not  this(snp, getHaplotype(), likelihoods[0], likelihoods[1], likelihoods[2]);
Why didn't you cache the value?
(ListView)  can be removed
Typo <naming
Why do the containsKey check? If its not in the map, then get() will return null.
You have insertAfter(..) and insertBefore(..) on DataTypeList and its View however use insert(Field)Above(..) and insert(Field)Below(..) here.. would a consistent term be better?
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
can we remove: declare-response, useless-assign and just return the object from the method-call?
Minor readability suggestion suggestion model.addPropertyChangeListener("scriptStatus", ignored->{
You should sort this Set by name asc and length desc. So we always generate methods with greater args count, for overloaded methods.
Do not make input file names cryptic. Please rename the file to clearly state its purpose.
should do some validation too. For example, if the input schema is non-null, make sure the fieldToClassify exists and is of type String, and the predictionField exists and is of type double
I know that tag is marked as NonNull, but since this is part of the public API, we should make sure to not accidentally introduce a possible NPE here. So what about using return tags.stream().anyMatch(t -> t.equalsIgnoreCase(tag));?
constant?
wha would it take to implement this for JPA? bit uncomfortable to have new methods only for particular type ...
better to remove if if statement, just set the value, the user of the entity can than use the getUseFreemarkerTemplate function to choose to use the template of not.
Let's use new CacheConfiguration<> to remove compiler warning
Should this be onReplicationPutRecord?
I wouldn't change the default.
I know this is not from you, but can you change to use arrayList, there is no good usage of linked list.
withMillisOfSecond(0) is not necessary here if it is used above.
This might as well become if (enable) since the for loop will end gracefully whether it's > 0 or not.
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
Not needed.
Minor nit: can we change these to use "reader job service" to differentiate them from the existing logging in ReaderUpdateService?
We should not get into firewallType being null, it should always be set for cluster add/update. If it's null, then proper error should be raised
Formatting is a bit odd in this
I think this can be static
Throws AIOOB exception when called with index = line count.
Was this detected by findbugs?
Should these have some kind of validation, e.g., non-negative, from less than to?
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
Could the method getBlockBlobClient(String containerName, String blobName, boolean autoCreateContainer) be used here?
I really feel like there should be a descriptor in the name, e.g. getQueueUrl(), getBlobUrl, etc. Thoughts?
So you removed final, but keep it immutable * Returns an empty list (immutable). This list is serializable.
racey single check
Sorry it seems I was wrong. It seems that indeed your previous attempt was correct. java if (t == null) { throw throwable; }
getNonEntityNonCollectionRegions creates a copy of all the collections, let's lookup the other maps...
Aren't there any test methods that require compatibility?
add non null validation
Is shutdownNow more appropriate (which would interrupt running tasks)?
I'm a little bit concerned about having this legacy code here. In theory, someone could make a component called None and it would not be selectable since this would just reset it.
None of these error cases need to post events
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
Redundant brackets suggestion return tryActivateAndGet(e, stack.getItem()) != null;
I'd probably format this to have a : before the actual digest value, just to delineate between the hash type & the value.
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
lowercase for package names.
Perhaps change %s to '%s' or so to make nasty leading or trailing spaces more obvious?
java authCardDetails.getAddress() .flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry) .map(NorthAmericaRegion::getAbbreviation) .ifPresent(smartpayTemplateData::setStateOrProvince);
Looks like getCMPath never throw IOException or MetaException. Shall check and remove it.
logger says "Unsubscribing"
The position parameter is in NatTable coordinates and could be out of range in the scrollableLayer. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportPosition.column);
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
This should be private unless there are plans to use it outside the class.
Make the fileInfo map immutable.
Looks like the client and the member proxy implementations diverge if the maxIdleUnit is null. Client interprets maxIdle as milliseconds in this case, while MapProxySupport throws NPE. Same with ttlUnit btw. This needs null timeUnits to be passed on the interface methods though. Is this expected?
nitpick ... this should be renamed to simply gammaId, it's not necessarily new.
this is asking for a helper function somewhere that turns mime type in to a MediaType. Could probably even go in the MediaType enum.
assertFalse(...);
It feels like there's a lot of context and state that's being managed here that would be much cleaner to delegate to a composed cacheState object (which would also make it easier to change this later more safely without requiring safely updating 5-6 implementaitons
unnecessary array new: {{true}, {false}} should work here
Is it really needed to create a new instance of WikiSite or couldn't you just use the one passed to this method?
There should be different ways to compare the type, based on the given type expression: 1. Check for equality with the fully qualified type name (including the namespace information) 2. If no namespace is provided in the given expression, check for equality with the type's display name 3. Check for equality with the fully qualified XML element names (including the namespace information)
personRepository.count()
The pattern we're using in StreamDescriptors is to have the extending classes also override the toConfig method from the base class and call super.toConfig as the first step. Might be a simpler interface for extending classes since there is one less config related interface method. If we do that, you might also not need to call addTableConfig to mutate the passed in tableConfig map in generateConfig.
Call the function with a single Type as input instead.
Should be "InstaPost" actually.
better do the close in a finally block.
Here it's OK: it really may returns an instance of anonimus implementation of ARPMH
I know we tend to always do remove/install in our code, but this is actually not needed: org.eclipse.gef.editparts.AbstractEditPart.installEditPolicy(Object, EditPolicy) will remove (and deactivate) any pre-existing policy in the role we want to install the new one.
this could easily be done when creating the repository as well.
Can you move the System.getProperty calls to methods on RoboSettings? We're trying to make that a central place to hold all system properties.
I'm good to toggle to production!
nit name is null or empty
You can condense this to DISPLAY.asyncExec(() -> progressBar.setVisible(visible));
No, no. Remove this logic (that checks whether the provider exists).
> HTTP_API_VERSION [](start = 51, length = 16) also what does the http_api_version mean? :) #Pending
why is this not private?
Should we include the label too?
In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean.
Please check if this method really should be public in a private static final class. The parent method is protected.
Expected value should be first.
Why it's here? Please try to understand what onInstall and onUpdate are doing. If keep as you wrote: it will be a duplication.
can use Ds3DocSpecEmptyImpl here
Should return an ImmutableSet, right?
As Kai already stated the mime type should not be optional.
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
- this.ephemeralCount = new HashMap<>();
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
use correct variable name
wouldn't it be preferred to store the value of each type in lower case instead of creating it each time this method invoked ?
throw new IllegalArgumentException("Unknown type " + value);
I know I did not mention it in the initial review but TransactionImple.getTransaction() can do a lot of work so I think you need to cache the result in a local variable in order to avoid the second call to getTransaction.
I don't like how this method has to use the duplicated string. I'm not sure the check is needed but at a minimum it should probably use the isPasswordHashed() method.
code format
I would add: setAlertType(AlertType.INFO); So you have a default of INFO for messages that don't specify.
+ NUM_HEADERS + NUM_FOOTERS;
You forgot to add the address to the toString() as you did in the patch on the master branch
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
For non-public methods checkWidget() is not required.
I think lowercase l should also be considered
context.getClassLoader() can return null
I think the attribute "create=true" should not be put in the test case, it is used the very first time to create the database.
Let's remove that TODO: we'll get to renaming things anyway.
I don't think that is necessary.
final?
I'll let @bstansberry review your changes as he already reviewed your PR However could you please rename this variable? WildFly code convention do not use _ to prefix variables? thanks
This may chain to the next (more complete) constructor instead.
Please no System.out.* calls. Thank you!
t should be e
couldn't / shouldn't getTenantAsString return the uniqueName instead? As we use it everywhere in the TenantUserManager
use parquet.Ints.checkedCast or you could get a negative value out of this cast. <LINK_0>
Unnecessary (and incompatible); revert.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
I guess the connectionInterface cannot be null, so we should throw a NullPointerException if this occurs.
It's better to log a message no matter compression is enabled or not, it's always easier to search the existence for a message than to find what's missing from thousands of lines.
BlockPos.ORIGIN
This should go before this.starts.next() as if this.starts.next() is empty, it will throw FastNoSuchElementException and the previous iterator would not have been closed.
Don't use variable names that are abbreviations or misspellings... optimize for readability rather than writability
s/install/enable/ (since there is an install command)
This appears in RawByteBitwiseOperationsCheck.isSecuringByte method, could you move both to a common method in LiteralUtils?
What about data type here?
exiting, so STDERR
... yes it does ...
Lowering should be set to true here, so that the elevator isn't holding up unnecessary weight
I think I prefer "Invalid key" as exception message
Why don't we retrieve the same label provider as for the image? Here we use the constant whereas for the image we use the object, I don't get it. Also, I need a null check would be useful.
This isn't a Messaging component and from other side using this one within a Messaging component, raising a MessagingException from here, we prevent re-throwing a correct MessagingException with failedMessage context. So, for me simple RuntimeException is enough in this context. WDYT?
What would you opinion be as to introducing a snowflake ID as opposed to random? <LINK_0>
Please revert this formatting changes
Same here and above.
this function can be private
use Long.valueOf() instead of new Long() - always for performance reasons
Is blocking, should be on a AsyncTask
Honestly I cannot remember the exact reason why I make this so permissive but I know he has something to do with the GeoServer integration: <LINK_0>
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
not even e.getMessage() ?
static
StringPool.EMPTY instead
probably this is an exceptional situation
why public? Are we planning to use it outside of this class?
and here ;) string concatenation would we preferable.
Why empty? It supports ALL streams!
throws
It could be - can you create a short script to show the issue and open an issue against the repo that contains it?
NAME -> HIGHLIGHT_CTX_DATA
this constructor can be package protected if it supposed to be used for test only
There are enough mock objects in here that it's worth using @Mock annotations instead.
return flagdown; ?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Just an FYI, we have a fairly robust date parser included in EndpointUtil because of variability we've encountered in the past <LINK_0>
Should we have a constant for this?
This makes the countQuery required and will break exiting users. Why is it required? You don't check for notNull, but than pass it on to sanitize, which doesn't do a null check.
you're testing for silence, but detect method returns true? shouldn't return false?
This call will lead to an NPE if no thing type is found for the thing.
Revert this line?
Package private should always be enough for testing. Use the same package for tests.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
remove
Enabling indexing even if autoConfig == false? Maybe this auto-enabling should happen only if autoConfig==true?
Let's move this ternary inside PlatformLruCache as it's an implementation detail of that type.
If this condition is considered as an error, shouldn't the execution be terminated after printing the error?
new String() is redundant.
can be !isDisabled()
why did this one change?
Why is this the case?
Collections.emptyList.
It is still public. Why?
Maybe just return map.computeIfAbsent(x->create())?
no need for concurrent
Not necessary
Shouldn't we switch on the id of the ListView, rather than checking whether or not the list exists?
It seems this variable is not used, can it be deleted?
Can you use EntityType.getEnum inside this method? This method will be pretty much similar to AbstractSchedulableEntityManager.checkSchedulableEntity, except, the exception may be different.
Something wrong is here: ![wrong_object_to_remove](<LINK_0> this.inUseConsumerChannels.remove(consumer.getChannel()); ?
All of these early returns you do like this need to be switched to if (!=null)'s 1) it's cleaner and 2) it makes code easier to understand and 3) it makes future expansion easier without need to refactor these two lines. Not to mention all you single line ifs need to be converted into two lined one minus the braces.
You'll want to use .setText("and 1 damage to each creature that player controls") here.
add requireNonNull for parameters.
Is this stray? Or do you actually set it to test?
Should be added the Override annotation.
why do we need this new method?
@yesamer Please use the *showCheck* method - otherwise we have two paths for the same behavior
Same code as in the method above, factor it out?
looks like the variable name also needs an update in some of these methods
add brackets around if the clause or move on to same line.
The image attribute is not supposed to be the text of the node. I'd rather keep it separate (the previous @Text attribute was fine). A practical reason for that is in the future, other languages may have a way to get the text of their node, in which case that wouldn't be fetched with getImage, for compatibility, but probably with a getText method, or getSourceCode like in #1728. Also we *may* deprecate or otherwise put getImage out of use as soon as 7.0, given its contract is super loose.
Why not just use the element.toString() instead? If we want to use something specific in the printing of the messager we should pass that in the arguments, and not do it in the toString. For debugging it would be much easier to just have element.toString() here.
FIXME: Don't cast getActivity(), use an interface.
Explicit type argument can be replaced with <>.
@Override
maybe just call this.addUpdateTask(operation, key, "") and remove the overload in BoxMetadataUpdateTask
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
Why do we need the scheduler address? It should come from the Hadoop configuration.
Could you please make this an extra bit more specific like -SNAPSHOT? Thanks! :)
this (also below)
validation? channel count must be > 0.
![CRITICAL](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
We can get rid of the above variable
Should use the log, maybe a warning.
This could be refactored into a single return statement easily.
![INFO](<LINK_1> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_2>](<LINK_0>
I think it is not guaranteed that changes to slot are visible within the bulkChecker which uses the mainThreadExecutor to run since the used Set implementation is not thread safe.
this is not good, you've removed the information from the nested exception! :)
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Consider capturing DAO layer exceptions and creating the corresponding service layer exceptions, to abstract away the persistence layer from servlets.
Pull this into a static final variable
This is not going to work as Keycloak may be exposed on a different context-path on the reverse proxy. I.e. frontendUrl could be "<LINK_0>" while Keycloak is listening on "<LINK_1>".
The warning message and the other one is very detailed and more related to transmission of activities. I do not know if it is helpful to mention a sender in the message as these are utility methods. Furthermore even if you see the message in the log file it is not very helpful at all as it does not include the path and you also do not know in what context it did happen (I guess it is the XStream Marshaller when converting activities)
In my opinion, all properties on VoiceStepOtion class should be set with test values. In the unit tests, all of them should be checked with the assertion.
this should be in the doPopulate() not in deprecatedPopulate()
But we have already clicked the button in the command before, haven't it?
Use one pattern consistently: Either model all sync calls as asyncCall.get() or Model all aysnc-calls as sync call + CompletableFuture.completedFuture(null) I'd prefer making async the more general API and expressing the sync-variant in terms of the async one
Use type ChargeDTO in return responseEntity instead of ?
This should be only created by the Guice injector. Make the constructor protected.
delegate=true style would be just fine.
use a dedicated method hasParameter(tree)
always linked hash map please
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
Log as _error_ or _warn_?
This looks like testDataFormat(COMPONENT); Please see other tests for sample
Is there a reason to have this setter instead of using a randomly assigned uuid and having the RollingOperation constructor check not null on it? We use this in some tests, but I don't see us testing the Id itself (and we shouldn't, I think).
Please extract this string
Returning isAuthRequired by default sounds gold to me.
You may use here listContainers(KieContainerResourceFilter containerFilter) to retrieve just containers with specific release id.
For loop?
Please use Singleton annotation and remove this explicit binding. We plan to remove existing such usage pattern.
You should change the error message here to be about AWS rather than GCR.
should move this to a finally block I think
i really do not like that getConsoleText() may throw WaitTimeoutExpiredException. I would expect that it will return text or null if there is none. WDYT ?
You should probably test with both pessimistic and optimistic transactions, and pessimistic with both RC and RR isolation levels. Also multi-node tests can reveal more issues than single-node ones, I think (testing both owner and non-owner variant).
I think it would be suitable if some kind of padding is applied between messages, such as a newline
@v-stepanov isn't it changing the behavior? Before this change we used to log 102 but now it's not clear if the status in the response is going to be 102. I think this is a special log for calls to consumption API where we only know the real response status code afterwards.
Can be inlined in the assertThat statement below.
Why this change?
Should use the log, maybe a warning.
This can be refactored to m_isTable = "true".equalsIgnoreCase(table)
please add specific error message for nic plug actions which specifies the valid statues for this action.
Why not make al these Calculate classes private to the method? Creating new ones everytime is a bit useless
Can this be null?
check notNull?
I believe this can be package protected. If so, please make it package protected.
Please avoid the use of too complex locators. Please use constants.
I think you need to call setSize instead, which does things like updating the bounding box.
Unsure this addition is useful.
We'd better fail here instead of silently returning null?
Isn't this equivalent to the below? java final GridColumn<?> uiColumn = newRuleNameColumn(makeHeaderMetaData(column), Math.max(column.getWidth(), 150), true, true, access, gridWidget); uiColumn.setMovable(false); uiColumn.setFloatable(true); uiColumn.setVisible(!column.isHideColumn()); uiColumn.setMinimumWidth(150.0); return uiColumn;  We could declare 150 as class constant if answer is yes.
Change to: include = true; (@jessehatfield, @meiercaleb) Or should we have a config option for each restriction? (i.e. conf.isInferHasSelf()) It appears that some visitors do have a unique config option while some don't.
We should give a better clue here what they did wrong, but I don't have the verbiage off the top of my head. README will need updating too.
Note you can put these on one line: this.httpRequest = checkNotNull(httpRequest); This can improve readability when there are several arguments (and helps you spot unchecked arguments).
Use Uri.Builder
can we please use {} for this if condition ?
This needs to choose the target when the ability triggers, not when it resolves. I'd use adjustTargets to do this.
hell no
Can you mark this @Nullable please?
shouldn't you convert the logType.getDuplicateEventsIntervalV value to millis?
This should check the environment variable before returning true.
Why? This was here for a reason etc.
Do you have a test that peeks the next sequence number?
not List<T>? :-)
This method can give an incorrect result if the last buffer is moved from the inner queue (which is then empty) to the output buffer (which was previously empty) in between those two calls.
the name of this method is not clear (pun not intended...) because the word 'clear' is usually used when some collection is being emptied. actually looking at the code in the clearAttachments, you are computing the attachments to remove. this makes sense, and is also consistent with the row above 'bondsToRemove.add' but is obscured by the name of clearAttachments. secondly, the last line in the clearAttachments() method is not dependent on the id that is being passed to it. so this line should not be there. it should be here below line 60. then you can rename clearAttachments to calcDestAttachmentsToRemove. this would make the flow symetric, consistent, readable.
Unchecked cast in the old code?
is it necessary to encode duration iso standard?
let's update all the includeTextDetails references to includeTextContent
This is not required. Instead of generating content uri here, simply pass it to UploadItem from UploadableFile.
The pattern is to have the init before the try: AdminClient client = AdminClient.create(getDefaultAdminProperties()); try { ... } finally { client.close(); // no need to check for null if the factory never returns null } But if AdminClient is AutoCloseable you can just use try-with-resources.
lambda
Could you replace the magic number 128 by a constant?
What I'm missing here is the check if the element is null. I know that the probability is very low, but still...
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 89-90. Do the same for the others.
this class doesn't have tests?
specify charset?
TODO: write headers
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
Please check if it is non null and running before you cancel it.
You can replace the for loop here with values.forEach(result::add);.
Don't you check for array size >=1
filterRowKey should only filter based on the rowkey, here you are looking at specific values. This is most likely called only once per row. I'm guessing the current implementation wouldn't work on SPLICE_TXN, since we'd inspect the latest written cell (COMMITTED or ROLLEDBACK), see that it's not the ACTIVE state and filter it out, which would filter out the whole row.
could we print the types here?
Please copy args here too
We will not show the 'saved' message because it is unnecessary. Could you also update the testplan?
Just for consistency, we do not need the keyword this here, see the getter of isEditModeEnabled.
this is just a setter, why we need to update it?
these setters should not be public
remove this
Also called twice here.
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
Instead of two fields Double, you should use double with value Double.NaN when field is supposed to be null.
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
We will probably run this from maven, and will use it to write to a "target/generated-metadata" directory, which won't initially exist, so please create the directory here if it doesn't exist: File outputDir = new File(args[0]); if (!outputDir.exists()) { outputDir.mkdirs(); }
In this case that you read all files into memory, there is no difference between using this and using File.listFiles()... Just saying... Something like the following? :) for ( File file : new TreeSet( Arrays.asList( dir.listFiles( new FileFilter() { public boolean accept(File pathname) { return pathname.getName().endsWith('.properties'); } } ) ) ) ) { loadFile(file); }
defensive copy?
nit: might read better if you rewrite this as: WebMessageCompat webMessage = WebMessageAdapter.webMessageCompatFromBoundaryInterface( BoundaryInterfaceReflectionUtil.castToSuppLibClass( WebMessageBoundaryInterface.class, message)); JsReplyProxy jsReplyProxy = JsReplyProxyImpl.forInvocationHandler(replyProxy); mWebMessageListener.onPostMessage(view, message, sourceOrigin, isMainFrame, jsReplyProxy);
Objects.requireNonNull(arg)
Why do we return the parents name instead of the name we store a few lines above?
Pet peave of mine. I'd prefer Integer.toString(CLIENT_MAX_PENDING_REQUESTS).
shouldn't this be throwing the exception ?
Why did you remove this call?
Starting with Java 8 you can do this: id = replacementIds.getOrDefault(id, id);
Oh, I think those lines can all just be removed. The title in settings is already handled by StatisticsFragment (where you added a similar change). That's a leftover from the old statistics screen with only one single tab.
Was this meant to be isValueDependent()?
Should we alert the user that an error occurred here?
Maybe call the data indecipherable instead of weird?
check for not null
Apache's _StringUtils_ has _StringUtils.containsIgnoreCase_ method
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
I think this already appeared before - maybe move the trenary if logic inside coco.getCommandEntity(guid) ?
other methods like this put name first, then id. switch for consistency
You can use getDbFacadeMockInstance() instead of mocking it yourself
magic number
again I don't think we should modify the generated methods. If we need to we should set this on merge.
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
Pattern.compile should be done only once.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Please add braces surrounding the for loop block. Otherwise this is confusing to read.
I think this stops admins from installing at for example /code/review/ on their server.
I'd return suggestedId for the time being, but if you have reasons to keep it this way for the time being I'd be ok with it.
null? why not just a () -> {} ?
I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?
Wrong method name in the error message.
this line shouldn't be there on this branch (sorry, forgot to mention)
Why is this necessary?
Same here, but check the max cook time instead.
Do we want/need this method to be public? The check is pretty straightforward.
Style inconsistency: space after if
How about including Loop will be retried in the message (like WorkflowExecutorLoop's Uncaught error during executing workflow state machine. Ignoring. Loop will be retried.) so that we won't be shocked too much when server shows this message?
As for me, it will look a bit better with something like  final int offset; if (child.getMainAst().getType() == TokenTypes.OBJBLOCK) { offset= getBasicOffset(); } else { offset= getIndentCheck().getLineWrappingIndentation()); } return new IndentLevel(getIndent(), offset);
Nit: the else is redundant since the if block above returns unconditionally
return (algName.equalsIgnoreCase("DSA") && algURI.equalsIgnoreCase(SignatureMethod.DSA_SHA1)) || (algName.equalsIgnoreCase("RSA") && algURI.equalsIgnoreCase(SignatureMethod.RSA_SHA1));
Just a suggestion: Objects#requireNonNull(Object, String)
The check is not necessary, File.mkdirs doesn't attempt to create the directory when one already exists.
Why is this now modified by this patch set whereas is wasn't earlier?
isInfoDebug
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
We should not be throwing RuntimeException
I don't see where we handle HibernernateException.
Should we add an empty() check for ignore.value() as well, before doing this concatenation because if the user didn't specify any value for value(), then we will end up setting a description which looks like  : my regression which kind of looks odd. So I think we should add an empty check for value before we decide to use it to set descriptions.
It may be cleaner to use Objects.hashCode for a single parameter, and Objects.hash for multiple (see the warning with Objects.hash, though that doesn't appear to matter here).
replace with return this == other;
the mafs often have the extension txt or tsv as well
Should be ObjectId, as the mapping cannot be mutable.
Any reason to use an unmodifiable list as the list is already a newly created one?
The pattern we're using in StreamDescriptors is to have the extending classes also override the toConfig method from the base class and call super.toConfig as the first step. Might be a simpler interface for extending classes since there is one less config related interface method. If we do that, you might also not need to call addTableConfig to mutate the passed in tableConfig map in generateConfig.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
remaining time only makes sense if the state is down. In the up case downUntil could be in the past and this could print a negative, misleading value.
for readability, consider using 'ImagesHandler.filterImageDisks' and check if it's empty...
Missing strings to fill in the first three placeholders: suggestion System.out.println(String.format("Received event [%s] on channel [%s] with data [%s] and event [%s]", event.getEventName(), event.getChannelName(), event.getData(), event.toString()));
Add the info log back after this line?
Use the new String(byte[], Charset.forName("UTF-8")); form to avoid the try/catch. Constify the UTF-8 Charset elsewhere for extra points ;)
this((Run<?,?>)owner, from, to) would be much simpler
Can just store a boolean shouldSkipVerification instead?
No need for public setter as it's set in the constructor.
I don't like the side effect within the if-condition (nothing wrong technically here). Could you please revert this to the form with a temporary variable like it was before. In addition, the code indeleteSilentAfterExtract and deleteSilentAfterCancel is identical. You could introduce a new private method private void deleteSilent(Path file).
Let's make this private and introduce two factory methods known(String, UUID) and empty()
I believe Role.SERVICEUSER would allow any service user to call this. Regarding rest of our API, you should check for FACILITYADMIN role and you should filter resulting list of facilities to return only those, where user is facility manager. Or to be more correct you should check, if user has READ right on attribute he search by on that facility. If not, do not return the facility.
Typo on attribute
I'd like to understand the reason of this extra MutableMessage creation object before encoding...
you import ByteBuffer, no need to use the full package path
Send this exception to the log.
I don't really like using null as a sentinel if we can avoid it (since it's nice to be able to use empty objects to avoid crashes around null references). And I don't think the server makes any guarantees about whether children is nil or just the empty list.
getAppDataSummary can be removed here as its contents are included in getAppData (same for device metadata)
this.
Couldn't you just to do: setXyz(0)? Like many other config classes? Also if you just want to initialize the value to 0, wouldn't you simply default the field value to 0 instead?
Hmm, why did we do this? I thought we'd have a try/catch block.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
can we use BeforeClass annotation?
Do we think that overByAmount will actually be a useful/actionable piece of information for users? As opposed to just saying it's too big to upload without specifying by how much?
Line delimiter allows newline or (carriage return-newline). Imap protocol is always delimited by carriage return - newline. Change to use only carriage return - newline.
I think that the log messages related to extensions cannot be part of "pluginNotStarted"
There's a way to avoid that n+1: doing a query searching for all questions in (:ids) and, after that, using session.load to get the questions in the specified order as you're doing (the hibernate would get the questions from the first level cache once you already selected them before). (yeah, its not pretty, but works)
extra newline
Why use only w2? Why the right shift? Likely it doesn't really matter.
This looks very user unfriendly. Does the UI really allow users to get this far?
Is this correct then?
it'd be nice if we could use polymorphic deserialization, but i thinkthat is a bigger change
This has nothing to do with your contribution. I would keep the class name as a String as it is clearer and avoid to import Serializable which is not required. Same remark for the other arguments.
No need to change. I feel that it's from the refactoring action
this("Safety Command")
Will the behavior of the other fireActivity(...) methods change in the future? Otherwise, you could consider just having one fireActivity(IActivity) method and differentiate between the activity types internally. This would allow you to avoid the code duplication for the other methods.
are you sure?
Are you aware that this very expensive use of String.format is executed every time, not only when debug is enabled?
Please change this to  java return new ArrayList<>(failures);
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
Let's refactor Topic a bit to be able not to pass anything there. We'll have something like new Topic().withBody("ab") and therefore other fields like title will be generated randomly.
nit: No need to print out organizationDiscoveryIntervalMillis.
why is this public?
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
log exception
Oh please, no! Don't ship a null object! :cry:
Does this need to be a left join or would JOIN FETCH be sufficient? I don't think there would be an entry in this table if the association wasn't there.
why delegating
I would delegate to the new method directly
You can do this instead.  proxyPorts.stream() .map(port -> "localhost:" + port) .collect(Collectors.joining(",", "terracotta://", ""));
This will call fireEvent() while the monitor is held, which will synchronously invoke registered event listeners. Invoking callbacks from a synchronized block is... risky.
nit, Collections.EMPTY_MAP?
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
This should follow the normal exception handling path and let the caller handle the printing of the exception.
See ByteByReference.java
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
I think all these assert methods can be static
i think we had talked about swapping the order of these so we can short-circuit?
You don't need this as compareAndSet will set it to true.
add: import org.ovirt.engine.core.common.utils.Pair;
Thow applicable exceptions
Shouldn't the FBOs be disposed here as well, when they are created here?
log and throw anti patttern
nit: Root groups cannot be fetched from the database
Why not return getAnnotation(annotationType) != null?
please also add the GUID which is important.
This looks like an infinite loop to me?
I don't see where we handle HibernernateException.
remove empty line
can also use a for each here
I assume this function must only be called if the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
Exception should be logged.
CHANGE it to TypeConstants.JAVA_LANG_RECORD
Possible deadlock: remove this call to sleep(). It's possible that no events will ever arrive.
You can simplify this by reordering the states.
Why to call finish?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I still don't see why we need the 'if..else' here? both cases are the same
Invoke validate()?
Should we include organization here too?
Again, I think this should evaluate against the standard special path info, not the stuff for the maven package
Simple for-each?
why not use a ConcurrentHashMap instead of making all these functions synchronized ?
Since there are two places using "tree-item", consider replacing it by a constant just like you did on the other classes.
can just do new ArrayList<ICommand>(commandMap.values()); instead of separate addAll
new ArrayList<>();
addAll
you could assert that the module that you loaded is in there. at the moment you assert that the number matches what you expect but it could as well have been the same number before you loaded the module. You did not check that.
You could just call the other ctor
Yeah, here's where I was thinking of using our custom exceptions. IdpResponse.fromError(...)
'isManagement()'? Please fix.
Add the check here.
Nit: Wouldn't it be good to move the settings to new lines? suggestion Settings settings = Settings.builder() // .put(loadConfig()) // .put("transport.type", "netty4") // .put("http.type", "netty4") // .put("path.home", this.pathHome) // .put("path.data", this.pathData) // .put("cluster.name", this.clusterName) // .put("node.max_local_storage_nodes", 100) // .build(); node = new TestNode(settings, Collections.singletonList(Netty4Plugin.class))
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
Should use the log, maybe a warning.
there is no need to execute initElements method, when you're extending BasePageObject
It could use StringBuilder instead.
Help me understand the change below more. The one on the left seems simple.
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
extract getVmDao to getter
not need for 'this'
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
Please keep this.cell near the related fields (previousFamily & cell count) below
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
I think that's the same as new HashSet<>(vertexRegions.values())
resolvedImges can't be null otherwise the next for loop would fail with an NPE. Actually I would either put this into an extra method which returns early in this case or put this into an if-else with the following loop.
I think we should use the setEnableFeelLegacyBehavior here so that we have a single point where the flag is changed. This might lead to inconsistent behaviour if a user isn't carefull.
No need to declare the types in new constructor, diamond is enough
Is this important? Should we throw instead? Or just make this a debug message if it's not important? (same for seek)
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
we shouldn't need the ?test param any more
can we make this one configurable?
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Remove this
Shouldn't this close the iterator before returning the list?
This code can be replaced by return str.matches("^[-_.a-zA-Z0-9]+$")
Should there be a second catch for ClassCastException? is art checked somewhere to verify that it is always a teamWorkFlowArtifact?
Guess we may want to leave the log in the same state in-case any one of the log segments throws on close, and hence we throw right away is it? In other words, might get a suggestion as to why not close as much as possible even if some log segments throws exception.
nit: I don't think you need fully qualified path name. it can just be CompletableFuture<LedgerEntries>.
This doesn't have to be public. Just use default package access since only thee cache impl in this package has to see it.
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
Inline this
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
Should these have some kind of validation, e.g., non-negative, from less than to?
nit: you can merge both lines above as checkNotNull will return the given argument
Can you add @NonNull @CheckResult @WorkerThread to these two methods as well?
Don't need to call here either
In cases like this I would expect it to throw an exception instead of returning null. For error handling it's okay to diverge a bit from the canonical data (I believe they're trying to remove most error cases from the canonical data for this reason) since it can vary a lot from language to language how you'd want to handle invalid input. In my opinion it's better to throw an exception in Java than to return null since that forces to user to deal with the error instead of relying on them checking if the output is null :)
Please enable run button in background tab
What happens when we have a file named "pack-1234idx" in that directory. No '.' but ending in a well known extension. Such files would be deleted, or?
should we be returning the defaultValueForNull instead of 0?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
instead of addAll(), you could just return the free vars from the definition. Same in VarDeclaration
suggestion this.className = requireNonNull(className);
We might need is[Type] methods for each avro type. What do you think about it?
I'd change this to include the full name of the sender. Tickets were bought, so a filled in profile is guaranteed. The term "user" isn't really something you want to say. They're people! :stuck_out_tongue_winking_eye:
Just a thought is the contract for running that its fully started? As Camel has a state called .. starting which is the phase it do when it startup. But I assume running is after all the startup stuff and its really running.
"You do not have any tapes"
> Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
I suggest encoding the above 4 assertions in a single call: assertEquals(ImmutableMap.of("1", "hazelcast", "2", "phonehome"), map);. In general it is a good practice to check the expected output in one assertion, instead of checking its pieces separately. Also, in these assertEquals() calls the expected and the actual values are mixed up. First should come the expected, then second the actual. Of course it works this way too, but if the assertion fails, then the output becomes confusing if the expected and actual are swapped, so it is useful to always put them in the correct order.
can we use method reference here this::createHeathIndicatorForCircuitBreaker
the client could be null
do we need new Array here? You can just use ImmutableList
<code>Downloadable.get()</code> may return null. It is a mistake in the original code, but it makes sense to fix it.
as is in 718
SecurityException?
Those two methods are similar. Consider using one.
Value nor envVar wont be ever null, but empty strings, so that check will be valuable
SpeedController not CustomSpeedController
this.id -> id
super. is unnecessary
Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.
decrease to TRACE level
Instead of exposing the data storage, I wonder if it would be cleaner to add a method to add something to the storage.
I find this confusing given that soon we'll have searchable fields that are not indexed. Should we rather rename it to failIfNotSearchable ? And the error message? Or maybe isSearchable should rather be isIndexed ?
final
This should be doable with Allele::basesMatch without converting the allele and the transition base to Strings.
Should not be necessary as you remove it in deactivate already.
I wonder if this method should take the check one step further and verify not only at least one location provider is enabled but also that LocationManager#getLastKnownLocation(provider) returns a non-null value for at least one provider?
magic numbers
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
I would use log.infoFormat since it is the standard way. Also, I think logging this at info level is too verbose, this sounds more like a debug to me (and if someone wants to monitor this query specifically he can lower it's log level)
This would not be a performance improvement. (And a tab character has appeared in the file.)
I assume the substring(1) is to skip the leading /. Can we be sure this will always be there? I think I'd feel more confident if it was something like Arrays.stream(path.split("/")).skip(1).collect(Collectors.toList()), which won't blow up if it isn't.
typo
should we also set myLocationEnabled = true here?
**USB**
We could omit the second Integer.
This method returns an Option<DRepresentation>, so the API clearly says it can be null. You must check 'if getRepresentation().some()" before.
For each?
eror  -> error captions -> depictions
What is this for? Feels like some unintended checked in code?
please add PageObjectLogging.log method here
@dalifreire join this with the previous line
Windup/Discover/Java ?
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
I don't this this is right solution. We don't need to to build and send a message only when there is no particular channel.
I think Assert is not imported and compilation will fail. Also can we test the cases when number of parameter and argument doesn't match?
style nit: no braces around single line blocks
I think it would be suitable if some kind of padding is applied between messages, such as a newline
I don't think you need this check. Just return size * 1024 ?
why do you not do this in DiagramElementEditPartOperation.activate(this); ?
Should't we call this incrementEntryRemovalCount? Other reasons can also be the cause to call this remove method like like expirations.
style nit: we don't use braces around single line blocks
why gone?
Given that this method is already dedicated to the audience claim, this change is redundant. Please rollback
foreach
This should actually return something, no? :)
@ikhvostenkov again json, maybe this part with mocking MemberProfileJson and adding when to it could be moved into single private method that would accept just the filename as a parameter.
I think that this is not a clear way to reset values to default - I think, that there should be something like: System.setOut(System.out);
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
Nit: could be called e1.
the put will remove the previous mapping
We'll get NPE here if socket is null, right?
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
no need for a final local var in this context.
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace the synchronized class "StringBuffer" by an unsynchronized one such as "StringBuilder". [![rule](<LINK_1>](<LINK_2>
Minor, but looks like this was for debugging and should be removed.
Could we use getUploadQueue() here instead of mQueue directly for consistency (like in getNextMediaToUpload() below)?
mixing tabs & spaces
the logic would be simpler if you just delete the key for revoked when is null
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
For executors that have a queue, we set the core size to be the same as the maximum size, so setting the maximum size should also change the core size. Maybe we also need attributes for the queue size and the maximum queue size.
Can we deprecate one of getURL or getUrl, and have the deprecated one call the non-deprecated one?
Mock this also.
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
replace with fType.add(DescriptorType.STRING); the idea with EnumSet is that as you see values you just add() them to the set, without having to care for the current contents. Then when reading you can check things like contains(), or the utility methods like isNumer() proposed above.
Collections.EMPTY_LIST
Even though it's java there is no reason for trailing spaces
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
we want to print to ex with the stracktrace, so do LOGGER.error("Error trying to close response", e) instead.
why do you deregister the trace?
I think it's customary to add the encoding; UTF-8.. IIRC @psiroky went though the codebase a while ago adding missing encoding... might be worth checking.
If this constructor is to be called only by the builder, remove the public modifier
isAbsolute is determined by if it has a scheme or not correct? Maybe use this instead? import com.google.gwt.safehtml.shared.UriUtils; boolean isAbsolute = UriUtils.extractScheme(url) != null;
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing an exception if the property is set, but is not "true" or "false"? Or, at the very least, log a warning.
Same thing than IntentBuilder.
Refactor getRoles() and getPermissionTypes() to return the array and construct the response object here since methods don't really need the root as param.
For future PRs, we use /* package */ to designate package protected methods.
EINVAL is expected for FileDescriptor.out / FileDescriptor.in. This is only expected to work for descriptors to "regular" files, and won't work if in / out are pipes or sockets (which they are, in some configs. The man-page uses weasel words to say this "EINVAL... or an mmap(2)-like operation is not available for in_fd,".
![INFO](<LINK_1> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_2>](<LINK_0>
nitpick: _latestBrokerOffsetsFetcher = null; // after shutdown
Could the uses of "/" here be replaced with Region.SEPARATOR, to remain consistent with the rest of the codebase?
If this was at the PaymentOutcome level it would use  Set<ConstraintViolation<PaymentOutcome>> constraintViolations = validator.validate(telephonePaymentRequest);  and then it could be passesValidationForNullPaymentOutcome and the assertion would be  assertThat(constraintViolations.isEmpty(), is(true));  , but it's not so it should test what the actual constraint violation is (applies to all validation tests). For other validator tests - they're not at the deepest validator level (which in some cases seem either impossible or difficult to do), and there is no general test for CreateTelephonePaymentRequest, so checking for the actual not null violation should be a part of them.
Or maybe just the following?  return HashCode.compute(principal,privileges);
> HTTP_API_VERSION [](start = 51, length = 16) also what does the http_api_version mean? :) #Pending
You can write this shorter: int size = Math.min(raw.length, FIRST_FEW_BYTES);
it would probably be more appropriate here, since this is an async command
Oh, right, that was me. Sorry!
Why do you need the filtering here?
Note that it would be clearer for this to be marked protected: the class is abstract so this constructor could only be called by subclass constructors.
@jackyq2015 best to wrap things like this with URL encode as a best practice.
In previous implementation, we had a different behaviour: all open traces will be updated in case their current time intersect with new range.
Multiline for statement should be wrapped with braces.
Only this check might be enough?
It seems that we are missing the resolved name for the getter case. I was thinking that we would need similar property as for the field to store the resolved name or am I missing something?
Better to return "";.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
If the BigDecimal multiplier values were static final class variables, you wouldn't have to "new" them with each conversion, which might be more efficient.
Why not extract assertThat... into separate methods: assertRoutingKeyResolver for example. If the requirement is not fulfilled, a message could be provided to be used for an AxonConfigurationException (I would argue that we could use the same message for both purposes: invoking the build method and validate method).
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
throws RestApiException not necessary.
Please change to externalSearch =
why ? how could this happen concurrently ? the workspace modification locks should prevents this.
change to arg
Why MobileSelector.IMAGE ?
please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean());
typo "cannot"
I think you want to call the new method which gives servers based on glusterPeerStatus
Calling System.exit needs to be carefully controlled or it will break embedded usage. "Quitting" an embedded CLI may not mean the user wants the embedding app to exit. On the server side we do this by using a SystemExiter interface, and all "exit" calls use that. We then swap in different impls of the interface depending on how the server is being used. The standard impl that is used when we know the server was started from the command line calls System.exit. Others do not.
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not get into corner cases :) )
grammar nit: 1, not one, and no :
Just use something like ZoneId.of("+08:00")? convertToZoneId should be removed eventually.
shouldn't actual <--> expected be replaced here as well ?
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
I'm not sure about the method name though. Why not "build" like in the state system analysis? Or "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
Maybe this will already be immutable. And a list.
Assert.notNull() - just for fail fast, since we really don't support null for this property.
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
I assume these are no longer throwing UnsupportedExceptions because split is something we want to hide (e.g., not have users worry about it at all and make it a no-op)?
@Before / @After could overwrite System.out :-P
Can created URL class loaders be cached, it should not be necessary to create a new class loader each time loadDependencies() is called.
throws APIManagementException
I don't really see a need for constructing a File object with the path to an URL here, just split it yourself
I think we should also perform the reverse operation here if possible: If only the new settings are set, also write the deprecated ones. This does not add much complexity but makes scheduler upgrade/downgrade paths easier to reason about.
This is a breaking change.
why not have the formatting method in UserAgent?
This code involves a potential NPE.
May be good to include a message for each of these exceptions.
I'm not a big fan of this format. Let's keep things consistent and put curly braces around the throw new CandybeanException
Minor: would be cleaner to have an overload instead of multiple null versions.
This should instead be this.setJobMetadata(LoggingFilter.OWNER_KEY, owner.getKey()), since the owner is never actually used as an argument in the execute method, and is only used as part of the metadata.
Java does not contain the keyword null.
I don't like this arbitrary limit of 400. Instead, I would check whether the index of the last visible line is lineCount. How about: public static boolean isShowingEntireContents(StyledText widget) { if (widget.getTopPixel() != 0) // more efficient shortcut return false; int lastVisiblePixel= computeLastVisiblePixel(widget); int bottom= widget.getLineIndex(lastVisiblePixel); if (bottom + 1 < widget.getLineCount()) { // There's definitely more lines below return false; } // Check whether the last line is fully visible int bottomTopPixel= getLinePixel(widget, bottom); int bottomHeight= computeLineHeight(widget, bottom); return bottomTopPixel + bottomHeight <= lastVisiblePixel; } That should also be much faster since it would at worst compute line heights for the actually visible lines, and it doesn't need any arbitrary magic number.
Oscars began in 1928 seems leftover because of copy/paste
I would add the case with Long.valueOf (to justify the generalization you made in the code).
nit: can you put "File connector started" instead?
Same as above, please move this line under the SetViewport line and add an empty line after it.
no need for this variable
It seems that we are no longer required to pass the session Id to the event?
Thanks for adding this!
nit: make this final
It would be great to have braces around.
Wouldn't this just be retryContext.tries() and not retryContext.tries() + 1?
@paulodamaso the braces and return are not needed here
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Revert the changes here.
I'm not sure you need this method at all.
With compression on, the serializer may always return a much smaller package than the input size. So do we have to fail it here? It is debatable.
See earlier question.
A more clear approach is to return an initialized reference and set it to a final field, i.e.:  this.annotatedMethods = wrapAnnotatedMethods(delegate.getMethods());  Also the sets should be immutable.
Gross! Could you change this to print the warning to the logger instead?
Possible candidate for bind() if that method is created.
This is a very interesting way of handling this. I'm not quite sure how to feel about it yet, so let's leave it as is and see if it establishes a pattern for general output processing of the Java rules output. If so, keep them all; otherwise I would argue this is probably an expensive way of doing a null check.
Newline at the beginning of the string? For readability?
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
Why use a full-name import here? I don't see any conflicts.
should this count be parameterized?
Wanna use another example? It's likely we'll support top-level primitives.
Assert.hasText() ?
+ desc
Instead of casting the context to CategoryImagesCallback, should we consider actually passing the callback to the fragment ?
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
same question about the list here
Variable attributeValue always contains null (see line 24), therefore this matcher will never match.
Could you replace the sole use of Guava's Files in this class with java.nio.file.Files.copy() and then avoid fully-qualified class name?
Use the API method and pass all given ids as ListInstancesOptions.
same question as above
It seems that the logic related to ongoingSyncs has potential concurrency issue. The worker never sends sync reply message if the following scenario occurs: each statement is executed in the following sequence L193 (if clause is true) -> L204 (if clause is false) -> L194~196 (if clause is false) -> L207.
Check if inputStream is null.
Since the menu item click has been handled, return true instead here.
Maybe better to return null
Please use Collections.unmodifiableMap(metaDataQualifiedNames) here.
why? let's format it properly, it was ok before. annotations and method definitions on different lines
Why is this behavior changed? It used to be NOT waitForWrite, but now it waits instead. Is that true?
rename to p, prop, currProperty
Are you sure you pushed it?
same question
create a buildServingTrucks method or something similar in the TruckEntry class instead of doing it here
mmm, i think this whole method should just always true. an I/O problem and all the other things are different from not being able to handle the request.
delay is already completed.
Would be great if we can check if the envelope.getOffset() is not null.
foreach loop, append the comma always and then resize the stringbuilder => shorter, clearer code, and more efficient :)
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
change it to log.error
should this be in a finally block to release in the case where an exception occurs?
There's no operation on SenderInMap, is this line redundant?
optional: consider returning this from setters to support chaining configuration.
Just asking, should we put it in the map too?
Please move to a separate "Polishing" PR.
try block.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Might be worth having a displayName?
Need to implement
"Magic" here was just a quick and dirty way to assure modules and stuff are loaded before running the tests - could you check if it is still needed and remove it if not?
Just putting it out there early in this review that I'm not too big of a fan of LongRunningOperationStatus - it's very long.
ok, I don't fully understand the class heirarchy in this connector. It's a bit confusing for me, but if you don't want to change this now it's ok. This review is big enough already.
This same as next test in terms of logic, since you're not actually testing the "default" min range is used since a min range is set on the annotation.
where did this go?
Should we keep a reference to the Bundle here?
requireNonNull
please validate ledger id
package or private access is acceptable since the inner class is private
No idea why, but the loaded_template entry on quality gate has not been removed on my box
ArrayUtils.contains(pageTypes, component.getResourceType()) ?
it looks like an universal operation, did we checked if sth similar is not performed in repo already?
Should you check .endswith(g.getName())? I find Jclouds prepends 'jclouds#' to the names of security groups it creates.
maybe it should be in a checkState as currently it would mean that there is a bug somewhere, no point of having parallel sort without a merge
@override and function declaration must be at same line.
is uniqueness of channelTypes guaranteed? The former HashSet would have removed duplicates.
Why not java static Builder builder() {  ?
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
log.trace
This plays the current, not the next station.
Why this? Is this an hack to make enum object has a value field with as type the enum itself?
Need to take a copy of the context to isolate it from changes to the global context that may come later. It should be, current style:  this.context = ARQ.getContext.copy() ;
Let's remove protected so it's package-private instead.
Shouldn't you be able to replace this with:  java return requestContext.getWebRequest()  If it's unset then there's a bug somewhere.
Exception should be logged.
This can be done through one call to obtainMessage(what, arg1, arg2, obj)
Just use !secondaryIndexes.isEmpty()?
Isn't this check is redundant?
This line is probably not needed at this point.
Multi return is forbidden.
I'm pretty sure "" is probably not a Synapse-friendly name either. (Or if it is, it's not a particularly useful one.) Would it be better to just throw on a null input?
Since this is only used in tests, is there any reason why we can't just have this exception bubble up all the way to the top?
this.
This line could merge with the next line, making the next line return new UID(requireNonNull(v));
This is perfect. 2 things though. 1. You need to also add clones of actions in the composite action here. 2. PrepareView should call prepareView on all actions in actionList
Minor: same as in other number check, WDYT about checking for the decimal point?
Will need a @since tag.
This is using scheduleAtFixedRate but task DirectoryScannerThread never terminates.
Looks like this field is never read.
Should make a more proper exception for this get call.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
returning an empty list by default would be nicer here IMHO, no need for null check on the invoker side.
checkNotNull
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
UnsupportedOperationException seems reasonable here.
I think that to be consistent the result of apply fn.apply(name) should also be checked using Preconditions.checkNotNull but maybe it is not needed?
Could change the return type on method to Collection
Please add { } even if its a single line statement.
What's up with this last one? Should it be in the finally block?
This is where you should print a stack trace.
Boolean vanished?
What is the general consensus around repositories with YELLOW health? Can those still be read?
Is this used anywhere?
nit: move this after catch, so that .success() failure doesn't trigger failed()  T t; try { t = supplier.get(); } catch (TException e) { responseHandle.failed(e); throw e; } responseHandle.success(); return t;
Please bring the braces back.
why this is in vmCommand? should be in stopBase command
I think you need some synchronization around modifications to this data structure. If I understand correctly, the Chore will be run in it's own thread, while quota changes would be dispatched from an IPC handler thread.
Instead of the try-catch please use the ValidatingVisitor#getFailureOfSchema(Schema, Object) method. It can be a little bit faster, since it just returns but does not throw the exception, so the stacktrace generation doesn't take time.
What is the reason for this change?
It is generally a good idea to make sure dispose() methods will not fail if called two times in a row. Here you'll get an NPE.
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
In the page, projects are sorted by a comparator, so that projects.get(0) may look as a randomly chosen project. The same problem was solved in NewApplicationWizardModel.getDefaultProject() by applying the comparator.
we never use NULL, it is a bad practice in general.
You forgot to add the address to the toString() as you did in the patch on the master branch
How does the deadline in Context set by user? It seems to be harder to track where the deadline is coming from.
hope it will works here as well for this class
Bad variable name! Variable names should be clear enough. Rename it.
@vilchik-elena if you follow my suggestion on file.uri() you'll have to update here as well
suggestion
Please use SecurityUtils.getMessageDigest
maybe log an error message here if numConnections ever goes less than zero
Looks like you are making double slashes here...
In order that the test runs successfully is a debugger required or is this some artifact of the test development?
Sounds like a singleton?
I don't think this is atomic.
not needed
avoid this containsKey
Is there a reason why this. is used for calling the setter in all the constructors?
How about setup(Long.MAX_VALUE)? 0ms timeout only works when we use wait(timeout) for checking timeout.
Should also have tests for strong with preceding character content, and following character content. (those are areas where we've had troubles before)
to be extra careful with the set math, might want to test which capability was deemed to be not allowed
uriHost is already a String. No need to call toString() on it.
Why does it return void?
simplify: return ...
These can all use ~~milestone::isSelected~~ PickerLabel::isSelected.
why is this public?
"notation".equals(resource.getURI().fileExtension()) to avoid potential NPEs.
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
Why add this here?
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
Is it worth having null checks?
Since the data set is the same for JobRecoveryTest (and because it is interesting to always test both JobRecoveryTest and NodeRecoveryTest on the same data set), maybe we could share this data set through a dedicated class, for example RecoveryDataSet?
Shouldn't we propogate this exception?
For loop?
Same here. Simple call to filter() is more readable
Don't we need to the close the streams?
This should probably be java if (CliLogger.ROOT_LOGGER.isTraceEnabled()) { if(satisfied) { CliLogger.ROOT_LOGGER.accessRequirementSatisfied(toString()); } else { CliLogger.ROOT_LOGGER.accessRequirementNotSatisfied(toString()); } }  The toString() may be expensive.
It turns-out this is not permitted. I now get an IllegalArgumentExcexception, saying high watermark has to be higher than low. I will add a small high watermark buffer, then.
settings - > keycalok/settings?
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
please leave it that way - it's intentionally referencing the deprecated version.
Can we introduce shutdown() to the _PartitionDiscoveryThread class. shutdown method can call the thread.interrupt() or any other mechanism to shut itself down?
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It should only be temporarily turned off to create (or delete) test content.
These checks would work better in PartitionHandlingConfigurationBuilder.validate(), logging warnings if the merge policy is ignored. Although I'm not sure the numOwners > 1 check is really needed...
getUsername().isEqual() make the same thing ?
WithTasksContext
Is not safer to use Locale.US instead of ENGLISH ?
That's not the correct message. The message should be: "Url cannot be null". And while you are at it, I believe null in the following two parameters is an error also.
for consistency with other classes, use Objects.hash()
This is breaking the existing conventions about allowing nulls. If we ever receive null inputstream we should throw an error here. To avoid them, we should change the calling site, not these utility methods, which operate under narrow set of constraints. suggestion
would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?
should this be 3.5?
pls. use Collections.emptyMap() instead.
entryId is not used, please remove
I'd suggest we also log/throw an error here if anyone attempt to rename a permanent group. That way if the UI layer (or any caller) makes such an attempt, it will receive an error message in return, instead of no response.
Typo? getTopologyMap -> getFaultZoneMap. And getFaultZoneMap throws an IllegalArgumentException when "The fault zone in cluster config is not defined" - it seems to be client error. Would you consider catching the exception and then returning a client error, instead of a server error. I think it'd be better to differentiate a client error and a server error.
i'd add "perform"
If exception happens, the ByteArrayOutputstream will never close it. Please move it to final block.
maybe we could query this somehow from JobManagerMetricGroup but I am also wondering whether the JobManagerMetricGroup registration/query code belongs to scheduler and not to a separate e.g. SchedulingMetrics or so component.
@ztravis synchronized scope, can be more smaller, like below.  private final Object getDateFormatLock = new Object(); public DateFormat get() { DateFormat dateFormat; synchronized (getDateFormatLock) { dateFormat = (DateFormat) threadMap.get(Thread.currentThread()); } ... return dateFormat; }
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
would be nice to try a few different configs here... like localhost, localhost/, localhost:9999/, localhost:9999, localhost/ .... maybe make the test do foreach(String zk : new String[]{"localhost", "localhost/", etc}
return queryId
Why don't we just set the memory usage with the setGeometry call? It's easy to miss setting the memory usage after setting the geometry.
Should this check Collection as that is the super type for List and will capture Set, Queue, etc.
Having users of the method forced to wrap the parameter into Collections.singletonList, I am thinking, why isn't there an overloaded method with , ... BibEntry entry added, which alles Collections.singletonList internally? -- Reasoning: There are more callers than callees, thus make it easy for the callers.
minor: I personally think that 'this' is redundant here.
Return all of them
putIfAbsent or use synchronized block
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
java @Rule public TemporaryFolder tmp = new TemporaryFolder();
perhaps a switch on severity.toLowerCase would be more readable?
I think this message can be reformulated to be less confusing. That's not really clear where which id is supposed to be. And yeah, pay attention that exception could be exposed to users. Then maybe something like User ID does not have permissions assigned to devfile ID
Assertion seems to be missing?
Dont use toString(). Our convention will be use the enum's name() function. Also please change the previous one.
Unnecessary this.
null and empty API key should throw
what is the purpose of this line?
Same deal here: use this version as the base, and have the extended versions just call into it with each arg.
Shouldn't appId and SecurityToken values be URL-encoded (or any URL parameters that could potentially contain illegal characters elsewhere in this source file)? I see the default app ID has / and + in them, for example. The appId might be only accidentally working at present.
Should be !socket.isValid()
for single lines, we do not want to have brackets
add non null validation
A Repository can be opened through the RepositoryCache or in a standalone way. We cannot change the close method to not close otherwise we will affect the standalone use case. The repository will never be closed because evict will not be called in standalone. I see 2 options here: Repository opened through the repository cache could be wrapped in a class holding the usage counters (useCnt and lastUsed) and overwrite the close method to do the logic done in evict method. The problem with that approach is that wrapping repository in not possible when repository is added to the cache using the register method. For this solution to work, we would need to remove the register method (and break backward compatibility). Another option is when repository are opened through the RepositoryCache, we leak one usage counter(as it was originally implemented) so useCnt=1 would mean that repo is not used but still in cache. In the therminator thread we do: Runnable terminator = new Runnable() { @Override public void run() { try { for (Reference<Repository> ref : cacheMap.values()) { Repository repository = ref.get(); if (repository.useCnt.get() == 1 && (System.currentTimeMillis() - repository.lastUsed.get() > 20000)) { RepositoryCache.unregister(repository); repository.close(); } } } catch (Throwable e) { LOG.error(e.getMessage(), e); } } };
s/isUserSelectVolumeType/isUserSelectedVolumeType
As a safety precaution, should we make this assignment just once to grab only the very first line number in case generated synthetic lambda method contains more than one line numbers?
I'm assuming this constructor is combining the two maps? If so, didn't we just get the jobCoordinatorZkBasePath from config? Do we need to add it back again?
Check for the existence of the file to delete?
missing @Override declaration.
This is another behavioral change that I don't want to see in an unrelated PR.
To improve, I think .warn is better.
any special characters to block in webhook name?
this must look at both request and session.
Nitpick: update variable names too, here and elsewhere.
Why is this loop necessary? Don't you just need to click a single element? However, I could be wrong since I'm not 100% sure what is being checked.
Hey, So it was definitely intentional before that there was a version of this function which *didn't* try to append domain credentials. If you've audited and it's clear that we never used the domain-less version, fine to remove it, although I'd change the name of this function to something that makes it clear that it's doing double duty (IE: Creating the basic auth credential string *AND* mutating the username to attach domain data). I think in the context it's used, it wouldn't necessarily be unambiguous that the username you pass in here isn't the one that's going to come back out, and am worried it'll be a source of future errors.
I think this should throw an exception instead of logging it. Otherwise, it would only be visible in a log that something was silently ignored.
Feel free to ignore: Do we really want these this there?
please keep the body of an if on its own line
make the constructor package private instead of private to avoid going through a generated synthetic constructor.
Another access change API violation, same a little below. If not needed then lets not change it here :-)
Multi return is forbidden.
i'd add "perform"
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
Why put at i-1? Wouldn't it be more natural to use i?
Is ... depends from onTheFly parameter?
Cosmetic: You could extract Optional.of(artifact).map(a -> a.getHierarchyParent()).orElse(artifact) into a private method (i.e. private getArtifactHierarchyParent()?) and re-use it in removeArtifact to avoid possible future issues when this logic needs to be changed (i.e. forgetting to apply the same change in removeArtifact)
This 4 lines be made into one line.
I wonder if this does not already do the job done in the following for block ?
Same as above: .getAllOfTypes(new VDSType[] { null });
It is still public. Why?
Immediately return the value here
Might be worth having a displayName?
Adding this to a field is good manner.
consider implement IntermediateResultPartitionID#equals(...)
Perhaps we could look into making the deserializer more flexible with respect to encoding issues (just like it can be configured to accept unescaped tabs)? I have not checked if it is possible though.
this.m_
Any reason this became package private? This seems necessary to continue a paged response set.
do most of these need the try-finally blocks (instead of only closing afterwards)? if there's an exception in these tests, does it matter if the file is closed?
This seems like a good use of ordinal since it's lifetime is expected to match app session.
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
I think we should not care about this situation (neither here nor in Excel) - if the file does not exist then we are not running any risks of overwriting existing data. So we should probably also name the configured property like that - instead of "overwriteFile" it should be "overwriteFileIfExists".
Hey Xabi, can you use an atomic boolean to set whether or not the ad closed? This prevents a situation where onAdClosed() is called multiple times and forwarded to the publisher. Similar to what we did on rewarded: <LINK_0> Please do this for both the OB and non-OB interstitial adapters.
minor static import isWhitespace for readability
Just a detail : I would use internalMatch instead of isToBeSent. (and so change internalMatch to protected) This make me read again internalMatch and - I still have difficulty to understand the inhibitNewConnection - is it possible to have an availableContext == null ?
I think each of these two constructors should provide examples of the querystring's they construct.
Maybe wrap in an immutable map.
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
debug = Boolean.getBoolean("run.flaky.tests.debug"); does the same thing as what you have here.
this usage does not seem very fine
Guava has Objects.ToStringHelper() to make it nicer.
Let's just fix the OS by default. The default location should be configured by the jclouds *Implicit Location Supplier*. The default hardware is, by default, the smallest one.
Wouldn't Collections.emptyList() be better?
Isn't this missing an implementation?
"RuntimeException" I guess this is leftover of copy-pasting from other issue. Please correct here and below.
this should go to super.reset(), shouldn't it?
default method visibility OK?
what about setColor(int progressAndThumbColor, int backgroundColor) if they alway need to be set together?
Its more specific you to create a mock of the message and then if the managementNode gets a schedule call with that instance to return the number. any() should be used in the case when the parameter can be variable things or its not specific to the test case you are checking.
In order that the test runs successfully is a debugger required or is this some artifact of the test development?
Shouldn't we add the Transmit options field here?
please create a more specific exception that extends this one.
use {} pattern for LOG statements. for example LOG.info("Starting PYAPEX with {}", StringUtils.join(args,' '));
This piece of code really would be easier to read:  haxe ResultHolder typeResult = getType(null); ResultHolder resolved = resolver.resolve(typeResult.getType().toStringWithoutConstant());  The way my mind works, I read getType(null) to call a local function, and the following getType() I also presumed to be the local function -- which didn't make sense. It took at least a minute just to figure out what was going on in that line; basically that the return value of getType(null) was not the same type as 'this'.
Ok if already stopped? idempotent?
Why are we configuring drawer in this activity. This activity shouldn't have it.
Since earlier commits enhanced serialization to avoid losing multi-types this if can be removed.
Should we throw an error here?
should this be in some MathUtils class?
No need for super()
nit: can you put "File connector started" instead?
spaces on empty line
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify (assert) it, then update it to a different value, fetch again and verify the new value.
if you're gonna rebase this patch, please consider dropping those this. prefixes from getters.
Can you check the String is not empty instead of length?
<LINK_0>
How about simplifying this method back to IndexCoordinates.of(getIndexName())) and keeping the evaluation within getIndexName()?
IntelliJ IDEA tolds me to remove this unnecessary boxing.
A task without times is currently not allowed to recur, so RDATE, RRULE and EXDATE should also be set to null.
Maybe just throw unsupported since this isn't used.
This can be improved by checking backup count:  @Override public boolean shouldBackup() { return mapContainer.getTotalBackupCount() > 0; }
Inside finally?
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
Exception is never thrown
typo: of -> or
return (splitTime < fTime + fDuration ? new TimeEvent(fEntry, Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fTime)) : null);
Should the shadow not store this value and the one above in variables and provide setters for them, rather than just always returning false? The same goes for all values actually... Would be better to provide setters for them.
nit: add message.
I think I'd rather store the instance as a field than to have to loop through the projections with instanceof attempts? You can easily store the EntityInstance during populateWithEntityInstance.
return Long.compare(sizeInButes, other.sizeInBytes);
oldValue should never be null; otherwise the merge function wouldn't be called. So, just use a putIfAbsent?
nit: you could add .map(Math::toIntExact) instead :)
You can change the 28 case to a default case, and remove this.
I think most of the other new 'getter' methods can be removed in favor of package-private visibility on the field. Keeping the field access simple, rather than creating all these new methods, will help future code changes by minimizing the call stack one has to follow to understand what is going on. However, I think this one should stay, because it provides access to a non-final field, whereas most of the others are final already. It should be package-private, though, instead of protected, because they don't need access by subclasses.
Shouldn't this be based on package name ? , getPackageName()+".depicts.contentprovider"
Shouldn't this return a Page<T> instead of a List<T>?
No, not toString(). Please, study the SpEL
Looks like this toString() got generated before the tags field was added :P
nit: Can we keep FilterSupportStatus() private?
there is no other (more elegant) way of getting article name
Is this line necessary? The radio group should already be visible.
Return from method Details at object that you found , and in place check for not null
Missing white space between ) and {.
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
Maybe better to return null
Can you please remove the non-vm networks from networks? Maybe removeIf would be nice.
not null check would be nice here
!isEmpty ?
I think we could have a better abstraction here for the list of possible values for a variable. We could consider this improvement for the next iteration.
You can add @RunWith(MockitoJUnitRunner.class) to the class, and then you"ll be able to use @mock on the declaration instead of this initialization. But it is just a matter of style, so as you wish.
Would the code be cleaner with  DetailAST node = lambda; do { node = node.getLastChild(); } while (node.getLastChild() != null);  ?
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
suggestion
This cast here is useless, Math.log10 returns a double already.
public ByteBuffer reset(ByteBuffer input)?
This is not used.
You may also want a test case for a search value that is non-blank but invalid.
This adds the caps a second time.
Coding conventions: Let's have the @Override on its own line please
one small edit: we should be using try { ... } finally { super.finalize() } here
Would prefer to store the quark as a member of this class and keep a getQuark method.
Does it make sense to change this to getInstance(Context c) and merge this with createGlobalInstance?
Minor: Collections.emptyMap();
Ok, I see why you want to pass in null. But instead would be better to have a super constructor that takes just class, so if someone calls the other constructor with a null entity instance we can fail fast.
log.info message is too general. When you have multiple bundles this statement may confuse you when trying to troubleshoot OSGi related issues. Instead, your message should ideally be "All required capabilities for web socket service component is available"
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
I don't like this method. It looks like magic in the call site.
no static
That is not necessary anymore as your other PR got merged already.
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
I think it should return Array here.
I would suggest using ConverstionPatterns.MAP_REPEATED_NAME here as well.
That can't compile anymore.
to be consistent we should introduce constant for kmodule.xml
The factory methods can be package scoped like the class.
Please move this logic to the constructor so that we can keep request final.
why add?
check notNull?
Since we're now using bus events, do we need this anymore? (The whole idea was to send events to individual cards, and avoid having to rebuild the whole view hierarchy of the RecyclerView.)
typo
It is generally bad form in Java land to modify the fields of another class directly. You should do this via getters and setters. While this introduces boilerplate, it makes for more extensible code: maybe you want to synchronize your setters across threads, maybe you want to cache computations and invalidate them when a setter is called, etc. Most importantly, this is convention: readers of code will not expect for class field mutations to occur outside of that class, and not look for it when they are trying to understand the code.
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
This should invoke the other constructor so that taskData can be marked as final.
If storageManager gets a value in constructor, then we don't need to check null.
WTF is lala
BigtableFilter should probably have a com.google.cloud.bigtable.data.v2.models.Filters.Filter member variable. That would likely mean deprecating the current constructor that uses com.google.cloud.bigtable.data.v2.wrappers.Filters.Filter, and use a com.google.cloud.bigtable.data.v2.models.Filters.Filter in a new constructor. Also, please add a BigtableFilter.getFilter() which returns the models.Filters.Filter and use that getter here.
Not that it matters but it would be "sourceFile"
This method (getUser) is equivalent to this.getUser(this.server.getPlayerProfileCache().getProfileByUUID(uuid), true);
Remove timer.
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
Please keep this.cell near the related fields (previousFamily & cell count) below
Optional, but this null could be better. How about defining a SESSION_NOT_SET constant and use it here?
Detail: FROM capitalized.
I'm not hugely keen of the aesthetics on the syntax here but I presume that this is Java-8 syntax for applying the same filter? (I'm not asking for changes, just reassurances that this is "how it's normally done these days" as I've not seen that code pattern before)
Here as well, I think the two calls to this method can supply an element id.
can this be readSafely instead of readBuffer so that read uses readSafely
.endsWith("'sParty") has an implicit semantical meaning and therefore should be put into a dedicated method. I'd guess something like boolean isOwnPartiesChannel(String name) But just comparing the end of the name sounds really... odd?
Synchronization is needed otherwise there can be a race condition between getting the current count and updating the count (line 296 and line297) Also between this.assignmentFailures.clear(); and assignmentFailures.put(node, failCount);
Maybe this should be getOrDefault to avoid null returns.
Should we log the potential error?
I can remove and update. (from all the references.) These were just to let you know what was changed.
public void fireEvent(GwtEvent<?> event) seems a bit redundant now. Is there a web bindery replacement for HasHandlers?
Shouldn't the return type be int?
Please remove the protected keyword because this class will never be subclassed.
This method should be static and need not pass this as an argument to the constructor.
possible exception
@vilchik-elena shouldn't we test at least one case where we don't know the type of an operand?
nit: you may keep the chain pattern as append returns the builder object. Do not have a strong opinion on the current or the chained version.
You won't need negation if you turn the order:  return binding.widgetAnswerText.getText().equals(getContext().getString(R.string.no_date_selected)) ? null : new DateData(selectedDate.toDate());
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
use FileUtils.createNewFile() instead in order to check return value
you can make this a class member and then only load it once here and reuse it on execute
let's do it using lambda approach
use existing constant
Please change this line to: DbSession currentSession = HibernateSessionFactory.getSessionFactory().getCurrentSession();
This can lead to NPE, better to swap the check.
Can you share why we need to unsubscribe all here?
We should return true here to ensure the menu is displayed.
Second parameter of Status is the pluginId. Why to pass path here?
Camel can do this automatic in the setProperties(configuration, parameters) you do further below. If you want to set default values then set them on the configuration class instead
minor nitpick: Could we rename it to removeNullEntries() ?
similar issue here. remove validation in client
that seems a wrong junit exception usage. test shouldn't suppress exceptions, it need only configure exception (that is Rule).
It should be this class' responsibility to register listener to AmbryStorageQuotaService. Instead of returning Listener objects, this class should create the object and AmbryStorageQuotaService.registerListener(listener). This will make things simple, as the only responsibility of AmbryStorageQuotaService will be to called listener that are registered by consumers. Also the AmbryStorageQuotaEnforcer doesn't need to do anything if it doesn't want to listen.
if you use a second client instance and do this remote operation, the test can be easily duplicated by non-java clients as well.
Docs here to please. I understand what you're doing here but given that they are public static methods it looks like "api" stuff
You are using Toaster everywhere in this class except for this message. For the sake of consistency, use the same class here as well.
what happened to handling of nullables?
I think the most likely case is that fboName is not the default frame buffer. But it's a very minor issue, so let's leave it as it is.
keep primitive, it's not used in JSON and can't have null?
minor: I personally think that 'this' is redundant here.
Hm... Migration feed is where it probably does not make sense to have Archive URLs. Maybe we can make these methods no-op?
No tests to cover this method! :open_mouth:
You could maybe use enclosingClass to save a few hops...
If we are always dealing with character-based payloads (and maybe we aren't) then logging the decoded version of the payload in a toString() would probably be more useful than the raw byte array
what is this String MediaWiki:RelatedVideosGlobalList?
This is not a good convention. How about changing internalNext() to be able to return null to indicate there's no more elements?
One more empty catch(){}.
Please check if this method really should be public in a private static final class. The parent method is protected.
is this toConfigurer needed as a variable?
We should log this error by using our Log.e method.
Always use blocks! :-)
byteOutput.emit(tuple.getBytes()) ?
I don't quite understand why this call is needed. If LazyBlocks are not loaded, the data is not read, hence no stats to update.
Should be cached or initialized in a field.
This needs to return a completable future, not null
how can this be null? isn't there a check in the canDoAction to block this from being null?
Here should be NOT_INCLUDE_DEFAULTS
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
please decrease log level to trace or better remove statement
Typo: "su*m*.misc...."
Change collectionType to iterableType?
"This method is not actually very useful and will likely be deprecated in the future."
Extract this into an AppPage method waitForElementVisibility? It can overload the one that accepts a WebElement. Accepting a By is so much more useful, as the element doesn't have to be present yet for us to use it.
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
This one needs to have context so you will need to have a method that takes an Integer object and a Character object.
The variable feels weird. copied gives me the impression that something worked but then I see that you throw an error if copied == true. maybe use something else e.g. failedToCopy? or alternatively return the string and check whether its null?
Maybe we can compare the 2 images to check that this is the correct one?
It seems strange to deactivat errorCatch here ...
Instead of removing "bbbb" which is the longest element so won't have trailing spaces, try removing "a" or "c" as it's a better test.
I continue to think that **aifc** should to be here...
Can you add getId() and mark id() as deprecated?
Why do you wrap here unconditionally, why there is no isValueNode() as in other place?
include retry template and do  return retryTemplate.execute(x -> remoteTokenServices.readAccessToken(accessToken));
Let's include the giver and recipient here too
This could also be chained.
this log seems useless, remove it
With zero knowledge of the code, are you sure this object is not reused? Because if it is a scheduled task it be just reset rather than recreated, but you cannot reset the telescope client, you'll need a new one.
(purity alert) This two can be written inline
Instead of obtaining the Authentication, please use the SecurityContext so that the original SecurityContext is used (this ensures that if a custom SecurityContext was established it is used later on as well)
Why is this necessay? it is called every 20ms! Why is it not sufficient to set it on top once?
Can summarise to two lines: java WebElement sessionRow = waitForElementPresence(By.id("session" + getEvaluationRowId(courseId, evalName))); verifyElementContainsElement(sessionRow, By.className("session-resend-published-email-for-test"));
super.stop() should really be in a finally block.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
The result variable should named as result
why public?
possible NPE
child
Same argument as with the DeadlineJob.
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
Can we change this line to this(0) and remove the if (port == -1) in the other constructor?
squigglies ftw
It may causes two consecutive calls of onTracksChanged due to MediaPlayer L3008 in the same patch set.
OCD: missing space between ) and ?
you can't just fix all magic 2 :)
This test probably doesn't do what you think it does, because it verifies that EXT_ID matches with itself. (Same with several of the subsequent tests.)
This method should be synchronized, otherwise, chances are eventually there might be a race condition for setting fAttribute.
Make this java fail("expected exception");
java if (mapperReference.isUsed() ) { mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ) }
What is the need to make issueArticles nullable? It would be easier to understand this view class if we required it. If that's totally impractical, we should consider having a separate view class to capture the difference.
Why is the modifier private? We should set same modifiers to validateDatabaseName and validateTableNamet methods.
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
final
if not blank
are these setters used anywhere?
Can you elaborate when long type can be nullable?
This method could be static since it does not depend on any local state. Same for hasCoordinatorMoved.
access modifiers?
you can use method getUrlForWiki (so you don't need to add empty string for article path)
nit: we don't usually use final on method. (Also, as a side note: we don't use final for tmp variables)
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
why can't the schemes be hash from starters?
For loop?
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
iirc it's initialized in the ctor, check that it's not empty .
Same - icsCode >= 1
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
What is the deal with the type converter?
Could you move "community" to URLsContent and store it as a String constant?
This is problematic: If a user foo has access to pipelineA, but not pipelineB - (s)he can possibly craft this url for the pipeline history page and get access to pipelineB, because the impl seems to prefer using the query parameter, and ignore the path param.  GET /go/tab/pipeline/history/pipelineB?pipelineName=pipelineA
If these queries are covered by TestJoinUsing, then maybe we could remove them from here?
checkNotNull(value, "value")
return symbol != null ? symbol.qualifiedName() : "";
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
feedback session's course ID -> feedback question?
backspace (bracket should be one tab back)
==
null? why not just a () -> {} ?
Same as the other write methods, it's safer to create a new ArrayList that modify it.
It's not flexible enough. So when you will need to add another requestCode, you will need to add another else if, which isn't a good practice.
This method should be static as well. Also, comparisons of the form "0".equals(s) are preferred over s.equals("0") since if s is null the former won't throw a NPE while the latter will. I'm aware that the rest of this file doesn't follow this convention, but there's no reason not to fix it for new patches... :)
this.
Should be a constant.
please use org.ovirt.engine.core.common.utils.ToStringBuilder.toString()
An empty message is OK.
Can header name and value be null?
I would suggest to use the vector's getter methods to get the entryX and the entryY properties.
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
It doesn't feel right. Why it is required?
You should externalize the string
Restore visibility of this and other methods in this class when unit tests are moved to jaggr-core
Yeah.... this is functionally ok, but it's very wasteful. Just use traditional if (color != null) logic. It reads better.
this can be simplified to this.sparql = checkNotNull(sparql) and the others here too
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_0>
IMO this should move to the presenter in the first place.. i.e. where you call view.init( this ) add the next line that calls if(this.canUpdateProject()) { view.enableAddAssetButton( false ); }
Replace 1 with TokenTypes.EOF.
can infos be null? (the check in line 112 above implies it might be)
Looks good to me. Can we do something to identify other occurrences of this issue?
Isn't this test the same as saying "API.getDesignProcessDefinition() should call service.getDesignProcessDefinition()" ? In that case, it would only suppose you verify(service).getDesignProcessDefinition();
why static?
If I understand correctly, the purpose of the patch is to fix a specific problem - failure of migration because of 'refreshCaps' failure to take a lock. It is enough to take a waiting lock inside the ActivateDeactivateVmIntefaceCommand before calling the refresh, instead of locking the host for the whole migration period. You can pass 'lockProperties.withScope(Scope.Execution).withWait(true)' as the 'lockProperties' of the parameters you pass to 'RefreshHost' (the 'RefreshHost' should pass it the 'RefreshCaps').
Map.replace also runs a containsKey:  The default implementation is equivalent to, for this map: if (map.containsKey(key)) { return map.put(key, value); } else return null;  I think a simple put is enough: you want to make sure you have the given expiration in tokenExpirations
This is the only part in this PR that I'm concerned about. Rethink this change from <String, String> to <String, Object>. Talk to @pshivana. I'd use the @Load mechanism instead to provide a way to get this, or the GoApplicationAccessor. I know it changes per job, but only one job runs in the agent at a time. The issue I have with changing it to Object is that this is no longer serializable. If we want to move plugins out into a different process, we cannot. Ideally, this wrapper should not be an object at all (as we've spoken). It should be a message based API as well, that the plugin can use. But, I know why this is done (for convenience of the plugin developer) and I agree. But, I don't think this should be passed in through the request params.
Simply return the id. It's either a ticket id, or a JWT. Right?
wait.forElementClickable() should be used before
I don't think we use final for functions in our code base
> Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
do we need to use static on this private method? Please update javac doc
suggestion assertThat(got).contains("Description");
delete() should be executed from within the future so it doesn't through right away.
It isn't clear to me where this user is created?
This utility class (even though it is used in the interceptor context) should not throw an InterceptorException but some other exception.
Please simplify this just to nameModel.getObject() because it is a bit confusing at first sight.
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
As you already need to touch this file, I think this empty line could be removed.
please use org.ovirt.engine.core.common.utils.ToStringBuilder
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
inline permissions and then remove redundant this
Please add a check here that would simply return if the color being set is the same as the current foreground color (linkColor).
What if a student or unregistered user calls this endpoint?
And also here: refer to L55 of calcite/core/src/main/java/org/apache/calcite/rel/RelShuttleImpl.java. The accept method does not change anything on this instance; it returns a modified copy of child, which you then discarded.
Could change the return type on method to Collection
This variable looks final.
suggestion Assert.notNull(consumer, "consumer must not be null"):  Parameters that are not annotated as @Nullable must be checked.
This seems to be outdated.
again, use 'guid'
Please, reuse your extracted method for checking if a file is an Erlang source file.
this line was probably copied from somewhere else but I think the message could be improved, for eg Charge with charge_external_id={} was updated from <old status> to <new status>
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
Delete can be better handled with this. <LINK_0>
My bad, I meant to say: "to be able to **change** the page source". I will improve this exception message.
Nit : suggest having a local visibility int like you're doing in other places, or a ternary to inline, so you don't duplicate this code
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
You may want to add assert size - toRemove.size() >= 0; (my genIntellijRuns task enables assertions by default)
This drops all rs and collapses all ns to  .
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To save changes you need 'Push' rights on " + REF_CONFIG"."
Please do check on null for all such getters. I believe we previously returned null in such case, because object was a Date, now we return primitive long which isn't an object. We should probably return Long so its serialized either as null or long value.
Maybe 'cluster.hasRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
Keep this check?
nit: wondering if we should use the same IllegalArgumentException if property is missing as with getString. Seems like we always encode a default.. I am not terribly sure which is a better model, but this will keep it closer to existing behavior at the least.
why not just getResourceManagerRoot().toPath();
Null check for leaderElectorListener
Check error code/description
Instead of null can this pass in a simple Supplier of some simple ExecutorService? That's out of scope for this really but it will help clean up test noise.
Guess return type should be void
Can just use mapper.readValue(partFile, Part.class). Would encapsulate this in a helper (i.e. readPart(partFile))
you are calling stream.addLivePacketListener on the onStreamCreate but not removing it on onStremDestroy.
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
why do you want to whitelist it at the end?
please use for the positive tests the following convention: assertThat(validator.shouldVdsBeFenced(), isValid());
Looks like epoch and reset logic should be pushed to pool as generic solution. Isn't it ?
final
Nit: "Creating ephemeral nodes..."
lookupHost is probably not the right name. It has other connotations and it doesn't really say what it's doing. v4IntToInetAddress? intToInetAddress? What do you think?
Don't you think there's a need to add a constructor with final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier
Please use CommonUtils.loadResource(). It allows overriding config files by placing them into /etc/sw360
Make this package private and remove the redundant null check.
Those two methods are similar. Consider using one.
"return position;" maybe?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
make it final. You don't want classes extending it to override this, as it's driving the analysis.
What about to use constants for the key strings?
This should stay final
Is this parameters really mandatory? I thought its default was false.
IntStream.ofRange(beginInclusive, endExclusive) .mapToObj(ImmutableList::of) .collecto(toImmutableList());
This is redundant, please remove.
This test is wrong, check that the expected exception gets thrown using the expected attribute of the @Test annotation
I'm thinking the constructor should be public as well so that applications can use it in their own authentication providers.
Think we should also look at remaining() - it can be efficient to use slice, in which case the buffer doesn't go to the end of the array.
Can we roll this into the parseJobId method and maybe rename that to reflect its purpose of creating a manager from config along with the attribute that its keyed on? E.g. getManagerFor... or getManagerFrom...
All attributes s values were -> All attributes values were
&& isFile() afair more exact check
I think you've set fStateValue to nullValue in the constructor in this case, so this is pretty much dead code
This should use a different match strategy.
Instead of two fields Double, you should use double with value Double.NaN when field is supposed to be null.
Should be : sizeInGiB
Is it possible, that the context is null?
shall we add some message here?
Do you think this is non-useful? I figured there would be cases where people would want to test code that behaves differently if the SDK claims to be something really old that we'll never fully emulate.
can it be made in one line?
set twice
Assert.notNull() - just for fail fast, since we really don't support null for this property.
Consider using == maybe?
Please remove usage of .class, for the same reason as above.
Is it really filter name?
it cannot be a constant: it needs to be a variable (like timeout) so that it can be changed per test / per class and eventually adapted for EE
@fanifieiev the same above.
It might still be nice to not add any network overhead to a request, even if it's time to fetch a new limit. Could we just have a background scheduled executor that fetches new limits, then updates the rate limiter when there's a change?
Is this intentional? You are forcing the value to 'true' Maybe a simple assignment is clearer
I think this can be set by spring application.properties without creating bean explictly.
should this count be parameterized?
I think this can be a bit simplified: return getVm().getDiskMap() .values() .stream() .map(disk -> (DiskImage)disk) .anyMatch(vmDisk -> vmDisk.getDiskStorageType() == DiskStorageType.IMAGE && storageDomainStaticDao.get(vmDisk.getStorageIds().get(0)).isBackup());
This is a stream range query (scans the bitsets on the sequencer), we should re-add that metric. Actually, there's a bug right now related to bitset queries #2747
Logging.
Can be static.
Should use ToStringBuilder.
shall we rename this as brokerUrl ?
You could put these checks in a constructor so you don't have to repeat in these factory methods.
I'd simply call the property changed event "SearchEnabled".
scaledData, thread safety and all
I can't remember our usage paradigm here, but I believe if the value is not null, we should use an assertion that the value is indeed a Map. Otherwise the caller of this method is probably trying to do something wrong (i.e. expecting a map when the property is not a map), which would be a bug and should be fixed.
you aren't calling super class. add super(params)
perhaps you need to trim first ?
but this should probably use that mechanism, too?
Just putting it out there early in this review that I'm not too big of a fan of LongRunningOperationStatus - it's very long.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
rename tempVar
Make this method synchronized.
Extra trailing comma.
Should use the location.
Why don't you use String.format?
Instead of changing the method that is getting called, the missing one in search query can be added here and it seems the updateDomain method in managementserviceimpl is not in use. It can be removed
Don't check these in.
This method looks horrible to me (and to whoever is a sane engineer, I should think).
If position() gives anything other than 0 then this will give a LimitReachedException won't it? Did you not mean capacity - position?
Are there any const that can be used instead of duplicating strings like this?
consider saving the value of group 1 and group 2 here rather than the whole matcher
Can we adhere to the coding style of this file and not have multiple return statements?
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Should be "InstaPost" actually.
let's make a meaningful constant for 5
to avoid some synchronization here, try something like this:  private Semaphore getSemaphore() { if (sem == null) { synchronized(this) { if (sem == null) { sem = new Semaphore(maxThreadPermits); } } return sem; }
return array == null || array.length == 0
what if my value is " " ? should use trim
Why 2? default-max-chars.csv has a single line so it should have a single set of arguments?
"The request cannot be processed due to the following issues"
code format
Do you want to check exists?
Assert.notNull() ?
this does not handle the empty 'lists', it will throw an exception
If this method is called with timeout = 5 seconds, and then getWaitTimeForPermit() returns 30 seconds, I think this implementation will incorrectly sleep for 30 seconds rather than 5 seconds.
Sorry! I meant we don't need to pass the options in!
Not related to the changes from this PR, but now that the ValidatorFactoryImpl is cleaner, I noticed that there are some getter methods that are not coming from any interfaces. Like for example isFailFast(), isTraversableResolverResultCacheEnabled(), getExecutableParameterNameProvider() and maybe others. Hence I wonder if we shouldn't pull then to HibernateValidatorFactory ?
move inside of for loop.
Could change the return type on method to Collection
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
hmm, do you test the rest service for update? What about if you try to update a given provider (without to change the name)?
why public? Are we planning to use it outside of this class?
I don't think we should ever update the property map for bindings nor should we update the binding instance. What can we do instead is to return a copy that is populated with the default value (i.e. the value that is supposed to override the unset value).
I think this method could be private.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
@Override
This should return KeyValueFilterConverter<K, V, C>
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
EmptyConfig.INSTANCE?
Multiple method(*) methods
intentional to remove the shutdownClientOnClose?
Very helpful
@tmarzeion you should start PatientDashbordActivity here with the created patient :)
Just use bytebuf.writeZero(size); ?
Change to ...sqlDatabase is not properly...
getNodeEnd() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails.
I'm not sure this is used for anything, I need to verify.
Lets change the default to GRACEFULLY
The super() returns "" on null. Why should we differ?
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
this test failed for me during a parallel run. This parallelizable test should have a path which we know is there but is private to this test; we can have another one which invokes on a missing path. The full root scan should be run in the ITestS3GuardDDBRootOperations test, before any cleanup
Please externalize these strings.
No need to use ConcurrentMap.
I would add a check if instance is != null, because with this, everyone can overwrite the current instance if its not null. Or only create a new instance in the getInstance methode, if instance == null
You should be able to use the diamond operator here, i.e. new ArrayList<>()
please create a more specific exception that extends this one.
![MAJOR](<LINK_1> Rename this method name to match the regular expression '^[a-z][a-zA-Z0-9]*$'. [![rule](<LINK_2>](<LINK_0>
There is a double ? sign here
Let's make sure error messages are consistent.
Please, add { and } to the if statement. if (dialog.open() == Window.OK) { ICommand cmd = wizard.getCommand(); //command execution ? } Modifiy the inheritance of the action and add the command execution
you need to put: fail("this should throw") in this try block -- if this never throws the test will still pass
The property name does not match the one in SystemEnvironment, may be you could use SystemEnvironment.GO_WEBSOCKET_MAX_MESSAGE_SIZE.propertyName()
return ImmutableSet.of();
If you use a concurrent map you can use: attestationValues.putIfAbsent(value.getHostName(), value);
default method visibility OK?
Consider to replace with "an allowed command".
Scm api has rules on the placement of annotations for methods
already passed in
this is a query metric I think the metric should be "query/jetty/numOpenConnections"
but now you don't really need "new" - these classes are stateless, no risk of two (or more threads changing a state of a single instance, so u can definitely hold a single instance of a mapper. You should be aware to the fact that "new" is an expensive operation.
return asyncHttpClientMap.remove(name) != null
You want to use FormField.getFirstValue() here and everywhere below.
@fchauveau there is no null handling of source, is this intended ?
columnIndex < getPrimaryKey() -> columnIndex <= getPrimaryKey()? If the column is the primary key, the cached index should be cleared.
I see you"ve moved 'reportsWebappDeployed' but what about 'retryCount > MAX_RETRY_COUNTS'?
this should go to login I think... 1. redirect to external 2. apache takes over 3. user press escape 4. we reach here 5. we should present login and not redirect to 1 and loop
Guice best practices: make this constructor visible only at package level.
The streams created are T1 and T3, but the ones added here are T1 and T2. Something is not right?
Update the toString to include ledgerIdAssigned?
- Integer.BYTES -> SIZE_OF_INT for consistency with getSerializedBuffersSizeInBytes - Any particular reason to not use SizeOf.sizeOfIntArray(positionCount) ?
built
I think we need file with version 1.4. inside.
Please change it to a normal null check and throw a IllegalArgumentException. This is more meaningful than throwing an NPE here.
Can't this NPE as they're Booleans (i.e. objects not primitives)
Update this method to also return true if status is HALF_OPEN?
This pattern can be created only one time at constructor level
Why not rather package private visibility? Protected visibility seems to recommend subclassing of DeploymentsOperations. Was it your intention? Why?
should check results here, not just size
We could shorten to one line return Optional.of(new Context());
just return "" instead of new String()
replacing this with helper method would be great
Again, use IOUtils.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I get a NPE here, processModel.tradeManager is null.
same as above, we should add throws IOException here and use ThrowingSupplier where this method used
We should only be pulling down upstream changes here.
I think Michael meant adding something like: "...using 'migrate' and 'stopmigration' actions..." (Michael said: "I'd mention the actual action used for that")
don't wrap at .
@inverno Why public?
-> assertThat(file.length(), greaterThan(0L))
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
Just some concern for security: should we output user/pass here?
Should use the log, maybe a warning.
isMatrix()? Also what about the row vector case? I've ran in to bugs in the past with subiRowVector being applied to row vector. May want to make this explicit.
it should be cleanup, no ?
MAXIMUM_CAPACITY is no longer used
Should be size != -1 since -1 is an explicit value. If someone passes a negative value then the behavior is undefined (which is fine).
this method should call projectDao.setReferenceGenomeDao as well
Maybe add regexp check about isNullOrEmpty() too
Can't this be further improved to just Arrays.asList(values)?
catch Throwable? When methods shouldn't throw, like where shouldThrow is false here, it's easy to end up with a hang because an exception type changed.
If we change the default value of getValueAsString we should change this one too.
we might just follow the pattern how ArrayList works. throw ArrayIndexOutOfBoundsException when requesting an entry is out of the range.
Preconditions.checkArgument() would be better form.
it'd be nice if we could use polymorphic deserialization, but i thinkthat is a bigger change
You can use StringUtils from the commons.lang3?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Why an array? List<String> is just as fine
this could be Lists.newArrayList(deviceId);
This shouldn't be changed, instead you need to change getAllCount() to return VisitService.getAllVisits().size()
Also modify varchar?
You should use ThreadContext.putAll() here.
I think try with resources should be used.
nit: this should be "f"
No need to catch the exception here, it was already done in the overload.
Could null be used instead of a custom exception?
can you wrap this with if (log.isTraceEnable)
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
could this be 8? the size of a char?
Consider using i18n for this title.
Constantes? Suggestion: EVENT_ID ou AN_EVENT_ID
TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every wrap?
Minor: For consistency: LOG.warn("Failed to read offset file in storage partition directory: {}", offsetFileName, storepath, e)
How about narrowing it to ClassNotFoundException and fail with other exceptions?
Fix aliases = aliases = ...
Is this test about setting the redirect attribute or replacing _HASHTAG_ with # ?
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
What if this path actually exists on the user's workstation?
Take care! arg.get().toString(). Otherwise you're passing the Optional object.
Use waitResponse()
this method deserves a description
could we solve this better by overriding send() in the TracingActor? I'd like if all this trace and replay code would be in that class.
nit: you can merge both lines above as checkNotNull will return the given argument
By default, it's enable, I didn't see you set it false. So, you can remove it.
Hehe, this is exactly the pitfall I pointed out :D If currentTimeMillis + timeout is actuall greater than Long.MAX_VALUE, you will get a overflow and the sum will become negative. Instead you should probably test, if Long.MAX_VALUE - currentTimeMillis() < timeout and if so, throw an error.
This will break existing installations. Revert the name.
why not letting return null and check if the url is null on this method client? Will clean the code a bit
Use a list to access at index
len is unnecessary variable name
Doesn't a constant for the "system" exist?
The @Override should be on this line.
you can simplify it with a single line by replacing the method's body with: return validate(hostExists()) && validate(hostStatusValid());
@since 9.3 originSystemProps.put(key, System.setProperty(key, newValue));
There are different ServiceId objects with the same serviceId field? e.g. that contain different aliases?
Why the + "\n*"?
I think it's more neater to not write extra lifespan/maxIdle parameters, but instead to write them where you write lifespan/maxIdle already and just add the possibility to send a new option which defines the granularity of lifespan/maxIdle. Your current solution feels akward since you're adding two new fields and the existing ones are not used. IOW, just add one more flag to the flags parameter here and you're done on the client :)
Extract result variable.
Can this return a List<JsonPatchOperation> instead?
@aschworer HEADER is used only here, you can inline it and remove static field
For Symbol and DataType we've static methods to handle the ordinal handling.  public static void toStream(DataType type, StreamOutput out) throws IOException { out.writeVInt(type.id()); type.writeTo(out); }  Do you think it would make sense to follow that pattern here too?
this class doesn't have tests?
I think you should use MISSING_ATTRIBUTE
This is not necessary.
we can do away with the local variable here @rishabh-997
I still think you should throw an exception if name is null
What about creating:  private static final Future<RecordMetadata> COMPLETED = CompletableFuture.completedFuture(null);  and then returning that instance in all of these places. Since it's already completed, immutable, and we don't allow cancellation, it should be fine to reuse in this LogReporter.
please use parameterized logging here :)
I think the granularity should be 1 seconds instead of 5 seconds here.
this is being called on a different flow now. is this intentional?
correct the type. it's not service
static
Not sure this is desired behavior if date time cannot be parsed
Making use of Guava lib this can be simplified to suggestion Preconditions.checkNotNull(module, "ModuleMarkupScraper:getModuleTags() - Module must be valid.");  As the module name will appear in the stack trace if the null check fails, it may be enough to just do suggestion Preconditions.checkNotNull(module);
do we want eventually to have a writeTo(ByteBuffer) ?
@AlexDBlack is this normal for transforms? Have we changed anything in the data vec transforms you can think of?
this is nullable
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
instead of just putting e.getMessage() as part of the new exception message, I think you should pass the entire e as the second parameter to the constructor of IllegalArgumentException.
This is a clear programming error, right? If so, suggest throwing NPE instead.
This is not correct for the same reason as i said above.
nit: simpler way: use noneMatch instead of ! + anyMatch. btw, it's better we can also update the matches method of PushFilterIntoTableSourceScanRule
is everything in this block (inside this if) not the same as the superclass' behavior? If so please replace with super. getSuiteFilter(klass)
It is shadow copy technically, but all fields are immutable (so there won't be any issue to directly use these fields).
I am sure you can replace this with Lambda.
Missing call to super implementation of onResumeFragments()
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
Please throw exception if ! nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN, please throw UnsupportedOperationException. If ! nameLookupPossibleInAdvance(), but getValueCardinality() returns something non-negative, the code in the hot loop could be optimized, idForNull could be assigned as soon as selector.lookupName(index) returns null for the first time.
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
I missed this the first time, but no raw English strings in the code. Do + StatCollector.translateToLocal("pe.arcana.inactive"); and then put pe.arcana.inactive=Inactive! in the en_US.lang. So it lets the string be translated to other languages
style-nit; no braces for simple single-statement constrcuts
Rebase error - should be used Helper.getCurrentUser.
I think this should be: java setCursor(Cursor.getPredefinedCursor(DEFAULT_CURSOR));
last argument needs to be ImmutableSpongeFlyingData.class.
I would suggest answer.toLowerCase() to make secret answer validation case insensitive.
We should include the topology name in the message as well: Topology foo already exists.
Take a look at <LINK_0>
This and similar blocks could use the NULL_LITERAL constant
How about adding an UncloseableAggregatedMemoryContext that throws if someone calls close
new ArrayList<>(causes);
Why change here? You mentioned partial models in test as a reason, but this is not a test case. This file could have a different encoding set by the user. Recommend:  settings.getModelEncoding() != null ? settings.getModelEncoding() : StandardCarsets_UTF_8.name();
once again, equals/hashcode - does it make sense? please revisit in all value types you created
ImmutableList.of
Should this be called id instead of store_id? Its a param and it shouldn't matter what it's called I suppose, but, id is the key we use in the response.
You can inline this variable.
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
is it better to use name instead of null?
getHeaderData and getItem data need to check for anything. They just need to return whatever value is set in the constructor. All methods can be final as well.
Is it safe to set limit for buffer here? I'm not sure. Suggest to get a read-only buffer.
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
if this is hit often, the String concatenation may slow things as opposed to using a StringBuilder. Also, would it be better to not append/concatenate the empty string "" if the treeId is null? Maybe do it like this: java StringBuilder sb = new StringBuilder(indexId.toString()).append("."); if (treeId != null) { sb.append(treeId.toString()); } return sb.toString().getBytes(Charsets.UTF_8);
Nit: use ImmutableMap.Builder, it's easier to read and modify, as there is no special case for the last item. I only use of() if there is one item. Same goes for the rest of this class (except the usages with exactly one item).
new ArrayList<>(causes);
could you please create another constructor accepting nameResolverProvider?
Please add ? and % as well
Could you please use TextUtils#isBlank here instead of "".equals(s)?
Something wrong is here: ![wrong_object_to_remove](<LINK_0> this.inUseConsumerChannels.remove(consumer.getChannel()); ?
When replacing a single char it is better to use public String replace(char oldChar, char newChar)
I don't think we use final for functions in our code base
this will throw timeout if infobox is not visible. use wait.forElementPresent() instead, but you will have to create By variable from that selector
Copy could potentially get very expensive. We normally just trust the modders not to screw things up.
I think we should set isBound = false here. onServiceDisconnected is not called when the client is unbound normally. According to the docs, onServiceDisconnected is only called when the process hosting the service is killed/crashed.
Could you please clarify the reason of this change?
You can remove your factory class and use: return singletonMap("surrogate_merger", (isettings, env, name, settings) -> new TokenFilterFactory() { @Override public String name() { return name; } @Override public TokenStream create(TokenStream tokenStream) { return new SurrogateMergerFilter(tokenStream); } });
You can create a constant to include the "http://" string and named as **HTTP_SCHEME** for instance.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
style nit: we don't use braces around single line blocks
Isn't there a better way to identify if an access right is inherited than checking is a UI widget is an instance of Hyperlink?
We want to always return '201' status Status.CREATED, but Response.ok() will set the status to Status.OK. You probably need to set the status by hand calling the status(Status.CREATED).location(.....) Would suggest to also enhance your tests below to also verify the status returned.
assertThat(gosecSsoUtils.userName).equals("anyUser");
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
I'm a bit perplexed: "dynamicStrict" does not match any field name... I wonder why this works. Anyway... Maybe there should be two different bridges here? It feels a bit strange that the name parameter in configureFieldMetadata is ignored. Same as before: I agree it can work as is, but it's more in case someone copy/pastes this code.
save an iterator by using index loop?
Exception Message like logs shouldn't be internationalize just use // NLS....
You don't really check much with this test. I think you can also mock cursorsCommitService. getSubscriptionCursors() and check that in response body you get what you expected.
Perhaps change %s to '%s' or so to make nasty leading or trailing spaces more obvious?
new fields should be added here, right?
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
Replace URL_TICKER with URL
I would suggest to add the overloaded method with accepts Bus bus, there are many places where it could be provided from context. What do you think?
use rewrite than getVisitor
Please fix this codacy issue
Doesn't contain questionGuid.
Would be nice to create an integer constant and assign 400 to it, and than use it here. E.g. public static int WINDOW_HEIGHT = 400. It'd be more explicit for another person (no magic numbers).
Could you explain why you don't use just true ?
Read, not readed
does this method need to be public?
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
I think this could be package-private: suggestion void enableOkButton() {
is it sufficient to have this c'tor package private?
defensive copy?
variable named abstractFile does not exist, which prevents pr from building
mark this method private as this is only used in this class.
Better use Double.isNaN(double) here. Reads better, IMHO.
It should be new TajoRuntimeException(new InvalidCastException(...).
fieldName
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
Use Assert.assertEquals
return new StringBuilder().append()....toString();
antipattern: using getBytes without character encoding
These will all break if A or B is null. Recommend using the autogenerated intellij equals + hashcode unless you have a good reason not to
This is another behavioral change that I don't want to see in an unrelated PR.
add this selector to UI mapping at the beginning
this method could be static i guess? more relevant: is this method necessary? i only see one usage
path.endsWith('/')
Just do sw.toString().
I guess you mean to pass kryo, not to create another Kryo.
why are we casting to "int" ? it the value is a "long" we must return a "long" or we have to handle the overflow some way
Should probably have a specific error code defined in ActiveMQClientLogger and use that.
Please kill this empty line.
getServicePolicy shouldn't ever return null. Based on how the Python SDK functions we return a policy object every time. In the case that it is in fact empty ({"factors": [], "minimum_requirements": []}), we return a policy with all the minimum_factors set to false or 0.
Swapping these around breaks all other GUI's.
How to do ensure that by requesting .getConceptNameTagByName(null) for should return null if No concept nameTag is found?
Could return result of getCurrentJson to avoid repeating this line (same for descendRepeatToJson)
Again, probably out of scope for this PR, but I don't think these andReturn() statements are needed.
I would move this to a constant so we can access it from tests as well.
double wait
I want to method accessor to be package private :eyes:
I think you can swap the order of the conjuncts because name.equals(other.name) is less expensive.
This 16 is unrelated to cube size. This is vanilla chunk height. Populator pregenerate those cubes to let default world generators do a job.
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
I think we should reuse this File object, returning it, for example, and then pass it to the copy medhod, instead of the string.
What's the reasoning for returning a LocalVariable[] instead of a Map<String, Object> directly here?
Same question about unit conversion as earlier.
I don't think you want this default. This default setting basically says "If debug mode is enabled (IE: You're on a dev machine), the default for the superuser flag is 'on'". You probably want it to just default to "no"
Why do we have different checks in these two tag methods ?
The parameter can bee removed
again, CoreUtilities.noDebugContext
I think this should be ss.findAllRepositories(streamName)
style nit: we don't use braces around single line blocks
store these as member during init? although not that important, it is good as is.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
here we need to go through Optional.ofNullable(Plaform.getProduct())
Unnecessary parens around the return value.
Should throw at construction time instead.
Can you explain a bit more why this piece of code? It looks like we're doing twice the .setValue() call. I guess that it has to do with the issue #1695 that you say it's solved here? If that were the case, please remove this piece of code from this PR and create a separate PR for #1695, but anyway...please answer my question. Thanks!
concat empty str ?
given/ execute/ assert
You can use sketches.computeIfAbsent().
Thanks for changing this to a switch! When I originally added the Lite and Premium versions of the app, I had to implement this as an if statement because the R.id constants were not declared as final.
return SUPPORTED_INPUT_FORMATS.contains(inputFormat);
you do not need to cast: just add a type like that:  Setting.NODE_CONFIG_DIR.<RawPath>getDefaultValue().toPath()
The exception also needs to be modified a bit.
Use same order as the field declarations.
Calling getPostListAdapter() will create the adapter if it doesn't already exist, so instead we should use mPostsListAdapter != null here.
No need to catch the exception here, it was already done in the overload.
unnecessary change
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
Same question as above.
If we log the entire asyncQuery object, we won't need all of these separate, sprinkled log messages.
instanceof check is enough, no need for null checks in this case
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
"set up" as a verb is two words, so should really this should be setUpFilters
Duplicate code we have method in utils that gets name from SecurityContextHolder.
Isn't it easier to reuse AsyncIterablePublisher with a Collections.emptyList?
Check if an entry with the given key (name) already exists and throw in that case an exception.
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
antipattern: using getBytes without character encoding
Maybe we're going at this the wrong way, and trying too hard. If you call ProjectJoinTransposeRule on a MergeJoin (which requires sorted input), and the Project does not, after being pushed down, give sorted output, then maybe the rule should just abort. Just a thought.
Use Paths.get or non os specific separator
You should pass here message not group converted to string.
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Any worry about case sensitivity wrt to scopes?
nit: still Sever here :)
These lines look the same as in discoverZone(). Could you extract it to a method String podName()?
this is a public method so better perform some null checks, or at least use assert statements
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
from the client point of view won't this just be getPaddingLeft() (and ..Right())? or is this the padding that's applied to each individual tab?
I might have been confused, but shouldn't we have a new handleNewSession method that takes a session Id as parameter?
I'm not sure that will work on import storage domain. The process of import is being done through one host first so calling HSMGetStorageDomainInfo should be done through this Host.
Might be worth having a displayName?
Still worth using Map<String, Object> commandParameters = Collections.singletonMap(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
consider being paranoid and prefix with "line.length() > 0"?
updateAvialability() calls -> updateAvailability(SystemTreeItemType.System, null); Since the reports init is no longer blocking the ui there is no guarantee the system tree selected item is the 'System'. Calling updateAvialability() will update all the tabs (not just the reports) as if the system is selected. In my opinion, you should extract a method in CommonModel to update just the reports availability and call in from here.
nice catch, I just recently wondered about our handling of singleTop
omit?
nit: can be chained onto previous line's assertion
suggestion return stage.thenCompose(ignore -> awaitQuiescence());
You can use ValidationUtils.nonNull for this.
Can you maybe extract the following three lines to a separate method? Maybe private void createTableWithData(tableDefinition, tableName)?
remove exists variable and just return !tuples.isEmpty();
Maybe assert that #put() returns null
can we use messageFormat instead of string-concatination? String result = MessageFormat.format( "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.", planet, new Date(), event);
There is no need to make this injector public.
I would suggest putting a more sensible name for the channel name like "Review reminder", the name will show up in settings for people to toggle.
let's not modify this. looks like the classes that use this method implement buffered writing
This is the only place that add entry to the pool, is it the only way to fill the pool?
you're testing binary branching, i.e. an if. A switch is meant for more branches. java's switch can be linear or can sometimes binary search or a lookup table. Javaslang's is always linear. Please test them properly.
Are these returns used anywhere? If not, might as well make the method void. Applies throughout.
Instead of "Not implemented yet", I would suggest "Iterator is read-only"
@exper0 full path HmRsHeader.VALUES_STR
How about move the check of null into setBookmark method and invoke the method from here? So that all the places where we want to set bookmark will just call a single setBookmark method.
Incorrect error message.
The indents are still incorrect.
please make list of strings that will contain internal modules, please place this module in that new list
suggestion return cachedBody.next().map(ByteBuffer::array);
We'd use { and } here or just fold the conditional into a single return statement.
add this (also below)
This remove will not occur if the group or store removal fails and the scheduled future is already "spent". We need to reschedule in that event. Same delay?
Just style, but I like wrapping conditionals in () for this statement. In my view it improves readability in the ternary operator that is already somewhat tricky.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
We should mark this as private.
Can't this be further improved to just Arrays.asList(values)?
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
the static modifier could go away
Just a heads up - I tried using this in the server and found some dependency problems. You will need to create an integration test, with some suitable source span data, to try this mechanism out running in the server, just to be sure.
Every time we change a JSON test using JSONPath a cute kitten is born.
Lines 1068-1088 are redundant.
if we don't compare value - there is no point in keeping it AtomicReference. Volatile can ensure new config will be propagated to all threads.
We could omit the second Integer.
InputStream.close() doesn't contain any implementation so you can drop that call (but it doesn't matter). But I am pretty sure that the base class close will not get an implementation some time because it would break all previously working subclasses.
I think it can be logged with WARN as this is situation that we create ourselves and we are aware of it, so it's not really an error.
Perhaps I'm being daft, is this condition backwards? Why set 'played' to false when position is greater than 0? Should it be setting 'new' to false?
Please fix indents and use assertNotNull
Should make a differentiation of the name and id.
can we leave this package private? This will make future refactorings easier, because we don't need to care about changing public interfaces ;-)
We should handle the case where getDAnalysis() returns null
I don't really like using null as a sentinel if we can avoid it (since it's nice to be able to use empty objects to avoid crashes around null references). And I don't think the server makes any guarantees about whether children is nil or just the empty list.
How about "Type is not supported"?
is something missing here?
equals() is not usefull for enum, == is sufficient.
Just putting it out there early in this review that I'm not too big of a fan of LongRunningOperationStatus - it's very long.
This should happen within the future
assertTrue instead
Usually (especially for loop conditions) I like this style but in this case this is a mask, so if we ever go up to the top bit this becomes broken unexpectedly. Let's use == instead.
Why is this returning null?
Maybe a check here that getLeft() and getRight() have identical schema?
Operation can have InputStreams attached. There's a way to translate that to HTTP, we should figure it out. Or at least throw an exception if there are attachments.
elapsedNanos.
extract actual.getModifiers() to a local variable.
ParameterNameProvider=ClockProvider Or, better yet, let's just move to getUnableToInstantiateException(), I don't think there's much value in having the dedicated versions really.
Why is this removed?
Should this fire regardless of if the prior delete succeeds?
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
Even if we have currently only a 2 state discrimination here I would maybe use an enum (like SitePickerMode). Wdyt?
looks the variable originalStream is not used.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
You'd probably dispose your stuff, and call super.dispose() at the end.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
How about putting the condition in the 3rd param to avoid duplication?
copying and rebuilding the list everytime an element is added to the chain? Maybe chains are not long to see the adverse impact of this now. But when long chains are build this could be seen as inefficient. Something to think about in future refactorings.
Why not use name as the key in CACHED_ENCRYPTION_KEYS?
There no whitespace around <=. Also - good to enclose blocks of that that if/else in {}.
It can be like: java if (o instanceof AdHocActivationCondition) { AdHocActivationCondition that = (AdHocActivationCondition) o; return Objects.equals(value, that.value); } return false;  instanceof operator check null value as well.
Should use .equals() to compare contexts. However you could be dealing with null, so you should check that first.
why not compile once in field?
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
remove when the export button is implemented
can this be just (time - this.lastModifiedChecked.get()) > this.refreshDelay) should always be > 0
You can combine these 2 lines into 1
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
Minor: Or code conventions typically favor this style:  try { ... } catch (Throwable t) { ... }
This probably will be replaced by <LINK_0> ?
fyi: if we counting everything, fs.getContentSummary(path) would be the most efficient.
requireNonNull(defaultValue, "defaultValue is null")
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Include the bit in the toString(), e.g. maybe 1<<getPosition()
This can be simplified to Optional.ofNullable(id).
maybe add a null check that it's not already detached?
What is this for? Feels like some unintended checked in code?
As a nit, should have a null guard here.
please decrease severity to "debug"
Please use lambdas where possible.
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
if getExternalNetwork() returns null, you'll end up with NPE.
Please remove this extra line
Use Optional.fromNullable(marker) instead?
a table without db is not invalid? is it only needed temporarilt - until this whole thing is done?
!(parent instanceof MGenericStack) || parent.getSelectedElement() == part
maybe get enclosing element before the loop ? or this operation is not very expensive ? Something like:  TypeElement methodEnclosingType = getEnclosingTypeElement( currentMethod ); for (...){ .... if ( elementUtils.overrides( currentMethod, (ExecutableElement) element, methodEnclosingType ) ) {
any reason to accept null? consider checkNotNull(initialAttributes,"message")
Use UTF-8 Charset here and the getBytes(Charset) implementation (it doesn't throw an exception). This use depends on the default system encoder and if it were to change it'll be trouble.
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
As a nit, should have a null guard here.
Should be immutable by making a copy.
You can use StringUtils from the commons.lang3?
should this say throws PatternSyntaxException ?
I'm iffy on having this here. This is partially because we let the status update handler write to pending tasks, and partially because it means we are reusing a pending task id. Generally we let the SingularityScheduler do all of the work of creating a pending task to keep responsibility for those types of operations separate. We actually removed bits from the status update handler a little while back so that it would avoid mutating the pending task queue. Instead I'd suggest using requestManager to add to the pending request queue. This will let the scheduler do it's normal thing and rebuild a full new pending task with new unique ID from that pending request
It might look better to start the new line from the .show() instead of breaking in the middle of the arguments. Also note that you aren't breaking the lines in other places.
Don't we need to do the caching here?
Should this not be nested-projects?
Maybe, but I like simple and dumb unit test, this test checks that the service is started and well initialized, we don't need to test that on all tests. I don't see cases where a Before something is useful to understand failure in this case.
Redundant else blocks.
Objects.requireNonNull
evaluatedAnnotationValue or evaluatedValue?
missing @Override declaration.
There's probably some edge cases where this isn't true. Consider the case where there's 1 discrete parameter to optimize, with possible values {A,B,C}. In this case, there's only 3 candidates - and the candidate generator should terminate once all 3 have been generated.
Be aware of close() issue, ie: input.close(), output.close(). I cannot remember if we need to do that. Please check the IOUtils.copy() to do so.
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
Same code as in the method above, factor it out?
& let's not forget about this.
The job of a dispose method is either to free unmanaged resources / memory and to deregister stuff properly so that the object can be garbage collected. Of course you can set all references to null / clear datastructures etc. to help the garbage collector but this is just boiler plate code with little benefits.
Throw an unsupported operation exception here.
Collections.unmodifableList()?
This is already done for you by the super class you extended
Either of the events should be raised I think.
defensive copy?
computeIfAbsent would reduce possible multiple queries to the Kubernetes master, <LINK_0>
size is calculated here. Do you want to change sizeCached to true?
What if fileName doesn't have any .?
seems like message is invalid (really draft-03/04 in this use-case?)
Use a list to access at index
returning null cause null pointer exceptions
Better to rename RoutingTable.removeWriter to RoutingTable.forgetWriter?
probably unrelated here, but if the class gets getParamaters() all at once, it seems unrequired to feed it with each getParamaters().getter as well.
extract
I wonder is there a reason this is specifically a BlockingQueue? We don't block waiting for elements to be added, we instead use the semaphore and we don't have a bounds (besides Integer.MAX_VALUE). Can this not just be a standard ConcurrentLinkedQueue ?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Why an array? List<String> is just as fine
Does it really need to be 'public static'? Is this method used from somewhere outside?
Same thing here. I don't think mProducerContext != null should be a precondition -- setup() may have thrown an exception and we still want to do our best effort to cleanup by allowing super.cleanup(context) to be called.
I'd feel better with this if this method was still protected. Why was it made public in Netty 5?
Would be great to have it part of the TestableObject directly; so when we change the build tool one day, this feature would still be present.
Use assertEquals
These might look a bit tidier as static imports
Add messages: checkNotNull(id, "id"); etc.?
suggestion LOGGER.warning("DNS multicast capability has been removed from Jenkins.");
bleep
Generally with these kinds of constructors you'll end up calling the other constructor directory, passing in null for the ignored param.
responseStr might as well be inlined here since it's the sole use of this variable and it wasn't any less readable before.
Binary output length can also be calculated.
Should this be one line down after site?
no need to assign the client to a var here since it's only used once; could collapse these 2 lines to 1 instead
We will probably run this from maven, and will use it to write to a "target/generated-metadata" directory, which won't initially exist, so please create the directory here if it doesn't exist: File outputDir = new File(args[0]); if (!outputDir.exists()) { outputDir.mkdirs(); }
I don't think we want to propagate the exception in this thread. We just want to return the throwable. It wasn't this thread that had the error.
please put each parameter in separate line :)
why rewind?
You should use a variable to store this 5, so that when you want to change it, you only have to change it in one position instead of 3.
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface ?
Should be "InstaPost" actually.
I would just use pairId here and remove second arguments from URL.
Either use assertEquals() or better just verify at least a single nic returned: assertFalse(interface.isEmpty()) ; in addition, you could iterate over the interfaces and verify that all of them belong to the desired hosts: for (VdsNetworkInterface nic : interfaces) { assertEquals(VDS_ID, nic.getVdsId()); }
nit: imageName field can be changed to DockerImageName, to make tests' bodies a little bit smaller
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
It would be nice to have a configuration file locally, like looking to see if a ~/bridge-sdk.properties file exists, that would override default props. Then environment variables can override both of these (don't know if Apache config does this but it looks like you're doing something like that here).
We are not splitting files between individual tests yet. Please remove the duplicated file and have them point to the same one.
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
java boolean result = false; final DetailAST parent = colonAst.getParent(); if (parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT) { result = true; } return result;  ----> java final DetailAST parent = colonAst.getParent(); return parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT;
Should be ClassNotFoundException. Catching all exceptions and disposing them may miss unexpected exceptions.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
use symbolic name for whatever the last feature supported in that release is (along with <= instead of <)
Remove this
I would retain the existing indexOf body to to avoid indirection in the most common case.
what if none found? are we sure there is at least one?
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
Isn't this going to throw even if one of the ids is bad? Do you want to change that to continue processing valid blob ids?
static import
One thing to note here is that since shutdownProducer() requires obtaining the lock, this operation can get stuck waiting on this lock. Operations such as flush can take a while (up to 15 minutes for BMM with the current flush timeout). Once concern might be that unassignTask() is called from the onAssignmentChange() threads, right? And have a limited time of 30-60 seconds within which it needs to complete?
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
use instead, please, implements IntegrationEvaluationContextAware
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
typo
use namespace instead of DEFAULT
A message might be helpful
brr... I don't understand this ctor. it should do just this: this(new RqFake(), dispositions). why it's doing something else?
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check !getClassConstantOperand().endsWith("LocalBroadcastManager") can still be present. It will be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
instanceof?
The true parameter causes the contents to be appended to the end of the file, instead of re-creating the file with the new data. This can simply be new FileOutputStream(file, true), which defaults to false.
wrong formatting - every parameter should be in new line
Will these methods ever be performed separately/one and not the other? If not maybe makes sense to combine to one method?
please add call to populate: addLinks(populate(connection))
failCanDoAction?
This should be at least a constant, and more probably an instance variable.
Fuse container?
Taking into account that you don't know final size of a list and you will dynamically add items you can benefit of using LinkedList. Though that would not have a real performance impact I would still recommend to consider that case here and further for production code.
Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?)
should this count be parameterized?
This method should be private or default as otherwise it is API addition.
As above: private, 100 chars, use error result instead of doOnError.
This method has an external annotation now.
Can have a isRef(Expression) and isLit(Expr)
The NO_OPTION test isn't needed given you test for YES before taking action.
Nitpick: I would simplify this to return compoundAssignmentStatement != null && isAccessingExpression(...)
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Let's add the partitions parameter to the message as well and verify the expected partitions are revoked.
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
change to List
shouldn't provider be validated for existence prior to accessing it?
Speaking of sanity checks, is this: (100 - lastVerified) + 1 OR 100 - (lastVerified + 1)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
Can we also have a test for LUCENE -> NATIVE -> LUCENE
If the o1 is diff than null, o1 must equals o2. If the o1 is null, return "o2 is _diff than_ null" ? I think this second part is wrong?
Here you test findByName method. I believe the bootstrap is better to perform not using EventTypeRepository, but just using jdbcTemplate or prepared statement.
Please considert moving this to line 238, and change this to positive condition
Is this System.out required?
This method should return RemoteCache<K, V>
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
What's the reason behind this change? changeListeners and pools are also GuardedBy this, and this change removes the synchronization on them.
Make it final static
nit: we could extract this into it own method or extract the message in a constant to avoid duplicating it bellow.
why not just repo?
Why are we using Math.min/max() here but not above in unionBlock()?
Why not just return the condtional?
this method still only supports one layer of children.
this is always true because you've set it to null in the line above. What was this intended to do / check for?
Doesn't the remove() function return you the UpdateHandler which you want to call onCompleted() on?
onAdLeftApplication() callback is missing for Interstitial Ads. Please use [this](<LINK_0> existing adapter for implementation.
It would be better to move this line to _ensureUserIsWorkspaceOwner_ method because it is part of it. You can name it as _ensureUserIsWorkspaceOwnerByName_
introducing double retrieval from thread local, unnecessary perf hit
This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)
I would just make 2 calculateHrefs, one that takes Tab and one that takes GroupedTabData. Or convert the GroupedTabData into a Tab somehow. Passing in Object seems wrong.
Wouldn't Assert.hasText() be more appropriate?
please use org.ovirt.engine.core.common.utils.ToStringBuilder
ResourceSet<E> is correct and stricter than ResourceSet<?>
Style-nit: no brackets around single-line blocks
I don't think this is correct. This looks like you are trying to use either class or style. It is entirely possible to have both. The style always takes precedent over the class.
return tags;
This isn't a Messaging component and from other side using this one within a Messaging component, raising a MessagingException from here, we prevent re-throwing a correct MessagingException with failedMessage context. So, for me simple RuntimeException is enough in this context. WDYT?
Maybe you can just rename the member variable instructorId to id since there is no ambiguity in this class.
somewhat confused, if you've specified serviceName you can no longer specify sid meaning that you get screwed over here whenever you call namespace i.e. you go from having a namespace to *not* having a namespace. What are the implications of this in atlas? If anything it feels like getConnectionDataString should return the service name if it is specified, otherwise it returns the sid and that sid is *always* provided OR that if you specify serviceName, then you *need* to specify namespace explicitly when migrating over. Let's chat about this face to face.
Raw type here, generic in the base
I think you can plug in the User directly as a method argument. @MatthijsKok figured this out somewhere. Maybe we can even make it a Class field as every method in this Controller needs the User object.
Is there a reason for this to be protected?
Not necessary.
Can combine the 2 above lines and use the constructor which accepts disk-id
seems false is also a valid response.
Same thing as above, let's split out a config for this.
The value is not assigned to json?
Minor: Use this. consistently in the class.
Remove?
Could you please add curly braces?
Looks like this will incorrectly log the requestExpiryTimeout for control actions. Can you update the log to use the expiry timeout computed from the previous line?
I really don't like the user of instanceof. Why not overload the method to recive VDSExceptionBase? In both places this function is used, you already have that information.
In what way is this an improvement?
But for this case, it will lose numbers under a decimal point.
suggestion return unmodifiableMap(properties.entrySet().stream().collect( toMap(Map.Entry::getKey, e -> e.getValue().property)));  needs toMap being imported statically
In the situation, when the session never gets reestablished, handleNewSession will not get invoked. So, handleStateChanged with state EXPIRY needs to be handled.
wait.forElementClickable() should be used before
return SUPPORTED_SERDES.contains(serdeName);
add wait condition for shell
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
convert to private constructor and a static create method
should either read: "Must set either both SslSocketFactory and TrustManager, or neither" or "Must set either both sslSocketFactory and trustManager, or neither"
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
This looks like testDataFormat(COMPONENT); Please see other tests for sample
Looks like you are making double slashes here...
Similarly, would be nice to log the class name of the input stream.
Why Level.CONFIG?
Shouldn't jobName and jobId be always available? Would prefer to throw if not instead of defaulting to arbitrary values.
suggestion return Arrays.toString(value);
Instead of introducing a new ITranslationUnitProvider interface, it's simpler to get the editor's input and check if it is an instance of ITranslationUnitEditorInput.
I don't quite understand why you verify something here and in all cases in this class when we expect a exception. Execution of this test will never reach to this line.
filters method argument should be passed to isMessageInLogFile as an argument
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void should_fail_if_one_field_or_property_is_set_even_if_another_is_ignored() { // GIVEN Jedi jedi = new Jedi("Kenobi", "blue"); // WHEN expectAssertionError(() -> objects.assertHasAllNullFieldsOrPropertiesExcept(someInfo(), jedi, "name")); // THEN verify(failures).failure(INFO, shouldHaveAllNullFields(jedi, list("lightSaberColor"), list("name"))); }
println should be changed to a logging message
To follow Spring Security conventions, please change Raw password to match the variable name of rawPassword.
Do we wanna return ImmutableList.of(address) or this is intensionally?
Encapsulation
The synchronized can be removed.
Should use the Value constructor that takes String
Map<TableScanNode, Void> result = new IdentityHashMap<>();
It'd probably be worth logging if is an invalid value rather than silently ignoring the input value.
> I'd prefer to have a consistent behaviour, and to modify it everywhere if we feel the need. I totally agree with you. Note that I'm not against the current version (i.e. it's not a blocker for this pull request), I'm just wondering if we should also include (or replace with) the date or not.
Extract this into a method, given that it's called twice
it looks like far more deeper in the stack from where it should be - let's say that we got an event with a latter time than another one we already processed, when the code is done here it means we'll process it and will just not save it to the DB. I think it should be much higher in the stack - maybe even not to call the perform method in this class if the fetched stats are the latest
question: have you found a benefit to using throw-away anonymous instances of things like Runnable preferable to either A) creating a single instance as a member variable and passing that instance to .post, or B) implementing Runnable and passing bare instances e.g., .post( new RenderTaskPostExecuteRunnable() ); i'm not saying it has to be one way or another, or even different than what you've done - just asking your opinion. i personally believe it to be most efficient (in this case) to use alternative A - define the Runnable once as a member variable of TileCanvasViewGroup and pass that to Handler.post each time, but am definitely open to other ways if there's a reason to. @peterLaurence feel free to weigh in here too
lambda?
remove(Object)
Change to: > Unsupported DMN asset
this. maxRetries = Math.min(5, maxRetries);
maybe some kind of separator would be nice here?
Change this variable declaration to something with meaning in the context. map is unclear here
Can use constant for "4". More importantly: if the blob is not already encrypted, the config flag "requireEncryption" is true, and cryptoService is null, upload should be skipped. (You'll see some of this logic when you merge with master.)
warn seems too relaxing for this kind of exception. maybe error?
I recommend using Collections.emptyMap() instead
change to IAdaptable
FYI, magic number 2 can be replaced by constant ComponentContainer.COMPONENTS_IN_EMPTY_COMPONENT_CONTAINER
can you refactor that in a test utility class?
why null check here? ... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution.)
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
Good one! :)
Is this supposed to be <code>return "Bump"</code>?
Was this intentional?
could we refactor the above into a setUp() method and not having to repeat for each test
This will create 0 connections. Didn't you mean < ?
Please check if this method really should be public in a private static final class. The parent method is protected.
I would change the 'by ourselves' into 'synchronously'
No necessary. + operator with a string operand (the prefix) performs auto-stringification of the other operand.
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
these setters should not be public
I added method in Utils for that
this method should be defined in Menu interface
OK to return the empty set - the JavaValue is a value, thus no variables inside.
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for ? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well ?
Maybe this whole if statement could be simplified a little
why this.writeLock().unlock() is not enough?
I hope you do not kill me, but as this is infra component it is good to know the practices... you should not allow caller to modify collection. return Collections.unmodifiableList(errors);
Aside: I'm assuming this was generated. What IDE are you using? Most of them should be able to generated Java 7-style equals that use java.util.Objects.equals(Object, Object) to avoid these null checks.
Gson doesn't run on these versions so I don't see any reason to include them.
Use fluent interface in here
Why do we return the parents name instead of the name we store a few lines above?
Let's change it to get the child commands CommandEntity rather then the CommandBase, it's slimmer (doesn't require to build all the command objects) and contains all the data you use in the calling class.
While you're at it, fix the initialization here, same way as you did with the singleton for Device Custom Properties.
And here. needs some validation.
Let's inline this: return doGetInputFieldsForPMMLStream(modelInfo.getPmml());
we should probably Assert.notNull here to ensure that a simple toString call would never end up with a NPE
n["+fTimeArray.length+"]("+min()+'\u2025'+max()+')';
please use try with resources as in ConfigurationHolder
suggestion if (keyedStateBackend instanceof CheckpointListener) {  Since the instanceof operator always returns false for null, there is no need to have an additional null check.
since "acceptedType" is of type list i would suggest to rename it to "acceptedTypes"
write nullable on the same line or don't write it
style nit: we don't use braces around single line blocks
You may want to make the default smaller - like 0.01.
can use Ds3DocSpecEmptyImpl here
allExtensions instead of getLoadedExtensions()
Iterables.all(toolGroup.getTools(), Predicates.instanceof( AbstractToolDescription.class)); allow to return false if all items are not of type AbstractToolDescription
move 0 to private constant as you use it in many lines, it will be easier to change it in the future if needed
better to set it to the default and log a warning
throws TaskException is part of the interface, did you mean to remove it?
Not sure if it matter much, but the 'better' way of getting an empty list is: return Collections.emptyList(); In this case however we need to specify the type: return Collections.<CertificateInfo>emptyList(); As the compiler cannot infer the proper return type.
You can drop these from the throws clause. Not only are they not thrown, but they are RuntimeExceptions.
Can we avoid the switch as its not common practice and maybe people dont know about how it works and would think that remove and put does nothing in this example etc. Make the code understandable and maintainable for everyone.
Same here, what's the purpose of getRoot()?
formatting
This is an expensive call. Is it really necessary? Maybe we can get the session ID cheaper by a direct call to zooKeeper.getZooKeeper() - (checking for nulls)
I don't like it. For me it should be very simple:  return "ExpressionEvaluatingSelector for: [" + this.expressionString + "]";  The compiler optimizes it to the StringBuilder
nit: now that we are passing in the processingMode, we could potentially use this check as a helper function as:  private boolean0 eosEnabled() { processingMode == EXACTLY_ONCE_ALPHA || processingMode == EXACTLY_ONCE_BETA; }
No need for second level of brackets.
Fix logging level here (error)
Same with the ( and )
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
should probably check the app name does not have any chars that are not allowed in a zookeeper node name
This is not how you make an [unordered list](<LINK_0> in HTML. Example:  html <ul> <li>Coffee</li> <li>Milk</li> </ul>  produces - Coffee - Milk
Need to pass the exception object.
suggestion ReentrantLock getLock() {
Is there a constant you can use to replace the ".done" literal?
Style points as before. In this case the class has existing code in a certain style.
Should we pass in MAX_VALUE to avoid introducing test flakyness?
can we use method reference here this::createHeathIndicatorForCircuitBreaker
I don't think you want to keep this print in here and the rethrow as a cause
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Consider writing a header for backward/forward compatibility.
Readability is concern here, lets keep it as it is.
Is it required for the upgrade?
Same issue as above.
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
If you combine the last two return statements you might as well only have one. However, I think the old way makes the code easier to read/understand.
populate with meaningful data. Version should fit to artifacts versions automatically Licence: <LINK_0>
unneeded throws Exception
If the format is null then we need to check for the translation type first. Anything not a text translation type has a format of markdown. If the type is text then if the project id is obs the format is markdown, otherwise the format is usfm. We cannot completely depend on the resource type here because a REGULAR type can be either obs or a non-gateway language translation of a Bible project. > NOTE: In the android app we don't directly support translating to a ulb or udb resource type. However, the desktop app _does_ support this. Therefore android provides just enough support so we can import a translation from the desktop app without breaking.
Unless I'm missing something, testFinished(class) == testStarted(class) (either a test starts and finishes, or it never starts). Can we just have one method (perhaps named wasRun)?
This will destroy performance. We cannot allocate a new byte array with every short read. You could use an instance field buffer of sufficient size to avoid the issue.
>byte[] [](start = 11, length = 6) DecryptResult
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
I think it's wrong. Maybe state when a.hashCode() != b.hashCode() but a.equals(b) is true.
whitespace/style
Since this is a String, perhaps you could use Collections.nCopies
Since this class only works with Numbers, we should throw an exception instead of returning null.
this is not good, you've removed the information from the nested exception! :)
Could change the return type on method to Collection
Pay attention that most methods of this class return the null as String, but this method returns "null" as String.
no checking flow when user sets grace period in the action
You could save a few lines by moving the return null into the default case instead of break.
This should never be null as DMR always returns something
Probably it should just return false
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _getCurrentContext()_ once and store the result in a _context_ variable). As a side note - in this and the following cases, the number of lines to change (and detected as changed by git) would be much lesser, and so the overall impact.
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
if you set this variable to null then calling twice this method will result in an ugly NullPointerException what about  try { if (txnLog != null) { txnLog.close(); } } finally { txnLog = null; }
use ShellIsAvailable
dont think a setter type function should return the "this"
- please remove TODO - please use propper logging instead of using printStackTrace()
This also seems kinda pointless and a bit brittle. Just return resource.
not use this to reference class members
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Please, don't reload the text in onResume(). Do it in onCreateView() or onActivityCreated(); onPause() and onResume() may be called when other windows partially hide the fragment (such as the menu showing apps to open the file outside of ownCloud) even though it stays visible.
before click, make sure element is clickable
You could add a text here to show what the output means. You probably know, but me running this benchmark, I'd need something more verbose ;-)
org.apache.wicket.request.resource.ResourceReference#ResourceReference(java.lang.Class<?>, java.lang.String, java.util.Locale, java.lang.String, java.lang.String) cares about the non-null name. No need to check it here too.
assert.NotNull ?
can you wrap this with if (log.isTraceEnable)
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
should probably throw a NotSupportedException instead of returning null.
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
notice that after previous alterations, this can be now easily rewritten using stream api to do filtering and applying method to all items. If you like it better, you can do this, not important.
We should just check for >= ICS instead?
maybe same logic can be addressed in less lines by using Streams, it would also help to read this method faster... Eg: Streams.stream(groups).filter(...).map(...).collect(...)
I think isDisposed should also be checked here, right?
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
why are you changing this line ?
config is a non-primitive object, cast to Map<String, String> here before serializing and adding into the map; similar to how containerModels are added above.
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter filter = filters[mid]; int c = methodName.compareTo(filter.methodName); if (c == 0) c = className.compareTo(filter.className); if (c == 0) { return true; } else if (c < 0) { high = mid; } else { low = mid + 1; } }
You don't need to set the Id here as it's done in the setup() method (but does no harm and makes the test clearer!)
Collections.emptyList()
We should leverage the appropriate org.wildfly.security.manager.WildFlySecurityManager method here.
This does not need to be changed.
Maybe legacy version of SetDigest can not be cast to HyperLogLog
requireNonNull?
Not in prod, no way!
Could have @VisibleForTesting annotation. Also could public be removed?
How about adding a param to constructor for this?
Not null, not empty, no blanks? There should be a pattern for a valid Java method name.
use new Guid(String) - this literal can't be null
If we modify this changeset, then we could give a try to using Optional here
It's better if you could make a function like getStringWithFormFieldId(String formFiledId). You could call the function getStringWithFormFieldId("clientID"); getStringWithFormFieldId(clientSecret);, ....
do we care to check the length to be positive here?
2 nits: - this should use remoting's WebPreconditions so that we can toss a 400 at the user here, rather than the 500 the current implementation would give (in a sense it's the user's fault!) - because TableReference.createFromFullyQualifiedName() itself does a (normal) preconditions check, this should go _before_ the table reference is created
Turn this into one or more helper methods. The simplest thing to do would be to have something that returns and List<String> or Iterable<String>. Then you could use standard Hamcrest matchers to assertThat the list does or does not contain the expected outputs. Alternatively, you could make higher level helpers such as assertSleepCount(expectedNumThrottles) and so on. Or even assertCount("Sleeping", 0) would be okay. But for more complex scenarios, you might need to check the order and count of messages. Your call on the specifics, just need something a little easier to read.
Use same pattern as above?  if (... == null) { // do null case } // do non-null case  ?
So does it work for ADMIN client port? If a client connects a node using admin port, then this client will try to connect to other nodes not using admin port. Right?
Is reentrancy a problem? It looks like it would be possible.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
Why do you use 3-argument constructor here?
Super minor but no conditional needed here since properties is either null or non-null.
Why this change?
you can check the cache file exists (check line 147, which checks the output report), and you can check the output for the cache warning to not be present
newVmStatic ?
Source ids are supposed to be unique. CachingFederationStrategy doesn't really care, but it's not accurate to how the system is supposed to behave. I'd prefer to mock normal behavior by making these ids unique within the scope of each unit test.
private static final int FIVE = 5
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
Could you please throw TalendRuntimeException instead of RuntimeException.
If item is null, the code will enter here and we'll have a crash. The condition must be split in two; it item != null, all the code is done (including the if (sendEnabled) ... else ...) ; if it's null, do nothing
shouldn't this be an else if?
Local variable not required. You can directly populate the class level variable this.servers
This and other setters don't have to be public, could be private.
@phillipm Bumping on this
nit: we could use putIfAbsent here
copyOf does not necessarilly copy (I know name is misleading). Also we value readability, and old version is way more redable than the new. Finnaly we prefer relying on guava's collection. So I disagree with this commit.
@ivandalbosco Is it possible to have invalid line? and as a consequence a parsing issue on file level?
@ekondrashev move this assignment to line 103 above.
either change the method name to refreshMetadataDevicesInfoIfNeeded or better yet add the if condition here.
As here we now want to compute generic cognitive complexity, not only for functions, why should we not increase complexity outside of functions?
Minor: can specify the initialCapacity constructor arg as 3
Normally we would do this to prevent accidental bugs to trigger the wrong failure:  private RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder() try { builder.rxFactory(null) } catch (IllegalArgumentException e { //... }
The flag is being set to true always, the previous statement does the right thing - Did you leave this by mistake?
@essobedo once used variable can be inline
Unnecessary call to super
I would use method reference as per below suggestion String[] nodeIds = logs.stream().map(NodeInstanceDesc::getNodeId).toArray(String[]::new);
Do we have to use the configurator for fetching 'MaxVmsInPool' value? A lot of configuration values are fetched in 'VmModelBehaviorBase' (e.g. GetMaxNumOfVmSockets) - try to retrieve it once 'PoolModelBehaviorBase' if it's not too cumbersome.
All of this can be replaced with an ExecutorService
this assumes that field.getRegister() is the same string as the fieldName. it might fail specifically for the registry field which links to the public-body register, not to the (non-existent) registry register
Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
There should be no need to recompile the RegExp for every file.
s/String splitKeyValue[]/String[] splitKeyValue
Use ClientLogger for throwing exceptions
I wonder if this change would result array allocation and extra cpu/memory consumption issues
Should this executor specify the Looper too?
Maybe better to generate N random bitmaps with a fixed seed. That way, the test is deterministic (but still tests decent variety due to the N factor).
senderId => fromuser
Same as above: could use searchPacksAgain
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
better use Strings.isNullOrEmpty(item.getLargeImageUrl())
nit: use List rather than ArrayList
Same as above for toString(): <LINK_0>
I wonder if it wouldn't be better if we *never* used null as key, and instead use the empty string. Then this 3 LOCs could be removed.
Missing null check on sampleClass
Are you using a mix of tabs and spaces?
checkState(mPut != null) ?
This does not take a message, it takes the id of the resource that is missing. Here I would just use the no-arg constructor.
Shouldn't you be asserting the UNWRAP_KEY permission?
why is this necessary? why onTouch? please do not use espresso onView or onData operations in setUp.
Replace with logger
Can this be within the if statement above?
else if (SecurityUtils.isHadoopWebSecurityEnabled())
Could you please rename also _result?
we should probably check in the canExecute whether we reached the end of the list
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
It seems you can remove the IOException now.
The Exception is never thrown.
LOG.info("endpoint : {} , timeout : {}, connected successfully", endpoint, timeout);
Add the attribute only if blocking is true
What about creating:  private static final Future<RecordMetadata> COMPLETED = CompletableFuture.completedFuture(null);  and then returning that instance in all of these places. Since it's already completed, immutable, and we don't allow cancellation, it should be fine to reuse in this LogReporter.
Again small thing, but "the existing file" sounds better IMHO.
Why not just use " " + System.lineSeparator() ?
The unit test params have a difficulty interval of 10. It looks like Block.createNextBlock() doesn't take that into account (yet). If it's an option to you, try running the test with TestNetParams/MainNetParams.
Please add java doc
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
not useful I think
Use reportError rather than report.
InfrastructureException can not be thrown here
This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was a reason it was an instance var that was mutable.
I think we should treat this like we do in Data, and assign currentTime if ctime <= 0. Don't let bogus ctimes be passed in.
This helper function seems to only be used by fetchUsers and perhaps it could live as private instead of public until someone really needs it. Cheers!
Please also exclude any fields starting with "$"
misspelled. plus why are we leaving the first character capitalized?
I'd prefer if you put the Headers here in a local and did isSameAs just like is being done with body.
rename 'variableName'
Do you think we can continue with the exceptions refactoring you started in repository level and throw these exceptions to controller level catching them with exception handling mechanism?
Please log the exception. Do not print it. Log it like this: logger.error("Some message..." + e);
I don't think this is possible, if the cache is not defined it will be created with the default configuration.
Could refactor this to something like the following, this would reuse code in super class. java @Override CompletableFuture<Boolean> getMainOp(CommitData cd) { return super.getMainOp(cd).thenApply(b-> { Preconditions.checkArgument(b); //expect this to always be true.. was not sure about adding this but decided its good to make few assumptions about the super method cd.commitObserver.committed(); return true; }); }  I was trying to make this shorter by using thenRun() but the void return type threw me off.
This is too broad and is swallowing exceptions that need to be propagated.
Maybe add a description for the error here, something like "Error occurred while requesting purchases for deletion check: " + error.toString(). I think it'd be easier for us to find the issue from the logs, especially for the HEs.
This is super minor (coding style): let's add a single space character between the , and new. You can perform this automatically by selecting the line (better select this single line only) and use "Code -> Reformat Code" from AndroidStudio's menu. Thanks!
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Would it make sense to add a String.class entry to POJO_TYPE_MAPPING instead?
Does this method need to be public?
@ikhvostenkov please name it json
we're used to write it as if (!t.isFree()) .
We should mutualize a hasTag (probably in stats)
Can be replaced with call to computeIfAbsent.
Why not just pass in only the message?
instead of calling here to a function that only set the status to connecting (without any callback meanings), just getVds().setStatus(connecting..) does the same thing. otherwise change the name of it, because it's not act as callback function does.
I would just not negate the condition.
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
I didn't highlight this issue in previous nodes as it isn't overly important but perhaps we might want to decide if to consistently initialize the two rendering configs either by first obtaining the Config object from the context or, as you do here, by having everything in one line. I guess on one hand I feel that having a local variable helps with the readability given that getRendering() and getDebug() are a bit ambiguous as method names go. On the other I like the compactness of the one-line in this case. I'd say I'd prefer readability over compactness though. What do you think?
Could you replace this and any occurrences of printStackTrace with logger.warn in the code (since you are making other fixes)? Bindings should not print to stdout or stderr but instead use log4j.
should this not be "Unsupported operation for Admin service"?
Perhaps swap the branches here, so you can drop the repeated return?
You only want to use closeQuietly() on an OutputStream when an exception already occurred. Otherwise you mask exceptions that happen during a close(). Those should be treated the same as exceptions during write() calls.
Is this related to metrics? Or something else?
This line now exists in the else statement as well [here](<LINK_0> I don't think this isOnline check is helpful. Because of that we have a hell of indentation here. I think shouldn't have getAsync from model 2 times. What we can do is that, we can first try to get it online, if that is unsuccesful, we can try to get from the cache, if that fails, we can use setIsloading(false)
Formatting?
If we provide port value of "0", each time we call start(), it generates a new NettyContext, which has a different "address" - "port" value. So if the caller first calls start(..) and then asks for the "address" value, while another caller also calls start(..) and asks for the address value, then there will be a race condition. Other than that, when we call start(..) at the inside of a single thread, the address value of the initial call will be lost. It seems we only need the "address" if we pass port value of "0", otherwise address can be created by merging "bindAddress" and "port"? If so, we might have a overload method which also provides the address value back? If caller really needs the address back, the caller can call this overloaded one. So we will not need any class member and it will still be ok for multithreading?
this change also needs to be made in KMeansPMMLUtils.read()
Can you replace IDs with names in this log message?
consider using a mixpanelPushNotification.isValid() that checks for errors inside
Spacing java for (FMLMissingMappingsEvent.MissingMapping evt : event.getAll())  The variable is better called entry instead of evt (event)
ProductInventoryClientImpl does not return null but 0 when exception occurs. Perhaps returning null would be the correct way, so the change should be implemented in the client..
This check should be outside of the synchronized block. No use grabbing a lock to throw an exception. Also, super nit pick: can you flip the order of the conditions so the less than zero check is first?
checkIfResoruceHasThisTagType
I think this is meant to be moved within the if (executor.inEventLoop()) { block below?
This assertion could be removed as it seems to test the Java type system rather than our code
Embed the caught exception in the newly thrown exception
can be reduced
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
prefer  String operation = isFile ? SASTokenProvider.CREATEFILE_OPERATION : SASTokenProvider.MKDIR_OPERATION;
IOException will be thrown if MappingMetaData is not valid json, right? (populateColumns doesn't throw, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think?
Echo the keyVersion that was checked to help users
You will probably need to change this auth and the accept type when completing teh request verification in the mock tests.
I realised that the session visible from time is never supposed to be after the session start time: <img width="940" alt="screen shot 2018-04-04 at 4 58 11 pm" src="<LINK_0>"> Hence, it is the start time that we need to set to a hundred years later. The visible from time can be set to TIME_REPRESENTS_FOLLOW_OPENING so that it follows the start time.
Not critical, but for simple maps like this it can be nice to use Collections.singletonMap to keep it concise.
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, Charset.defaultCharset())?
I think it would be nicer to call darker only once, although it is not really critical.
Same exception text adjustment suggestion as above.
Isn't this better done at the beginning of onResponse() instead of here?
we should check mMediaUpoadHandler != null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
Rather than printing it out, use an assert*() test method. Simplest might be asserting the string is not null; you could possibly String.split() on the delimiter and assert that the resulting array has a length of at least 4.
<LINK_0> should be used
in theory this should be newTableHandle.getLayout . But if we decided to squash these commits it might not matter..
This is really not needed. CommandBase#1256 sets CommandEntity.commandStatus to FAILED in this case.
[minor] ImmutableList.<Segment>of should also work and avoid the cast
This is generated code, please remove this or adjust the EMF code generator.
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
Why don't you initialize this where you define eventHandlers? This saves the null check on every call to this method.
this must be disposed
Duplicated?
This method sums over the second and third dimension.
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
iteration over the entrySet is faster
Shouldn't we throw an exception here ?
Just put runningQueries.keySet() here in the for loop. No need for the extra queryKeys array list that you copy it into.
Unnecessary. There is nothing in the Guice world to start or stop.
Can't tell how this works from this RB alone. Is this going to become the logical id for the stream when you create a spec for it in the Planner? And then the physical name by default appends the JOB_NAME and JOB_ID?
There's an inherent race here, if the following sequence occurs: 1. Thread A: getRealmIdentityForUpdate 2. Thread A: removeFromCache 3. Thread B: getRealmIdentity 4. Thread A: modify credentials 5. Thread B: authenticate with wrong credentials, which are cached forever The entry should only be removed from the cache *after* modifications occur, i.e. ModifiableRealmIdentity has to be wrapped as far as I can tell.
Maybe you should look into "logic of detecting directory" which is really used for meta data editor. Not in any case used directory is named with process title.
Seems like this configuration is being created and not used. Does this test pass?
Minor nit, shouldn't this also be at debug?
Lines 56-71 shouldn't be indented while they are inside if statement from in line 55?
Please assume usage of org.drools.workbench.screens.guided.rule.client.util.ModelFieldUtil.modelField method
I think it is better to use static import here
StringBuilder please
s/id/ID
We are passing an owner here, but we are never adding it to the collection.
This code assumes that the first 8 bytes of pcapPacketHeader have already been read... It's true in practice but not very safe.
I prefer to keep the static import.
Avoid hard coding the path, use Environment.getExternalStorageDirectory() and the local path as a string resource.
this branch is redundant, can be replaced by if (op2Zero)
If container is IWorkspaceRoot the scheduling rule must be WorkspaceRoot.
I thougt we had a function to print that string
wouldn't all start times be invalid then?
remove !=null since null instanceof WrappedMessageContext will return false
field.getChildren().get(0) is an Optional and we just call get, is a value guaranteed to be present in this optional? On L176 we do a isPresent check, but not here (and below around L156)
NACK. this undoes #1272
Not being able to set the timer due to an unknown exception is a critical error, so it is ok for it to crash the app and open the bug report screen. So this whole piece should be converted into: updateTimer(this);
Looks from the conditional block above like ref can be null - should we be handling that here?
nit: this can be private synchronized Optional... and we wouldn't need the synchronized block below
It'd be nice to clean this up a bit and have a single constructor.
Precondition to check page Offset is positive?
what if valuelist is empty? should you check for that?
nit: put with the previous line
You don't need to repeat lines 67, 69 and 70 as this will be invoked by this(resource) : this(...) invokes the other constructor first so no need to repeat it's content.
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.
Good catch :)
No need for a null check here, instanceof would allow both the class and null check as one.
This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an error to the caller instead of ignoring and continue?
This comes from when we pull the body out the camel exchange right? If somebody sends in the wrong type, the exception message does not seem accurate.
Remove unnecessary variable.
The Kafka client library has constants for these strings, would nice to use those.
Since this is a separate check anyways, I don't see a benefit in comparing with FFFD instead of 10000. Use >= Character.MIN_SUPPLEMENTARY_CODE_POINT instead. It's also more evident what the code is trying to do that way.
Cannot this be changed to orElseThrow?
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
Should initialize list size with children.length
It's possible between null checks that someone sets the subscriber to null when you retrieve it a second time.
I think it makes sense to limit Che container name like to 50 characters and if preliminaryName is too long then get first 12 characters from Che Plugin Name concatenate Che container name along with '-' separator. @garagatyi Please pay attention to this. Maybe you can suggest a better way.
check if volume is null and log and return.
The empty string in the constructor is redundant.
Please keep this.cell near the related fields (previousFamily & cell count) below
Would you mind improving this test to use executeFile() instead of executeString()?
It seems that the following does the same thing with super.unparse(...).
This annotation should probably stay, and again for parse below
Put ITEM in front of OTHER_FUNCTION .
we might avoid using this new getMacPool method by using AgrumentCaptor and verifying that the expected macPool object is being passed.
static final String
@inverno can we drop it?
You didn't want to use minDateTime() and maxDateTime() huh? :P
please rename both variables: sortFilterCmd and updateFilterApplicationCmd
Add a check here to verify that the serialDataReceived method was not called.
I think this exception should be about a @ResultHandler annotation, is that's what's being verified in the MessageHandlerInterceptorDefinition#wrapHandler method.
This does not match the debug log below. We should ignore a remote Ack if we are the master.
To go up before the first "for" to avoid to call this code several times.
Please move this to DBUpgrader. Also, use oldVersion < 1090001. Users might skip AntennaPod versions. When checking for equality, this skips the migration when coming from, say 1080100 instead of exactly 1090000.
This is in general a bit tricky. This check implies, that the namespace is contained in the properties. Is this really always the case? The namespace should at least be enforced before trying to equal on it Besides this, an edge can connect the same vertex, so pointing to itself. This may not be used often, but AFAIK it can already happen within linkd.
is this really a requirement that in().dimension(2)==3? actually it should work for arbitrary dims, right?
please remove alias setting (should be encapsulated in addManagedDevice
Tool tips can be slightly more detailed. Sometimes just a one word may not be enough.
The hashCode() and equals() implementations depend on the current position in each payload's ByteBuffer. The implementations can also process the same payload bytes as it recurses through the child packets. The payload should be processed only when there is no more child packet, and it should process the whole payload regardless of current position.
Inserting line breaks in log entries can cause pains when reading the logs. Can we remove the \n?
Did OSCORE specify to use ACK (and not RST) even if the message processing caused an error?
is this supposed to be deadlineMs - System.currentTimeMillis()?
you're synchronized on shutdownGracefully. Is it possible we are active at this check, but then become inactive ungracefully? I'm assuming that is also synchronized? I see that the handshake case is covered below in the else{}
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
What is this proving? If you  groovy sh 'cat /any/file/at/all'  your log will contain  + cat /any/file/at/all
IOUtils.close
If the Deserializer is named, Deserializer. The Serializer should be call Serializer!
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
Use parameterized logging instead of string concatenation.
you can move this line out of the loop
I take it a CborLong is 32-bits long?
nit: for all of these, can you do assertEquals(addresses.getStatusCode(), 200); to avoid [yoda conditions](<LINK_0>
Can we rename this.policies to this.customerPolicies? This method is hard to follow with two different lists called "policies"
remember Logger.debug(getClass(), ()->"luceneQuery: " + sanitizedQuery);
newMappings is not used. You can avoid all this synchronization by atomically replacing channelMappings with newMappings.
I assume this fetches VLAN devices properly, i.e. if the iSCSI bond only uses eth0.101, this won't return eth0 right?
s/unexpetedly/unexpectedly
we should log this before throwing it.
Do we want to return here so as to skip the older File.setWritable call?
You need to make sure the revisedOrder has the correct action of REVISE
Maybe just have one TextView for parcelExtra like the other samples? parcelText.setText(String.valueOf(parcelExtra));
The point I was trying to make is that you know this data in the constructor. You can do this logic in the constructor and simply return a copy of the binary data. Before, you were iterating through the Iterable of BinaryData each time, creating a new List object and then throwing it away to get the first item before copying it.
Nit: could you avoid static imports for non-obvious cases like this?
why replacing lockKey by lockKey? shouldn't be lockValue by lockValue?
![Codacy](<LINK_0> Issue found: [These nested if statements could be combined](<LINK_1>
Remove unnecessary blank line
I don't think there is a need for this any longer - Files.move() will copy the file if necessary - I tested it on OS X and Files.move() moved the file to another physical disk. But I suppose it doesn't hurt to leave it here. WDYT?
Please remove initEditors
Should be Localized in Android framework.
We have another NPE here
I need to hit ARROW-DOWN twice to get something selected if there's no selection yet. Perhaps select the first item then?
Existing code use null as the sentinel for this field, so I think you should keep using null here. suggestion this.apiUri = null;
same question here, do we account for the colo with single replica?
This should be validated with an assertion as well
any reason for this change?
This may cause a breaking change. Until now, the "type" of a DomainEventMessage wasn't used. I suggest accepting unmatched types when the aggregateModel doesn't define any polymorphic types. In that case, we can silently accept "mistypes". If the model _does_ define multiple polymorphic types, then we should throw an exception.
This seems like a significant refactoring - why? Can we do it as a separate change or is it required for the java8 migration?
Can you set the message inside the method avoiding passing it as an argument?. It's always the same
Shouldn't we use the material library version to get sexiness pre-L? (And consistent behavior in general.)
The registration1 doesn't care about the value other than it is different than registration. For this case, registration3 needs to use the new variables, so (if it is kept around) it should be named more explicitly.
objectRefs.get().acquireReference(object) -> objectRefs.get().releaseReference(object) I think you want to decrease the reference count here?
not necessary to add "due to"
You could combine this into the for loop conditional using && and removing the negation.
Should we use one of the core executors here?
@inverno We have 2 times "Second argument" :)
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
i18n
Could use a mocked Model to avoid the need to tidy up.
Will always start by "file", so you can directly return true
why do we need to make a copy here? just use props directly?
new String() is redundant.
No special need for final and please use interface. No need to know implementation. I would even recommend to use ImmutableSet from guava for safety.
Shouldn't this be Calendar.getInstance() instead ? That way it's truly a no-op.
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
this is not needed as done internally in the ItemService.delete <LINK_0>
Can the method be called getLabelNames instead?
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
I think we can just go with the  @ContextConfiguration @RunWith(SpringRunner.class) @DirtiesContext  and avoid extra loads for the the same config in each test method. I that case the outbound-gateway-parser-config.xml should be renamed to the MongoDbOutboundGatewayParserTests-context.xml
We need the group_id as well.
I'm missing the new field in the toString method.
Maybe turn these three into a single if?
DefaultStainCategoryService calculates whether to add the 's' or not, could this one too?
wrong order
This expression (nano % 1000 >= 500) is used in more than one place, why don't extract it to a function?
The 'Network' should be omitted from this context since this is not a specific provider.
Share the string.
I guess you want to return Optional.empty() here
Change LIKE to =
You could probably check Jenkins core version here: Jenkins.getVersion().isNewerThan(new VersionNumber("2.64")) in order to optimize the call on the agent side. and to check JNR version before it . But it's rather polishing, which may actually break some use-cases with pre-loaded JAR files
you directly use the member variable tcpSocket, but shouldnt it be the parameter socket?
this test is failing in JpaStoreFunctionalTest. I believe you have to use String in the keys and wrap the value using wrap("k1", "v1")
ExecutionException wrap the actual cause on loading the file channel. so you need to unwrap this.  if (e.getCause() instanceof IOException) { throw (IOException) e.getCause(); } else { throw new IOException("Encountered unknown exception on opening read channel for entry log " + entryLogId, e.getCause()); }
We should probably add 1 more new line to separate from the error itself more in the dialog and make it stand out. Also, will this get localized properly for our translations support?
Should StringUtils.EMPTY be used for these lines?
This whole block can be simplified, no? You're effectively checking for negative health twice now.
Please, make sure all the code follows [project style guide](<LINK_0>
We should mention this default value in the getter and setter
why not check for null?
Method should be synchronized probably?
Is Windows going to be handled? It probably needs to return 501 from the REST endpoint
nit: If we make this method synchronized, then this synchronized statement is unnecessary.
Try to use CollectionUtils.isEmpty instead
I think you can replace this with import com.android.internal.util.CollectionUtils; public String[] getLocalOnlyIfaces() { final List<String> list; synchronized(mPublicSync) { list = CollectionUtils.filter(mTetherStates, state -> state.lastState == IpServer.STATE_LOCAL_ONLY)); } return list.toArray(new String[0]); } (note that passing a new String[0] is typically faster than passing a new String[list.size()] thanks to intrinsics, but it's really marginal)
IIUC, the reportedConfigurations are relevant just if the networks is out-of-sync. Why passing reported configuration of a sync network? The network may be even moved to another nic, so the its original reported configuration doesn't relevant anymore.
It seems that we could replace these methods by an AssertJ call. (Perhaps first converting the Issues to Strings using a very simple, clean stream.)
I think this condition makes sense. Can you update the code to match the surrounding formatting (hard tabs, and use braces)?
why did you change to final here? should be outside of the scope of the patch.
@essobedo once used variable can be inline
after you changed that dao call the if condition is no longer neccessary the loop can be removed completely - replace it with use of Entities.businessEntitiesById
Just inline the variable here.
Most of the methods are synchronized. What's the point of using ConcurrentMap, then?
this condition would always succeed when there is a transformation, because getLayout would return the transformed layout. That is probably not what you intended.
we should figure out the best way to handle defense against this endpoint being called repeatedly and bogging down the server
I think we should rename Identifiable. It sounds like an interface, but it's actually a class. Maybe just BaseModel or something like that. By the way Extensible is also probably a bad name. Maybe we should rename it into ExtendedModel or something like that.
Why are you retrieving data from a newly generated intent? Also, I saw this function is often followed by a putExtra(VideoPlayer.PLAYER_TYPE, can't playerType be made an argument?
I'd like to see tighter bounds on the test. The first 10 invocations should say it is expensive and then is should switch back.
Typo? What does this do? If partitionCapacity is null, this would throw a NullPointerException.
Using this magic string here with the concatenation is a bit brittle. It would be nice if we had a centralized place where the prefix lived, ideally with three methods like: 1. createSourceElapsedPropKey(String): String 2. isSourceElapsedPropKey(String): Boolean 3. getSourceFromKey(String): String The first would only be needed here; the latter two would be used in SourceMetricsImpl.
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Cannot render banner ad. -> Cannot render interstitial ad. AdMob console -> AdMob UI. Please apply this across all messages.
Are we going to support VARIANT type? As I know We're handling variant as String in schema.
Couldn't this if block move before the other if block? If the data has a size of 1 then the lower index will always be data.size() - 1.
No need for this.
Use emptyList() instead new ArrayList<>()
why do you need to start another processor? The monitor should trigger job model regeneration, shouldn't it?
I think this could use exactRef()
It would be good to check whether the header was defined first.
Also add group.setType(AccountGroup.Type.SYSTEM)
"is handled as if"?
I think we should remove ObjectTriples... Originally, I created it as a Map. Perhaps we can modify ObjectTriplesIterator to TopicIterator that returns a Topic object when .next() is called.
With those 2 lines, you'll instantiate a new FilterInputStream whenever this method is asked. Instead, the generated filtered inputstream must be stored as a field and returned if already existing.
Can you use MediaType.PLAIN_TEXT_UTF_8 instead?
I would have inverted the check but that may be unnecessary
missing the byte order: pcapPacketHeader.order(fByteOrder);
object -> function?
is this even necessary given that we use new URI(...) ?
nit: No need to declare these exception types now that we're calling getMajorVersion directly.
Curly braces in the same line of if statement. Add spaces between variables and operands, such as cursor != null
Shouldn't we add this only in case of async actions? Maybe check if action.isAsync() == true, in addition to jobId != null check.
-1 would be more correct. AFAIC you can skip this.
Let's take this out as the user can already do jwt -> jwt.claim("scope", Arrays.asList(scopes))
I would use stronger wording after the last comma, like "which usually leads to bad query performance." (Additionally, I'm not a native speaker either, but I believe you either need a "that" after "Despite" or use some other word, for example "Although".)
If you add condition hint to card then you can improve card's usability for users. Search for example: * .addHint(new ConditionHint(LudevicNecroAlchemistCondition.instance, "Player other than you lost life this turn"))); How to add: 1. Extract checkTrigger code to Condition object; 2. Use that condition in checkTrigger; 3. Add condition hint to ability. You can use same condition hints in your another PR (#6430).
"Inventory amount" could be extracted as a constant
do we really need this catch block ?
Please add null check for volume.getAsyncTask()
If we'd like to call sendResultToOrigin(operation) when 1) the operation is not from local client, and 2) all sub operations have been complete, then could we change as follows?  try { // L104 if (!operation.waitOperation(TIMEOUT_MS)) { // L106 } else { // L108 if (!operation.isFromLocalClient()) { sendResultToOrigin(operation); } } } catch (final InterruptedException e) { // .. }  I don't think it's a good idea to synchronize a CountdownLatch only for getting the current value, especially when we'd like to check whether the value is 0, which is the terminating condition of await(). What do you think?
Here is another one.
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through here.
Could use return ParameterUtil.toMap(StringUtils.split(processArgs, ","), "="); .. does the same thing.
if (f.isCancelled()) {...} else if (f.error() != null) {...} else {...}
With the requireNonNull, the null check would be redundant... I think...
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Sadly checkstyle isn't as strict as I would like. We could probably do a custom regex for it.
This should return the entity shouldn't it?
@dkayiwa Are there any visits without patients? Should this not fail with an error?
Space between if and (
@tarilabs I usually like to check that the ServiceResponse succeeded before doing any other assertions. It helps to quickly narrow down environment issues when the test suddenly starts failing for no apparent reason.
you can mutialize this code
what if input.length is a multiple of 256? wont this add an extra 256 bytes?
Overdid: "foo" is String already :smile:
We promise the produce json output. Plain string is not valid json.
why do you add the tags to the reportModel and the scenarioModel?
doc
what if WebFaultException caused by absence of permissions to execute this query?..., i'd suggest using runQuery() and analysing return-value instead.
maybe lets use the new name text?
IStateEx or IArgumentEx.
email is still here?
suggestion filtered = StringUtils.replaceEach(input, searchList.toArray(new String[0]), replacementList.toArray(new String[0]));
Why do you fetch the task again?
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
why change the readability status here?
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
why did we use cast here? can we change it to -1L?
One of the need for acceptSession() API was to show user that it can fail. if session does not get accepted they need to do something? Either go to next session or have some code to log message about it.
if the original is missing should we not just add the new copy?
Isn't it enough to mark the RealmChangeListener interface with @Nonnull ? Doing it at every call site seems a bit excessive?
style nit: add a space after if
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
useless
why not instanceof ?
Can be delayed to after the following check, avoids creating the strings unnecessarily.
Shouldn't those line be removed?
checkList ? u mean errors ?
@Oak committers: Would it make sense for SessionContext.getValueFactory() to return ValueFactoryImpl right away, so we don't need the cast? SessionContext always creates a ValueFactoryImpl in its constructor, and AFAICS SessionContext is an internal object that isn't required to stick to the API interfaces (but I might be missing something). Alternatively, we could add a new interface BlobValueFactory that ValueFactoryImpl can implement, and which would provide Binary createBinary(Blob) and String getBlobId(Binary) (used below in getHttpDownloadURL())..
Don't need to call deleteOnExit
Should it be "if (numConnectAttempts >= maxAttempts) { ... }" ?
Rubbish
int mapSize
Are we sure newValue is always non null?
We'd better not fail here and just return null.
assertThat(build.getConsole(), containsString(customWorkspace))
Create the tool section between the layer and the first mapping. Then pass it as parameter of each createXXxMappingYYY method and in those methods, you will have the possibility to create a creation tool correpsonding to each mapping, link it to the mapping and add it to the tool section. ContainerMapping -> ContainerCreationDescirption EdgeMapping -> EdgeCreationDescription NodeMapping -> NodeCreationDescription
Why is it better to use more than one scope to test?
Shouldn't it be logged in debug only?
Let's not send BAD_REQUEST for Remote exception. We can throw a RestAPIException for that, since it will be an internal server error.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
1 -> numInputChannels ?
one-liner
Unless this needs to be protected it should be made private
Consider to use negative condition here, so it will just return false when the super CDA will return false. Also use the formatter on the if condition (add space between the if and the call to super)
suggestion Assert.notEmpty(query.getIds(), "No Ids defined for Query");
formatter
can you also test the case with begin > end?
This is strange. Why would we go to the preference store of the Linux Tools Docker plugin when we are fetching an ID that is defined in CDT? I believe the prefStore should be the one from DockerLaunchUIPlugin, no?
Isn't a LinkedList better if we don't know the size (to reduce reallocations and copies)?
The detach was done because info was retrieved after deletion. I swapped things and retrieved the info before then it went fine
fos can be inside try ()
final
what does -1 signal here? i don't see a good explanation of this in the solr docs
Need to use parameterized logging instead of string concatenation. This should also be a warning and not an error.
Remove extra semicolon.
Good spot! We could actually do this: java authCardDetails.getAddress().map(AddressEntity::new).ifPresent(addressEntity -> { //   });
34 and 36 should be in one line
assertThat(entries).hasSize(3); the same for several occurances below
question: are we forced to use the toString() as serialization? if not, I prefer two methods: serialize() and deserialize(s) instead of asymmetric toString() and getValue(s)
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think we'd want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
Typo #xpected
replace with persistCommandIfNeeded
Is Itemizing (or promoting parts of) request option, to limit to applicable ones?
Extra space again
Do we need String.format here? Seems like String concat would be fine.
ps is not closed. Should be DbUtils.closeQuietly(rs, ps, connection);
Don't put chatcolors into the block data :NotLikeThis:
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
Please do: acitivity.startActivity(CreatePostActivity.newIntent(activity));
Variable naming. Be consistent across the entire codebase. why sc? sock or socket?
error message should be changed to reference actual problem of "not a leap year". See existing implementations.
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue(), "%") which basically does exactly the same.
Why is input generator called modifier??
if(!(o instanceof LegalInformationComplete)) is better, will not break the equals contract in case of inheritance.
No worries... we have all done it a bazillion times. :smile:
same here about this.
These two lines should come before the if. (Remove in the other branch.)
overall the commit is very good, but this method might be misleading - it doesn't set anything if the field belongs to a probe.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
This should be replacable by switch (solverStatus.get()), as all the actual state mutation happens in solvingTerminated()/solver.terminateEarly() as I've suggested above.
since we did not advance so the event is not thrown away really.
@bharatviswa504 can we make some test utility methods for this that hide the detail that table/cache are being updated directly?
Make this an assume
We should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED.
can this be turned into lambda?
They are mutually exclusive? Or is that a micro optimization?
start
A bit a matter of taste but I'd remove the spaces here around the =, it would look more consistent with the "Contents" column, i.e. field=123, foo=345
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
Something like:  if (this == object) { return true; } else if (obj == null || !(obj instanceof RowProcessingStream)) { return false; } else { return Objects.equals(_analysisJob, other._analysisJob && Objects.equals(_table, other._table) }  Seems quite a bit more readable to me.
Is it worth moving the reporting out of the synchronized block (though I wouldn't expect convention on that span)?
This array must be calculated one time only
Use logging instead of e.printStackTrace()
We should guard this with if (mEndTime != null) and in the block, return false if it fails.
please consider instanceOf check?
You can use CollectionUtils.toImmutableList
I think this one can be defined at the time declaration as well. Please make it final.
@bxf12315 same as above, please use assertThat.
Here should be NOT_INCLUDE_DEFAULTS
return new StringBuilder().append()....toString();
use constants.
why not process all files?
You can change the 28 case to a default case, and remove this.
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
{} missing
is this check necessary?
I think we should TRY to move before we update the file path
I don't think this will work if the claim name requested is a standard JWT date field, because that value is required to be in seconds (not millis) since epoch. In other words, if I do:  java claims.get("iat", Date.class);  It should work. In fact, the other get\* methods that return a date should probably delegate to this method so the behavior is guaranteed.
If the store is already started, I think we should return true. Same for stop (return true if the store is already stopped and don't try to stop again)
Use constant
why not set serverCnxnClassCtr to NIOServerCnxn by default to avoid looking up the right constructor every time we want to create a new connection (a bit of a hot path)?
I believe this line can be replaced with DMContexts.getAncestorOfType(ctx, IExecutionDMContext.class)
Suggestion: "--active and --inactive options are mutually exclusive."
Map
need type name
Perhaps we may as well add the sequence number below to this message.
Let's move this line below, just before the requiresFBO line.
formatting
can be static
Should we consider other measurement units, like kg?
There is no need to mock api calls to implement this test.
Do we have only two types of disks? Even if we have, this code will fail when we add another type. I think we should check for LUN type before trying to update one.
This is fine but I would prefer iterators[i++] since that is a much more common style in the code base
It feels to me that there is much code duplication between this and DateTime.truncate
Under some conditions I'm running here into an StackOverflowError: java.lang.StackOverflowError: null at com.google.gwt.user.client.ui.TreeItem.getChildCount(TreeItem.java:371) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:538) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:528) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:310) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) ... One scenario in which I'm getting this error is when I filter for projects having the parent 'parent2' while having the following project structure: -- All Projects -- -> parent1 -> parent2 -> (project1, project2, project3)
This variable is very badly name if it's supposed to be the serializedUserReference.
also these *xx things should be constants.
return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM) if it needs to be modifiable - add new ArrayList<>(...)
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then it will add another *. We shouldn't add the slash if it already ends with *
Please return an empty RepositoryDTO here
It's advisable to start variable names with lower case
@dmzaytsev try to use org.apache.commons.lang3.StringUtils#join() here. It could be more visual
why?
Can you also include the workspace ID in the message? Just in case.
You don't need to set the Id here as it's done in the setup() method (but does no harm and makes the test clearer!)
@tbagz104 i guess you should make the links as a string resource and refer them from the strings.xml file. and please remove the extra spacing present in this file
This class has no superclass, so I'm not sure we need to call super() here.
Please rename this to eObjectMatchEngineFactory or something closer to the real use.
is it possible to use hash here to accommodate the case where gradle cache may have different versions of the same artifact present?
why synchronized?
Extract properties.getRest() into a variable.
better at least add a debug logging here
I would say just Template expressions are deprecated for ExpressionRetryPolicy . We really can't say *literal expressions* since that is going to confuse and users just because there is really a LiteralExpresion to return just plain string all the time. So, we can't say that here to bring end-users in the situation when they may decide that this is trealy going to be only about simple strings.
I don't think this optimization of repacing .equals by '=' is correct. I suspect there are cases with dynamic metamodels where we won't have the same instance of feature on each side of a comparison...
NP: As this is now abstract, it should say "...json data for component ...".
you could do i++ here and remove the line 1886
@xpdavid is this the right thing to do?
This resource needs to be managed and disposed when appropriate. Sometimes we use org.eclipse.jface.resource.LocalResourceManager. It also might be appropriate to change the org.eclipse.e4.ui.internal.css.swt.definition.IColorAndFontProvider interface so that it becomes responsible for managing the resource, if that can be done.
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
@Serranya same here. See above.
Perhaps the '104' could be a constant?
Please rename this layout file as well removing _new_api.
Why not prefer the new one (spec) if it's set?
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
Minor: please move private utility methods to bottom.
You can do BuildTrigger buildTrigger = BuildTrigger.forUser(username.or("unknown"));
I don't think this is the right test... you should do something like if (superclass instanceof ParameterizedType)
You can replace the for loop here with values.forEach(result::add);.
As mentioned above, why don't we making it a non-static method?
velocity..
The error message doesn't match the actual behaviour.
Extract this try-catch block to a method to avoid code duplication
These variable names are pretty confusing to me. @haozhun you have a quick suggestion?
Is this line always safe for NPE?
Use .isEmpty() rather than .size() < 1
Unnecessary else.
action should fail when a problem with post request occurs, so please throw this exceptions
Preconditions.checkArgument() on all non-null arguments to prevent bad config
please decrease log level to trace or better remove statement
what is your opinion about that you convert only the different value and you are using the .name() any other case?
This can be optimized to a simple messages.get() if the underlying Collection is a Set.
We don't really need to create a new deserializer for each request.
I _think_ this is ok - typically for netty applications, you want to avoid blocking the main event loop - but I guess in this case, we want to avoid the acceptor event loop blindly accepting connections when the worker group has to deal with a potentially blocked queue. I wonder if, given that the act of adding an item to a queue in logstash can block, whether the work group would be better in its own thread pool, but I think this should be ok in the short term
Do we need to check which button triggered the event?
Method duplicated
Another null test of the response. I won't mark any others I see below this point, but they should all be fixed.
Can you extract this to a method? There is code duplication here.
baseId +diagram
Nit: would it make sense that this constructor calls the constructor on line 63?
"Couldn't rename [" -> Fail to rename
GitHubSCMNavigator. suggestion NamedArrayList.select(all, Messages.GitHubSCMNavigator_withinRepository(), NamedArrayList.anyOf(NamedArrayList.withAnnotation(Discovery.class),NamedArrayList.withAnnotation(Selection.class)),
I suggest changing "doesn't exist" to "not found" or "nor available" in all these methods.
Seems we have changed to log2, the computation will be accurate but now what is the plan to show all files < 1 MB query? Seems more computation to be done in UI. From the user point of view, 1KB, 2KB, and 4KB is all noise in UI. The 10s of bytes makes it more readable!
The amount of duplicated logic we're amassing is concerning. This is going to be painful from a maintenance standpoint.
Same as above, the for loop would throw a NPE if methods variable becomes null.
Can't we use stream here?
Why do we have to check read scopes when we commit cursor ?
We can throw the exception to client.
suggestion PodTemplateUtilsTest.assertQuantity(PodTemplateBuilder.DEFAULT_JNLP_CONTAINER_CPU_REQUEST, requests.get("cpu")); PodTemplateUtilsTest.assertQuantity(PodTemplateBuilder.DEFAULT_JNLP_CONTAINER_MEMORY_REQUEST, requests.get("memory"));
Can you please convert this to throw specific exceptions instead of PerunException ? Thank you.
don't you want to add a/b?
@Override
double check that the group is still here
I'm assuming we can't use something from Joda because there are sometimes stupid dates? otherwise ISODateTimeFormat.basicDate() should work.
break is missed. If smth illegal is found - we should stop search/matching quickly. Please update all other cases below.
did you want to remove this throws IOException as well?
Why is this not based on context.getCurrentUser()?
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
I think the granularity should be 1 seconds instead of 5 seconds here.
"error".equalsIgnoreCase(...)
Could you please change the name to indicate it is responsible for startpoint registration? "StartpointVisitor" can be anything that needs to act on a Startpoint, so just using KafkaStartpointVisitor isn't specific enough.
we just log, update metric and move ahead with next iteration?
As with others, I would not assert on the return value of the operation
Removing test because you can not fix it is usually bad idea
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
getSourceVmFromDb can return null..
Unsigned types are not used in the current implementation. So, you can omit them.
add principal name to message?
This assert statement is always true. Not needed here. Rest code changes LGTM.
I am not familiar with the script cache stuff, but this will delazify the cache contents and hold it all into memory. Is this okay?
I don't like that we must first call "getSelectedFile" and then additionaly "confirmFileSave". Could we have a method that merges the logic of the two above? It could be named "getFileWithConfirmation".
Once we have a pre-inited EnumMap we can do away with this null check.
It's not necessarily a build script - only if the resource is a file.
@mykelalvis please, rename to server. s is meaningless :)
monitoringId will be null if split fails
Why are we getting BigtableClusterName and BigtableInstanceName from two different places? Are they V1 and V2 names? If both are V2 name we can get InstanceName from ClusterName.
can you add metrics to this?
same, would inline here and extract a common method with just the Activity class that you want to start, two lines of code.
I'd extract this into a method isUnset(Diff) as well. Don't we have util methods for determining whether it is an unset? They seem to be very generic and maybe should go there, if we haven't them yet.
I would prefer not having to deal with string parsing. What do you think about the approach we use for Neo4j? We use a Neo4jParameter class and check if this is an instance for it. This actually connect to what I suggested before and we could keep the code consistent between the two dialects.
'map' name may be problematic. e.g. following line results in an error : a = load 'a.txt' as (map : [chararray]);
please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method if there is too much condition
What is the purpose of this logic? From the xml file I can tell that the 0210 thing has this channel, so why do you have this check and addition logic here?
This seems like it should handle the exceptionsl ike the RuntimeException block from above. Why make the distinction here?
Did this convert it to a Callable or a Runnable? I believe this is why it wasn't inlined before.
TransportException is not just a wrapper for other exceptions, so where it is thrown and it's (sub)class is important, just pass it as the new cause.
You're not passing in the message even though you have a marker there. Think that might throw weird RTEs.
rename to key
If someone calls offset.reset() (topN does this sometimes) then this will be wrong. I think you need some logic to detect the offset going backwards, and resetting the iterator in that case.
Use TreeMap to keep the order.
why not initialize this in the constructor (and only set the herder in the Worker#start() via a setter method in connectorStatusMetricsGroup)?
You also need to update the text of the menu button here.
You can remove the surrounding brackets.
why return a candidate if it is not a factory for an object or an eObject ?
why use ellipsis?
Why are you suppressing exception here? Let the runtime exception bubble up. This is changing the behavior of the wrapped processor.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Same thing, using this method here may cause the getLinePixel method to return erroneous result, which may cause regressions in customers (I think code minings actually use this method extensively to compute where to draw for instance)
It seems there is some compilation error here. Or some pending change in AQL ?
I this refactoring, very nice. Could make this method protected.
getBigtableWriteThrottleMs() returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableWriteThrottleMs() ValueProvider into a "true" or "false" for the google.bigtable.buffered.mutator.throttling.enable value
The first message will show 0 / 5. Should we set the currentRetries to 1? For the message, we should log something useful for the user to know what it is happening. Can I suggest you this message: - Attempting to acquire the DB log notification lock: 3 out of 5 retries
Could above if/else be replaced by  java return modelId != null ? modelId.toString() : null;
Probably we should log the exception here (debug or trace), just to help with troubleshooting
bridgeUID is the only property which is interesting from the bridge handler here. I suggest only giving this ThingUID in the constructor.
Be careful. This is not a preference but an option in a dialog.
You're better off pokemon-catching these.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
suggestion Path relativePath = Paths.get(referencePointPath).relativize(Paths.get(filePath));
the default should be made a constant somewhere instead of being defined in multiple places
This null check should only be applied to the loadProfileImage() call. The profileImage variable should be assigned regardless, as the whole point of it is to store the image for when the view is initialized.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
"due to".
Is there a functional change here, it seems like we lose the error message of failing to close the block reader?
This line will always evaluate to false as we are comparing ExitCode with String?
typo in DATAPAAKCAGE
Would this timing logging be better within PageCacheWarmer#reheat? PageCacheWarmerKernelExtension is the only other place to call this and contains identical logging logic, with a different instance of Monitor.
Integer.SIZE here as well
suggestion Path relativePath = Paths.get(referencePointPath).relativize(Paths.get(filePath));
change variable to something more meaningful
Extract -> Extracts
Remove.
break the line
Since the near-duplicate indices level is now configurable, can 2 be changed to indexChecker.getWarningMismatches()?
what is adding items into the cache?
Browser.CHROME
Would it be the same to say lemmasList.addAll(keyValues) here?
reset compensation?
I am wondering should we use a ConcurrentLinkedQueue here instead? It is a collection that provides duplicates but in a non blocking fashion.
nit: instead of the boolean here, would be better to use an enum (would make the test clearer) or two methods runSslConnectionTestWithoutClientAuth, etc.
I would be more defensive here. I would check if the num of containers returned by getContainers() is > 0 and if the value returned by getImage() is nullOrEmpty
Never handle exceptions like that. If you can't handle it, request user help, or rethrow it, thel log it via plugin activator.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
One more times(1).
I think illegalKeys is better than illegalKeyValues.
Please remove BaseAsyncTask::AddOrUpdateTaskInDB:
We need to enforce TCP connect timeout and read timeout, apply reasonable defaults, and make the timeouts configurable.
Can you use a more relevant variable name?
No, This is not right place to dismiss the dialog, do it <LINK_0>
we can create lazy iterator here instead of collecting updates into array list and pass that iterator into apply, so we can avoid one top additional for loop
What you think to change to assertThat(validation.getErrors(), empty())? It's more readeable, sounds like "assert that validation.getErrors is empty". empty() is a static import from org.hamcrest.Matchers. If the assert fails, hamcrest matchers have a more pretty message than assertTrue from JUnit, that don't show any message.
obsolete when naming loopvar 'console'
can we move getMethodOn().getWorkflowGroupForRole(UUID.fromString(halResource.getContent().getUuid()) outside the for to optimize a bit the code execution?
This is a little hack for me. Could we avoid these kind of hacks?
i don't think they are all supposed to be uppercase. in fact, i think in the wiki the acceptable values are: -beta -alpha -RC -RC2 - same as the three above but with a version appended
1. Change Exception to exact exception you get 2. throw the exception after log or don't catch it here
a piece of thought for discussions: in the loop above (line 1018-1021), should we put the node id of ALL running attempts here into unhealthy nodes (instead of just the earliest attempt)? since by the time we got here, a redundant attempt was deemed necessary, that must be suggesting all the unfinished(running) attempts for this task are potentially problematic/long-tailed.
Log in logger, not just print in console.
Possible candidate for bind() if that method is created.
Suggestion: Use an else-if for these two and provide the missing braces. And instead of length() == 0 I'd use isEmpty().
There is no need to create an odd variable
suggestion throw new IOException(MESSAGE, (Exception) DummyClassLoader.apply(TestCallable.class));
What happens here when mergeOldAndNewHistory() returns null. Looks like it will fail in writeHistoryToFile() later.
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
Can we move this above cGroupsCpuResourceHandler.prestart()?
"Entity" + id
This noneMatch(notVisited) seems rather convoluted for no practical reason : wouldn't a Collections.disjoint be enough in our case ? and/or maybe Guava Sets.intersection (maybe applicable to sets only) ? Ideally encapsulated in a "visitedAllParents" method ?
Is this still needed if the value gets overwritten in the next line?
Using stringbuilder and then a + op is pretentious ;)
Does {this} instead of the name of the card not work in this case?
Try something like this  private Set<ID> toSet(Iterable<ID> ids) { if (ids instanceof Set) return (Set<ID>)ids; Iterator<ID> itr = ids.iterator(); if (!itr.hasNext()) return emptySet(); ID key = itr.next(); Set<ID> keys = key instanceof Comparable ? new TreeSet<>() : new HashSet<>(); keys.add(key); while (itr.hasNext()) { key = itr.next(); keys.add(key); } return keys; }
Like above, using the absolute path should accomplish this properly
A method similar to this but with first parameter Connection<T> would be more convenient for use in CPPSemantics. Such method could be moved to /org.eclipse.cdt.core/parser/org/eclipse/cdt/core/parser/util/CollectionUtils.java
I can see why this is necessary, with the change a few lines above from 'indexOf(".")' to 'lastIndexOf(".")'. However, there are two things I don't like about it: * what about, say, "model.profile.profile.di" ? (granted, unlikely, but handled by the previous version of this code) * more seriously, this hard-codes an extension that is defined in a <diagramCategory> contributed by some plug-in on the org.eclipse.papyrus.infra.core.papyrusDiagram extension point. Other plug-ins can define additional extensions that aren't enumerated, here. Rather than hard-coding this, we should look up the extensions that need to be trimmed off in the DiagramCategoryRegistry
suggestion LOGGER.trace("The service with name [{}] is not found in the cache, try to find it from [{}]",
LZ4FastDecompressor requires the size of the uncompressed data as the last argument to decompress, vs. LZ4SafeDecompressor requires the maximum size of the output as the last argument, so we should only use lz4Fast if we know the size of the uncompressed data, which is not the case in this method.
This is inherently dangerous. sharedList is a CopyOnWriteArrayList which is _safe for iteration_ even while it is modified. However, once you abandon the iterator, it is possible for the sharedList size to decrease while you are in the loop, and sharedList.get(i) will generate an ArrayIndexOutOfBounds exception.
squigglies ftw
can we put this line just after line 119 -- nc = (NameCallback) callback; ? then we can remove this if statement. Also we can remove line 115 to 117 I think. if (callback instanceof RealmChoiceCallback) { continue; }
It would be nice to create constants for these props in AccumuloProps class.
I think this call to byteArrayOutputStream.toByteArray() can still blow up memory. I would recommend using guava's [FileBackedOutputStream](<LINK_0>, and calling .toByteSource().openStream().  private void writeMetacardToZip(ZipOutputStream zipOutputStream, Metacard metacard) { InputStream inputStream = null; try (FileBackedOutputStream fileBackedOutputStream = new FileBackedOutputStream(THRESHOLD); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileBackedOutputStream)) { ZipEntry zipEntry = new ZipEntry(METACARD_PATH + metacard.getId()); zipOutputStream.putNextEntry(zipEntry); objectOutputStream.writeObject(new MetacardImpl(metacard)); inputStream = fileBackedOutputStream.asByteSource().openStream(); IOUtils.copy(inputStream, zipOutputStream); } catch (IOException e) { LOGGER.debug("Failed to add metacard with id {}.", metacard.getId(), e); } finally { try { inputStream.close(); } catch (IOException | NullPointerException ignore) { } } }
Coding best practices: Interface i = new Implementation();
maybe it would be more readable of you had isEqualFilter(PlanNode node) method which would do all the checks but not on a single line?
@maria-farooq we should provide a description to the log message
Single pass is needed here.
I think for contacts it would be better to use Number: instead of Id:. Otherwise it looks good!
PerunClient is valid only for OAUTH2 clients. Otherwise its half empty object, especially client ID is not present. I would prefer logging whole PerunSession, but I understand, that this message should be rather short. But neither PerunSession or PerunPrincipal within it have a short toString(). Please add method in PerunSession like: getLogId() which will return value of actor property, so we will see user identity. If it won't be sufficient in a future, we can safely change such method to return also extSourceName or other properties. Thank you.
I'm really sorry for your work, but in my opinion a simple TextInputDialog should be sufficient (instead of a custom dialog): <LINK_0>
If you ever make this public this _ will break the JavaBeans specification.
So this throws a new exception? Where does this exception end up going? I think this will convert an UnknownTokenException to a runtime IllegalArgumentException and so this will cause weird failures up the stack?
f.isFile() is better since it checks if .project isn't a directory accidentally.
Isn't this problematic, since the byte-array may not be a string, and it may not even be decodeable as a string, so this could throw.
you fetch vdsDao.getAllForCluster(getClusterId()) and then fetch it again in runAnsibleReconfigureGluster() (line 304) you can save it to a local variable and save the second call. Also, it seems that you rely on host 1 and host 2, therefore you can just pass them to the method runAnsibleReconfigureGluster(firstGlusterClusterNode, secondGlusterClusterNode)
Not really.
this will go to the char after '[', is that OK?
Since Rx is optional, would be great if you add a check, I've added this in Hawk.java but that can be moved to utils and used here as well.  java private static void checkRx() { if (!Utils.hasRxJavaOnClasspath()) { throw new NoClassDefFoundError("RxJava is not on classpath, " + "make sure that you have it in your dependencies"); } }
remove this..i already have a pr with the fix
MaybegetOrFetchToken if the csrf token has been already loaded?
I think get was more approriate here
Sorry, but I don't think this is right: IMO the new eventually calls should be exactly where the sleepThread calls were
No LOG
Could you rename DirectDebitConnectorCreatePaymentResponse to remove "Create" as it's now used for both create and get
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
NullHandling.defaultDoubleValue()
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
final is unnecessary here
Could you please add clear message for case when assert failed?
Any value in:  int start = getInitialStub().isPresent() ? 1 : 0; int end = periods.size() - (getFinalStub().isPresent() ? 1 : 0); return periods.subList(start, end);  If necessary, you could check if start and end were zero but would be surprised if there was much perf impact from not doing so.
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
use Arrays.fill instead for loops
You need to also store the lastStartTime: long lastStartTime = prevFullState == null ? -1 : prevFullState.get(statusQuark).getStartTime(); Also, lastEndTime can change for the same attribute while it's being build and below...
Should it be ColumnIndexType.DICTIONARY?
not really needed for test. just keep it simple
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below the line 187 and remove this check.
Here, size is the number of currencies.
Why not initialize them at construction time instead of lazily on request?
just use context as synch obj
It would be slightly better to check that project is opened first instead of letting it throw CoreException in hasNature().
From big height the fix looks reasonable for me. But does it work really against real Broker? I'm just curious if that CustomExchange is robust. But, yeah, thank you @panchenko for the effort to support community and improve the Framework!
FIXME: Don't cast getActivity(), use an interface.
I see a default value for version in PartitionLayout but not here. Is this on purpose?
@tmjee the same
return (this.sslContextDependency != null) ? this.sslContextDependency.register(builder) : builder; :)
There is already a method called getProperty() in same class. You just need to do getValue on that. We don't need a whole new method for that. However do the improvements in this method to the old method itself.
The existing return output.repeat(2, (long) getN()); should be replaced by:  try(MemoryWorkspace ws = workspaceMgr.notifyScopeBorrowed(ArrayType.ACTIVATIONS)) { return output.repeat(2, (long) getN()); }  We don't want this to be detached instead.
This part is mostly duplicated with part of the isLoading block. The duplication can probably be removed by restructuring the code a little.
Why is this change necessary?
When assumption fails it emits an exception that is ignored by the runner (effectively, later part of this test method is not executed)?
Could you please replace event.getTarget with a variable to make it clearer
Can we reword the error message for recovery?
Avoid hard coding the path, use Environment.getExternalStorageDirectory() and the local path as a string resource.
list could be edited by other threads therefore it is not thread save maybe make a copy before iterating?
The true parameter causes the contents to be appended to the end of the file, instead of re-creating the file with the new data. This can simply be new FileOutputStream(file, true), which defaults to false.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Would it be possible to retrieve only message keys? Not sure if that is possible here
Does HQL have an "EXISTS"? If so, using EXISTS rather than IN may produce a faster query, and you will not need the DISTINCT fi.ingestion.
@tumijacob Rather invert this logic and throw if the user is null. You can then remove the else block and indent the remaining code one level less.
need to pass Locale.ENGLISH here don't you?
Agreed, makes sense to me.
We don't need the AccessController.doPrivileged call anymore because this is now done inside of ReflectionUtils.accessMember. Just ReflectionUtils.accessMember(initMethod, () -> initMethod.invoke(viewModel), "mvvmFX wasn't able to call the initialize method of ViewModel [" + viewModel + "]."); should work.
Is it necessary to call this again?
This is probably not the right example. This specific problem goes away when you use the Right R class here. Can you modify this change to repro your case i.e have another module refer to the resource in its main code and this module invokes that piece of code in it's test?
Is order important here? Should the 2 collections correlate each to another?
should be singular, VTIDSection. It's not like in French (ex. un magasin de souliers vs a shoe store).
I would rename the original createAuthConfig() to a private method with a distinguished name to clarify that this should be the single entry point.
Will it not be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded ?
You can create mock mannually with SelfReturningAnswer instead of this code. To wit jsonRequest = mock(HttpJsonRequest.class, new SelfReturningAnswer()); P.S. SelfReturningAnswer is from org.eclipse.che.core:che-core-commons-test
I think we should TRY to move before we update the file path
@inverno We have 2 times "Second argument" :)
Maybe we could also add _seq_no or so to the RETURNING clause here. As that is one of the use cases we want to enable
TimeUnit is easier to read than the SystemTime constants: timeToLive = SystemTime.getInstance().milliseconds() + TimeUnit.HOURS.toMillis(1); I had to read your code twice to pin down that TTL is creationTime + one hour. With TimeUnit, its one read to understand.
set to 'null' and create a default in AbstractObjectConfigurationProvider
Casting to MenuItem is redundant here
Leave out this line, the processException will already log it.
I think It's needed to convert to milliseconds.
@cuenyad use factor variable
Check: <LINK_0>
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the command.
final IPath pathString = Path.fromOSString(path); is needed and pathString needs to be passed to the createLink() method below. That's why the Unit test fails.
Interesting. Since we're guarding for null here, it might also make sense to log this in case it is null. Wdyt?
ERR_DELETE_ERROR, add if there isn't one already
Not required
style-nit: remove curly brackets around single line block
What about new File(internalFileDir, fileName.name()).getAbsolutePath()? I think we should not create paths by concatenating strings
This would probably work 90% of the time, but the value that should be tested against the current value is the response from 'asMessage(text,args).
use translateText
Not necessary. The web plugin should be bound in the Gerrit-HttpModule.
It seems this log is for your debugging. Do we want to remove it then?
The reason why ReachabilityChecker supports reusing an existing RevWalk (instead of maintaining our own), presumably, is so that we can save on object parsing. So I think it's less flexible if we set this here - the caller should be setting it if they know that they want it.
method.getMethod() is already clear. You don't need to extract this method. Please get back to method.getMethod()
is this really necessary? you destroy the activity anyway.
You can make this method more functional if you want :)  java return Arrays.stream(services).flatMap(service -> { Collection<Class<?>> serviceInterfaces = serviceProcessor.extractServiceInterfaces(service); return serviceInterfaces.stream().map(serviceProcessor::introspectServiceInterface); }).collect(Collectors.toMap(ServiceDefinition::serviceName,def -> "service"));
it's duplicated by convertSampleListToTreeNode
Does the segment delete need upgraded locks?
Never swallow exceptions without at least logging them. In this case: Why not throw them?
i think you could use only the timezone variable, set it inside the if here, and nothing to do in the else
on the catch, let's add a servere logger
I think we should prefer a setter here rather than member variable access.
It would be good to verify that each export dir contains a disjoint set of file names. This may be a good place to do this check. If the check is not done and someone make mistake it seems like it could lead to multiple entries for same file, but I am not sure.
ignore if you'd like: Bookmark bookmark = getModel().getSelectedObjects().isEmpty() ? null : getModel().getSelectedObjects().get(0); BookmarkModelProvider.this.getModel().setSelectedItem(bookmark);
- Use isNotBlank() better? - Long? for sure integer is enough. - Check safely if it is a number?
Missing opening "(" before getDescription().
Keep this static imported?
Better to write unit tests for these conditions
endIndex
Again, don't clone a new event. In the new code change, the "else" will only be executed in very very small time windows. You have proved that when the sender is shutdown, the eventProcessor will be kept. So enqueue will not go to the "else". We will never worry about the tmpDroppedEvents become too big.
It's always a single item collection. Why not add another one even though our current implementation layer does not support it.
Perhaps also desirable to call track(Node, Credentials). (For BindingStep, just inject a Node; for SecretBuildWrapper, use the method on AbstractBuild IIRC.) @stephenc any guidance?
dont do this but let the exception be propagated back up so we can have a better error reporting about not possible to generate jacoco report due to .... Also these methods can be static methods
Note that I asked one of the authors of the "one sql to rule them all" paper. The only reason that they use wstart and wend was because of the layout for a paper. I got suggestion to use window_start and window_end. I also believe in a JIRA or an email (sorry I cannot recall which one it is) we agreed to switch to window_start and window_end. So I will suggest we keep window_start and window_end, which can be understood easier than wstart/wend.
not necesary
It might be better to use Collections.emptyMap() instead of new HashMap()
Sad times, but I don't think we can easily work around this.
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
Can use Optional to avoid null checks!
Nit: this is duplicated at line 48, I would get rid of this line.
Use type.getObjectValue to print the indeterminate in the error message to help user debugging: java throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "map key cannot be indeterminate: " + mapType.getvalueType.getObjectValue(session, keyBlock, i));
There seems to be a convention established to update these metrics. For e.g. replicationMetrics.updateMetadataRequestTime(metadataRequestTime, isRemoteColo, isSSLEnabled, remoteDatacenterName); Is it possible to follow the same kind of convention here (updating via a function)?
Maybe mix multiple timezones? The idea really is to trigger a failure, so let's not make it easy for tests to pass... In particular, I would use local date/times that are not ordered, but become ordered when you take into account the time zones.
This introduces a bug: since there are two possible SegmentWithOvershadowedStatus for each underlying DataSegment, now the same segment can be in publishedSegments twice for a period of time. There's a few ways to deal with this: 1. Make publishedSegments a TreeSet<SegmentWithOvershadowedStatus> and update the entire map atomically. This is a super clean solution but would burst to higher memory usage (it would need to keep two entire copies of the map in memory when replacing them). 2. Make publishedSegments a ConcurrentSkipListMap<DataSegment, CachedSegmentInfo> where CachedSegmentInfo is some static class, defined in this file, containing the updated timestamp and the overshadowed boolean. If you do this, the SegmentWithOvershadowedStatus won't be stored long term anymore. You could minimize memory footprint of CachedSegmentInfo, if you want, by making the timestamp a long rather than DateTime. 3. Make publishedSegments a ConcurrentSkipListSet<SegmentWithOvershadowedStatus>, make SegmentWithOvershadowedStatus mutable (in a thread-safe way), make its equals, hashCode, and compareTo methods only based on the dataSegment field, let its overshadowed field be modified, and add a timestamp field to it. When syncing the cache, get the current object and mutate the overshadowed field if necessary. Btw, a ConcurrentSkipListSet uses a ConcurrentSkipListMap under the hood, so the memory footprint savings of this aren't as much as you might expect relative to (2). (2) is the variant that's closest to what the code was doing before this patch. One thing I don't love about it is that it is racey: it means that if a set of segments is overshadowed all at once, callers will not necessarily see a consistent view, because the map is being concurrently updated. They'll see the overshadowed flag get set for the underlying segments one at a time. But the same problem existed in the old code, so fixing it could be considered out of scope for this patch.
Is it a conscious decision to throw an unchecked here?
It's java.util.Objects.equals(dims, that.dims)
why if is here?
Don't use addFileUrls, just add to your urlList
Minor: tweak the spacing here? i = 0; i < 5; i++
not even e.getMessage() ?
String concatenation here as well ?
It would be better to strictly align these variable names with the method names. Since there are methods of both Resource and ResourceInfo, I would suggest to also include the class name. E.g., - resourceSetResourceInformationMethod - resourceInformationGetNameMethod
I would rename it to something like migrateLegacyPreferences to make it more clear what it actually does.
create a method called getOrCreateContext() and use that
well, the probability is very low, I know, but shouldn't be >= ? in terms of readability I would prefer to have if (fetchTime.compareTo(vmManager.getLastUpdateDate()) > 0){... } else {.. } - but that's subjective I guess, so for your consideration
So you have default settingsfor userId and NetworkAccessPointId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
The check item.getUrl() != null is not needed.
On line 133: partitionSession = getPartitionSession(subscriptionId, eventType.getTopic(), cursor); you take topic from event type. I think it does not make much sense.
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
does this mean that we won't try to flush the last session counts when the application shuts down?
looping with a char is kind of weird?
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
I have a strong negative reaction to assignments within conditionals. * They are surprising and therefore liable to be overlooked or misinterpreted, especially given that "=" is a mathematical symbol for equality. * They are hard to reason about. Please rewrite this code to avoid assignments within conditionals.
Please kill this empty line.
nit: it would be more efficient to keep a local variable with the count, and update the meter at the end. i don't have a great sense for how expensive that getMeter call is, but i assume it has to access a couple maps
Isn't this going to throw even if one of the ids is bad? Do you want to change that to continue processing valid blob ids?
Do we really want to catch Throwable here? How about ClassNotFoundException?
maybe, it would be better to inline that actual following way:  java Matchers.containsString( new StringBuilder() .append("<a>") .append(System.lineSeparator()) .append("<b/>") .append(System.lineSeparator()) .append("</a>") .toString() );  what do you think?
The purpose of this test is to throw inside the onError block. I don't understand why you removed the IAE
Strings.isNullOrEmpty can simplify the code.
> When we do have an error though (please see the Travis log or pull it locally) or a simplification (e.g. the Character constructor), we should definitely take advantage of Java 9's wisdom. true
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
What would the previous code have returned?
Have String headerKey = key.toLowerCase(Locale.US) only once to avoid repeated case conversion.
@xpdavid is this the right thing to do?
This is completely redundant as the Listener which calls this method already checks if it is cancelled. Also missing brackets.
that's invalid anyway, isn't it? what's the meaning of CLUSTER_DEFAULT on cluster, you can never set it. autodetect==null, and then only concrete values are allowed
please also replace UserAgentContainer.AZSDK_USERAGENT_PREFIX with hard coded value for the test
getMethod(methodName) can throw a SecurityException as well.
is /./ necessary?
code dup. would be better to move it to private saveInternal()
Mmmh, I'm not sure to follow you here. What is bothering me is having two times the same message on the same tree (so a duplicate of Location). So why considering the kind of the tree and only the message value? It's probably way simpler to rely on equality of locations to filter out, with a LinkedHashSet for instance.
I think you meant LOGGER.debug("Initialized debug logging"); ?
Hmm. do we log tags? Probably a good idea but C Git doesn't.
suggestion if (isZipFile(Files.getFileExtension(filename))) {
we set Logout only if a displayable id is present? What about ADFS?
EditedStyleItem item = (value instanceof EditedStyleItem) ? (EditedStyleItem) value : null;
is logics correct here?
viewName and viewIndex don't seem to be used in the tests below - probably testGetSourceTableName_index() and testGetSourceTableName_viewIndex() ought to use these instead of tableName. If not, consider removing them.
only if name changes?
Not relevant for this PR, but I'm curious: why is the TrustAllX509TrustManager necessary?
Redundant replicationSpec.isInReplicationScope().
Should we log a warning or throw an exception in the else of this if? I don't think we want to just quietly ignore a put call...
Above three lines are duplicated.
The empty string in the constructor is redundant.
Instead of getting the matrix every time you update it, build the matrix entry-by-entry and *then* put it.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
do we even need to report this given there is a whoAmI which reports this in a much nicer way (and most users won't check the headers, and most scripts can't take any action)
Mid return may worsen readability
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs)
why use domain id from parameters and not from storage object from method parameter?
Do we need any tests for the changes in this plugin info builder and others?
This change looks unrelated to fluids? Seems like it belongs on a separate PR ;P
is this ok? Shouldn't we return null / empty string here?
rename to sash
I would rather have the toolchest stay in control of the merge operation, it seems odd that some merge operations would be defined within the toolchest, and others outside of it.
You may want to use assertEquals directly?
please remove.
I'd consider writing a helper like this to remove boilerplate:  private <T> List<T> nullToEmpty(List<T> list) { if (list == null) { return Collections.emptyList(); } else { return new ArrayList<>(list); } }  and then call it in constructor like this.mavenOuput = nullToEmpty(mavenOutput);
debug/trace/remove?
It isn't clear to me where this user is created?
I think we should TRY to move before we update the file path
The last ask about using ZERO_ constants was particularly about makeObjectColumnSelector() methods, because they return Object. This method returns primitive so the change here is pointless (and in some other places in this commit)
This cannot be removed. The scheduled task needs to be saved.
Could you please add curly braces?
One of 2 things should occur here: - Opt A) throw the exception ( add it to method signature ); not the generic Exception, but the IOException one - Opt B) set file to null, so it ends up getting returned as a null object, rather than a corrupted one If none of the above occur, and in a scenario where some exception takes please, the person leveraging this method would never know of it, and rely that the returned File object is a solid one.
I think this might lead to unused space on the right, when one of the columns has a higher preferred width than it's maximum (because you don't redistribute the difference among the other columns).
Is this idempotent? PUT should be idempotent. What happens when we call failQuery for a query that's already failed?
you don't really need to get explicit index tx state twice
This method need not be static
this should be outside the loop? Otherwise it will only check for the first brick in the list
Name it folder, or reuse doc maybe? domain is misleading.
What about extracting this block of code into a private method? Ideally, public methods should be like pseudocode (no conditionals, fors, etc.).
Hard-coded. What if we add another format in the future?
Don't add a rollback handler, override rollbackRuntime, which is called by the RollbackHandler added by the superclass.
You should be able to pull the conflict overrides directly without needing to rebuild from the string array. If that's not working, there's a problem in the new serializer paths that we need to address. Ideally the following line should work: ConflictOverrides overrides = args.getAs(CONFLICT_OVERRIDES, ConflictOverrides.class) If so, the setter above should also change accordingly.
If you don't return here, this will run only after current repl dump execution? What is the order of execution in the current case?
This should probably be an error since it is fatal and that way it will be seen by apprunner
Since it is major websocket endpoint it should be logged as error
You omitted that blank after the == on purpose, right? ;) But without jokes, that means one cannot retrieve a node entity without explicit @NodeEntity.
Shouldn't you add the colums disposition, disposition_type and disposition_log_guid?
I think we should also display the involved branches/commits which the user tried to merge (in the same way we do that for a plain merge operation failing due to merge conflicts)
Isn't the devfile detached from the JPA session when it leaves this method anyway? Why do we need to create a copy of it?
make this one final maybe? there should never be a reason to override this
Not directly related to this PR. But at some point, we need to update <LINK_3> <LINK_0> They say " It is the average amount of time it took for ack or fail to be called". But the latency is only calculated on ack not on fail. The original code <LINK_1> is implemented the same. I believe this is a mistake introduced in <LINK_2>
Should be updated to use getSupportActionBar() instead of getActionBar() as in the [guidelines](<LINK_0> to ensure backwards compatibility.
Start message from capital letter.
is 404 not valid anymore?
sgtm
hardcoded value. Can you move this to a constant or get it some other way?
you have the batch service already as a class attribute
Is this expected to be just single udnerscore? Bbecause other chars are replaced by double underscore..
System.clearProperty can be used instead.
I think this would be clearer though more verbose:  final Schema inputSchema = getChild().getSchema(); final Schema groupingSchema = inputSchema.getSubSchema(gfields); Schema aggSchema = Schema.EMPTY_SCHEMA; for (final AggregatorFactory factory : factories) { aggSchema = Schema.merge(aggSchema, factory.generateSchema(inputSchema)); } return Schema.merge(groupingSchema, aggSchema);
Can you add a call to "DataCacheFactory.getCache().getCacheManager().clearAll()" as well? In the default configuration it will clear the same cache as the "report-dataset-cache", but if an OEM replaces the DataCache-implementation, we will cover their implementation too.
I think this line is too long. Did you apply the formatting rules?
I am assuming nestedActivity is already defined elsewhere in the project
Please consider adding the following Preconditions.checkArgument checks: * alias is not blank * cert is not blank * privateKey is not blank
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
nit: rename to runner?
Can you add the user to the logParameters as well please (there is a .user(String email) on the log builder so no need to do addParameter. Can you do this in all places where you added the new field (all places where it's already logging something)
suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {
rename to child or childElement
StringBuffer is so 1900-ish. and adding the ", " is I think cleaner if you add it conditionally
You can highly improve the performance of this line by calling the Vm.isCreated() method. Check issue #188 for details. suggestion if(broker0.equals(vm.getBroker()) && vm.isCreated()) {
You can use Collections.singleton.
lock user_point
Can you do a more precise check? Comparing the string with exactly what you expect? You should check a specific blob as well, not just the first one (not sure you'll have a deterministic order).
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like:  if(!AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(user)) && !AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(specificUser))) { .. }
This should return a command exception.
It would be better if we would show the user some message as toast as well!
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessorRegistry().getQuickAssistProcessors(...))
Instead of hardcoding path, can you check if Files.createTempDirectory() works?
Other places in MISO use owner to refer to a user, but it's used here to refer to the associated QC-able thing. What do you think about changing the field name on the DTO from owner to entity to match the QC model?
final
typo: you have two "f"s To avoid such typos, please copy from the config directly. These are quite hard to catch and we are not always looking for them.
We should add local vars for position.getX/Y() and entityPosition.getX/Y() to make this a bit easier to read
ImmutableMap.of()
Remove this?
make all local vars final if possible
Can you explain what problem this is solving? The jira does not tel much about leases.
printing contextId in the message will be helpful for debugging.
This can be replaced by StringUtil:isNotBlank
Let's swap to use Guava Hashing instead of DigestUtils.
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
Extra new line.
Nit: Just printing the additional paths should suffice, just so the information does not get drowned.
Can we just do ByteBuffer.wrap(b, off, len) and save one more copy?
Can't we do that in the EnvironementInitializationFilter to avoid adding this top all the sites?
The interceptors must not try to access the TM transaction via the thread-local, only via the invocation context. So it's safe to suspend the TM transaction before calling invokeAsync.
From the code of extractValue(), it could also be Memory.
Fully-qualified class name not needed.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
missing final
I don't get how what is replaced maps to a checkAndMutate instance? There is no matching in previous impl?
Hmmm this test depends on the ResponseStatusFromPayloadHttpCommandExecutorService fixing the response code. Even if the _real_ provider returns a 500, I'd just configure a 404 response to make sure the API works, without coupling it to that class. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status is properly fixed and that should be enough.
Lets use VectorUtils.of(...).
Start with a Capital letter. This is missing in all the other calls to receiveError too. We should look into a uniform way of handling Service exceptions. Because in the case where the app is closed, we cannot show toasts. Maybe store errors and show them on the next app startup ?
According to the docs[0], this should be called from onCreate()... But how are you supposed to get the MapView before onCreateView()? [0] "You must call this method from the parent's Activity.onCreate(Bundle) or Fragment.onCreate(Bundle)." <LINK_0>
Maybe consider using guava here? int[] shape = Ints.toArray(dimensions);
final missing
This will fail if the key is an empty string.
extra line
In all cases of this pattern, we're throwing away the NotFoundException. It would be better if we could pass it as the "cause" argument when we eventually construct the RestClientException object.
Small point that I think this should be >=. There could be a situation where the old resource and new resource have the same version and the old resource is on the way out. In that case the signal that this current resource is installed (because it is being initialized, which only happens to installed resources) should imply that this resource is valid, so with no other information about the installed resource we should presume that it may not be.
We don't need this, the ConfigSaved would handle this already.
Check methods do not return boolean. As we are using them, they always end with or without error without any returned output.
Another lambda-ing opportunity:  source_.withSaveFilesBeforeCommand(() -> { server_.startBuild(type, subType, new SimpleRequestCallback<Boolean>() { @Override public void onResponseReceived(Boolean response) { } @Override public void onError(ServerError error) { super.onError(error); workbenchContext_.setBuildInProgress(false); } }); }, () -> {}, "Build");
it should use integer parameter instead of true i think
suggestion
OOC, in what ways does findSpecial differ from unreflectSpecial? are the two functionally equivalent (ignoring the JDK bugs), except one stards with reflect data (Method) and the other with a signature (MethodType)? if so, is it worthwhile simplifying this to _just_ use findSpecial? also: does this change have any impact on the calculus of who has access? if the types (args or return) are private, package-private or protected, will unreflectSpecial|findSpecial fail whereas the reflected approach would have succeeded, because we explicitly set the modes to all access levels?
I think we should consider the case sensitivity here.
cannot convert to double value, same reason
Please use "something <operator> null" convention
Could lines 154 - 170 be checked once outside the loop? It doesnt seem like they would change based on the sync path?
static import
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
Does k need to be a new hashmap here? Looks like it is initialized on line 343 already.
Inconsistent format! space after comma
Shall we use expected exception here, instead of asserting the exception?
Should at least have a DEBUG statement in this catch.
move this to the previous line
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Best to avoid logging any passwords, some end users will actually audit log files to ensure no passwords are logged.
With the overloaded constructor, this change is no longer necessary
System.clearProperty can be used instead.
Could we go with the name finalRequestConditions or something? conditionsReal sounds a little odd
Don't we want to check if it's a 401 first?
These 2 if conditons can be merged
I'd like to see what the format of the output is for JFlat. We may have specific requirements around how the JSON is flattened - so would also be good to see the customization options.
Great catch! Instead of maintaining another Set could you just check processToContainer.values().containsKey(container.getId())? That guarantees that we're always in sync with what startExecutor has started, since it updates processToContainer.
use compare - that is every version implementation implemented.
Replace SizeOf.sizeOf. You statically imported it.
Theoretically it would save a memory allocation and garbage collection to just return value;. Maybe Hotspot will optimise this in practice. Same in the other file.
Does only the dot trigger the special handling? Or any non-digit character?
why not use the logger for this?
lots of loc here :) this method was only present for toString ordering
You have two placeholders in the stream but only one argument, is this intentional?
This does not verify the order. (The iteration order over expectedMap is undefined).
BasicMessages have no type property, so just use empty string for logging the message type (the second parameter in this method call)
rename to simpler variable name (columns).
Ravi, if you just initialize this with false before the creation of the tasks then your fix will be perfect.
Would not use the work "type" here
this else seems redundant
rename to delta
We should set connection and socket timeouts here. By default there are no timeouts, so in case of network problems this may hang forever, which is pretty long. ;-)
Do we not want to log the exception that was caught here?
I noticed that you use this on many places, shouldn't this be NPE instead of IAE?
Use already defined Constants
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
why not use a ConcurrentHashMap instead of making all these functions synchronized ?
if (repository == null || repository.isBare()) { is more concise and gets rid of the {}-less block below.
Please replace all tabs with spaces and indent consistently.
Restore visibility of methods in this class to package level when unit tests are moved to jaggr-core
I would probably split this up and check the token type prior to getting and checking for credentials. It's a personal preference, though.
You need to pass the auth option along when doing the resolving, also consider the options in the call
I would go the other way around but that's my preference
Can you please also make this block contribute the the dynamicRegistration map?
We have too many nested try/catch/finally blocks here mixed with throws statements. Could we simplify this?
Why not just: java for (String msg : msgs.toArray(new String[0]))  ? No need to make a new ArrayList. Just the array.
same here for hasArray
check for isDestroyed().
The cursor iteration block can use a try-catch-log-finally, so we can see errors if read fails.
try isnt necessary here
if it isn't too much change, lets get rid of SecurityServiceCallback
So that is getting a thread that is local so as to get the classloader?
please use more concise methods like Arrays.asList
The config location is not ~/.motech , but ~/.motech/config - in Tomcat ITs we have no config because of this
I think we should assert two more things: 1. The value of getMillis() and getDecimalMillis() is the same. 2. This is the *correct* value (i.e. it's the same as cal1.getTimeInMillis()).
use Map interface instead
this should be private also
Minor: suggest moving port == that.port && xid == that.xid to the position close to Objects.equals(sslPort, that.sslPort). We can compare instanceName first. The port and xid are usually same.
This actually brings up an interesting question. If user wants to store the point with column lat, lng as double, is it possible to create an index for them?
It is minor, but to me this new name is not very accurate. I would call it assurePathExists.
Replace with Util.threadLocalRandomUUID()
add <> to "new ArrayList()" to avoid warnings
can you add some docs around this method.
@since 1.0.RC5
log.error("xxxx {}", e.getMessage()) ?
Hmm. Took me a little while to figure out that isExtension everywhere really means is a static extension. is_Static_Extension would be a better name. Not a big deal, though.
better Exception
Again, these should not pass validateInputs()
Given that we are not loading just genes but also transcripts, and IIRC the stored object is called FeatureCoordinates, I suggest renaming this class to LoadFeatureCoordinatesStepParameteresValidator. Related classes such as the step itself may also need to be renamed accordingly.
the steps 35, 36 and 38 are not neccesary
suggestion return spanBuilder.start();  immediately return
which exception are you avoiding?
toString() is not overriden in GridClientClusterState. I think it's better to use here state.state().toString()
You only produce String values here so the map can be using String.
instead of calling String.trim() multiple times here use map(), e.g.  Files.lines(p).map(String::trim).forEach(...)  You could also filter there too, e.g. .map(...).filter(s -> !s.isEmpty()).forEach()
what about !selection.isEmpty() instead of selection.size() >= 1?
nit: do you need AuthMethodPickerActivity.this or could it be just this?
Same as above here: use .isEmpty() rather than .equals for the empty checks.
why use ellipsis?
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write:  MockBattleState.builder() .attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))) .defendingUnit(givenUnit()) .defendingUnit(givenUnitIsAir()) .build();
Recheck the condition, it should be 0 <= pageIndex && pageIndex < getChildren().size()
Can you make these variables final and they can be used for both methods?
A warn as well. I am not even sure we need the stacktrace here
This method can be private
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Maybe we should use a specific ID/token (e.g. "HTTP", "WebSocket") instead of the class name?
Who does throw this exception?
Perhaps call getProxyHost and getProxyPort once only - else you risk the logged message masking a different version that is actually used. Potential future bug should someone change what getProxyPort and getProxyHost implementations.
NPE for: <LINK_0>
Why test canUpdate here? It's not necesasrily linked, is it?
Don't you think that set in a static field will be simpler?
Maybe add @Nullable to taskExecutorManager.
I'd use the Consts you defined in HibernateConsts for these values.
forgive my ignorance, but how does this solve the issue? Isn't there still the org.hibernate.Query vs org.hibernate.query.Query issue in the source code?
log me?
Doesn't look like the false param should be here anymore (onMediaUploadProgress wasn't changed) - also in two more places in this class.
Yeah, I think it makes sense. IIRC, netty swallows the throwable silently, so it's difficult to figure out what's wrong.
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
Why do we need this Map mutable?
This won't do. Schema is in request body, not part of uri. Parse string to json, and set the request body. Also, overload the schema constructor to get a JsonNode schema, because body is json in AbstractListhblueMEtadataRequest
Once we cache new DDF, do we need to uncache old DDF to claim some memory?
This ID is not the chargeId suggestion logger.info("Offered payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), charge.getExternalId());
You seem to be reusing this code in the other method overload as well. How about moving this logic elsewhere into a separate method to minimize duplicate code?
unnestChannelInputBlock -> newInputBlock
See earlier question.
We should write a real test cases for dropping connections.
If the error happen that early, can you map the error in early phase before mapping page result?
I am not sure if this solves the problem I was raising. Eclipse only creates a single instance of BndContainerInitializer. Not one per projects. So the constructor is only called once and the model listener is only added once. This change calls addModelListener multiple times. But since the method wont add if already added, it is not harmful. However, I think the cleaner solution is to make an onWorkspaceInit call in the constructor to add the model listener rather than piggy backing on the initialize call which is called many times.
suggestion boolean notInGraphAtAll = candidatesForDeletion.isEmpty();
This should call all  java return all(params, (RequestOptions) null);
Throwing an IllegalArgumentException could be confusing since it's not the arguments passed to the invoked method causing the problem. Maybe throw new InvokerInvocationException(ex) or  throw new InvokerInvocationException( new AccessControlException("Illegal access to method" + cachedMethod.getName(), ex) )
Could we add a check on the node being replaced having a null parent?
Would it be worth adding a break; after this line, or is it possible to have more than one note with a matching id?
I think we should find a way to do that differently, without needing AmbiguousSymbolImpl to store symbolsByDeclarationTree.
Move this if block after all if blocks.
Swapping the order of parameters would be more consistant with the standard method this replaces/wraps, ResourceSet.getResource(URI).
Please don't remove this mechanism for changing the color. Here we make sure that changes of the colours modify the individual views, e.g. night mode switches to day mode.
hmm, ugly workaround. If it is not / cannot be final, leave the field nullable and mark it null here. It would be more representative.
why not use IDE generated toString() ?
I would change the text to say "The encryption algorithm is not strong enough."
Is it possible to throw a more specific exception?
Why do we use iterators? I know the base class does, but why in the first place?
const for 5 .. use here and on line 445
resolvedImges can't be null otherwise the next for loop would fail with an NPE. Actually I would either put this into an extra method which returns early in this case or put this into an if-else with the following loop.
Likewise don't need the if statement since the optional value will return empty.
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
also include in the error message the build you found
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check for the presence in the list of the low-level permission like WriteProperties which are the ones actually checked by code in AbstractSession.
You can replace this by: java return input.entrySet().stream.collect(Collectors.toMap(entry -> entry.getKey(), entry-> base64StringToSerializable(entry.getValue())));
It would be nicer to extract it to an init method (e.g. initEditors())
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
AbstractSnomedRefSetImporter.createComponent(String) already initializes the UUID property (probably also applies to core components, not just the reference set members). It could be removed from all classes implementing applyRow.
Iterate over all the terms in map.baseTerms
channel.close().sync();
do add a null check for options before invoking the getter for ifMatch.
Anything we can assert here?
4 spaces
Hey, So currently there shouldn't be an assumption that there are any "universal" strings in the localization engine like this, so wee should likely move these to something like loggerInterface.logXPathParseError, loggerInterface.logXPathException() or moving the errors to be non-localized.
"Gerrit does not currently support generating diff output for this kind of change."
no need to write "VmHandler::" in the log, the logger already write the class name (also for the other logging below)
is this log at the right level ? also line 41
log and throw
allowing flight is different from the player flying, I think you meant capabilities.isFlying instead.
you can simply use Predicates.notNull()
Doesn't account for this odd behavior: > If the first few arguments (up to four) are specified simply as values without identifying the arguments, they are assumed to be, in order, x, y, z, and r. Thus, the following two commands are identical: > /gamemode creative @a[x=10,y=20,z=30,r=4] > /gamemode creative @a[10,20,30,4] Edit: applies to entire function, making a working version
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
but you didn;t ask it to leave a CID file...
We could avoid cloning here? (The message is not modified by the view?)
hopefully the close isn't necessary?
revert this string
Why do we need extra comma here?
Can we have some meaningful messages to accompany the tests please?
Should at least have a DEBUG statement in this catch.
rename to res
Use org.apache.flink.table.utils.EncodingUtils#objectToString
maybe this can be a set, so that duplicates get filtered out
If this property is set, shouldn't the classpath have been updated before? I'm not sure why we need this code.
Could you also test what happens when the data isn't Base64-url-safe-encoded, with labels, collision with an existing secret, etc?
I think this is incorrect - we shouldn't be placing files for variants of the same blueprint in the same directory. Can we add a pre-install command to create run.dir earlier than would otherwise happen?
Update log messages to refer to timer instead of commit, here and elsewhere in this class.
The other examples all use ASCII table output - is there a reason for switching to CSV or has this just been left in after testing?
ideally put operations would be done asynchronously so we don't have to wait for them to happen, but it's ok if jedis doesn't support that, we can always do it in asynchronous manner elsewhere in druid.
Why the dir variable ? I think you can inline it and concatenate it to the file name.
why not entity?
This code is duplicated in removeImage too. You may want to extract it to a new method
It looks like a publish buffer, thats set to infinite during reconnect. I don't believe there's an analogous buffer in the other clients.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
formatting should be num = Math.abs(num);. Even more, from my point of view it would be better not to change value of the method input parameter and just rewrite the line in cycle int chunk = (int) (Math.abs(num) & 0xf); WDYT?
< 0 doesn't seem like a great overflow check, maybe be more explicit?
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
Space after comma.
Those looked like good tests? Why remove them? Hash collision?
The variable name - may be something different?
no need for the if..diskimage is diskimage :)
If every other variable is in PascalCase, we should keep the convention in the file. Use TirePressureObject instead of tirePressureObject.
Where is the aggregation?
use Java8 stream anyMatch() instead of this loop.
perhaps, combine these if statements
It would have be easier to review if the refactoring to use an ExpectedException would have been done in another commit
What does this do? The result is passed directly into Datasets.load above so it should produce a dataset or view URI. But it appears to check if the URI is absolute (assuming that it has a scheme) and remove the beginning '/' if so?
I think most of the callers of normalize() convert the String you return to a BytesRef. So maybe it would be better to drop the extra utf8ToString() call and make this method return a BytesRef directly?
suggestion scopes = new Gson().fromJson(responseString, ScopesList.class).getList();
I would prefer some brackets around the logic elements for readability
isSameAs() instead of isEqualsTo()
Since IBlock is a thing, I'd definitely call this blockstate or something.
Given the FBO manager is passed in anyway, why not leave an additional constructor that takes the FBO's URN as input, retrieves the FBO from the manager and simply passes it to the constructor being used here? It would shorten this line and others like it.
and the param?
use <LINK_0> to avoid the build version tests
getLong?
Why would we want to silently fail here? Why not throw an exception on any update operations to tombstoned relation metadata?
nit: perhaps, include column name in the error message
nit: usually we put everything in one line or follow this pattern: java PlanBuilder planBuilder = subqueryPlanner.appendLateralJoin( leftPlanBuilder, rightPlanBuilder, subQueryNotSupportedError(lateral.getQuery()), true, LateralJoinNode.Type.INNER);  Just like what you have done to appendApplyNode
move else if next to closing brackets.
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldUpdateReadOnly() is being called.
getCurrentVariables() => currentVariables
Would it be too nitpicky to question why there is an intermediate rolls variable? dice.getRolls() is just as descriptive and it's only used a couple times below. Removing intermediate variables is often a good thing, one less thing for a maintainer to keep on their mental stack when reading code. At this point when reading the method, there are 3 variables in scope, soon to be a 4th one, leaves little room for much else!
you could use executeGet()
combine the two lines and return the String
I am having a hard time understanding the reason for this change?
Can we log the case of "dg" is empty?
You need to go through the persistent resource (instead of the data store), to ensure security is invoked.
assertThat( query ).assertThat( query ) ?
URL Decode would be necessary for parameter name and value
Instead of having this be a part of every authorizer, we probably want to push it up a level and have it be a part of the code that calls the Authorizer.
Do we need this catch block at all? I think exceptions are handled up the stack anyway.
no need to handle failure (rollback, log, etc..)?
The values are sometimes a list and sometimes a comma-delimited string?
You should handle the exception here, report the error and report the whole process as failed.
possible NPE
use Arrays.asList(...) for short lists.
I test fails than container will remain started and port is busy. So, good practice is to enclose tested code in try block and stop container in finally
It's wired the method getXXXList does not return a list but a set instead.
Add this logic into the certificatemanagerserviceImpl class.
please log in error
Use IASTUnaryExpression instead of CASTUnaryExpression.
Typically we use Map on the left hand side rather than HashMap
This can be simplified when we remove the enableDoAs logic.
ExtensionNamespaces.LBAAS to be consistent with the alias name.
Missing final
Please double check all methods that modify the LinkedHashSet. From what I read the iterator might need to be regenerated every time something is added or removed from the set. If that is the case it might be appropriate to have additional register(ArrayList) and unregister(ArrayList) methods to pool changes together and regenerate the iterator only once.
Set this only if session details not null??
Suppose there are two interfaces:  public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.impl.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { }  so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a Format, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
Can we also have a test for LUCENE -> NATIVE -> LUCENE
Suggest adding an assert that the only task name in the list corresponds to the last invocation of setTaskName(...).
Put these two assignments in order so it's clearer
No reason to store in a local variable if only used once within the method. suggestion
If instead throwing an exception when policyParameters[3] == null you log the error. I think it will return a NullPointerException when you do credentials = (byte[]) policyParameters[3].
use LinkedHashMap
Shouldn't you return early when you find a non-null interval so that you don't have to map every remaining quark for nothing?
Run formatter
Could we simplify the 2 lines above as if (FileKey.resolve(gitDirOf(name), fs) != null) {
nit: perhaps, include column name in the error message
you can call getLocalClusterRoleType
This should be changed to @%s usage warning: found unsupported restricted type <%s> on %s. instead, or something similar, since these APIs aren't official supported APIs and are subject to change at any time.
This log ends with a period, the corresponding does not, they can be unified. Perhaps these messages could be more "parsable" visually. What do you think of the following? [Signal(id)] Created consumer for {}. [Signal(id)] Deleting consumer for {}. (and so on)
Just do getAndSet(null). Then shutdown the returned value.
I think here you can do something like steps.stream().findFirst().orElse(null); If findActions receives null, return a Collections.emptyList();
Same nesting questions
Please inline the variable numberOfArguments (which is not used elsewhere), remove the finalmodifier (we internally don't use them in such context), and use type ProgramState.Pop instead of Pop (in order to avoid import of type Pop, and simplify understanding of the context). I would also prefer a variable name close from what it represents, like unstack, which is the name used everywhere in this class.
No need to mock, this is the default value.
I think this solves the problem, but why aren't we removing the processor field from this object? If it's dangerous to reuse it, and the one stored here isn't necessarily the one used elsewhere, then surely we shouldn't store it for later access?
This is the second use of these strings, specifically with a trailing space. It would probably be best to extract constants for them.
Don't catch Exception or Throwable, that's overkill. If any of that code throws a checked exception, catch that, optionally with RuntimeException too if needed. If you want to catch 2 exceptions, use java 7 style "catch (FooException | BarException e)" Catching Exception is bad because if the code has no checked exceptions, then you could just catch RuntimeException. If it has, you can catch those and optionally RuntimeException (if the latter makes sense and often it does not make sense to catch RuntimeException) Catching Throwable would be even worse, as that catches OutOfMemoryError etc, which need to bubble up the stack.
can you change this impl to be addJobProperties(job.getConfiguration()) ?
Should these go to logcat?
A SashWindowsManager can contain several TabFolders. Only iterating on the Active one will miss some (opened) diagrams To reproduce, open 2 diagrams in Papyrus, and layout them side by side, and control them both. Only one of them will actually be opened in the resulting controlled models (The one from the "active" tab folder)
nit: maybe better to check the newSegment has a newer version than the old one.
use multi-catch ?
Collections.singletonList() might be more concise. List returned is immutable if that is of any importance.
I have to admit that I don't understand enough about this, but could this be a binary compatibility issue?
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.
lots of these to cleanup
How about we use the isBetterOrEqual method from GeneticAlgorithm class?
This is where the if statement should be for checking the property for allowing for corrected times.
It would be better to write group by clause at the next new line.
Use the whole path IPv4.Availability.PUBLIC
This is the line of code from the else branch. Since the version is above honeycomb you should use findPatientView = (SearchView) mFindPatientMenuItem.getActionView(); from the if branch.
Oh yuck. ;)
This will always be true right now, you'd have to setNofityRequestNeeded(false) also in buildManually of the history builder. I'm not sure what this adds, it's one more call the module developer will have to make, just to avoid calling this twice.
why the magic right shift? is this based on experience?
add java doc explaining the packageName is used for finding the package and if it is not found it is created. method name should be reflect this. Maybe this should be split up into separate fucntions
For the sake of saving some network traffic, let's not call logNavigate in this case. We can simply assume that, in the case of version 0, a linkClick event also implies a navigate event.
You should read <LINK_0>
if (
What about caching the list? AFAIK this method will be called multiple times on the same connection.
Unless a good reason for this, the following is considered more correct:  java if (getClass() != obj.getClass()) { return false; }
return builder.toString();
just a reminder about the db lock for better user experience so we can see more opinions about that
How are you planning on setting this flag? Does the application need to know whether fetched offsets have taken into account ongoing transactions?
You don't have to implement entire getCurrentToken() in each TokenCreator. Each TokenCreator is having the exact same code. Instead add this logic to a method retrieveCurrentToken() to AbstractTokenUtil and then just invoke that method (azureTokenUtils.retrieveCurrentToken()) from each TokenCreator:: getCurrentToken()
could this be replaced with return JodaUtils.umbrellaInterval(usedSegmentIntervals) ?
Should be dispatched from UI thread, TimeGraphViewTest:304 is also wrong.
Although we don't gain that much from wholeWord, we may need to implement it to be consistent with the options available.
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Perfect! :+1: Just a few things. I'm a little picky here :grimacing: No need to extends Object. Please use Map as declaration type. java return new ArrayList<>(uniqueMap.values());  The method is a perfect text-book example for tests. :wink:
this, too.
necessary?
What are these annotations ?
just do not catch anything, you test throws exception
There are quite some AccessResultCodes beside SUCCESS. If the result is included with the exception this could provide useful information about what exactly went wrong.
@gitgabrio can you please explain why you removed this? I see you added scenarioGrid.clearSelections(); to clear the selection @ line 133, but scenarioGrid.deselect(); modifies a different status.
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
types --> type
Please do a table.put(List<Put>) instead.
This line should be removed
"belonging" -> "which belong"
why is the first parameter a LayerCommand if we only need the resulting Layer?
also assert the cause attributes
Should we add: Objects.requireNonNull(record)?
I recommend throwing the list into dependency resolver instead. This also will allow the user to not have to specify the full dependency chain.
why causeOfDeath is empty ?
Are you sure that you should add this file, too?
Can we name this something other than it? Even i would be better to me than it.
HQL/JP-QL
{} for blocks
This is not needed. In super.tearDown(), all the replaced stuffs are restored automatically.
what if the acl is not found? we should skip metadata update in this case and return false?
Message should probably be sent before actually unloading chunks. :)
You could use getEndTimeAsZonedDateTime here for simplicity
Could you please assign the URL to a local variable before opening the connection? This helps while debugging problems.
suggestion Pattern argPattern = Pattern.compile("^\\$(?:\\{(.*)\\}|(.*))$");  Align with start and end of the string. Otherwise you would also match bla$ad or ${foo}bar
Are we expecting more than ILaunchConfigurationTab? The exsd file mentions that we should get CLaunchConfigurationTab, although I think it should probably be AbstractLaunchConfigurationTab
missing braces
Why do you need this cast? Is it because ScreenLoadCallback implements both interfaces and its picking the wrong return type for the old style RPC call? If that is the issue maybe add a 3rd method addOldCallback() that calls the old type add() version so the compiler can't guess wrong for a ScreenLoadCallback?
how would you feel about making this an actual URI builder instead of a string builder?
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
don't we want to copy the name from the model to BE?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
resolvedImges can't be null otherwise the next for loop would fail with an NPE. Actually I would either put this into an extra method which returns early in this case or put this into an if-else with the following loop.
If we are going to use System properties shouldn't we reset them when the test tears down? We don't want any unexpected side effects when other tests run.
I would dump this iterable into a variable just for clarity. It looks more than a tad clunky in-lined...
I fail to see the difference to the previous test. Is there any?
System.out.println("...... and path id (optional).......
I'm really used to the builders creating all their children all the time, is it really worth doing it differently here?
We should probably also add a message saying that you cannot barter with piglins using Slimefun items.
it would fit easily one line
Don't duplicate the error messages and again, in almost every case I think just throwing without context is fine. The code well explains what's wrong and we don't expect it happens under on any reasonable Android device.
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
This exception is not ignored, so can you fix the variable name?
nit: what about java nulls[i] = i % 7 == 0  ?
I'm surprised that getRequestParameter does not return an Optional :)
Unneeded empty line here.
Looks like addEdge(), removeEdge() has the same logics as the base class. Why do we need to override here?
toTraceId already returns a string, on need to call format()
Shouldn't it be CONF_DEVICE_ID_TOPIC?
Not worth debugging for this QS
Use class-level constant.
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
Better to replace -1234 with MultitenantConstants.SUPER_TENANT_ID
do you need to add CRC here?
Spaces after commas
else { is redundant
This (And other filters) need their type as well. The reason being we could have a TagValueRegexp with a filter like .* and a FieldRegexp filter with the same filter and want them to hash to something different. For this and other regex filters, you can omit the pattern from equals and hash as those are just compiled versions of the filter field. It's ok not to use the parsed version even if someone puts a space in front or back.
assertThat(list).containsExactlyInAnyOrder(item1, item2, item3...) can simplify this
Shouldn't the setup happen from the loader? Seems like an anti-pattern to trigger this from the sync adapter.
You don't need it in every Exception since you have a finally clause that will get executed at the end.
Can you factor out psInfoFactory.get(db, pId).getAuthor() into a variable? I think it would be better than to have it in 3 places now.
This should be a triggered ability of the enchantment, not a trigger gained by the creature
Can be shorter: Collections.singletonList(mock(DataType.class));
possible NPE?
Use new lines.
this is not vdsm, should be another configuration or setting within database, but we kill this code anyway, so not that important.
There is a singleton for OK Status: Status.OK_STATUS
Does this logic also need to be replicated in AvroParquetFileReader?
@aertoria Can you change all the variable names in test method to not have _1
Please use Collections.singletonMap here.
Same question about maintaining type information.
try {
Better return 0 ?
I don't think it's a good idea to make a special case for this. We can POST the options in the body for all changes requests
optional: this can be outside the try{} block
We might want to consider logging something into the log so it's trackable. Wdyt?
style nit: missing braces, since a while we use braces around single line blocks, change this only for new or modified code
Class<?>
We are calling close even though it doesn't do anything just to avoid warnings? Where are the warnings coming from?
This doesn't ensure the file was flushed. Which means it may be stuck in a buffer and isn't shared with the other open file handle created by the Compiler. It also might not work on Windows, where files cannot be open for both writing and reading at the same time. You need to ensure the file is written and closed before you call the Prolog Compiler.
Need to have Assert.hasText for taskName.
Exception#printStackTrace goes to stderr by default.
@vilchik-elena Why not use the expression stack?
This is wrong map, one from change info and not one from revision info, that you need. The right one would be the code that you have removed: RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { NativeMap<ActionInfo> actionMap = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo> create(); }
long nextBackOffMillis = backoff.nextBackOffMillis();
Why are these changes required? I think that keeping it at just Segment should be fine (and more correct, 'cause it's totally possible that someone chooses to implement Segment without using AbstractSegment).
Can use validatePrimaryLanguage here and below.
If you change this to be a VariableReferenceExpression builder it will save me a few lines of code when I get to this part for symbol to variable refactoring, lol.
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_0>
can be removed now
using the payload as the assert failure message might be confusing without more context
super.init() method never throw an exception.
empty hashmap.
Instead of creating a couple of extra Timestamp objects, move this as the first line in your if statement and just return true, like this:  if(divBy > 1) { return true; // As in this case, we've already got the correct value in ptr }  Also, another good optimization would be to check the last four bytes being non zero without creating a Timestamp object. You could do this like this:  int nanos = PDataType.INTEGER.getCodec().decodeInt(ptr.getBuffer(), ptr.getOffset()+PDataType.LONG.getMaxLength());
One concern that I have is whether this method is only used for the determining the next billing period start date. I want to make sure it does not inadvertently affect offer parts of the application.
This null check should in fact be avoided. The only case where a method symbol from a method tree can be null is when semantic is not available. In the ruling that happens for package java.lang of JDK. If it is not available, then it makes actually no sense to run this check so, in fact at the beginning of the visitNode you can have a :  if(!hasSemantic()) { return; }  You can test this by using JavaCheckVerifier.verifyNoIssueWithoutSemantic (which you already use).
I don't like here that you include parameters that had to be omitted. If something will change this could be a cause of a problem.
If you see opportunity it would be great if you could refactor the methods with many parameters.
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in the grand scope of things but it fits the error message better.
Suspicious null here. Instead of getType(null), why not just Type.STRING?
Ah, and CheckStyle allows it? Rewrite to the long but more readable form:  java if (result.IsEmpty) { return emptyList; } return callDao();
nit: The mocked environment creates 3 nodes (by default) that you can use so you don't have to create them. You can get them with env.getCluster().nodeById(..).
If you're at it you can change it to: return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
Isn't this the number of mappers? Can the reducer get it instead and compare with it?
Minor: Maybe extract local variable with the size. Will be more understandable.
"e" is an exception. Per definition. :)
Missing null check on sampleClass
Null check required?
Same observation as WCS and WFS tests
isEmpty
This error message is not very useful. How about "no matching files for folder with regex: " + regex.
I think lowercase l should also be considered
Modern Java does not need StringBuilder any more. Simply use += to build a regular string, this is fast. It may even be possible to use StringUtils on an array of longs, but I'm not sure about this.
Should this use a try { } finally? Otherwise other Throwables leak.
This should be EntityNotFoundException#byName instead of EntityNotFoundException#byId
Is this better than Assert.assertEquals?
Lets use APILifeCycleAction.PUBLISHED.getAction()
This looks like different logic. You only have one serial read. putChar also writes two bytes into the buffer. This seems weird in the first place. We could maybe jut write:  return ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).put( new byte[]{serial.read(), serial.read()}).getShort(0);
setGameState( BOT_VS_PLAYER ). make final int
maybe mention the field type?
Collection<?> cpuCol = (Collection<?>) cpus; return cpuCol.stream().filter(c -> c instanceof Integer).map(c -> (Integer) c).collect(Collectors.toSet());
Why the extra parenthesis? It's a single parameter lambda.
Not sure but I think this would only happen if there is an error in the business logic on the client side when processing the closure, even if the request itself succeeded. So this might not warrant marking the span as error.
These should be inline - not required for testing
If you are in Java 8, it is nicer to use .then.
Is the intent here to make tracing table transactional? What would happen to the existing tracing table i.e. on a cluster with existing phoenix deployment with tracing enabled? You will likely need some kind of upgrade path to update the metadata of existing tracing table to mark it as transactional.
Test for last four digits as well?
If we keep this approach, encoding should be a module option
Let's use request body rather than request params for this. You can use getAndValidateRequestBody method with List<String> or String[] as the type.
please rename to performOpenMoreOptions
you can use tasksByPriority.entrySet() here
should rather be named currentContextClassloader
Should maybe be "SocketException has occurred"
any reason to not do this in the constructor? Is it null in the normal flow?
It should be openDeleteConnection, shouldn't it?
This catches too many exceptions. 1. I think exceptions from formatPath should be a fatal error. Users should notice that path includes an invalid syntax. 2. If listS3FilesByPrefix throws an exception, it's also fatal. Otherwise the result will be invalid.
why new a map here, is it OK to do like this?  final Map<String, Object> aggMap = toJson(node.getAggregation()); aggMap.put("class", node.getAggregation().getClass().getName());  And you only need to add class info for UDAF, for system aggregate function, you do not need to add class info in the map.
Just realized that in SQL, we directly exposed the system.stream format of names to the user. This is slightly different from the Java fluent API where we are changing to use logic streamId to uniquely identify a source in the program. Let's discuss to settle this one.
Add the command that is being executed to the log
I think everything from Optional<Status> statusMaybe =   could be replaced by: java return statusMap .flatMap(StatusMap::getToStatus) .map(status -> { if (status instanceof ChargeStatus) { return new MappedChargeStatus((ChargeStatus) status); } if (status instanceof RefundStatus) { return new MappedRefundStatus((RefundStatus) status); } return new UnknownStatus(); }) .orElseGet(IgnoredStatus::new);
This needs to be new Request(Request.Type.OPEN) now.
suggestion server.getFileStreams().forEach(UncheckedFiles::closeInputStream);
do you think debug is enough to report this problem? I would use warn.
Needs to be in an else-clause, otherwise you'll count twice (newChild() and worked()) and thus reach 100% before the last path.
you can use Schema's isNullable and getNonNullable methods to help out here.
As the inspection says, what is this variable for? Why not just use packetIn
Do either of these two 1. Add address.equals(InetAddress.getLocalHost()) to the check as a local inet address may still not match the two specified conditions above. 2. Create an unresolved InetSocketAddress in getRMWebAddress with canonical hostname and check for null InetAddress here
if it existed in containers, is it not sufficient?
NaN if outputRowCount is 0
We should either do a info log to inform users that we are still waiting for the operation to complete or we should timeout at some point.
nit: better to add ledgerId into the log statement, so it is easier for troubleshooting.
Please use new File(basePath, ".gitignore") Instead of string concat with the platform specific "/" character.
since we use instance variables for most part to construct BlobId, may be you can introduce a privateMethod which takes in non-instance variables and version to construct BlobId is the specified version
Should we consider the value of "length", it should be > 0, and for Oracle [<= 4000](<LINK_0>
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
Convert Unspecified to constant. And there's probably a framework constant for this string somewhere.
why couldn't we return results before the analysis is completed?
Why is this here with such a wide exception type?
We shouldn't use 'String(keyTable[i])' here because sb.append(Object arg) is doing 'String.valueOf(arg), so it already has a null-safe Object-to-String conversion.
This feels weird to me - why are we manually setting the height like this?
Why bcast when it can be sent to Admins only? Ops could use it to spam.
why is this necessary? Isn't better to fieldCache.put below here?
You probably made it a couple of thousand times slower :-) Keys rarely overlap in this domain creating a StringBuilder has an initialization cost that is not amortized.
Can you add a way to signal this runnable to finish?
Shouldn't the exception bubble up in these cases? Fail fast fail hard!
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
how did the previous version work? Use FileUtils.mkdirs
As said in previous review: Add here a condition on isSequenceElement, the below code is unnecessary if isSequenceElement == false
maybe change "== -1" to "< 0"
Is this System.out required?
static import?
We better not have the supported/unsupported versions hard coded here. Please check whether discard is supported using the FeatureSupported class.
just for consistency, can we use final int?
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the setNegativeButton method call will lead to the same effect (closes the Dialog), probably adding some clarity to the code as well
Could you use just one RevWalk instance for all selected commits?
it's better to use registerAndRefresh() because registration can be done async in monitoring server depending on when voltron is calling us.
should not error if docker doesn't exist?
id is the unique element in a HTML page. Therefore, there is not need to have a chain to locate it. Check if there are similar case in your PR.
Adding an immediate return after appending in the isEmpty case would get rid of the else:  if (validationResults.isEmpty()) { validationResultSummary.append("Invalid - ").append(NO_PACKAGE_IMPORTS_FOUND).append("\n"); return validationResultSummary; } for (ValidationResult result : validationResults) validationResultSummary.append(result).append("\n"); return validationResultSummary;
Neither here, nor in the interface, does it say as to how much data is read into the buffer. Let us be clear: unlike other similar apis, it is not "read as much or till EOF", but "read exactly buffer.remaining() or throw".
Can be moved to if block above
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class.
Yay, so this worked for you I assume?
Do we want to close the closer when server fails to shutdown?
Exceptions.launderedException instead? This would not wrap RuntimeExceptions one more time.
We could omit the second Integer.
Can we add a log message with the iteration number, size of workload, and computationSpeed before each iteration? This could help authors debug their optimizers. (Since the computationSpeed doesn't change, we could log that once, on initialization if preferred.) Maybe we can even log this once on start and once on exit?
same question as before, about the value of heart beat..
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
This (the whole method) could keep the same indentation char.
This is where you should print a stack trace.
s/vdsGroupId/clusterId
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
I would prefer to see this logic broken up into a couple of lines, it is a bit hard to parse. As well, then you could avoid the need to create the empty set to pass in for the other getProducts(page) call.
I'm afraid this could spam the logs. I made bad experiences with logging when developing the DOIConsumer. Please reduce the log level to debug.
These aren't equivalent. The StringUtils version checks for null and "" in one call.
Collections.emptyList()?
Copy this value from the previous and ensure the previous' value isn't null
The protocol file is not allowed when using live streaming. The session creation fails. We have to make sure that this combination is not allowed.
![MINOR](<LINK_2> 'Severity: MINOR') Add logic to this catch clause or eliminate it and rethrow the exception automatically. [![rule](<LINK_1>](<LINK_0>
Consider moving to the Enum, also a bit confused on this - is it an "id" used for wicket communication - or is it human readable (in which case it should be translatable).
I think that using containsOnly could hide the fact that duplicates are not preserved. Inspecting the variable load.getParticipants() I get this: > 0 = {Programmer@4134} "Programmer{nick='fax4ever'}" 1 = {Programmer@4135} "Programmer{nick='phone4induction'}" 2 = {Programmer@4136} "Programmer{nick='telegraph4eternity'}" I think that duplicates are lost even in a @OneToMany. Aren't they?
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously)
Is it suppose to use config.m_getOutput as path for target file?
this should probably fail on receiving interrupt
Use WebUtils instead of casting this yourself.
I like the approach; but I'd like the TLS 1.2 and allowed CipherSuites to be only limited to API 24 (higher API levels might want to use TLS 1.3 for example)
The null will clear the current start time from the db.
Why not pass regionInfo instead of table, then encoded name and replica id?
It does not seem to matter what the disconnect message is, or does it? We probably do not need to assert a specific message.
wouldn't it need to sort the list in this case, too? (I wonder if using a self-sorting list here would not be the better solution.)
Use the pre-existing localized string R.string.multimedia_editor_popup_cloze, and definitely follow up on the "TODO" by using a static constant value instead of a magic number.
Class name is not needed when calling method on same class.
Why is this not a if condition
suggestion setValue(relativePos / rectangle.width);
can this be a method reference?
For me, It's strange to see that if exception during parsing of jwttoken failed - then authentication should be skipped. Is it supposed that this token will be validated by the next authentication filter?
(minor) You could add an explicit .setPrivate(false).
Same as above for toString(): <LINK_0>
I think the order of the checks here is relevant to minimize the work. We should check "firstParent" first, then SEEN and then parsing the headers if needed.
ugh again ..
Arrays.fill(filler, '0');
I don't understand why you don't use the sonarUsersGroupId and have simply the query:  "SELECT u.id " + "FROM users u " + "WHERE u.active=? AND NOT EXISTS " + "(SELECT 1 FROM groups_users gu " + "WHERE gu.user_id=u.id and gu.group_id=?)"
Why not return getAnnotation(annotationType) != null?
Could we add something like: if(System.getProperty(PROP_UUID) != null) { return System.getProperty(PROP_UUID); } Then product creators can disable by setting the property to whatever value they want.
why is the lower bound 0? Should it not be at least 1?
Let's explicitly check whether numBlockOwnershipByEvalIdForWorker contains workerId. Same for storeServerMetrics().
Maybe just via backspace? I've never really used the case list search functionality on older devices.
I think this is a bit too early. We support loading from many places other than the internet.
Apache commons is already present; can replace with if (CollectionUtils.isNotEmpty(contentParts))
We should not use Optional
Why do you need to do this?
This is still needed and should be retained.
Missed it at previous review. Question - why via getVmDao()? and not via VmStaticDao()?
Should this test that explicit exception type is thrown not just any old exception. As probably should fail if an unexpectes exception is ever thrown.
I would put the "magic number" into a static var.
extra space
Perhaps safer to construct a new List using subList as you otherwise have to make an assumption that Files.readAllLines will always return a concrete List that supports the optional remove operation.
provide style as parameter to above methods
Can we inline getArguments().providerInfo below? (Trick: use Ctrl + Shift + N)
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Extract notification to own method notify...
Looks like it will throw NPE if undefined.
We should always do a null check before doing an empty check. Better yet you can use NullChecker.isNotNullish here.
Code style
Does it need to be public is protected not enough ?
aren't you confusing the size in chars from the size in bytes? I'm not seeing the right encoding being applied.
It'd be nice to use a constant for this, e.g., NO_ENCODED_LENGTH?
It seems strange to test for null in this test, since it is testing the happy path. Can you create a FilterStub?
The logic in lines 37-64 is common between C and C++ and should be moved to VariableReadWriteFlags.
To me it would be a bit clearer to use append chain here.
Why aren't you using 'createNic(..);
I think you need to do this and the next line in a finally
This should be done through a custom method on ActiveMQServerLogger.LOGGER rather than through the generic warn() method.
We should not wait for Active here
Style-nit: Parens aren't necessary around the conditional.
you don't need this. the "+" operator does this for you.
I think this can be truststorePasswordAlias instead of the string?
I don't think it's a good idea to swallow an SQLException. If you can't throw it or print entire error trace for some reason, at least get error message from 'e' and append it to warn log.
These tests should also check the name and url are showing up correctly in the TaskData.
Why adding unneeded braces?
Shouldn't this be generalGroup now?
The selectSQL method is called for normal data extraction, there is already a separate method to handle visitors, the problem is that one of the various wrappers between GeoServer and the datastore is not passing down the visitor and thus breaks the optimization.
Don't branch on the exception message, let WindowsFileOperations.readSymlinkOrJunction throw the right exception instead.
Not sure this is strictly necessary, @efge?
Can you also verify the error message? This way, the reader can easily tell what kind of error this test cases tries to check.
optional: this can be outside the try{} block
Log and throw is considered to be anti-pattern: <LINK_0>
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set a boolean and then reset the interrupt flag after we are outside of the while loop.
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
How about using try catch instead of if else?
Can we invert the conditions to be able to use early returns and thus avoid the nesting?
log should say store is not initialized.
not important, but that could be "return Optional.ofNullable(ispnResource).map(IspnResource::getResource)"
toString() is not overriden in GridClientClusterState. I think it's better to use here state.state().toString()
nit: add some line breaks, similar to the original formats. ditto for others.
You might want to add 2 more things here: - double check if sock is still not null - make sock = null after the close to prevent further usage of the object and let GC collect it
This should be getModified.
-> could not **read**
suggestion .filter(Objects::nonNull)
This will not include the line break. Probably should append('\n')
Potential alternate wording: "If these messages are no longer available (perhaps you deleted and re-created your Kafka topic) you can use the supervisor reset API to restart ingestion." your choice if you want to use it or not.
We can move this audit log to the common method. As this is common code for all ACL requests. auditAcl(OzoneObj ozoneObj, OzoneAcl ozoneAcl, OMAction omAction, Exception exception)
Let's simplify this condition
Please keep this.cell near the related fields (previousFamily & cell count) below
Is this System.out required?
How do you know that tableName is not, itself, an SQL injection attack?
should we throw an exception here?
seems worth throwing an exception if the file isn't found, no?
please also assert that this calls enque on the call.
I think this is the condition for !editable, i.e., readOnly.
Why do you use sleep ? It is highly discouraged, wait for an element instead
The Exception message should contains the original IOException ?
As discussed, a metric would be useful.
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations.size()).isEqualTo(1);  =>  assertThat(violations).hasSize(1);
This can't be null if it's instanceof ITask.
This should be done in the above if and before calling isLooselyScopedCookie, avoids doing all the work if the cookie is ignored.
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
Use the 2-argument constructor.
dispatchDepth > 0 ? dataLoader.dispatch() : completedFuture(emptyList()) You dont need this. dataLoader.dispatch() does nothing and returns an empty list if there is nothing to do So just return new DispatchedBatchLoader<>(key, dispatchDepth,dataLoader.dispatch());
if the host doesn't support the v3 format (old vdsm version), we'll fail when trying to add the domain. i think that if there's no pool, we can add the domain as v1 (it's rare enough anyway)..in the worst case, it'll be upgraded.
String.format?
Does this ever get called more than once?
use style provided with callback instead
I suggest to resolve these two references separately, you can have two methods: Optional<Image> aboutImage Optional<AboutItem> aboutItem after that the code should be less complex
May this dialog also limit resources with *.json as the other one that browses the workspace?
why not list.stream().forEach?
Is this supposed to be mId = null? mTitle is set in the next block
Use TaskType.STANDBY.
isn't better to call it dimensions ?
I think this lines are not required, but never mind.
Why a TreeMap?
nit: getBytes(CharsetUtil.US_ASCII);
Use ConfigUtils:isBetaFlavour
This doesn't work if the editor has a file open that is not in the workspace. Don't we have something somewhere (SelectionUtils?) that would make this work also in that case?
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter filter = filters[mid]; int c = methodName.compareTo(filter.methodName); if (c == 0) c = className.compareTo(filter.className); if (c == 0) { return true; } else if (c < 0) { high = mid; } else { low = mid + 1; } }
Please include clientTelemetryEnabled in toString() API
formatting
I'd declare the kieConfiguration as a local variable, with a setter/getter pair. This will allow Camel to generate code to allow users to configure username/password outside of the uris. It will be the default configuration (i.e. if not overridden in the endpoint uri, the parameters present in that local variables will be used). Then, in the createEndpoint, you can "clone" the default kieConfiguration and override settings using parameters/remaining-uri. This is because uri parameters cannot be configured directly using environment variables, while component fields can.
Is it an exceptional case for ConfigLoaderFactory to not be present here?
succeeded() or succeededSilently().
Should this be CF_METRICS_METADATA_NAME ?
In what case can we not create an evaluator?
I am not sure if we want to return null here
This case could be avoided by creating a getLabel(ButtonData buttonData) method in the ValueType enum, which then is overridden by each enum value. But it's kind of esoterically.
Error occurred while creating a new XMLEventReader from InputStream.
Does this truly need to be done in arjunaCore or could it be guarded in XTS alone? It is fine if it is an arjunaCore issue and we should code to fix it but I need to see an arjunacore test case that shows this or reasoning it can't be sole change in XTS
No need to append an empty string :)
same string used multiple times ==> put in a var.
Fine to move the command, but since you try to refactor the code, this method should be private
Would it be better to use:  java if (thing == null) { continue; }  If there are two factories that could create the thing, you will return "null" here and do not try to use the other factory.
If the lastException is null or not an instance of AmqpException, we should return null. For example, an IllegalArgumentException is not retriable.
matchAll will internally still copy the entire match set, so in case of hybrid matching, this will not perform as expected
if this utils... I would have passed the calling class as parameter to get this defaults... so that you can have multiple... or better just pass InputStream...
OCFile now has a method getRemoteParentPath that may replace this block. Let's take advantage of it :)
Should be Refreshing_X and use NLS.bind()
can this be called from multiple threads? If yes then there is a concurrency issue. fParameterProviders needs to be handle thread safe in this class.
unnecessary parenthesis?
We could just return true here and let auto-boxing take care of the conversion.
Code cleanup: Remove all throws MiddlewareException and throws MiddlewareQueryException for this class
is there a reason you don't just return this here?
After <LINK_0>, tuple should be singleton.
Can just use diamond operator on RHS
Using CompletionException would be more appropriate I think. Otherwise we would end up with longer ex-> RuntimeException(ex) -> CompletionException chain of causes.
why?
What about doing one thing at a time?  java View frame = Views.findById(this, R.id.login_icon_frame_layout); frame.setBackground(new BubblyDrawable(getContext()));
I would have put it after the createAnnotationAndAddSubscription call.
Just to keep the logic in a same class, why not move all this in the prepareValue method. You would need to pass the operator, but that's fine. This class wouldn't be modified.
Why is this here with such a wide exception type?
Change Object to String
Do we need to check if manager is null? If not, maybe we should remove geofence manager check?
Have you checked that the test fails if the this assertion fails?
addAll or stream?
It looks like right now when a connector is made diagnostics aware, There is a lot of boiler plate the connector needs to do to parse out commands and parameters. We could consider creating a library or utils that helps diagnostic aware connectors to reduce this boiler plate. We don't need to do this right now. Something to consider for future enhancements.
Likewise, this should probably be /rest/script/sessions, and the sessions controller should be updated. The restlet framework handled servlet paths differently from the MVC framework I believe. Either way, you should verify in a 2.11 geoserver with script installed to be sure of the correct path.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
This also needs to be reworked once #6327 is merged.
so it records stopped time only if all workspaces are stopped? Shouldn't it be all user's workspaces?
wrong code format
Unkonwn => Unknown
Please do not swallow exceptions silently.
optional nit: File::getName
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
load() is unnecessary as the constructor above already calls it.
Can you set the message inside the method avoiding passing it as an argument?. It's always the same
This is an alternative to have just one assert:  aList.stream().allMatch(num - > bList.contains(num)));
I assume this should be deleted
This might cause problems with dedicated servers since you refer to a screen class and the minecraft class here. Have you tested this with dedicated servers? If it does cause a problem, consider moving the gui display to MSScreenFactories.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
This is test can give false negatives. e.g. if a real user email can contain 'tmt'. Use a longest string possible for both cases.
optional: this can be outside the try{} block
please add <?> to avoid warning
Are there unit tests for channelSignIn?
Please extract to a method and call it after you verified this is an image disk
No space between STARTS and WITH??
resizeWidth variable is unused now, should be removed
unrelated change
nit: Add "I_" "D_" prefix
java assertEquals("Unexpected failure code", ERROR_SUCCESS, result);  Try to provide as much information about the failure - in this case, not only that it has failed but also why.
rename 'visibleField'
can you make "9" a constant as we use it most places
handle this with an error log and returning null instead of a viewer? as the view won't work with an incorrect id?
> isAssignableFrom fails because the classloaders used between the two classes is different I don't understand, this is with a built-in policy implementation right? How can two types that belong to the same JAR get loaded by different classloaders? Regarding Dynamic-ImportPackage: *, as far as I understand this is the nuclear option, so I still see a value in allowing users to pass their classloader to the builder.
In cleanupNodes above we do a NPE check like: java if (nodeList != null) { // ... }  Shouldn't we do also here?
yes, I'd log failures, the bundle activator has some methods for logging: Activator.logError()
Remove the matching given method call as well.
here schema is always not null
We are using Java 8 here. You can say catch InstantiationException | IllegalAccessException | ...
This only runs on Gtk3. How about trying to set this to not run on gtk2 instead? would this work on cocoa/win32?
Log and throw is generally considered an anti-pattern. We should perhaps be able to get rid of the log message in this particular line.
what happens when inputSchema is null? Also, to reduce indentation, we prefer:  if (inputSchema == null) { return; } // Rest of the logic ...
no System.gc() before/after?
This will truncate to the closest size in GB. I'd do the division in doubles and then round UP to a long
If it got deprecated in Gtk3.10, then it should still work between Gtk3 to <Gtk3.10. You may wanna put this around a version check instead perhaps?
Is the purpose of this to show the user the REPL prompt again?
The legacy behavior corresponds to SingleAffinityResourceDefinition.PATH, thus I think we want to use: builder.rejectChildResource(NoAffinityResourceDefinition.PATH)
Are these two if necessary?
Would it be possible to fix workspace object as soon as possible in the chain, so we would avoid ifs like this in the code later?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
the definition can move to the else block
Throwing an IllegalArgumentException could be confusing since it's not the arguments passed to the invoked method causing the problem. Maybe throw new InvokerInvocationException(ex) or  throw new InvokerInvocationException( new AccessControlException("Illegal access to method" + cachedMethod.getName(), ex) )
what if the account id, container id is 1? I think its probably better to do something like "current id + 1" so you are sure it is different
Hi @xstefank, This is a minor point, but I would suggest using a status like 456, something that wouldn't arise otherwise. You could get a 404 by getting the URL wrong. -Ron
no need to specify type on RHS
We need to do something bette than log an ERROR. Either its a DEBUG/TRACE logging error to ignore this. Or its something that needs to be wrapped and thrown as runtime exception. And is there any API on OSGi you can use to check if the syntax is correct and then just do a if correct then ... else ignore,
It would not be here, in HttpPanelSender(or ManualHttpRequestEditorDialog?) by having it listen to the option change (OptionsChangedListener?) and update the button when that happens.
I thought there was going to be a separate monitor for this CM integration descriptor, the handling of which would be contained in the cm-integration module.
what if extension does not return VALID_TO? I guess you have null pointer exception.
object.toString() isn't a null-safe call, while sb.append(Object arg) is doing 'String.valueOf(arg), so it has a null-safe Object-to-String conversion. So we just shouldn't call toString() here.
Better to make "ping" a constant. Fix in all places
use java.util.Objects
Unnecessary (and incompatible); revert.
Gson doesn't run on these versions so I don't see any reason to include them.
This will not insert commas as required.
next time you can leverage switch case for ENUM
1. You could just make calculated limit a field that you set in the constructor instead of reading it here. 2. If you don't do that, I would make it final here. 3. Would it make sense to have a lower default value, like 100? All of these are trivial and probably not necessary.
IIRC, I think the reason for only printing out the exception message rather than the full stack trace was to reduce noise in logs. I think the full stack gets printed if the number of failures reaches some threshold. Maybe reconsider.
one more test case for a reply != 354 here would be nice
Ugh. Why do we have updatePresenceStatusForXmppProvider(pps) and updatePresenceStatusForXmppProviders() that implement the same logic twice? :/ I know that's not related to the PR, so I don't expect you to fix it
Perhaps put sendError(ex); after the branch (since it is the last statement in each "leg" of the branch.
Same here, you cannot create a RawType of the given data, why is this accepted without throwing an exception? Need to check other types. Is this our common handling to ignore a correct "deserialization"?
I feel like this test and the above test have switched titles.
Consider slicing the ByteBuffer instead of allocating another byte[], a bit more math to compute bounds, but less allocations in the end.
this can be an info
this should probably fail on receiving interrupt
why not make "update" a constant too?
we can set variable directly here.
When I did expunge(true) on a jboss7 entity, I saw logging of:  2014-01-28 22:18:47,089 WARN brooklyn.management.internal.LocalEntityManager@2524e205 call to stop management of unknown entity (already unmanaged?) JBoss7ServerImpl{id=mPXYvab1}; skipping, and all descendants  This is because Entities.destroyCatching will also unmanage. So you want an if-else, to only do the mgmt.getEntityManager().unmanage(entity) in the else block.
Use org.apache.flink.table.utils.EncodingUtils#objectToString
not needed, can't happen (don't trust your IDE on this one ;))
"".equals or StringUtil.isEmpty.
why ? how could this happen concurrently ? the workspace modification locks should prevents this.
Decompose this into multiple lines for clarity.
wait.forElementVisible returns WebElement, so you can assign the value to avatar here and then remove the line below completely
Should be done before opening a db session - for to fail fast.
I don't get the idea of using an array here...
Why not passing the expected return value as an argument to mockOffsetResponse(), this way you can control whether the mock object should return true or false.
Don't make this an ImmutableSet when the builder gets converted to a FetchHints it will take care of that
Message seems to be unused. Remove this line?
we don't use braces around singe line blocks
check if you can use fluent api to add the storm tag
This should be strongbox. This leads me to the thought that Strongbox should have instance names (I've raised #693 for this). Cosmetic: Could you please make the first method invocation on the same line as the new instance (and re-align the rest of the chained methods? I've seen the same in a few places across the pull). Thanks!
requireNonNull(finalTaskInfos, "finalTaskInfos is null");
Race condition, multiple instances could be constructed at once.
remove the explicit initialization?
new ArrayList<>(Arrays.asList( should just be Arrays.asList(. you may have to do a Ctrl F and replace all.
Is there a particular reason to make the rect a single pixel shorter and narrower than the graphics object? It causes a black border to appear on the right and bottom sides of the display, which doesn't affect the test fidelity but also seems unrelated to the functionality being tested.
nit: Please fix code style.
This is hard to read, please move out the non-null checks.
Use IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST here (also in other places).
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> escape), we should avoid @Nullable parameter in the constructor.
this state does not exist...
How about to replace calls to root.getLoggerContext() to loggerContext, if we already have the context as a field?
Sorry for the pedantry, but we use { } everywhere :)
memory...single 'm'
This test method contains no asserts. How do we verify that quota records aggregation is correct rather simply not throwing an exception?
if not blank
this one too
fix formatting (some redundant spaces...)
Same here. Magic -1 :P
remove this line and set it in the following RuntimeException?
here we need to use instead this pattern: java java.net.SocketAddress addr; if (channel.hasAttr(REMOTE_ADDRESS_OVERRIDE)) { Attribute< java.net.SocketAddress> attr = channel.hasAttr(REMOTE_ADDRESS_OVERRIDE); addr = attr.get(); } else { addr = chctx.channel().remoteAddress(); }  Calling attr(key) while it is not set will have the side effect to create the attribute. Attributes cannot be removed.
"put(key, val)" will take extra lock that you don't need.
Please construct it, passing in the file?
StringUtil.containsChar
Do we need a new reason code here? Pipeline Failed is getting overloaded.
unused
Throw a NullPointerException if address value is null.
Again, I don't see anything wrong with the existing use of implicit casting. It's much easier to scan.
Do we need a new BufferManager on every snapshotApply? or could we just reset?
@HDouss how about TimeUnit.MILLISECONDS.sleep(this.delay)? makes it clear we are using ms
Why not simply "100px" as String? (100 is a constant here.) This <number> + <unitType> concatenation is unnecessarily complex, I think. This applies to other such occurences as well.
Should we put the check here too?
instead of path separator create new path to make it generic
try using stream api for filtering
space line
This feels like an error situation. If no keys come back, how will the authorization server be able to sign keys? I think throwing an IllegalStateException is better than returning the empty set in this case.
Maybe we could spice this up a tad to throw in another nice aesthetic change?
I don't know this confirmable word :smile: Maybe publisher-confirm would be better? At least that is how PublisherCallbackChannelImpl.toString() represents it...
@danielsuter This can be done more elegantly. Will improve it for you.
extra line
can this be a method reference?
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
Google Java style always uses braces for if and while statements
style nit, put the { up with the if clause
please don't swallow exceptions. Re-throw up the chain.
you should never use assertEquals, it's too error-prone (people flip expected and actual all the time). Prefer using assertThat().isEqualTo() every time.
can we refactor to reduce copy-paste with fromList?
looks like equalsignorecase is redundant as we are lowercasing both images anyway
Magic numbers here and in the line below
This is incorrect. If ps is null, you'd still need to close fos. You need to rearrange the try block to acknowledge the existence of two resources - nesting is the usual approach.
Missing opening "(" before getDescription().
We can't use nanoTime as a replacement for currentTimeMillis - which is a true timestamp. As described in the nanoTime docs This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time..
Nit, I don't think this error message is appropriate. I remembered @lei-xia reviewed this in the previous ticket, this path invalidation is not an error in the server. So keeping info (or warn) may be good enough.
you touched that but did not change to assertThat? ;)
We should simplify this by replacing the if(x){result = true;} by result = x;
shouldn't you be using SESSION_INFO_LIST_TYPE here instead of going from an array to a list?
bad replacement? (not sure about this one)
You may want to extract attribute.getAttributes() into something, so as to not repeat the call a few more times.
Two thoughts here, both 'nice to have' (it's also ok the way it is). 1) Since you're already cleaning up, maybe it's unnecessary to hold _result as an instance variable? 2) Perhaps fenceNode() should already return FenceOperationResult and not FenceStatusReturnForXmlRpc?
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
This IMHO introduces a rather surprising piece of global state into the translation. What about extracting a relativeTo(namespace) method that returns the appropriate Function?
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
Wrap in a if (Logger.isDebugEnabled()) check.
"Finish calculating assignment." Usually, we don't like pasting code details in the log. Consider what if we change the method name in the future?
You have insertAfter(..) and insertBefore(..) on DataTypeList and its View however use insert(Field)Above(..) and insert(Field)Below(..) here.. would a consistent term be better?
Please use case detection API from Protobuf.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
When would this exception be thrown / can it be caused by user input? If so I would prefer a checked exception here (even if it's a DevfileException or something) since unchecked means more to think about.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Can be simplified to: return observable.timeout(1, SECONDS).toList().toBlockingObservable().first();
Should this do a hasProperty() check if someone else calls this (thats not searchAndUpdateResourceType()) ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I think I prefer "Invalid key" as exception message
suggestion assertThat( out.getShelve() ).isNotSameAs( in.getShelve() );
- this should delegate to call two functions above. - also, here name would be a bit confusing from displayName. Maybe @rongrong could provide suggestion.
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as  PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL)  as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
no need to catch exceptions. just let them propagate.
Why this change? Do we still need the doPrivileged?
This should be atomic - looks like it was broken by INT-2856. There is a small timing hole where there's no recipients, or an incomplete list.
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java .put(TESTER_NAMES, testnames.stream() .map(ProjectTesterImpl::maybeQuote) .collect(Collectors.joining(",")));
You can make the return type here more specific so that you don't to cast to SchedulerTask elsewhere
@navis any reason this is changing?
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs, ...)?
What if the server is not associated with a DC but rather with an RC
Please avoid unnecessarily nesting if blocks. This method could be written as: if (getName() == null) { return getPersonId(); } else if (getPersonId() == null) { return getName(); } else if (getName().equals(getPersonId())) { return getName(); } else { return getName() + " <" + getPersonId() + ">"; //$NON-NLS-1$ //$NON-NLS-2$ }
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
This is a little hack for me. Could we avoid these kind of hacks?
Should this return false? I thought we have the theory that blank counts as false, in general.
There are some project types that are not AbstractProject like Build Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstractProject that causes problems in these scenarios but those should be fixed as time goes on (hopefully) and maybe we could try to avoid those problems here. Can we find a better class or interface to check for that also has getTriggers?
a lock is freed inside super.ExecuteVmCommand(); , it is means that status of entity in DB is changed after, the race is left
Unhandled
Are we able to test this method ? Same for updateStateOfReplicas  method.
UnlockImage is performed anyway, so it can just be removed out of the if-else.
use enum name() instead of toString()
typo
Is warn sufficient here?
Do you think this is non-useful? I figured there would be cases where people would want to test code that behaves differently if the SDK claims to be something really old that we'll never fully emulate.
I think these all should go into your symbol table class eventually.
IMHO this should include a descriptive reflog update, since this is a local repository that a user might be poking around in. cf. the output of "git reflog refs/remotes/origin/master" in a repo of your choice.
do we need to ask service for current user role? cannot Principal be added as a method parameter?
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>() );
If it is possible that provided URI is relative and this line throws NPE, argument can be used on the left side instead
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Doesn't the former condition mean that the Arbiter volume is available only for version 4.1 and lower? In that case removing the version check changes the logic and makes it available for other versions. The Arbiter volume should be probably removed completely.
As written, this inputStream will only be closed if any of the code above does not throw an exception. Normally to solve this, you would add a finally block after the catch, and close it there, so that it gets closed no matter what. That said, [whoever opens a stream is typically responsible for closing it](<LINK_0> Since the customer will be opening the InputStream, I think we should leave it up to the customer to close it.
don't printStackTrace, call LOG.error("", e)
Might be able to get away with protected
Kind of picky, but this should be taskFragment instead of mTaskFragment
Can't you extract FS.detect() from the loop?
Can you also verify the error message? This way, the reader can easily tell what kind of error this test cases tries to check.
I would prefer to use same code as in method getProjectRelease  final Set<String> releaseIds = project.getReleaseIdToUsage().keySet(); for (string releaseId : releaseIds) { ...
instead of transport!=null, could we use globalConfiguration.isClustered() ? when reading the line, it seems like we are avoiding a null pointer exception (like protecting) for an eventual transport null instead of something that explains that indeed it needs to be clustered to check it's a coordinator
Why the + "\n*"?
I would put the return 0L here. This is probably the one and only place where you do not propagate the exception
You don't want to move them all to hamcrest?
It'd be better to do it as a fall-back only after the normal approach, as I suppose using the service loader is slower.
Does it need to be public is protected not enough ?
This can be private, I think
rename to hostCandidate
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
here too we could use getClass().getSimpleName()
This value could be changed during runtime to 0 which should abort it, not cause the thread to never sleep. How should a change from 0 to >0 be handled? I guess admins are used to clicking that reconnect button?
Can we add session handle to log
you dont need this line You can simply do Metrics.newHistogram in the line below
This test should also test the case StringUtility.toString(null)
TRSRTransformation.identity would probably be better here. And new matrix only needs to be created in the "default" case.
isUnauthorized 403
Please change this hardcoded "btc" to checkerInfo.getCurrencyBaseLowerCase()
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
Do we show some icon If visibility equals to public? If no, why? I think it is not good behaviour to show icon for private project but not show some icon for public projects.
If I may do some nitpicking on the name, the actual exponent is retry in this statement, the variable called exponent is a factor (exponentialFactor if you like).
I think its good idea to fail with meaningful errors instead of a potential NPE. Although, is this new contract necessary as part of this change? 1. Is it possible for kafkaConsmer.endOffsets(...) to return null in the first place? 2. If yes to above, have we seen any issues around NPE before or is this purely from the standpoint of defensive programming?
API breakage errors. You should declare another method and mark for deprecation this one.
I think you could read the file contents with many fewer lines of code, especially in Java 8. Something like: java return Files.lines(filename).collect(Collectors.joining(System.lineSeparator()));
'static' could be added, since it doesn't rely on any particular instance of the class.
The empty string in the constructor is redundant.
Why this field is final ? It is only used in method scope.
String.format?
If getNextMergedRow() return null or a full row, then we don't need to translate from !isPresent to null.
Please use parent.is here!
Make null-safe: if (m_decimalFormat == null) { return null; }
*style*. same line
nice! Thank you. Really appreciate that and I think it's for the good
cache?
Ah this was meant to use the guava Lists
Is the old method, <code>updateFeedbackQuestion</code> still used in the code?
II think this code was also inherited but it might be clearer if the scope of this block was reduced to activity.getResources().getResourceName(item.getItemId()) and we just do a null check on resourceName.
This won't work... now your just breaking builds without proper checkout. Please make it throw AbortException.
This should probably just be !parents.add(p) instead of !contains and then eliminate line 222. That would eliminate the double lookup and potentially detect a parent loop one step earlier (I think when a parent points to the original project)?
There are a couple of copy-paste lines here and there, could you please refactor it a little bit? e.g. extract the reader.readEvents-reader.commit loops to a method. The assertion part (listFiles, checking the count, removing from the expectedLeftFiles, checking the emptiness of it) might be possible to extract too, to improve the readability of the code. (e.g. void assertExpectedLeftFiles(String... expectedFileNames))
Yes, what Tor said: Please add a dispose() in LayoutCanvasViewer and chain the dispose methods.
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
I think we should close the StringReader after unmarshaling.
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
Already adding network incompatible change, might be a good idea to encode more boolean flags into byte[], potentially also giving a way to add future changes. It's small amount of data so probably not really worth it as an optimization, but it would allow to add 5 new flags later while still allowing new clients to join old servers.
I think we should create a defensive copy of the Map
Minor: use AssertJ org.assertj.core.util.List.list and static import for readability.
There is actually yet another error here: this should be java int start = Util.toIntUnsigned(getValue(ir));
Will this be OK across different screen sizes? Should we put the 35 in dimens.xml?
Might be worthwhile to also factor this out into a method getInstructor to be consistent with getStudent below.
well, of course I can read the code and understand, but - still, maybe enum is better.
No big deal, but if you modify anyway, you can add a break here.
Is not the status code to be Response.Status.INTERNAL_SERVER_ERROR?
instead of creating a new StringBuilder object, you could maybe do something like: text.append("Date: ").append(date.toString())); (you might need "\nDate: " depending on what the line situation is)
Missed one
Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?
Not important now, but I wonder if we should consider consolidating these core initializers into one so we only have to iterate over the beans once.
We talked about using docker-fixtures for tests in this PR, though it is more work to set up.
these 2 for loops should be replaced by a single entryset iteration
The entire emails is the join link?
Doing the refactoring of the OH2 bindings, this default implementation does not appear to be helpful. In most cases, the Thing is simply expected to go ONLINE once the bridge is ONLINE. This means that this method needs to be overwritten, so the question arises if super. bridgeStatusChanged() should be called at all or if the logic isn't reimplemented. Both variants are not really nice. I think we should change this line to ThingStatus.ONLINE as this will be the expected behavior in most cases. Whoever needs something else, should override the default impl. @sbussweiler WDYT?
Does this one need to be changed to '...' too?
May be you do not need another submonitor conversion here?
Immutable?
cannot convert to double value, same reason
As it's a nullable field, null protection would be good just in case: if (occurrence.isValidated() != null && occurrence.isValidated() != validated)
Why are you checking the members inside the compute block? I smell race conditions since the membership change does not have to lock this map.
I'm not a fan of this solution - it creates an additional coupling between the different commands. How about the following approach - we should only update the status if the image is on a DATA domain: [pseudo code] StorageDomain sd = getStorageDomainDao().get(image.getStorageDoaminIds().get(0); if (sd.getStorageDomainType().isData()) { // update status to illegal... }
It seems like we can add two storage domains at the same time
This is actually adding functionality, since in 3.0 only system-disk is bootable. I think method should have an oldAPI flag, and in such a case break on the first system-disk and skip non-system disks.
Should this be a write lock because we might delete the page if there is not enough space?
Should be final
Iterator could return multiple items erroneously and pass.
unnecessary array new: {{true}, {false}} should work here
We also have to override getEventHoverToolTipInfo(ITimeEvent) to call this, with the event's time. For markers...
The previous setting INSTRUCTOR_PERMISSION_MODIFY_SESSION is correct for previewing. This is correct for moderation only. Refer to checkAccessControlForStudentFeedbackSubmission.
@linzhp why is this needed? after I removed the instanceof the tests are still passing, if this is really required can you update the test to reflect the case?: path instanceof BuildTargetSourcePath
Yes, we rely on the I18nProviderImpl to be present and running. Not nice, I agree.
"positionX" and "positionY"
Isn't this constant and shared across all producers? Then can't it be static?
Better use ImmutableSet to avoid accidental changes. Might as well use it for the above method as well, should be a NOP in the general case where we are passing immutable already.
Just remove the try/catch. An exception will fail the test.
Fix warning: suggestion KeyedMultipleInputTransformation<OUT> keyedTransform = (KeyedMultipleInputTransformation<OUT>) transformation;
Is it possible that the same project is added to the list twice?
rulesList will never be null, widget#getVisibility always returns a list instance.
Ditto (same for the new methods).
MetaObjectStoreEnvironmentBean was added to ensure that our config bean changes were backwardly compatible with the old arjPropertyManager approach to config (ie did not break the old semantics of arjPropertyManager). I would either keep the old code or use arjPropertyManager instead (but the problem then is that we want to discourage the use of arjPropertyManager)
Smells like a bug. Are you sure it should not be equals?
org.apache.commons.lang.StringUtils.isEmpty(String) is available for null safe string checking.
I believe the preferred method is to do one cache.get(nodeId) and then check to see if that result is null. I believe containsKey should be avoided.
Can you repro this on master? If yes - definitely worth filing.
Do we really need to make it info level?
We shoul get the exception (most likely if different type as DynamicUtils is in jbpm-flow so ProcessDefinitionNotFoundException is not available there) here and then wrap it with ProcessDefinitionNotFoundException and rethow it
Multi return is forbidden.
@kachayev one question... isn't this assuming that we are talking HTTP/1.1 ? I mean for 1.0 we would need to add the keep-alive imho
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
I wonder in which case PUT is not found when updating Ttl for certain key. And it might be worth a warn here.
Add a break to this if? Then, this condition is not needed.
Ew, that just looks icky. Admitedly less efficient ... bypassing the reservation but still not breaking the loop. Likely less than a microsecond of "spin" even if the pool had 500 idle connections. Reads much nicer:  java for (PoolBagEntry bagEntry : bag) { if (removable > 0L && connectionBag.reserve(bagEntry)) { ... } }
I think that it would be better if the result message used "Space" instead of "OrganizationalUnit". What do you think?
id is the id of the container. so it means in the scope of this container "createItem." + this.getId() can be pre-computed for the container, rather than re-computing it each time. Could you pre-compute this in the container level.
I'd use a different name, e.g. doStream
I think everything from Optional<Status> statusMaybe =   could be replaced by: java return statusMap .flatMap(StatusMap::getToStatus) .map(status -> { if (status instanceof ChargeStatus) { return new MappedChargeStatus((ChargeStatus) status); } if (status instanceof RefundStatus) { return new MappedRefundStatus((RefundStatus) status); } return new UnknownStatus(); }) .orElseGet(IgnoredStatus::new);
This will not include the line break. Probably should append('\n')
Can the filteredHeaderNames be put into a case insensitive TreeSet? Then this nested loop could be converted to a contains.
what about:  SELECT x, array_agg(y FILTER y > 1 ORDER BY y), count(*) FROM (...); SELECT x, array_agg(DISTINCT y ORDER BY y), count(*) FROM (...);  ?
should just be inside try block
this line is gone, why?
Move this call down to around like 128.
Typo: attemp_t_ToUpdate
This is not required since you are checking for null in view
This isn't localization friendly. We should move the word Error to our strings.xml file.
This won't work on blockdevice. Take a look at how the StoreMigrator does it.
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgWithFreshAcsrfToken, instead of getTokens and getTokenValue)
Docs (<LINK_0> you must always check isConnected() before initia...
Number of rows of input does not change since we don't allow reshaping of layers. Thus, checking the number of columns is enough.
Google's Java style requires methods to be lower-camel-case. e.g. convertChunkSourcesToModules() This looks like Python code to me. :)
this should be moved out of the try/catch at all filters
duplicate
HQL/JP-QL
Shouldn't we close the FileReader after the unmarshal? We could also pass the File directly to the JaxbUtils.
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to put fileInfo into both write cache and read cache. And we need to increment refCount by 2 because we put that FileInfo into both read cache and write cache
How many times are we going to visit each field? I have the impression that this recursion will visit attributes multiple times for no reason but maybe I am wrong.
Failed to getTable
isUnauthorized 401
@CheckForNull
You might want to move this into a shared helper method for other tests which need a temp file with random data.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
Can we please add a CommonConnection.getAllRegionInfos(TableName) method instead?
cruft removed
same in line 45
a lock is freed inside super.ExecuteVmCommand(); , it is means that status of entity in DB is changed after, the race is left
use Arrays.fill instead for loops
why relaceFirst instead of replace
Format this line
you don't need the zone in the constructor but it's not that important, also you need to set the text since it won't autogenerate correctly
Maybe do the commonColumns same way you did in upgradeOutcomeTableRevision2To3 for consistency? Not a big deal just one way or the other so that they match.
why public?
I thought that we did not need to have this mapping in the compute engine
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request);
Does it really make sense to have a plugin with multiple secure-stores ? What would be the rationale behind it ?
break the line
again: removing the explicit initialization: worse, not better
suggestion var service = getCandidateServicesToMatch(serviceId)
Should there be a check to make sure the asset is non-null before modifying it?
Shouldn't this code run even if mHasWifi is false?
after this line, call collector.getOrThrowException() to stop execution if there are problems.
Where is the aggregation?
Could we please update method name. I think the name should contain just **IfDataTypeIsStructure** or **WhenDataTypeIsStructure**.
Shouldn't you be getting this option in a way similar to this?  java SharedPreferences prefs = context.getSharedPreferences(PushPlugin.COM_ADOBE_PHONEGAP_PUSH, Context.MODE_PRIVATE); boolean force_show = prefs.getBoolean(FORCE_SHOW, false);  Accessing FORCE_SHOW directly is only targeting the String defined in PushConstants, and a String is always true'ish, thus making it not an option to decide on.
Can you move this functionality to IjProjectPaths?
You can move the inner loop out of the outer loop so that you dont have to set all the fields for each split. That way you will be able to reuse the builder
Why the heck are we painting all columns ourselves? We only need to draw column 1 containing the graphical commit tree. This suggests a nice two-liner to fix this: replace above by event.index == 1 and...
I think Local.ROOT is probably a better choice.
These first two test methods are identical except for the slice creation, and can be replaced with a single method and a data provider.
should this have a ,  to match the rest of the pattern?
I think we should avoid printing stack traces and make the app crash... Could we setup an error activity or handle the error as transparent?
I don't understand what command parameters have to do with key bindings. The way you implement it you will also skip the adding of parameter values to the tooltip of menu items. Also, why is it necessary to distinguish between menu item and tool item regarding the tooltip?
Can we replace these 2 lines with createTreeWalkerConfig?
Why make it public?
still not a fan
LOGGER.info? Maybe LOGGER.warn?
remove !=null since null instanceof WrappedMessageContext will return false
Please use ""
Use static strings.
Avoid variable names like event1
There is something wrong with the button text. You set it to default here but it's not set to R.string.replace_bearing when we record bearing (only if we create the widget from scratch and there is an answer).
Before this change, we had the eventDeliveryLock semaphore which was only released upon receiving the ack. So if the ack is lost somewhere, the shard gets stuck for ever. Was there any reason why we didn't release it within restartFrom here? Looks like we are fixing that issue in this change. Shouldn't adding this step into the Semaphore solution fix the issue? What do we gain on top of that by this new solution?
Ditto about interfaces
- Suggest we loop through the complete FontData array.
Should maybe be "SocketException has occurred"
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
why it is not a constant!
An empty loop can be written as while (vcfReader.read() != null);
as not found typo, should be  was not found
Please keep this.cell near the related fields (previousFamily & cell count) below
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
This line is not needed
Is this a safety check? Whats the case where this would be null?
pass in the metric registry
There is a pretty frustrating race condition here, unsure if it is worth fixing. - ModelAndConsumer cachedModel = localModelCache.get(modelId); returns from cache successfully - Model is removed from cache as it is only referenced by a pipeline (updated via cluster state change) - Search adds itself as a consume too late and it is evicted The referenced model from the get call will still be around. But the next call for the same model will load from the index again :/. The only way I could see of fixing this is locking here (which defeats the purpose of the fast get). Since the cost is low, it might just be OK to have this as it is recoverable later.
Lines 95-102 should be at the beginning of the execute method rather than in an accessor.
Is this really what you want? If you get an exception, you'll be returning null for a query on a record that exists, but that can't be parsed.
Would be good to remove some, if not all, of these log messages before merging.
The format of the names is inconsistent, also remove duration.
Better to just add a throws to getPolicy and not catch IOException if you aren't doing anything with it.
.first(Audience.class) -> .getAudience() (audiences do have special handling in command causes)
processInstanceKey.isValid() == false -> !processInstanceKey.isValid()
Do we wanna add those array list into accounting? (e.g., inMapStreams)
I'm not sure if the fix should be here but the current implementation raises an FP for:  "%%(key)s" % {"other": "str"} # OK. Pylint FP  The problem is that createFromPrintfStyle returns a StringFormat with 0 replacement fields, so we enter checkPositional and then raise because the rhs is not a tuple. Either the StringFormat should return Optional.empty() in such case, or this logic should be updated.
actualEntry should be a better name
No need for a mock.
You don't need this restriction and createAlias calls, I think you should have one restriction in place of the 2 lines above like this: Restrictions.eq("m.patient", new Patient(1)) Alternatively you can load the patient by the patientId first and use the loaded patient object in place of of new Patient(1)
assignedPartitionIds can get large. We may want to log the whole set only in debug mode, in case addPartition gets called many times on startup.
Is a service user required here? Doesn't the request require enough security context to be able to derive the Resource type anyhow? Could this simply be:  return resourceTypes.stream().filter(rt -> { if(slingRequest.getResource().isResourceType(rt)) { return true; } else if (slingRequest.getResource().getChild("jcr:content") != null) { return slingRequest.getResource().getChild("jcr:content").isResourceType(rt); } ).anyMatch();
Why don't you use formatCurrentTimeForId() here like the line 217 below? Likewise for the line 115. We can pass the time as a parameter to that function for general cases rather than just current time only.
Shouldn't this code run even if mHasWifi is false?
Insert a space after if
These should not be needed.
check if you can use fluent api to add the storm tag
gt 120
Why do you use fori loop instead of foreach? BTW I would use stream API here
Any reason to use round-robin? Can't we just put a certain number of keys to split at once?
ArchitectureType.forValue(rs.getInt("architecture")
Same here, Chat takes a token, not the access key. (Look out for CommunicationUserCredential which always wraps a token)
codestyle - move ); to next line plz
This message looks a little bit misleading, or am I mistaken?
Excuse me, I want confirm with you about "A suggestion for a follow on change would be to add any permissions only projects as candidates even if they are not yet parents since that is likely their sole purpose: to become parents." here can I understand "to add any permissions only projects as candidates " as to delete Line 54?
Replace with SubMonitor.convert
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
let's change this if to - if (Guid.isNullOrEmpty(storagePoolId) || !FeatureSupported.refreshLunSupported(DbFacade.getInstance() .getStoragePoolDao() .get(storagePoolId) .getCompatibilityVersion()))) end eliminate the else cluse from line 105.
extract into method?
per the style in rest of this file, add a space after "if": s/if(/if (/ and same for similar if statements below
I think you need a tearDown method to ensure that Locator and Servers are all stopped in every VM even if any tests failed. You could probably move destroyRegion and destroyDiskStore to tearDown as well (or remove them?). Close clients 1st, then servers, then locator (see the order of VMs in Arrays.asList):  @After public void tearDown() throws Exception { for (VM vm : Arrays.asList(getVM(4), getVM(3), getVM(2), getVM(1), getVM(0)) { vm.invoke(() -> { if (clientCache != null) { clientCache.close(); } if (LOCATOR_LAUNCHER.get() != null) { LOCATOR_LAUNCHER.get().stop(); } if (SERVER_LAUNCHER.get() != null) { SERVER_LAUNCHER.get().stop(); } clientCache = null; LOCATOR_LAUNCHER.set(null); SERVER_LAUNCHER.set(null); } } }  You'll need to hoist anything (such as clientCache) to be a private static field/var in the test class so that you can reference it from tearDown() to close it.
Why did we switch out the old code back to this?
Variable with constant like name.
this might not be true for 'executeDelete()' when we implement Multi object delete API. Change this to executeDelete() itself taking the content length.
Since there is a default hardcoded test resource group you can get rid of the null or empty check and just use the following here. java String resourcegroupname = Configuration.getGlobalConfiguration().get(AZURE_RESOURCEGROUP_NAME, TEST_RESOURCE_GROUP);  This is effectively a get or default.
:ant: multicast is one word.
We need to test the regular constructor without a custom serializer.
please fix
This condition is hard to understand. Do you simply mean if (addressModelNode.isDefined()) ?
Should anyone be able to create a new instance of reference instead of GitProjectSetCapability? I would rather make it package-level.
please dont remove explicit initialization
This is the line of code from the else branch. Since the version is above honeycomb you should use findPatientView = (SearchView) mFindPatientMenuItem.getActionView(); from the if branch.
Should never happen btw
As above: private, 100 chars, use error result instead of doOnError.
This handler is not used at all, please remove it.
Re-use temp file
In the #valueOf(int,int) method, we could simplify the resulting bytecode slightly by eliminating i and using fromIndex as the index variable within the loop. As in: java for (; fromIndex < count; fromIndex++) { ...
what is this close and open curly brace doing?
Cosmetic: please align this path parameter with the annotation above.
This is convenient API, but I worry that this obscures the configuration properties outside of code... like if one is manually editing the config file or using the shell to set properties... the code doesn't match the literal property names people use elsewhere. I think a better implementation is to stop requiring properties to be prefixed with "general.custom" and allowing them to have any arbitrary property name in our config. Then, we just let SPI implementations do whatever they want for their property names.
Only the Lower/Upper constraint should be disabled. In this case, unrelated constraints on the same element will be ignored too
Remove all the sharedpreferences here instead of using clearToken() method. When one logs out, the application should clear all the saved 'SharedPreference values'. clearToken() will only save a blank passcode value and all the remaining sharedpreferences will remain intact. You can save the Instance Domain to make it convenient for the other users to login but it is already handled in LoginActivity.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
trade off here but I would trade the possible ClassCastException against one uncovered case (that should throw an IllegalStateException )
Label should be reporting.parameter.onOrAfter
Flush after you write the data....same thing for all the places you write data.
What do you think changing the name to memory. We do not know whether it is in kilobytes?
Missing final
This is already done for you by the super class you extended
Any reason to use an unmodifiable list as the list is already a newly created one?
no longer necessary, after changes in xml.
I wonder why it is fine for DoubleValidation if the value is not String or Double? IIUC it should not pass the validation if you send here any other object that has nothing to do with any number. IMO you should check if the value is String or Number, if not return fail.
Good catch. But I think we should still replace the File.separator with a ..
Please use a instance-variable for the version, this way we can configure it for each service instance separately. Also extend the service-descritor to support the version-field (and add a default-value)
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the value anymore.
break the line
What do you think about putting this in a class constant instead to improve visibility/maintainability?
It would have be easier to review if the refactoring to use an ExpectedException would have been done in another commit
use for (Map.Entry entry : activeConnection.entrySet() ) {
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been merged and the DifferenceState. It seems very likely that setting the DifferenceState to a proper value (either MERGED or DISCARDED) would allow us to not use the MergeMode in the UI to compute the icon to use on a merged diff. I want to take the time to consider all that fully.
There are other places we perform the same validation. any scope for reducing redundancy?
I think we should leave the NoSuchMethodException here and just wrap it in a FacesException.
please directly call CrashReporter.sendUnhandledCaughtException(); and remove the utility function.
is this needed for the test?
I discovered sometimes I do want to enable displaying SPARQL. Maybe not for this patch, but is this log level the best way to make it easily accessible or we need to do something else?
space after if.
I think you have an additional "\n" at the end of the new error message.
wrapping
Should this be try with resources? I don't see the reader closed
This is not going to work as Keycloak may be exposed on a different context-path on the reverse proxy. I.e. frontendUrl could be "<LINK_0>" while Keycloak is listening on "<LINK_1>".
Does it need to be package private? Can't we make it just private?
This means you're also trying to manually get things from the media folder if a file has no prefix? Why? Also consider that if a jr://file/ URI is set, for example, you'd end up with a path that looks like /path/to/media/folder/jr://file/name
Can be possibly moved to shouldShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place.
This step is same for standalone as well as domain ;-)
nit - for me creating ke is unneeded. Create the exception directly as the argument
it sounds a bit strange to use PSK_LENGHT_BITS constant for virtualHost length.
Should be updated to use getSupportActionBar() instead of getActionBar() as in the [guidelines](<LINK_0> to ensure backwards compatibility.
We're still violating encapsulation principles here. We don't want to modify the collection and assume that's going to be retained. We should be building up the content and then throwing a new collection at the DTO, or figuring out a way to return the addContent method back to the OpenAPI DTOs.
use rewrite than getVisitor
The duration variable should be qualified with the this keyword.
shouldn't we have an array of configs (just like the others)?
The other formats are actual formats (HTML or MD) whereas simple is just plain-text. Maybe instead of simple, it could be txt or text for plain-text?
Please use com.palantir.logsafe.Preconditions. Granted this doesn't have any args, but it does mean the message will be visible in our internal logging infrastructure without us having to trace back by class and line number.
Spatial reference is always null, hence, drop this variable is use null below.
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down to selectReadReplica?
Same as above, maybe I misunderstand something
May I suggest a pre-check for getParameterCount() == paramTypes.length in order to avoid possible allocations coming from getParameterTypes()?
This can be simplified by using the Kuali's DateTimeServiceImpl
I believe that setters normally return the type/value they just set as well.
please include the VM's ID as well
Not that it matters but it would be "sourceFile"
Please change the line 38 to also use EnumMap<> for consistency.
Shouldn't we rather compare the whole sequence data?
isnt segmentsMapToFind? (not Maps)
This part of code (up to line 370) could be extracted to the end of the method. Currently it's duplicated.
NP: As this is now abstract, it should say "...json data for component ...".
maybe we could open another commit/pr for this
Cosmetic: Curly braces on new line.
Might as well call delegateFirehoseFactory as firehoseFactory from the start. The renaming isn't doing much useful anymore.
Instead of returning here based on course access, we should make setHasOptionsMenu() dependent on it like: setHasOptionsMenu(courseData.getCourse().getCoursewareAccess().hasAccess())
In addition to checking these for null, now that TimestampedEntityTranslator is not extended, we need to manually also translate the created/updated fields.
Need something better here?
Could you remove Error message from log message and give to logger the exception ?
Why don't you store the pattern in a final static (instead of only the String and compiling each time)?
Would change this to Objects.requireNotnull
put some context to wrapper exception.
Why change to use the String instead of char?
We can put one parameter per line as this line is long:  public static Map<List<String>, RichColumnDescriptor> getDescriptors( MessageType fileSchema, MessageType requestedSchema, Map<parquet.schema.Type, HiveColumnHandle> typeColumns) {
is a break; missing here?
similarly here: java assertThat(Sets.difference(generatedMethods, originalMethods)) .containsOnly("delegate");
I think here we could just us a file-handler just the configuration is less complex and slight less overhead as there is no WriteHandler.preWrite() invoked. Really not a big deal though.
Can you set the message inside the method avoiding passing it as an argument?. It's always the same
The PROPER solution would be to make getContainerItem NOT return null, as Null ItemStacks are not valid anymore in 1.11
s/id/ID
same thing here, it doesn't need to suddenly start working after the first experiment, plus is this test strictly necessary, considering it's subsumed by attemptsExperimentAgainAfterEnoughTimeHasElapsed
can be inserted to the if bellow (redundant if build is not captured)
Must be Outcome.Benefit to keep good card
Replace this with The number you have entered (<Number>) is too small, it must be at least 0
This should use a PageLink method to generate this URL.
newRefreshToken!=parameters.refreshToken looks always true so redundant: this operator compares references to the strings but not content.
This is not an integration test, you're working with a mock version of Github. This test method belongs to another class (and another ticket)
Here I have 4 connections and the dialog shows 4 lines with <unknown> as a label.
You can remove braces.
Typo; Should be authentication in lower case.
I think this case shouldn't be allowed?
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
not correct
Is this what we want here? If so we should have it as a Log method then.
switch/case here too It's not just for the sake of it ;) But for example, if we ever add new types of ITmfStateValues (which we've done before), we would then get warnings here asking us to handle them, which is exactly what we want.
this does not handle the empty 'lists', it will throw an exception
How about in-lining o1 and o2 since they are not reused?
I would rather get rid of RuleSetAdapter because: * it assumes that rules in RuleSet have particular semantics (e.g: only one rule matches) * it wraps and executes rules in a different way than during actual optimization * it doesn't allow to test how rules interact (e.g: trait rules before other rewrite rules) * it only allows to test rule set which are grouped in RuleSet, but we might want to test not grouped rules (e.g: trait rules and rewrites). * it is a work around RuleAssert limitation of testing singular rule. I would rather test multiple rules explicitly in RuleAssert with assertions.
Platform.exit()
THIS!!! THIS IS THE PROBLEM!!!! Look, it needs to be Integer.parseInt
So I believe if IPath bundlePath and IFile bundleFile is not null that means we have a workspace archive so we should use ArchiveSourceContainer as before. But if those aren't in the workspace we could fallback to using the ExternalArchiveContainer.
This seems wrong/redundant. The check !file.exists() && !dest.exists() will often return true before reaching here. We will only get the IllegalStateException if !file.exists() && dest.exists(), and the catch block after Files.move already throws the same exception if we are in this state anyway.
This log is too frequent. Please remove it and add only "info" log to the Auditer class itself where we will have better control on using these debug messages.
Perhaps 'Not unpacking {file name}... 'would be better - this gives the impression that there are no unpacked variables in the file - but this may not be the case - config could be overriding this.
If list.get(ListKey.ALL) returns a reasonable upper bounds for the size, I think that an ArrayList would likely be faster.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
externalize
This would be a good time to change this to fire exception via the log object, i.e. org.infinispan.util.logging.Log.invalidConfigurationIndexingWithInvalidation
I'm not certain what the correct thing to do here. If there are multiple groups in flight and the outer observable is unsubscribed, do we want to unsubscribe the open groups, enqueue onCompleted elements on them but let them run, or something else? Window has this anomaly as well where the unsubscribed outer may never deliver an onCompleted on the inner windows and thus they stall.
Change this to a public static function that can be called from the adapter, instead of duplicating this logic there.
Please change to !message.trim().isEmpty()) {
looks like you missed these
@cuenyad use factor variable
Could we use PreparedStatement parameters rather than String.format()? I don't think this would be exploitable but I think we should do it the right way on production code. Also for the other places the idiom is used.
This is early exit, so you can move the else part unindented below.
I can't remember why it needed this? And I get paranoid about it since I spent months tweaking the multi server configurations to not break.
Convert Unspecified to constant. And there's probably a framework constant for this string somewhere.
Why was the reflection needed here? is it due to API levels?
I think you want to pass in the errorListener to super
This log doesn't look very useful, we should at least log more information than just the courseId.
Please write a method ProcessService.getNumberOfChildren(process) which is calling the ProcessDAO to count on database
rename 'listeners'
We should abstract updating of dependent phenotypes as out of sync from this service. That is, it should be part of the Middleware API call.
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
Do we need this? The java doc for "yield" says, its rarely appropriate and used for testing or debugging.
Doing it this way will not update the actual Pod spec. I think we need to add this in createOpenShiftDeployment()  PodSpec podSpec = new PodSpecBuilder() .withContainers(container) .withVolumes(getVolumesFrom(volumes, workspaceID)) .withTerminationGracePeriodSeconds(OPENSHIFT_POD_TERMINATION_GRACE_PERIOD) .build();
We should just expose getRemoteAddress()
I think all of the stuff that modifies the response needs to happen outside of the thread after start is called. Otherwise, the method will have already returned, so I'm not sure what would even happen if you modify the response.
You can use CollectionUtils.toImmutableList
'e' is not logged
You should use here errorFormat instead error and "...{0}",domain.getId" instead "{0}" + domain.getId()"
Better to log the error
Please refactor DbFacade.getInstance().getLunDao() to a method...
Better to constrain it to List<Object> instead of ArrayList<Object>.
Maybe we could directly pass UpdateMode if isInsert is only used once?
It seems like we can add two storage domains at the same time
Should this be IllegalStateException? Please correct the message.
i think it is probably better to just get the whole thing as lrange(...) in one shot, and probably best to not bother fetching the size (again, doing it as a two-step you are leaving yourself open to concurrency problems. imagine that while thread A is in the middle of iterating through a peekAll, thread B starts rapidly popping members out.)
replace everywhere "symbol instanceof VariableSymbol" by "symbol.isVariableSymbol()"
There's a utility class for this. Check out DisplayUtils.dpToPx()
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
Returning entity.toString() could be ok. iirc, the stable id should be the same as the canonical path except for the very long canonical paths.
InterruptedIOException
Also, in case there are two inputs to a job w/o the same number of partitions but using GroupByPartition, how do we reconcile and propagate the EoS marker?
You will probably need to change this auth and the accept type when completing teh request verification in the mock tests.
what's the point of doing this?
As a nit, should have a null guard here.
Also too many empty lines... Please compact the code a bit.. Thanks!
This can be collapsed to a single line.
These should probably be below our lifecycle methods since that would follow the logical flow more
Nice, i was wondering if this would work for overloaded methods and it appears it does (i.e. findSliceInvoker1 is defined if a previous findSliceInvoker exists.
no need for the additional check if propertyParts.length is ok?
That's wrong. Please see org.intellij.erlang.psi.ErlangSpecFun#getReference and isReferenceTo() method.
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
the default should be made a constant somewhere instead of being defined in multiple places
Rename this variable. It is no longer accurate.
We should abstract updating of dependent phenotypes as out of sync from this service. That is, it should be part of the Middleware API call.
If a branch gets deleted can newObjectId be null so that in this case ObjectId.zeroId() should be used as new objectId?
Remove this :)
why starting from the identifierToken() and not directly from parameterUsage ? You can directly strart from the parameter parent.
I'd like to keep formatting/mark up out of our controllers. Maybe we could put the queryText into its model attribute and use it in searchResults.jsp
Fix bug
I think CDA is not the place to set values
Is the configuration object always available also for already created bridge things? If it could be missing, this (<code>getConfig().get(POLLING_INTERVAL)</code>) could return null and your intValue call will raise a NPE.
We could probably use getItem() method here, for consistency.
nit: would case switch be better?
Extra asserts?
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 21 to at most 20. [![rule](<LINK_2>](<LINK_0>
Why don't you want to use curator TreeCache for that? In that case you won't store the list of caches.
I think everything from Optional<Status> statusMaybe =   could be replaced by: java return statusMap .flatMap(StatusMap::getToStatus) .map(status -> { if (status instanceof ChargeStatus) { return new MappedChargeStatus((ChargeStatus) status); } if (status instanceof RefundStatus) { return new MappedRefundStatus((RefundStatus) status); } return new UnknownStatus(); }) .orElseGet(IgnoredStatus::new);
String.valueOf
Please re-format this method in your IDE, I suggest using the Eclipse code formatter located at config/engine-code-format.xml (If you're using IntelliJ IDEA, you can install the "Eclipse Code Formatter" plugin.)
you need to check for null case
order of operands
if that previews is showing cleaned-up code, why is this one still here?
' ' should be enough, no need for a String object
This pattern makes it easy to know what placeholders are available and to directly navigate to the implementation.
needs some doc , on why you need this
I'm thinking that we should provide a different strategy for some block types, such as table, numeric list and bulleted list - there's no need for <br/> <br/> to terminate these.
Don't return, just do a continue so other modules can still add their state systems as children.
Move this binding to StorageModule.
So the issue was that they had _case in an identifier? Should you be testing for _ afterwards as well?
Could you, please, explain, why verification the command palette had been removed?
speces before and after "+" :)
You could think about extracting the listener to a local variable: java final ChangeListener<Boolean> tabListener = (observable, oldValue, newValue) -> { if (newValue && !repositoryManager.isRepositoryLoaded()) { repositoryManager.triggerRepositoryChange(); } }; this.mainWindow.getApplicationsTab().selectedProperty().addListener(tabListener); this.mainWindow.getContainersTab().selectedProperty().addListener(tabListener);
Looks like spurious changes with no changed behaviour in this file. Necessary?
nit: for src code readability & more explicit error message java Preconditions.checkNotNull(p.getParent(), "Path for page %s can not be root", pageId); Files.createDirectories(p.getParent());
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Why do we need new File(file.getAbsolutePath()), instead of just using file?
These is a most ugly way of work, you crated wrapper, passed all parameters and you are passing a list of canDoMessages all over a code in order to fill it. Such approach is wrong (I know that it is used at our code, but sometimes someone should do something smart), you should use return value.
Use UTF-8.
Use getSimpleName instead?
can you add some docs around this method.
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Missing braces
can't you reuse these mappings form the VmMapper?
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
same here:  this.left = checkNotNull(left, "left");
Remove this line so that you fail on assertion.
if a column was missing, should we ever match it in this case? fn.apply(value) looks a little bit unusual as value is really an element from the Range of the function and not Domain. may be it should be...  return new BooleanValueMatcher(false);  @xvrl ?
Is this really more readable? (IMHO it's not)
Seems possible to simplify. I'm not sure, but is this just?  if (profile == null || profile.email == null) { return user.getUsername(); } return profile.email;
Actually, in what way does this change relate to adding a new status command? Because this change affects all other CLI commands perhaps it deserve its own separate commit. Anyway, just making sure this change landed here voluntarily and not as a result of mingling with another context...
@vilchik-elena Style: I would have created a variable for (ExpressionStatementTree) statement).expression()
deviceIdentifcation => deviceIdentification
from L257~262, you can use Strings.repeat
This should be a triggered ability of the enchantment, not a trigger gained by the creature
A question about the purpose of doing this -1 test. I do not understand how this -1 works in Socket InputStream. I would expect that int read = in.read( buffer ) will block read until we get something from InputStream, unless an exception is thrown. However if we get an exception, we will never get to this if.
Why do we need to change it?
minor: could also use CacheUtil.getDistributedObjectName(CACHE_NAME) instead of string concatenation
Should go into @ After method to make sure it clears authorizations even if an assert statement fails.
datum.toString() seems suspicious
The fail()method throws AssertionError which is an Exception. Either use ExpectedException or change your catch clause to catch the exact exception you are expecting
what if storageDomainDR.getJobId() != null, won't we need to use storageDomainDR.getGeoRepSessionId and storageDomainDR.getStorageDomainId instead of getParameters().getGeoRepSessionId() and getParameters().getStorageDomainId()
This turned out great, I think it's really easy to understand exactly how we get retries to work properly with this code.
This can't be true, as Math.min() would return max if nsz would be > maz. :-) I think you really meant to write: if (buf.length == valid) { if (buf.length == max) throw When buf.length == valid we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == valid) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw ...
Follow the more general approach of getCellValueFromDataTable (include a table index instead of hardcoding 0).
How did you convince your IDE that primaryIP is definitely not null here?
If we want to be totally safe here, should we add || pages.isEmpty()?
Wouldn't it be more efficient to just create patient dao once?
what is the value of getting the instance this way?
please move it to resourceManager.resetVmAttributes
Nice. The intent is more clear than using a file in the previous version.
I'm not quite following what you are doing with the Entity Builder here. It seems like you are using it primarily to convert each TypedEntity returned in this loop to an Entity. If that is the case, you should be creating a new Builder for each TypedEntity and then doing your duplicate comparison within this loop. As it is currently written, it seems like you are just overwriting properties as you iterate through the TypedEntities.
use Arrays.fill instead for loops
subMonitor.newChild with 1 tick
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
If this is never going to happen, why modify this to be less chatty?
No need for final, it's already private
This is pretty dangerous because alerts bigger than 1MB will break the emitter
Strange logging "cursor[input.getTime()]". Also maybe just remove this debugging line
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner:  Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri()[0], "Config server URI is undefined.");
Can we move the path to ApplicationUtils class?
Why not just "else"? Also, please add a space between if and (. There should also be a space between { and else
Remove all the sharedpreferences here instead of using clearToken() method. When one logs out, the application should clear all the saved 'SharedPreference values'. clearToken() will only save a blank passcode value and all the remaining sharedpreferences will remain intact. You can save the Instance Domain to make it convenient for the other users to login but it is already handled in LoginActivity.
Add newline before return.
I realize it's a first cut, but I wonder if we should map some basic headers (method, path (uri), Accept) ??
Why are we using Math.min/max() here but not above in unionBlock()?
If you create a new Color you have to store it and dispose it later, unless it's a system color.
new byte[0] is kind of ugly. Maybe another method that doesn't take it?
The session can be removed between the two calls to sessionRef.get(). Session session = sessionRef != null ? sessionRef.get() : null; if(session == null)
As an improvement over current state of this test, could initialize config with smallInstanceConfig() (also use the same in MemcachedMultiendpointTest)
The check for shiftedKind < ITypeMarshalBuffer.FLAG4 is not needed anymore since shiftedKind can be safely combined with ITypeMarshalBuffer.BASIC_TYPE into a short int.
this shouldn't do anything?
forEach is designed for side effect, a chained stream seems better to me.
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can use.
Why do you wait?
what about case when predicate evaluates to FALSE_LITERAL?
CodePointIterator might be a better choice here?
This line is now unnecessary because disposedOperators is updated in disposeAllOperators before throwing an exception.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
jsonRow != null? So what will be happen when jsonRow is null?
Better: append this unconditionally, and only append the other part based on the condition.
Why not reuse existing? public static Type valueOfIgnoreCase(String name) { if (name != null) { return valueOf(name.toUpperCase()); } throw new IllegalArgumentException("Invalid value null"); }
Please don't introduce labels, as I removed them in anoher pull request because sonarcloud complains about them (and not just sonarcloud)
this is as bad as flatMap, we need to look further into this in a next iteration
If you want you could build the whole string directly as: String s = bids.stream().map(snapshot::getBundle).map(this::represent).collect(Collectors.joining());
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
private, should only be called from the builder.
String can be externalized.
Aren't these args backwards?
Are we using lamda notation in this project?
this check is again done in getTaskCategory(..) and is redundant.
Spacing
suggestion throw new RuntimeException(String.format("Failed to parse geometry from string: %s", argumentValues[i]));
Remove conditional + exception. Uniqueness is guaranteed here.
This would be set on the event. A PRE_DELETE event doesn't have a delta, so you'll never get here. Just remove this.
I'm really sorry for your work, but in my opinion a simple TextInputDialog should be sufficient (instead of a custom dialog): <LINK_0>
No need
s/createPolygon()/createMultiPolygon()
"Couldn't rename [" -> Fail to rename
wondering which flow is better. Using the following might get rid of the reconnectToGemfire method in Cluster. suggestion String userName = authorizedClient.getPrincipalName(); if (isExpired(authorizedClient.getAccessToken())) { logoutUser(userName); authorizedClient = refreshExpiredClient(authentication, authorizedClient); } userName = authorizedClient.getPrincipalName(); String credentials = authorizedClient.getAccessToken().getTokenValue(); return getClusterWithCredentials(userName, credentials);
Since the subject isn't initialized until the callback returns. Won't this most likely lose the race and cause an NPE? I think this could be solved by making an AMLoginInfoTask subclass that provides latching mechanisms like AMSubject and Subject. So the code here would look something like (super approximately): LoginInfo info = new LoginInfo(); info.execute(); info.await(); assertThat(info.result(), ...); // Even more approximate if (info.legacyAuth()) { Subject subject = new Subject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); } else { AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); }
No need to do this, long strings are fairly common and the checkstyle configuration accounts for them, so they shouldn't trigger a warning.
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason. It's safest to simply return in that case.
can you make the name more explicit? array doesn't indicate anything.
should cleanup be in finally block?
Pass in true for the second param (discardUndefined), and remove the undefined model node from the values
remove local variable
Runtime Exception
Another option would be for WarningAction.onAttached to call Run.setResult automatically. On the other hand I can imagine wanting this drastic effect to be explicit.
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
Nit : you don't need this local, you could just inline the member in the next line. (it doesn't matter)
what happens if remove() fails (throws an exception)?
the path always starts with '/'. If it doesn't start with '/', then it isn't the path. (You're probably accidentally using '/' as a separator between the authority and the path. Actually the '/' is a part of the path.)
No, This is not right place to dismiss the dialog, do it <LINK_0>
Do we need to spoof the location in the packet or can we just create the ender pearl at the correct location server side (by adding 1.75 to throwLoc)?
curious: why remove anyTree?
Locking the configuration shouldn't be necessary. FileBasedConfig extends from Config, and Config is thread-safe via atomic references. So you just need to determine if either file needs to be refreshed, and if so, run its load() method again to pull it in from disk.
I believe jobId always defaults to 1. Why is it currentTimeMillis here? Wouldn't this cause different path across processors? Perhaps I am missing something
In general, I think we should start the tasks that need to be started, and then stop the tasks that are supposed to be stopped. The other way around could potentially introduce latency.
inverting the if-condition allows an early return and thus saves a level of indentation
minor: can be final
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit in memory a VSM via hard to read and duplicated logic. Simply craft a VSM with the 8 possible combinations and make the test simply call validation on it. * The test does not cover all the cases.
suggestion FSubscriberTransportFactory subscriberFactory = new FJmsSubscriberTransport.Factory(connection, "Consumer.frugal-examples.VirtualTopic.", true);
rename to res
lets make this an internal server error
please put in a separate method or rename this support method accordingly
I suggest to name it "binding" instead of "b"
Shown on the UI so should be i18n aware.
- Does Consul take docker client as a parameter?
What is the purpose of this logic? From the xml file I can tell that the 0210 thing has this channel, so why do you have this check and addition logic here?
Why not directly call a canDeleteInstance(input) ?
I think we should avoid calling getById multiple times.
Did you mean to call this on the view instead of the system table?
No big deal but think readTree accepts JsonParser too.
just remove the fileSize from here... and that's the only change you will need.
we should check mMediaUpoadHandler != null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
Here errorMessage needs to have single quotes escaped. The permission error ('You don't have permission to upload media to the site'), for example, causes an error. errorMessage.replaceAll("'", "\\\\'") should do it. We should probably do this everywhere we're sending string literals from Android, since a translated String may contain a single quote even if the default one doesn't.
Looks like this now should be withing if (result && this.fullStatsEnabled) as well.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
warning for missing non-nls. Isnt' there a constant for that?
IIRC anonymous users will crash here because they have no user account to get the prefs from.
Hey @mjsax . Sorry, but I didn't follow this change. How does this test pass when it expects the value to be 7, but it's now 3?
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still improve readability of the code. What do you think?
Do you think it would be better to find a way of doing this without sorting a collection on every call?
Since the fields are not final, I don't see the point of setting them to null explicitly.
Typo: line too long. Let's assert here that error message contains correct error description schema 'DOMAIN' from joining node differs to 'DOMAIN_1'
maybe use dnsServerAddress.isEmpty()
Why it is named by testLoadYamlFileFromDirectory ? Does it mean it will include all .flow files in the directory?
it can destroy vungleBannerAd from the new adapter on refresh.
Same as above, What happens when you print the outer DatastreamException
What about handling the case where the ASTValue is NOTHING? It should be legal to assign a variable to be nothing, as in, "x is nothing.". Also, is it legal to assign a variable to an object? For example: Fred is a person. X is Fred. (If that's legal, garbage collection becomes harder, so it's probably not legal. But if it's not legal, then the code here will silently do nothing, whereas I think it should give a runtime exception to the user.)
Can you please check the full expected result? One way to do this would be to build the expected Config manually and then compare it to the output of buildCoordinatorStreamConfig.
nit: I know this is following existing test case, but since we now have a logger, we can use this:  LOG.info("Got expected exception", uhe);  Sytem.err in test code is not friendly to test output/log interpretation.
unecessary test : less is more.
I wonder if something like src/main/java/org/apache/calcite/runtime/CalciteResource.java should be used instead
I believe we added a guard class to the sdk that will do this exact check.
Since keyFile,passwd & alias are used for both methods, I think it will be nice to put them as private (final) members of the class
It's a bit confusing to call get method to recover something. It's basically using it's side-effect. In getInternalRuntime, do we really need writelock for just getting the runtime? Or is it needed only for restore?? If so, I would rather handle writelock in recoverone method and make getInternalRuntime simpler with just readlock. I agree that this solution is simpler and safer one, but it's not the most readable and intuitive.
Should be the responsibility of service/requestman layer after Hibernatization
Why not set it to postgres in ctor?
Could you make this message more informative?
Unnecessary intermediate collection.
Please keep this.cell near the related fields (previousFamily & cell count) below
listView.setHasFixedSize(true);  listView -> recyclerView? Also, you can take <LINK_0> and  RecyclerView.ItemDecoration itemDecoration = new DividerItemDecoration(getActivity(), null); listView.addItemDecoration(itemDecoration);
just use an EnumRenderer in the view instead of localization in the model (and modify Enums.properties...)
You actually don't need a whole Project Object becaus you only work with lists of project, please change the functionality to only work with lists, by now
might want to change this to checkButton.setText(Strings.isValid(checkBoxMessage) ? checkBoxMessage : "<NONE>");
let us avoid the thread from crashing...and remove this code.
nit: precondition goes to the top
can we also include a test where we set includeInsights to be true?
This looks rather scary here: I would think you'd want the return type of #processUpdate to indicate whether there was an event that should cause everything to be reset?
This function doesn't seem to be used anywhere.
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
I think this should be after oos.writeObject(o);, in case there is buffered data. In any case, before obtaining the byte[] result.
Why don't we store the build folder as a full path, so we don't have to relativize again and again? We need to keep in mind that this is called for every folder that is ever added/removed/changed.
Removing test because you can not fix it is usually bad idea
Do we need to check Null of the input parameters?
nit: final modifier for unmodifiable variable.
modify it as it was implemented in ENG-10264
AggregateRoot is not an Entity.
i think initialization code should be in constructor but its only my opinion, not mandatory
this doesn't look like new code... was it reinstated after a merge or something?
Cloning after calling getEyeLocation is unnecessary
Do this check before the for(), because if this.notificationConfiguration.isEnabled() or this.notificationConfiguration.areEmailsEnabled() are false, you don't event need to load the descriptors and so on...
Does that handle 'null' properly?
have a default constructor with reasonable default values
this line can be removed (variable end not used)
stringutils.empty
I think you may be able to .put the added PartitionData into sessionPartitions up front, and capture the value returned by the .put, as it will return the previous value. If the previous value was null, then we add to added, if it was not null we add it to altered. This will save us the additional containsKey check.
How this change makes anything better?
I think you meant LOGGER.debug("Initialized debug logging"); ?
Having execute{Head,Get,Post,Put,Delete} are just wrappers to execute() for convenience and readability across APIs Spreading the logic of type checking will lead to confusion in future and its not a good idea.
Why is this hardcoded to 4 threads? Should there be an option to control this?
suggestion  refresh still shouldn't be necessary.
If this fails, it should be reported like this: ActionReturnValue attachReturnValue = attachToClusters(); if (!attachReturnValue.getSucceeded()) { propagateFailure(attachReturnValue); return; } I wonder if it is possible to rollback the whole command if this fails.
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
This can be small D double
It's good practice to provide as much inforamtion as possible. Please, use constructor of WrongAttributeValueException with additional parameters Attribute and AttributeHolder.
checkNotNull
s/Started/Starting
No need to cast a Player to a Player here.
Why do we want to return here ? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fPostListenersByPartId.get(listenerPartId)
you can append "twice()" to the expect
Swap the equals condition.
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should check its own overflows.
Instead of always firing this and having the receiver figure out if it should do something, why not determine if we should fire the event here, and have the receiver just do what it needs to do when it receives the event.
I Don't like this at all: the superclass is now doing different things based on the subclass. Prefer: factor out into an abstract method where each subclass does their own thing.
no need to specify type on RHS
I think the granularity should be 1 seconds instead of 5 seconds here.
Should this pass true for dryrun, when calling parse?
Why do you do it here and not as part of the initDcList()?
Duplicate in both createSubject and createEvidenceSubject methods. Consider to refactoring into helper method.
Need to check for more than WHITE_SPACE here, too.
ex
assertFalse(...);
I would like ot be extra safe here and it becomes smth like OS.GTK3 && !OS.isX11. This way I would be confident it would not have effect on X11.
Check what happens with an empty file: Looks like on replay, both openFile() and closeFile() calls are skipped since there are no recovery entries for that file.
I'd instantiate the ProducerArbiter before parent and supply it to SwitchIfEmptySubscriber and child, saving on this 'relaying' allocation. (Remark, our life would be much easier if we could implement Producer in Subscriber, but since request() is protected final, it is unoverridable :( )
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
Declared but unused.
close streams
What about new File(internalFileDir, fileName.name()).getAbsolutePath()? I think we should not create paths by concatenating strings
If response contains result (which it should contain) then you are creating new HashMap instance for no reason. Wouldn't following code be better: Map<String, List<String>> namespacesMap = (Map<String, List<String>>) SSOOAuthServiceUtils.getAvailableNamespaces( getSessionDataContainer().getSsoAccessToken(getParameters().getSessionId())).get("result); if (namespacesMap != null) { namespacesMap = (Map<String, List<String>>) response.get("result"); for (List<String> entry : namespacesMap.values()) { Collections.sort(entry); } } else { namespaceMap = new HashMap<>(); } setReturnValue(namespacesMap); Also if namespaceMap is read only, then even better would be to use Collections.emptyMap();
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F1, return fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
I don't see why we need a TBaseUtil at all and don't declare "isUnion" private in this class. I usually try to avoid "Util" classes. It could always be moved if some other class needs it.
I think you need to do this and the next line in a finally
the batch utility service has a function to remove a done file by passing tin the data file name.
lets make this an internal server error
We could create a new ChatMessage with messageData and remote
Should this method be private? Or protected? I don't see a need for package visibility.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Why are you using a Queue here? And then by extension a LinkedList?
nit: No need to declare these exception types now that we're calling getMajorVersion directly.
don't we want to remove the place holder in case of failure?
remove "public"
I don't think this is possible, if the cache is not defined it will be created with the default configuration.
use TWR to close
Shouldn't this be warning instead of info message? The message "kieMap not present with compilationID and container present" is a bit confusing Is the kie map not present? Or is it present but doesn't contain complationID? Imagine that you are a user who sees this log message. If the message is good he'll immediately know what's wrong and what and where should be fixed. Otherwise he'll have to look at the source code to understand what's wrong :( Also there is probably duplication of log messages on line 194: getLog().info("Kie Map not present"); - we should probably only log this at one place.
Another %n?
This block only compares AttributeAccessItem objects to themselves. It should compare them to the AttributeAccessItemDto objects from the corresponding indexes of attributeAccessItemDtoList.
There are a few checkstyle errors left:  [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./core/src/main/java/de/danoeh/antennapod/core/preferences/UserPreferences.java:1064:51: WhitespaceAround: '{' is not preceded with whitespace. [WhitespaceAround]
I think we can later implement a logger instead of directly printing to sysout. For now it's okay though. :)
Hardcoded list of locations have to be removed before merging.
Shouldn't we be moving the elevator while we're moving the clamp?
This won't work with generic builders I think.
You can use filterableNotification here
avoid increasing visibility?!
This is insufficient as googleId still leaks
you need a space between : user"+ userName
Nothing harmful, but the null check is done twice.
Minor: Please add whitespace before the final argument.
You can improve this further. Refer AddBrickPopupView.java Line:283 Sorry this did not come to my mind lastime :)
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
lots of loc here :) this method was only present for toString ordering
4.2
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Please refactor to different methods
can this happen? why not checking before cloning the whole list?
Can be replaced with ImmutableList.of().reverse().
It seems like passing the event id to the super class constructor and also making it a field might be a little confusing. Personally, I prefer the approach used in DataSourceAddedEvent where the id of the object is obtained in getNewValue via long id = (Long) super.getNewValue() and the "extra" field is not required. Thoughts?
You can't change the semantics of createControl(*) to dispose the toolbar.
is /./ necessary?
The stream() is not necessary here.
handle null case (same for rest below)
I'd break this up as java StringBuilder sb = new StringBuilder() .append(formatExpression(column.getName(), parameters)) .append(" ").append(column.getType());
Shouldn't we be passing an executor here? Was this missed by will's checkstyle PR?
warn seems too relaxing for this kind of exception. maybe error?
java return IntStream.range(0, numSegments) .mapToDouble(s -> new Variance().evaluate(Doubles.toArray(getCoveragesInSegment(s)))) .average();
Is there any value in asserting that these commands come in the right order? Although the implementation is a List I guess it protects against changes to duplicate checking or something doing an insertion into the wrong place in future. Maybe something like: if (latch.getCount() == 2){ latch.countDown() } else { fail("Wrong order")} for start and similarly with a 1 count for the stop event. WDYT?
Rather than duplicating this loop (which only gets the second level in the hierarchy), wouldn't it be better to go recursive?
s/any(List.class)/anyList/
should it return the record count?
Extract for readability.
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Would be good to add one final assertion that the folder created exists at a non-transactional uri after the tx closes, so just make sure that a non-tx client can get a 200 response at the obj uri
Single static string somewhere?
Replace with specific exception types.
Why initialize this to a new OkHttpClient instance that is not being used?
Timestamps within the last hour are rounded to "0 hr. ago". I personally prefer showing "X min. ago" for those cases and "A moment ago" or "Just now" for timestamps within the last minute.
minor, is it method scope for Visible For Testing? If not please change it to private.
healthyWritablePartitions
Does k need to be a new hashmap here? Looks like it is initialized on line 343 already.
just FYI, this if block could be replaced by switch statement since it's for Java 7
We should also verify that call to Elastic that sends the data is actually made and that it contains the results that were given on inputs. In the end, that's the most important action of your class, so it should be tested.
1) what do you want to test between line 65 to line 69? why not write it in a loop? what is the difference between line 67 and other lines? 2) you might consider verifying the mock BookieClient on how many times it is called?
i18n
Fix warning: suggestion KeyedMultipleInputTransformation<OUT> keyedTransform = (KeyedMultipleInputTransformation<OUT>) transformation;
space after if.
IMHO we should do _something_ here. As there is no obvious default action, how about printing some help then?
Debugging? Remove.
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right?  1 2337032 rs1129171 C T,<NON_REF> 480.77 . BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,13,13
stream & collect
what this line is for? I didn't get it
nit: a better approach would be create the subdir under the tmpDir initialized in this test suite.  File firstDir = new File(tmpDir, "dir1"); File secondDir = new File(tmpDir, "dir2");
We need to check null before reference dvd[i] here.
This looks like the new implementation, you should leverage current one by calling existing method with some transformation.
I think the following would also fix the leak and will not call the removeAction twice in any code path java @Override public void addDestroyAction(UUID registrationId, Callable<Boolean> removeAction) { synchronized (removeListenerActions) { if (destroyed) { callRemoveAction(removeAction); } else { removeListenerActions.put(registrationId, removeAction); } } }
This is fine, but even better would be to also catch any ToolError (e.g. a typechecking error) and print the error message on standard error.
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say "-option=value arg". And it doesn't take into account the -- that stops option parsing.
The layout could be passed in the constructor.
rename to path
Can we add log that the configuration setting from query is ignored?
code formatter missing? At least there should be a space before the curly bracket and you have a lot of tabs in here...
What about the following:  // onFail callback does not update task info to failed state. // With recoverable grouped execution, a single failed task doesn't fail the whole query. Not updating the task info make query not finish in tests because failed task is stuck in RUNNING state. // TODO: This issue only happens in test TestHiveRecoverableGroupedExecution when a worker is closed. Investigate why this is not an issue for production query recovery.  This explains what is missing from onFail, and why it's now a problem (since we don't fail query now). "RequestErrorTracker#requestFailed throws when backoff threshold is reached." explains why the exception will be thrown, in my opinion is a low level detail. The key here is the task somehow failed, but the task info is not updated. It's not a problem before since the query will fail. But now it can make the task stuck :/
I think it is better to return an empty collection instead of null.
Use new lines.
Why are you keeping the conversion-less method?
in calculateQualifiedVersion(), there are other ways to set the qualifier which are not being validated. rather pull this out into a dedicated validateQualifer method and call it after qualifier was determined.
can you explain this?
Do you have an opinion either way about (in the future, not now, let's just get this done already) rewriting this and any similar lines to Optional.ofNullable(property).map(prop -> new TypedValue(prop.getQualifiedType(), prop.get(obj)))?
this.
np: s/LocalApplicationRunner/RemoteApplicationRunner
Gson doesn't run on these versions so I don't see any reason to include them.
I guess EhcacheActiveEntity should never be getting any PassiveReplicationMessage since execution strategy prohibits that, right ?
Very unreadable, please extract to a boolean with a meaningful name
Can we use already-defined constants for the following three strings?
Same here, with respect to bad exception handling.
Result of replaceAll is ignored. Please, assign it to a variable. suggestion maxUploadSizeString = maxUploadSizeString.replaceAll("\\s+", "");
relevant non-logging code change here ^^^
Currently we don't have PERUNOBSERVER role assignable by config to specific credentials (unlike perun admin). This mean, we will always have User, related to this role. So anywhere, check on SELF (without specifying user or where passed user is only own) will let PERUNOBSERVER pass too. Only if it would filter result, we would have to separate them. What do you think @stavamichal @licehammer @martin-kuba ? Will we need PERUNOBSERVER role for accounts without User in Perun or not ? I suppose not, it is always safer to have account with contact info etc.
Should it be a NoSuchElementException instead of returning null?
PercentType is a DecimalType and for DecimalType calling toString() is the right thing.
agreed that this block should be removed
Why are you using supplyAsync here? createFromInitializingJob should be non-blocking.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Since this block is repeated in above, shall we move it to a separate private method?
Instances can be null or empty in case of no instances in ready. Null check and empty check is required here right ?
Minor confusion: If the spans are the same, sort should not have any effect right? Might be missing something here.
Check whether array length is even to avoid index out of bound exception in case of data corruption? But I am not sure whether this is really necessary.
.take(limit) is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
as author is not null and author.getUserId() not null due to previous block check it can be simplified to if (!author.getUserId().equals(userId)) {
could you remove the tab and use spaces for indents?
Shouldn't this be "Custom/"? Because if you look to string s (below) you will have a double slash on the one side and no slash on the other side
This uses the platforms default charset, I think we should probably use the more explicit getBytes("UTF-8").
final
ditto :)
Does this work if Column A or Column C has trailing whitespace? It might be better to split on comma and then do a colName.trim() or something along those lines.
possible NPE
I think it should be: tType = ((ParameterizedType) tType).getActualTypeArguments()[cDept] BTW: In a separate branch I'm working on strategic solution to compare generic types. Will refactor this code to use the common feature.
suggest rewrite this method
buffer size 1, why?
suggestion return Optional.of(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8));  I think that's enough examples for now, I hope I got my point across
The AllCleanRule should do the work of lines 158..159, so you can skip this code.
Can you add the other flag values as well?
Minor thing: "referer != null"
can this use increment util?
Please rename variable to something more meaningful other than the character v
Do we want to turn this on by default in elide-standalone, or did you mean to wrap this in an if block?
spacing
Sorry, I forgot about one thing! This will no longer be enough, there's VERSION_1_8_0 now. I think a better condition would be: ctx.version.lessThan(ServerVersion.VERSION_1_7_0) || ctx.version.inRange(ServerVersion.VERSION_2_0_0, ServerVersion.VERSION_2_2_0), but feel free to write the condition on your own.
please review code formatting
Needs to shut down the scheduler.
this can be merged with the above
return flagdown; ?
countVal is not necessary. you can use state.setSumC(State.getSumC() + count) directly.
Recommend changing this method to use the reference name exclusively. Eg.,  if ( SAMRecord.NO_ALIGNMENT_REFERENCE_NAME.equals(rec.getReferenceName()) ) { return record(null, 0); } else { return record(rec.getReferenceName(), rec.getAlignmentStart()); }
since you are catching.. why not test this :)
nit: just simplify to throws Exception
Variable is never used
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
Why this get deleted? Your code depends on this function?
ping
typo!
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
overflow = ((xl ^ yl) & (xl ^ zl)) < 0;
Why put at i-1? Wouldn't it be more natural to use i?
this looks funky! shall we re-visit?
This could be simplified to  hResult = shellFolder.ParseDisplayName(null, null, directory, pchEaten, ppidl,
silent errors are evil, even the "its almost impossible" ones ;) just surround the entire methods body with try - catch you have a good catch that handles it in the end
please add line above to separate 'block'
you control all the source here, I think it's fair to assume non null + you have Preconditions.checkNotNull
1 Euro for every System.out.println pls
Looks correct. I think you can just do result[1] |= shard() << 6; since bytes in an array by default are zero.
Looks like wait forTaskRelease is buggy. it seems to swallow interruptedException and return which means that waitForTaskRelease will return when the thread is interrupted making the caller believe that the task is released whereas it was not. Can you please take care of that issue?
Should this be a new Exception class?
file might be a directory - message will then be misleading
is this line useless?
Why does this give a bad request but the above tests returns an empty data? I suspect the RSQL filter is formatted incorrectly.
if we fail here we have a stale VM version in hand. we should roleback
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
Should this return Flux.error instead of throwing?
This needs to be new Request(Request.Type.OPEN) now.
Any strong reason why switch from DEBUG to TRACE ?
Excuse me, I want confirm with you about "A suggestion for a follow on change would be to add any permissions only projects as candidates even if they are not yet parents since that is likely their sole purpose: to become parents." here can I understand "to add any permissions only projects as candidates " as to delete Line 54?
Assertj has a fluent API. You have to do assertThat(events.size()).isEqulTo(1);
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
NITPICK: There is a class for this that already exist, can you reuse that.
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
Typically we use Map on the left hand side rather than HashMap
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
I think it was better with the old static imports.
I'm not sure that it will be correct to return only 400 for Nakadi Exception and 503 for everything else. I think that in reality there are more options.
unused
You can also use IO.close(bb) as IO.close will not throw any exception.
Yikes. I didn't see this before. Is it in master?! We shouldn't unwrap ExecutionException like this. It makes it look like the exception happened in this thread, rather than in the other thread. For example, if the other thread was interrupted then ExecutionException.getCause() will return an InterruptedException. Rethrowing the cause make it look like _this_ thread is being interrupted (and looks like the interrupt is being handled incorrectly, because it is just caught and wrapped without marking this thread as Thread.interrupt().
formatting
This check should be in the Service alongside alias validation
Absolute or just path?
nit: I somehow liked the old, more concise UNKNOWN_STATS
Check args?
Preconditions.checkNotNull(is, "Input stream required to create temp file for %s*%s", prefix, suffix);
Let's remove the finals. They're not adding anything.
Could this be merged with what we have from line 85?
Can this be private, or is there another use case for default attribute outside the builder's call?
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further logic since no further information is provided (e.g. type or format).
do not forge to test the isActivated() flag: it is as important than testing the node count... withTopologyService(1, XX topologyService -> assertFalse(topologyService.isActivated()));
IsAccessible is equivalent of isExist so the refresh should be done before ?
HQL/JP-QL
Why it's here? Please try to understand what onInstall and onUpdate are doing. If keep as you wrote: it will be a duplication.
prevState will be equal to current state if the state object is same.
long hashCode; try { hashCode = (long) keyBlockHashCode.invokeExact(keyBlock, position); } catch (RuntimeException e) { throw e; } catch (Throwable throwable) { throw new RuntimeException(throwable); }
It would make sense to use the constant you declared above.
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
why public? also the ordering of methods is a bit off, run() should come first so it's easier to read
why not public?
tab starts this line, we use spaces to indent code
I think this could leverage stream api : deduce().stream().map().filter().firstMatch().orElse...
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I think you could remove unnecessary brackets around path
shouldn't this be throwing the exception ?
throw that please
To make this more portable, could you create and approve a savings account first via the API and then undo the approval on the just created account?
How about in-lining o1 and o2 since they are not reused?
I think this method has no need to be static
Can you not use a for-each loop here?  for (JsonElement jsonEle: doc.getAsJsonArray()){ // stuff }
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
Could you please log the transaction ID here, instead of the entire transaction?
this makes a bit change as we were previously ignoring issue here which makes sense while stopping
IMO if we know executeTask() doesn't trigger maxIdle expiration, we should assert that
i++ is generally the convention unless you explicitly need to preincrement.
Same here with not needing the local variable.
this is a public method so better perform some null checks, or at least use assert statements
I wonder if we could end up with some issue, having bean as a field here and the setter for the same in the super class... I'd say that we really should use for the MultiMethodRabbitListenerEndpoint the same setters model. Even for the methods.
We cannot just delete package name from each class. It's required to test that a check supports fully-qualified names. In this exact case probably it's better to move this class to new line
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list assets at font path" so it's less ambiguous, it's not really failing to load fonts if you get me!
Nitpick: might be better to use constants for these.
This seems unnecessary. What advantage is there here versus before ? Both guarantee the order is respected.
Should we return emptyMap if we are SUSPENDED as well?
Move this line down. We don't need to instantiate a new object if it's not an IContainer.
Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?
This could be null, we should probably handle this if the JIRA api changes again
clean up empty quotes and new line.
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-local. Also please annotate @VisibleForTesting
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
is it possible that among the possible NakadiBaseExceptions there would be an authorization exception? I'm not sure if authorization is checked earlier in the code path, but if that's the case, we should handle this one specially. Could you please check that?
Same as above, try to simplify this by adding meaningful local variables.
This can be handled by waitForRunningTaskToComplete accepting a callback function to be executed that can contain the following code.
Change to a single call with both arguments.
Please don't extract that into other methods, it makes the tests hard to read. Either you multiply the test classes, each one of them having only one test method and one setup, or you use classes with many test methods but then, each test method must be readable at a glance and not rely on other methods located elsewhere, because it makes the intention of the test unclear.
I believe jobId always defaults to 1. Why is it currentTimeMillis here? Wouldn't this cause different path across processors? Perhaps I am missing something
I think we could only just set the StrictMode in Application.
Don't call toString()
This is bytecode equivalent to using the for-each syntax on an array.
Um, surely 1.6.6 is closer to 1.6.5 than it is to 1.6.
Note that using builder.setNegativeButton(R.string.cancel, null); here will accomplish the same thing.
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
You need to use the following pattern when using reentrant lock. Otherwise it could happen that the lock won't be unlocked if an exception happens in between lock and unlock. lock.lock(); // block until condition holds try { // ... method body } finally { lock.unlock() }
I'd prefer overriding of setEntity() method to listening for events in this case.
Can we collapse these two branches and just pass the parameter (direction == Direction.ASC) ?
<field name>_COLUMN
Is this supposed to return the task to the pool (no longer claimed)?
Just stuff all this logic in "getAllowedCategories" so you have no if statement here. Then the case statement just has return pickRandomInsightCategory(getAllowedCategories(marketingInsightPool, marketingSeenCategories),random);
Nit: superfluous as the equals will say got null below
nit: it's my personal style preference, but I much prefer instance != null ? instance : result.newModule() rather than the flipped case you have here.
Second parameter of Status is the pluginId. Why to pass path here?
Duplicated _for_ loop could be extract as a private method to factorize the code.
let's change the order in the ctor - its clearer when the source is before the dest :)
Must be AIDontUseIt (otherwise AI will discards all own hand for lands).
That's true It's fine then.
remove newline at the end of methods
May we detail the logger message a lit like > error in registering flow trigger <PojrectName_FlowName> in Quartz,
what about : this.myField ? This isField method should probably return the referenced symbol.
Why not update it in setZoomRatioInternal()? Is it because of float rounding error?
these 3 lines are common in closeXXX() and can be moved to close()
I believe jobId always defaults to 1. Why is it currentTimeMillis here? Wouldn't this cause different path across processors? Perhaps I am missing something
please dont remove explicit initialization
:ant: Deserves a functional test.
should be int y
Replaceable with Iterators.transform()
Why AttributeModifier needed here? Why just don't update PasswordsPanel.html?
Why allocate a new array? You already have created the array; why not just set the array element ?
If you make the EMPTY_EXPIRES, you could use it here.
Suggest leaving them as null if not set
check is unnecessary
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base will be left empty.
please don't call this a regex
The 'finally' block is not needed since calling monitor.done() is not required.
There are two 'additions' groups, this one and another before the align action. One should probably be changed. I wonder if those two TmfView common actions should be in some same group, with 'additions' group separator added after, for all the subclass actions in that group?
use ConcurrentUtils.withLock()
It's a common misconception to size a hash map this way. Guava uses the following computation to compensate for deficiency of the HashMap constructor: static int capacity(int expectedSize) { if (expectedSize < 3) { checkNonnegative(expectedSize, "expectedSize"); return expectedSize + 1; } if (expectedSize < Ints.MAX_POWER_OF_TWO) { // This is the calculation used in JDK8 to resize when a putAll // happens; it seems to be the most conservative calculation we // can make. 0.75 is the default load factor. return (int) ((float) expectedSize / 0.75F + 1.0F); } return Integer.MAX_VALUE; // any large value }
You can use a foreach loop of the form for(BibEntry entry : entries).
There is a lot happening here. It would be nice to break this up into multiple statements to improve the readability. Something like this: java ClientRegistration clientRegistration = context.getClientRegistration(); boolean isClientCredentials = AuthorizationGrantType.CLIENT_CREDENTIALS .equals(clientRegistration.getAuthorizationGrantType()); if (!isClientCredentials) { return null; } OAuth2AuthorizedClient authorizedClient = context.getAuthorizedClient(); if (!shouldRequestToken(authorizedClient)) { return null; }
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
FileOutputStream has a different usage of FileNotFoundException than FileInputStream. Here I would propose deleting specific handling of FileNotFoundException and left just IOException, stating that file cannot be created and logging stacktrace.  Throws: FileNotFoundException - if the file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason
Do we need to check Null of the input parameters?
Why add random options without a detailed explanation what the issue is and what these options change?
This class has Constructor and getter/setter which are never used.
Same as above, using GeoWebCacheExtensions.getProperty would allow more options to set a property.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
we tend to like initialization like this: final A a; if (cond) { a = something; } else { a = null; } This make very clear when a is set to null;
you could _extract method_ here, to avoid duplicated code on instanceFor and canProvide methods (just like type = extractRawType(type)) or just add this 2 lines on getBeanFrom
Unsigned types are not used in the current implementation. So, you can omit them.
I know that logically the changes in this method are correct due to the last return true. However, the method is already quite complex and big and it might make it more complex to follow certain changes to it. Or in case the default or some logic before it changes.
mmm not sure if it is gt 120 characters.
See above about title, file_name, and content being required parameters.
isn't the default 2?
For null values, we just do not supply those properties in the autoGenerationOption
Also include the values here?
Nitpick: We can do the if else together here :)
I think all of the stuff that modifies the response needs to happen outside of the thread after start is called. Otherwise, the method will have already returned, so I'm not sure what would even happen if you modify the response.
Take executor from here <LINK_0> Withiut daemon shutdown of server may not go cleanly.
Arguments should be switched.
Can you add a call to "DataCacheFactory.getCache().getCacheManager().clearAll()" as well? In the default configuration it will clear the same cache as the "report-dataset-cache", but if an OEM replaces the DataCache-implementation, we will cover their implementation too.
Worth checking that the UUID doesn't exist? Veeeeeery unlikely it does, but...
How are we testing these changes?
Instead of adding inline styles like this could you pass in a class name that we apply to the element instead? This makes maintenance a lot easier as well as making branding applying different styles.
Preferably use assertEquals. < testing
Use ImmutableSweepBatchConfig.builder to create the sweepBatchConfig.
suggestion assertThat(filter.beforeRequestMessage).contains("/hotel");  This is analogous to the aforementioned .startsWith() change. Please apply to all affected methods.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
Is this System.out required?
Remember the special case of issues having only flows with a single location (like cognitive complexity). Here all (single) locations of all flows should be highlighted.
Minor: can we check if the number contains the decimal point instead?
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
It is a bad practice to print stack trace instead of logging or processing exception
This code also does not respect devices in single-SIM mode (i.e. phoneCount == 1) where there are both pSIM and eSIM slots, but only one can be active at a time. This case still needs to be accounted for using the old logic.
nit: you may keep the chain pattern as append returns the builder object. Do not have a strong opinion on the current or the chained version.
According to the docs[0], this should be called from onCreate()... But how are you supposed to get the MapView before onCreateView()? [0] "You must call this method from the parent's Activity.onCreate(Bundle) or Fragment.onCreate(Bundle)." <LINK_0>
Extract the "USER_ID" to a constant and make it more unique. The HttpSession can be accessed "everywhere" in a servlet container. For example: "org.everit.jira.timetracker.plugin.user.id.hash".
category
shouldn't need the throws declaration?
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
it also need to be checked that token not expired at the beginning and expired only when expected time passed.
Does this line have any effect? Can it be removed?
Does not need to be public
You don't need this null-check, the getJavaElement method already does that.
I believe we just had someone discover this wait strategy doesn't work as expected
@cyberone no need for Mockito.times(1)
extra ;?
Should we consider other measurement units, like kg?
might be more logical to swap the order of the two lines above (install java, download tarball, unpack tarball)
can we add a log line that we are killing a segment located at location <somethign>
In this case I don't think it matters, but I think in general as we write new tests with operations we shouldn't use the constants. It's mainly a regression check to ensure the operation names don't change in the constant value.... ...though I should probably bring this up on wildfly-dev and not this PR :)
I feel like this is the best place to construct the spring resource URL with either file:// or resource://. this.configDir value could actually be a URL containing file:// or resource:// and then used for loading security, variables, and tables (all using spring resource loader).
There is an asGuid helper method. You can see the work I did for AddVmFromSnapshot at BackendVmsResource as a reference.
This should be outer.
Instead of a null check, why not just move the rest of the method to the try block?
Couldn't this if block move before the other if block? If the data has a size of 1 then the lower index will always be data.size() - 1.
This should probably be done using a progress dialog instead of showing the entire activity as loading. You can do that by extending ProgressDialogTask in the FollowUserTask class
Shouldn't it be true ? (legacy SQL used for old jobs)
Shall we catch specific exception?
![MINOR](<LINK_2> 'Severity: MINOR') "get" returns a string, there's no need to call "toString()". [![rule](<LINK_1>](<LINK_0>
is it possible to have tests for the encrypt/decrypt methods of this util?
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
The type should be included in the context.
return Collections.emptyList()
Glad to see that with this change, one can now navigate the (java) code and notice the different icons the button can display. Previously, one of the cases was set vie the xml layout file.
nit: missing newline
To make this more bulletproof, can we use the variant of waitFor() that takes no arguments? The Jenkins test harness puts a timeout on each test, so if the code under test has failed, the test would eventually time out. In contrast, this approach has an implicit assumption that the CI system will be running at a particular speed, and I'm not sure that we can rely on the Jenkins project's CI system to have any particular performance guarantees.
do you really mean "master cluster"
So why actually returning something ? I would really prefer to stick to throwing an explicit exception. AFAI understand you only return so you can test it in an existing test : create a dedicated test for the case and keep the explicit failure.
minor, is it method scope for Visible For Testing? If not please change it to private.
this for is exactly the same in all the array tests, let's move it to a private method
Minor: For consistency: LOG.warn("Failed to read offset file in storage partition directory: {}", offsetFileName, storepath, e)
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate column number
no need for this change now
use Arrays.fill instead for loops
going to assume a potential illegal argument exception here, too, if adSpaceName=""
please don't use labels
The field state should be read into a local variable outside the loop.
Could you remove a newline?
use single quote to make this a Char
We need to check the rightOperandList also.
"FROM" - we should make sure we are consistent when capitalizing HQL keyword.
Findbugs reports this, as you ignore the result of read(). Please add it to findbugsExcludeFile.xml to ignore it (or you can use return value to check if the read was successful here, not necessary though).
Can you please close the response in the end of test?
I think it would be nicer if we removed the intermediate OptimizeTableAnalyzedStatement and instead directly build the request classes. WDYT?
Can we please mock the Future?
Not sure whether we should transparently fall back? I think using this interpolator should be an active choice, especially since it does not even handle all default constraints out of the box.
I know I started using just title, but looking at some Google apps, like the Play store app, I think it's better to just use message. so, I recommend to change HistoryActivity instead to be consistent with this.
Remove this printStackTrace. logger.error will log a stack trace if you do this: logger.error("description of context", e); Basically we never want to see e.printStackTrace in geode code. Always use a logger instead.
This should not be changed, you should only be changing search methods
When would the offsets be unsorted? Is this more of a precaution or is it common? Is it again the small file optimization?
Shouldn't we add this only in case of async actions? Maybe check if action.isAsync() == true, in addition to jobId != null check.
Setting the style isn't needed for this component as this is the default already.
do we really have to work with classNames here and couldn't use Class objects directly instead? This smells like dynamic-import again :-(
Please use StringUtils.equals
Use of this.getClass().getName
set it to the appOptions by default. If it's still null, set it to a new instance.
This can be static.
asyncInvokeNext already checks if the delay stage is completed.
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
In several tools, we're using "jopt" for argument parsing. Perhaps you want to introduce it here as well?
is there a reason the fixture parser isn't in a initFixtureParser() function like these others?
Can you make these 5 seconds a constant like the other timeouts?
null check?
Not mandatory but we could save some duplication by refactoring these tests
This is no longer needed if MVs dont support indexes.
As a reply to your TODO in line #126- Seems that your code ("moveMacsFromOldMacPoolToNewOne();") should be moved to line 92. And should be in the same transaction with "getStoragePoolDao().updatePartial(getStoragePool());". Line 91 includes the update of the dc mac pool. So in case of a failure (crashing of the engine for example) after the mac pool update and before moving the macs to the new pool, the dc will be in inconsistent state and needs to be reverted.
Maybe it is better to say _"Provider for DTO type ..."_ ?
This is pretty inefficient, the way you would normally do this in JGit is: while (baseUrl.charAt(baseUrl.length() - 1) == '/') baseUrl = baseUrl.substring(0, baseUrl.length() - 1);
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
Could also do:  ApiDate lastSeen = Optional.ofNullable(r.getLastseen()).map(ApiDate::new).orElse(null);
use apiClass.getName() instead of LoginAPI.class.getName()
what do the 0L, 100L represent?
Wdyt about using a java 8 method to check lists ?  public boolean isRowSorted(List<String> info) { return info.equals(info.stream().sorted().collect(Collectors.toList())); }
more than 120 characters.
This method should declare that it throws this exception so that all usages are forced to handle it
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
Let's remove the BsmAdminPageEditWindow(String) constructor.
I don't think this is needed because this is a new build step type so there won't be any older jobs to correct
Please externalize these strings.
If we're going to use this Exception for both Create and Modify, should we rename to something more appropriate like "DomainDaoException" or "DomainTxException"?
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
Could use the Apache CommonsIO FilenameUtils.separatorsToSystem(String path) to be safe & cut down on verbosity. Also, that same utility has a lot of other useful methods that we could be leveraging throughout: A few: normalize(String filename) //normalize unneeded relative paths to simplify the path. ex: a/b/../b becomes a/b getExtension(String filename) //gets the extension wildcardMatch(String filename, String wildcardMatcher) //allows you to compare extensions or file names easily via wildcard
If we arrive here the statusCallback is notified already in the DownloadBatch.batchCannotContinue method, right?
Should this get a trailing newline too?
maybe this can be a set, so that duplicates get filtered out
if it isn't too much change, lets get rid of SecurityServiceCallback
foreach loop, append the comma always and then resize the stringbuilder => shorter, clearer code, and more efficient :)
why? just don't set _vds, and if _vds is null then do not enforce. I think we talked about this. Always use the engine interfaces.
remove the explicit initialization?
cleanup this temp dir afterwards
As Alex suggested, this should just be a continuation of the above if (as another else if) rather than a new if.
Couple of things here: (a) we can use Preconditions.checkArgument/checkState - less verbose (b) When throwing exceptions, I think it's good practice to include useful information. What dimension? What's the shape of the array? Without that, I need a debugger to get that information, which adds a lot of time required to fix it...
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
still think that we should log when there is a not found mapping
If this is only for testing, use stream api
Should be Reflections.getAllInterfaces(Class) to get interfaces on superclass and so forth. Returns a List<Class<?>> instead of an array, but should be OK.
why final variable? :-)
unnecessary new line
Why are you removing metrics at the end ? It's not already done by DbTester ?
You should only take into account owning partitions here (avoid renting partitions, moving are not possible because previous assignment is ideal).
can you explain this logic? Should partial task data not carry the updated date/revision information?
Should we make this intermediate commit point *configurable*? I'm hoping committing every 10,000 is a sane default, but just wondering out loud if it's worth making this a configuration setting.
try/catch
Should probably use System.lineSeparator() for the benefit of non-Unix-like consoles.
Remove the * 2
