public boolean equals ( Object that )   {  if  ( this  =  =  that )   {  return true ;   }  if  ( that instanceof Rating )   {  Rating other  =   ( Rating )  that ;  return type . equals ( other . type )   &  &  value  =  =  other . value  &  &  numberOfVotes . equals ( other . numberOfVotes )  ;   }  return false ;   } 	Hash code
public synchronized void dispose (  )   {  ILaunchManager launchManager  =  DebugPlugin . getDefault (  )  . getLaunchManager (  )  ;  launchManager . removeLaunchConfigurationListener ( this )  ;  launchManager . removeLaunchListener ( this )  ;  for  ( ISourceLookupParticipant participant  :  fParticipants )   {  if ( participant  !  =  this )   {  participant . dispose (  )  ;   }   }  fParticipants . clear (  )  ;  if  ( fSourceContainers  !  =  null )   {  for  ( ISourceContainer fSourceContainer  :  fSourceContainers )   {  fSourceContainer . dispose (  )  ;   }   }  fSourceContainers  =  null ;  fResolvedElements  =  null ;   } 	> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
 @ Override protected void onEntityAdded ( Entity member )   {  try  {   (  ( MongoDBReplicaSetImpl )  entity )  . serverAdded (  ( MongoDBServer )  member )  ;   }  catch  ( Exception e )   {  ServiceStateLogic . ServiceNotUpLogic . updateNotUpIndicator (  ( EntityLocal ) member ,  "Failed to update replicaset" ,  e )  ;   }   } 	Likewise.
private void testSanitization (  )  throws IOException  {   _  _  _  _  _  _ TS ( "Test sanitization for edit page" )  ;  instructorId  =  testData . accounts . get ( "instructor1OfTestingSanitizationCourse" )  . googleId ;  FeedbackSessionAttributes session  =  testData . feedbackSessions . get ( "session1InTestingSanitizationCourse" )  ;  courseId  =  session . getCourseId (  )  ;  feedbackSessionName  =  session . getFeedbackSessionName (  )  ;  feedbackEditPage  =  getFeedbackEditPage (  )  ;  feedbackEditPage . verifyHtmlMainContent ( "instructorFeedbackEditPageTestingSanitization . html" )  ;   _  _  _  _  _  _ TS ( "Test sanitization for copy question modal" )  ;  feedbackEditPage . clickCopyButton (  )  ;  feedbackEditPage . waitForCopyTableToLoad (  )  ;  feedbackEditPage . verifyHtmlPart ( By . id ( "copyModal" )  ,  " / instructorFeedbackCopyQuestionModalTestingSanitization . html" )  ;   } 	Added because?
public TextArgs add ( Object .  .  .  args )   {  if  ( positionedArgsBuilder  =  =  null )   {  throw new IllegalArgumentException ( "Positioned arguments were already accessed ,  to add"  +  "more arguments use TextArgs . copy (  ) " )  ;   }  positionedArgsBuilder . add ( args )  ;  return this ;   } 	Should have a space after add
public List getList ( String key )   {  for  ( Config child  :  children )   {  if  ( child . containsKey ( key )  )   {  return child . getList ( key )  ;   }   }  return null ;   } 	call notFound
Mono < Response < RecognizePiiEntitiesResult >  >  recognizePiiEntitiesWithResponse ( String text ,  String language ,  Context context )   {  return recognizeBatchPiiEntitiesWithResponse (  Arrays . asList ( new TextDocumentInput ( Integer . toString ( 0 )  ,  text ,  language )  )  ,  null ,  context )   . flatMap ( response  -  >   {  Iterator < RecognizePiiEntitiesResult >  responseItem  =  response . getValue (  )  . iterator (  )  ;  return Mono . just ( new SimpleResponse <  >  ( response ,  responseItem . next (  )  )  )  ;   }  )  ;   } 	"0"?
public static  < T >  FactorComparator < T >  create ( String factorName ,  int weight ,  Comparator < T >  comparator )  {  if  ( null  =  =  factorName  |  |  factorName  =  =  ""  |  |  weight  <  0  |  |  null  =  =  comparator )  {  logger . error ( "failed to create instance of FactorComparator ,  at least one of the input paramters are invalid" )  ;  return null ;   }  return new FactorComparator < T >  ( factorName , weight , comparator )  ;   } 	throw exception
public ExprEval apply ( List < Expr >  args ,  Expr . ObjectBinding bindings )   {  if  ( args . size (  )   !  =  2 )   {  throw new IllegalArgumentException ( "function  ' "  +  name (  )   +  " '  needs 2 argument" )  ;   }  Expr expr1  =  args . get ( 0 )  ;  Expr expr2  =  args . get ( 1 )  ;  return eval ( expr1 . eval ( bindings )  ,  expr2 . eval ( bindings )  )  ;   } 	needs 2 _arguments_, plural
public static IGerritHudsonTriggerConfig getConfig ( String serverName )   {  return PluginImpl . getInstance (  )  . getServer ( serverName )  . getConfig (  )  ;   } 	possible NPE
public void setObject _ unmanagedObjectThrows (  )   {  RealmResults < AllTypes >  collection  =  realm . where ( AllTypes . class )  . findAll (  )  ;  realm . beginTransaction (  )  ;  try  {  collection . setObject ( AllTypes . FIELD _ REALMOBJECT ,  new Dog (  )  )  ;  fail (  )  ;   }  catch  ( IllegalArgumentException e )   {  assertTrue ( "Wrong error message :  "  +  e . getMessage (  )  ,  e . getMessage (  )  . contains ( "is not a valid a valid ,  managed Realm object . " )  )  ;   }   } 	remove double a valid from test & implementation
public Update createStatement ( String sql )   {  Foreman updateForeman  =  foreman . createChild (  )  ;  return new Update ( this ,  statementLocator ,  statementRewriter ,  statementBuilder ,  sql ,  new ConcreteStatementContext ( globalStatementAttributes ,  MappingRegistry . copyOf ( mappingRegistry )  ,  updateForeman )  ,  timingCollector ,  updateForeman ,  collectorFactoryRegistry )  ;   } 	Can we revert this constructor argument change for classes that don't implement ResultBearing?
public void execute ( JobDelegateDataBean data )   {  try  {  executeDelegate ( data )  ;   }  catch  ( Exception e )   {  Logger . error ( this ,  "An error occurred when running the Job Delegate :  "  +  this . getClass (  )  ,  e )  ;   }  finally  {  try  {  HibernateUtil . closeSession (  )  ;   }  catch  ( DotHibernateException e )   {  Logger . warn ( this ,  e . getMessage (  )  ,  e )  ;   }   }   } 	Let's remove the wrapping finally (including HibernateUtil.closeSession) also
public void nextJsonObject _ ArrayOfElements (  )  throws JsonParseException ,  IOException  {  String element1  =  normalizeJson ( " { bre :   ' sss '  ,  arr :   [  ' 1112 '  ,   ' abc '  ]  } " )  ;  String element2  =  normalizeJson ( " { bre :   ' sss '  ,  arr :   [  ' 1112 '  ,   ' abc '  ]  ,  dd :   ' ssssxx '  } " )  ;  String content  =  " [ "  +  element1  + " ,  "  +  element2  +  " ] " ;  JsonParser jsonParser  =  jsonFactory . createParser ( content )  ;  JsonToken jsonToken  =  jsonUtils . nextJsonObject ( jsonParser )  ;  assertEquals ( content . replaceAll ( " \  \ s" ,  "" )  ,  jsonParser . readValueAsTree (  )  . toString (  )  )  ;  jsonToken  =  jsonUtils . nextJsonObject ( jsonParser )  ;  assertNull ( jsonToken )  ;   } 	you don't need use replaceAll, because above you used normalizeJson
public PreparedOperationWithReactiveStream < Cursor >  prepare (  )   {  Checks . checkNotNull ( query ,  "Please specify query" )  ;  if  ( getResolver  =  =  null )   {  getResolver  =  DefaultGetResolver . INSTANCE ;   }  return new PreparedGetCursor (  storIOContentProvider ,  getResolver ,  query  )  ;   } 	Static import
public void designDocSync (  )  throws MalformedURLException  {  DesignDocument designDoc  =  DesignDocumentManager . fromFile ( designDocExample )  ;  db . getDesignDocumentManager (  )  . put ( designDoc )  ;   } 	Exception again
protected String getLaunchDebugCommand ( JBossServer jbossServer )  throws CoreException  {  String programArguments  =  getLaunchProgramArgs (  )  ;  String vmArguments  =  getLaunchVMArgs (  )  ;  String jar  =  getJar ( jbossServer . getServer (  )  )  ;  String debugPort  =  getDebugPort (  )  ;  String debugArgs  =  " - Xrunjdwp : transport = dt _ socket , server = y , suspend = n , address = "  +  debugPort  +  "  - Xdebug " ;  String command  =  "java "  +  debugArgs  +  vmArguments  +  "  - jar "  +  jar  +  " "  +  IJBossRuntimeConstants . SPACE  +  programArguments  +  " & " ;  return command ;   } 	use return ... ? ... : ...?
public void testCreateInvalidConfigAeadWithAuth (  )  throws Exception  {  IpSecConfig ipSecConfig  =  buildBasicIpSecConfig (  )  ;  for  ( int direction  :  directions )   {  ipSecConfig . setAuthentication ( direction ,  authAlgo )  ;  try  {  ipSecConfig . setAuthenticatedEncryption ( direction ,  aeadAlgo )  ;   }  catch  ( IllegalArgumentException expected )   {   }   }  try  {  mIpSecService . createTransportModeTransform ( ipSecConfig ,  new Binder (  )  )  ;  fail (  "IpSecService should have thrown an error on authentication being"  +  " enabled with authenticated encryption" )  ;   }  catch  ( IllegalArgumentException expected )   {   }   } 	By composition, do we need this?
public boolean isUnifiable ( Index index )   {  return index instanceof TopIndex  |  |  equals ( index )   |  |   ( index instanceof TokenIndex  &  &  kLabel . sorts (  )  . contains (  (  ( TokenIndex )  index )  . sort (  )  )  )  ;   } 	same question
static void writeModel ( NaiveBayesModel model )  throws IOException  {  ensureTextClassifierFolderExists (  )  ;  FileWriter fw  =  new FileWriter ( new File ( MODEL _ PATH )  )  ;  PlainTextNaiveBayesModelWriter modelWriter ;  modelWriter  =  new PlainTextNaiveBayesModelWriter ( model ,  new BufferedWriter ( fw )  )  ;  modelWriter . persist (  )  ;  fw . close (  )  ;   } 	Why need to catch to simply rethrow?
public ImmutableRatesProviderBuilder iborIndexCurve ( IborIndex index ,  Curve forwardCurve )   {  ArgChecker . notNull ( index ,  "currency" )  ;  ArgChecker . notNull ( forwardCurve ,  "forwardCurve" )  ;  this . indexCurves . put ( index ,  forwardCurve )  ;  return this ;   } 	Argument name
 @ Override public E remove (  )   {  lock . lock (  )  ;  try  {  if  ( queue . isEmpty (  )  )   {  throw new NoSuchElementException (  )  ;   }  E peek  =  queue . peek (  )  ;  queue . remove (  )  ;  return peek ;   }  catch  ( IOException e )   {  QueueFile .  < Error > getSneakyThrowable ( e )  ;  return null ;   }  finally  {  lock . unlock (  )  ;   }   } 	throws
public String toString (  )   {  return String . format ( "byte @ 0x % x = 0x % x  (  % d ) " ,  Pointer . nativeValue ( getPointer (  )  )  ,  getValue (  )  ,  getValue (  )  )  ;   } 	See ByteByReference.java
Builder addClientCapabilities ( Collection < String >  clientCapabilities )   {  for  ( String cap :  clientCapabilities )   {  if  ( cap . startsWith ( "agent = " )  )   {  setAgent ( cap . substring ( "agent = " . length (  )  )  )  ;   }  else  {  clientCaps . add ( cap )  ;   }   }  return this ;   } 	This adds the caps a second time.
public void deactivate (  )   {  logger . debug ( "Deactivate" )  ;   } 	please decrease log level to trace or better remove statement
private static Instant retrieveDeadlineTimestamp ( JobDataMap jobDataMap )   {  Object timestamp  =  jobDataMap . get ( MESSAGE _ TIMESTAMP )  ;  if  ( timestamp instanceof String )  return Instant . parse ( timestamp . toString (  )  )  ;  return Instant . ofEpochMilli (  ( long )  timestamp )  ;   } 	Same argument as with the DeadlineJob.
public synchronized long getTimestamp ( final int offset )   {  HistogramScaledData scaledData  =  fScaledData ;  if  ( scaledData  !  =  null )   {  return fScaledData . fFirstBucketTime  +   ( long )   ( 0 . 5  +   ( fScaledData . fBucketDuration  *  offset )  )  ;   }  return 0 ;   } 	scaledData, thread safety and all
private  < T extends Enum < T >  >  void registerStatistic ( String statNameSuffix ,  StatisticType type ,  final OperationStatisticDescriptor < T >  descriptor ,  final EnumSet < T >  outcomes )   {  if  ( contextObject  =  =  null )   {  return ;   }  Set < TreeNode >  result  =  queryBuilder (  )   . descendants (  )   . filter ( context ( attributes ( Matchers .  < Map < String ,  Object >  > allOf (  hasAttribute ( "type" ,  descriptor . getType (  )  )  ,  hasAttribute ( "name" ,  descriptor . getObserverName (  )  )  ,  hasAttribute ( "tags" ,  new Matcher < Set < String >  >  (  )   {   @ Override protected boolean matchesSafely ( Set < String >  object )   {  return object . containsAll ( descriptor . getTags (  )  )  ;   }   }  )  )  )  )  )   . filter ( context ( identifier ( subclassOf ( OperationStatistic . class )  )  )  )   . build (  )  . execute ( Collections . singleton ( ContextManager . nodeFor ( contextObject )  )  )  ;  if  (  ! result . isEmpty (  )  )   {  for  ( TreeNode node  :  result )   {  String discriminator  =  null ;  Map < String ,  Object >  properties  =   ( Map < String ,  Object >  )  node . getContext (  )  . attributes (  )  . get ( "properties" )  ;  if  ( properties  !  =  null  &  &  properties . containsKey ( "discriminator" )  )   {  discriminator  =  properties . get ( "discriminator" )  . toString (  )  ;   }  String fullStatName  =   ( discriminator  =  =  null  ?  ""  :   ( discriminator  +  " : " )  )   +  statNameSuffix ;  final OperationStatistic < T >  statistic  =   ( OperationStatistic < T >  )  node . getContext (  )  . attributes (  )  . get ( "this" )  ;  registerStatistic ( fullStatName ,  type ,  new ValueStatistic < Number >  (  )   {   @ Override public Number value (  )   {  return statistic . sum ( outcomes )  ;   }   }  )  ;   }   }   } 	We should mutualize a hasTag (probably in stats)
public void process ( String sessionId ,  String taskId ,  NodeId agentId ,  NodeContext nodeContext ,  SystemInfo systemInfo )   {  String serviceId  =  getKey ( sessionId ,  taskId )  ;  if  (  ! metricServiceMap . containsKey ( serviceId )  )  {  metricServiceMap . put ( serviceId ,  new DefaultMetricService ( sessionId ,  taskId ,  nodeContext )  )  ;   }  saveMonitoringValues ( serviceId ,  agentId . getIdentifier (  )  ,  systemInfo . getSysInfo (  )  )  ;  if  ( systemInfo . getSysUnderTest (  )   =  =  null )  {  return ;   }  for  ( Map . Entry < String ,  SystemUnderTestInfo >  entry  :  systemInfo . getSysUnderTest (  )  . entrySet (  )  )  {  saveMonitoringValues ( serviceId ,  entry . getKey (  )  ,  entry . getValue (  )  . getSysUTInfo (  )  )  ;   }  log . trace ( "System info  {  }  received from agent  {  }  and has been written to FileStorage" ,  systemInfo ,  agentId )  ;   } 	IMHO it does not need to be public
private void finalizeMetadataChunk (  )   {  finalBlobProperties  =  new BlobProperties ( getBlobSize (  )  ,  passedInBlobProperties . getServiceId (  )  ,  passedInBlobProperties . getOwnerId (  )  ,  passedInBlobProperties . getContentType (  )  ,  passedInBlobProperties . isPrivate (  )  ,  passedInBlobProperties . getTimeToLiveInSeconds (  )  ,  passedInBlobProperties . getCreationTimeInMs (  )  ,  passedInBlobProperties . getAccountId (  )  ,  passedInBlobProperties . getContainerId (  )  ,  false )  ;  if  ( getNumDataChunks (  )   >  1 )   {  List < StoreKey >  orderedChunkIdList  =  new ArrayList <  >  ( indexToChunkIds . values (  )  )  ;  buf  =  MetadataContentSerDe . serializeMetadataContent ( routerConfig . routerMaxPutChunkSizeBytes ,  getBlobSize (  )  ,  orderedChunkIdList )  ;  onFillComplete ( false )  ;   }  else  {  blobId  =   ( BlobId )  indexToChunkIds . get ( 0 )  ;  state  =  ChunkState . Complete ;  operationCompleted  =  true ;   }   } 	doc
public static void testGetCentresByBranch (  )  throws MambuApiException  {  methodName  =  new Object (  )   {  }  . getClass (  )  . getEnclosingMethod (  )  . getName (  )  ;  System . out . println ( methodName  =  " \ nIn "  +  methodName )  ;  OrganizationService organizationService  =  MambuAPIFactory . getOrganizationService (  )  ;  String branchId  =  BRANCH _ ID ;  String offset  =  "0" ;  String limit  =  "500" ;  System . out . println (  " \ nIn testGetCentresByBranch"  +  " BranchID = "  +  branchId  +  " Offset = "  +  offset  +  " Limit = "  +  limit )  ;  Date d1  =  new Date (  )  ;  List < Centre >  centres  =  organizationService . getCentres ( branchId ,  offset ,  limit )  ;  Date d2  =  new Date (  )  ;  long diff  =  d2 . getTime (  )   -  d1 . getTime (  )  ;  System . out . println ( "Total Centres = "  +  centres . size (  )   +  " for branch = "  +  branchId  +  " .  Total time = "  +  diff )  ;  for  ( Centre centre  :  centres )   {  System . out . println ( " Name = "  +  centre . getName (  )   +  " \ tId = "  +  centre . getId (  )  )  ;   }  System . out . println (  )  ;   } 	How does this work if the app image is loaded? Won't the test fail?
public void copyRightToLeft ( Diff target ,  Monitor monitor )   {  if  ( target . getState (  )   !  =  DifferenceState . UNRESOLVED )   {  return ;   }  long start  =  System . currentTimeMillis (  )  ;  target . setState ( DifferenceState . MERGED )  ;  final Set < Diff >  dependencies  =  getDirectMergeDependencies ( target ,  true )  ;  boolean requiresMerging  =  requiresMerging ( target ,  true )  ;  for  ( Diff mergeMe  :  dependencies )   {  mergeDiff ( mergeMe ,  true ,  monitor )  ;   }  for  ( Diff transitiveMerge  :  getDirectResultingMerges ( target ,  true )  )   {  transitiveMerge . setState ( DifferenceState . MERGED )  ;   }  if  ( requiresMerging )   {  if  ( target . getSource (  )   =  =  DifferenceSource . LEFT )   {  reject ( target ,  true )  ;   }  else  {  accept ( target ,  true )  ;   }   }  if  ( isHandleSubDiffs (  )  )   {  Set < Diff >  subDiffs  =  Sets . newLinkedHashSet ( ComparisonUtil . getDirectSubDiffs ( false )  . apply ( target )  )  ;  for  ( Diff subDiff  :  subDiffs )   {  mergeDiff ( subDiff ,  true ,  monitor )  ;   }   }  if  ( LOGGER . isDebugEnabled (  )  )   {  long duration  =  System . currentTimeMillis (  )   -  start ;  LOGGER . debug ( "copyLeftToRight ( Diff ,  Monitor )   -  diff "  +  target . hashCode (  )   +  " merged in "  +  duration  +  "s" )  ;   }   } 	start
public void testAddDraggableGroupsWithExperimental (  )   {  disabledExperimentalFeatures . add ( Group1LayoutDragComponent1 . class . getName (  )  )  ;  disabledExperimentalFeatures . add ( Group1LayoutDragComponent3 . class . getName (  )  )  ;  disabledExperimentalFeatures . add ( Group2LayoutComponentPaletteGroupProvider . class . getName (  )  )  ;  disabledExperimentalFeatures . add ( Group3LayoutDragComponent1 . class . getName (  )  )  ;  presenter . addDraggableGroups ( Arrays . asList ( new Group1LayoutComponentPaletteGroupProvider ( true )  ,  new Group2LayoutComponentPaletteGroupProvider (  )  ,  new Group3LayoutComponentPaletteGroupProvider (  )  )  )  ;  verify ( dragComponentGroupPresenter ,  times ( 2 )  )  . init ( any (  )  )  ;  verify ( dragComponentGroupPresenter ,  times ( 2 )  )  . getView (  )  ;  verify ( dragComponentGroupView ,  times ( 1 )  )  . setExpanded ( true )  ;  verify ( dragComponentGroupView ,  times ( 1 )  )  . setExpanded ( false )  ;  verify ( view ,  times ( 2 )  )  . addDraggableComponentGroup ( any (  )  )  ;  assertEquals ( 2 ,  presenter . getLayoutDragComponentGroups (  )  . size (  )  )  ;  assertNotNull ( presenter . getLayoutDragComponentGroups (  )  . get ( Group1LayoutComponentPaletteGroupProvider . ID )  )  ;  assertFalse ( presenter . hasDraggableComponent ( Group1LayoutComponentPaletteGroupProvider . ID ,  Group1LayoutDragComponent1 . ID )  )  ;  assertTrue ( presenter . hasDraggableComponent ( Group1LayoutComponentPaletteGroupProvider . ID ,  Group1LayoutDragComponent2 . ID )  )  ;  assertFalse ( presenter . hasDraggableComponent ( Group1LayoutComponentPaletteGroupProvider . ID ,  Group1LayoutDragComponent3 . ID )  )  ;  assertNull ( presenter . getLayoutDragComponentGroups (  )  . get ( Group2LayoutComponentPaletteGroupProvider . ID )  )  ;  assertFalse ( presenter . hasDraggableComponent ( Group2LayoutComponentPaletteGroupProvider . ID ,  Group2LayoutDragComponent1 . ID )  )  ;  assertFalse ( presenter . hasDraggableComponent ( Group2LayoutComponentPaletteGroupProvider . ID ,  Group2LayoutDragComponent2 . ID )  )  ;  assertNotNull ( presenter . getLayoutDragComponentGroups (  )  . get ( Group3LayoutComponentPaletteGroupProvider . ID )  )  ;  assertFalse ( presenter . hasDraggableComponent ( Group3LayoutComponentPaletteGroupProvider . ID ,  Group3LayoutDragComponent1 . ID )  )  ;   } 	One more times(1).
public List < URI >  uploadAllFromHome ( String inVerzeichnis )   {  User currentUser  =  Helper . getCurrentUser (  )  ;  ArrayList < URI >  files  =  new ArrayList <  >  (  )  ;  FilenameFilter filter  =  new FileNameEndsWithFilter ( " ] " )  ;  try  {  if  ( currentUser  !  =  null )   {  URI directoryName  =  serviceManager . getUserService (  )  . getHomeDirectory ( currentUser )  . resolve ( inVerzeichnis )  ;  files  =  fileService . getSubUris ( filter ,  directoryName )  ;   }  else  {  Helper . setFehlerMeldung ( "uploadFromHomeAlle abgebrochen ,  Fehler  -  no user assigned" )  ;  return files ;   }   }  catch  ( IOException ioe )   {  logger . error ( "Exception uploadFromHomeAlle (  ) " ,  ioe )  ;  Helper . setFehlerMeldung ( "uploadFromHomeAlle abgebrochen ,  Fehler" ,  ioe . getMessage (  )  )  ;  return files ;   }  for  ( URI data  :  files )   {  String dataString  =  data . toString (  )  ;  if  ( dataString . endsWith ( " / " )   |  |  dataString . endsWith ( " \  \ " )  )   {  data  =  URI . create ( dataString . substring ( 0 ,  dataString . length (  )   -  1 )  )  ;   }  if  ( data . toString (  )  . contains ( " / " )  )   {  data  =  URI . create ( dataString . substring ( dataString . lastIndexOf ( " / " )  )  )  ;   }   }  return files ;   } 	This should be done in the constructor. Then you can also make the member final.
private List < AccountInfo >  suggestAccount ( VisibilityControl visibilityControl )  throws OrmException  {  if  (  ! suggestAccounts )   {  return Collections . emptyList (  )  ;   }  final String a  =  query ;  final String b  =  a  +  MAX _ SUFFIX ;  final LinkedHashMap < Account . Id ,  AccountInfo >  r  =  new LinkedHashMap < Account . Id ,  AccountInfo >  (  )  ;  for  ( final Account p  :  dbProvider . get (  )  . accounts (  )   . suggestByFullName ( a ,  b ,  limit )  )   {  addSuggestion ( r ,  p ,  new AccountInfo ( p . getId (  )  )  ,  visibilityControl )  ;   }  if  ( r . size (  )   <  limit )   {  for  ( final Account p  :  dbProvider . get (  )  . accounts (  )   . suggestByPreferredEmail ( a ,  b ,  limit  -  r . size (  )  )  )   {  addSuggestion ( r ,  p ,  new AccountInfo ( p . getId (  )  )  ,  visibilityControl )  ;   }   }  if  ( r . size (  )   <  limit )   {  for  ( final AccountExternalId e  :  dbProvider . get (  )  . accountExternalIds (  )   . suggestByEmailAddress ( a ,  b ,  limit  -  r . size (  )  )  )   {  if  (  ! r . containsKey ( e . getAccountId (  )  )  )   {  final Account p  =  accountCache . get ( e . getAccountId (  )  )  . getAccount (  )  ;  final AccountInfo info  =  new AccountInfo ( p . getId (  )  )  ;  addSuggestion ( r ,  p ,  info ,  visibilityControl )  ;   }   }   }  return new ArrayList < AccountInfo >  ( r . values (  )  )  ;   } 	final is unnecessary here
public String generateTOTPTokenLocal ( String username )  throws TOTPException  {  long token  =  0 ;  try  {  int tenantId  =  IdentityUtil . getTenantIdOFUser ( username )  ;  UserRealm userRealm  =  TOTPManagerComponent . getRealmService (  )  . getTenantUserRealm ( tenantId )  ;  if  ( userRealm  !  =  null )   {  UserStoreManager userStoreManager  =  userRealm . getUserStoreManager (  )  ;  String secretKey  =  userStoreManager . getUserClaimValue ( MultitenantUtils . getTenantAwareUsername  ( username )  ,  Constants . SECRET _ KEY ,  null )  ;  byte [  ]  secretkey ;  String encoding  =  "Base32" ;  try  {  encoding  =  TOTPUtil . getEncodingMethod (  )  ;   }  catch  ( IdentityApplicationManagementException e )   {  log . error ( "Error when fetching the encoding method" )  ;   }  if  ( "Base32" . equals ( encoding )  )   {  Base32 codec32  =  new Base32 (  )  ;  secretkey  =  codec32 . decode ( secretKey )  ;   }  else  {  Base64 code64  =  new Base64 (  )  ;  secretkey  =  code64 . decode ( secretKey )  ;   }  try  {  token  =  getCode ( secretkey ,  getTimeIndex (  )  )  ;  if  ( log . isDebugEnabled (  )  )   {  log . debug ( "Token is sent to via email .  token  :  "  +  token )  ;   }  log . info ( "Generated token  :  "  +  token )  ;   }  catch  ( NoSuchAlgorithmException e )   {  throw new TOTPException ( "TOTPTokenGenerator can ' t find the configured hashing algorithm" ,  e )  ;   }  catch  ( InvalidKeyException e )   {  throw new TOTPException ( "Secret key is not valid" ,  e )  ;   }   }  else  {  throw new TOTPException ( "Cannot find the user realm for the given tenant domain  :  "  +  CarbonContext  . getThreadLocalCarbonContext (  )  . getTenantDomain (  )  )  ;   }   }  catch  ( IdentityException e )   {  throw new TOTPException ( "TOTPTokenGenerator failed while trying to get the tenant ID of the user "  +  username ,  e )  ;   }  catch  ( UserStoreException e )   {  throw new TOTPException ( "TOTPTokenGenerator failed while trying to access userRealm of the user  :  "  +  username ,  e )  ;   }  return Long . toString ( token )  ;   } 	Use already defined Constants
protected void onCreate ( Bundle savedInstanceState )   {  super . onCreate ( savedInstanceState )  ;  setContentView ( R . layout . fui _ auth _ method _ picker _ layout )  ;  FlowParameters params  =  getFlowParams (  )  ;  mHandler  =  ViewModelProviders . of ( this )  . get ( SimpleProvidersHandler . class )  ;  mHandler . init ( params )  ;  populateIdpList ( params . providerInfo ,  mHandler )  ;  int logoId  =  params . logoId ;  if  ( logoId  =  =  AuthUI . NO _ LOGO )   {  findViewById ( R . id . logo )  . setVisibility ( View . GONE )  ;  ConstraintLayout layout  =  findViewById ( R . id . root )  ;  ConstraintSet constraints  =  new ConstraintSet (  )  ;  constraints . clone ( layout )  ;  constraints . setHorizontalBias ( R . id . container ,  0 . 5f )  ;  constraints . setVerticalBias ( R . id . container ,  0 . 5f )  ;  constraints . applyTo ( layout )  ;   }  else  {  ImageView logo  =  findViewById ( R . id . logo )  ;  logo . setImageResource ( logoId )  ;   }  mHandler . getOperation (  )  . observe ( this ,  new Observer < Resource < IdpResponse >  >  (  )   {   @ Override public void onChanged ( Resource < IdpResponse >  resource )   {  if  ( resource . getState (  )   =  =  State . LOADING )   {  getDialogHolder (  )  . showLoadingDialog ( R . string . fui _ progress _ dialog _ signing _ in )  ;  return ;   }  getDialogHolder (  )  . dismissDialog (  )  ;  if  ( resource . isUsed (  )  )   {  return ;   }  if  ( resource . getState (  )   =  =  State . SUCCESS )   {  startSaveCredentials ( mHandler . getCurrentUser (  )  ,  null ,  resource . getValue (  )  )  ;   }  else  {  Exception e  =  resource . getException (  )  ;  if  (  ! FlowUtils . handleError ( AuthMethodPickerActivity . this ,  e )   &  &  e . getLocalizedMessage (  )   !  =  null )   {  Toast . makeText ( AuthMethodPickerActivity . this ,  R . string . fui _ error _ unknown ,  Toast . LENGTH _ SHORT )  . show (  )  ;   }   }   }   }  )  ;   } 	nit: do you need AuthMethodPickerActivity.this or could it be just this?
public static Booleans copyOrUpdate ( Realm realm ,  Booleans object ,  boolean update ,  Map < RealmObject , RealmObjectProxy >  cache )   {  if  (  (  ( RealmObject )  object )  . realm  !  =  null  &  &   (  ( RealmObject )  object )  . realm . threadId  !  =  realm . threadId )   {  throw new IllegalArgumentException (  "Objects belonging to Realm instances in other threads cannot be copied into this Realm instance . " )  ;   }  if  (  (  ( RealmObject )  object )  . realm  !  =  null  &  &   (  ( RealmObject )  object )  . realm . getPath (  )  . equals ( realm . getPath (  )  )  )   {  return object ;   }  return copy ( realm ,  object ,  update ,  cache )  ;   } 	"belonging" -> "which belong"
public QName ( final String namespaceURI ,  final String localPart ,  final String prefix )   {  if  ( Objects . isNull ( namespaceURI )  )   {  setNamespaceURI ( XMLConstants . NULL _ NS _ URI )  ;   }  else  {  setNamespaceURI ( namespaceURI )  ;   }  if  ( Objects . isNull ( localPart )  )   {  throw new IllegalArgumentException ( "local part cannot be  \ "null \ " when creating a QName" )  ;   }  setLocalPart ( localPart )  ;  if  ( Objects . isNull ( prefix )  )   {  throw new IllegalArgumentException ( "prefix cannot be  \ "null \ " when creating a QName" )  ;   }  setPrefix ( prefix )  ;  setKey ( toString (  )  )  ;  String retrievedPrefix  =  getPrefix (  )  ;  final String usedPrefix  =   ( retrievedPrefix  =  =  null  |  |  retrievedPrefix . isEmpty (  )  )   ?  ""  :  retrievedPrefix  +  " : " ;  final String string  =  " { "  +  getNamespaceURI (  )   +  " } "  +  usedPrefix  +  getLocalPart (  )  ;  setString ( string )  ;   } 	it would fit easily one line
protected Deconvolution2D ( BaseConvBuilder <  ?  >  builder )   {  super ( builder )  ;  this . hasBias  =  builder . hasBias ;  this . convolutionMode  =  builder . convolutionMode ;  this . dilation  =  builder . dilation ;  if  ( builder . kernelSize . length  !  =  2 )  throw new IllegalArgumentException ( "Kernel size of should be rows x columns  ( a 2d array ) " )  ;  this . kernelSize  =  builder . kernelSize ;  if  ( builder . stride . length  !  =  2 )  throw new IllegalArgumentException ( "Stride should include stride for rows and columns  ( a 2d array ) " )  ;  this . stride  =  builder . stride ;  if  ( builder . padding . length  !  =  2 )  throw new IllegalArgumentException ( "Padding should include padding for rows and columns  ( a 2d array ) " )  ;  this . padding  =  builder . padding ;  this . cudnnAlgoMode  =  builder . cudnnAlgoMode ;  this . cudnnFwdAlgo  =  builder . cudnnFwdAlgo ;  this . cudnnBwdFilterAlgo  =  builder . cudnnBwdFilterAlgo ;  this . cudnnBwdDataAlgo  =  builder . cudnnBwdDataAlgo ;  initializeConstraints ( builder )  ;   } 	These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_0>
private static void getPackageFragmentRootContainers ( IRuntimeClasspathEntry entry ,  List < ISourceContainer >  containers )   {  IJavaModel model  =  JavaCore . create ( ResourcesPlugin . getWorkspace (  )  . getRoot (  )  )  ;  IPath entryPath  =  entry . getPath (  )  ;  boolean found  =  false ;  try  {  IJavaProject [  ]  jps  =  model . getJavaProjects (  )  ;  for  ( int i  =  0 ;  i  <  jps . length ;  i +  +  )   {  IJavaProject jp  =  jps [ i ]  ;  IProject p  =  jp . getProject (  )  ;  if  ( p . isOpen (  )  )   {  IPackageFragmentRoot [  ]  allRoots  =  jp . getPackageFragmentRoots (  )  ;  for  ( int j  =  0 ;  j  <  allRoots . length ;  j +  +  )   {  IPackageFragmentRoot root  =  allRoots [ j ]  ;  if  ( root . getPath (  )  . equals ( entryPath )   &  &  isSourceAttachmentEqual ( root ,  entry )  )   {  PackageFragmentRootSourceContainer container  =  new PackageFragmentRootSourceContainer ( root )  ;  if  (  ! containers . contains ( container )  )   {  containers . add ( container )  ;  found  =  true ;  break ;   }   }   }   }   }   }  catch  ( JavaModelException e )   {  LaunchingPlugin . log ( e )  ;   }  if  (  ! found )   {  tryToAddSourceAttachment ( entry ,  containers )  ;   }   } 	if it existed in containers, is it not sufficient?
private  < T >  T executeCall ( String methodName ,  Class < T >  returnType ,  Object [  ]  params )  throws ESException  {  if  ( client  =  =  null )   {  throw new ConnectionException ( ConnectionManager . REMOTE )  ;   }  if  ( Configuration . getClientBehavior (  )  . getChangePackageFragmentSize (  )  . isPresent (  )  )   {  for  ( int i  =  0 ;  i  <  params . length ;  i +  +  )   {  final Object param  =  params [ i ]  ;  if  ( param instanceof AbstractChangePackage  &  &   ! ChangePackageProxy . class . isInstance ( param )  )   {  params [ i ]   =  fragmentChangePackage (  ESCollections . find ( params ,  SessionId . class )  ,  ESCollections . find ( params ,  ProjectId . class )  ,  AbstractChangePackage . class . cast ( param )  )  ;   }   }   }  try  {  T result  =   ( T )  client . execute ( serverInterface  +  " . "  +  methodName ,  params )  ;  if  ( result instanceof Object [  ]  )   {  final Object [  ]  objects  =   ( Object [  ]  )  result ;  final Optional < SessionId >  maybeSession  =  ESCollections . find ( params ,  SessionId . class )  ;  for  ( int i  =  0 ;  i  <  objects . length ;  i +  +  )   {  final Object item  =  objects [ i ]  ;  if  ( ChangePackageProxy . class . isInstance ( item )  )   {  objects [ i ]   =  aggregateChangePackageFragments (  ( ChangePackageProxy )  item ,  maybeSession )  ;   }   }  result  =   ( T )  objects ;   }  return result ;   }  catch  ( final XmlRpcException e )   {  if  ( e . getCause (  )  instanceof ESException )   {  throw  ( ESException )  e . getCause (  )  ;   }  else if  ( e . linkedException instanceof SAXException  &  &   (  ( SAXException )  e . linkedException )  . getException (  )  instanceof SerializationException )   {  final SerializationException serialE  =   ( SerializationException )   (  ( SAXException )  e . linkedException )   . getException (  )  ;  throw new org . eclipse . emf . emfstore . internal . server . exceptions . SerializationException ( serialE )  ;   }  else  {  throw new ConnectionException ( ConnectionManager . REMOTE  +  e . getMessage (  )  ,  e )  ;   }   }   } 	The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
public void test (  )  throws IOException  {  Configuration cfg  =  new Configuration (  )  ;  for  ( Class <  ?  >  cl  :  Domain . classes )   {  cfg . addAnnotatedClass ( cl )  ;   }  HibernateDomainExporter exporter  =  new HibernateDomainExporter ( folder . getRoot (  )  ,  cfg )  ;  exporter . execute (  )  ;  File origRoot  =  new File ( " .  .  / querydsl - jpa / target / generated - test - sources / java" )  ;  Set < File >  files  =  exporter . getGeneratedFiles (  )  ;  assertFalse ( files . isEmpty (  )  )  ;  for  ( File file  :  files )   {  String path  =  file . getAbsolutePath (  )  . replace (  folder . getRoot (  )  . getAbsolutePath (  )  ,  origRoot . getAbsolutePath (  )  )  ;  String reference  =  Files . toString ( new File ( path )  ,  Charsets . UTF _ 8 )  ;  String content  =  Files . toString ( file ,  Charsets . UTF _ 8 )  ;  try  {  assertEquals ( file . getPath (  )  ,  reference ,  content )  ;   }  catch  ( Throwable e )   {  errors . addError ( e )  ;   }   }   } 	You don't want to move them all to hamcrest?
public String getName (  )   {  if  ( title  =  =  null )   {  if  ( base  =  =  null )   {  title  =  MessageFormat . format ( UIText . DiffEditorInput _ Title1 ,  tip . getObjectId (  )  . abbreviate ( 7 )  . name (  )  ,  GitLabels . getPlainShortLabel ( tip . getRepository (  )  )  )  ;   }  else  {  title  =  MessageFormat . format ( UIText . DiffEditorInput _ Title2 ,  base . getObjectId (  )  . abbreviate ( 7 )  . name (  )  ,  tip . getObjectId (  )  . abbreviate ( 7 )  . name (  )  ,  GitLabels . getPlainShortLabel ( tip . getRepository (  )  )  )  ;   }   }  return title ;   } 	looks like you missed these
void onContext ( ValueChangeEvent < String >  e )   {  String v  =  e . getValue (  )  ;  int c ;  if  ( v  !  =  null  &  &  v . length (  )   >  0 )   {  c  =  Math . min ( Math . max ( 0 ,  Integer . parseInt ( v )  )  ,  32767 )  ;  contextEntireFile . setValue ( false )  ;   }  else if  ( v  =  =  null  |  |  v . isEmpty (  )  )   {  c  =  WHOLE _ FILE _ CONTEXT ;  contextEntireFile . setValue ( true )  ;   }  else  {  return ;   }  prefs . context ( c )  ;  updateContextTimer . schedule ( 200 )  ;   } 	It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
public void testPublish (  )   {  byte [  ]  testBytes  =   {  }  ;  String testString  =  "Test" ;  when ( urlService . inputStreamToByteArray ( inputStream )  )  . thenReturn ( testBytes )  ;  when ( facebookService . publishToFacebook ( any ( byte [  ]  . class )  ,  any ( String . class )  ,  any ( String . class )  ,  any ( String . class )  ,  any ( String . class )  )  )  . thenReturn ( testString )  ;  Response response  =  resource . publish ( key ,  "Test" ,  inputStream ,  contentDisposition ,  "photo" ,  "Test" ,  "Test" )  ;  String result  =   ( String )  response . getEntity (  )  ;  assertEquals ( response . getStatusInfo (  )  ,  Response . Status . OK )  ;  assertEquals ( result ,  "Test" )  ;   } 	Same here with not needing the local variable.
public Response createBranchWithId ( long branchUuid ,  NewBranch data )   {  setUpHttpHeaders (  )  ;  if  ( branchUuid  <  =  0 )   {  throw new OseeWebApplicationException ( Status . BAD _ REQUEST ,  "branchUuid  [  % d ]  uuid must be  >  0" ,  branchUuid )  ;   }  CreateBranchData createData  =  new CreateBranchData (  )  ;  createData . setUuid ( branchUuid )  ;  createData . setName ( data . getBranchName (  )  )  ;  createData . setBranchType ( data . getBranchType (  )  )  ;  createData . setCreationComment ( data . getCreationComment (  )  )  ;  createData . setUserArtifact ( getArtifactById ( COMMON _ ID ,  data . getAuthorId (  )  )  )  ;  createData . setAssociatedArtifact ( getArtifactById ( COMMON _ ID ,  data . getAssociatedArtifactId (  )  )  )  ;  createData . setFromTransaction ( TokenFactory . createTransaction ( data . getSourceTransactionId (  )  )  )  ;  createData . setParentBranchUuid ( getBranchUuidFromTxId ( data . getSourceTransactionId (  )  )  )  ;  createData . setMergeDestinationBranchId ( data . getMergeDestinationBranchId (  )  )  ;  createData . setMergeAddressingQueryId ( data . getMergeAddressingQueryId (  )  )  ;  createData . setTxCopyBranchType ( data . isTxCopyBranchType (  )  )  ;  Callable < BranchReadable >  op  =  getBranchOps (  )  . createBranch ( createData )  ;  BranchReadable result  =  executeCallable ( op )  ;  UriInfo uriInfo  =  getUriInfo (  )  ;  URI uri  =  getBranchLocation ( uriInfo ,  result )  ;  activityLog . createEntry ( BRANCH _ OPERATION _ TYPEID ,  ActivityLog . INITIAL _ STATUS ,  String . format (  "Branch Operation Create Branch  { branchUUID :   % s ,  branchName :   % s accountId :   % s serverId :   % s clientId :   % s } " ,  branchUuid ,  data . getBranchName (  )  ,  accountId ,  serverId ,  clientId )  )  ;  return Response . created ( uri )  . entity ( asBranch ( result )  )  . build (  )  ;   } 	May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
public void perform ( GraphRewrite event ,  EvaluationContext context ,  XmlFileModel payload )   {  ClassificationService classificationService  =  new ClassificationService ( event . getGraphContext (  )  )  ;  ClassificationModel classificationModel  =  classificationService . attachClassification ( event ,  context ,  payload ,  IssueCategoryRegistry . MANDATORY ,  "WebSphere WS Binding" ,  "WebSphere Webservice Binding XML Deployment Descriptor .   \ n"  +  "This deployment descriptor extension is IBM - specific and it needs to be migrated to JBossWS .   \ n"  +  "JBossWS implements the latest JAX - WS specification ,  which users can reference for any vendor - agnostic web service usage need .   \ n"  +  "You can migrate deployment descriptors following the links below .   \ n" )  ;  classificationModel . setEffort ( 3 )  ;  GraphContext graphContext  =  event . getGraphContext (  )  ;  LinkService linkService  =  new LinkService ( graphContext )  ;  LinkModel documentationEAP6Link  =  linkService . create (  )  ;  documentationEAP6Link . setDescription ( "JAX - WS Web Services  ( EAP 6 ) " )  ;  documentationEAP6Link . setLink (  " < LINK _ 0 > " )  ;  classificationService . attachLink ( classificationModel ,  documentationEAP6Link )  ;  LinkModel documentationEAP7Link  =  linkService . create (  )  ;  documentationEAP7Link . setDescription ( "Developing JAX - WS Web Services  ( EAP 7 ) " )  ;  documentationEAP7Link . setLink (  " < LINK _ 2 > " )  ;  classificationService . attachLink ( classificationModel ,  documentationEAP7Link )  ;  LinkModel documentationCommunityLink  =  linkService . create (  )  ;  documentationCommunityLink . setDescription ( "JBossWS configuration  ( community documentation ) " )  ;  documentationCommunityLink . setLink ( " < LINK _ 1 > " )  ;  classificationService . attachLink ( classificationModel ,  documentationCommunityLink )  ;  TechnologyTagService technologyTagService  =  new TechnologyTagService ( event . getGraphContext (  )  )  ;  technologyTagService . addTagToFileModel ( payload ,  "WebSphere WS Binding" ,  TechnologyTagLevel . IMPORTANT )  ;   } 	again IBM-specific i would go with "IBM specific"
private void growup (  )   {  if  ( values . length  =  =  capacity (  )  )   {  throw new IllegalStateException ( "This matrix can ' t grow up . " )  ;   }  int c  =  rows  *  columns  <  0  ?  Integer . MAX _ VALUE  :  rows  *  columns ;  int capacity  =  Math . min ( c ,   ( cardinality  *  3 )   /  2  +  1 )  ;  double  $ values [  ]   =  new double [ capacity ]  ;  int  $ columnIndices [  ]   =  new int [ capacity ]  ;  System . arraycopy ( values ,  0 ,   $ values ,  0 ,  cardinality )  ;  System . arraycopy ( columnIndices ,  0 ,   $ columnIndices ,  0 ,  cardinality )  ;  values  =   $ values ;  columnIndices  =   $ columnIndices ;   } 	Probably, there is something wrong with idenations.
protected void executeQueryCommand (  )   {  List < Disk >  allDiskAndSnapshots  =  diskDao . getAllFromDisksIncludingSnapshots ( getUserID (  )  ,  getParameters (  )  . isFiltered (  )  )  ;  HashMap < UUID ,  DiskImage >  activeDisks  =  new HashMap <  >  (  )  ;  HashMap < UUID ,  List < DiskImage >  >  disksLeftForAggregate  =  new HashMap <  >  (  )  ;  List < Disk >  result  =  new ArrayList <  >  (  )  ;  allDiskAndSnapshots . stream (  )   . filter ( disk  -  >   {  if  ( disk . isOvfStore (  )  )   {  result . add ( disk )  ;  return false ;   }  return true ;   }  )   . filter ( disk  -  >   {  if  ( disk instanceof LunDisk )   {  result . add ( disk )  ;  return false ;   }  return true ;   }  )   . map ( diskImage  -  >   ( DiskImage )  diskImage )   . forEach ( diskImage  -  >   {  UUID imageId  =  diskImage . getId (  )  . getUuid (  )  ;  if  ( diskImage . getActive (  )  )   {  activeDisks . put ( imageId ,  diskImage )  ;  if  ( disksLeftForAggregate . containsKey ( imageId )  )   {  activeDisks . get ( imageId )  . getSnapshots (  )  . addAll ( disksLeftForAggregate . get ( imageId )  )  ;  disksLeftForAggregate . remove ( imageId )  ;   }   }  else  {  if  ( activeDisks . containsKey ( imageId )  )   {  activeDisks . get ( imageId )  . getSnapshots (  )  . add ( diskImage )  ;   }  else if  ( disksLeftForAggregate . containsKey ( imageId )  )   {  disksLeftForAggregate . get ( imageId )  . add ( diskImage )  ;   }  else  {  List < DiskImage >  newDiskImageList  =  new ArrayList <  >  (  )  ;  newDiskImageList . add ( diskImage )  ;  disksLeftForAggregate . put ( imageId ,  newDiskImageList )  ;   }   }   }  )  ;  result . addAll ( activeDisks . values (  )  . stream (  )  . collect ( Collectors . toList (  )  )  )  ;  getQueryReturnValue (  )  . setReturnValue ( result )  ;   } 	Map instead of concrete type
int blockPlayerWin (  )   {  int equalCount  =  0 ;  int emptyI  =  0 ,  emptyJ  =  0 ;  int winCombinationsNumber  =  fieldSize  *  2  +  2 ;  for  ( int k  =  0 ;  k  <  winCombinationsNumber ;  k +  +  )   {  equalCount  =  0 ;  for  ( int i  =  0 ;  i  <  fieldSize ;  i +  +  )  for  ( int j  =  0 ;  j  <  fieldSize ;  j +  +  )   {  if  ( fieldArray [ i ]  [ j ]   =  =  playerMark  &  &   ( getWinCombination ( k ,  i ,  j )   =  =  1 )  )   {  equalCount +  +  ;   }  if  (  ( fieldArray [ i ]  [ j ]   =  =  EMPTY _ MARK )   &  &   ( getWinCombination ( k ,  i ,  j )   =  =  1 )  )   {  emptyI  =  i ;  emptyJ  =  j ;   }  if  (  ( fieldArray [ i ]  [ j ]   =  =  aIMark )   &  &   ( getWinCombination ( k ,  i ,  j )   =  =  1 )  )   {  j  =  fieldSize ;  i  =  fieldSize ;  equalCount  =  0 ;   }   }  if  ( equalCount  =  =   ( fieldSize  -  1 )  )   {  return  ( emptyI  *  fieldSize  +  emptyJ )  ;   }   }  return NOTHING _ TO _ PREVENT ;   } 	Braces
public ConnectionPoolConfig ( VerifiableProperties verifiableProperties )   {  connectionPoolReadBufferSizeBytes  =  verifiableProperties . getIntInRange ( "connectionpool . read . buffer . size . bytes" ,  1048576 ,  1 ,  1024  *  1024  *  1024 )  ;  connectionPoolWriteBufferSizeBytes  =  verifiableProperties . getIntInRange ( "connectionpool . write . buffer . size . bytes" ,  1048576 ,  1 ,  1024  *  1024  *  1024 )  ;  connectionPoolReadTimeoutMs  =  verifiableProperties . getIntInRange ( "connectionpool . read . timeout . ms" ,  1500 ,  1 ,  100000 )  ;  connectionPoolConnectTimeoutMs  =  verifiableProperties . getIntInRange ( "connectionpool . connect . timeout . ms" ,  800 ,  1 ,  100000 )  ;  connectionPoolMaxConnectionsPerPortPlainText  =  verifiableProperties . getIntInRange ( "connectionpool . max . connections . per . port . plain . text" ,  5 ,  1 ,  20 )  ;  connectionPoolMaxConnectionsPerPortSSL  =  verifiableProperties . getIntInRange ( "connectionpool . max . connections . per . port . ssl" ,  2 ,  1 ,  20 )  ;   } 	isn't the default 2?
private static File asTemp ( InputStream in ,  String prefix ,  String suffix ,  File dir )  throws IOException  {  File tmp  =  File . createTempFile ( prefix ,  suffix ,  dir )  ;  boolean keep  =  false ;  try  {  FileOutputStream out  =  new FileOutputStream ( tmp )  ;  try  {  byte [  ]  data  =  new byte [ 8192 ]  ;  int n ;  while  (  ( n  =  in . read ( data )  )   >  0 )   {  out . write ( data ,  0 ,  n )  ;   }  keep  =  true ;  return tmp ;   }  finally  {  out . close (  )  ;   }   }  finally  {  if  (  ! keep )   {  tmp . delete (  )  ;   }   }   } 	unrelated bug fix?
public void writeTo ( final Object data ,  Class <  ?  >  type ,  Type genericType ,  Annotation [  ]  annotations ,  MediaType mediaType ,  MultivaluedMap < String ,  Object >  httpHeaders ,  OutputStream entityStream )  throws IOException ,  WebApplicationException  {  InputStream templateStream  =  null ;  try  {  String xslName  =  " / "  +  type . getSimpleName (  )   +  "AsPdf . xsl" ;  templateStream  =  type . getResourceAsStream ( xslName )  ;  if  ( templateStream  !  =  null )   {  StreamSource transformSource  =  new StreamSource ( templateStream )  ;  Method factoryMethod  =  null ;  for  ( Method currentMethod  :  objectFactory . getClass (  )  . getDeclaredMethods (  )  )   {  Class <  ?  >  [  ]  parameterTypes  =  currentMethod . getParameterTypes (  )  ;  if  ( parameterTypes . length  =  =  1  &  &  parameterTypes [ 0 ]   =  =  type )   {  factoryMethod  =  currentMethod ;  break ;   }   }  if  ( data  !  =  null  &  &  factoryMethod  !  =  null )   {  JAXBElement <  ?  >  element  =   ( JAXBElement <  ?  >  )  factoryMethod . invoke ( objectFactory ,  data )  ;  Source source  =  new JAXBSource ( jaxbContext ,  element )  ;  Transformer xslfoTransformer  =  transfact . newTransformer ( transformSource )  ;  Fop fop  =  fopFactory . newFop ( MimeConstants . MIME _ PDF ,  foUserAgent ,  entityStream )  ;  Result res  =  new SAXResult ( fop . getDefaultHandler (  )  )  ;  xslfoTransformer . transform ( source ,  res )  ;   }  else  {  log . error ( "No profile data is available for the selected volume" )  ;   }   }  else  {  log . error ( "Error while generating PDF . Null InputStream" )  ;   }   }  catch  ( Exception e )   {  log . error ( "Error while generating PDF . " ,  e )  ;   }  finally  {  if  ( templateStream  !  =  null )   {  templateStream . close (  )  ;   }   }   } 	Declare templateStream hear, as a local variable.
public void nonVmWithSameMTUAddedToNic (  )   {  Network net  =  createNetwork ( "VLanVmMtu9000" )  ;  net . setvlan _ id ( 100 )  ;  net . setMtu ( 9000 )  ;  Network newNet  =  createNetwork ( "nonVmMtu5000" )  ;  newNet . setVmNetwork ( false )  ;  newNet . setMtu ( 9000 )  ;  mockExistingNetworks ( net ,  newNet )  ;  VdsNetworkInterface nic  =  createNic ( "nic0" ,  null )  ;  VdsNetworkInterface nicWithVlan  =  createVlan ( nic . getName (  )  ,  net . getvlan _ id (  )  ,  net . getName (  )  )  ;  nicWithVlan . setMtu ( net . getMtu (  )  )  ;  mockExistingIfaces ( nic ,  nicWithVlan )  ;  nic . setNetworkName ( newNet . getName (  )  )  ;  SetupNetworksHelper helper  =  createHelper ( createParametersForNics ( nic ,  nicWithVlan )  )  ;  validateAndExpectNoViolations ( helper )  ;   } 	nonVmMtu5000 ==> nonVm
public Mono < MsalToken >  authenticateWithUsernamePassword ( TokenRequestContext request ,  String username ,  String password )   {  return Mono . fromFuture (  (  )   -  >  getPublicClientApplication ( false )  . acquireToken (  UserNamePasswordParameters . builder ( new HashSet <  >  ( request . getScopes (  )  )  ,  username ,  password . toCharArray (  )  )   . build (  )  )  )   . onErrorResume ( t  -  >  Mono . error ( new ClientAuthenticationException ( "Failed to acquire token with username "  +  "and password" ,  null ,  t )  )  )  . map ( ar  -  >  new MsalToken ( ar ,  options )  )  ;   } 	onErrorMap?
public void enableAccelerometer ( byte [  ]  config )   {  BluetoothLeGattCharacteristic accEnableChar ;  if  ( this . cc2650 )   {  try  {  accEnableChar  =  this . gattServices . get ( MOVEMENT )   . findCharacteristic ( TiSensorTagGatt . UUID _ MOV _ SENSOR _ ENABLE )  ;  byte [  ]  oldConfig  =  accEnableChar . readValue (  )  ;  Integer newConfig  =  ByteBuffer . wrap ( config )  . getShort (  )   |  ByteBuffer . wrap ( oldConfig )  . getShort (  )  ;  ByteBuffer bb  =  ByteBuffer . allocate ( 2 )  ;  bb . putShort ( newConfig . shortValue (  )  )  ;  accEnableChar . writeValue ( bb . array (  )  )  ;   }  catch  ( KuraException e )   {  logger . error ( MOV _ ERROR _ MESSAGE ,  e )  ;   }   }  else  {  try  {  accEnableChar  =  this . gattServices . get ( ACCELEROMETER )   . findCharacteristic ( TiSensorTagGatt . UUID _ ACC _ SENSOR _ ENABLE )  ;  accEnableChar . writeValue ( config )  ;   }  catch  ( KuraException e )   {  logger . error ( "Accelerometer enable failed" ,  e )  ;   }   }   } 	Similar
public void editAggregateProvidersAttributesTest (  )  throws Exception  {  String provider1name  =  randomAlphanumeric ( 5 )   +  " _ 1" ,  provider2name  =  randomAlphanumeric ( 5 )   +  " _ 2" ,  provider3name  =  randomAlphanumeric ( 5 )   +  " _ 3" ,  aggregateProvidersName  =  randomAlphanumeric ( 5 )  ;  Address provider1address  =  elyOps . getElytronAddress ( PROVIDER _ LOADER ,  provider1name )  ,  provider2address  =  elyOps . getElytronAddress ( PROVIDER _ LOADER ,  provider2name )  ,  provider3address  =  elyOps . getElytronAddress ( PROVIDER _ LOADER ,  provider3name )  ,  aggregateProvidersAddress  =  elyOps . getElytronAddress ( AGGREGATE _ PROVIDERS ,  aggregateProvidersName )  ;  page . navigateToApplication (  )  . selectResource ( AGGREGATE _ PROVIDERS _ LABEL )  ;  try  {  ops . add ( provider1address )  . assertSuccess (  )  ;  ops . add ( provider2address )  . assertSuccess (  )  ;  ops . add ( provider3address )  . assertSuccess (  )  ;  ops . add ( aggregateProvidersAddress ,  Values . of ( PROVIDERS ,  new ModelNodeListBuilder (  )   . addNode ( new ModelNode ( provider1name )  )   . addNode ( new ModelNode ( provider2name )  )  . build (  )  )  )  ;  page . navigateToApplication (  )  . selectResource ( AGGREGATE _ PROVIDERS _ LABEL )  . getResourceManager (  )   . selectByName ( aggregateProvidersName )  ;  page . switchToConfigAreaTab ( ATTRIBUTES _ LABEL )  ;  new ConfigChecker . Builder ( client ,  aggregateProvidersAddress )  . configFragment ( page . getConfigFragment (  )  )   . editAndSave ( TEXT ,  PROVIDERS ,  provider2name  +  " \ n"  +  provider3name )  . verifyFormSaved (  )   . verifyAttribute ( PROVIDERS ,  new ModelNodeListBuilder (  )   . addNode ( new ModelNode ( provider2name )  )   . addNode ( new ModelNode ( provider3name )  )  . build (  )  )  ;   }  finally  {  ops . removeIfExists ( aggregateProvidersAddress )  ;  ops . removeIfExists ( provider1address )  ;  ops . removeIfExists ( provider2address )  ;  ops . removeIfExists ( provider3address )  ;  adminOps . reloadIfRequired (  )  ;   }   } 	Navigating again...
protected File findPom ( String side ,  String version ,  File json )  throws IOException  {  File pom  =  cache ( "versions" ,  version ,  side  +  " . pom" )  ;  HashStore cache  =  new HashStore ( this . cache )  . load ( cache ( "versions" ,  version ,  side  +  " . pom . input" )  )  ;  if  ( "client" . equals ( side )  )   {  cache . add ( json )  ;   }  if  (  ! cache . isSame (  )   |  |   ! pom . exists (  )  )   {  POMBuilder builder  =  new POMBuilder ( GROUP ,  side ,  version )  ;  if  ( "client" . equals ( side )  )   {  VersionJson meta  =  Utils . loadJson ( json ,  VersionJson . class )  ;  for  ( VersionJson . Library lib  :  meta . libraries )   {  if  ( lib . downloads . classifiers  !  =  null )   {  if  ( lib . downloads . classifiers . containsKey ( "test" )  )   {  builder . dependencies (  )  . add ( lib . name ,  "test" )  . withClassifier ( "test" )  ;   }  if  ( lib . natives  !  =  null  &  &  lib . natives . containsKey ( CURRENT _ OS )   &  &   ! lib . getArtifact (  )  . getName (  )  . contains ( "java - objc - bridge" )  )   {  builder . dependencies (  )  . add ( lib . name ,  "runtime" )  . withClassifier ( lib . natives . get ( CURRENT _ OS )  )  ;   }   }  else  {  builder . dependencies (  )  . add ( lib . name ,  "compile" )  ;   }   }   }  else  {  builder . dependencies (  )  . add ( GROUP  +  " : "  +  side  +  " : "  +  version ,  "compile" )  . withClassifier ( "extra" )  ;   }  builder . dependencies (  )  . add ( GROUP  +  " : "  +  side  +  " : "  +  version ,  "compile" )  . withClassifier ( "data" )  ;  builder . dependencies (  )  . add ( "com . google . code . findbugs : jsr305 : 3 . 0 . 1" ,  "compile" )  ;  String ret  =  builder . tryBuild (  )  ;  if  ( ret  =  =  null )   {  return null ;   }  FileUtils . writeByteArrayToFile ( pom ,  ret . getBytes (  )  )  ;  cache . save (  )  ;  Utils . updateHash ( pom )  ;   }  return pom ;   } 	Not really.
 @ Override public int selectString ( Options options )  throws IOException  {  int p  =  peeked ;  if  ( p  =  =  PEEKED _ NONE )   {  p  =  doPeek (  )  ;   }  if  ( p  !  =  PEEKED _ DOUBLE _ QUOTED )   {  return  - 1 ;   }  int result  =  source . select ( options . doubleQuoteSuffix )  ;  if  ( result  =  =   - 1 )   {  String nextString  =  nextString (  )  ;  for  ( int i  =  0 ,  size  =  options . strings . length ;  i  <  size ;  i +  +  )   {  if  ( nextString . equals ( options . strings [ i ]  )  )   {  result  =  i ;  peeked  =  PEEKED _ NONE ;  pathIndices [ stackSize  -  1 ]  +  +  ;  break ;   }   }  if  ( result  =  =   - 1 )   {  peeked  =  PEEKED _ BUFFERED ;  peekedString  =  nextString ;  pathIndices [ stackSize  -  1 ]  -  -  ;   }   }  else  {  peeked  =  PEEKED _ NONE ;  pathIndices [ stackSize  -  1 ]  +  +  ;   }  return result ;   } 	ooh, I would have probably missed this.
public void updateMessage (  )  throws Exception  {  assertThat ( modifier . createEdit ( change ,  getCurrentPatchSet ( changeId )  )  )   . isEqualTo ( RefUpdate . Result . NEW )  ;  Optional < ChangeEdit >  edit  =  editUtil . byChange ( change )  ;  try  {  modifier . modifyMessage (  edit . get (  )  ,  edit . get (  )  . getEditCommit (  )  . getFullMessage (  )  )  ;  fail ( "InvalidChangeOperationException expected" )  ;   }  catch  ( UnchangedCommitMessage ex )   {  assertThat ( ex . getMessage (  )  )  . isEqualTo (  "New commit message cannot be same as existing commit message" )  ;   }  String msg  =  String . format ( "New commit message \ n \ nChange - Id :   % s" ,  change . getKey (  )  )  ;  assertThat ( modifier . modifyMessage ( edit . get (  )  ,  msg )  )  . isEqualTo (  RefUpdate . Result . FORCED )  ;  edit  =  editUtil . byChange ( change )  ;  assertThat ( edit . get (  )  . getEditCommit (  )  . getFullMessage (  )  )  . isEqualTo ( msg )  ;  editUtil . publish ( edit . get (  )  )  ;  assertThat ( editUtil . byChange ( change )  . isPresent (  )  )  . isFalse (  )  ;  ChangeInfo info  =  get ( changeId ,  ListChangesOption . CURRENT _ COMMIT ,  ListChangesOption . CURRENT _ REVISION )  ;  assertThat ( info . revisions . get ( info . currentRevision )  . commit . message )   . isEqualTo ( msg )  ;   } 	UnchangedCommitMessageException
private long getCowVirtualSize ( String id )  throws IOException  {  byte [  ]  imgContent  =  new byte [ 72 ]  ;  ImageDownload downloadImage  =  getGlanceClient (  )  . images (  )  . download ( id )  . execute (  )  ;  try  {  int bytesRead  =  downloadImage . getInputStream (  )  . read ( imgContent ,  0 ,  imgContent . length )  ;  if  ( bytesRead  !  =  imgContent . length )   {  throw new RuntimeException ( "Unable to read image header :  "  +  bytesRead )  ;   }   }  finally  {  downloadImage . getInputStream (  )  . close (  )  ;   }  ByteBuffer b  =  ByteBuffer . wrap ( imgContent )  ;  if  ( b . getInt (  )   =  =  0x514649fb  &  &  b . getInt (  )   =  =  2 )   {  b . position ( 24 )  ;  return b . getLong (  )  ;   }  throw new RuntimeException ( "Unable to recognize QCOW2 format" )  ;   } 	please extract these constants
public void swap ( INDArray x ,  INDArray y )   {  if  ( Nd4j . getExecutioner (  )  . getProfilingMode (  )   =  =  OpExecutioner . ProfilingMode . ALL )  OpProfiler . getInstance (  )  . processBlasCall ( false ,  x ,  y )  ;  if ( x . isSparse (  )   |  |  y . isSparse (  )  )   {  Nd4j . getSparseBlasWrapper (  )  . level1 (  )  . swap ( x ,  y )  ;   }  if  ( x . data (  )  . dataType (  )   =  =  DataBuffer . Type . DOUBLE )   {  DefaultOpExecutioner . validateDataType ( DataBuffer . Type . DOUBLE ,  x ,  y )  ;  dswap ( x . length (  )  ,  x ,  BlasBufferUtil . getBlasStride ( x )  ,  y ,  BlasBufferUtil . getBlasStride ( y )  )  ;   }  else  {  DefaultOpExecutioner . validateDataType ( DataBuffer . Type . FLOAT ,  x ,  y )  ;  sswap ( x . length (  )  ,  x ,  BlasBufferUtil . getBlasStride ( x )  ,  y ,  BlasBufferUtil . getBlasStride ( y )  )  ;   }   } 	@raver119 I feel like this should be in a util class of some kind?
public static void openConsole ( File file )  throws IOException  {  if  ( file  =  =  null )   {  return ;   }  String absolutePath  =  file . toPath (  )  . toAbsolutePath (  )  . getParent (  )  . toString (  )  ;  boolean usingDefault  =  Globals . prefs . getBoolean ( JabRefPreferences . USE _ DEFAULT _ CONSOLE _ APPLICATION )  ;  if  ( usingDefault )   {  NATIVE _ DESKTOP . openConsole ( absolutePath )  ;   }  else  {  String command  =  Globals . prefs . get ( JabRefPreferences . CONSOLE _ COMMAND )  ;  command  =  command . trim (  )  ;  if  (  ! command . isEmpty (  )  )   {  command  =  command . replaceAll ( " \  \ s + " ,  " " )  ;  String [  ]  subcommands  =  command . split ( " " )  ;  String commandLoggingText  =  command . replace ( " % DIR" ,  absolutePath )  ;  JabRefGUI . getMainFrame (  )  . getDialogService (  )  . notify ( Localization . lang ( "Executing command  \ " % 0 \ " .  .  . " ,  commandLoggingText )  )  ;  LOGGER . info ( "Executing command  \ ""  +  commandLoggingText  +  " \ " .  .  . " )  ;  try  {  new ProcessBuilder ( subcommands )  . start (  )  ;   }  catch  ( IOException exception )   {  LOGGER . error ( "Open console" ,  exception )  ;  JOptionPane . showMessageDialog ( null ,  Localization . lang ( "Error occured while executing the command  \ " % 0 \ " . " ,  commandLoggingText )  ,  Localization . lang ( "Open console" )   +  "  -  "  +  Localization . lang ( "Error" )  ,  JOptionPane . ERROR _ MESSAGE )  ;   }   }   }   } 	I think output is deprecated, you should instead use DialogService.
private ISYBindingConfig parseConfig ( final Item item ,  final String bindingConfig )  throws BindingConfigParseException  {  ISYNodeType type ;  String controller  =  null ;  String address  =  null ;  ISYControl command  =  null ;  if  ( item instanceof GroupItem )   {  type  =  ISYNodeType . GROUP ;   }  else if  ( item instanceof ContactItem )   {  type  =  ISYNodeType . CONTACT ;   }  else if  ( item instanceof NumberItem )   {  type  =  ISYNodeType . NUMBER ;   }  else if  ( item instanceof StringItem )   {  type  =  ISYNodeType . STRING ;   }  else if  ( item instanceof DimmerItem )   {  type  =  ISYNodeType . DIMMER ;   }  else if  ( item instanceof DateTimeItem )   {  type  =  ISYNodeType . HEARTBEAT ;   }  else  {  type  =  ISYNodeType . SWITCH ;   }  String [  ]  arr  =  bindingConfig . split ( " , " )  ;  for  ( String str  :  arr )   {  String [  ]  pair  =  str . split ( " = " )  ;  String key  =  pair [ 0 ]  ;  String value  =  pair [ 1 ]  ;  switch  ( key )   {  case "ctrl" :  controller  =  value . replace (  '  .  '  ,   '   '  )  ;  break ;  case "addr" :  address  =  value . replace (  '  .  '  ,   '   '  )  ;  break ;  case "type" :  if  ( "thermostat" . equalsIgnoreCase ( value )  )   {  type  =  ISYNodeType . THERMOSTAT ;   }  if  ( "lock" . equalsIgnoreCase ( value )  )   {  type  =  ISYNodeType . LOCK ;   }  if  ( "heartbeat" . equalsIgnoreCase ( value )  )   {  type  =  ISYNodeType . HEARTBEAT ;   }  break ;  case "cmd" :  try  {  command  =  ISYControl . valueOf ( value . toUpperCase (  )  )  ;   }  catch  ( IllegalArgumentException ie )   {  throw new BindingConfigParseException ( "Unsupported cmd "  +  value . toString (  )  )  ;   }  break ;   }   }  if  ( address  =  =  null )   {  address  =  controller ;   }  return new ISYBindingConfig ( item ,  type ,  controller ,  address ,  command )  ;   } 	throws BindingConfigParseException
private TestResult runAll4x (  )  throws Exception  {  List < String >  testClassNames  =  new ArrayList <  >  (  )  ;  Files . walk ( Paths . get ( projectPath ,  "target" ,  "test - classes" )  )  . forEach ( filePath  -  >   {  if  ( Files . isRegularFile ( filePath )   &  &  filePath . toString (  )  . toLowerCase (  )  . endsWith ( " . class" )  )   {  String path  =  Paths . get ( projectPath ,  "target" ,  "test - classes" )  . relativize ( filePath )  . toString (  )  ;  String className  =  path . replace (  '  /  '  ,   '  .  '  )  ;  className  =  className . replace (  '  \  \  '  ,   '  .  '  )  ;  className  =  className . substring ( 0 ,  className . length (  )   -  6 )  ;  testClassNames . add ( className )  ;   }   }  )  ;  List < Class >  testableClasses  =  new ArrayList <  >  (  )  ;  for  ( String className  :  testClassNames )   {  Class <  ?  >  clazz  =  Class . forName ( className ,  false ,  projectClassLoader )  ;  if  ( isTestable4x ( clazz )  )   {  testableClasses . add ( clazz )  ;   }   }  return run4xTestClasses ( testableClasses . toArray ( new Class [ testableClasses . size (  )  ]  )  )  ;   } 	path separator?
private Phenotype updatePhenotype (  final Integer observationId ,  final Integer categoricalValueId ,  final String value ,  final Boolean draftMode )   {  final PhenotypeDao phenotypeDao  =  this . daoFactory . getPhenotypeDAO (  )  ;  final Phenotype phenotype  =  phenotypeDao . getById ( observationId )  ;  if  ( draftMode )   {  phenotype . setDraftValue ( value )  ;  phenotype . setDraftCValueId ( categoricalValueId  =  =  null  |  |  categoricalValueId  =  =  0  ?  null  :  categoricalValueId )  ;   }  else  {  phenotype . setValue ( value )  ;  phenotype . setcValue ( categoricalValueId  =  =  null  |  |  categoricalValueId  =  =  0  ?  null  :  categoricalValueId )  ;   }  final Integer observableId  =  phenotype . getObservableId (  )  ;  this . resolveObservationStatus ( observableId ,  phenotype )  ;  phenotype . setChanged ( true )  ;  phenotypeDao . update ( phenotype )  ;  return phenotype ;   } 	datasetId is unused in reorganizePhenotypesStatus method
public Pair < List < Guid >  ,  Guid >  balance ( VDSGroup cluster ,  List < VDS >  hosts ,  Map < String ,  String >  parameters ,  ArrayList < String >  messages )   {  final Pair < List < Guid >  ,  Guid >  migrationRule  =  super . balance ( cluster ,  hosts ,  parameters ,  messages )  ;  List < VDS >  allHosts  =  DbFacade . getInstance (  )  . getVdsDao (  )  . getAllForVdsGroup ( cluster . getId (  )  )  ;  Pair < VDS ,  VDSStatus >  action  =  evaluatePowerManagementSituation (  getDownHosts ( allHosts ,  parameters )  ,  getMaintenanceHosts ( allHosts ,  parameters )  ,  getEmptyHosts ( allHosts ,  parameters )  ,  parameters  )  ;  if  ( action  !  =  null )  processPmAction ( action )  ;  return migrationRule ;   } 	Single pass is needed here.
public LowLevelHttpResponse execute (  )  throws IOException  {  if  ( getStreamingContent (  )   !  =  null )   {  Preconditions . checkArgument (  request instanceof HttpEntityEnclosingRequest ,  "Apache HTTP client does not support  % s requests with content . " ,  request . getRequestLine (  )  . getMethod (  )  )  ;  ContentEntity entity  =  new ContentEntity ( getContentLength (  )  ,  getStreamingContent (  )  )  ;  entity . setContentEncoding ( getContentEncoding (  )  )  ;  entity . setContentType ( getContentType (  )  )  ;  if  ( getContentLength (  )   =  =   - 1 )   {  entity . setChunked ( true )  ;   }   (  ( HttpEntityEnclosingRequest )  request )  . setEntity ( entity )  ;   }  return new ApacheHttpResponse ( request ,  httpClient . execute ( request )  )  ;   } 	checkState
public void onMessage ( Message message )   {  try  {  log . infof ( "onMessage received message :   % s  '  % s ' " ,  message ,   (  ( TextMessage )  message )  . getText (  )  )  ;  if ( checker . getRolledback (  )   >  0 )   {  log . infof ( "Discarding message  '  % s '  as onMessage called for second time" ,  message )  ;  return ;   }  final Destination replyTo  =  message . getJMSReplyTo (  )  ;  if  ( replyTo  =  =  null )   {  throw new RuntimeException ( "ReplyTo info in message was not specified"  +  " and bean does not know where to reply to" )  ;   }  TxTestUtil . enlistTestXAResource ( tm . getTransaction (  )  )  ;  try  (  JMSContext context  =  factory . createContext (  )   )   {  context . createProducer (  )   . setJMSCorrelationID ( message . getJMSMessageID (  )  )   . send ( replyTo ,  REPLY _ PREFIX  +   (  ( TextMessage )  message )  . getText (  )  )  ;   }  TxTestUtil . waitForTimeout ( tm )  ;   }  catch  ( Exception e )   {  throw new RuntimeException ( "onMessage method execution failed" ,  e )  ;   }   } 	log.tracef
private Object convertValue ( Object value ,  Type type )   {  if  ( value  =  =  null )   {  return null ;   }  if  ( BOOLEAN . equals ( type )   |  |  Varchars . isVarcharType ( type )  )   {  return value ;   }  if  ( BIGINT . equals ( type )  )   {  return  (  ( Number )  value )  . longValue (  )  ;   }  if  ( INTEGER . equals ( type )  )   {  return  (  ( Number )  value )  . intValue (  )  ;   }  if  ( DOUBLE . equals ( type )  )   {  return  (  ( Number )  value )  . doubleValue (  )  ;   }  if  ( DATE . equals ( type )  )   {  return value ;   }  throw new AssertionError ( "unhandled type :  "  +  type )  ;   } 	Unhandled
public void getCallsListUsingSorting (  )   {  JsonObject response1  =  RestcommCallsTool . getInstance (  )  . getCalls ( deploymentUrl . toString (  )  ,  adminAccountSid ,  adminAuthToken ,  0 ,  10 ,  "date _ created : asc" ,  true )  ;  assertTrue (  (  ( JsonObject ) response1 . get ( "calls" )  . getAsJsonArray (  )  . get ( 0 )  )  . get ( "date _ created" )  . getAsString (  )  . equals ( "Fri ,  5 Jul 2013 22 : 15 : 53  + 0300" )  )  ;  JsonObject response2  =  RestcommCallsTool . getInstance (  )  . getCalls ( deploymentUrl . toString (  )  ,  adminAccountSid ,  adminAuthToken ,  0 ,  10 ,  "date _ created" ,  true )  ;  assertTrue (  (  ( JsonObject ) response2 . get ( "calls" )  . getAsJsonArray (  )  . get ( 0 )  )  . get ( "date _ created" )  . getAsString (  )  . equals ( "Tue ,  31 May 2016 16 : 20 : 22  + 0300" )  )  ;  JsonObject response3  =  RestcommCallsTool . getInstance (  )  . getCalls ( deploymentUrl . toString (  )  ,  adminAccountSid ,  adminAuthToken ,  0 ,  10 ,  "date _ created : desc" ,  true )  ;  assertTrue (  (  ( JsonObject ) response3 . get ( "calls" )  . getAsJsonArray (  )  . get ( 0 )  )  . get ( "date _ created" )  . getAsString (  )  . equals ( "Tue ,  31 May 2016 16 : 20 : 22  + 0300" )  )  ;  JsonObject response4  =  RestcommCallsTool . getInstance (  )  . getCalls ( deploymentUrl . toString (  )  ,  adminAccountSid ,  adminAuthToken ,  0 ,  10 ,  null ,  true )  ;  assertTrue (  (  ( JsonObject ) response4 . get ( "calls" )  . getAsJsonArray (  )  . get ( 0 )  )  . get ( "date _ created" )  . getAsString (  )  . equals ( "Tue ,  31 May 2016 16 : 20 : 22  + 0300" )  )  ;  try  {  RestcommCallsTool . getInstance (  )  . getCalls ( deploymentUrl . toString (  )  ,  adminAccountSid ,  adminAuthToken ,  0 ,  10 ,  " : asc" ,  true )  ;   }  catch  ( UniformInterfaceException e )   {  assertTrue ( e . getResponse (  )  . getStatus (  )   =  =  BAD _ REQUEST . getStatusCode (  )  )  ;   }  try  {  RestcommCallsTool . getInstance (  )  . getCalls ( deploymentUrl . toString (  )  ,  adminAccountSid ,  adminAuthToken ,  0 ,  10 ,  "start _ time : invalid" ,  true )  ;   }  catch  ( UniformInterfaceException e )   {  assertTrue ( e . getResponse (  )  . getStatus (  )   =  =  BAD _ REQUEST . getStatusCode (  )  )  ;   }   } 	nit: if (p != null)
public int getInt ( int length ,  boolean signed )   {  if  ( length  =  =  0 )   {  return 0 ;   }  if  (  ! canRead ( length )  )   {  throw new BufferOverflowException (  )  ;   }  int val  =  0 ;  boolean gotIt  =  false ;  if  ( this . pos  %  BitBuffer . BIT _ CHAR  =  =  0 )   {  switch  ( length )   {  case BitBuffer . BIT _ CHAR :  val  =  this . buf . get (  ( int )   ( this . pos  /  8 )  )  ;  if  (  ! signed )   {  val  =  val  &  0xff ;   }  gotIt  =  true ;  break ;  case BitBuffer . BIT _ SHORT :  val  =  this . buf . getShort (  ( int )   ( this . pos  /  8 )  )  ;  if  (  ! signed )   {  val  =  val  &  0xffff ;   }  gotIt  =  true ;  break ;  case BitBuffer . BIT _ INT :  val  =  this . buf . getInt (  ( int )   ( this . pos  /  8 )  )  ;  gotIt  =  true ;  break ;  default :  break ;   }   }  if  (  ! gotIt )   {  if  ( this . byteOrder  =  =  ByteOrder . LITTLE _ ENDIAN )   {  val  =  getIntLE ( this . pos ,  length ,  signed )  ;   }  else  {  val  =  getIntBE ( this . pos ,  length ,  signed )  ;   }   }  this . pos  +  =  length ;  return val ;   } 	remove useless blank line
private void visitClassOrInterface ( String name ,  FunctionType ftype )   {  final boolean emitInstance  =   ! ftype . isInterface (  )  ;  if  ( emitInstance )   {  emit ( "class" )  ;  emit ( name )  ;  visitTemplateTypes ( ftype )  ;  emit ( "extends" )  ;  emit ( name  +  INSTANCE _ CLASS _ SUFFIX )  ;  visitTemplateTypes ( ftype )  ;  emit ( " { " )  ;  indent (  )  ;  emitBreak (  )  ;  visitProperties ( ftype ,  true )  ;  unindent (  )  ;  emit ( " } " )  ;  emitBreak (  )  ;   }  if  ( ftype . isConstructor (  )  )   {  emit ( "class" )  ;   }  else if  ( ftype . isInterface (  )  )   {  emit ( "interface" )  ;   }  else  {  checkState ( false ,  "Unexpected function type "  +  ftype )  ;   }  emit ( emitInstance  ?  name  +  INSTANCE _ CLASS _ SUFFIX  :  name )  ;  visitTemplateTypes ( ftype )  ;  if  ( ftype . getExtendedInterfacesCount (  )   >  0 )   {  emit ( "extends" )  ;  Iterator < ObjectType >  it  =  ftype . getExtendedInterfaces (  )  . iterator (  )  ;  emitCommaSeparatedInterfaces ( it )  ;   }  ObjectType superType  =  getSuperType ( ftype )  ;  if  ( superType  !  =  null )   {  emit ( "extends" )  ;  if  ( isPrivate ( superType . getJSDocInfo (  )  )  )   {  emit ( Constants . INTERNAL _ NAMESPACE  +  " . PrivateClass" )  ;   }  else  {  Visitor < Void >  visitor  =  new ExtendsImplementsTypeVisitor (  emitInstance  &  &   ! isDefinedInPlatformExterns ( superType )  )  ;  superType . visit ( visitor )  ;   }   }  Iterator < ObjectType >  it  =  ftype . getOwnImplementedInterfaces (  )  . iterator (  )  ;  if  ( it . hasNext (  )  )   {  emit ( "implements" )  ;  emitCommaSeparatedInterfaces ( it )  ;   }  boolean implementsIArrayLike  =  any ( ftype . getOwnImplementedInterfaces (  )  ,  IARRAYLIKE _ PREDICATE )  ;  visitObjectType ( ftype ,  ftype . getPrototype (  )  ,  ftype . isDict (  )   |  |  implementsIArrayLike )  ;   } 	whitespace is a bit off here
public void startExec ( String execId ,  MessageProcessor < LogMessage >  execOutputProcessor )  throws IOException  {  final List < Pair < String ,   ?  >  >  headers  =  new ArrayList <  >  ( 2 )  ;  headers . add ( Pair . of ( "Content - Type" ,  "application / json" )  )  ;  final ExecStart execStart  =  new ExecStart (  )  . withDetach ( execOutputProcessor  =  =  null )  ;  final String entity  =  JsonHelper . toJson ( execStart ,  FIRST _ LETTER _ LOWERCASE )  ;  headers . add ( Pair . of ( "Content - Length" ,  entity . getBytes (  )  . length )  )  ;  try  ( DockerConnection connection  =  openConnection ( dockerDaemonUri )  . method ( "POST" )   . path ( " / exec / "  +  execId  +  " / start" )   . headers ( headers )   . entity ( entity )  )   {  final DockerResponse response  =  connection . request (  )  ;  final int status  =  response . getStatus (  )  ;  if  ( status  /  100  !  =  2 )   {  throw new DockerException ( getDockerExceptionMessage ( response )  ,  status )  ;   }  if  ( status  !  =  204  &  &  execOutputProcessor  !  =  null )   {  try  ( InputStream responseStream  =  response . getInputStream (  )  )   {  new LogMessagePumper ( responseStream ,  execOutputProcessor )  . start (  )  ;   }   }   }   } 	constant?
private void updateSnapshotConfigWithoutImage ( Guid imageGroupToRemove )   {  List < DiskImage >  snapshotDisks  =  getDiskImageDao (  )  . getAllSnapshotsForImageGroup ( imageGroupToRemove )  ;  for  ( DiskImage snapshotDisk  :  snapshotDisks )   {  NGuid vmSnapshotId  =  snapshotDisk . getvm _ snapshot _ id (  )  ;  if  ( vmSnapshotId  !  =  null  &  &   ! Guid . Empty . equals ( vmSnapshotId . getValue (  )  )  )   {  try  {  lockSnapshotWithWait ( vmSnapshotId . getValue (  )  )  ;  final Snapshot updated  =  prepareSnapshotConfigWithoutImageSingleImage ( vmSnapshotId . getValue (  )  ,  snapshotDisk . getImageId (  )  )  ;  if  ( updated  !  =  null )   {  TransactionSupport . executeInScope ( TransactionScopeOption . RequiresNew ,  new TransactionMethod < Object >  (  )   {   @ Override public Object runInTransaction (  )   {  getSnapshotDao (  )  . update ( updated )  ;  return null ;   }   }  )  ;   }   }  finally  {  freeSnapshotLock (  )  ;   }   }   }   } 	free the lock in a finally block
public void MercuryCuratedNavigationTest _ 004 _ navigateThroughDifferentUrl (  )   {  CuratedContentPageObject section  =  new CuratedContentPageObject ( driver )  ;  String expectedUrl  =  urlBuilder . getUrlForPathWithoutWiki ( Configuration . getWikiName (  )  ,  MercurySubpages . CC _ CATEGORY _ TEMPLATES )  ;  String testUrl  =  expectedUrl ;  section . openWikiPage ( testUrl )  ;  section . waitForLoadingSpinnerToFinish (  )  ;  Assertion . assertUrlEqualToCurrentUrl ( driver ,  expectedUrl )  ;  expectedUrl  =  urlBuilder . getUrlForPathWithoutWiki ( Configuration . getWikiName (  )  ,  MercurySubpages . CC _ SECTION _ CATEGORIES )  ;  testUrl  =  expectedUrl ;  section . openWikiPage ( testUrl )  ;  section . waitForLoadingSpinnerToFinish (  )  ;  Assertion . assertUrlEqualToCurrentUrl ( driver ,  expectedUrl )  ;  expectedUrl  =  urlBuilder . getUrlForPath ( Configuration . getWikiName (  )  ,  MercurySubpages . CC _ MAIN _ PAGE )  ;  testUrl  =  urlBuilder . getUrlForPathWithoutWiki ( Configuration . getWikiName (  )  ,  MercurySubpages . CC _ EMPTY _ CATEGORY )  ;  section . openWikiPage ( testUrl )  ;  section . waitForLoadingSpinnerToFinish (  )  ;  Assertion . assertUrlEqualToCurrentUrl ( driver ,  expectedUrl )  ;  expectedUrl  =  urlBuilder . getUrlForPath ( Configuration . getWikiName (  )  ,  MercurySubpages . CC _ MAIN _ PAGE )  ;  testUrl  =  urlBuilder . getUrlForPathWithoutWiki ( Configuration . getWikiName (  )  ,  MercurySubpages . CC _ NOT _ EXISTING _ SECTION )  ;  section . openWikiPage ( testUrl )  ;  section . waitForLoadingSpinnerToFinish (  )  ;  MercuryAlertComponentObject mercuryError  =  new MercuryAlertComponentObject (  driver ,  Mercury . AlertMessage . NOT _ EXISTING _ SECTION )  ;  Assertion . assertTrue ( mercuryError . isAlertMessageVisible (  )  )  ;  Assertion . assertUrlEqualToCurrentUrl ( driver ,  expectedUrl )  ;   } 	please declare variable in first usage
public void testScenarios (  )  throws IOException ,  DockerCertificateException  {  String testResourcesPath  =  getClass (  )  . getClassLoader (  )  . getResource ( " . " )  . getPath (  )  ;  TestScenariosFinder testScenariosFinder  =  new TestScenariosFinder ( testResourcesPath )  ;  List < TestScenario >  testScenarios  =  testScenariosFinder . getScenarios (  )  ;  TestScenarioRunner caseRunner  =  new TestScenarioRunner ( ProjectVersion . currentVersion (  )  ,  9080 )  ;  int successfulScenarios  =  0 ;  int failedScenarios  =  0 ;  for  ( TestScenario testScenario :  testScenarios )   {  if  ( testScenario . enabledTests (  )   =  =  0 )   {  continue ;   }  int successfulTestCases  =  caseRunner . run ( testScenario )  ;  if  ( successfulTestCases  =  =  testScenario . enabledTests (  )  )   {  System . out . println ( " \ nScenario success :  "  +  testScenario  +  " \ n" )  ;  System . out . println ( "Number of successful test cases :  "  +  successfulTestCases )  ;  successfulScenarios +  +  ;   }  else  {  System . out . println ( " \ nScenario failed :  "  +  testScenario  +  " \ n" )  ;  System . out . println ( "Number of failed test cases :  "  +   ( testScenario . enabledTests (  )   -  successfulTestCases )  )  ;  failedScenarios +  +  ;   }   }  System . out . println ( " \ n \ nScenarios results :  \ nSuccessful :  "  +  successfulScenarios  +  " ,  Failed :  "  +  failedScenarios  +  " \ n \ n" )  ;   } 	Left over?
public boolean handleNotificationFor ( String ipAddress ,  String payload )   {  if  ( isNotificationRejectedFromIpAddress ( ipAddress )  )   {  logger . error ( " {  }  notification received from ip  '  {  }  '  which is not in domain  '  {  }  ' " ,  gatewayName (  )  ,  ipAddress ,  notificationDomain (  )  )  ;  return false ;   }  WorldpayNotification notification ;  try  {  logger . info ( "Parsing  {  }  notification" ,  gatewayName (  )  )  ;  logger . debug ( "Payload :   {  } " ,  payload )  ;  notification  =  XMLUnmarshaller . unmarshall ( payload ,  WorldpayNotification . class )  ;  logger . info ( "Parsed  {  }  notification :   {  } " ,  gatewayName (  )  ,  notification )  ;   }  catch  ( XMLUnmarshallerException e )   {  logger . error ( " {  }  notification parsing failed :   {  } " ,  gatewayName (  )  ,  e . toString (  )  )  ;  return true ;   }  if  ( isIgnored ( notification )  )   {  logger . info ( " {  }  notification  {  }  ignored" ,  gatewayName (  )  ,  notification )  ;  return true ;   }  if  ( isTransactionIdBlank ( notification )  )   {  logger . warn ( " {  }  notification  {  }  failed verification because it has no transaction ID" ,  gatewayName (  )  ,  notification )  ;  return true ;   }  Optional < ChargeEntity >  optionalChargeEntity  =  chargeDao . findByProviderAndTransactionId ( gatewayName (  )  ,  notification . getTransactionId (  )  )  ;  if  (  ! optionalChargeEntity . isPresent (  )  )   {  logger . info ( " {  }  notification  {  }  could not be evaluated  ( associated charge entity not found ) " ,  gatewayName (  )  ,  notification )  ;  return false ;   }  if  ( isCaptureNotification ( notification )  )   {  chargeNotificationProcessor . invoke ( notification . getTransactionId (  )  ,  optionalChargeEntity . get (  )  ,  CAPTURED ,  notification . getGatewayEventDate (  )  )  ;   }  else if  ( isRefundNotification ( notification )  )   {  refundNotificationProcessor . invoke ( getPaymentGatewayName (  )  ,  newRefundStatus ( notification )  ,  notification . getReference (  )  ,  notification . getTransactionId (  )  )  ;   }  else  {  logger . error ( " {  }  notification  {  }  unknown" ,  gatewayName (  )  ,  notification )  ;   }  return true ;   } 	have we seen this error before?
private PinotExpression handleCast ( CallExpression cast ,  Map < VariableReferenceExpression ,  Selection >  context )   {  if  ( cast . getArguments (  )  . size (  )   =  =  1 )   {  RowExpression input  =  cast . getArguments (  )  . get ( 0 )  ;  Type expectedType  =  cast . getType (  )  ;  if  ( isImplicitCast ( input . getType (  )  ,  expectedType )  )   {  return input . accept ( this ,  context )  ;   }  else  {  throw new PinotException ( PINOT _ UNSUPPORTED _ EXPRESSION ,  Optional . empty (  )  ,  "Non implicit casts not supported :  "  +  cast )  ;   }   }  throw new PinotException ( PINOT _ UNSUPPORTED _ EXPRESSION ,  Optional . empty (  )  ,  format ( "This type of CAST operator not supported .  Received :   % s" ,  cast )  )  ;   } 	else { is redundant
public void testPublishWithNullVideoTitle (  )   {  byte [  ]  testBytes  =   {  }  ;  String testString  =  "Test" ;  when ( urlService . inputStreamToByteArray ( inputStream )  )  . thenReturn ( testBytes )  ;  when ( facebookService . publishToFacebook ( any ( byte [  ]  . class )  ,  any ( String . class )  ,  any ( String . class )  ,  any ( String . class )  ,  any ( String . class )  )  )  . thenReturn ( testString )  ;  Response response  =  resource . publish ( key ,  "Test" ,  inputStream ,  contentDisposition ,  "photo" ,  "Test" ,  null )  ;  String result  =   ( String )  response . getEntity (  )  ;  assertEquals ( response . getStatusInfo (  )  ,  Response . Status . OK )  ;  assertEquals ( result ,  "Test" )  ;   } 	Same here with not needing the local variable.
public void testDeleteClientDeleteMutationPlan (  )  throws Exception  {  String tableName  =  generateUniqueName (  )  ;  String indexName  =  generateUniqueName (  )  ;  String tagValue  =  "customer - delete" ;  String delete  =  "DELETE FROM "  +  tableName  +  " WHERE v1  =   ' foo ' " ;  Properties props  =  PropertiesUtil . deepCopy ( TEST _ PROPERTIES )  ;  props . setProperty ( ConnectionQueryServices . SOURCE _ OPERATION _ ATTRIB ,  tagValue )  ;  createAndUpsertTable ( tableName ,  indexName ,  props )  ;  verifyDeletePlan ( delete ,  "ClientSelectDeleteMutationPlan" ,  props )  ;  executeDelete ( delete ,  props ,  1 )  ;  String startRowKeyForBaseTable  =  "1" ;  String startRowKeyForIndexTable  =  "foo" ;  checkTagPresentInDeleteMarker ( tableName ,  startRowKeyForBaseTable ,  true ,  tagValue )  ;  checkTagPresentInDeleteMarker ( indexName ,  startRowKeyForIndexTable ,  false ,  null )  ;   } 	rather than hardcode the string, can use the class name
public void updateDocument ( String entityType ,  int entityId ,  int documentId ,  String name ,  String desc ,  File file )   {  checkViewAttached (  )  ;  getMvpView (  )  . showProgressbar ( true )  ;  mSubscriptions . add ( mDataManagerDocument . updateDocument ( entityType ,  entityId ,  documentId ,  name ,  desc ,  getRequestFileBody ( file )  )   . observeOn ( AndroidSchedulers . mainThread (  )  )   . subscribeOn ( Schedulers . io (  )  )   . subscribe ( new Subscriber < DocumentRelatedResponse >  (  )   {   @ Override public void onCompleted (  )   {   }   @ Override public void onError ( Throwable e )   {  getMvpView (  )  . showProgressbar ( false )  ;  if  ( e instanceof HttpException )   {  try  {  String errorMessage  =   (  ( HttpException )  e )  . response (  )  . errorBody (  )   . string (  )  ;  getMvpView (  )  . showUpdationError ( MFErrorParser  . parseError ( errorMessage )   . getErrors (  )  . get ( 0 )  . getDefaultUserMessage (  )  )  ;   }  catch  ( Throwable throwable )   {  RxJavaPlugins . getInstance (  )  . getErrorHandler (  )  . handleError ( e )  ;   }   }  else  {  getMvpView (  )  . showUpdationError ( e . getLocalizedMessage (  )  )  ;   }   }   @ Override public void onNext ( DocumentRelatedResponse documentUpdateResponse )   {  getMvpView (  )  . showProgressbar ( false )  ;  getMvpView (  )  . showDocumentUpdatedSuccessfully ( documentUpdateResponse )  ;   }   }  )   )  ;   } 	@tarun0 why don't you use <LINK_0>
public String solveProblemForAll (  )   {  try  {  for  ( Task s  :  this . steps )   {  this . currentStep  =  s ;  serviceManager . getWorkflowService (  )  . setSolution ( getSolution (  )  )  ;  try  {  setCurrentStep ( serviceManager . getWorkflowService (  )  . solveProblem ( this . currentStep ,  this . solutionTask )  )  ;   }  catch  ( DataException e )   {  logger . error ( "Problem couldn ' t be solved :  "  +  e )  ;   }  saveStep (  )  ;   }  this . solution . setMessage ( "" )  ;  this . solutionTask  =  "" ;  AktuelleSchritteForm asf  =   ( AktuelleSchritteForm )  Helper . getManagedBeanValue ( " #  { AktuelleSchritteForm } " )  ;  return asf . filterAll (  )  ;   }  catch  ( AuthenticationException e )   {  Helper . setFehlerMeldung ( e . getMessage (  )  )  ;  return "" ;   }   } 	2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting exception object to string message?
public void onMessage ( String data )   {  try  {  Map < String ,  Object >  dataMap  =  objectMapper . readValue ( data ,  new TypeReference < Map < String ,  Object >  >  (  )   {  }  )  ;  String event  =   ( String )  dataMap . get ( "event" )  ;  if  ( "KEEP _ ALIVE" . equals ( event )  )   {  return ;   }  String type  =   ( String )  dataMap . get ( "type" )  ;  if  ( type  =  =  null )   {  log . debug ( "type missing so ignoring message .   {  } " ,  dataMap )  ;  return ;   }  if  ( type . equals ( "authenticated" )  )   {  log . info ( "WebSocket connection authenticated as  {  }   ( in  {  }  ) " ,  dataMap . get ( "userId" )  ,  dataMap . get ( "orgId" )  )  ;   }  else  {  String channelName  =   ( String )  dataMap . get ( "channel" )  ;  if  ( channelName  !  =  null )   {  TransportChannel channel  =  channels . get ( channelName )  ;  if  (  ( channel  !  =  null )   &  &   (  ! channel . isClosed (  )  )  )   {  StreamMessage message  =  new StreamMessage ( type ,  null ,  data )  ;  channel . offer ( message )  ;   }  else  {  log . debug ( "ignoring message .  channel not found  {  } " ,  channelName )  ;   }   }   }   }  catch  ( IOException ex )   {  log . error ( "failed to process messages" ,  ex )  ;   }   } 	rm
public NetworkScan requestNetworkScan ( int subId ,  NetworkScanRequest request ,  Executor executor ,  NetworkScanCallback callback ,  String callingPackage )   {  try  {  ITelephony telephony  =  getITelephony (  )  ;  if  ( telephony  !  =  null )   {  int scanId ;  synchronized  ( mScanInfo )   {  scanId  =  telephony . requestNetworkScan (  subId ,  request ,  mMessenger ,  new Binder (  )  ,  callingPackage )  ;  if  ( scanId  =  =  INVALID _ SCAN _ ID )   {  Rlog . e ( TAG ,  "Failed to initiate network scan" )  ;  return null ;   }  saveScanInfo ( scanId ,  request ,  executor ,  callback )  ;   }  return new NetworkScan ( scanId ,  subId )  ;   }   }  catch  ( RemoteException ex )   {  Rlog . e ( TAG ,  "requestNetworkScan RemoteException" ,  ex )  ;   }  catch  ( NullPointerException ex )   {  Rlog . e ( TAG ,  "requestNetworkScan NPE" ,  ex )  ;   }  return null ;   } 	now you can just do int scanId = telephony.requestNetworkScan(
private static ContinuousStream < Map < String ,  Object >  >  cepStatelessRulesTranslator (  final ContinuousStream < Map < String ,  Object >  >  inputMap ,  final List < CepStatelessRule >  cepStatelessRules )   {  final int ruleNum  =  cepStatelessRules . size (  )  ;  for  ( int i  =  0 ;  i  <  ruleNum ;  i +  +  )   {  final CepStatelessRule rule  =  cepStatelessRules . get ( i )  ;  final CepAction action  =  rule . getAction (  )  ;  final CepSink sink  =  action . getCepSink (  )  ;  ContinuousStream < Map < String ,  Object >  >  temp  =  inputMap ;  switch  ( action . getCepActionType (  )  )   {  case TEXT _ WRITE :   {  switch  ( sink . getCepSinkType (  )  )   {  case TEXT _ SOCKET _ OUTPUT :   {  temp  =  cepConditionTranslator ( temp ,  rule . getCondition (  )  )  ;  final List < Object >  params  =  action . getParams (  )  ;  final String separator  =  sink . getSeparator (  )  ;  temp . map ( new CepMapToStringFunction ( params ,  separator )  )   . textSocketOutput (  ( String ) sink . getSinkConfigs (  )  . get ( "SOCKET _ SINK _ ADDRESS" )  ,   ( int ) sink . getSinkConfigs (  )  . get ( "SOCKET _ SINK _ PORT" )  )  ;  break ;   }  case MQTT _ OUTPUT :   {  temp  =  cepConditionTranslator ( temp ,  rule . getCondition (  )  )  ;  final List < Object >  params  =  action . getParams (  )  ;  final String separator  =  sink . getSeparator (  )  ;  temp . map ( new CepMapToStringFunction ( params ,  separator )  )   . map ( value  -  >  new MqttMessage ( value . getBytes (  )  )  )   . mqttOutput (  ( String )  sink . getSinkConfigs (  )  . get ( "MQTT _ SINK _ BROKER _ URI" )  ,   ( String )  sink . getSinkConfigs (  )  . get ( "MQTT _ SINK _ TOPIC" )  )  ;  break ;   }  default :  throw new IllegalStateException ( "Wrong sink type ! " )  ;   }  break ;   }  default :  continue ;   }   }  return inputMap ;   } 	final
public static void createQueue ( String projectId ,  String locationId ,  String queueId )  throws Exception  {  try  ( CloudTasksClient client  =  CloudTasksClient . create (  )  )   {  String parent  =  LocationName . of ( projectId ,  locationId )  . toString (  )  ;  String queuePath  =  QueueName . of ( projectId ,  locationId ,  queueId )  . toString (  )  ;  Queue queue  =  client . createQueue ( parent ,  Queue . newBuilder (  )  . setName ( queuePath )  . build (  )  )  ;  System . out . println ( "Queue created :  "  +  queue . getName (  )  )  ;   }   } 	Ideally we are as specific as possible with exceptions based on what developers might see.
public void createPartControl ( Composite parent )   {  super . createPartControl ( parent )  ;  pinPropertySheetAction . addPropertyChangeListener ( new IPropertyChangeListener (  )  {   @ Override public void propertyChange ( PropertyChangeEvent event )   {  if  ( IAction . CHECKED . equals ( event . getProperty (  )  )  )   {  updateContentDescription (  )  ;   }   }   }  )  ;  IMenuManager menuManager  =  getViewSite (  )  . getActionBars (  )   . getMenuManager (  )  ;  menuManager . add ( new Separator ( IWorkbenchActionConstants . MB _ ADDITIONS )  )  ;  menuManager . add ( pinPropertySheetAction )  ;  IToolBarManager toolBarManager  =  getViewSite (  )  . getActionBars (  )   . getToolBarManager (  )  ;  menuManager . add ( new Separator ( IWorkbenchActionConstants . MB _ ADDITIONS )  )  ;  toolBarManager . add ( pinPropertySheetAction )  ;  SaveablesList saveables  =   ( SaveablesList )  getSite (  )  . getService ( ISaveablesLifecycleListener . class )  ;  if  ( saveables  !  =  null )   {  saveables . addModelLifecycleListener ( saveablesTracker )  ;   }  getSite (  )  . getPage (  )  . getWorkbenchWindow (  )  . getWorkbench (  )  . getHelpSystem (  )   . setHelp ( getPageBook (  )  ,  IPropertiesHelpContextIds . PROPERTY _ SHEET _ VIEW )  ;   } 	check for non null?
private SimRobot (  )   {  super (  )  ;  nodeList . add ( new FullSimRunner ( "Full Sim Toolbox" ,  new LocTuple ( 40 . 441670 ,   - 79 . 9416362 )  )  )  ;  RobobuggyJFrame mainWindow  =  new RobobuggyJFrame ( "MainWindow" ,  1 . 0 ,  1 . 0 )  ;  Gui . getInstance (  )  . addWindow ( mainWindow )  ;  RobobuggyGUITabs tabs  =  new RobobuggyGUITabs (  )  ;  mainWindow . addComponent ( tabs ,  0 . 0 ,  0 . 0 ,  1 . 0 ,  1 . 0 )  ;  tabs . addTab ( new MainGuiWindow (  )  ,  "Home" )  ;  tabs . add ( new PathPanel (  )  ,  "Path Visualizer" )  ;  tabs . addTab ( new ConfigurationPanel (  )  ,  "Configuration" )  ;   } 	More magic numbers; use variables for longitude/latitude?
public void testFilteredContent _ 2 (  )  throws Throwable  {  UserDetails user  =  new OAuth2TestUtils . UserBuilder ( "jack _ bauer" ,  "0x24" )   . withAuthorization ( Group . FREE _ GROUP _ NAME ,  "tempRole" ,  Permission . BACKOFFICE )  . build (  )  ;  String accessToken  =  mockOAuthInterceptor ( user )  ;  ResultActions result  =  mockMvc  . perform ( get ( " / plugins / cms / contents" )   . param ( "status" ,  IContentService . STATUS _ ONLINE )   . param ( "sort" ,  IContentManager . CONTENT _ CREATION _ DATE _ FILTER _ KEY )   . param ( "direction" ,  FieldSearchFilter . DESC _ ORDER )   . param ( "filters [ 0 ]  . attribute" ,  "id" )   . param ( "filters [ 0 ]  . value" ,  "EVN194" )   . sessionAttr ( "user" ,  user )   . header ( "Authorization" ,  "Bearer "  +  accessToken )  )  ;  String bodyResult  =  result . andReturn (  )  . getResponse (  )  . getContentAsString (  )  ;  result . andExpect ( status (  )  . isOk (  )  )  ;  String expectedContentId  =  "EVN194" ;  int payloadSize  =  JsonPath . read ( bodyResult ,  " $  . payload . size (  ) " )  ;  String extractedId  =  JsonPath . read ( bodyResult ,  " $  . payload [ "  +  0  +  " ]  . id" )  ;  Assert . assertEquals ( expectedContentId ,  extractedId )  ;   } 	Code style
public void deleteCacheStorageTest (  )   {  CacheStorageImpl cache  =  new CacheStorageImpl (  )  ;  final Map < Identifier ,  OperatorState >  queryState1 =  new HashMap <  >  (  )  ;  queryState1 . put ( oid1 ,  value1 )  ;  cache . create ( qid1 ,  queryState1 )  ;  Assert . assertEquals ( value1 ,  cache . read ( qid1 ,  oid1 )  )  ;  Assert . assertEquals ( true ,  cache . delete ( qid1 )  )  ;  Assert . assertSame ( null ,  cache . read ( qid1 ,  oid1 )  )  ;  Assert . assertEquals ( false ,  cache . delete ( qid1 )  )  ;  Assert . assertEquals ( false ,  cache . delete ( qid2 )  )  ;   } 	1 =
public void shouldDeleteNetworkToPublicRouterNoDeleted (  )  throws OpenStackException ,  InfrastructureException  {  String response  =  " {  \ "ports \ " :   [   {  \ "status \ " :   \ "ACTIVE \ " ,  \ "name \ " :   \ " \ " ,   \ "admin _ state _ up \ " :  true ,  "  +  " \ "network _ id \ " :   \ "ID \ " ,   \ "tenant _ id \ " :   \ "08bed031f6c54c9d9b35b42aa06b51c0 \ " , "  +  " \ "device _ owner \ " :   \ "compute : None \ " ,   \ "binding : capabilities \ " :   {  \ "port _ filter \ " :  true }  ,  "  +  " \ "fixed _ ips \ " :   [   {  \ "subnet _ id \ " :   \ "ID \ " ,   \ "ip _ address \ " :   \ "172 . 31 . 0 . 3 \ " }  ]  , "  +  " \ "id \ " :   \ "07fd27d2 - 9ce1 - 48f3 - be83 - c7d2b7041a1a \ " ,   \ "security _ groups \ " :   [  ]  ,   \ "device _ id \ " : "  +  "  \ "dhcpfa3e6aae - 2140 - 5176 - 877a - 2f67684a3165 - 6a609412 - 3f04 - 485c - b269 - b1a9b9ecb6bf \ ""  +  " }  ]  } " ;  when ( openStackUtil . listPorts ( any ( PaasManagerUser . class )  ,  anyString (  )  )  )  . thenReturn ( response )  ;  NetworkInstance net  =  new NetworkInstance ( "router" ,  "vdc" ,  "region" )  ;  SubNetworkInstance subNet  =  new SubNetworkInstance ( "dd" ,  "vdc" ,  "region" ,  "ID" )  ;  subNet . setIdSubNet ( "ID" )  ;  net . addSubNet ( subNet )  ;  when ( openStackUtil . deleteInterfaceToPublicRouter ( any ( PaasManagerUser . class )  ,  any ( NetworkInstance . class )  ,  anyString (  )  )  )  . thenReturn ( response )  ;  openStackNetworkImpl . deleteNetworkToPublicRouter ( claudiaData ,  net ,  REGION )  ;   } 	line > 120 chars
public void requestSpace ( long sessionId ,  long blockId ,  long additionalBytes )  throws BlockDoesNotExistException ,  WorkerOutOfSpaceException ,  IOException  {  LOG . debug ( "requestSpace :  sessionId =  {  }  ,  blockId =  {  }  ,  additionalBytes =  {  } " ,  sessionId ,  blockId ,  additionalBytes )  ;  try  ( LockResource r  =  new LockResource ( mMetadataWriteLock )  )   {  TempBlockMeta tempBlockMeta  =  mMetaManager . getTempBlockMeta ( blockId )  ;  StorageDirView allocationDir  =  allocateSpace ( sessionId ,  AllocateOptions . forRequestSpace ( additionalBytes ,  tempBlockMeta . getBlockLocation (  )  )  )  ;  if  ( allocationDir  =  =  null )   {  throw new WorkerOutOfSpaceException ( String . format (  "Can ' t reserve more space for block :   % d under session :   % d . " ,  blockId ,  sessionId )  )  ;   }  if  (  ! allocationDir . toBlockStoreLocation (  )  . equals ( tempBlockMeta . getBlockLocation (  )  )  )   {  throw new RuntimeException ( "Allocation error :  location enforcement failed" )  ;   }  try  {  mMetaManager . resizeTempBlockMeta (  tempBlockMeta ,  tempBlockMeta . getBlockSize (  )   +  additionalBytes )  ;   }  catch  ( InvalidWorkerStateException e )   {  throw Throwables . propagate ( e )  ;   }   }   } 	Do we ever expect this to happen?
protected void processMultiValuedEAttribute ( EAttribute eAttribute ,  SIRIUS processedDescription ,  SIRIUS currentDescription ,  TransformationCache cache )   {  Object processedValue  =  processedDescription . eGet ( eAttribute )  ;  Object currentValue  =  currentDescription . eGet ( eAttribute )  ;  if  ( currentValue instanceof Iterable <  ?  >   &  &  processedValue instanceof Iterable <  ?  >  )   {  List < Object >  newValue  =  new ArrayList <  >  (  )  ;  Iterable <  ?  >  currentIterable  =   ( Iterable <  ?  >  )  currentValue ;  Iterable <  ?  >  processedIterable  =   ( Iterable <  ?  >  )  processedValue ;  for  ( Object object  :  currentIterable )   {  newValue . add ( object )  ;   }  for  ( Object object  :  processedIterable )   {  newValue . add ( object )  ;   }  processedDescription . eSet ( eAttribute ,  newValue )  ;   }   } 	java8-isation [forEach][filter]
public static UUID makeUUID ( byte bytes [  ]  )   {  long high  =  0 ;  long low  =  0 ;  if  ( bytes . length  <  Utils . UUID _ LEN )   {  throw new IllegalArgumentException ( "UUID byte field must be 16 bytes long" )  ;   }  final int bitsPerByte  =  Byte . SIZE ;  int bitMask  =   ( 1  <  <  bitsPerByte )   -  1 ;  for  ( int i  =  0 ;  i  <  bitsPerByte ;  i +  +  )   {  low  =   ( low  <  <  bitsPerByte )   |   ( bytes [ i  +  bitsPerByte ]   &  bitMask )  ;  high  =   ( high  <  <  bitsPerByte )   |   ( bytes [ i ]   &  bitMask )  ;   }  UUID uuid  =  new UUID ( high ,  low )  ;  return uuid ;   } 	Causes ctf tests to fail
public void verify _ fallback _ in _ download _ presigned _ urls (  )  throws Exception  {  AmazonServiceException firstException  =  new AmazonServiceException ( "Didn ' t find Object Id in bucket" )  ;  firstException . setStatusCode ( HttpStatus . NOT _ FOUND . value (  )  )  ;  int bucketPoolSize  =  32 ;  int bucketKeySize  =  2 ;  ReflectionTestUtils . setField ( service ,  "bucketPoolSize" ,  bucketPoolSize )  ;  ReflectionTestUtils . setField ( service ,  "bucketKeySize" ,  bucketKeySize )  ;  ObjectURLGenerator urlGen  =  new AmazonURLGenerator (  )  ;  ReflectionTestUtils . setField ( urlGen ,  "s3Client" ,  ObjectDownloadServiceStubFactory . createS3ClientForRadosGW ( endpointUrl )  )  ;  ReflectionTestUtils . setField ( service ,  "urlGenerator" ,  urlGen )  ;  when ( s3Client . getObject ( Mockito . any (  )  )  )  . thenThrow ( firstException )  ;  List < Part >  parts  =  ObjectDownloadServiceStubFactory . createParts ( 5 )  ;  ObjectSpecification os  =  ObjectDownloadServiceStubFactory . createObjectSpecification ( objectId ,  ObjectKeys . getObjectKey ( dataDir ,  objectId )  ,  104857600 )  ;  os . setParts ( parts )  ;  os . setRelocated ( true )  ;  ObjectDownloadService sut  =  spy ( service )  ;  doReturn ( os )  . when ( sut )  . getSpecification ( objectId )  ;  val objSpec  =  sut . download ( objectId ,  0 ,  104857600 ,  false )  ;  Part p  =  objSpec . getParts (  )  . get ( 0 )  ;  URL url  =  new URL ( p . getUrl (  )  )  ;  String path  =  url . getPath (  )  ;  if  ( path . startsWith ( " / " )  )   {  path  =  path . substring ( 1 ,  path . length (  )   -  1 )  ;   }  String bucket  =  Splitter . on (  '  /  '  )  . trimResults (  )  . omitEmptyStrings (  )  . split ( path )  . iterator (  )  . next (  )  ;  assertEquals ( dataBucketName ,  bucket )  ;  System . out . println (  )  ;   } 	A lot more vals please
public SAMFileSpan removeContentsAfter ( final SAMFileSpan fileSpan )   {  if ( fileSpan  =  =  null )  return clone (  )  ;  if (  !  ( fileSpan instanceof BAMFileSpan )  )  throw new SAMException ( "Unable to compare " )  ;  final BAMFileSpan bamFileSpan  =   ( BAMFileSpan ) fileSpan ;  if ( bamFileSpan . isEmpty (  )  )  return clone (  )  ;  validateSorted (  )  ;  final BAMFileSpan trimmedChunkList  =  new BAMFileSpan (  )  ;  final long chunkEnd  =  bamFileSpan . chunks . get ( 0 )  . getChunkEnd (  )  ;  for ( final Chunk chunkToTrim :  chunks )   {  if ( chunkToTrim . getChunkStart (  )   <  chunkEnd )   {  if ( chunkToTrim . getChunkEnd (  )   <  =  chunkEnd )   {  trimmedChunkList . add ( chunkToTrim . clone (  )  )  ;   }  else  {  trimmedChunkList . add ( new Chunk ( chunkToTrim . getChunkStart (  )  , chunkEnd )  )  ;   }   }   }  return trimmedChunkList ;   } 	make this final I think
public void handleSetDeviceLifecycleStatusByChannelResponse ( final DeviceMessageMetadata deviceMessageMetadata ,  final ResponseMessageResultType result ,  final OsgpException osgpException ,  final SetDeviceLifecycleStatusByChannelResponseDto responseDto )   {  LOGGER . info ( "handleSetDeviceLifecycleStatusByChannelResponse for MessageType :   {  } " ,  deviceMessageMetadata . getMessageType (  )  )  ;  this . setDeviceLifecycleStatusByChannel ( responseDto )  ;  final String gatewayDeviceIdentification  =  deviceMessageMetadata . getDeviceIdentification (  )  ;  final SetDeviceLifecycleStatusByChannelResponseData responseData  =  this . managementMapper . map ( responseDto ,  SetDeviceLifecycleStatusByChannelResponseData . class )  ;  this . webServiceResponseMessageSender . send (  ResponseMessage . newResponseMessageBuilder (  )   . withCorrelationUid ( deviceMessageMetadata . getCorrelationUid (  )  )   . withOrganisationIdentification ( deviceMessageMetadata . getOrganisationIdentification (  )  )   . withDeviceIdentification ( gatewayDeviceIdentification )  . withResult ( result )   . withOsgpException ( osgpException )  . withDataObject ( responseData )   . withMessagePriority ( deviceMessageMetadata . getMessagePriority (  )  )  . build (  )  ,  deviceMessageMetadata . getMessageType (  )  )  ;   } 	Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
protected void onMessageReceived ( WorkspaceStatusEvent statusEvent )   {  final String workspaceId  =  statusEvent . getWorkspaceId (  )  ;  switch  ( statusEvent . getEventType (  )  )   {  case STARTING :  onWorkspaceStarting ( workspaceId )  ;  break ;  case RUNNING :  onWorkspaceStarted ( workspaceId )  ;  break ;  case ERROR :  notificationManager . notify ( locale . workspaceStartFailed (  )  ,  FAIL ,  FLOAT _ MODE )  ;  loader . setError ( LoaderPresenter . Phase . STARTING _ WORKSPACE _ RUNTIME )  ;  final String workspaceName  =  workspace . getConfig (  )  . getName (  )  ;  final String error  =  statusEvent . getError (  )  ;  workspaceServiceClient . getWorkspaces ( SKIP _ COUNT ,  MAX _ COUNT )  . then ( showErrorDialog ( workspaceName ,  error )  )  ;  eventBus . fireEvent ( new WorkspaceStoppedEvent ( workspace )  )  ;  break ;  case STOPPING :  loader . show ( LoaderPresenter . Phase . STOPPING _ WORKSPACE )  ;  break ;  case STOPPED :  loader . setSuccess ( LoaderPresenter . Phase . STOPPING _ WORKSPACE )  ;  try  {  eventBus . fireEvent ( new WorkspaceStoppedEvent ( workspace )  )  ;   }  catch  ( Exception e )   {  Log . error ( WorkspaceEventsHandler . class ,  e . getMessage (  )  ,  e )  ;   }  startWorkspaceNotification . show ( statusEvent . getWorkspaceId (  )  )  ;  break ;  case SNAPSHOT _ CREATING :  loader . show ( LoaderPresenter . Phase . CREATING _ WORKSPACE _ SNAPSHOT )  ;  break ;  case SNAPSHOT _ CREATED :  loader . setSuccess ( LoaderPresenter . Phase . CREATING _ WORKSPACE _ SNAPSHOT )  ;  snapshotCreator . successfullyCreated (  )  ;  break ;  case SNAPSHOT _ CREATION _ ERROR :  loader . setError ( LoaderPresenter . Phase . CREATING _ WORKSPACE _ SNAPSHOT )  ;  snapshotCreator . creationError ( "Snapshot creation error :  "  +  statusEvent . getError (  )  )  ;  break ;   }   } 	explain this
